/*
  Modified copy of MDBug install.sql
  For copyright and license notice of install_sql function contents, see beginning of ocelotgui.cpp.
  This file was made by downloading MDBug's install.sql and editing. Most of the editing was done thus:
  (1) replace all \ with \\ (2) replace all " with \" (3) replace all \n with " \n" (4) replace all //" with
  ";\n\nif (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;\nstrcpy(x,
  Pass &mysql[MYSQL_MAIN_CONNECTION].
*/

/*
  Six lines have been commented out in xxxmdbug.privilege_checks(). This is only a temporary solution for a race.
  One line has been commented out in xxxmdbug.setup_internal(). The job is now being done in ocelotgui.cpp.
  Three lines have been commented out because "REPAIR TABLE mysql.proc" is now not needed (I hope).
  Five lines are changed in xxxmdbug.dbms_pipe_receive so that there is one critical SET statement rather thn three (less race).
  In debuggee_wait_loop "PREPARE xxxmdbug_stmt FROM @xxxmdbug_what_to_call;" was replaced with "LEAVE x;".
  In insert_into_statements two lines were changed because a statement within an ELSE wasn't generated.
*/

/*
  2016-06-12 Several lines have been added in xxxmdbug.generate().
  This was a fix for github bug#1. If hostname=% is must be inside backticks.
*/

/*
  2016-06-13 A begin...end block has been added in xxxmdbug.generate_icc_process_user_command_set_server_variables
  and generate_icc_process_user_command_set_server_variables.
  This was a fix for the MySQL 5.7 switch to performance_schema use.
*/

/*
  2018-05-25 Functions must be called deterministic now, due to a change
  in MySQL 8.0. Routines referencing information_schema.server_variables
  must be removed (there are substitutes in the C code), due to a change
  in MySQL 8.0. All string comparisons must have an explicit collate
  clause, due to a change in MySQL 8.0.
*/

/* #include "install_sql.h" relies on "#if (OCELOT_MYSQL_DEBUGGER == 1)" which is true by default. */
/* Todo: This file's routines are unneccessary if NEW_SETUP == 1 but I haven't gotten around to removing all references to them. */

#ifndef INSTALL_SQL_CPP

/* todo: ensure this doesn't waste space by including things in ocelotgui.h that are unnecessary */
//TEST!! #include "ocelotgui.h"
//#include "ui_ocelotgui.h"

int MainWindow::debug_mdbug_install_sql(MYSQL *mysql, char *x)
{
strcpy(x,
"SET @xxxmdbug_copyright = '" 
"" 
"This file is part of MDBug." 
"" 
"(c) Copyright 2012 Hewlett-Packard Development Company, L.P." 
"" 
"This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License" 
"as published by the Free Software Foundation; version 2 of the License." 
"" 
"This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty" 
"of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details." 
"" 
"You should have received a copy of the GNU General Public License along with this program; if not, see" 
"<http://www.gnu.org/licenses>." 
"" 
"Linking MDBug statically or dynamically with other modules is making a combined work based on MDBug. Thus, the terms and" 
"conditions of the GNU General Public License cover the whole combination." 
"" 
"In addition, as a special exception, the copyright holders of MDBug give you permission to combine MDBug with free" 
"software programs or libraries that are released under the GNU LGPL and with code included in the standard release" 
"of Eclipse under the Eclipse Public License version 1.0 (or modified versions of such code, with unchanged license)." 
"You may copy and distribute such a system following the terms of the GNU GPL for MDBug and the licenses of the other" 
"code concerned, provided that you include the source code of that other code when and as the GNU GPL requires" 
"distribution of source code." 
"" 
"Note that people who make modified versions of MDBug are not obligated to grant this special exception for their" 
"modified versions; it is their choice whether to do so. The GNU General Public License gives permission to release a" 
"modified version without this exception; this exception also makes it possible to release a modified version which" 
"carries forward this exception." 
"'");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* THE MDBUG CORE DEBUGGER" 
"   Version 0.3 Alpha" 
"   Last Revision 2012-09-11" 
"   Written by Peter Gulutzan */" 
"" 
"/* If install has been done before, then get rid of all old routines or tables" 
"   which we will be replacing during this install. But do not get rid of" 
"   setup_log, or any surrogate routines which happen to be in xxxmdbug," 
"   such as 'xxxmdbugxxxPicc_core' procedures." 
"   That is why we cannot do the easy thing, DROP DATABASE IF EXISTS xxxmdbug. */" 
"" 
"SET @xxxmdbug_saved_sql_mode=@@sql_mode");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"SET SESSION sql_mode=''");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
//strcpy(x,
//""
//"REPAIR TABLE mysql.proc");
//
//if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
//MYSQL_RES *debug_res= NULL;                          /* added because REPAIR returns a result set */
//debug_res= mysql_store_result(mysql);
//if (debug_res != NULL) mysql_free_result(debug_res);

strcpy(x,
""
"CREATE DATABASE IF NOT EXISTS xxxmdbug");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP TABLE IF EXISTS xxxmdbug.copyright");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP TABLE IF EXISTS xxxmdbug.readme");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.add_delimiters");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.become_debuggee_connection");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.breakpoint_delete");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.check_surrogate_routine");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.checks_and_warnings");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.clear_warnings");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.command");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.command_i_status");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.command_r_breakpoints");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.command_r_call_stack");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.command_r_prepared_statements");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.command_r_server_variables");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.command_r_statements_executed");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.command_r_user_variables");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.command_r_variables");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.compare");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.create_breakpoints_table");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.create_prepared_statements_table");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.create_routines_table");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.create_server_variables_table");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.create_setup_log_table");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.create_statements_executed_table");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.create_statements_table");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.create_tmp_user_variables_table");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.create_tokens_table");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.create_user_variables_table");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.create_variables_table");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.dbms_pipe_clean");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.dbms_pipe_receive");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.dbms_pipe_receive_with_timeout");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.dbms_pipe_send");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.debuggee_get_surrogate_name");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.debuggee_stop");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.debuggee_wait_loop");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.debugger_wait_and_receive");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.delete_from_linked_list");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.delete_from_prepared_statements");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.determine_what_variables_are_in_scope");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.fixed_breakpoints_clear");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.fixed_delete");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.fixed_insert");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.fixed_prepared_statements_clear");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.fixed_routines_clear");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.fixed_select");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.fixed_statements_executed_clear");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.fixed_update");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.fixed_variables_clear");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.generate");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.generate_ender");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.generate_icc_core");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.generate_icc_process_user_command_r_server_variables");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.generate_icc_process_user_command_set_server_variables");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.generate_label");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.generate_routine_entry_parameter");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.generate_starter");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.generate_statement_text");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.generate_statement_text_as_is");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.get_current_schema_identifier_and_routine_identifier");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.get_from_linked_list");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.get_setup_group_name");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.get_token_identifier_type");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.get_token_type");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_breakpoint_check");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_change_statement_status");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_copy_table_row_to_variable");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_copy_variable_to_table_row");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_core");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_end");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_get_user_command");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_process_user_command");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_process_user_command_attach");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_process_user_command_break");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_process_user_command_execute");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_process_user_command_r_breakpoints");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_process_user_command_r_call_stack");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_process_user_command_r_prepared_statements");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_process_user_command_r_server_variables");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_process_user_command_set_server_variables");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_process_user_command_r_statements_executed");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_process_user_command_r_user_variables");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_process_user_command_r_variables");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_process_user_command_set");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_process_user_command_step_or_next");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_send_statement_status");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.icc_start");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.initialize_variables");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.insert_into_linked_list");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.insert_into_prepared_statements");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.insert_into_routines");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.insert_into_statements");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.insert_into_tokens");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.insert_into_tokens_linked_list");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.insert_into_variables_declared_variables");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.insert_into_variables_parameters");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.insert_into_variables_user_variables");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.install_check");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP FUNCTION IF EXISTS xxxmdbug.isnumeric");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP FUNCTION IF EXISTS xxxmdbug.is_debuggee_and_is_attached");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.multiple_name_parser");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.mysql_proc_insert");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.mysql_proc_insert_caller");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.overflow_check");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.preparer");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.prepare_while_ansi_quotes_yes");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.prepare_while_ansi_quotes_no");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.privilege_checks");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.reset");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.retype");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.routine_entry");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.routine_exit");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.setup");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.setup_internal");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.setup_switches");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.setxxxmdbug_channel");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.set_default_schema");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.statement_change");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.syntax_check_for_breakpoint");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.syntax_check_for_debug");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.syntax_check_for_set");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.update_linked_list");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.update_statements_executed");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.uvar");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.view_and_trigger_and_event_check");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"DROP PROCEDURE IF EXISTS xxxmdbug.walkthrough");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"SET @xxxmdbug_start_timestamp = CURRENT_TIMESTAMP");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE TABLE xxxmdbug.copyright (copyright TEXT CHARACTER SET utf8)");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"INSERT INTO xxxmdbug.copyright VALUES (@xxxmdbug_copyright)");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/*" 
"DBMS_PIPE" 
"=========" 
"" 
"The dbms_pipe routines enable passing messages between connections." 
"dbms_pipe_send(prefix,string) -- \"sends\" a message in string parameter" 
"dbms_pipe_receive(prefix,erase,string) -- \"receives a message in string parameter" 
"Requires super privilege." 
"Todo: need something for \"clear pipe x\" or \"clear all pipes\" or \"clear pipes which have no connections\"" 
"" 
"*/" 
"" 
"CREATE PROCEDURE xxxmdbug.dbms_pipe_send (prefix VARCHAR(66) CHARACTER SET utf8," 
"                                                     string MEDIUMTEXT CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v CHAR(1) CHARACTER SET utf8;" 
"  /* If @@init_connect is null, change it to empty string -- else all sending will fail." 
"     The simpler-looking check \"IF @@init_connect IS NULL THEN SET global init_connect = ''; END IF;\"" 
"     is no good, it seems that \"is null\" can be true even when @@init_connect is not null. */" 
"  SET v = LEFT(@@init_connect,1);" 
"  IF v IS NULL THEN SET global init_connect = ''; END IF;" 
"  CALL xxxmdbug.dbms_pipe_clean(string);" 
"  SET global init_connect = CONCAT(@@init_connect,'/*',prefix,string,'*/');" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Receive." 
"   Ignore messages which don't start with prefix." 
"   Erase received messages if erase = 1." 
"   Return message value in string." 
"   This is changed from the original MDBug routine -- putting multiple SET statements into one big SET statement to avoid races."
"   Todo: Sometimes we can receive a blank message. Check that you're checking for that (by looking if p_message_start <> 0) */" 
"CREATE PROCEDURE xxxmdbug.dbms_pipe_receive (prefix VARCHAR(66) CHARACTER SET utf8," 
"                                                        erase INT," 
"                                                        OUT string MEDIUMTEXT CHARACTER SET utf8," 
"                                                        OUT p_message_start INT)" 
"BEGIN" 
"  DECLARE v_message_start INT;" 
"  DECLARE v_message MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_star_plus_slash_plus_prefix VARCHAR(66)  CHARACTER SET utf8;" 
"  SET v_star_plus_slash_plus_prefix=CONCAT('/*',prefix);"
"  SET v_message_start = INSTR(@@init_connect,v_star_plus_slash_plus_prefix);"
"  IF v_message_start <> 0 THEN"
"    IF erase = 0 THEN"
"      SET v_message = SUBSTRING(@@init_connect FROM INSTR(@@init_connect,v_star_plus_slash_plus_prefix)+LENGTH('/*') FOR (LOCATE('*/',@@init_connect,INSTR(@@init_connect,v_star_plus_slash_plus_prefix)) - (INSTR(@@init_connect,v_star_plus_slash_plus_prefix)+LENGTH('/*'))));"
"      END IF;"
"    IF erase = 1 THEN"
"      SET v_message = SUBSTRING(@@init_connect FROM INSTR(@@init_connect,v_star_plus_slash_plus_prefix)+LENGTH('/*') FOR (LOCATE('*/',@@init_connect,INSTR(@@init_connect,v_star_plus_slash_plus_prefix)) - (INSTR(@@init_connect,v_star_plus_slash_plus_prefix)+LENGTH('/*')))),"
"          global init_connect = CONCAT(LEFT(@@init_connect,INSTR(@@init_connect,v_star_plus_slash_plus_prefix)-1),"
"                                       RIGHT(@@init_connect,LENGTH(@@init_connect)-(LOCATE('*/',@@init_connect,INSTR(@@init_connect,v_star_plus_slash_plus_prefix))+1)));"
"      END IF;"
"    SET v_message = RIGHT(v_message,LENGTH(v_message)-LENGTH(prefix));"
"    END IF;"
"  SET string = v_message;" 
"  SET string = REPLACE(string,'*([xxxmdbug)','*'); /* We got rid of *s and /s to avoid possible /* comments. Now put them back. */" 
"  SET string = REPLACE(string,'/([xxxmdbug)','/');" 
"  SET p_message_start = v_message_start;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Eliminate any occurrences of '*' or '/' in string -- anything that might cause comment parts to be in init_connect is dangerous." 
"   Todo: Oh, and do some trivial encryption while you're at it." 
"   Maybe sending everything as hex(xor(xxxmdbug_channel)) is a solution. */" 
"CREATE PROCEDURE xxxmdbug.dbms_pipe_clean (INOUT string MEDIUMTEXT CHARACTER SET utf8)" 
"BEGIN" 
"  SET string = REPLACE(string,'*','*([xxxmdbug)');" 
"  SET string = REPLACE(string,'/','/([xxxmdbug)');" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Getting VARCHAR values to debugger from debuggee.." 
"   The affected items are variables.value, variables.old_value, server_variables.value, server_variables.old_value," 
"   user_variables.value, user_variables.old_value, prepared_statements.statement_text, breakpoints.condition_value," 
"   information_status.last_command, information_status.last_command_result." 
"   These values might contain 's (single quotes) which will confuse the tokenizer." 
"   So debuggee hexes them before passing and debugger unhexes them after receiving." 
"   For example in icc_send_statement_status, send HEX(@xxxmdbug_status_last_command), and in command_i_status," 
"   insert UNHEX(v_last_command) and v_last_command now has size = 66*2." 
"   Todo: since the result of UNHEX is binary, some variables don't need to be UTF8." 
"   Todo: pass source data type and character set too. */" 
"" 
"/* Called by debugger." 
"   For everything except 'info', send message from debugger to debuggee." 
"   So far we only send C message." 
"   Todo: 'd' for delay n seconds, thus allowing a nicer demo */" 
"CREATE PROCEDURE xxxmdbug.command (xxxmdbug_channel VARCHAR(66) CHARACTER SET utf8, message VARCHAR(8192) CHARACTER SET utf8)" 
"command:" 
"BEGIN" 
"  DECLARE v_length_of_first_token INT;" 
"  DECLARE v_value_of_first_token VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_value_of_second_token VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_token_count INT;" 
"  DECLARE v_value VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_prefix VARCHAR(128)  CHARACTER SET utf8; /* sizeof('xxxmdbug_' + xxxmdbug_channel) + 'C ' + room to grow */" 
"  DECLARE v_error_message VARCHAR(128) CHARACTER SET utf8;" 
"" 
"  CALL xxxmdbug.initialize_variables();" 
"  CALL xxxmdbug.privilege_checks();" 
"" 
"  CALL xxxmdbug.setxxxmdbug_channel(xxxmdbug_channel); /* sets @xxxmdbug_channel */" 
"" 
"  CALL xxxmdbug.create_tokens_table();" 
"  CALL xxxmdbug.insert_into_tokens('','',message,0);" 
"  SET v_token_count = (SELECT COUNT(*) FROM xxxmdbug.tokens);" 
"  IF v_token_count = 0 THEN SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text='no arguments'; END IF;" 
"  SET v_value_of_first_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = 1);" 
"  SET v_value_of_second_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = 2);" 
"  SET v_length_of_first_token = LENGTH(v_value_of_first_token);" 
"syntax_check: BEGIN" 
"    IF v_value_of_first_token = LEFT('attach',v_length_of_first_token) THEN" 
"      IF v_token_count>1 THEN SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text='(attach) too many arguments'; END IF;" 
"      SET v_value_of_first_token = 'attach';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"    IF v_value_of_first_token = LEFT('breakpoint',v_length_of_first_token) THEN" 
"      CALL xxxmdbug.syntax_check_for_breakpoint();" 
"      SET v_value_of_first_token = 'breakpoint';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"    IF v_value_of_first_token  = 'c' THEN"
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'ambiguous command, could be an abbreviation for either clear or continue';" 
"      END IF;" 
"    IF v_value_of_first_token  = LEFT('clear',v_length_of_first_token) THEN"
"      CALL xxxmdbug.syntax_check_for_breakpoint();" 
"      SET v_value_of_first_token = 'clear';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"    IF v_value_of_first_token  = LEFT('continue',v_length_of_first_token) THEN"
"      IF v_token_count>1 THEN SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text='(continue) too many arguments'; END IF;" 
"      SET v_value_of_first_token = 'continue';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"    IF v_value_of_first_token  = 'd' OR v_value_of_first_token = 'de' THEN"
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'ambiguous command, could be an abbreviation for either debug or delete';" 
"      END IF;" 
"    IF v_value_of_first_token  = LEFT('debug',v_length_of_first_token) THEN"
"      CALL xxxmdbug.syntax_check_for_debug();" 
"      SET v_value_of_first_token = 'debug';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"    IF v_value_of_first_token  = LEFT('delete',v_length_of_first_token) THEN"
"      SET v_value = (SELECT value FROM xxxmdbug.tokens WHERE token_number = 2); /* will be null if 'delete' with no number */" 
"      IF v_value NOT BETWEEN 1 AND 10000 THEN SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text='(delete) second argument is not a number'; END IF;" 
"      IF v_token_count>2 THEN SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text='(delete) too many arguments'; END IF;" 
"      SET v_value_of_first_token = 'delete';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"    IF v_value_of_first_token  = 'e' OR v_value_of_first_token  = 'ex' THEN"
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'ambiguous command, could be an abbreviation for either exit or execute';" 
"      END IF;" 
"    IF v_value_of_first_token  = LEFT('execute',v_length_of_first_token) THEN"
"" 
"      /* I can check that the first word might begin a" 
"         preparable statement. Actually checking whether" 
"         PREPARE works might also be feasible but would" 
"         involve much labour because some errors would" 
"         be applicable only to the debugger, which has" 
"         different privileges or defaults. */" 
"      IF v_value_of_second_token   NOT IN ("
"      'ALTER','ANALYZE','CACHE','CALL','CHANGE','CHECKSUM','COMMIT'," 
"      'CREATE','DELETE','DO','DROP','FLUSH','GRANT','INSERT','INSTALL'," 
"      'KILL','LOAD','OPTIMIZE','RENAME','REPAIR','REPLACE','RESET'," 
"      'REVOKE','ROLLBACK','SELECT','SET','SHOW','SLAVE','UNINSTALL','UPDATE') THEN" 
"        SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Statement is not preparable';" 
"        END IF;" 
"      SET v_value_of_first_token = 'execute';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"    IF v_value_of_first_token   = LEFT('exit',v_length_of_first_token) THEN"
"      IF v_token_count>1 THEN SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text='(exit) too many arguments'; END IF;" 
"      SET v_value_of_first_token = 'exit';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"    IF v_value_of_first_token   = LEFT('information',v_length_of_first_token) THEN"
"      IF v_value_of_second_token<>'status' THEN SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text='(information) second word not recognized'; END IF;" 
"      SET v_value_of_first_token = 'information';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"    IF v_value_of_first_token   = LEFT('leave',v_length_of_first_token) THEN"
"      IF v_token_count>1 THEN SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text='(leave) too many arguments'; END IF;" 
"      SET v_value_of_first_token = 'leave';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"" 
"    IF v_value_of_first_token   = LEFT('next',v_length_of_first_token) THEN"
"      IF v_token_count>1 THEN SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text='(next) too many arguments'; END IF;" 
"      SET v_value_of_first_token = 'next';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"" 
"    IF v_value_of_first_token   = LEFT('refresh',v_length_of_first_token) THEN"
"      IF v_value_of_second_token NOT IN ('call_stack','breakpoints','variables','server_variables','user_variables'," 
"                                       'statements_executed','prepared_statements') THEN" 
"        SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= '(refresh) Invalid argument';" 
"        END IF;" 
"      SET v_value_of_first_token = 'refresh';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"    IF v_value_of_first_token   = 's' THEN"
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'ambiguous command, could be an abbreviation for set or skip or source or step';" 
"      END IF;" 
"    IF v_value_of_first_token   = LEFT('set',v_length_of_first_token) THEN"
"      CALL xxxmdbug.syntax_check_for_set();" 
"      SET v_value_of_first_token = 'set';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"    IF v_value_of_first_token  = LEFT('skip',v_length_of_first_token) THEN"
"      IF v_token_count>1 THEN SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text='(skip) too many arguments'; END IF;" 
"      SET v_value_of_first_token = 'skip';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"    IF v_value_of_first_token  = LEFT('source',v_length_of_first_token) THEN"
"      SET v_value_of_first_token = 'source';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"    IF v_value_of_first_token  = LEFT('step',v_length_of_first_token) THEN"
"      IF v_token_count>1 THEN SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text='(step) too many arguments'; END IF;" 
"      SET v_value_of_first_token = 'step';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"" 
"    IF v_value_of_first_token  = LEFT('tbreakpoint',v_length_of_first_token) THEN"
"      CALL xxxmdbug.syntax_check_for_breakpoint();" 
"      SET v_value_of_first_token = 'tbreakpoint';" 
"      LEAVE syntax_check;" 
"      END IF;" 
"" 
"    SET v_error_message=CONCAT('unknown command: ',v_value_of_first_token);" 
"    SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text=v_error_message;" 
"    END; /* end of syntax_check */" 
"" 
"  SET @xxxmdbug_last_command = message; /* This is never used. Maybe I put it in for debugging reasons. */" 
"" 
"  /* There is nothing to if v_value_of_first_token='attach', which doesn't do much. But consider for 'attach':" 
"     todo: see whether debuggee is waiting for you particularly" 
"     todo: see whether channel is empty" 
"     todo: send connection_id along with attach message. */" 
"" 
"  IF v_value_of_first_token ='information' AND v_value_of_second_token  = 'status' THEN"
"    CALL xxxmdbug.command_i_status();" 
"    LEAVE command;" 
"    END IF;" 
"" 
"  IF v_value_of_first_token='source' THEN" 
"    SET message=RIGHT(message,LENGTH(message)-v_length_of_first_token);" 
"    CALL xxxmdbug.setup_internal(message,0);" 
"    LEAVE command;" 
"    END IF;" 
"" 
"  IF v_value_of_first_token  = 'refresh' THEN"
"    IF v_value_of_second_token ='call_stack' THEN CALL xxxmdbug.command_r_call_stack(message); END IF;"
"    IF v_value_of_second_token ='breakpoints' THEN CALL xxxmdbug.command_r_breakpoints(message); END IF;"
"    IF v_value_of_second_token ='variables' THEN CALL xxxmdbug.command_r_variables(message); END IF;"
"    IF v_value_of_second_token ='server_variables' THEN CALL xxxmdbug.command_r_server_variables(message); END IF;"
"    IF v_value_of_second_token ='user_variables' THEN CALL xxxmdbug.command_r_user_variables(message); END IF;"
"    IF v_value_of_second_token ='statements_executed' THEN CALL xxxmdbug.command_r_statements_executed(message); END IF;"
"    IF v_value_of_second_token ='prepared_statements' THEN CALL xxxmdbug.command_r_prepared_statements(message); END IF;"
"    /* anything else is probably bad syntax, and that will have beeen stop by earlier syntax checking */" 
"  ELSE" 
"    SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_command); /* 'C ' */" 
"    CALL xxxmdbug.dbms_pipe_send(v_prefix,message);" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* We do not actually do anything for command(...,'breakpoint ...'), except pipe it to the debuggee." 
"   But there are many syntax errors to check for. */" 
"/* syntax_check_for_breakpoint() is called from command() and follows" 
"   the same sequence of checks as icc_process_user_command_break()." 
"   In fact it would be surprising if icc_process_user_command_break()" 
"   saw bad syntax because syntax_check_for_breakpoint() should catch" 
"   everything severe. */" 
"/* todo: syntax must allow type," 
"   check for identifier contains supplementary characters." 
"   check for too-long-literal happens before changing 0x... to longblob." 
"   decide between SQL-ish syntax and gdb-ish syntax." 
"   perhaps @variable_name could be legal instead of literal. */" 
"/* break. expect \"break|tbreak [[schema_identifier.]routine_identifier] line_number_minimum[-line_number_maximum] [variable=value]\". */" 
"/* this syntax check is also used for the 'clear' command. */" 
"CREATE PROCEDURE xxxmdbug.syntax_check_for_breakpoint ()" 
"BEGIN" 
"  DECLARE break_token_number INT;" 
"  DECLARE break_token VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_schema_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_routine_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_routine_type VARCHAR(10) CHARACTER SET utf8 DEFAULT 'ROUTINE';" 
"  DECLARE v_line_number_minimum INT DEFAULT 0;" 
"  DECLARE v_line_number_maximum INT DEFAULT 0;" 
"  DECLARE v_condition_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_condition_operator VARCHAR(2) CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_condition_value VARCHAR(66) CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_junk VARCHAR(256) CHARACTER SET utf8;" 
"  DECLARE routine_type VARCHAR(1) CHARACTER SET utf8; /* 'F' or 'P', taken from surrogate routine identifier */" 
"  DECLARE v_surrogate_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_surrogate_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_remainder_of_original_name VARCHAR(8192) CHARACTER SET utf8;" 
"" 
"  /* if it doesn't start with line_number, then it must be starting with [[schema_identifier.]routine_identifier] */" 
"" 
"  SET break_token_number = 2;" 
"" 
"  SET break_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number);" 
"" 
"  CALL xxxmdbug.get_token_identifier_type(break_token);" 
"" 
"  IF @xxxmdbug_token_type IN (1,2,3) THEN /* is break_token any kind of identifier? */" 
"    SET break_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number+1);" 
"    IF break_token = '.' THEN" 
"      SET v_schema_identifier = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number);" 
"      SET v_routine_identifier = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number+2);" 
"      SET break_token_number=break_token_number+3;" 
"    ELSE" 
"      SET v_schema_identifier = @xxxmdbug_default_schema;" 
"      SET v_routine_identifier = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number);" 
"      SET break_token_number=break_token_number+1;" 
"      END IF;" 
"" 
"    /* It is okay if the routine is not in the setup group that is being debugged." 
"       It is not okay if the routine cannot be found. */" 
"    IF (SELECT COUNT(*) FROM information_schema.routines" 
"        WHERE routine_schema COLLATE utf8_general_ci  LIKE v_schema_identifier AND routine_name   LIKE v_routine_identifier)=0 THEN"
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Routine not found';" 
"      END IF;" 
"" 
"    /* I used to have an additional check: it is not okay if the routine's surrogate cannot be found." 
"       I decided that is too strict, since it should be okay if debugger user has no privilege on a subsidiary routine." 
"       Also the method of checking, calling debuggee_get_surrogate_name, ran into trouble when I escaped for % and _. */" 
"" 
"    END IF;" 
"" 
"  SET break_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number);" 
"" 
"  CALL xxxmdbug.get_token_identifier_type(break_token);" 
"  IF @xxxmdbug_token_type=0 THEN CALL xxxmdbug.get_token_type(break_token); END IF;" 
"" 
"  IF @xxxmdbug_token_type <> 4 THEN" 
"    SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'There has to be a line number';" 
"  ELSE" 
"    SET v_line_number_minimum = break_token;" 
"    SET break_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number+1);" 
"    IF break_token  = '-' THEN"
"      SET break_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number+2);" 
"      CALL xxxmdbug.get_token_identifier_type(break_token);" 
"      IF @xxxmdbug_token_type=0 THEN CALL xxxmdbug.get_token_type(break_token); END IF;" 
"      IF @xxxmdbug_token_type <> 4 THEN" 
"        SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Maximum line number must be an integer';" 
"        END IF;" 
"      SET v_line_number_maximum = break_token;" 
"      IF v_line_number_maximum < v_line_number_minimum THEN" 
"        SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Maximum line number < minimum line number';" 
"        END IF;" 
"      SET break_token_number=break_token_number+3;" 
"    ELSE" 
"      SET v_line_number_maximum=v_line_number_minimum;" 
"      SET break_token_number=break_token_number+1;" 
"      END IF;" 
"    END IF;" 
"  SET v_condition_identifier='';" 
"  SET v_condition_operator='';" 
"  SET v_condition_value='';" 
"  SET v_condition_identifier = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number);" 
"  SET v_condition_operator = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number+1);" 
"  SET v_condition_value = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number+2);" 
"" 
"  IF v_condition_identifier  <> '' THEN"
"    /* Check that identifier is valid by seeing whether one could create an object with that name." 
"       There is no check whether the variable actually exists because breakpoints can be set in advance.. */" 
"      CALL xxxmdbug.get_token_identifier_type(v_condition_identifier);" 
"      IF @xxxmdbug_token_type=0 THEN CALL xxxmdbug.get_token_type(v_condition_identifier); END IF;" 
"      IF @xxxmdbug_token_type NOT IN (1,2,3) THEN" 
"        SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Condition identifier format is invalid';" 
"        END IF;" 
"    IF v_condition_operator IS NULL THEN" 
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Condition operator is missing';" 
"      END IF; " 
"    IF v_condition_operator  <> '=' AND v_condition_operator <> '<>' AND v_condition_operator <> '<=' THEN"
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Condition operator is not ''='' or ''<>'' or ''<=''';" 
"      END IF;" 
"    IF v_condition_operator = '<=' AND v_condition_identifier <> 'CALL_STACK_DEPTH' THEN"
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Before ''<='' the only allowed possibility is call_stack_depth';" 
"      END IF;" 
"    IF v_condition_value IS NULL THEN" 
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Condition value is missing';" 
"      END IF;" 
"    IF v_condition_operator  = '<>' AND v_condition_value  <> 'OLD' THEN"
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'After ''<>'' the only allowed possibility is old';" 
"      END IF;" 
"    IF v_condition_operator  <> '<>' THEN"
"      /* For = and <=, value must be a literal i.e. numeric or 0x... or '...' */" 
"      /* If it can be an identifier, then it cannot be a literal, and we expect a literal. */" 
"      /* Todo: Think whether the literal could be a @user_variable. */" 
"      CALL xxxmdbug.get_token_identifier_type(v_condition_value);" 
"      IF @xxxmdbug_token_type=0 THEN CALL xxxmdbug.get_token_type(v_condition_value); END IF;" 
"      IF @xxxmdbug_token_type NOT IN (4,5,6,7,8) THEN" 
"        SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Condition value is not a valid literal';" 
"        END IF;" 
"      SET @xxxmdbug_token_value_4=v_condition_value;" 
"      CALL xxxmdbug.retype(); /* returns @xxxmdbug_token_value_4a */" 
"      IF LENGTH(@xxxmdbug_token_value_4a)>64 THEN" 
"        SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Literal is too long';" 
"        END IF;" 
"      SET @xxxmdbug_uvar=@xxxmdbug_token_value_4a;" 
"      CALL xxxmdbug.uvar(v_junk,''); /* returns @xxxmdbug_uvar_type */" 
"      IF @xxxmdbug_uvar_type ='LONGTEXT' AND (LEFT(v_condition_value,1) <>'''' OR RIGHT(v_condition_value,1) <>'''') THEN"
"        SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'String literals must be inside ''quote marks''';" 
"        END IF;" 
"      /* If the variables table has been refreshed and has the variable, you could check now that type is correct. */" 
"      END IF;" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Some of the code here is the same as in syntax_check_for_breakpoint() */" 
"CREATE PROCEDURE xxxmdbug.syntax_check_for_debug ()" 
"BEGIN" 
"  DECLARE break_token_number INT;" 
"  DECLARE break_token VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_schema_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_routine_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_junk VARCHAR(256) CHARACTER SET utf8;" 
"  DECLARE v_routine_type VARCHAR(1) CHARACTER SET utf8; /* 'F' or 'P', taken from surrogate routine identifier */" 
"  DECLARE v_surrogate_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_surrogate_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_remainder_of_original_name VARCHAR(8192) CHARACTER SET utf8;" 
"  DECLARE v_prepare_failed INT;" 
"  DECLARE v_argument_count,v_parameter_count INT;" 
"" 
"  SET break_token_number = 2;" 
"" 
"  SET break_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number+1);" 
"  IF break_token  = '.' THEN"
"    SET v_schema_identifier = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number);" 
"    SET v_routine_identifier = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number+2);" 
"    SET break_token_number=break_token_number+3;" 
"  ELSE" 
"    SET v_schema_identifier = @xxxmdbug_default_schema;" 
"    SET v_routine_identifier = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number);" 
"    SET break_token_number=break_token_number+1;" 
"    END IF;" 
"" 
"  SET v_schema_identifier=TRIM(BOTH '`' FROM v_schema_identifier);" 
"  SET v_routine_identifier=TRIM(BOTH '`' FROM v_routine_identifier);" 
"" 
"  /* It is okay if the routine is not in the setup group that is being debugged." 
"     It is not okay if the routine cannot be found, or if its surrogate cannot be found." 
"     Maybe this is too strict, since it should be okay if debugger user has no privilege on a subsidiary routine. */" 
"  IF (SELECT COUNT(*) FROM information_schema.routines" 
"      WHERE routine_schema COLLATE utf8_general_ci =v_schema_identifier AND routine_name =v_routine_identifier)=0 THEN"
"    SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Routine not found';" 
"    END IF;" 
"  CALL xxxmdbug.debuggee_get_surrogate_name(CONCAT(v_schema_identifier,'.',v_routine_identifier)," 
"                                            @xxxmdbug_default_schema," 
"                                            v_surrogate_schema_identifier," 
"                                            v_surrogate_routine_identifier," 
"                                            v_routine_type," 
"                                            v_remainder_of_original_name);" 
"  IF v_surrogate_routine_identifier IS NULL THEN" 
"    SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Surrogate routine not found';" 
"    END IF;" 
"" 
"  /* The number of parameters for this routine should" 
"     equal the number of arguments, and each argument" 
"     should be a literal. There is no check whether" 
"     data_type and argument literal type correspond," 
"     because I cannot decide what conditions are errors. */" 
"  SET v_argument_count=0;" 
"  SET break_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number);" 
"  IF break_token='(' THEN" 
"    x: LOOP" 
"      SET break_token_number=break_token_number+1;" 
"      SET break_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number);" 
"      IF break_token IS NULL THEN" 
"        SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Missing '')''';" 
"        END IF;" 
"      IF break_token  =')' THEN LEAVE x; END IF;"
"" 
"      SET v_prepare_failed=0;" 
"      BEGIN" 
"        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET v_prepare_failed=1;" 
"        SET @xxxmdbug_test_setting = CONCAT('CREATE DATABASE ',break_token);" 
"        PREPARE xxxmdbug_stmt FROM @xxxmdbug_test_setting;" 
"        END;" 
"      IF v_prepare_failed=0 THEN" 
"        SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Argument value is not a valid literal';" 
"        END IF;" 
"      /* The above test is not complete enough because reserved words are illegal too." 
"         But in this case I'll assume it is a reserved word because it is NULL, CURRENT_DATE, etc." 
"         The test could be more strict, and in syntax_check_for_breakpoint() it is more strict. */" 
"      SET @xxxmdbug_token_value_4=break_token;" 
"      CALL xxxmdbug.retype(); /* returns @xxxmdbug_token_value_4a */" 
"      IF LENGTH(@xxxmdbug_token_value_4a)>64 THEN" 
"        SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Literal is too long';" 
"        END IF;" 
"      SET @xxxmdbug_uvar=@xxxmdbug_token_value_4a;" 
"      CALL xxxmdbug.uvar(v_junk,''); /* returns @xxxmdbug_uvar_type */" 
"      IF @xxxmdbug_uvar_type ='LONGTEXT' AND (LEFT(break_token,1) <>'''' OR RIGHT(break_token,1) <>'''') THEN"
"        SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'String literals must be inside ''quote marks''';" 
"        END IF;" 
"" 
"      SET v_argument_count=v_argument_count+1;" 
"      SET break_token_number=break_token_number+1;" 
"      SET break_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = break_token_number);"
"      IF break_token =',' THEN ITERATE x; END IF;"
"      IF break_token =')' THEN LEAVE x; END IF;"
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Argument not followed by '','' or '')''';" 
"      END LOOP;" 
"    END IF;" 
"  SELECT COUNT(*) INTO v_parameter_count" 
"                           FROM information_schema.parameters" 
"                           WHERE specific_schema COLLATE utf8_general_ci =v_surrogate_schema_identifier"
"                           AND specific_name =v_surrogate_routine_identifier"
"                           AND LEFT(routine_type,1) =v_routine_type"
"                           AND ordinal_position<>0;" 
"  IF v_parameter_count<>v_argument_count THEN" 
"    SET @xxxmdbug_error_message=CONCAT('Argument count (',v_argument_count,') <> parameter count (',v_parameter_count,')');" 
"    SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text=@xxxmdbug_error_message;" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* The expectation for 'set' is 'set identifier = literal | null */" 
"CREATE PROCEDURE xxxmdbug.syntax_check_for_set ()" 
"BEGIN" 
"  DECLARE break_token VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_prepare_failed INT;" 
"  DECLARE v_junk VARCHAR(256) CHARACTER SET utf8;" 
"" 
"  SET break_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = 2);       /* identifier */" 
"" 
"  IF break_token IS NULL THEN" 
"    SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Declared-variable identifier is missing';" 
"    END IF;" 
"" 
"  /* Check that identifier is valid by seeing whether one could create an object with that name." 
"     There is no check whether the variable actually exists because breakpoints can be set in advance.. */" 
"  CALL xxxmdbug.get_token_identifier_type(break_token);" 
"  IF @xxxmdbug_token_type=0 THEN CALL xxxmdbug.get_token_type(break_token); END IF;" 
"  IF @xxxmdbug_token_type NOT IN (1,2,3) THEN" 
"    SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Identifier format is invalid';" 
"    END IF;" 
"" 
"  SET break_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = 3);       /* '=' */" 
"  IF break_token  <> '=' OR break_token IS NULL THEN"
"    SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= '''='' sign is missing';" 
"    END IF;" 
"" 
"  SET break_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = 4);       /* literal | NULL */" 
"" 
"  IF break_token IS NULL THEN" 
"    SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Value is missing';" 
"    END IF;" 
"" 
"  /* Todo: Think whether the literal could be a @user_variable. */" 
"  CALL xxxmdbug.get_token_identifier_type(break_token);" 
"  IF @xxxmdbug_token_type=0 THEN CALL xxxmdbug.get_token_type(break_token); END IF;" 
"  IF @xxxmdbug_token_type NOT IN (4,5,6,7,8) THEN" 
"    SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Value is not a valid literal or NULL';" 
"    END IF;" 
"" 
"  SET @xxxmdbug_token_value_4=break_token;" 
"  CALL xxxmdbug.retype(); /* returns @xxxmdbug_token_value_4a */" 
"  IF LENGTH(@xxxmdbug_token_value_4a)>64 THEN" 
"    SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'Literal is too long';" 
"    END IF;" 
"  SET @xxxmdbug_uvar=@xxxmdbug_token_value_4a;" 
"  CALL xxxmdbug.uvar(v_junk,''); /* returns @xxxmdbug_uvar_type */" 
"  IF @xxxmdbug_uvar_type ='LONGTEXT' AND (LEFT(break_token,1) <>'''' OR RIGHT(break_token,1) <>'''') THEN"
"    SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text= 'String literals must be inside ''quote marks''';" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Clear warnings. Call this when a handler catches a syntax error and" 
"   there's no need to leave the message in the warning list. MySQL will" 
"   not clear automatically." 
"   called from: get_token_identifier_type, get_token_type(). */" 
"CREATE PROCEDURE xxxmdbug.clear_warnings ()" 
"BEGIN" 
"  DECLARE v INT;" 
"  SELECT 1 INTO v FROM information_schema.tables LIMIT 1;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* For checking command syntax, we need to know what kind of token a token is." 
"   0 not yet known, a temporary return from get_token_identifier_type" 
"   1 delimited identifier e.g. `x`" 
"   2 regular identifier e.g. X or 5X or `X`" 
"   3 regular identifier except it contains '%' e.g. 5%X" 
"   4 small integer e.g. 5 or 5.0" 
"   5 number but not integer e.g. 5.1 or 99999" 
"   6 string inside ''s or \"\"s e.g. '5'" 
"   7 string starting with 0x e.g. 0x5b" 
"   8 NULL" 
"   9 other, e.g. reserved word or @user_variable or too-long identifier." 
"   We have to split this into routines, get_token_identifier_type and get_token_type," 
"   because functions cannot contain dynamic SQL and therefore debuggee can't call" 
"   get_token_identifier_type. So debuggee just assumes it's an identifier if it's" 
"   not a number or a string (which causes return = 8). That should be safe, since" 
"   command() checks before sending. */" 
"CREATE PROCEDURE xxxmdbug.get_token_identifier_type (p_token VARCHAR(66) CHARACTER SET utf8)" 
"xx:" 
"BEGIN" 
"  IF LENGTH(p_token)>66 THEN SET @xxxmdbug_token_type=9; LEAVE xx; END IF;" 
"  IF LEFT(p_token,1) ='`' THEN"
"    SET @xxxmdbug_token_type=1;" 
"    LEAVE xx;" 
"    END IF;" 
"  IF LEFT(p_token,1) ='\"' THEN"
"    SET @xxxmdbug_token_type=0;" 
"    LEAVE xx;" 
"    END IF;" 
"  IF LENGTH(p_token)>64 THEN SET @xxxmdbug_token_type=9; LEAVE xx; END IF;" 
"  BEGIN" 
"    DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN CALL clear_warnings(); END;" 
"    SET @xxxmdbug_test_setting = CONCAT('CREATE DATABASE ',p_token);" 
"    PREPARE xxxmdbug_stmt FROM @xxxmdbug_test_setting;" 
"    SET @xxxmdbug_token_type=2;" 
"    LEAVE xx;" 
"    END;" 
"  BEGIN" 
"    DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN CALL clear_warnings(); END;" 
"    SET @xxxmdbug_test_setting = CONCAT('CREATE DATABASE ',REPLACE(p_token,'%','Q'));" 
"    PREPARE xxxmdbug_stmt FROM @xxxmdbug_test_setting;" 
"    SET @xxxmdbug_token_type=3;" 
"    LEAVE xx;" 
"    END;" 
"  SET @xxxmdbug_token_type=0;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* get_token_type() should not be called from debuggee routine because that changes the warning list. */" 
"CREATE PROCEDURE xxxmdbug.get_token_type (p_token VARCHAR(66) CHARACTER SET UTF8)" 
"xx:" 
"BEGIN" 
"  DECLARE v_integer INT;" 
"  DECLARE v_double DOUBLE PRECISION;" 
"  BEGIN" 
"    DECLARE EXIT HANDLER FOR SQLEXCEPTION, SQLWARNING BEGIN CALL clear_warnings(); END;" 
"    SET v_integer = p_token;" 
"    IF v_integer < 0 OR v_integer <> p_token THEN" 
"      SET @xxxmdbug_token_type=5;" 
"      LEAVE xx;" 
"      END IF;" 
"    SET @xxxmdbug_token_type=4;" 
"    LEAVE xx;" 
"    END;" 
"  BEGIN" 
"    DECLARE EXIT HANDLER FOR SQLEXCEPTION, SQLWARNING BEGIN CALL clear_warnings(); END;" 
"    SET v_double = p_token;" 
"    SET @xxxmdbug_token_type=5;" 
"    LEAVE xx;" 
"    END;" 
"  IF LEFT(p_token,1) ='''' OR LEFT(p_token,1) ='\"' THEN"
"    SET @xxxmdbug_token_type=6;" 
"    LEAVE xx;" 
"    END IF;" 
"  IF LEFT(p_token,2) ='0x' AND HEX(RIGHT(p_token,LENGTH(p_token)-2)) IS NOT NULL THEN"
"    SET @xxxmdbug_token_type=7;" 
"    LEAVE xx;" 
"    END IF;" 
"  IF p_token ='NULL' THEN"
"    SET @xxxmdbug_token_type=8;" 
"    LEAVE xx;" 
"    END IF;" 
"  SET @xxxmdbug_token_type=9;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.command_i_status ()" 
"BEGIN" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_message_start INT;" 
"" 
"  DECLARE v_debugger_name VARCHAR(32) CHARACTER SET utf8;" 
"  DECLARE v_debugger_version VARCHAR(5) CHARACTER SET utf8;" 
"  DECLARE v_timestamp_of_status_message DATETIME;" 
"  DECLARE v_number_of_status_message INT;" 
"  DECLARE v_icc_count INT;" 
"  DECLARE v_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_line_number INT;" 
"  DECLARE v_is_at_breakpoint VARCHAR(3) CHARACTER SET utf8;" 
"  DECLARE v_is_at_tbreakpoint VARCHAR(3) CHARACTER SET utf8;" 
"  DECLARE v_is_at_routine_exit VARCHAR(3) CHARACTER SET utf8;" 
"  DECLARE v_stack_depth INT;" 
"  DECLARE v_last_command VARCHAR(132) CHARACTER SET utf8;" 
"  DECLARE v_last_command_result VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_commands_count INT;" 
"" 
"  DECLARE v_comma CHAR CHARACTER SET utf8;" 
"  DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE i INT DEFAULT 0;" 
"" 
"  DECLARE c CURSOR FOR SELECT value FROM xxxmdbug.tokens ORDER BY token_number;" 
"" 
"  CALL xxxmdbug.create_tokens_table();" 
"" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.information_status;" 
"  CREATE TEMPORARY TABLE xxxmdbug.information_status (" 
"  debugger_name VARCHAR(32) CHARACTER SET utf8," 
"  debugger_version VARCHAR(5) CHARACTER SET utf8," 
"  timestamp_of_status_message DATETIME," 
"  number_of_status_message INT," 
"  icc_count INT," 
"  schema_identifier VARCHAR(66) CHARACTER SET utf8," 
"  routine_identifier VARCHAR(66) CHARACTER SET utf8," 
"  line_number INT," 
"  is_at_breakpoint VARCHAR(3) CHARACTER SET utf8," 
"  is_at_tbreakpoint VARCHAR(3) CHARACTER SET utf8," 
"  is_at_routine_exit VARCHAR(3) CHARACTER SET utf8," 
"  stack_depth INT," 
"  last_command VARCHAR(66) CHARACTER SET utf8," 
"  last_command_result VARCHAR(128) CHARACTER SET utf8," 
"  commands_count INT) engine=memory;" 
"" 
"  /* 'R ' is for receiving, so this is what debugger uses to get status messages from debuggee. */" 
"  /* There is no need to go on and send something, just return. */" 
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_statement_status); /* 'R ' */" 
"" 
"  /* It is possible that debuggee calls icc_send_statement_status() and erases an old message," 
"     then debugger gets control before debuggee can make the new message." 
"     So try 10 times. But if you keep failing, give up and return with an empty table. */" 
"  x: WHILE i < 10 DO" 
"    CALL xxxmdbug.dbms_pipe_receive(v_prefix,0,v_ret,v_message_start);" 
"    IF v_ret  <> '' THEN LEAVE x; END IF;"
"    SET i=i+1;" 
"    DO SLEEP(@xxxmdbug_sleep_time);" 
"    END WHILE;" 
"" 
"  CALL xxxmdbug.insert_into_tokens('','',v_ret,0);" 
"  UPDATE xxxmdbug.tokens SET value = TRIM(BOTH '\"' FROM value);" 
"  UPDATE xxxmdbug.tokens SET value = TRIM(BOTH '''' FROM value);" 
"  OPEN c;" 
"  FETCH c INTO v_debugger_name; FETCH c INTO v_comma;" 
"  FETCH c INTO v_debugger_version; FETCH c INTO v_comma;" 
"  FETCH c INTO v_timestamp_of_status_message; FETCH c INTO v_comma;" 
"  FETCH c INTO v_number_of_status_message; FETCH c INTO v_comma;" 
"  FETCH c INTO v_icc_count; FETCH c INTO v_comma;" 
"  FETCH c INTO v_schema_identifier; FETCH c INTO v_comma;" 
"  FETCH c INTO v_routine_identifier; FETCH c INTO v_comma;" 
"  FETCH c INTO v_line_number; FETCH c INTO v_comma;" 
"  FETCH c INTO v_is_at_breakpoint; FETCH c INTO v_comma;" 
"  FETCH c INTO v_is_at_tbreakpoint; FETCH c INTO v_comma;" 
"  FETCH c INTO v_is_at_routine_exit; FETCH c INTO v_comma;" 
"  FETCH c INTO v_stack_depth; FETCH c INTO v_comma;" 
"  FETCH c INTO v_last_command; FETCH c INTO v_comma;" 
"  FETCH c INTO v_last_command_result; FETCH c INTO v_comma;" 
"  FETCH c INTO v_commands_count;" 
"  CLOSE c;" 
"  INSERT INTO xxxmdbug.information_status VALUES (" 
"  v_debugger_name," 
"  v_debugger_version," 
"  v_timestamp_of_status_message," 
"  v_number_of_status_message," 
"  v_icc_count," 
"  v_schema_identifier," 
"  v_routine_identifier," 
"  v_line_number," 
"  v_is_at_breakpoint," 
"  v_is_at_tbreakpoint," 
"  v_is_at_routine_exit," 
"  v_stack_depth," 
"  UNHEX(v_last_command)," 
"  UNHEX(v_last_command_result)," 
"  v_commands_count);" 
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* All the 'refresh' commands ('refresh breakpoints' etc.) will call debugger_wait_and_receive()." 
"   Since they have sent out a command that requires a debuggee response, they always wait." 
"   We will also check if the debuggee is alive (with 'i status')." 
"   todo: we could also 'show processlist' if we knew the debuggee connection id and believed it was stable." 
"   There is a timeout, but it is very long (e.g. 1000 seconds)." 
"   The user might stop the job with ^C, or some other connection might stop it with 'kill'." 
"   If that happens, and debugger starts again, it might see a stray response from the last time," 
"   and it is hard to see that since we do not have message numbering, so: too bad." 
"   Typically @xxxmdbug_sleep_time = 0.1 seconds and @xxxmdbug_timeout_for_r_commands = 1000 seconds. */" 
"CREATE PROCEDURE xxxmdbug.debugger_wait_and_receive (p_prefix VARCHAR(128) CHARACTER SET utf8," 
"                                                    OUT p_ret MEDIUMTEXT CHARACTER SET utf8," 
"                                                    p_message VARCHAR(8192) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_message_start INT;" 
"  DECLARE v_start_time BIGINT;" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8; /* for sending. for receiving, it's p_prefix. */" 
"  SET v_start_time=TO_SECONDS(CURRENT_TIMESTAMP);" 
"" 
"  /* At least we can ignore any messages that are responses to the question which we have not asked yet. */" 
"  y: LOOP" 
"    CALL xxxmdbug.dbms_pipe_receive(p_prefix,1,p_ret,v_message_start);" 
"    IF v_message_start=0 THEN LEAVE y; END IF;" 
"     END LOOP;" 
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_command); /* 'C ' */" 
"  CALL xxxmdbug.dbms_pipe_send(v_prefix,p_message);" 
"  CALL xxxmdbug.dbms_pipe_receive_with_timeout(p_prefix,1,p_ret,v_message_start,@xxxmdbug_timeout_for_r_commands);" 
"  /* Something has arrived from debuggee */" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* dbms_pipe_receive_with_timeout() calls dbms_pipe_receive(no wait) repeatedly until" 
"   it gets a message or until a supplied number-of-seconds has passed. Timeout causes signal 5678." 
"   We also do 'i status' to check whether the debuggee has stopped totally -- this involves an" 
"   automatic refresh of information_status but surely that will not cause trouble, eh?" 
"   It does mean, though, that currently this routine is only useful for debugger 'refresh' commands." 
"   todo: Both timeout and exit-detected could merely cause warnings not exceptions, and the table could be empty. */" 
"CREATE PROCEDURE xxxmdbug.dbms_pipe_receive_with_timeout (prefix VARCHAR(66) CHARACTER SET utf8," 
"                                                                     erase INT," 
"                                                                     OUT string MEDIUMTEXT CHARACTER SET utf8," 
"                                                                     OUT p_message_start INT," 
"                                                                     p_timeout INT)" 
"BEGIN" 
"  DECLARE v_start_time BIGINT;" 
"  DECLARE v_is_at_routine_exit VARCHAR(3) CHARACTER SET utf8;" 
"  DECLARE v_stack_depth INT;" 
"" 
"  SET v_start_time=TO_SECONDS(CURRENT_TIMESTAMP);" 
"  x: LOOP" 
"    IF SLEEP(@xxxmdbug_sleep_time) = 1 THEN" 
"      /* Usually ^C causes error 1317, but just in case it doesn't ... */" 
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno,message_text='sleep interrupted, probably due to control C';" 
"      END IF;" 
"    CALL xxxmdbug.dbms_pipe_receive(prefix,erase,string,p_message_start);" 
"    IF p_message_start>0 THEN LEAVE x; END IF;" 
"    IF TO_SECONDS(CURRENT_TIMESTAMP)>v_start_time+p_timeout THEN" 
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno,message_text='timeout';" 
"      END IF;" 
"" 
"    CALL xxxmdbug.command_i_status();" 
"    SELECT is_at_routine_exit, stack_depth INTO v_is_at_routine_exit,v_stack_depth FROM xxxmdbug.information_status;" 
"    IF v_is_at_routine_exit IS NULL" 
"    OR (v_is_at_routine_exit ='yes' AND v_stack_depth = 0) THEN"
"      /* no messages at all on this channel, or 'routine_exit' happened while at top of stack, i.e. routine has ended */" 
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno,message_text='debuggee has not started or has ended';" 
"      END IF;    " 
"    END LOOP;" 
"  /* Something has arrived */" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.command_r_call_stack (p_message MEDIUMTEXT CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_comma CHAR CHARACTER SET utf8;" 
"  DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_type VARCHAR(10) CHARACTER SET utf8;" 
"  DECLARE v_line_number INT;" 
"  DECLARE www_eof INT DEFAULT 0;" 
"  DECLARE c CURSOR FOR SELECT value FROM xxxmdbug.tokens ORDER BY token_number;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET www_eof = 1;" 
"" 
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_call_stack); /* 'A ' */" 
"  CALL xxxmdbug.debugger_wait_and_receive(v_prefix,v_ret,p_message);" 
"  CALL xxxmdbug.create_tokens_table();" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.call_stack;" 
"  CREATE TEMPORARY TABLE xxxmdbug.call_stack (" 
"  schema_identifier VARCHAR(66)  CHARACTER SET utf8," 
"  routine_identifier VARCHAR(66) CHARACTER SET utf8," 
"  routine_type VARCHAR(10) CHARACTER SET utf8," 
"  line_number INT) engine=memory;" 
"  CALL xxxmdbug.insert_into_tokens('','',v_ret,0);" 
"  UPDATE xxxmdbug.tokens SET value = TRIM(BOTH '\"' FROM value);" 
"  OPEN c;" 
"  www: LOOP" 
"    FETCH c INTO v_schema_identifier; FETCH c INTO v_comma;" 
"    IF www_eof = 1 THEN LEAVE www; END IF;" 
"    FETCH c INTO v_routine_identifier; FETCH c INTO v_comma;" 
"    FETCH c INTO v_routine_type; FETCH c INTO v_comma;" 
"    FETCH c INTO v_line_number; FETCH c INTO v_comma;" 
"    IF v_routine_type ='P' THEN SET v_routine_type='PROCEDURE'; ELSE SET v_routine_type='FUNCTION'; END IF;"
"    INSERT INTO xxxmdbug.call_stack VALUES (" 
"    v_schema_identifier," 
"    v_routine_identifier," 
"    v_routine_type," 
"    v_line_number);" 
"    END LOOP;" 
"  CLOSE c;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.command_r_variables (p_message VARCHAR(8192) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_type VARCHAR(10) CHARACTER SET utf8;" 
"  DECLARE v_token_number_of_declare INT;" 
"  DECLARE v_variable_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_data_type VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_value VARCHAR(132) CHARACTER SET utf8;" 
"  DECLARE v_old_value VARCHAR(132) CHARACTER SET utf8;" 
"  DECLARE v_is_in_scope INT;" 
"  DECLARE v_is_settable INT;" 
"  DECLARE v_is_updated_by_set INT;" 
"  DECLARE v_comma CHAR CHARACTER SET utf8;" 
"  DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE www_eof INT DEFAULT 0;" 
"  DECLARE c CURSOR FOR SELECT value FROM xxxmdbug.tokens ORDER BY token_number;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET www_eof = 1;" 
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_variables); /* 'V ' */" 
"  CALL xxxmdbug.debugger_wait_and_receive(v_prefix,v_ret,p_message);" 
"  /* TODO: This drops and creates xxxmdbug.variables every time. It would be smarter to preserve. */" 
"  CALL xxxmdbug.create_variables_table();" 
"  CALL xxxmdbug.create_tokens_table();" 
"  CALL xxxmdbug.insert_into_tokens('','',v_ret,0);" 
"  UPDATE xxxmdbug.tokens SET value = TRIM(BOTH '\"' FROM value);" 
"  OPEN c;" 
"  www: LOOP" 
"    FETCH c INTO v_schema_identifier; FETCH c INTO v_comma;" 
"    IF www_eof = 1 THEN LEAVE www; END IF;" 
"    FETCH c INTO v_routine_identifier; FETCH c INTO v_comma;" 
"    FETCH c INTO v_routine_type; FETCH c INTO v_comma;" 
"    FETCH c INTO v_token_number_of_declare; FETCH c INTO v_comma;" 
"    FETCH c INTO v_variable_identifier; FETCH c INTO v_comma;" 
"    FETCH c INTO v_data_type; FETCH c INTO v_comma;" 
"    FETCH c INTO v_value; FETCH c INTO v_comma;" 
"    FETCH c INTO v_old_value; FETCH c INTO v_comma;" 
"    FETCH c INTO v_is_in_scope; FETCH c INTO v_comma;" 
"    FETCH c INTO v_is_settable; FETCH c INTO v_comma;" 
"    FETCH c INTO v_is_updated_by_set; FETCH c INTO v_comma;" 
"    INSERT INTO xxxmdbug.variables VALUES (" 
"    v_schema_identifier," 
"    v_routine_identifier," 
"    v_routine_type," 
"    v_token_number_of_declare," 
"    v_variable_identifier," 
"    v_data_type," 
"    UNHEX(v_value)," 
"    UNHEX(v_old_value)," 
"    v_is_in_scope," 
"    v_is_settable," 
"    v_is_updated_by_set);" 
"    END LOOP;" 
"  CLOSE c;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.command_r_server_variables (p_message VARCHAR(8192) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_variable_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_value VARCHAR(132) CHARACTER SET utf8;" 
"  DECLARE v_data_type VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_comma CHAR CHARACTER SET utf8;" 
"  DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE www_eof INT DEFAULT 0;" 
"  DECLARE v_is_settable INT;" 
"  DECLARE c CURSOR FOR SELECT value FROM xxxmdbug.tokens ORDER BY token_number;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET www_eof = 1;" 
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_server_variables); /* 'S ' */" 
"  CALL xxxmdbug.debugger_wait_and_receive(v_prefix,v_ret,p_message);" 
"  /* TODO: This drops and creates xxxmdbug.server_variables every time. It would be smarter to preserve. */" 
"  CALL xxxmdbug.create_server_variables_table();" 
"  CALL xxxmdbug.create_tokens_table();" 
"  CALL xxxmdbug.insert_into_tokens('','',v_ret,0);" 
"  UPDATE xxxmdbug.tokens SET value = TRIM(BOTH '\"' FROM value);" 
"  OPEN c;" 
"  www: LOOP" 
"    FETCH c INTO v_variable_identifier; FETCH c INTO v_comma;" 
"    IF www_eof = 1 THEN LEAVE www; END IF;" 
"    FETCH c INTO v_value; FETCH c INTO v_comma;" 
"    FETCH c INTO v_is_settable; FETCH c INTO v_comma;" 
"    FETCH c INTO v_data_type; FETCH c INTO v_comma;" 
"    INSERT INTO xxxmdbug.server_variables VALUES (" 
"    NULL,                        /* schema_identifier VARCHAR(66) */" 
"    NULL,                        /* routine_identifier VARCHAR(66) */" 
"    NULL,                        /* routine_type VARCHAR(10) */" 
"    NULL,                        /* token_number_of_declare INT */" 
"    v_variable_identifier," 
"    v_data_type,                 /* data_type VARCHAR(66) */" 
"    UNHEX(v_value)," 
"    NULL,                        /* old_value VARCHAR(66) */" 
"    1,                           /* is_in_scope INT */" 
"    v_is_settable,               /* is_settable INT */" 
"    0);                          /* is_updated_by_set INT */" 
"    END LOOP;" 
"  CLOSE c;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.command_r_user_variables (p_message VARCHAR(8192) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_variable_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_value,v_old_value VARCHAR(132) CHARACTER SET utf8;" 
"  DECLARE v_type VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_comma CHAR CHARACTER SET utf8;" 
"  DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE www_eof INT DEFAULT 0;" 
"  DECLARE c CURSOR FOR SELECT value FROM xxxmdbug.tokens ORDER BY token_number;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET www_eof = 1;" 
"" 
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_user_variables); /* 'U ' */" 
"  CALL xxxmdbug.debugger_wait_and_receive(v_prefix,v_ret,p_message);" 
"  /* TODO: This drops and creates xxxmdbug.variables every time. It would be smarter to preserve. */" 
"  CALL xxxmdbug.create_user_variables_table();" 
"  CALL xxxmdbug.create_tokens_table();" 
"  CALL xxxmdbug.insert_into_tokens('','',v_ret,0);" 
"  UPDATE xxxmdbug.tokens SET value = TRIM(BOTH '\"' FROM value);" 
"  OPEN c;" 
"  www: LOOP" 
"    FETCH c INTO v_variable_identifier; FETCH c INTO v_comma;" 
"    IF www_eof = 1 THEN LEAVE www; END IF;" 
"    FETCH c INTO v_value; FETCH c INTO v_comma;" 
"    FETCH c INTO v_old_value; FETCH c INTO v_comma;" 
"    FETCH c INTO v_type; FETCH c INTO v_comma;" 
"" 
"    INSERT INTO xxxmdbug.user_variables VALUES (" 
"    NULL,                        /* schema_identifier VARCHAR(66) */" 
"    NULL,                        /* routine_identifier VARCHAR(66) */" 
"    NULL,                        /* routine_type VARCHAR(10) */" 
"    NULL,                        /* token_number_of_declare INT */" 
"    v_variable_identifier," 
"    v_type,                        /* data_type VARCHAR(66) */" 
"    UNHEX(v_value)," 
"    UNHEX(v_old_value),          /* old_value VARCHAR(66) */" 
"    1,                           /* is_in_scope INT */" 
"    1,                           /* is_settable INT */" 
"    0);                          /* is_updated_by_set INT */" 
"    END LOOP;" 
"  CLOSE c;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.command_r_breakpoints (p_message VARCHAR(8192) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_breakpoint_identifier INT;" 
"  DECLARE v_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_type VARCHAR(10) CHARACTER SET utf8;" 
"  DECLARE v_line_number_minimum INT;" 
"  DECLARE v_line_number_maximum INT;" 
"  DECLARE v_condition_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_condition_operator VARCHAR(2) CHARACTER SET utf8;" 
"  DECLARE v_condition_value VARCHAR(132) CHARACTER SET utf8;" 
"  DECLARE v_hit_count INT;" 
"  DECLARE v_is_temporary INT;" 
"  DECLARE v_is_temporary_and_to_be_cleared INT;" 
"  DECLARE v_is_matching_location INT;" 
"  DECLARE v_is_matching_condition INT;" 
"  DECLARE v_call_stack_depth_when_set INT;" 
"  DECLARE v_command VARCHAR(14) CHARACTER SET utf8;" 
"  DECLARE v_comma CHAR CHARACTER SET utf8;" 
"  DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE www_eof INT DEFAULT 0;" 
"  DECLARE c CURSOR FOR SELECT value FROM xxxmdbug.tokens ORDER BY token_number;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET www_eof = 1;" 
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_breakpoints); /* 'B ' */" 
"  CALL xxxmdbug.debugger_wait_and_receive(v_prefix,v_ret,p_message);" 
"  /* TODO: This drops and creates xxxmdbug.breakpoints every time. It would be smarter to preserve. */" 
"  CALL xxxmdbug.create_breakpoints_table();" 
"  CALL xxxmdbug.create_tokens_table();" 
"  CALL xxxmdbug.insert_into_tokens('','',v_ret,0);" 
"  UPDATE xxxmdbug.tokens SET value = TRIM(BOTH '\"' FROM value);" 
"  OPEN c;" 
"  www: LOOP" 
"    FETCH c INTO v_breakpoint_identifier; FETCH c INTO v_comma;" 
"    IF www_eof = 1 THEN LEAVE www; END IF;" 
"    FETCH c INTO v_schema_identifier; FETCH c INTO v_comma;" 
"    FETCH c INTO v_routine_identifier; FETCH c INTO v_comma;" 
"    FETCH c INTO v_routine_type; FETCH c INTO v_comma;" 
"    FETCH c INTO v_line_number_minimum; FETCH c INTO v_comma;" 
"    FETCH c INTO v_line_number_maximum; FETCH c INTO v_comma;" 
"    FETCH c INTO v_condition_identifier; FETCH c INTO v_comma;" 
"    FETCH c INTO v_condition_operator; FETCH c INTO v_comma;" 
"    FETCH c INTO v_condition_value; FETCH c INTO v_comma;" 
"    FETCH c INTO v_hit_count; FETCH c INTO v_comma;" 
"    FETCH c INTO v_is_temporary; FETCH c INTO v_comma;" 
"    FETCH c INTO v_is_temporary_and_to_be_cleared; FETCH c INTO v_comma;" 
"    FETCH c INTO v_is_matching_location; FETCH c INTO v_comma;" 
"    FETCH c INTO v_is_matching_condition; FETCH c INTO v_comma;" 
"    FETCH c INTO v_call_stack_depth_when_set; FETCH c INTO v_comma;" 
"    FETCH c INTO v_command; FETCH c INTO v_comma;" 
"    INSERT INTO xxxmdbug.breakpoints VALUES (" 
"    v_breakpoint_identifier," 
"    v_schema_identifier," 
"    v_routine_identifier," 
"    v_routine_type," 
"    v_line_number_minimum," 
"    v_line_number_maximum," 
"    v_condition_identifier," 
"    v_condition_operator," 
"    UNHEX(v_condition_value)," 
"    v_hit_count," 
"    v_is_temporary," 
"    v_is_temporary_and_to_be_cleared," 
"    v_is_matching_location," 
"    v_is_matching_condition," 
"    v_call_stack_depth_when_set," 
"    v_command);" 
"    END LOOP;" 
"  CLOSE c;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.command_r_prepared_statements (p_message VARCHAR(8192) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_statement_name VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_statement_text VARCHAR(132) CHARACTER SET utf8;" 
"  DECLARE v_comma CHAR CHARACTER SET utf8;" 
"  DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE prepared_statements_eof INT DEFAULT 0;" 
"  DECLARE c_tokens_of_prepared_statements CURSOR FOR SELECT value FROM xxxmdbug.tokens ORDER BY token_number;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET prepared_statements_eof = 1;" 
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_prepared_statements); /* 'P ' */" 
"  CALL xxxmdbug.debugger_wait_and_receive(v_prefix,v_ret,p_message);" 
"  /* TODO: This drops and creates xxxmdbug.prepared_statements every time. It would be smarter to preserve. */" 
"  CALL xxxmdbug.create_prepared_statements_table();" 
"  CALL xxxmdbug.create_tokens_table();" 
"  CALL xxxmdbug.insert_into_tokens('','',v_ret,0);" 
"  UPDATE xxxmdbug.tokens SET value = TRIM(BOTH '\"' FROM value);" 
"  OPEN c_tokens_of_prepared_statements;" 
"  prepared_statementsxxx: LOOP" 
"    FETCH c_tokens_of_prepared_statements INTO v_statement_name; FETCH c_tokens_of_prepared_statements INTO v_comma;" 
"    IF prepared_statements_eof = 1 THEN LEAVE prepared_statementsxxx; END IF;" 
"    FETCH c_tokens_of_prepared_statements INTO v_statement_text; FETCH c_tokens_of_prepared_statements INTO v_comma;" 
"    INSERT INTO xxxmdbug.prepared_statements VALUES (" 
"    v_statement_name," 
"    UNHEX(v_statement_text));" 
"    END LOOP;" 
"  CLOSE c_tokens_of_prepared_statements;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.command_r_statements_executed (p_message VARCHAR(8192) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_type VARCHAR(10) CHARACTER SET utf8;" 
"  DECLARE v_number INT;" 
"  DECLARE v_caught_by_no_handler INT;" 
"  DECLARE v_caught_by_sqlwarning_handler INT;" 
"  DECLARE v_caught_by_sqlexception_handler INT;" 
"  DECLARE v_caught_by_not_found_handler INT;" 
"  DECLARE v_caught_by_user_written_handler INT;" 
"  DECLARE v_row_count INT;" 
"  DECLARE v_comma CHAR CHARACTER SET utf8;" 
"  DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE xxx_eof INT DEFAULT 0;" 
"  DECLARE cxxx CURSOR FOR SELECT value FROM xxxmdbug.tokens ORDER BY token_number;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET xxx_eof = 1;" 
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_statements_executed); /* 'X ' */" 
"  CALL xxxmdbug.debugger_wait_and_receive(v_prefix,v_ret,p_message);" 
"  /* TODO: This drops and creates xxxmdbug.statements_executed every time. It would be smarter to preserve. */" 
"  CALL xxxmdbug.create_statements_executed_table();" 
"  CALL xxxmdbug.create_tokens_table();" 
"  CALL xxxmdbug.insert_into_tokens('','',v_ret,0);" 
"  UPDATE xxxmdbug.tokens SET value = TRIM(BOTH '\"' FROM value);" 
"  OPEN cxxx;" 
"  xxx: LOOP" 
"    FETCH cxxx INTO v_schema_identifier; FETCH cxxx INTO v_comma;" 
"    IF xxx_eof = 1 THEN LEAVE xxx; END IF;" 
"    FETCH cxxx INTO v_routine_identifier; FETCH cxxx INTO v_comma;" 
"    FETCH cxxx INTO v_routine_type; FETCH cxxx INTO v_comma;" 
"    FETCH cxxx INTO v_number; FETCH cxxx INTO v_comma;" 
"    FETCH cxxx INTO v_caught_by_no_handler; FETCH cxxx INTO v_comma;" 
"    FETCH cxxx INTO v_caught_by_sqlwarning_handler; FETCH cxxx INTO v_comma;" 
"    FETCH cxxx INTO v_caught_by_sqlexception_handler; FETCH cxxx INTO v_comma;" 
"    FETCH cxxx INTO v_caught_by_not_found_handler; FETCH cxxx INTO v_comma;" 
"    FETCH cxxx INTO v_caught_by_user_written_handler; FETCH cxxx INTO v_comma;" 
"    FETCH cxxx INTO v_row_count; FETCH cxxx INTO v_comma;" 
"    INSERT INTO xxxmdbug.statements_executed VALUES (" 
"    v_schema_identifier," 
"    v_routine_identifier," 
"    v_routine_type," 
"    v_number," 
"    v_caught_by_no_handler," 
"    v_caught_by_sqlwarning_handler," 
"    v_caught_by_sqlexception_handler," 
"    v_caught_by_not_found_handler," 
"    v_caught_by_user_written_handler," 
"    v_row_count);" 
"    END LOOP;" 
"  CLOSE cxxx;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* We can call this during setup, and from debugger, but debuggee procedures use fixed areas.*/" 
"CREATE PROCEDURE xxxmdbug.insert_into_tokens (mysql_proc_db VARCHAR(66) CHARACTER SET utf8," 
"                                     mysql_proc_name VARCHAR(66) CHARACTER SET utf8," 
"                                     body LONGTEXT CHARACTER SET utf8," 
"                                     is_body INT)" 
"BEGIN" 
"  DECLARE i INT DEFAULT 1;" 
"  DECLARE current_line_number INT;" 
"  DECLARE token_offset INT DEFAULT 1;" 
"  DECLARE token_line_number INT;" 
"  DECLARE token VARCHAR(21000) CHARACTER SET utf8;" 
"  DECLARE first_char_in_token CHAR CHARACTER SET utf8;" 
"  DECLARE last_was_operator INT;" 
"  DECLARE is_unary INT;" 
"  DECLARE v_token_number INT DEFAULT 1;" 
"" 
"  /* If we call insert_into_routines twice (for parameters then for body), then token_number > 1. */" 
"  SET v_token_number = (SELECT COUNT(*) FROM xxxmdbug.tokens) + 1;" 
"" 
"  /* If it's from param_list then is_body=0 and line number should always be 0. */" 
"  IF is_body = 0 THEN" 
"    SET current_line_number=0; SET token_line_number=0;" 
"  ELSE" 
"    SET current_line_number=1; SET token_line_number=1;" 
"    END IF;" 
"  SET token='';" 
"  SET last_was_operator=1;" 
"start_of_while:" 
"  WHILE i <= CHAR_LENGTH(body) DO" 
"    SET @xxxmdbug_char = SUBSTRING(body FROM i FOR 1);" 
"    IF @xxxmdbug_char  = '.' THEN"
"      /* A '.' followed by a digit or preceded by a number is treated" 
"         as part of a token. Otherwise it will be seen" 
"         later as a one-byte token. */" 
"      SET first_char_in_token = LEFT(token,1);"
"      IF (first_char_in_token BETWEEN '0' AND '9' OR first_char_in_token IN ('-','+'))" 
"      OR SUBSTRING(body FROM i +1 FOR 1)   BETWEEN '0' AND '9' THEN"
"        SET token = CONCAT(token,@xxxmdbug_char);" 
"        SET i = i + 1;" 
"        ITERATE start_of_while;" 
"        END IF;" 
"      END IF;" 
"    IF (@xxxmdbug_char = '+' OR @xxxmdbug_char = '-')" 
"    AND SUBSTRING(body FROM i-1 FOR 1)  = 'e' THEN"
"      /* A '+'  or '-' preceded by 'e' and preceded by a number is treated" 
"         as part of a token. Otherwise it will be seen" 
"         later as a one-byte token. */" 
"      SET first_char_in_token = LEFT(token,1);" 
"      IF (first_char_in_token   BETWEEN '0' AND '9' OR first_char_in_token IN ('-','+','.'))"
"      AND SUBSTRING(body FROM i+1 FOR 1)   BETWEEN '0' AND '9' THEN"
"        SET token = CONCAT(token,@xxxmdbug_char);" 
"        SET i = i + 1;" 
"        ITERATE start_of_while;" 
"        END IF;" 
"      END IF;" 
"    IF @xxxmdbug_char   IN ('`',CHAR(39),'\"') THEN"
"      /* ` and ' and \" are used to enclose strings." 
"         A double occurrence of the enclosing character," 
"         such as \"xxx\"\"yyy\", may occur." 
"         Newline, CHAR(10), may occur." 
"         { and } enclose an ODBC-like literal. */" 
"      IF @xxxmdbug_char   = '{' THEN"
"        SET @xxxmdbug_end_char = '}';" 
"        ELSE SET @xxxmdbug_end_char = @xxxmdbug_char;" 
"        END IF;" 
"      IF CHAR_LENGTH(token)>0 THEN" 
"        INSERT INTO xxxmdbug.tokens VALUES (mysql_proc_db, mysql_proc_name, 'ROUTINE', v_token_number,token_offset,token_line_number,token);" 
"        SET v_token_number=v_token_number+1;" 
"        END IF;" 
"      SET token = @xxxmdbug_char;" 
"      SET token_offset = i;" 
"      SET token_line_number = current_line_number;" 
"      SET i = i + 1;" 
"start_of_loop:" 
"      LOOP" 
"        SET @xxxmdbug_char_in_string = SUBSTRING(body FROM i FOR 1);" 
"        SET token = CONCAT(token,@xxxmdbug_char_in_string);" 
"        SET i = i + 1;" 
"        IF @xxxmdbug_char_in_string = CHAR(10) THEN" 
"          IF is_body = 1 THEN SET current_line_number = current_line_number + 1; END IF;" 
"          END IF;" 
"        IF @xxxmdbug_char_in_string   = @xxxmdbug_end_char THEN"
"           IF SUBSTRING(body FROM i FOR 1)   <> @xxxmdbug_char THEN"
"             LEAVE start_of_loop;" 
"             END IF;" 
"           SET token = CONCAT(token,@xxxmdbug_char_in_string);" 
"           SET i = i + 1;" 
"           END IF;" 
"        IF i > CHAR_LENGTH(body) THEN" 
"          LEAVE start_of_loop;" 
"          END IF;" 
"        END LOOP;" 
"      INSERT INTO xxxmdbug.tokens VALUES (mysql_proc_db, mysql_proc_name, 'ROUTINE', v_token_number,token_offset,token_line_number,token);" 
"      SET v_token_number=v_token_number+1;" 
"      SET token = '';" 
"      SET token_offset = i;" 
"      SET token_line_number = current_line_number;" 
"      ITERATE start_of_while;" 
"      END IF;" 
"" 
"    SET @xxxmdbug_2_chars = SUBSTRING(body FROM i FOR 2);" 
"    IF @xxxmdbug_2_chars  = '/*' THEN"
"      /* Inline comments are ignored and do not end current tokens. Todo: Actually inline comments are whitespace in MySQL. */" 
"      WHILE SUBSTRING(body FROM i FOR 2)  <> '*/' AND i<= CHAR_LENGTH(body) DO"
"        IF SUBSTRING(body FROM 1 FOR 1)  = CHAR(10) THEN"
"          IF is_body=1 THEN SET current_line_number = current_line_number + 1; END IF;" 
"          END IF;" 
"        SET i = i + 1;" 
"        END WHILE;" 
"      SET i = i + 2;" 
"      ITERATE start_of_while;" 
"      END IF;" 
"" 
"    IF @xxxmdbug_char IN ('-','+')" 
"    AND token=''" 
"    AND last_was_operator=1" 
"    AND SUBSTRING(body FROM i+1 FOR 1)   BETWEEN '0' AND '9' THEN"
"      /* We don't detect all cases of unary - or unary +," 
"         but we can see (operator) (+-) (digit) which is enough. */" 
"      SET is_unary=1;" 
"    ELSE" 
"      SET is_unary=0;" 
"      END IF;" 
"" 
"    IF @xxxmdbug_char   IN ('<','>','!','%','&','(',')','*','+',',','-',';',"
"                 ':','/','=','[',']','^','|','~','?','.','@',CHAR(92))" 
"    AND is_unary=0 THEN" 
"      /* A one-byte token e.g. < may actually be the start of" 
"         a two-byte token e.g. <= or even a three-byte token <=>. */" 
"      IF CHAR_LENGTH(token)>0 THEN" 
"        INSERT INTO xxxmdbug.tokens VALUES (mysql_proc_db, mysql_proc_name, 'ROUTINE', v_token_number,token_offset,token_line_number,token);" 
"        SET v_token_number=v_token_number+1;" 
"        END IF;" 
"      SET token_offset = i;" 
"      SET token_line_number = current_line_number;" 
"      IF @xxxmdbug_2_chars  IN ('&&',':=','<=','>=','<<','>>','<>','||','!=','@@') THEN"
"        SET @xxxmdbug_3_chars  = SUBSTRING(body FROM i FOR 3);"
"        IF @xxxmdbug_3_chars  = '<=>' THEN"
"          SET token = @xxxmdbug_3_chars;" 
"          SET i = i + 3;" 
"        ELSE" 
"          SET token = @xxxmdbug_2_chars;" 
"          SET i = i + 2;" 
"        END IF;" 
"      ELSE" 
"        SET token = @xxxmdbug_char;" 
"        SET i = i + 1;" 
"        END IF;" 
"      /* '@' causes end of previous token, but @ and @@" 
"         are not themselves tokens, only starts of tokens. */" 
"      IF @xxxmdbug_char  <> '@' THEN"
"        SET last_was_operator=1;" 
"        INSERT INTO xxxmdbug.tokens VALUES (mysql_proc_db, mysql_proc_name, 'ROUTINE', v_token_number,token_offset,token_line_number,token);" 
"        SET v_token_number=v_token_number+1;" 
"        SET token='';" 
"        SET token_offset = i;" 
"        SET token_line_number = current_line_number;" 
"        END IF;" 
"    ELSE" 
"      SET last_was_operator=0;" 
"      IF ASCII(@xxxmdbug_char)<=32 THEN" 
"        /* A character less than or equal to ascii(32) is" 
"           white space. */" 
"        IF CHAR_LENGTH(token)>0 THEN" 
"          INSERT INTO xxxmdbug.tokens VALUES (mysql_proc_db, mysql_proc_name, 'ROUTINE', v_token_number,token_offset,token_line_number,token);" 
"          SET v_token_number=v_token_number+1;" 
"          END IF;" 
"        /* Newline, CHAR(10), is whitespace that can affect line number. */" 
"        IF @xxxmdbug_char  = CHAR(10) THEN"
"          IF is_body=1 THEN SET current_line_number = current_line_number + 1; END IF;" 
"          END IF;" 
"        SET token = '';" 
"        SET i = i + 1;" 
"        SET token_offset = i;" 
"        SET token_line_number = current_line_number;" 
"      ELSE" 
"        /* Any non-special character is part of a token. */" 
"        SET token = CONCAT(token,@xxxmdbug_char);" 
"        SET i = i + 1;" 
"        END IF;" 
"      END IF;" 
"    END WHILE;" 
"  IF CHAR_LENGTH(token)>0 THEN" 
"    INSERT INTO xxxmdbug.tokens VALUES (mysql_proc_db, mysql_proc_name, 'ROUTINE', v_token_number,token_offset,token_line_number,token);" 
"    SET v_token_number=v_token_number+1;" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/*" 
"  Token linked list:" 
"  8 length(of value)" 
"  8 offset i.e. character number within body" 
"  8 line number" 
"  n value" 
"  so the size of an entry is always 24 + length(of value) */" 
"CREATE PROCEDURE xxxmdbug.insert_into_linked_list (token_offset INT," 
"                                          token_line_number INT," 
"                                          token VARCHAR(21000) CHARACTER SET utf8," 
"                                          INOUT linked_list VARCHAR(21000) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE field_for_length VARCHAR(8) CHARACTER SET utf8;" 
"  DECLARE field_for_offset VARCHAR(8) CHARACTER SET utf8;" 
"  DECLARE field_for_line_number VARCHAR(8) CHARACTER SET utf8;" 
"  SET field_for_length=LENGTH(token);" 
"  SET field_for_length=RPAD(field_for_length,8,' ');" 
"  SET field_for_offset=token_offset;" 
"  SET field_for_offset=RPAD(field_for_offset,8,' ');" 
"  SET field_for_line_number=token_line_number;" 
"  SET field_for_line_number=RPAD(field_for_line_number,8,' ');" 
"  SET linked_list=CONCAT(linked_list,field_for_length,field_for_offset,field_for_line_number,token);" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.update_linked_list (pos INT," 
"                                          token VARCHAR(21000) CHARACTER SET utf8," 
"                                          INOUT linked_list VARCHAR(21000) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE len INT;" 
"  SET len = LEFT(SUBSTRING(linked_list FROM pos FOR 8),8);" 
"  SET linked_list = INSERT(linked_list,pos+24,len,LEFT(token,len));" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Suppose you make a linked list with insert_into_tokens_linked_list." 
"   Now you can get out the nth item in the list by passing (linked list, n)." 
"   The return will be blank if n > number of items. */" 
"CREATE PROCEDURE xxxmdbug.get_from_linked_list (linked_list VARCHAR(21000) CHARACTER SET utf8," 
"                                                           token_number INT," 
"                                                           OUT token_value VARCHAR(8192) CHARACTER SET utf8," 
"                                                           OUT p_token_value_offset INT)" 
"BEGIN" 
"  DECLARE i INT;" 
"  DECLARE token_value_offset INT;" 
"  DECLARE token_value_length INT;" 
"  SET token_value_offset = -23; /* i.e. 24 - 1 */" 
"  SET i = 1;" 
"  SET token_value_length = 0;" 
"  x: LOOP" 
"    SET token_value_offset = token_value_offset + 24 + token_value_length;" 
"    IF token_value_offset >= LENGTH(linked_list) THEN LEAVE x; END IF;" 
"    SET token_value_length = SUBSTRING(linked_list FROM token_value_offset FOR 8);" 
"    IF i = token_number THEN LEAVE x; END IF;" 
"    SET i = i + 1;" 
"    END LOOP;" 
"  IF token_value_offset >= LENGTH(linked_list) THEN" 
"    SET token_value = '';" 
"  ELSE" 
"    SET token_value = SUBSTRING(linked_list FROM token_value_offset+24 FOR token_value_length);" 
"    END IF;" 
"  SET p_token_value_offset=token_value_offset;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Suppose you make a linked list with insert_into_tokens_linked_list." 
"   Now you can remove the nth item in the list by passing (linked list, n)." 
"   The result is okay even if n > number of items. */" 
"CREATE PROCEDURE xxxmdbug.delete_from_linked_list (INOUT linked_list VARCHAR(21000) CHARACTER SET utf8," 
"                                                           token_number INT)" 
"BEGIN" 
"  DECLARE i INT;" 
"  DECLARE token_value_offset INT;" 
"  DECLARE token_value_length INT;" 
"  SET token_value_offset = -23; /* i.e. 24 - 1 */" 
"  SET i = 1;" 
"  SET token_value_length = 0;" 
"  x: LOOP" 
"    SET token_value_offset = token_value_offset + 24 + token_value_length;" 
"    IF token_value_offset >= LENGTH(linked_list) THEN LEAVE x; END IF;" 
"    SET token_value_length = SUBSTRING(linked_list FROM token_value_offset FOR 8);" 
"    IF i = token_number THEN LEAVE x; END IF;" 
"    SET i = i + 1;" 
"    END LOOP;" 
"  IF token_value_offset >= LENGTH(linked_list) THEN" 
"    BEGIN END;" 
"  ELSE" 
"    SET @xxxmdbug_part1 = LEFT(linked_list,token_value_offset+1);"
"    SET @xxxmdbug_part2 = RIGHT(linked_list,LENGTH(linked_list)-((token_value_offset+1)+token_value_length+24));"
"    SET linked_list=CONCAT(@xxxmdbug_part1,@xxxmdbug_part2);" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* insert_into_tokens_linked_list" 
"  This will call insert_into_linked_list rather than INSERT INTO TOKENS." 
"  This might be more useful than insert_into_tokens because, since output is to memory not to table, we:" 
"  * avoid changing diagnostics" 
"  * avoid having a different routine for each time." 
"  NB: we're appending to the linked list, so when you want a new one, clear it first." 
"  Todo: replace insert_into_tokens by writing to linked list first, then copying linked list to tokens table" 
"*/" 
"/* We can call this during setup, but also during icc_process_user_command. */" 
"CREATE PROCEDURE xxxmdbug.insert_into_tokens_linked_list (body VARCHAR(21000) CHARACTER SET utf8," 
"                                                          INOUT linked_list VARCHAR(21000) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE i INT DEFAULT 1;" 
"  DECLARE current_line_number INT DEFAULT 1;" 
"  DECLARE token_offset INT DEFAULT 1;" 
"  DECLARE token_line_number INT default 1;" 
"  DECLARE token VARCHAR(21000) CHARACTER SET utf8;" 
"  DECLARE first_char_in_token CHAR CHARACTER SET utf8;" 
"  DECLARE last_was_operator INT;" 
"  DECLARE is_unary INT;" 
"  DECLARE is_body INT DEFAULT 1;"
"" 
"  SET token='';" 
"  SET last_was_operator=1;" 
"start_of_while:" 
"  WHILE i <= CHAR_LENGTH(body) DO" 
"    SET @xxxmdbug_char = SUBSTRING(body FROM i FOR 1);" 
"    IF @xxxmdbug_char = '.' THEN" 
"      /* A '.' followed by a digit or preceded by a number is treated" 
"         as part of a token. Otherwise it will be seen" 
"         later as a one-byte token. */" 
"      SET first_char_in_token = LEFT(token,1);" 
"      IF (first_char_in_token   BETWEEN '0' AND '9' OR first_char_in_token   IN ('-','+'))"
"      OR SUBSTRING(body FROM i+1 FOR 1)   BETWEEN '0' AND '9' THEN"
"        SET token = CONCAT(token,@xxxmdbug_char);" 
"        SET i = i + 1;" 
"        ITERATE start_of_while;" 
"        END IF;" 
"      END IF;" 
"    IF (@xxxmdbug_char = '+' OR @xxxmdbug_char = '-')" 
"    AND SUBSTRING(body FROM i-1 FOR 1)   = 'e' THEN"
"      /* A '+'  or '-' preceded by 'e' and preceded by a number is treated" 
"         as part of a token. Otherwise it will be seen" 
"         later as a one-byte token. */" 
"      SET first_char_in_token = LEFT(token,1);" 
"      IF (first_char_in_token  BETWEEN '0' AND '9' OR first_char_in_token   IN ('-','+','.'))"
"      AND SUBSTRING(body FROM i+1 FOR 1)   BETWEEN '0' AND '9' THEN"
"        SET token = CONCAT(token,@xxxmdbug_char);" 
"        SET i = i + 1;" 
"        ITERATE start_of_while;" 
"        END IF;" 
"      END IF;" 
"    IF @xxxmdbug_char   IN ('`',CHAR(39),'\"') THEN"
"      /* ` and ' and \" are used to enclose strings." 
"         A double occurrence of the enclosing character," 
"         such as \"xxx\"\"yyy\", may occur." 
"         Newline, CHAR(10), may occur." 
"         { and } enclose an ODBC-like literal. */" 
"      IF @xxxmdbug_char  = '{' THEN"
"        SET @xxxmdbug_end_char = '}';" 
"        ELSE SET @xxxmdbug_end_char = @xxxmdbug_char;" 
"        END IF;" 
"      IF CHAR_LENGTH(token)>0 THEN" 
"        CALL xxxmdbug.insert_into_linked_list(token_offset,token_line_number,token,linked_list);" 
"        END IF;" 
"      SET token = @xxxmdbug_char;" 
"      SET token_offset = i;" 
"      SET token_line_number = current_line_number;" 
"      SET i = i + 1;" 
"start_of_loop:" 
"      LOOP" 
"        SET @xxxmdbug_char_in_string = SUBSTRING(body FROM i FOR 1);"
"        SET token = CONCAT(token,@xxxmdbug_char_in_string);" 
"        SET i = i + 1;" 
"        IF @xxxmdbug_char_in_string  = CHAR(10) THEN"
"          IF is_body = 1 THEN SET current_line_number = current_line_number + 1; END IF;" 
"          END IF;" 
"        IF @xxxmdbug_char_in_string  = @xxxmdbug_end_char THEN"
"           IF SUBSTRING(body FROM i FOR 1)  <> @xxxmdbug_char THEN"
"             LEAVE start_of_loop;" 
"             END IF;" 
"           SET token = CONCAT(token,@xxxmdbug_char_in_string);" 
"           SET i = i + 1;" 
"           END IF;" 
"        IF i > CHAR_LENGTH(body) THEN" 
"          LEAVE start_of_loop;" 
"          END IF;" 
"        END LOOP;" 
"      CALL xxxmdbug.insert_into_linked_list(token_offset,token_line_number,token,linked_list);" 
"      SET token = '';" 
"      SET token_offset = i;" 
"      SET token_line_number = current_line_number;" 
"      ITERATE start_of_while;" 
"      END IF;" 
"" 
"    SET @xxxmdbug_2_chars = SUBSTRING(body FROM i FOR 2);" 
"    IF @xxxmdbug_2_chars = '/*' THEN" 
"      /* Inline comments are ignored and do not end current tokens. Todo: Actually inline comments are whitespace in MySQL. */" 
"      WHILE SUBSTRING(body FROM i FOR 2)  <> '*/' AND i<= CHAR_LENGTH(body) DO"
"        IF SUBSTRING(body FROM 1 FOR 1)  = CHAR(10) THEN"
"          IF is_body=1 THEN SET current_line_number = current_line_number + 1; END IF;" 
"          END IF;" 
"        SET i = i + 1;" 
"        END WHILE;" 
"      SET i = i + 2;" 
"      ITERATE start_of_while;" 
"      END IF;" 
"" 
"    IF @xxxmdbug_char   IN ('-','+')"
"    AND token =''"
"    AND last_was_operator=1" 
"    AND SUBSTRING(body FROM i+1 FOR 1)   BETWEEN '0' AND '9' THEN"
"      /* We don't detect all cases of unary - or unary +," 
"         but we can see (operator) (+-) (digit) which is enough. */" 
"      SET is_unary=1;" 
"    ELSE" 
"      SET is_unary=0;" 
"      END IF;" 
"" 
"    IF @xxxmdbug_char   IN ('<','>','!','%','&','(',')','*','+',',','-',';',"
"                 ':','/','=','[',']','^','|','~','?','.','@',CHAR(92))" 
"    AND is_unary=0 THEN" 
"      /* A one-byte token e.g. < may actually be the start of" 
"         a two-byte token e.g. <= or even a three-byte token <=>. */" 
"      IF CHAR_LENGTH(token)>0 THEN" 
"        CALL xxxmdbug.insert_into_linked_list(token_offset,token_line_number,token,linked_list);" 
"        END IF;" 
"      SET token_offset = i;" 
"      SET token_line_number = current_line_number;" 
"      IF @xxxmdbug_2_chars   IN ('&&',':=','<=','>=','<<','>>','<>','||','!=','@@') THEN"
"        SET @xxxmdbug_3_chars = SUBSTRING(body FROM i FOR 3);" 
"        IF @xxxmdbug_3_chars   = '<=>' THEN"
"          SET token = @xxxmdbug_3_chars;" 
"          SET i = i + 3;" 
"        ELSE" 
"          SET token = @xxxmdbug_2_chars;" 
"          SET i = i + 2;" 
"        END IF;" 
"      ELSE" 
"        SET token = @xxxmdbug_char;" 
"        SET i = i + 1;" 
"        END IF;" 
"      /* '@' causes end of previous token, but @ and @@" 
"         are not themselves tokens, only starts of tokens. */" 
"      IF @xxxmdbug_char  <> '@' THEN"
"        SET last_was_operator=1;" 
"        CALL xxxmdbug.insert_into_linked_list(token_offset,token_line_number,token,linked_list);" 
"        SET token='';" 
"        SET token_offset = i;" 
"        SET token_line_number = current_line_number;" 
"        END IF;" 
"    ELSE" 
"      SET last_was_operator=0;" 
"      IF ASCII(@xxxmdbug_char)<=32 THEN" 
"        /* A character less than or equal to ascii(32) is" 
"           white space. */" 
"        IF CHAR_LENGTH(token)>0 THEN" 
"          CALL xxxmdbug.insert_into_linked_list(token_offset,token_line_number,token,linked_list);" 
"          END IF;" 
"        /* Newline, CHAR(10), is whitespace that can affect line number. */" 
"        IF @xxxmdbug_char   = CHAR(10) THEN"
"          IF is_body=1 THEN SET current_line_number = current_line_number + 1; END IF;" 
"          END IF;" 
"        SET token = '';" 
"        SET i = i + 1;" 
"        SET token_offset = i;" 
"        SET token_line_number = current_line_number;" 
"      ELSE" 
"        /* Any non-special character is part of a token. */" 
"        SET token = CONCAT(token,@xxxmdbug_char);" 
"        SET i = i + 1;" 
"        END IF;" 
"      END IF;" 
"    END WHILE;" 
"  IF CHAR_LENGTH(token)>0 THEN" 
"    CALL xxxmdbug.insert_into_linked_list(token_offset,token_line_number,token,linked_list);" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Current schema.routine = end of call stack. If that is empty, try result of 'debug routine'. */" 
"/* todo: get type */" 
"CREATE PROCEDURE xxxmdbug.get_current_schema_identifier_and_routine_identifier" 
"(OUT p_schema_identifier VARCHAR(66) CHARACTER SET utf8," 
" OUT p_routine_identifier VARCHAR(66) CHARACTER SET utf8," 
" OUT p_routine_type VARCHAR(66) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_location VARCHAR(139) CHARACTER SET utf8; /* 66+66+1+6 */" 
"  DECLARE v_schema VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine VARCHAR(66) CHARACTER SET utf8;" 
"" 
"  IF @xxxmdbug_call_stack ='' THEN"
"    SET v_schema=@xxxmdbug_schema;" 
"    SET v_routine=@xxxmdbug_routine;" 
"  ELSE " 
"    SET v_location = RIGHT(@xxxmdbug_call_stack,66+66+1+6); /* call stack top = schema and name */" 
"    SET v_schema=TRIM(LEFT(v_location,66));" 
"    SET v_routine=TRIM(SUBSTRING(v_location FROM 66 FOR 66));" 
"    END IF;" 
"  IF v_schema IS NULL THEN SET v_schema = 'unknown'; END IF;" 
"  IF v_routine IS NULL THEN SET v_routine = 'unknown'; END IF;" 
"  SET p_routine_identifier = v_routine; " 
"  SET p_schema_identifier = v_schema;" 
"  SET p_routine_type = 'ROUTINE';" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* When a command is considered \"done\", we call icc_change_statement_status() so that it will" 
"   change @xxxmdbug_status_last_command_result to 'Fail' or 'OK' etc., and increment @xxxmdbug_commands_count." 
"   These values will be visible via 'information status'." 
"   For 'continue' 'exit' 'leave' 'skip' 'step','next' we have to say 'OK' every time so we do that early." 
"   For 'execute' and 'set' we might declare 'fail' even though the debugger has done its bit, it's the DBMS that's rejecting." 
"   This can be called from (generated) icc_core, debuggee_wait_loop, icc_process_user_command..., is_debuggee_and_is_attached. */" 
"CREATE PROCEDURE xxxmdbug.icc_change_statement_status (last_command_result VARCHAR(128) CHARACTER SET utf8)" 
"BEGIN" 
"  SET @xxxmdbug_status_last_command_result = last_command_result;" 
"  SET @xxxmdbug_commands_count = @xxxmdbug_commands_count + 1;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Whenever the debuggee reaches a debuggable statement, it sends a status message. For example" 
"    THE MDBUG CORE DEBUGGER Version 0.2" 
"    Status 2012-12-12 12:12:12" 
"    Datetime = 2012-12-12 12:12:12" 
"    Location = test.p1 line 4" 
"    At breakpoint = NO" 
"    Last command = 'b 4'" 
"    Last command result = OK" 
"   This is sent for each statement, not for each command." 
"   This is sent for each statement, not for each statement that's at a breakpoint." 
"   The debugger isn't waiting for this message, but can call command('i status') any time." 
"   The debugger isn't expected to remove this message, the debuggee will overwrite it." 
"   Todo: knowing byte-start and byte-end for both statement and line would help displays. */" 
"CREATE PROCEDURE xxxmdbug.icc_send_statement_status (called_from VARCHAR(20) CHARACTER SET utf8)" 
"BEGIN" 
"  /* Erase any earlier messages from debuggee to debugger" 
"     ?? Maybe there's more than one, left over from an earlier round? */" 
"  DECLARE v_status_message VARCHAR(500) CHARACTER SET utf8;" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8; /* sizeof('xxxmdbug_' + xxxmdbug_channel) + 'C ' + room to grow */" 
"" 
"  DECLARE v_at_breakpoint VARCHAR(3) CHARACTER SET utf8;" 
"  DECLARE v_at_tbreakpoint VARCHAR(3) CHARACTER SET utf8;" 
"  DECLARE v_at_routine_exit VARCHAR(3) CHARACTER SET utf8;" 
"  DECLARE v_stack_depth INT;" 
"  DECLARE v_message_start INT;" 
"  DECLARE v_schema VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_type VARCHAR(10) CHARACTER SET utf8; /* todo: use this */" 
"" 
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_statement_status); /* 'R ' */" 
"  CALL xxxmdbug.dbms_pipe_receive(v_prefix,1,@xxxmdbug_x,v_message_start);" 
"" 
"  SET v_stack_depth=LENGTH(@xxxmdbug_call_stack)/(66+66+1+6);" 
"" 
"  CALL xxxmdbug.get_current_schema_identifier_and_routine_identifier(v_schema,v_routine,v_routine_type);" 
"  IF v_routine IS NULL THEN" 
"    signal sqlstate '05678' set mysql_errno=@xxxmdbug_signal_errno,message_text='assert.icc_send_statement_status';" 
"    end if;" 
"  SET v_at_breakpoint = CASE WHEN @xxxmdbug_status_breakpoint_check_result > 0 THEN 'yes' ELSE 'no' END;" 
"  SET v_at_tbreakpoint = CASE WHEN @xxxmdbug_status_breakpoint_check_result = 2 THEN 'yes' ELSE 'no' END;" 
"" 
"  SET v_at_routine_exit='no';" 
"  IF called_from   = 'routine_exit' THEN"
"    SET v_at_breakpoint = 'no';" 
"    SET v_at_tbreakpoint = 'no';" 
"    SET v_at_routine_exit = 'yes';" 
"    END IF;" 
"  SET @xxxmdbug_number_of_last_status_message=@xxxmdbug_number_of_last_status_message+1;" 
"  SET v_status_message = CONCAT('''',@xxxmdbug_debugger_name,''','," 
"                                '''',@xxxmdbug_debugger_version,''','," 
"                                '''',CURRENT_TIMESTAMP,''','," 
"                                '''',@xxxmdbug_number_of_last_status_message,''','," 
"                                '''',@xxxmdbug_icc_count,''','," 
"                                '''',v_schema,''','," 
"                                '''',v_routine,''','," 
"                                '''',@xxxmdbug_status_line_number,''','," 
"                                '''',v_at_breakpoint,''','," 
"                                '''',v_at_tbreakpoint,''','," 
"                                '''',v_at_routine_exit,''','," 
"                                '''',v_stack_depth,''','," 
"                                '''',HEX(@xxxmdbug_status_last_command),''','," 
"                                '''',HEX(@xxxmdbug_status_last_command_result),''','," 
"                                '''',@xxxmdbug_commands_count,'''');" 
"  CALL xxxmdbug.dbms_pipe_send(v_prefix,v_status_message);" 
"  if v_status_message is null then signal sqlstate '05678' set mysql_errno=@xxxmdbug_signal_errno,message_text='assert.icc_send_statement_status'; end if;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Return 1 if token is all digits or - or . else return 0." 
"   This isn't as good as get_token_type() but it won't cause warnings, so debuggee can invoke it. */" 
"CREATE FUNCTION xxxmdbug.isnumeric (break_token VARCHAR(66) CHARACTER SET utf8) RETURNS INT DETERMINISTIC "
"BEGIN" 
"  DECLARE c CHAR CHARACTER SET utf8;" 
"  DECLARE i INT DEFAULT 1;" 
"  WHILE i <= LENGTH(break_token) DO" 
"    SET c = SUBSTRING(break_token FROM i FOR 1);" 
"    IF (c  < '0' OR c  > '9') AND c  <> '.' AND c  <> '-' THEN RETURN 0; END IF;"
"    SET i = i + 1;" 
"    END WHILE;" 
"  RETURN 1;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* todo: syntax must allow type */" 
"/* break. expect \"break|tbreak [[schema_identifier.]routine_identifier] line_number_minimum[-line_number_maximum] [variable=value]\". */" 
"/* 'clear' comes through here too, with the same expected clauses */" 
"CREATE PROCEDURE xxxmdbug.icc_process_user_command_break ()" 
"BEGIN" 
"  DECLARE break_token_number INT;" 
"  DECLARE break_is_bad_syntax INT;" 
"  DECLARE break_token VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE break_token_offset INT;" 
"  /* DECLARE v_breakpoint_identifier INT DEFAULT 0; */" 
"  DECLARE v_schema_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_table_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_table_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_type VARCHAR(10) CHARACTER SET utf8 DEFAULT 'ROUTINE';" 
"  DECLARE v_line_number_minimum INT DEFAULT 0;" 
"  DECLARE v_table_line_number_minimum INT;" 
"  DECLARE v_line_number_maximum INT DEFAULT 0;" 
"  DECLARE v_table_line_number_maximum INT;" 
"  DECLARE v_condition_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_condition_operator VARCHAR(2) CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_condition_value VARCHAR(66) CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_hit_count INT DEFAULT 0;" 
"  DECLARE v_is_temporary INT DEFAULT 0;" 
"  DECLARE v_is_temporary_and_to_be_cleared INT DEFAULT 0;" 
"  DECLARE v_is_matching_location INT DEFAULT 0;" 
"  DECLARE v_is_matching_condition INT DEFAULT 0;" 
"  DECLARE v_call_stack_depth_when_set INT DEFAULT 0;" 
"  /* DECLARE v_command VARCHAR(14) CHARACTER SET utf8 DEFAULT ''; */" 
"  DECLARE v_n INT;" 
"  DECLARE v_flags INT;" 
"  DECLARE v_row_count INT;" 
"  /* if it doesn't start with line_number, then it must be starting with [[schema_identifier.]routine_identifier] */" 
"" 
"  IF @xxxmdbug_token_value_1  = 'tbreakpoint' THEN SET v_is_temporary = 1; END IF;"
"" 
"  SET break_token_number = 2;" 
"  SET break_is_bad_syntax = 0;" 
"  CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list,break_token_number,break_token,break_token_offset);" 
"  CALL xxxmdbug.get_current_schema_identifier_and_routine_identifier(v_schema_identifier,v_routine_identifier,v_routine_type); /* default */" 
"" 
"  IF xxxmdbug.isnumeric(break_token) = 0 THEN /* If it's not an integer i.e. line number, it must be an identifier */" 
"    CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list,break_token_number+1,break_token,break_token_offset);" 
"    IF break_token  = '.' THEN"
"      CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list,break_token_number,v_schema_identifier,break_token_offset);" 
"      CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list,break_token_number+2,v_routine_identifier,break_token_offset);" 
"      SET break_token_number=break_token_number+3;" 
"    ELSE" 
"      CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list,break_token_number,v_routine_identifier,break_token_offset);" 
"      SET break_token_number=break_token_number+1;" 
"      END IF;" 
"    END IF;" 
"  CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list,break_token_number,break_token,break_token_offset);" 
"" 
"  IF xxxmdbug.isnumeric(break_token) = 0 THEN" 
"    SET break_is_bad_syntax = 1; /* Error! there has to be a line number */" 
"  ELSE" 
"    SET v_line_number_minimum = break_token;" 
"    CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list,break_token_number+1,break_token,break_token_offset);" 
"    IF break_token  = '-' THEN"
"      CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list,break_token_number+2,break_token,break_token_offset);" 
"      SET v_line_number_maximum = break_token;" 
"      SET break_token_number=break_token_number+3;" 
"    ELSE" 
"      SET v_line_number_maximum=v_line_number_minimum;" 
"      SET break_token_number=break_token_number+1;" 
"      END IF;" 
"    END IF;" 
"  SET v_condition_identifier='';" 
"  SET v_condition_operator='';" 
"  SET v_condition_value='';" 
"  CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list,break_token_number,v_condition_identifier,break_token_offset);" 
"  CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list,break_token_number+1,v_condition_operator,break_token_offset);" 
"  CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list,break_token_number+2,v_condition_value,break_token_offset);" 
"" 
"  IF v_condition_identifier  <> '' THEN"
"    IF v_condition_operator  <> '=' AND v_condition_operator  <> '<>' AND v_condition_operator  <> '<=' THEN"
"      SET break_is_bad_syntax = 1; /* Error! there has to be an '=' sign or a '<>' or a '<=' sign */" 
"      END IF;" 
"    IF v_condition_operator  = '<=' AND v_condition_identifier  <> 'CALL_STACK_DEPTH' THEN"
"      SET break_is_bad_syntax = 1; /* Error! Before '<=' the only allowed possibility is 'call_stack_depth */" 
"      END IF;" 
"    IF v_condition_operator  = '<>' AND v_condition_value  <> 'OLD' THEN"
"      SET break_is_bad_syntax = 1; /* Error! After '<>' the only allowed possibility is 'old' which I assume is followed by '.variable' */" 
"      END IF;" 
"    /* todo: more checks: value must a literal (except if operator is '<>' */" 
"    CALL xxxmdbug.add_delimiters(v_condition_identifier);" 
"    END IF;" 
"" 
"  SET v_call_stack_depth_when_set=LENGTH(@xxxmdbug_call_stack)/(66+66+1+6);" 
"" 
"  IF break_is_bad_syntax = 1 THEN" 
"    CALL xxxmdbug.icc_change_statement_status('Bad syntax');" 
"    END IF;" 
"" 
"  IF break_is_bad_syntax = 0 AND @xxxmdbug_token_value_1  = 'clear' THEN"
"    /* DELETE FROM breakpoints WHERE routine name and line numbers match; */" 
"    SET v_n=0; SET v_row_count=0;" 
"    xclear: LOOP" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_schema_identifier,80,v_n,v_table_schema_identifier,v_flags);" 
"      IF v_flags=-1 THEN LEAVE xclear; END IF;" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_routine_identifier,80,v_n,v_table_routine_identifier,v_flags);" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_line_number_minimum,10,v_n,v_table_line_number_minimum,v_flags);" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_line_number_maximum,10,v_n,v_table_line_number_maximum,v_flags);" 
"      IF v_table_schema_identifier COLLATE utf8_general_ci =v_schema_identifier"
"      AND v_table_routine_identifier=v_routine_identifier" 
"      AND v_table_line_number_minimum=v_line_number_minimum" 
"      AND v_table_line_number_maximum=v_line_number_maximum THEN" 
"        CALL xxxmdbug.breakpoint_delete(v_n);" 
"        SET v_row_count=v_row_count+1;" 
"        SET v_n=v_n-1;" 
"        END IF;" 
"      SET v_n=v_n+1;" 
"      END LOOP;" 
"    CALL xxxmdbug.icc_change_statement_status(CONCAT('OK, row_count()=',v_row_count));" 
"    END IF;" 
"" 
"  IF break_is_bad_syntax = 0 AND (@xxxmdbug_token_value_1  = 'breakpoint' OR @xxxmdbug_token_value_1  = 'tbreakpoint') THEN"
"    /* INSERT INTO breakpoints VALUES (" 
"       v_breakpoint_identifier," 
"       v_schema_identifier," 
"       v_routine_identifier," 
"       v_routine_type," 
"       v_line_number_minimum," 
"       v_line_number_maximum," 
"       v_condition_identifier," 
"       v_condition_operator," 
"       v_condition_value," 
"       v_hit_count," 
"       v_is_temporary," 
"       v_is_temporary_and_to_be_cleared," 
"       v_is_matching_location," 
"       v_is_matching_condition," 
"       v_call_stack_depth_when_set," 
"       @xxxmdbug_token_value_1); */" 
"      SET @xxxmdbug_breakpoints_last_insert_id=@xxxmdbug_breakpoints_last_insert_id+1;" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_breakpoint_identifier,10,@xxxmdbug_breakpoints_last_insert_id);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_schema_identifier,80,v_schema_identifier);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_routine_identifier,80,v_routine_identifier);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_routine_type,16,v_routine_type);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_line_number_minimum,10,v_line_number_minimum);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_line_number_maximum,10,v_line_number_maximum);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_condition_identifier,80,v_condition_identifier);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_condition_operator,10,v_condition_operator);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_condition_value,@xxxmdbug_value_length,v_condition_value);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_hit_count,10,v_hit_count);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_is_temporary,5,v_is_temporary);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_is_temporary_and_to_be_cleared,5,v_is_temporary_and_to_be_cleared);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_is_matching_location,5,v_is_matching_location);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_is_matching_condition,5,v_is_matching_condition);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_call_stack_depth_when_set,10,v_call_stack_depth_when_set);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_command,20,@xxxmdbug_token_value_1);" 
"    CALL xxxmdbug.icc_change_statement_status(CONCAT('OK, breakpoint_identifier=',@xxxmdbug_breakpoints_last_insert_id));" 
"    END IF;" 
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* icc_process_user_command_step_or_next() does what icc_process_user_command_break() does: adds a 'row' in breakpoints 'table'." 
"       'step' is the same as 'continue but stop on the next statement'," 
"       including a statement that we reach after going down into a function or called procedure." 
"       'next' is the same as 'continue but stop on the next statement'," 
"       but without going down into a function or called procedure (that would be 'step')." 
"       The value for call_stack_depth_when_set is calculated and stored in the breakpoints" 
"       table at the time the debuggee receives it, so it is only reliable if one says 'next'" 
"       while at a breakpoint.." 
"   The effect of 'step' is like 'tbreakpoint %.% 1-99999' followed by 'continue'." 
"   The effect of 'next' is like 'tbreakpoint %.% 1-99999 call_stack_depth<=call_stack_depth_when_set' followed by 'continue'." 
"   We actually create the temporary breakpoint, then check immediately afterward for breakpoints," 
"   so after 'step' or 'next' the information status will show we're stopped at a temporary breakpoint." 
"   Unlike gdb, 'step' does not go to the next line, it goes to the next iteration of the SQL statement, regardless of line number." 
"   Do not change statement status, it's changed already." 
"   Todo: We're not showing 'breakpoint_identifier=n' as we do for breakpoint/tbreakpoint -- should we do so?" 
"   Todo: We're setting the temporary breakpoint as starting at line 1, not line 0 -- I wonder if that's the right decision? */" 
"CREATE PROCEDURE xxxmdbug.icc_process_user_command_step_or_next ()" 
"BEGIN" 
"  DECLARE v_call_stack_depth_when_set INT;" 
"" 
"  SET v_call_stack_depth_when_set=LENGTH(@xxxmdbug_call_stack)/(66+66+1+6);" 
"  SET @xxxmdbug_breakpoints_last_insert_id=@xxxmdbug_breakpoints_last_insert_id+1;" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_breakpoint_identifier,10,@xxxmdbug_breakpoints_last_insert_id);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_schema_identifier,80,'%');" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_routine_identifier,80,'%');" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_routine_type,16,'ROUTINE');" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_line_number_minimum,10,1);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_line_number_maximum,10,99999);" 
"  IF @xxxmdbug_token_value_1 ='next' THEN"
"    CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_condition_identifier,80,'call_stack_depth');" 
"    CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_condition_operator,10,'<=');" 
"    CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_condition_value,@xxxmdbug_value_length,'call_stack_depth_when_set');" 
"  ELSE /* 'step' */" 
"    CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_condition_identifier,80,'');" 
"    CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_condition_operator,10,'');" 
"    CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_condition_value,@xxxmdbug_value_length,'');" 
"    END IF;" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_hit_count,10,0);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_is_temporary,5,1);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_is_temporary_and_to_be_cleared,5,0);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_is_matching_location,5,0);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_is_matching_condition,5,0);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_call_stack_depth_when_set,10,v_call_stack_depth_when_set);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_breakpoints_command,20,@xxxmdbug_token_value_1);" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.icc_process_user_command ()" 
"BEGIN" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_n INT;" 
"  DECLARE v_flags INT;" 
"  DECLARE v_table_breakpoint_identifier INT;" 
"  DECLARE v_row_count INT;" 
"" 
"  IF @xxxmdbug_token_value_1  = 'breakpoint' OR @xxxmdbug_token_value_1 = 'tbreakpoint' OR @xxxmdbug_token_value_1 = 'clear' THEN"
"    CALL xxxmdbug.icc_process_user_command_break();" 
"    END IF;" 
"  IF @xxxmdbug_token_value_1  = 'refresh' THEN"
"    IF @xxxmdbug_token_value_2 = 'call_stack' THEN" 
"      CALL xxxmdbug.icc_process_user_command_r_call_stack();" 
"      END IF;" 
"    IF @xxxmdbug_token_value_2  = 'breakpoints' THEN"
"      CALL xxxmdbug.icc_process_user_command_r_breakpoints();" 
"      END IF;" 
"    IF @xxxmdbug_token_value_2  = 'variables' THEN"
"      CALL xxxmdbug.icc_process_user_command_r_variables();" 
"      END IF;" 
"    IF @xxxmdbug_token_value_2  = 'server_variables' THEN"
"      CALL xxxmdbug.icc_process_user_command_r_server_variables();" 
"      END IF;" 
"    IF @xxxmdbug_token_value_2  = 'statements_executed' THEN"
"      CALL xxxmdbug.icc_process_user_command_r_statements_executed();" 
"      END IF;" 
"    IF @xxxmdbug_token_value_2  = 'prepared_statements' THEN"
"      CALL xxxmdbug.icc_process_user_command_r_prepared_statements();" 
"      END IF;" 
"    /* a check for user_variables is deliberately not here */" 
"    END IF;" 
"  IF @xxxmdbug_token_value_1  = 'set' THEN"
"    CALL xxxmdbug.icc_process_user_command_set();" 
"    END IF;" 
"  IF @xxxmdbug_token_value_1  = 'execute' THEN"
"    CALL xxxmdbug.icc_process_user_command_execute();" 
"    END IF;" 
"  IF @xxxmdbug_token_value_1  = 'delete' THEN"
"    /* DELETE FROM breakpoints WHERE breakpoint_identifier = @xxxmdbug_token_value_2; */" 
"    SET v_n=0; SET v_row_count=0;" 
"    xd: LOOP" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_breakpoint_identifier,10,v_n,v_table_breakpoint_identifier,v_flags);" 
"      IF v_flags=-1 THEN LEAVE xd; END IF;" 
"      IF v_table_breakpoint_identifier=@xxxmdbug_token_value_2 OR @xxxmdbug_token_value_2 IS NULL OR @xxxmdbug_token_value_2  = '' THEN"
"        CALL xxxmdbug.breakpoint_delete(v_n);" 
"        SET v_row_count=v_row_count+1;" 
"        /* LEAVE xd; would be appropriate here if I was saying 'delete n', but I might have said 'delete' i.e. delete all. */" 
"        SET v_n=v_n-1;" 
"        END IF;" 
"      SET v_n=v_n+1;" 
"      END LOOP;" 
"    CALL xxxmdbug.icc_change_statement_status(CONCAT('OK, row_count()=',v_row_count));" 
"    END IF;" 
"" 
"  IF @xxxmdbug_token_value_1  = 'debug' THEN"
"    CALL xxxmdbug.icc_change_statement_status('Failed, debug is already in progress');" 
"    END IF;" 
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Command 'r call_stack'" 
"   todo: watch for overflow of v_ret */" 
"CREATE PROCEDURE xxxmdbug.icc_process_user_command_r_call_stack ()" 
"BEGIN" 
"  DECLARE v_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_tmp_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_type VARCHAR(10) CHARACTER SET utf8;" 
"  DECLARE v_line_number INT;" 
"  DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_n INT;" 
"" 
"  SET v_n=0;" 
"  x: LOOP" 
"    SET v_schema_identifier=TRIM(SUBSTRING(@xxxmdbug_call_stack FROM 1+v_n*(66+66+1+6) FOR 66));" 
"    IF v_schema_identifier COLLATE utf8_general_ci ='' OR v_schema_identifier COLLATE utf8_general_ci IS NULL THEN LEAVE x; END IF;"
"    SET v_routine_identifier=TRIM(SUBSTRING(@xxxmdbug_call_stack FROM 1+v_n*(66+66+1+6)+66 FOR 66));" 
"    SET v_routine_type=SUBSTRING(@xxxmdbug_call_stack FROM 1+v_n*(66+66+1+6)+66+66 FOR 1);" 
"    SET v_line_number=SUBSTRING(@xxxmdbug_call_stack FROM 1+v_n*(66+66+1+6)+66+66+1 FOR 6);" 
"    /* John wanted line number of last call_stack item to be current line number */" 
"    SET v_n=v_n+1;" 
"    SET v_tmp_schema_identifier=TRIM(SUBSTRING(@xxxmdbug_call_stack FROM 1+v_n*(66+66+1+6) FOR 66));" 
"    IF v_tmp_schema_identifier COLLATE utf8_general_ci ='' OR v_tmp_schema_identifier COLLATE utf8_general_ci IS NULL THEN SET v_line_number=@xxxmdbug_status_line_number; END IF;"
"    SET v_ret=CONCAT(v_ret," 
"    '\"',v_schema_identifier,'\",'," 
"    '\"',v_routine_identifier,'\",'," 
"    '\"',v_routine_type,'\",'," 
"    '\"',v_line_number,'\";');" 
"    END LOOP;" 
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_call_stack); /* 'A ' */" 
"  CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);" 
"  CALL xxxmdbug.icc_change_statement_status('OK');" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Command 'r breakpoints'" 
"   todo: watch for overflow of v_ret */" 
"CREATE PROCEDURE xxxmdbug.icc_process_user_command_r_breakpoints ()" 
"BEGIN" 
"  DECLARE v_breakpoint_identifier INT;" 
"  DECLARE v_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_type VARCHAR(10) CHARACTER SET utf8;" 
"  DECLARE v_line_number_minimum INT;" 
"  DECLARE v_line_number_maximum INT;" 
"  DECLARE v_condition_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_condition_operator VARCHAR(2) CHARACTER SET utf8;" 
"  DECLARE v_condition_value VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_hit_count INT;" 
"  DECLARE v_is_temporary INT;" 
"  DECLARE v_is_temporary_and_to_be_cleared INT;" 
"  DECLARE v_is_matching_location INT;" 
"  DECLARE v_is_matching_condition INT;" 
"  DECLARE v_call_stack_depth_when_set INT;" 
"  DECLARE v_command VARCHAR(14) CHARACTER SET utf8;" 
"  DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';" 
"  /* DECLARE eof INT DEFAULT 0; */" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_n INT;" 
"  DECLARE v_flags INT;" 
"" 
"  /* TODO: ORDER BY */" 
"  /* DECLARE c CURSOR FOR SELECT * FROM breakpoints; */" 
"  /* DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1; */" 
"  /* OPEN c; */" 
"  SET v_n=0;" 
"  x: LOOP" 
"    /* FETCH c INTO " 
"       v_breakpoint_identifier," 
"       v_schema_identifier," 
"       v_routine_identifier," 
"       v_routine_type," 
"       v_line_number_minimum," 
"       v_line_number_maximum," 
"       v_condition_identifier," 
"       v_condition_operator," 
"       v_condition_value," 
"       v_hit_count," 
"       v_is_temporary," 
"       v_is_temporary_and_to_be_cleared," 
"       v_is_matching_location," 
"       v_is_matching_condition," 
"       v_call_stack_depth_when_set," 
"       v_command;" 
"       IF eof = 1 THEN LEAVE x; END IF; */" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_breakpoint_identifier,10,v_n,v_breakpoint_identifier,v_flags);" 
"    IF v_flags=-1 THEN LEAVE x; END IF;" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_schema_identifier,80,v_n,v_schema_identifier,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_routine_identifier,80,v_n,v_routine_identifier,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_routine_type,16,v_n,v_routine_type,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_line_number_minimum,10,v_n,v_line_number_minimum,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_line_number_maximum,10,v_n,v_line_number_maximum,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_condition_identifier,80,v_n,v_condition_identifier,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_condition_operator,10,v_n,v_condition_operator,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_condition_value,@xxxmdbug_value_length,v_n,v_condition_value,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_hit_count,10,v_n,v_hit_count,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_is_temporary,5,v_n,v_is_temporary,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_is_temporary_and_to_be_cleared,5,v_n,v_is_temporary_and_to_be_cleared,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_is_matching_location,5,v_n,v_is_matching_location,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_is_matching_condition,5,v_n,v_is_matching_condition,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_call_stack_depth_when_set,10,v_n,v_call_stack_depth_when_set,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_command,20,v_n,v_command,v_flags);" 
"" 
"    SET v_ret=CONCAT(v_ret," 
"    '\"',v_breakpoint_identifier,'\",'," 
"    '\"',v_schema_identifier,'\",'," 
"    '\"',v_routine_identifier,'\",'," 
"    '\"',v_routine_type,'\",'," 
"    '\"',v_line_number_minimum,'\",'," 
"    '\"',v_line_number_maximum,'\",'," 
"    '\"',v_condition_identifier,'\",'," 
"    '\"',v_condition_operator,'\",'," 
"    '\"',HEX(v_condition_value),'\",'," 
"    '\"',v_hit_count,'\",'," 
"    '\"',v_is_temporary,'\",'," 
"    '\"',v_is_temporary_and_to_be_cleared,'\",'," 
"    '\"',v_is_matching_location,'\",'," 
"    '\"',v_is_matching_condition,'\",'," 
"    '\"',v_call_stack_depth_when_set,'\",'," 
"    '\"',v_command,'\";');" 
"    SET v_n=v_n+1;" 
"    END LOOP;" 
"  /* CLOSE c; */" 
"  /* Send entire xxxmdbug.breakpoints back to debugger, which will insert it to xxxmdbug.breakpoints. */" 
"  if v_ret is null then signal sqlstate '05678' set mysql_errno=@xxxmdbug_signal_errno,message_text = 'assert. v_ret is null'; end if;" 
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_breakpoints); /* 'B ' */" 
"  CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);" 
"  CALL xxxmdbug.icc_change_statement_status('OK');" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* command = 'r statements_executed'" 
"   todo: watch for v_ret overflow */" 
"CREATE PROCEDURE xxxmdbug.icc_process_user_command_r_statements_executed ()" 
"BEGIN" 
"  DECLARE v_table_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_routine_type VARCHAR(10) CHARACTER SET utf8;" 
"  DECLARE v_table_number INT;" 
"  DECLARE v_table_caught_by_no_handler INT;" 
"  DECLARE v_table_caught_by_sqlwarning_handler INT;" 
"  DECLARE v_table_caught_by_sqlexception_handler INT;" 
"  DECLARE v_table_caught_by_not_found_handler INT;" 
"  DECLARE v_table_caught_by_user_written_handler INT;" 
"  DECLARE v_table_row_count INT;" 
"  DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';         /* todo: try TEXT */" 
"  /* DECLARE eof INT DEFAULT 0; */" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_n INT;" 
"  DECLARE v_flags INT;" 
"" 
"  /* TODO: ORDER BY */" 
"  /* DECLARE c CURSOR FOR SELECT * FROM statements_executed; */" 
"  /* DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1; */" 
"  /* OPEN c; */" 
"  SET v_n=0;" 
"  x: LOOP" 
"    /* FETCH c INTO " 
"    v_table_schema_identifier," 
"    v_table_routine_identifier," 
"    v_routine_type," 
"    v_table_number," 
"    v_number," 
"    v_caught_by_no_handler," 
"    v_caught_by_sqlwarning_handler," 
"    v_caught_by_sqlexception handler," 
"    v_caught_by_not_found_handler," 
"    v_caught_by_user_written_handler," 
"    v_row_count; */" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_statements_executed_schema_identifier,80,v_n,v_table_schema_identifier,v_flags);" 
"    IF v_flags = -1 THEN LEAVE x; END IF;" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_statements_executed_routine_identifier,80,v_n,v_table_routine_identifier,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_statements_executed_routine_type,16,v_n,v_table_routine_type,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_statements_executed_number,10,v_n,v_table_number,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_statements_executed_caught_by_no_handler,10,v_n,v_table_caught_by_no_handler,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_statements_executed_caught_by_sqlwarning_handler,10,v_n,v_table_caught_by_sqlwarning_handler,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_statements_executed_caught_by_sqlexception_handler,10,v_n,v_table_caught_by_sqlexception_handler,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_statements_executed_caught_by_not_found_handler,10,v_n,v_table_caught_by_not_found_handler,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_statements_executed_caught_by_user_written_handler,10,v_n,v_table_caught_by_user_written_handler,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_statements_executed_row_count,10,v_n,v_table_row_count,v_flags);" 
"    /* IF eof = 1 THEN LEAVE x; END IF; */" 
"    SET v_ret =CONCAT(v_ret,"
"    '\"',v_table_schema_identifier,'\",'," 
"    '\"',v_table_routine_identifier,'\",'," 
"    '\"',v_table_routine_type,'\",'," 
"    '\"',v_table_number,'\",'," 
"    '\"',v_table_caught_by_no_handler,'\",'," 
"    '\"',v_table_caught_by_sqlwarning_handler,'\",'," 
"    '\"',v_table_caught_by_sqlexception_handler,'\",'," 
"    '\"',v_table_caught_by_not_found_handler,'\",'," 
"    '\"',v_table_caught_by_user_written_handler,'\",'," 
"    '\"',v_table_row_count,'\";');" 
"    SET v_n=v_n+1;" 
"    END LOOP;" 
"  /* CLOSE c; */" 
"  /* Send entire xxxmdbug.statements_executed back to debugger, which will insert it to xxxmdbug.variables. */" 
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_statements_executed); /* 'X ' */" 
"  CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);" 
"  CALL xxxmdbug.icc_change_statement_status('OK');" 
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* command = 'r prepared_statements'" 
"   todo: watch for v_ret overflow */" 
"CREATE PROCEDURE xxxmdbug.icc_process_user_command_r_prepared_statements ()" 
"BEGIN" 
"  DECLARE v_table_statement_name VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_statement_text VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';         /* todo: try TEXT */" 
"  /* DECLARE eof INT DEFAULT 0; */" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_n INT;" 
"  DECLARE v_flags INT;" 
"" 
"  /* TODO: ORDER BY */" 
"  /* DECLARE c CURSOR FOR SELECT * FROM prepared_statements; */" 
"  /* DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1; */" 
"  /* OPEN c; */" 
"  SET v_n=0;" 
"  x: LOOP" 
"    /* FETCH c INTO " 
"    v_table_statement_name," 
"    v_table_statement_text; */" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_prepared_statements_statement_name,80,v_n,v_table_statement_name,v_flags);" 
"    IF v_flags = -1 THEN LEAVE x; END IF;" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_prepared_statements_statement_text,80,v_n,v_table_statement_text,v_flags);" 
"    /* IF eof = 1 THEN LEAVE x; END IF; */" 
"    SET v_ret=CONCAT(v_ret," 
"    '\"',v_table_statement_name,'\",'," 
"    '\"',HEX(v_table_statement_text),'\";');" 
"    SET v_n=v_n+1;" 
"    END LOOP;" 
"  /* CLOSE c; */" 
"  /* Send entire xxxmdbug.prepared_statements back to debugger, which will insert it to xxxmdbug.prepared_statements. */" 
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_prepared_statements); /* 'P ' */" 
"  CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);" 
"  CALL xxxmdbug.icc_change_statement_status('OK');" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* command = 'r variables'" 
"   todo: decide whether to select only what's in scope" 
"   todo: watch for v_ret overflow */" 
"CREATE PROCEDURE xxxmdbug.icc_process_user_command_r_variables ()" 
"BEGIN" 
"  DECLARE v_table_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_routine_type VARCHAR(10) CHARACTER SET utf8;" 
"  DECLARE v_table_token_number_of_declare INT;" 
"  DECLARE v_table_variable_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_data_type VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_value VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_old_value VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_is_in_scope INT;" 
"  DECLARE v_table_is_settable INT;" 
"  DECLARE v_table_is_updated_by_set INT;" 
"  DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';         /* todo: try TEXT */" 
"  /* DECLARE eof INT DEFAULT 0; */" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_n INT;" 
"  DECLARE v_flags INT;" 
"" 
"  /* TODO: ORDER BY */" 
"  /* DECLARE c CURSOR FOR SELECT * FROM variables; */" 
"  /* DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1; */" 
"  /* OPEN c; */" 
"  SET v_n=0;" 
"  x: LOOP" 
"    /* FETCH c INTO " 
"    v_table_schema_identifier," 
"    v_table_routine_identifier," 
"    v_table_routine_type," 
"    v_table_token_number_of_declare," 
"    v_table_variable_identifier," 
"    v_table_data_type," 
"    v_table_value," 
"    v_table_old_value," 
"    v_table_is_in_scope," 
"    v_table_is_settable," 
"    v_table_is_updated_by_set; */" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_schema_identifier,80,v_n,v_table_schema_identifier,v_flags);" 
"    IF v_flags = -1 THEN LEAVE x; END IF;" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_routine_identifier,80,v_n,v_table_routine_identifier,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_routine_type,80,v_n,v_table_routine_type,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_token_number_of_declare,10,v_n,v_table_token_number_of_declare,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_variable_identifier,80,v_n,v_table_variable_identifier,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_data_type,80,v_n,v_table_data_type,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_value,@xxxmdbug_value_length,v_n,v_table_value,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_old_value,@xxxmdbug_value_length,v_n,v_table_old_value,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_is_in_scope,5,v_n,v_table_is_in_scope,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_is_settable,5,v_n,v_table_is_settable,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_is_updated_by_set,5,v_n,v_table_is_updated_by_set,v_flags);" 
"    /* IF eof = 1 THEN LEAVE x; END IF; */" 
"    IF v_table_value IS NULL THEN SET v_table_value = 'null'; END IF;" 
"    IF v_table_old_value IS NULL THEN SET v_table_old_value = 'null'; END IF;" 
"    SET v_ret=CONCAT(v_ret," 
"    '\"',v_table_schema_identifier,'\",'," 
"    '\"',v_table_routine_identifier,'\",'," 
"    '\"',v_table_routine_type,'\",'," 
"    '\"',v_table_token_number_of_declare,'\",'," 
"    '\"',v_table_variable_identifier,'\",'," 
"    '\"',v_table_data_type,'\",'," 
"    '\"',HEX(v_table_value),'\",'," 
"    '\"',HEX(v_table_old_value),'\",'," 
"    '\"',v_table_is_in_scope,'\",'," 
"    '\"',v_table_is_settable,'\",'," 
"    '\"',v_table_is_updated_by_set,'\";');" 
"    SET v_n=v_n+1;" 
"    END LOOP;" 
"  /* CLOSE c; */" 
"  /* Send entire xxxmdbug.variables back to debugger, which will insert it to xxxmdbug.variables. */" 
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_variables); /* 'V ' */" 
"  CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);" 
"  CALL xxxmdbug.icc_change_statement_status('OK');" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
//strcpy(x,
//""
//"/* command = 'r server_variables'"
//"   This is generated by generate_icc_process_user_command_r_server_variables ()."
//"   So this is a stub which is commented out. */"
//"/*"
//"CREATE PROCEDURE xxxmdbug.icc_process_user_command_r_server_variables ()"
//"BEGIN"
//"  DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';"
//"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;"
//""
//"SET v_ret=CONCAT(v_ret,'\"@@ARIA_BLOCK_SIZE\",','\"',@@ARIA_BLOCK_SIZE,'\";');"
//"SET v_ret=CONCAT(v_ret,'\"@@ARIA_CHECKPOINT_INTERVAL\",','\"',@@ARIA_CHECKPOINT_INTERVAL,'\";');"
//"SET v_ret=CONCAT(v_ret,'\"@@ARIA_CHECKPOINT_LOG_ACTIVITY\",','\"',@@ARIA_CHECKPOINT_LOG_ACTIVITY,'\";');"
//"... and so on for about 350 items"
//"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_server_variables);"
//"  CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);"
//"  CALL xxxmdbug.icc_change_statement_status('OK');"
//"  END");

//if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;


/* command = 'r user_variables'
   This is do-nothing. If there are user variables, the variant generated icc_core happens. */
strcpy(x,
"CREATE PROCEDURE xxxmdbug.icc_process_user_command_r_user_variables () "
"BEGIN"
"  DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';"
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;"
"  SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_user_variables); /* 'U ' */"
"  CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);"
"  CALL xxxmdbug.icc_change_statement_status('OK');"
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* retype() is called from icc_process_user_command_set (when processing 'set'" 
"   for declared variables or user variables), and from generated icc_core" 
"   (when processing 'set' for user variables)." 
"   We know that @xxxmdbug_token_value_4 is the value that we will assign." 
"   If @xxxmdbug_token_value_4 was not passed within ''s, it must be a number." 
"   For a user variable, numbers are DOUBLE PRECISION or DECIMAL(65,30) or BIGINT(20)." 
"   We cannot use CAST() for a DOUBLE PRECISION, so we assign and reassign." 
"   In the end, @xxxmdbug_token_value_4 should have the type we want." 
"   This is necessary, otherwise assignments to server variables would fail" 
"   and assignments to user variables would succeed but as LONGTEXT." 
"   Rule summary:" 
"   * 'null' in quotes is LONGTEXT, null without quotes is NULL and LONGBLOB" 
"   * anything inside ''s or \"\"is LONGTEXT" 
"   * anything starting with 0x is LONGBLOB, we do our own conversion" 
"   * otherwise, DOUBLE if contains, DECIMAL if contains '.', BIGINT if nothing else." 
"   We use the same rules in compare(), for breakpoint condition comparisons." 
"   Return is @xxxmdbug_token_value_4a. */" 
"CREATE PROCEDURE xxxmdbug.retype ()" 
"retype:" 
"BEGIN" 
"  DECLARE i_double DOUBLE PRECISION; /* Float -> Double */" 
"  DECLARE i_decimal DECIMAL(65,30); /* DecimalNumeric -> Decimal */" 
"  DECLARE i_bigint BIGINT(20); /* Tinyint|Smallint|Int|MediumInt -> Bigint */" 
"  DECLARE i_longblob LONGBLOB;" 
"  DECLARE j,k,l INT;" 
"" 
"  IF LEFT(@xxxmdbug_token_value_4,1) ='''' THEN"
"    SET @xxxmdbug_token_value_4a=TRIM(BOTH '''' FROM @xxxmdbug_token_value_4);" 
"    LEAVE retype;" 
"    END IF;" 
"  IF LEFT(@xxxmdbug_token_value_4,1) ='\"' THEN"
"    SET @xxxmdbug_token_value_4a=TRIM(BOTH '\"' FROM @xxxmdbug_token_value_4);" 
"    LEAVE retype;" 
"    END IF;" 
"  IF @xxxmdbug_token_value_4 ='null' THEN"
"    SET i_longblob=NULL; SET @xxxmdbug_token_value_4a=i_longblob;" 
"    LEAVE retype;" 
"    END IF;" 
"  IF LEFT(@xxxmdbug_token_value_4,2) ='0x' THEN"
"    SET i_longblob='';" 
"    SET j = 3;" 
"    WHILE j < LENGTH(@xxxmdbug_token_value_4) DO" 
"      SET k = SUBSTRING(@xxxmdbug_token_value_4 FROM j FOR 1);" 
"      SET l = SUBSTRING(@xxxmdbug_token_value_4 FROM j+1 FOR 1);" 
"      SET i_longblob = CONCAT(i_longblob,CHAR(k*16+l));" 
"      SET j = j + 2;" 
"      END WHILE;" 
"    SET @xxxmdbug_token_value_4a = i_longblob;" 
"    LEAVE retype;" 
"    END IF;" 
"  IF @xxxmdbug_token_value_4   LIKE '%e%' THEN"
"    SET i_double=@xxxmdbug_token_value_4; SET @xxxmdbug_token_value_4a=i_double;" 
"    LEAVE retype;" 
"    END IF;" 
"  IF @xxxmdbug_token_value_4   LIKE '%.%' THEN"
"    SET i_decimal=@xxxmdbug_token_value_4; SET @xxxmdbug_token_value_4a=i_decimal;" 
"    LEAVE retype;" 
"    END IF;" 
"  SET i_bigint=@xxxmdbug_token_value_4; SET @xxxmdbug_token_value_4a=i_bigint;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Processing 'set'" 
"   Assuming syntax is correct (todo: syntax checking)," 
"   we will have 4 tokens: 'set', variable_identifier, '=', variable_value." 
"   This works for declared variables by changing the variables table, later icc_copy_variables_to_table_row makes assignments." 
"   This does not work for user variables, they should have direct assignment statements in a generated icc_core." 
"   TODO: set statement status */" 
"CREATE PROCEDURE xxxmdbug.icc_process_user_command_set ()" 
"user_command_s:" 
"BEGIN" 
"  DECLARE v_variable_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_variable_value VARBINARY(66);" 
"  DECLARE v_n INT;" 
"  DECLARE v_flags INT;" 
"  DECLARE v_table_is_in_scope INT;" 
"  DECLARE v_table_variable_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_is_settable INT;" 
"  DECLARE v_row_count INT;" 
"" 
"  CALL xxxmdbug.retype(); /* Strip ''s from @xxxmdbug_token_value_4 and possibly change its type. */" 
"" 
"  IF LENGTH(@xxxmdbug_token_value_4a) > 64 THEN" 
"    CALL xxxmdbug.icc_change_statement_status('\"Refused, maximum length = 64\"');" 
"    LEAVE user_command_s;" 
"    END IF;" 
"" 
"  IF LEFT(@xxxmdbug_token_value_2,2) ='@@' THEN"
"    CALL xxxmdbug.icc_process_user_command_set_server_variables();" 
"    LEAVE user_command_s;" 
"    END IF;" 
"" 
"  SET v_variable_value= @xxxmdbug_token_value_4a;" 
"  SET v_variable_identifier= @xxxmdbug_token_value_2;" 
"  CALL xxxmdbug.add_delimiters(v_variable_identifier);" 
"  /*" 
"  IF (SELECT is_settable" 
"      FROM variables" 
"      WHERE variable_identifier  = v_variable_identifier AND is_in_scope = 1) = 0 THEN"
"    CALL xxxmdbug.icc_change_statement_status('\"Refused, not settable\"');" 
"    LEAVE user_command_s;" 
"    END IF;" 
"  */" 
"  SET v_n=0;" 
"  xv: LOOP" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_variable_identifier,80,v_n,v_table_variable_identifier,v_flags);" 
"    IF v_flags=-1 THEN LEAVE xv; END IF;" 
"    IF v_table_variable_identifier =v_variable_identifier THEN"
"      CALL xxxmdbug.fixed_select(@xxxmdbug_variables_is_in_scope,5,v_n,v_table_is_in_scope,v_flags);" 
"      IF v_table_is_in_scope=1 THEN" 
"        CALL xxxmdbug.fixed_select(@xxxmdbug_variables_is_settable,5,v_n,v_table_is_settable,v_flags);" 
"        IF v_table_is_settable=0 THEN" 
"          CALL xxxmdbug.icc_change_statement_status('\"Refused, not settable\"');" 
"          LEAVE user_command_s;" 
"          END IF;" 
"        END IF;" 
"      END IF;" 
"    SET v_n=v_n+1;" 
"    END LOOP;" 
"" 
"  /* UPDATE variables SET value = v_variable_value," 
"                       is_updated_by_set = 1" 
"                       WHERE variable_identifier = v_variable_identifier AND is_in_scope = 1; */" 
"  SET v_n=0;" 
"  SET v_row_count=0;" 
"  x: LOOP" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_is_in_scope,5,v_n,v_table_is_in_scope,v_flags);" 
"    IF v_flags=-1 THEN LEAVE x; END IF;" 
"    IF v_table_is_in_scope=1 THEN" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_variables_variable_identifier,80,v_n,v_table_variable_identifier,v_flags);" 
"      IF v_table_variable_identifier =v_variable_identifier THEN"
"        CALL xxxmdbug.fixed_update(@xxxmdbug_variables_value,@xxxmdbug_value_length,v_n,v_variable_value);" 
"        CALL xxxmdbug.fixed_update(@xxxmdbug_variables_is_updated_by_set,5,v_n,1);" 
"        SET v_row_count=v_row_count+1;" 
"        END IF;" 
"      END IF;" 
"    SET v_n=v_n+1;" 
"    END LOOP;" 
"  CALL xxxmdbug.icc_change_statement_status(CONCAT('\"OK, row_count()=',v_row_count,'\"'));" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Processing 'execute'." 
"   For example, 'execute insert into t values (5)' should cause prepare+execute of an INSERT." 
"   It is easy for this to go wrong, for example if we are within a function this will cause" 
"   \"| Error | 1336 | Dynamic SQL is not allowed in stored function or trigger |\"." 
"   and we handle that so that the status message will be right -- but this cause the" 
"   routine to fail? I am just guessing that is not what is wanted so do not RESIGNAL." 
"   TODO: Replace references to routines with references to surrogate routines." 
"   TODO: the result should  be like the result for statements_executed" 
"    */" 
"CREATE PROCEDURE xxxmdbug.icc_process_user_command_execute ()" 
"BEGIN" 
"  DECLARE v_result VARCHAR(66) CHARACTER SET utf8 DEFAULT '\"OK\"';" 
"  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET v_result = '\"Exception\"';" 
"  DECLARE CONTINUE HANDLER FOR SQLWARNING SET v_result = '\"Warning\"';" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_result = '\"Not found\"';" 
"" 
"  SET @xxxmdbug_stmt_for_x = RIGHT(@xxxmdbug_message,LENGTH(@xxxmdbug_message)-LENGTH('execute '));" 
"  PREPARE xxxmdbug_stmt_for_x FROM @xxxmdbug_stmt_for_x;" 
"  IF v_result  = '\"OK\"' OR v_result  = '\"Warning\"' THEN EXECUTE xxxmdbug_stmt_for_x; END IF;"
"  CALL xxxmdbug.icc_change_statement_status(v_result);" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Update the variables table, setting is_in_scope=1 for parameters/variables that are" 
"   declared within the routine, and" 
"   are the first with this name (going upward), and" 
"   can be associated with an earlier DECLARE that is not within a localized BEGIN/END. */" 
"/* User variables are always in scope but they appear in a different table. */" 
"/* todo: maybe it would be faster to go forward through the statements looking for BEGIN/DECLARE/END */" 
"CREATE PROCEDURE xxxmdbug.determine_what_variables_are_in_scope (p_token_number INT," 
"                                                                            mysql_proc_db VARCHAR(66) CHARACTER SET utf8," 
"                                                                            mysql_proc_name VARCHAR(66) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE eof INT DEFAULT 0;" 
"  DECLARE v_token_number INT;" 
"  DECLARE v_value VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_next_value VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_statement_number_within_routine INT;" 
"  DECLARE v_token_number_of_first_token INT;" 
"  DECLARE v_statement_type enum('flow_control','declare_variable','declare_handler','declare_condition','declare_cursor','debuggable','unknown');" 
"  DECLARE v_end_count INT;" 
"  DECLARE is_declare_seen INT DEFAULT 0;" 
"" 
"  DECLARE statement_cursor CURSOR FOR" 
"  SELECT statement_number_within_routine,token_number_of_first_token,statement_type" 
"  FROM xxxmdbug.statements" 
"  WHERE schema_identifier COLLATE utf8_general_ci=mysql_proc_db AND routine_identifier=mysql_proc_name AND token_number_of_first_token < p_token_number"
"  ORDER BY statement_number_within_routine DESC;" 
"" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1;" 
"" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.tmp_variables;" 
"  CREATE TEMPORARY TABLE xxxmdbug.tmp_variables (variable_identifier VARCHAR(66) CHARACTER SET utf8);" 
"" 
"  /* Start by declaring everything to be out of scope. */" 
"  UPDATE xxxmdbug.variables SET is_in_scope=0;" 
"" 
"  /* Go backwards through the routine's statements looking for DECLAREs that are not within deeper BEGIN/ENDs */" 
"  SET v_end_count = 0;" 
"  OPEN statement_cursor;" 
"  x: LOOP" 
"    FETCH statement_cursor INTO v_statement_number_within_routine,v_token_number_of_first_token,v_statement_type;" 
"    IF eof = 1 THEN LEAVE x; END IF;" 
"    IF v_statement_type  = 'flow_control' OR v_statement_type  = 'unknown' THEN"
"      SELECT value INTO v_value FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_first_token;" 
"      IF v_value ='END' THEN"
"        SELECT value INTO v_next_value FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_first_token+1;" 
"        IF v_next_value   NOT IN ('WHILE','CASE','LOOP','REPEAT','IF') THEN SET v_end_count = v_end_count + 1; END IF;"
"        END IF;" 
"      IF v_value ='BEGIN' AND v_end_count > 0 THEN SET v_end_count = v_end_count - 1; END IF;"
"      END IF;" 
"    IF v_statement_type  = 'declare_variable' THEN"
"      IF v_end_count=0 THEN" 
"        /* This DECLARE is in scope." 
"           Mark any variables associated with this DECLARE" 
"           as \"in scope\", unless a variable with the same" 
"           name has already been marked. */" 
"        UPDATE xxxmdbug.variables SET is_in_scope=1" 
"        WHERE token_number_of_declare=v_token_number_of_first_token" 
"        AND variable_identifier   NOT IN (SELECT variable_identifier FROM xxxmdbug.tmp_variables);"
"        /* todo: this inserts too many rows, we only care about non-duplicate ones that we just updated */" 
"        INSERT INTO xxxmdbug.tmp_variables" 
"        SELECT variable_identifier" 
"        FROM xxxmdbug.variables" 
"        WHERE is_in_scope=1 AND token_number_of_declare=v_token_number_of_first_token;" 
"        IF @xxxmdbug_track_declared_variables=1 THEN" 
"          /* If the user did call setup('-track_declared_variables=1 ...') then we stop after the most immediate DECLARE */" 
"          SET is_declare_seen = 1;" 
"          LEAVE x;" 
"          END IF;" 
"        END IF;" 
"      END IF;" 
"    END LOOP;" 
"  CLOSE statement_cursor;" 
"" 
"  /* parameters are in scope if the procedure name matches." 
"     But if a variable has the same name as a parameter, then the variable is in scope, not the parameter  */" 
"  IF @xxxmdbug_track_declared_variables = 2 OR is_declare_seen = 0 THEN" 
"    UPDATE xxxmdbug.variables" 
"    SET is_in_scope=1" 
"    WHERE token_number_of_declare = 0 AND schema_identifier COLLATE utf8_general_ci=mysql_proc_db AND routine_identifier=mysql_proc_name"
"    AND variable_identifier NOT IN (SELECT variable_identifier FROM xxxmdbug.tmp_variables);" 
"    END IF;" 
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* In icc_start we said" 
"     UPDATE variables SET is_in_scope=0;  start with assumption = all variables out of scope" 
"   Now we will selectively turn is_in_scope back on. As well, we will do the main job: copying." 
"   For values longer than 66 bytes, truncate and set is_settable=0 so later 'set' commands will not work." 
"   I made p_variable_value a BLOB on the theory that casting to BLOB will not cause an error, while casting to UTF8 CHAR would.*/" 
"CREATE PROCEDURE xxxmdbug.icc_copy_variable_to_table_row (p_variable_identifier VARCHAR(66) CHARACTER SET utf8," 
"                            p_token_number_of_declare INT," 
"                            p_variable_value BLOB)" 
"BEGIN" 
"  DECLARE v_is_settable INT;" 
"  DECLARE v_value_as_binary VARBINARY(998); /* todo: any reason this has to be varbinary? */" 
"  DECLARE v_n INT;" 
"  DECLARE v_flags INT;" 
"  DECLARE v_table_token_number_of_declare INT;" 
"  DECLARE v_table_variable_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_old_value VARCHAR(66) CHARACTER SET utf8;" 
"" 
"  /* A warning is probably overflow, value length > 66 */" 
"  /* Currently @xxxmdbug_value_length = 80 but I see we defined variables.value for 66 (characters) */" 
"  IF LENGTH(p_variable_value)>66 THEN" 
"    SET v_is_settable = 0;" 
"    SET v_value_as_binary = LEFT(p_variable_value,@xxxmdbug_value_length-3);" 
"  ELSE" 
"    SET v_is_settable = 1;" 
"    SET v_value_as_binary = p_variable_value;" 
"  END IF;" 
"" 
"  /* UPDATE variables" 
"     SET value = v_value_as_binary, is_in_scope = 1, is_settable = v_is_settable" 
"     WHERE variable_identifier = p_variable_identifier" 
"     AND token_number_of_declare = p_token_number_of_declare; */" 
"  SET v_n=0;" 
"  x: LOOP" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_variable_identifier,80,v_n,v_table_variable_identifier,v_flags);" 
"    IF v_flags=-1 THEN LEAVE x; END IF;" 
"    IF v_table_variable_identifier=p_variable_identifier THEN" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_variables_token_number_of_declare,10,v_n,v_table_token_number_of_declare,v_flags);" 
"      IF v_table_token_number_of_declare=p_token_number_of_declare THEN" 
"        /* Copy old_value = current_value before changing current_value. */" 
"        CALL xxxmdbug.fixed_select(@xxxmdbug_variables_value,@xxxmdbug_value_length,v_n,v_table_old_value,v_flags);" 
"        CALL xxxmdbug.fixed_update(@xxxmdbug_variables_old_value,@xxxmdbug_value_length,v_n,v_table_old_value);" 
"        CALL xxxmdbug.fixed_update(@xxxmdbug_variables_value,@xxxmdbug_value_length,v_n,v_value_as_binary);" 
"        CALL xxxmdbug.fixed_update(@xxxmdbug_variables_is_in_scope,5,v_n,1);" 
"        CALL xxxmdbug.fixed_update(@xxxmdbug_variables_is_settable,5,v_n,v_is_settable);" 
"        END IF;" 
"      END IF;" 
"    SET v_n=v_n+1;" 
"    END LOOP;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* This routine is depending on the current and possibly-undocumented behaviour that," 
"   if we do not assign to an OUT variable, we do not change it. */" 
"CREATE PROCEDURE xxxmdbug.icc_copy_table_row_to_variable (p_variable_identifier VARCHAR(66) CHARACTER SET utf8," 
"                                                 p_token_number_of_declare INT," 
"                                                 INOUT p_variable_value BLOB)" 
"BEGIN" 
"  DECLARE v_table_value VARBINARY(998);" 
"  DECLARE v_n INT;" 
"  DECLARE v_flags INT;" 
"  DECLARE v_table_is_updated_by_set INT;" 
"  DECLARE v_table_variable_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_token_number_of_declare INT;" 
"" 
"  /* SELECT value, is_updated_by_set" 
"     INTO v_value, v_is_updated_by_set" 
"     FROM variables" 
"     WHERE variable_identifier  = p_variable_identifier"
"     AND token_number_of_declare = p_token_number_of_declare; */" 
"  SET v_n=0;" 
"  xv2: LOOP" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_variable_identifier,80,v_n,v_table_variable_identifier,v_flags);" 
"    IF v_flags=-1 THEN LEAVE xv2; END IF;" 
"    IF v_table_variable_identifier =p_variable_identifier THEN"
"      CALL xxxmdbug.fixed_select(@xxxmdbug_variables_token_number_of_declare,10,v_n,v_table_token_number_of_declare,v_flags);      " 
"      IF v_table_token_number_of_declare=p_token_number_of_declare THEN" 
"        CALL xxxmdbug.fixed_select(@xxxmdbug_variables_value,@xxxmdbug_value_length,v_n,v_table_value,v_flags);" 
"        CALL xxxmdbug.fixed_select(@xxxmdbug_variables_is_updated_by_set,5,v_n,v_table_is_updated_by_set,v_flags);" 
"        END IF;" 
"      END IF;       " 
"    SET v_n=v_n+1;" 
"    END LOOP;" 
"" 
"  IF v_table_is_updated_by_set = 1 THEN" 
"    /* UPDATE variables" 
"       SET is_updated_by_set = 0" 
"       WHERE variable_identifier = p_variable_identifier" 
"       AND token_number_of_declare = p_token_number_of_declare; */" 
"    SET v_n=0;" 
"    x: LOOP" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_variables_variable_identifier,80,v_n,v_table_variable_identifier,v_flags);" 
"      IF v_flags=-1 THEN LEAVE x; END IF;" 
"      IF v_table_variable_identifier =p_variable_identifier THEN"
"        CALL xxxmdbug.fixed_select(@xxxmdbug_variables_token_number_of_declare,10,v_n,v_table_token_number_of_declare,v_flags);" 
"        IF v_table_token_number_of_declare=p_token_number_of_declare THEN" 
"          CALL xxxmdbug.fixed_update(@xxxmdbug_variables_is_updated_by_set,5,v_n,0);" 
"          END IF;" 
"        END IF;" 
"      SET v_n=v_n+1;" 
"      END LOOP;" 
"    SET p_variable_value = v_table_value;" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Find the breakpoint in the fixed list." 
"   todo: check all fields, not just routine name and line numbers */" 
"/* Conditions of the form \"variable <> old.variable\":" 
"   The \"current value\" of the variable is in the variables table." 
"   In icc_copy_variable_to_table_row(), we copy current to old before changing current." 
"   Originally I had planned to keep old_value in the breakpoints table so updates of" 
"   old_value would only occur when there was a breakpoint to check, but I ran into a" 
"   problem: what is the 'current value' if multiple variables have the same name?" 
"   With this scheme, we know that the current value is the one that is in scope." 
"   When breakpoint check happens: compare current value to old value. if <>, then set old-value = current-value, and result = 1." 
"   todo: For comparisons, null <> null is false and non-null <> null is true. */" 
"/* Conditions of the form \"hit_count = n\":" 
"   If location is a match, ++hit_count (this happens regardless of condition)" 
"   If condition is \"hit_count = n\", compare hit_count to n" 
"   Never cleared, so it's useless after it's true one time. */" 
"CREATE PROCEDURE xxxmdbug.icc_breakpoint_check (p_line_number INT,OUT result INT)" 
"icc_breakpoint_check:" 
"BEGIN" 
"  DECLARE v_breakpoint_number INT; /* unused? */" 
"  DECLARE v_breakpoint_identifier INT;" 
"  DECLARE v_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_type VARCHAR(10) CHARACTER SET utf8;" 
"  DECLARE v_line_number_minimum INT;" 
"  DECLARE v_line_number_maximum INT;" 
"  DECLARE v_condition_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_condition_operator VARCHAR(2) CHARACTER SET utf8;" 
"  DECLARE v_condition_value VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_hit_count INT;" 
"  DECLARE v_is_temporary INT;" 
"  DECLARE v_is_temporary_and_to_be_cleared INT;" 
"  DECLARE v_is_matching_location INT;" 
"  DECLARE v_is_matching_condition INT;" 
"  DECLARE v_call_stack_depth_when_set INT;" 
"  DECLARE v_command VARCHAR(14) CHARACTER SET utf8;" 
"  DECLARE v_schema VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine VARCHAR(66) CHARACTER SET utf8;" 
"  /* DECLARE eof INT DEFAULT 0; */" 
"  DECLARE v_n INT;" 
"  DECLARE v_flags INT;" 
"  DECLARE v_table_variable_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_variable_value VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_variable_old_value VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_is_in_scope INT;" 
"  DECLARE v_n2 INT;" 
"  DECLARE v_table_breakpoint_identifier INT;" 
"  DECLARE v_n3 INT;" 
"  DECLARE v_table_is_temporary INT;" 
"  DECLARE v_n4 INT;" 
"  DECLARE step_or_next_already_deleted INT;" 
"" 
"  /* DECLARE c CURSOR FOR SELECT * FROM breakpoints; */" 
"  /* DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1; */" 
"" 
"  IF @xxxmdbug_last_was_debug = 1 THEN" 
"    /* debuggee_wait_loop() sets @xxxmdbug_last_was_debug=1 just before" 
"       invoking, and right after routine_entry() is call icc_core(0), so if" 
"       @xxxmdbug_last_was_debug=1 then you know that 'debug' command" 
"       just happened and line_number=0. Treat this as a breakpoint. */" 
"    SET @xxxmdbug_last_was_debug=0;" 
"    CALL xxxmdbug.icc_change_statement_status('OK'); /* i.e. 'debug' was okay */" 
"    SET result=2;" 
"    LEAVE icc_breakpoint_check;" 
"    END IF;" 
"" 
"  IF @xxxmdbug_token_value_1   IN ('step','next') THEN CALL xxxmdbug.icc_process_user_command_step_or_next(); END IF;"
"" 
"  SET result = 0;" 
"  CALL xxxmdbug.get_current_schema_identifier_and_routine_identifier(v_schema,v_routine,v_routine_type);" 
"  /* OPEN c; */" 
"  SET v_n=0;" 
"  x: LOOP" 
"    /* FETCH c into " 
"       v_breakpoint_identifier," 
"       v_schema_identifier," 
"       v_routine_identifier," 
"       v_routine_type," 
"       v_line_number_minimum," 
"       v_line_number_maximum," 
"       v_condition_identifier," 
"       v_condition_operator," 
"       v_condition_value," 
"       v_hit_count," 
"       v_is_temporary," 
"       v_is_temporary_and_to_be_cleared," 
"       v_is_matching_location," 
"       v_is_matching_condition," 
"       v_call_stack_depth_when_set," 
"       v_command;" 
"       IF eof = 1 THEN LEAVE x; END IF; */" 
"" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_breakpoint_identifier,10,v_n,v_breakpoint_identifier,v_flags);" 
"    IF v_flags=-1 THEN LEAVE x; END IF;" 
"" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_schema_identifier,80,v_n,v_schema_identifier,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_routine_identifier,80,v_n,v_routine_identifier,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_routine_type,16,v_n,v_routine_type,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_line_number_minimum,10,v_n,v_line_number_minimum,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_line_number_maximum,10,v_n,v_line_number_maximum,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_condition_identifier,80,v_n,v_condition_identifier,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_condition_operator,10,v_n,v_condition_operator,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_condition_value,@xxxmdbug_value_length,v_n,v_condition_value,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_hit_count,10,v_n,v_hit_count,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_is_temporary,5,v_n,v_is_temporary,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_is_temporary_and_to_be_cleared,5,v_n,v_is_temporary_and_to_be_cleared,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_is_matching_location,5,v_n,v_is_matching_location,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_is_matching_condition,5,v_n,v_is_matching_condition,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_call_stack_depth_when_set,10,v_n,v_call_stack_depth_when_set,v_flags);" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_command,20,v_n,v_command,v_flags);" 
"" 
"    SET v_is_matching_location = 0;" 
"    SET v_is_matching_condition = 0;" 
"    IF TRIM(BOTH '`' FROM v_schema)   LIKE TRIM(TRIM(BOTH '`' FROM v_schema_identifier))"
"    AND TRIM(BOTH '`' FROM v_routine)   LIKE TRIM(TRIM(BOTH '`' FROM v_routine_identifier))                  "
"    AND p_line_number >= v_line_number_minimum" 
"    AND p_line_number <= v_line_number_maximum THEN" 
"      SET v_is_matching_location = 1;" 
"      SET v_hit_count = v_hit_count+1;" 
"      condition_check: BEGIN" 
"        IF v_condition_identifier ='hit_count' THEN"
"          IF v_hit_count = v_condition_value THEN" 
"            SET v_is_matching_condition = 1;" 
"            IF v_is_temporary=0 THEN SET result = 1; ELSE  SET result = 2; END IF;" 
"            END IF;" 
"          LEAVE condition_check;" 
"          END IF;" 
"        IF TRIM(BOTH '`' FROM v_condition_identifier) ='call_stack_depth' THEN"
"          /* it could be 'breakpoint call_stack_depth <= call_stack_depth_when_set', it could be 'breakpoint call_stack_depth <= n' */" 
"          IF (v_condition_value  = 'call_stack_depth_when_set' AND LENGTH(@xxxmdbug_call_stack)/(66+66+1+6)<=v_call_stack_depth_when_set)"
"          OR LENGTH(@xxxmdbug_call_stack)/(66+66+1+6)<=v_condition_value THEN" 
"            SET v_is_matching_condition = 1;" 
"            IF v_is_temporary=0 THEN SET result = 1; ELSE  SET result = 2; END IF;" 
"            END IF;" 
"          LEAVE condition_check;" 
"          END IF;" 
"        IF v_condition_identifier ='' THEN"
"          IF v_is_temporary=0 THEN SET result = 1; ELSE  SET result = 2; END IF;" 
"          LEAVE condition_check;" 
"          END IF;" 
"" 
"        /* SELECT value" 
"          INTO v_table_variable_value" 
"          FROM variables" 
"          WHERE variable_identifier =v_condition_identifier AND is_in_scope = 1; */"
"        SET v_n4=0;" 
"        xvar: LOOP" 
"          CALL xxxmdbug.fixed_select(@xxxmdbug_variables_variable_identifier,80,v_n4,v_table_variable_identifier,v_flags);" 
"          IF v_flags=-1 THEN" 
"            /* identifier not found, or not in scope */" 
"            LEAVE condition_check;" 
"            END IF;" 
"          IF v_table_variable_identifier =v_condition_identifier THEN"
"            CALL xxxmdbug.fixed_select(@xxxmdbug_variables_is_in_scope,5,v_n4,v_table_is_in_scope,v_flags);" 
"            IF v_table_is_in_scope=1 THEN" 
"              CALL xxxmdbug.fixed_select(@xxxmdbug_variables_value,@xxxmdbug_value_length,v_n4,v_table_variable_value,v_flags);" 
"              LEAVE xvar;" 
"              END IF;" 
"            END IF;" 
"          SET v_n4=v_n4+1;" 
"          END LOOP;" 
"        IF v_condition_value  = 'OLD' THEN"
"          CALL xxxmdbug.fixed_select(@xxxmdbug_variables_old_value,@xxxmdbug_value_length,v_n4,v_table_variable_old_value,v_flags);" 
"          IF v_table_variable_value  <> v_table_variable_old_value THEN"
"            SET v_is_matching_condition = 1;" 
"            IF v_is_temporary=0 THEN SET result = 1; ELSE  SET result = 2; END IF;" 
"            LEAVE condition_check;" 
"            END IF;" 
"          END IF;" 
"        CALL xxxmdbug.compare(v_condition_value,v_table_variable_value,v_is_matching_condition); /* becomes = 1 if true */" 
"        IF v_is_matching_condition = 1 THEN" 
"          IF v_is_temporary=0 THEN SET result = 1; ELSE  SET result = 2; END IF;" 
"          END IF;" 
"        END;" 
"      END IF;" 
"    /* UPDATE breakpoints" 
"       SET is_matching_location = v_is_matching_location," 
"           is_matching_condition = v_is_matching_condition" 
"       WHERE breakpoint_identifier = v_breakpoint_identifier; */" 
"    CALL xxxmdbug.fixed_update(@xxxmdbug_breakpoints_is_matching_location,5,v_n,v_is_matching_location);" 
"    CALL xxxmdbug.fixed_update(@xxxmdbug_breakpoints_hit_count,10,v_n,v_hit_count);" 
"    CALL xxxmdbug.fixed_update(@xxxmdbug_breakpoints_is_matching_condition,5,v_n,v_is_matching_condition);" 
"" 
"    SET v_n=v_n+1;" 
"    END LOOP;" 
"  /* CLOSE c; */" 
"" 
"  IF result>0 THEN" 
"    /* The temporary breakpoints become temporary_and_to_be_cleared breakpoints." 
"       Clearing happens when motion command, e.g. 'continue'" 
"       If a breakpoint has been reached (i.e. result > 0)" 
"         For each breakpoint" 
"           If (not temporary) skip -- permanent breakpoints don't disappear" 
"           If (not a match) skip -- this is a change from the original idea" 
"           If (already marked as to-be-cleared) clear" 
"           If (not 'step' or 'next') mark as to-be-cleared" 
"           If ('step' or 'next') mark as to-be-cleared, but do so only once" 
"       We want it so that if user says 'step' 3 times, it stops 3 times. */" 
"    /* UPDATE breakpoints SET is_temporary_and_to_be_cleared = is_temporary; */" 
"    SET v_n3=0;" 
"    SET step_or_next_already_deleted=0;" 
"    x3: LOOP" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_is_temporary,5,v_n3,v_table_is_temporary,v_flags);" 
"      IF v_flags=-1 THEN LEAVE x3; END IF;" 
"      IF v_table_is_temporary=0 THEN SET v_n3=v_n3+1; ITERATE x3; END IF;" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_is_matching_location,5,v_n3,v_is_matching_location,v_flags);" 
"      IF v_is_matching_location=0 THEN SET v_n3=v_n3+1; ITERATE x3; END IF;" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_is_matching_condition,5,v_n3,v_is_matching_condition,v_flags);" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_condition_identifier,5,v_n3,v_condition_identifier,v_flags);" 
"      IF v_condition_identifier >'' AND v_is_matching_condition=0 THEN SET v_n3=v_n3+1; ITERATE x3; END IF;"
"" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_is_temporary_and_to_be_cleared,5,v_n3,v_is_temporary_and_to_be_cleared,v_flags);" 
"      IF v_is_temporary_and_to_be_cleared=1 THEN" 
"        CALL xxxmdbug.breakpoint_delete(v_n3);" 
"        ITERATE x3;" 
"        END IF;" 
"" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_command,20,v_n3,v_command,v_flags);" 
"      IF v_command ='step' OR v_command ='next' THEN"
"        IF step_or_next_already_deleted=1 THEN SET v_n3=v_n3+1; ITERATE x3; END IF;" 
"        SET step_or_next_already_deleted=1;" 
"        END IF;" 
"      CALL xxxmdbug.fixed_update(@xxxmdbug_breakpoints_is_temporary_and_to_be_cleared,5,v_n3,v_table_is_temporary);" 
"      SET v_n3=v_n3+1;" 
"      END LOOP;" 
"    END IF;" 
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* compare() is called from breakpoint_check()." 
"   We use the \"retype()\" tricks to determine v_condition_value, and then we force v_table_variable_value" 
"   to be the same. In other words, the declared variable type is not what matters." 
"   What matters is the way the user input the breakpoint condition literal, 'quoted', 0x65, 0.5, etc." 
"   Return 0 unequal or 1 equal." 
"   This is going to be slower than the alternative of converting the breakpoint" 
"   condition value during the 'breakpoint' command and performing a binary comparison" 
"   during breakpoint_check(), but that is not a todo. */" 
"CREATE PROCEDURE xxxmdbug.compare (v_condition_value VARCHAR(66) CHARACTER SET utf8," 
"                                   v_table_variable_value VARCHAR(66) CHARACTER SET utf8," 
"                                   OUT return_value INT)" 
"compare:" 
"BEGIN" 
"  DECLARE i_double,i_double_2 DOUBLE PRECISION; /* Float -> Double */" 
"  DECLARE i_decimal,i_decimal_2 DECIMAL(65,30); /* DecimalNumeric -> Decimal */" 
"  DECLARE i_bigint,i_bigint_2 BIGINT(20); /* Tinyint|Smallint|Int|MediumInt -> Bigint */" 
"  DECLARE i_longblob LONGBLOB;" 
"  DECLARE i_longtext LONGTEXT;" 
"  DECLARE j,k,l INT;" 
"  DECLARE EXIT HANDLER FOR SQLEXCEPTION SET return_value = 0;" 
"  IF LEFT(v_condition_value,1) ='''' THEN"
"    SET i_longtext=TRIM(BOTH '''' FROM v_condition_value);" 
"    SET return_value = (i_longtext = v_table_variable_value);" 
"    LEAVE compare;" 
"    END IF;" 
"  IF LEFT(v_condition_value,1) ='\"' THEN"
"    SET i_longtext=TRIM(BOTH '\"' FROM v_condition_value);" 
"    SET return_value = (i_longtext = v_table_variable_value);" 
"    LEAVE compare;" 
"    END IF;" 
"  IF v_condition_value ='null' THEN"
"    SET return_value = 0;" 
"    IF v_table_variable_value IS NULL THEN SET return_value = 1; END IF;" 
"    LEAVE compare;" 
"    END IF;" 
"  /* Todo: There is nothing adequate for comparison with NULL. */" 
"  IF LEFT(v_condition_value,2) ='0x' THEN"
"    SET i_longblob='';" 
"    SET j = 3;" 
"    WHILE j < LENGTH(v_condition_value) DO" 
"      SET k = SUBSTRING(v_condition_value FROM j FOR 1);" 
"      SET l = SUBSTRING(v_condition_value FROM j+1 FOR 1);" 
"      SET i_longblob = CONCAT(i_longblob,CHAR(k*16+l));" 
"      SET j = j + 2;" 
"      END WHILE;" 
"    SET return_value = (i_longblob  = v_table_variable_value);"
"    LEAVE compare;" 
"    END IF;" 
"  IF v_condition_value   LIKE '%e%' THEN"
"    SET i_double=v_condition_value;" 
"    SET i_double_2=v_table_variable_value;" 
"    SET return_value = (i_double = i_double_2);"
"    LEAVE compare;" 
"    END IF;" 
"  IF v_condition_value   LIKE '%.%' THEN"
"    SET i_decimal=v_condition_value;" 
"    SET i_decimal_2=v_table_variable_value;" 
"    SET return_value = (i_decimal = i_decimal_2);" 
"    LEAVE compare;" 
"    END IF;" 
"  SET i_bigint=v_condition_value;" 
"  SET i_bigint_2=v_table_variable_value;" 
"  SET return_value = (i_bigint = i_bigint_2);" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* if with_wait=0 i.e. \"with no wait\" then don't wait, but take from the queue." 
"   todo: timeout (maybe) */" 
"CREATE PROCEDURE xxxmdbug.icc_get_user_command (with_wait INT)" 
"BEGIN" 
"  DECLARE sleep_result INT;" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_message_start INT;" 
"" 
"  x: LOOP" 
"    IF with_wait=1 THEN SET sleep_result=SLEEP(@xxxmdbug_sleep_time); END IF; /* e.g. wait 1/10 second */" 
"    SET @xxxmdbug_message = ''; /* unnecessary? */" 
"    SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_command); /* ignore messages that don't start with this ('C ') */" 
"    CALL xxxmdbug.dbms_pipe_receive(v_prefix,1,@xxxmdbug_message,v_message_start);" 
"    IF @xxxmdbug_message  <= '' AND with_wait=1 THEN ITERATE x; END IF;"
"    LEAVE x;" 
"    END LOOP;" 
"  /* todo: see if you can get rid of @xxxmdbug_status_last_command and just use @xxxmdbug_message */" 
"  IF @xxxmdbug_message  > '' THEN"
"    SET @xxxmdbug_status_last_command = @xxxmdbug_message;" 
"    SET @xxxmdbug_status_last_command_result = '?'; /* this '?' should be overwritten, it's a bug if anybody sees it with 'i status' */" 
"    END IF;" 
"  SET @xxxmdbug_linked_list = '';" 
"  CALL xxxmdbug.insert_into_tokens_linked_list(@xxxmdbug_message,@xxxmdbug_linked_list);" 
"if @xxxmdbug_message is null then signal sqlstate '05678' set mysql_errno=@xxxmdbug_signal_errno,message_text = 'assert. @xxxmdbug_message is null'; end if;" 
"if @xxxmdbug_linked_list is null then signal sqlstate '05678' set mysql_errno=@xxxmdbug_signal_errno,message_text = 'assert. @xxxmdbug_linked_list is null'; end if;" 
"  /* Todo: um, maybe we could have a slightly more general way to go through a linked list" 
"     ... that's done now, it's get_from_linked_list(), but we're not using it here yet. */" 
"  SET @xxxmdbug_token_value_1_offset = 1;" 
"  SET @xxxmdbug_token_value_1_length = SUBSTRING(@xxxmdbug_linked_list FROM @xxxmdbug_token_value_1_offset FOR 8);" 
"  SET @xxxmdbug_token_value_1 = SUBSTRING(@xxxmdbug_linked_list FROM @xxxmdbug_token_value_1_offset+24 FOR @xxxmdbug_token_value_1_length);" 
"  SET @xxxmdbug_token_value_2_offset = 1+24+@xxxmdbug_token_value_1_length;" 
"  SET @xxxmdbug_token_value_2_length = SUBSTRING(@xxxmdbug_linked_list FROM @xxxmdbug_token_value_2_offset FOR 8);" 
"  SET @xxxmdbug_token_value_2 = SUBSTRING(@xxxmdbug_linked_list FROM @xxxmdbug_token_value_2_offset+24 FOR @xxxmdbug_token_value_2_length);" 
"  SET @xxxmdbug_token_value_3_offset = 1+24*2+@xxxmdbug_token_value_1_length+@xxxmdbug_token_value_2_length;" 
"  SET @xxxmdbug_token_value_3_length = SUBSTRING(@xxxmdbug_linked_list FROM @xxxmdbug_token_value_3_offset FOR 8);" 
"  SET @xxxmdbug_token_value_3 = SUBSTRING(@xxxmdbug_linked_list FROM @xxxmdbug_token_value_3_offset+24 FOR @xxxmdbug_token_value_3_length);" 
"  SET @xxxmdbug_token_value_4_offset = 1+24*3+@xxxmdbug_token_value_1_length+@xxxmdbug_token_value_2_length+@xxxmdbug_token_value_3_length;" 
"  SET @xxxmdbug_token_value_4_length = SUBSTRING(@xxxmdbug_linked_list FROM @xxxmdbug_token_value_4_offset FOR 8);" 
"  SET @xxxmdbug_token_value_4 = SUBSTRING(@xxxmdbug_linked_list FROM @xxxmdbug_token_value_4_offset+24 FOR @xxxmdbug_token_value_4_length);" 
"" 
"  /* @xxxmdbug_token_value_1 will not be abbreviated form e.g. 'cont', it will be unabbreviated e.g. 'continue'. */" 
"  IF @xxxmdbug_token_value_1_length>0 THEN" 
"    IF @xxxmdbug_token_value_1=LEFT('attach',@xxxmdbug_token_value_1_length) THEN SET @xxxmdbug_token_value_1='attach'; END IF;" 
"    IF @xxxmdbug_token_value_1=LEFT('breakpoint',@xxxmdbug_token_value_1_length) THEN SET @xxxmdbug_token_value_1='breakpoint'; END IF;" 
"    IF @xxxmdbug_token_value_1=LEFT('clear',@xxxmdbug_token_value_1_length) THEN SET @xxxmdbug_token_value_1='clear'; END IF;" 
"    IF @xxxmdbug_token_value_1=LEFT('continue',@xxxmdbug_token_value_1_length) THEN SET @xxxmdbug_token_value_1='continue'; END IF;" 
"    IF @xxxmdbug_token_value_1=LEFT('debug',@xxxmdbug_token_value_1_length) THEN SET @xxxmdbug_token_value_1='debug'; END IF;" 
"    IF @xxxmdbug_token_value_1=LEFT('delete',@xxxmdbug_token_value_1_length) THEN SET @xxxmdbug_token_value_1='delete'; END IF;" 
"    IF @xxxmdbug_token_value_1=LEFT('execute',@xxxmdbug_token_value_1_length) THEN SET @xxxmdbug_token_value_1='execute'; END IF;" 
"    IF @xxxmdbug_token_value_1=LEFT('exit',@xxxmdbug_token_value_1_length) THEN SET @xxxmdbug_token_value_1='exit'; END IF;" 
"    IF @xxxmdbug_token_value_1=LEFT('leave',@xxxmdbug_token_value_1_length) THEN SET @xxxmdbug_token_value_1='leave'; END IF;" 
"    IF @xxxmdbug_token_value_1=LEFT('next',@xxxmdbug_token_value_1_length) THEN SET @xxxmdbug_token_value_1='next'; END IF;" 
"    IF @xxxmdbug_token_value_1=LEFT('refresh',@xxxmdbug_token_value_1_length) THEN SET @xxxmdbug_token_value_1='refresh'; END IF;" 
"    IF @xxxmdbug_token_value_1=LEFT('set',@xxxmdbug_token_value_1_length) THEN SET @xxxmdbug_token_value_1='set'; END IF;" 
"    IF @xxxmdbug_token_value_1=LEFT('skip',@xxxmdbug_token_value_1_length) THEN SET @xxxmdbug_token_value_1='skip'; END IF;" 
"    IF @xxxmdbug_token_value_1=LEFT('step',@xxxmdbug_token_value_1_length) THEN SET @xxxmdbug_token_value_1='step'; END IF;" 
"    IF @xxxmdbug_token_value_1=LEFT('tbreakpoint',@xxxmdbug_token_value_1_length) THEN SET @xxxmdbug_token_value_1='tbreakpoint'; END IF;" 
"    END IF;" 
"  /* Usually 'execute' is in the IN list, but not this time, because 'execute' does its own call to icc_change_statement_status. */" 
"  IF @xxxmdbug_token_value_1   IN ('attach','continue','exit','leave','next','skip','step') THEN CALL xxxmdbug.icc_change_statement_status('OK'); END IF;"
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* There are two kinds of commands: the ones that cause forward motion (continue, leave, exit, skip)" 
"   and the ones that get or set data (break, set, refresh). The motion ones break out of the loop so" 
"   they stop picking commands from the queue, but that's okay, the next icc_core call will pick them. */" 
"/* todo: syntax check */" 
"/* todo: check: does anything call icc_core any more? seems to me that we only call the generated icc_core variations. */" 
"CREATE PROCEDURE xxxmdbug.icc_core (line_number INT)" 
"" 
"BEGIN" 
"  DECLARE sleep_result INT;" 
"  DECLARE v_n INT;" 
"  DECLARE v_flags INT;" 
"  DECLARE v_table_is_temporary_and_to_be_cleared INT;" 
"" 
"  /* DECLARE breakpoint_check_result INT; todo: restore someday, but for breakpoint_check_result is changed to a global */" 
"  SET @xxxmdbug_token_value_1 = ''; /* unnecessary? */" 
"  SET @xxxmdbug_icc_count=@xxxmdbug_icc_count+1;" 
"  /* get and process any pending (i.e. queued) messages from Debugger Connection */" 
"  x1: LOOP" 
"    /* 0 means no wait, i.e. get from queue */" 
"    CALL xxxmdbug.icc_get_user_command(0);" 
"    IF @xxxmdbug_message  <= 0x20 THEN LEAVE x1; END IF; /* if empty queue, go on */"
"    IF @xxxmdbug_token_value_1   IN ('continue','exit','leave','next','execute','skip','step') THEN LEAVE x1; END IF; /* if motion causer, go on */"
"    /* This is replaced with user-variables code in the generated icc_core (if there are user variables and track_user_variables=1). */"
"    CALL xxxmdbug.icc_process_user_command();" 
"    END LOOP;" 
"  SET @xxxmdbug_status_line_number = line_number;" 
"" 
"  CALL xxxmdbug.icc_breakpoint_check(line_number,@xxxmdbug_breakpoint_check_result);" 
"  SET @xxxmdbug_status_breakpoint_check_result = @xxxmdbug_breakpoint_check_result;" 
"  CALL xxxmdbug.icc_send_statement_status('icc_core');" 
"  IF @xxxmdbug_breakpoint_check_result > 0 THEN" 
"    x2: LOOP" 
"      IF @xxxmdbug_token_value_1   IN ('continue','exit','leave','next','execute','skip','step') THEN"
"        LEAVE x2;" 
"        END IF; /* if motion causer, go on */" 
"      /* 1 means wait, i.e. we have to get a command that causes motion */" 
"      CALL xxxmdbug.icc_get_user_command(1);" 
"      IF @xxxmdbug_token_value_1   IN ('next','step') THEN CALL xxxmdbug.icc_process_user_command_step_or_next(); END IF;"
"      IF @xxxmdbug_token_value_1   IN ('continue','exit','leave','next','execute','skip','step') THEN"
"        LEAVE x2;"
"        END IF; /* if motion causer, go on */" 
"    /* This is replaced with :IF @xxxmdbug_token_value_2 = 'user_variables' ,,,\" in the generated icc_core (if track_user_variables=1). */" 
"      CALL xxxmdbug.icc_process_user_command();" 
"      CALL xxxmdbug.icc_send_statement_status('icc_core');" 
"      END LOOP;" 
"" 
"    CALL xxxmdbug.icc_send_statement_status('icc_core');" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* generate_icc_core will generate, for a user variable named @a:" 
"  SET @xxxmdbug_uvar=@a; CALL xxxmdbug.uvar(v_ret,'@a'); */" 
"/* This is a way to get the type of a @user_variable or @server_variable," 
"   without creating a table. Assign it to @xxxmdbug_uvar (which" 
"   preserves the type), and call this. It seems to work most of the time, but" 
"   establishing the character set and collation (with the charset and" 
"   collation functions) would be tedious, and I didn't test thoroughly," 
"   and I cannot figure out a way to get type when the value is NULL" 
"   (LONGBLOB might be a good guess but I chose 'unknown')." 
"   I think that is okay for 'refresh' but consider:" 
"   For 'set @xxxmdbug_uvar=value' and 'set @xxxmdbug_uvar=value, we do the equivalent of:" 
"   SET @xxxmdbug_tmp=@xxxmdbug_uvar;" 
"   CREATE TEMPORARY TABLE xxxmdbug_for_casts AS SELECT @xxxmdbug_tmp AS s1;" 
"   INSERT INTO xxxmdbug_for_casts VALUES (value);" 
"   SET @xxxmdbug_uvar=(SELECT s1 FROM xxxmdbug_for_casts);" 
"   Thus we'd preserve the original data type and character set and collation of @xxxmdbug_uvar." 
"   But we'd destroy the warning list. Maybe try it with MariaDB 5.6, eh? It's slow on Windows." 
"   ... or, when you use 'set', you have to specify a cast. */" 
"CREATE PROCEDURE xxxmdbug.uvar (INOUT v_ret MEDIUMTEXT CHARACTER SET utf8,p_variable_name VARCHAR(66) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE i_double DOUBLE PRECISION; /* Float -> Double */" 
"  DECLARE i_decimal DECIMAL(65,30); /* DecimalNumeric -> Decimal */" 
"  DECLARE i_bigint BIGINT(20); /* Tinyint|Smallint|Int|MediumInt -> Bigint */" 
"  DECLARE i_longblob LONGBLOB; /* Binary|Varbinary -> Longblob */" 
"  DECLARE i_longtext LONGTEXT; /* Char|Date|Text|Enum -> Longtext */" 
"" 
"x1:BEGIN" 
"    IF CHARSET(@xxxmdbug_uvar) <>'binary' OR COLLATION(@xxxmdbug_uvar) <>'binary' THEN"
"      SET @xxxmdbug_uvar_type = 'LONGTEXT';" 
"      LEAVE x1;" 
"      END IF;" 
"    IF @xxxmdbug_uvar IS NULL THEN" 
"      SET @xxxmdbug_uvar_type = 'unknown';" 
"      LEAVE x1;" 
"      END IF;" 
"    SET i_longblob = @xxxmdbug_uvar;" 
"    IF i_longblob<0 THEN" 
"      IF -@xxxmdbug_uvar <> CONCAT('0',-i_longblob) THEN" 
"        SET @xxxmdbug_uvar_type = 'LONGBLOB';" 
"        LEAVE x1;" 
"        END IF;" 
"      END IF;" 
"    IF i_longblob >= 0 THEN" 
"      IF @xxxmdbug_uvar <> CONCAT('0',i_longblob) THEN" 
"        SET @xxxmdbug_uvar_type = 'LONGBLOB';" 
"        LEAVE x1;" 
"        END IF;" 
"      END IF;" 
"    SET i_double = -@xxxmdbug_uvar/1.1;" 
"    IF LENGTH(i_double)=LENGTH(-@xxxmdbug_uvar/1.1) THEN" 
"      SET @xxxmdbug_uvar_type = 'DOUBLE';" 
"      LEAVE x1;" 
"      END IF;" 
"    SET i_decimal = -@xxxmdbug_uvar/1.1;" 
"    IF LENGTH(i_decimal)=LENGTH(-@xxxmdbug_uvar/1.1) THEN" 
"    SET @xxxmdbug_uvar_type = 'DECIMAL';" 
"      LEAVE x1;" 
"      END IF;" 
"    SET @xxxmdbug_uvar_type = 'BIGINT';" 
"    END;" 
"" 
"  SET v_ret=CONCAT(v_ret,'\"',p_variable_name,'\",'," 
"                         '\"',HEX(IFNULL(LEFT(@xxxmdbug_uvar,66),'NULL')),'\",'," 
"                         '\"',HEX(IFNULL(LEFT(@xxxmdbug_old_uvar,66),'NULL')),'\",'," 
"                         '\"',@xxxmdbug_uvar_type,'\";'," 
"                         @xxxmdbug_lf);" 
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* This generates a variant icc_core that can handle 'refresh user_variables'.." 
"   Any changes to icc_core() should be made here too." 
"   Comments are stripped so see the original icc_core() above." 
"   The tmp_user_variables table was populated with @user-variable-names while we were generating." 
"     Although it is easy to assign to a user variable or server variable by" 
"     preparing and executing a SET statement, it is unreliable because we" 
"     might be in a function rather than in a procedure. So, for 'set', we" 
"     generate fixed SET statements for the user variables that we know of." 
"   Use the base icc_core if track_user_variables=0." 
"   Todo: probably this would be faster if it was smaller. */" 
"CREATE PROCEDURE xxxmdbug.generate_icc_core ()" 
"BEGIN" 
"  DECLARE mysql_proc_name VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE mysql_proc_db VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE mysql_proc_type VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_variable_name VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE eof INT DEFAULT 0;" 
"  DECLARE v_g LONGTEXT CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_offset_of_begin INT;" 
"  DECLARE c CURSOR FOR SELECT DISTINCT variable_identifier" 
"                   FROM xxxmdbug.tmp_user_variables" 
"                   ORDER BY variable_identifier;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1;" 
"" 
"  SET mysql_proc_name = 'icc_core';" 
"  SET @xxxmdbug_surrogate_routine_identifier = @xxxmdbug_icc_core_surrogate_name;" 
"  SET mysql_proc_db='xxxmdbug';" 
"  SET mysql_proc_type = 'PROCEDURE';" 
"" 
"  /* Opening matches what is in generate(). */" 
"  SET v_g = CONCAT('DROP ',mysql_proc_type,' IF EXISTS ',mysql_proc_db,'.',@xxxmdbug_surrogate_routine_identifier,';',@xxxmdbug_lf);" 
"" 
"  SET v_g = CONCAT(v_g,'CREATE ');" 
"" 
"  SET v_g = CONCAT(v_g," 
"                   mysql_proc_type," 
"                   ' '," 
"                   mysql_proc_db,'.',@xxxmdbug_surrogate_routine_identifier," 
"                   '(line_number INT) ');" 
"" 
"  SET v_offset_of_begin=LENGTH(v_g)+LENGTH(@xxxmdbug_lf);" 
"" 
"/* part 1 -- as far as the first 'call xxxmdbug.process_user_command'." 
"   v_ret and v_prefix are part of the variant. */" 
"/* todo: as far as I can tell, the initial label 'z:' is not needed */" 
"  SET v_g = concat(v_g,'z:BEGIN',@xxxmdbug_lf," 
"                   'DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8;',@xxxmdbug_lf," 
"                   'DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;',@xxxmdbug_lf," 
"                   'DECLARE sleep_result INT;',@xxxmdbug_lf," 
"                   'DECLARE v_n INT;',@xxxmdbug_lf," 
"                   'DECLARE v_flags INT;',@xxxmdbug_lf," 
"                   'DECLARE v_table_is_temporary_and_to_be_cleared INT;',@xxxmdbug_lf," 
"                   'SET @xxxmdbug_token_value_1 = '''';',@xxxmdbug_lf," 
"                   'SET @xxxmdbug_icc_count=@xxxmdbug_icc_count+1;',@xxxmdbug_lf," 
"                   'x1: LOOP',@xxxmdbug_lf," 
"                   'CALL xxxmdbug.icc_get_user_command(0);',@xxxmdbug_lf," 
"                   'IF @xxxmdbug_message  <= 0x20 THEN LEAVE x1; END IF;',@xxxmdbug_lf,"
"                   'IF @xxxmdbug_token_value_1   IN (''continue'',''exit'',''leave'',''next'',''execute'',''skip'',''step'') THEN LEAVE x1; END IF;',@xxxmdbug_lf,"
"                   'IF @xxxmdbug_token_value_2  = ''user_variables'' THEN',@xxxmdbug_lf,"
"                   'SET v_ret='''';',@xxxmdbug_lf);" 
"/* part 1 end */" 
"" 
"  OPEN c;" 
"  x: LOOP" 
"    FETCH c INTO v_variable_name;" 
"    IF eof = 1 THEN LEAVE x; END IF;" 
"    SET v_g = CONCAT(v_g,'SET @xxxmdbug_uvar='," 
"                         v_variable_name," 
"                         ';'," 
"                         'SET @xxxmdbug_old_uvar=','@xxxmdbug_old_',RIGHT(v_variable_name,LENGTH(v_variable_name)-1),';'," 
"                         'CALL xxxmdbug.uvar(v_ret,'''," 
"                         v_variable_name," 
"                         ''');');" 
"    END LOOP;" 
"  CLOSE c;" 
"  SET v_g = CONCAT(v_g,'SET v_prefix = CONCAT(''xxxmdbug_'',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_user_variables);',@xxxmdbug_lf," 
"                       'CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);',@xxxmdbug_lf," 
"                       'CALL xxxmdbug.icc_change_statement_status(''OK'');',@xxxmdbug_lf," 
"                       'ELSE',@xxxmdbug_lf," 
"                       'CALL xxxmdbug.icc_process_user_command();',@xxxmdbug_lf," 
"                       'END IF;',@xxxmdbug_lf);" 
"" 
"  SET v_g = concat(v_g,'IF @xxxmdbug_token_value_1 = ''set'' AND LEFT(@xxxmdbug_token_value_2,1) = ''@'' AND LEFT(@xxxmdbug_token_value_2,2) <> ''@@'' THEN',@xxxmdbug_lf," 
"                        'SET @xxxmdbug_status_last_command = ''set'';',@xxxmdbug_lf," 
"                        'SET @xxxmdbug_tmp_for_set=''Fail'';',@xxxmdbug_lf);" 
"  OPEN c;" 
"  SET eof = 0;" 
"  x44: LOOP" 
"    FETCH c INTO v_variable_name;" 
"    IF eof = 1 THEN LEAVE x44; END IF;" 
"    SET v_g = CONCAT(v_g,'IF @xxxmdbug_token_value_2  = ''',"
"                         v_variable_name,"
"                         ''' THEN CALL xxxmdbug.retype(); SET '," 
"                         v_variable_name," 
"                         '= @xxxmdbug_token_value_4a; SET @xxxmdbug_tmp_for_set=''OK''; END IF; ',@xxxmdbug_lf);" 
"    END LOOP;" 
"  SET v_g = concat(v_g,'CALL xxxmdbug.icc_change_statement_status(@xxxmdbug_tmp_for_set);',@xxxmdbug_lf);" 
"  CLOSE c;" 
"  SET v_g = concat(v_g,'END IF;',@xxxmdbug_lf);" 
"" 
"/* part 2 */" 
"  SET v_g = concat(v_g,'END LOOP;',@xxxmdbug_lf," 
"                       'SET @xxxmdbug_status_line_number = line_number;',@xxxmdbug_lf," 
"                       'CALL xxxmdbug.icc_breakpoint_check(line_number,@xxxmdbug_breakpoint_check_result);',@xxxmdbug_lf," 
"                       'SET @xxxmdbug_status_breakpoint_check_result = @xxxmdbug_breakpoint_check_result;',@xxxmdbug_lf," 
"                       'CALL xxxmdbug.icc_send_statement_status(''icc_core'');',@xxxmdbug_lf," 
"                       'IF @xxxmdbug_breakpoint_check_result > 0 THEN',@xxxmdbug_lf," 
"                       'x2: LOOP',@xxxmdbug_lf," 
"                       'IF @xxxmdbug_token_value_1 IN (''continue'',''exit'',''leave'',''next'',''execute'',''skip'',''step'') THEN',@xxxmdbug_lf,"
"                       'LEAVE x2;',@xxxmdbug_lf,"
"                       'END IF;',@xxxmdbug_lf," 
"                       'CALL xxxmdbug.icc_get_user_command(1);',@xxxmdbug_lf," 
"                       'IF @xxxmdbug_token_value_1 IN (''next'',''step'') THEN CALL xxxmdbug.icc_process_user_command_step_or_next(); END IF;',@xxxmdbug_lf," 
"                       'IF @xxxmdbug_token_value_1 IN (''continue'',''exit'',''leave'',''next'',''execute'',''skip'',''step'') THEN',@xxxmdbug_lf,"
"                       'LEAVE x2;',@xxxmdbug_lf,"
"                       'END IF;',@xxxmdbug_lf," 
"                       'IF @xxxmdbug_token_value_2 = ''user_variables'' THEN',@xxxmdbug_lf," 
"                       'SET v_ret='''';',@xxxmdbug_lf);" 
"/* part2 end */" 
"" 
"  OPEN c;" 
"  SET eof = 0;" 
"  x_s: LOOP" 
"    FETCH c INTO v_variable_name;" 
"    IF eof = 1 THEN LEAVE x_s; END IF;" 
"    SET v_g = CONCAT(v_g,'SET @xxxmdbug_uvar='," 
"                         v_variable_name," 
"                         ';'," 
"                         'SET @xxxmdbug_old_uvar=','@xxxmdbug_old_',RIGHT(v_variable_name,LENGTH(v_variable_name)-1),';'," 
"                         'CALL xxxmdbug.uvar(v_ret,'''," 
"                         v_variable_name," 
"                         ''');');" 
"    END LOOP;" 
"  CLOSE c;" 
"  SET v_g = CONCAT(v_g,'SET v_prefix = CONCAT(''xxxmdbug_'',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_user_variables);',@xxxmdbug_lf," 
"                       'CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);',@xxxmdbug_lf," 
"                       'CALL xxxmdbug.icc_change_statement_status(''OK'');',@xxxmdbug_lf," 
"                       'ELSE',@xxxmdbug_lf," 
"                       'CALL xxxmdbug.icc_process_user_command();',@xxxmdbug_lf," 
"                       'END IF;',@xxxmdbug_lf);" 
"" 
"  SET v_g = concat(v_g,'IF @xxxmdbug_token_value_1 = ''set'' AND LEFT(@xxxmdbug_token_value_2,1) = ''@''  AND LEFT(@xxxmdbug_token_value_2,2) <> ''@@'' THEN',@xxxmdbug_lf," 
"                        'SET @xxxmdbug_status_last_command = ''set'';',@xxxmdbug_lf," 
"                        'SET @xxxmdbug_tmp_for_set = ''Fail'';',@xxxmdbug_lf);" 
"  OPEN c;" 
"  SET eof = 0;" 
"  x44: LOOP" 
"    FETCH c INTO v_variable_name;" 
"    IF eof = 1 THEN LEAVE x44; END IF;" 
"    SET v_g = CONCAT(v_g,'IF @xxxmdbug_token_value_2 = '''," 
"                         v_variable_name," 
"                         ''' THEN CALL xxxmdbug.retype(); SET '," 
"                         v_variable_name," 
"                         '= @xxxmdbug_token_value_4a; SET @xxxmdbug_tmp_for_set = ''OK''; END IF; ',@xxxmdbug_lf);" 
"    END LOOP;" 
"  CLOSE c;" 
"  SET v_g = CONCAT(v_g,'CALL xxxmdbug.icc_change_statement_status(@xxxmdbug_tmp_for_set);',@xxxmdbug_lf);" 
"  SET v_g = concat(v_g,'END IF;',@xxxmdbug_lf);" 
"" 
"/* part 3 start */" 
"  SET v_g = concat(v_g,'CALL xxxmdbug.icc_send_statement_status(''icc_core'');',@xxxmdbug_lf," 
"                       'END LOOP;',@xxxmdbug_lf," 
"" 
"                       'CALL xxxmdbug.icc_send_statement_status(''icc_core'');',@xxxmdbug_lf," 
"                       'END IF;',@xxxmdbug_lf);" 
"/* part 3 end */" 
"" 
"/* part 4 */" 
"  /* Copy all user variables to old user variables. For example, if there is" 
"     a user variable @a, this will generate \"SET @xxxmdbug_old_a=@a;\"." 
"     Results should show up in user_variables.old_value column." 
"     Todo: check for too-long variable names." 
"     Todo: there has to be some way to clean up all the @xxxmdbug_old_ variables. */" 
"  OPEN c;" 
"  SET eof = 0;" 
"  xoldcopy: LOOP" 
"    FETCH c INTO v_variable_name;" 
"    IF eof = 1 THEN LEAVE xoldcopy; END IF;" 
"    SET v_g = CONCAT(v_g,'SET @xxxmdbug_old_',RIGHT(v_variable_name,LENGTH(v_variable_name)-1),'=',v_variable_name,';',@xxxmdbug_lf);" 
"    END LOOP;" 
"  CLOSE c;" 
"" 
"  SET v_g = CONCAT(v_g,'END;',@xxxmdbug_lf);" 
"" 
"  INSERT INTO xxxmdbug.routines" 
"  VALUES (mysql_proc_db,mysql_proc_name,@xxxmdbug_surrogate_routine_identifier,@xxxmdbug_timestamp,'','',mysql_proc_type,v_g,v_g,v_offset_of_begin);" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* icc_start is called before the variable-copying and" 
"   breakpoint-checking which will change the warning list." 
"   Store @@warning_count so icc_end() can later signal \"there were warnings\"." 
"   We can't preserve the original warnings but we can put a generic message in." 
"   This only affects rare situations like this:" 
"     SET smallint_variable=99999;  causes a warning" 
"     SET i=i;                      doesn't change the warning list" 
"     SHOW WARNINGS                 shows the warning list" 
"   Todo: use GET DIAGNOSTICS if version = 5.6. */" 
"CREATE PROCEDURE xxxmdbug.icc_start (v_line_number_of_start_of_first_token INT," 
"                                                is_first_statement_in_a_handler INT)" 
"BEGIN" 
"  DECLARE v_table_is_in_scope INT;" 
"  DECLARE v_n INT;" 
"  DECLARE v_flags INT;" 
"  DECLARE v_schema VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_type VARCHAR(10) CHARACTER SET utf8;" 
"  SET @xxxmdbug_warning_count = @@warning_count; /* todo: unnecessary now, I think */" 
"  /* UPDATE variables SET is_in_scope=0; */ /* start with assumption = all variables out of scope */" 
"  SET v_n=0;" 
"  x: LOOP" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_variables_is_in_scope,5,v_n,v_table_is_in_scope,v_flags);" 
"    IF v_flags=-1 THEN LEAVE x; END IF;" 
"    CALL xxxmdbug.fixed_update(@xxxmdbug_variables_is_in_scope,5,v_n,0);" 
"    SET v_n=v_n+1;" 
"    END LOOP;" 
"  IF is_first_statement_in_a_handler = 1 THEN" 
"    /* update the last statements_executed row */" 
"    CALL xxxmdbug.update_statements_executed(4);" 
"    END IF;" 
"  /* insert the new statements_executed row */" 
"" 
"  CALL xxxmdbug.get_current_schema_identifier_and_routine_identifier(v_schema,v_routine,v_routine_type);" 
"  IF LENGTH(@xxxmdbug_statements_executed_schema_identifier)/80 >= @xxxmdbug_max_executed_statements_rows THEN" 
"    CALL xxxmdbug.fixed_delete(@xxxmdbug_statements_executed_schema_identifier,80,0);" 
"    CALL xxxmdbug.fixed_delete(@xxxmdbug_statements_executed_routine_identifier,80,0);" 
"    CALL xxxmdbug.fixed_delete(@xxxmdbug_statements_executed_routine_type,16,0);" 
"    CALL xxxmdbug.fixed_delete(@xxxmdbug_statements_executed_number,10,0);" 
"    CALL xxxmdbug.fixed_delete(@xxxmdbug_statements_executed_caught_by_no_handler,10,0);" 
"    CALL xxxmdbug.fixed_delete(@xxxmdbug_statements_executed_caught_by_sqlwarning_handler,10,0);" 
"    CALL xxxmdbug.fixed_delete(@xxxmdbug_statements_executed_caught_by_sqlexception_handler,10,0);" 
"    CALL xxxmdbug.fixed_delete(@xxxmdbug_statements_executed_caught_by_not_found_handler,10,0);" 
"    CALL xxxmdbug.fixed_delete(@xxxmdbug_statements_executed_caught_by_user_written_handler,10,0);" 
"    CALL xxxmdbug.fixed_delete(@xxxmdbug_statements_executed_row_count,10,0);" 
"    END IF;" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_statements_executed_schema_identifier,80,v_schema);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_statements_executed_routine_identifier,80,v_routine);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_statements_executed_routine_type,16,v_routine_type);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_statements_executed_number,10,v_line_number_of_start_of_first_token);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_statements_executed_caught_by_no_handler,10,0);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_statements_executed_caught_by_sqlwarning_handler,10,0);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_statements_executed_caught_by_sqlexception_handler,10,0);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_statements_executed_caught_by_not_found_handler,10,0);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_statements_executed_caught_by_user_written_handler,10,0);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_statements_executed_row_count,10,0);" 
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* We generate \"call icc_end()\" after \"call icc_core()\" and after checking for 'set' or 'execute'," 
"   but before checking for 'leave' or 'skip'. So this is the appropriate place to delete all" 
"   temporary_and_is_to_be_cleared breakpoints -- if we did it before checking 'set', we could" 
"   do it twice because \"call icc_core\" is inside a loop. Also we preserved @@warning_count from" 
"   the last executed statement during \"call icc_start\", though I think this signal does little good. */" 
"CREATE PROCEDURE xxxmdbug.icc_end ()" 
"BEGIN" 
"  DECLARE v_n INT;" 
"  DECLARE v_flags INT;" 
"  DECLARE v_table_is_temporary_and_to_be_cleared INT;" 
"  DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN END;" 
"" 
"  IF @xxxmdbug_breakpoint_check_result>0 THEN" 
"    /* DELETE FROM breakpoints WHERE is_temporary_and_to_be_cleared = 1; */" 
"    SET v_n=0;" 
"    xd: LOOP" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_is_temporary_and_to_be_cleared,5,v_n,v_table_is_temporary_and_to_be_cleared,v_flags);" 
"      IF v_flags=-1 THEN LEAVE xd; END IF;" 
"      IF v_table_is_temporary_and_to_be_cleared=1 THEN" 
"        CALL xxxmdbug.breakpoint_delete(v_n);" 
"        SET v_n=v_n-1;" 
"        END IF;" 
"      SET v_n=v_n+1;" 
"      END LOOP;" 
"    END IF;" 
"" 
"  IF @xxxmdbug_warning_count>0 THEN" 
"    SIGNAL SQLSTATE '01000' SET message_text = 'The Debugger has removed one or more warnings.';" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* There is a generated 'call xxxmdbug.update_statements_executed()' call" 
"   after the generated statement." 
"   After reaching a maximum number of rows, start delete-before-insert to maintain a constant size." 
"   todo: consider changing from line number to statement number within the routine" 
"   todo: send status so 'i status' knows the statement is done" 
"   todo: if the line number is the same as last time, then update rather than insert: ++ the relevant columns" 
"    */" 
"CREATE PROCEDURE xxxmdbug.update_statements_executed (statement_result_type INT)" 
"BEGIN" 
"  DECLARE v_caught_by_no_handler INT DEFAULT 0;" 
"  DECLARE v_caught_by_sqlwarning_handler INT DEFAULT 0;" 
"  DECLARE v_caught_by_sqlexception_handler INT DEFAULT 0;" 
"  DECLARE v_caught_by_not_found_handler INT DEFAULT 0;" 
"  DECLARE v_caught_by_user_written_handler INT DEFAULT 0;" 
"  DECLARE v_row_count INT DEFAULT 0;" 
"  DECLARE v_n INT;" 
"" 
"  IF statement_result_type = 0 THEN SET v_caught_by_no_handler = 1; END IF;" 
"  IF statement_result_type = 1 THEN SET v_caught_by_sqlexception_handler = 1; END IF;" 
"  IF statement_result_type = 2 THEN SET v_caught_by_sqlwarning_handler = 1; END IF;" 
"  IF statement_result_type = 3 THEN SET v_caught_by_not_found_handler = 1; END IF;" 
"  IF statement_result_type = 4 THEN SET v_caught_by_user_written_handler = 1; END IF;" 
"  SET v_row_count = ROW_COUNT();" 
"" 
"  SET v_n = LENGTH(@xxxmdbug_statements_executed_caught_by_no_handler)/10 - 1;" 
"  CALL xxxmdbug.fixed_update(@xxxmdbug_statements_executed_caught_by_no_handler,10,v_n,v_caught_by_no_handler);" 
"  CALL xxxmdbug.fixed_update(@xxxmdbug_statements_executed_caught_by_sqlwarning_handler,10,v_n,v_caught_by_sqlwarning_handler);" 
"  CALL xxxmdbug.fixed_update(@xxxmdbug_statements_executed_caught_by_sqlexception_handler,10,v_n,v_caught_by_sqlexception_handler);" 
"  CALL xxxmdbug.fixed_update(@xxxmdbug_statements_executed_caught_by_not_found_handler,10,v_n,v_caught_by_not_found_handler);" 
"  CALL xxxmdbug.fixed_update(@xxxmdbug_statements_executed_caught_by_user_written_handler,10,v_n,v_caught_by_user_written_handler);" 
"  CALL xxxmdbug.fixed_update(@xxxmdbug_statements_executed_row_count,10,v_n,v_row_count);" 
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* We generate 'call insert_into_prepared_statements()' when we see 'PREPARE'." 
"   We generate 'call delete_from_prepared_statements()' when we see 'DEALLOCATE'." 
"   todo: you forgot to delete old for prepare (prepare automatically overwrites) */" 
"CREATE PROCEDURE xxxmdbug.insert_into_prepared_statements (statement_name VARCHAR(66) CHARACTER SET utf8," 
"                                                                      statement_text VARCHAR(66) CHARACTER SET utf8)" 
"BEGIN" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_prepared_statements_statement_name,80,statement_name);" 
"  CALL xxxmdbug.fixed_insert(@xxxmdbug_prepared_statements_statement_text,80,statement_text);" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"CREATE PROCEDURE xxxmdbug.delete_from_prepared_statements (statement_name VARCHAR(66) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_n INT;" 
"  DECLARE v_table_statement_name VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_flags INT;" 
"  SET v_n=0;" 
"  x: LOOP" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_prepared_statements_statement_name,80,v_n,v_table_statement_name,v_flags);" 
"    IF v_flags=-1 THEN LEAVE x; END IF;" 
"    IF v_table_statement_name  = statement_name THEN"
"      CALL xxxmdbug.fixed_delete(@xxxmdbug_prepared_statements_statement_name,80,v_n);" 
"      CALL xxxmdbug.fixed_delete(@xxxmdbug_prepared_statements_statement_text,80,v_n);" 
"      LEAVE x;" 
"      END IF;" 
"    SET v_n = v_n+ 1;" 
"    END LOOP;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.create_setup_log_table ()" 
"BEGIN" 
"  CREATE TABLE IF NOT EXISTS xxxmdbug.setup_log (" 
"    group_name VARCHAR(3) CHARACTER SET utf8," 
"    user VARCHAR(80) CHARACTER SET utf8," 
"    version_number_of_debugger CHAR(5) CHARACTER SET utf8," 
"    timestamp_when_setup_procedure_was_run DATETIME," 
"    arguments_passed_to_setup VARCHAR(8192) CHARACTER SET utf8," 
"    routine_type VARCHAR(10) CHARACTER SET utf8, /* procedure|function. not event|trigger yet. */" 
"    schema_identifier VARCHAR(66) CHARACTER SET utf8," 
"    original_routine_identifier VARCHAR(66) CHARACTER SET utf8," 
"    surrogate_routine_identifier VARCHAR(66) CHARACTER SET utf8," 
"    outcome VARCHAR(66) CHARACTER SET utf8, /* Made surrogate, Overwrote, or Failed */" 
"    invocations_of_routines_in_same_group INT," 
"    invocations_of_routines_in_any_group INT," 
"    comment_based_on_generate VARCHAR(66) CHARACTER SET utf8," 
"    comment_based_on_readme VARCHAR(66) CHARACTER SET utf8) engine=myisam;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.create_routines_table ()" 
"BEGIN" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.routines;" 
"  CREATE TEMPORARY TABLE xxxmdbug.routines (" 
"  schema_identifier_of_original VARCHAR(66) CHARACTER SET utf8," 
"  routine_identifier_of_original VARCHAR(66) CHARACTER SET utf8," 
"  routine_identifier_of_surrogate VARCHAR(66) CHARACTER SET utf8," 
"  last_altered DATETIME," 
"  param_list VARCHAR(8192) CHARACTER SET utf8," 
"  returns VARCHAR(10) CHARACTER SET utf8,                       /* someday view|event|function|procedure|trigger */" 
"  routine_type VARCHAR(10) CHARACTER SET utf8," 
"  definition_of_original_routine LONGTEXT CHARACTER SET utf8," 
"  definition_of_surrogate_routine LONGTEXT CHARACTER SET utf8," 
"  offset_of_begin INT) engine=myisam;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.create_tokens_table ()" 
"BEGIN" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.tokens;" 
"  CREATE TEMPORARY TABLE xxxmdbug.tokens (" 
"                       schema_identifier VARCHAR(66) CHARACTER SET utf8," 
"                       routine_identifier VARCHAR(66) CHARACTER SET utf8," 
"                       routine_type VARCHAR(10) CHARACTER SET utf8," 
"                       token_number int primary key," 
"                       offsetx INT," 
"                       line_number INT," 
"                       value VARCHAR(16384) CHARACTER SET utf8) engine=myisam;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* TODO: get rid of statement_number_within_routine, apparently it's always the same as statement_number. */" 
"CREATE PROCEDURE xxxmdbug.create_statements_table ()" 
"BEGIN" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.statements;"
"  CREATE TEMPORARY TABLE xxxmdbug.statements ("
"  statement_number INT," 
"  schema_identifier VARCHAR(66) CHARACTER SET utf8," 
"  routine_identifier VARCHAR(66) CHARACTER SET utf8," 
"  routine_type VARCHAR(10) CHARACTER SET utf8," 
"  statement_number_within_routine INT," 
"  token_number_of_first_token INT," 
"  line_number_of_start_of_first_token INT," 
"  character_number_of_start_of_first_token INT," 
"  token_number_of_last_token INT," 
"  line_number_of_end_of_last_token INT," 
"  character_number_of_end_of_last_token INT," 
"  statement_type enum('flow_control','declare_variable','declare_handler','declare_condition','declare_cursor','debuggable','unknown')," 
"  is_leave_possible INT) engine=memory;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.create_variables_table ()" 
"BEGIN" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.variables;" 
"  CREATE TEMPORARY TABLE xxxmdbug.variables (" 
"  schema_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  routine_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  routine_type VARCHAR(10) CHARACTER SET utf8 DEFAULT ''," 
"  token_number_of_declare INT DEFAULT 0," 
"  variable_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  data_type VARCHAR(66) CHARACTER SET utf8 DEFAULT '',                       /* todo: this might be too small for ENUM and SET */" 
"  value VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  old_value VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  is_in_scope INT DEFAULT 0," 
"  is_settable INT DEFAULT 0," 
"  is_updated_by_set INT DEFAULT 0) engine=memory;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.create_tmp_user_variables_table ()" 
"BEGIN" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.tmp_user_variables;" 
"  CREATE TEMPORARY TABLE xxxmdbug.tmp_user_variables (" 
"  variable_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT '') engine=memory;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.create_server_variables_table ()" 
"BEGIN" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.server_variables;" 
"  CREATE TEMPORARY TABLE xxxmdbug.server_variables (" 
"  schema_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  routine_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  routine_type VARCHAR(10) CHARACTER SET utf8 DEFAULT ''," 
"  token_number_of_declare INT DEFAULT 0," 
"  variable_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  data_type VARCHAR(66) CHARACTER SET utf8 DEFAULT '',                       /* todo: this might be too small for ENUM and SET */" 
"  value VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  old_value VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  is_in_scope INT DEFAULT 0," 
"  is_settable INT DEFAULT 0," 
"  is_updated_by_set INT DEFAULT 0) engine=memory;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.create_user_variables_table ()" 
"BEGIN" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.user_variables;" 
"  CREATE TEMPORARY TABLE xxxmdbug.user_variables (" 
"  schema_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  routine_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  routine_type VARCHAR(10) CHARACTER SET utf8 DEFAULT ''," 
"  token_number_of_declare INT DEFAULT 0," 
"  variable_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  data_type VARCHAR(66) CHARACTER SET utf8 DEFAULT '',                       /* todo: this might be too small for ENUM and SET */" 
"  value VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  old_value VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  is_in_scope INT DEFAULT 0," 
"  is_settable INT DEFAULT 0," 
"  is_updated_by_set INT DEFAULT 0) engine=memory;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.create_prepared_statements_table ()" 
"BEGIN" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.prepared_statements;" 
"  CREATE TEMPORARY TABLE xxxmdbug.prepared_statements (" 
"  statement_name VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  statement_text VARCHAR(66) CHARACTER SET utf8 DEFAULT '');" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* xxxmdbug.breakpoints is a TEMPORARY table in xxxmdbug." 
"   The debugger uses it, but the debuggee does not (it simulates with fixed_select etc.)." 
"   The create_breakpoints_table() procedure is called for command('r breakpoints'). */" 
"CREATE PROCEDURE xxxmdbug.create_breakpoints_table ()" 
"BEGIN" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.breakpoints;" 
"  CREATE TEMPORARY TABLE xxxmdbug.breakpoints (" 
"  breakpoint_identifier INT primary key," 
"  schema_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  routine_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  routine_type VARCHAR(10) CHARACTER SET utf8 DEFAULT ''," 
"  line_number_minimum INT DEFAULT 0," 
"  line_number_maximum INT DEFAULT 0," 
"  condition_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  condition_operator VARCHAR(2) CHARACTER SET utf8 DEFAULT ''," 
"  condition_value VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  hit_count INT DEFAULT 0," 
"  is_temporary INT DEFAULT 0," 
"  is_temporary_and_to_be_cleared INT DEFAULT 0," 
"  is_matching_location INT DEFAULT 0," 
"  is_matching_condition INT DEFAULT 0," 
"  call_stack_depth_when_set INT DEFAULT 0," 
"  command VARCHAR(14) CHARACTER SET utf8 DEFAULT '') engine=memory;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.create_statements_executed_table ()" 
"BEGIN" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.statements_executed;" 
"  CREATE TEMPORARY TABLE xxxmdbug.statements_executed (" 
"  schema_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  routine_identifier VARCHAR(66) CHARACTER SET utf8 DEFAULT ''," 
"  routine_type VARCHAR(10) CHARACTER SET utf8 DEFAULT ''," 
"  number INT, /* i.e. line number */" 
"  caught_by_no_handler INT DEFAULT 0, /* went through to next statement without being caught by any handler */" 
"  caught_by_sqlwarning_handler INT DEFAULT 0, /* was caught by generated DECLARE EXIT HANDLER FOR SQLWARNING */" 
"  caught_by_sqlexception_handler INT DEFAULT 0, /* was caught by generated DECLARE EXIT HANDLER FOR SQLEXCEPTION */" 
"  caught_by_not_found_handler INT DEFAULT 0, /* was caught by generated DECLARE EXIT HANDLER FOR NOT FOUND */" 
"  caught_by_user_written_handler INT DEFAULT 0, /* was caught by user-written handler (usually more specific than warning/exception/not found) */" 
"  row_count INT DEFAULT 0) engine=memory;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* routine_identifier_of_surrogate = xxxmdbug xxx type routine_identifier" 
"   where xxx = set name = a 3-character value with character set { 0-9 A-Z }," 
"   up to 36 * 36 * 36 = 46656 possibilities, and it goes up every time we call setup()." 
"   where type = first letter of mysql.proc.type so 'P' for procedure and 'F' for function." 
"   This format is expected by debuggee_wait_loop()." 
"   In get_set_setup_group_name() all we do is get the 3-character string, @xxxmdbug_setup_group_name." 
"   Todo: explain what to do if set name reaches 'ZZZ'. */" 
"CREATE PROCEDURE xxxmdbug.get_setup_group_name ()" 
"BEGIN" 
"  DECLARE vxxx_as_number INT;" 
"  DECLARE v_digit1,v_digit2,v_digit3 INT;" 
"  DECLARE v_max_name VARCHAR(66) CHARACTER SET utf8 DEFAULT NULL;" 
"  DECLARE v_max_name_in_setup_log VARCHAR(66) CHARACTER SET utf8 DEFAULT NULL;" 
"" 
"  SELECT MAX(name) INTO v_max_name FROM mysql.proc WHERE name   LIKE 'xxxmdbug____%';"
"  SELECT MAX(surrogate_routine_identifier) INTO v_max_name_in_setup_log FROM xxxmdbug.setup_log WHERE surrogate_routine_identifier   LIKE 'xxxmdbug____%';"
"  IF v_max_name_in_setup_log > v_max_name OR v_max_name IS NULL THEN SET v_max_name = v_max_name_in_setup_log; END IF;" 
"" 
"  IF v_max_name IS NULL THEN" 
"    SET @xxxmdbug_setup_group_name = '000';" 
"  ELSE" 
"    SET @xxxmdbug_setup_group_name = SUBSTRING(v_max_name FROM LENGTH('xxxmdbug')+1 FOR 3);" 
"    IF @xxxmdbug_setup_group_name ='ZZZ' THEN"
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno,message_text='too many sets of surrogates';" 
"      END IF;" 
"    SET v_digit1 = ASCII(SUBSTRING(@xxxmdbug_setup_group_name FROM 1 FOR 1));" 
"    IF v_digit1 <= 57 THEN SET v_digit1 = v_digit1 - 48; ELSE SET v_digit1 = v_digit1 - (65-10); END IF;" 
"    SET v_digit2 = ASCII(SUBSTRING(@xxxmdbug_setup_group_name FROM 2 FOR 1));" 
"    IF v_digit2 <= 57 THEN SET v_digit2 = v_digit2 - 48; ELSE SET v_digit2 = v_digit2 - (65-10); END IF;" 
"    SET v_digit3 = ASCII(SUBSTRING(@xxxmdbug_setup_group_name FROM 3 FOR 1));" 
"    IF v_digit3 <= 57 THEN SET v_digit3 = v_digit3 - 48; ELSE SET v_digit3 = v_digit3 - (65-10); END IF;" 
"    SET vxxx_as_number = ((v_digit1 * 36 * 36) + (v_digit2 * 36) + v_digit3) + 1;" 
"    SET v_digit3 = MOD(vxxx_as_number,36);" 
"    SET v_digit2 = MOD((vxxx_as_number-v_digit3)/36,36);" 
"    SET v_digit1 = MOD((vxxx_as_number-(v_digit3+v_digit2*36))/(36*36),36);" 
"    IF v_digit1 <= 9 THEN SET v_digit1 = v_digit1 + 48; ELSE SET v_digit1 = v_digit1 + (65-10); END IF;" 
"    IF v_digit2 <= 9 THEN SET v_digit2 = v_digit2 + 48; ELSE SET v_digit2 = v_digit2 + (65-10); END IF;" 
"    IF v_digit3 <= 9 THEN SET v_digit3 = v_digit3 + 48; ELSE SET v_digit3 = v_digit3 + (65-10); END IF;" 
"    SET @xxxmdbug_setup_group_name = CONCAT(CHAR(v_digit1),CHAR(v_digit2),CHAR(v_digit3));" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.insert_into_routines (`p_db` VARCHAR(66) CHARACTER SET utf8," 
"                                      `p_name` VARCHAR(66) CHARACTER SET utf8," 
"                                      `language` VARCHAR(66) CHARACTER SET utf8," 
"                                      param_list VARCHAR(8192) CHARACTER SET utf8," 
"                                      returns VARCHAR(66) CHARACTER SET utf8," 
"                                      type VARCHAR(66) CHARACTER SET utf8," 
"                                      `body` longblob)" 
"x:" 
"BEGIN" 
"  DECLARE v_routine_identifier_of_surrogate VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_stripped_name VARCHAR(66) CHARACTER SET utf8 DEFAULT NULL;" 
"" 
"  SET v_stripped_name=TRIM(BOTH '`' FROM p_name);" 
"  SET v_routine_identifier_of_surrogate = CONCAT('`xxxmdbug'," 
"                                                 @xxxmdbug_setup_group_name," 
"                                                 LEFT(type,1)," 
"                                                 v_stripped_name,'`');" 
"  INSERT INTO xxxmdbug.routines" 
"  VALUES (p_db,p_name,v_routine_identifier_of_surrogate,@xxxmdbug_timestamp,param_list,returns,type,body,NULL,NULL);" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.insert_into_statements (mysql_proc_db VARCHAR(66) CHARACTER SET utf8, mysql_proc_name VARCHAR(66) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_token_number INT;" 
"  DECLARE v_offset INT;" 
"  DECLARE v_line_number INT;" 
"  DECLARE v_value VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_value_of_first_token VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE eof INT DEFAULT 0;" 
"  DECLARE last_token_was_end_of_statement INT DEFAULT 1;" 
"  DECLARE v_token_number_of_first_token INT;" 
"  DECLARE v_line_number_of_first_token INT;" 
"  DECLARE v_offset_of_first_token INT;" 
"  DECLARE v_statement_number INT DEFAULT 0;" 
"  DECLARE end_of_declare_handler INT;" 
"  DECLARE v_statement_type enum('flow_control','declare_variable','declare_handler','declare_condition','declare_cursor','debuggable','unknown');" 
"  DECLARE v_previous_statement_type enum('flow_control','declare_variable','declare_handler','declare_condition','declare_cursor','debuggable','unknown');" 
"  DECLARE v_value_of_third_token VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_value_of_next_token VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_value_of_next_next_token VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_is_leave_possible INT;" 
"  DECLARE c CURSOR FOR SELECT token_number,offsetx,line_number,value" 
"                       FROM xxxmdbug.tokens" 
"                       WHERE schema_identifier COLLATE utf8_general_ci= mysql_proc_db AND routine_identifier = mysql_proc_name"
"                       ORDER BY token_number;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1;" 
"" 
"  SET v_statement_type=NULL; /* unnecessary */" 
"  OPEN c;" 
"  x: LOOP" 
"    FETCH c INTO v_token_number,v_offset,v_line_number,v_value;" 
"    IF v_line_number = 0 THEN ITERATE x; END IF; /* skip if line_number =0 because that's the parameter list */" 
"    IF eof <> 1 AND last_token_was_end_of_statement=1 THEN" 
"      /* This is the start of a statement */" 
"      SET v_value_of_first_token = v_value;" 
"      SET v_token_number_of_first_token = v_token_number;" 
"      SET v_line_number_of_first_token = v_line_number;" 
"      SET v_offset_of_first_token = v_offset;" 
"      SET v_statement_number = v_statement_number + 1;" 
"      SET last_token_was_end_of_statement = 0;" 
"      SET v_is_leave_possible = 1;" 
"      END IF;" 
"    /* DECLARE handler_action FOR condition [,condition] is hairy. */" 
"    SET end_of_declare_handler = 0;" 
"    IF eof <> 1 THEN" 
"      IF v_value_of_first_token = 'DECLARE' THEN" 
"        SELECT value INTO @xxxmdbug_tmp_1 FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_first_token+2;" 
"        SET v_value_of_third_token = @xxxmdbug_tmp_1;" 
"        IF v_token_number > (v_token_number_of_first_token+3)" 
"        AND v_value <> 'NOT'" 
"        AND v_value <> ',' THEN" 
"          SELECT value INTO @xxxmdbug_tmp_1 FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_first_token+2;" 
"          IF v_value_of_third_token = 'HANDLER' THEN" 
"            SELECT value INTO @xxxmdbug_tmp_2 FROM xxxmdbug.tokens WHERE token_number = v_token_number+1;" 
"            IF @xxxmdbug_tmp_2 <> ',' THEN" 
"              SET end_of_declare_handler = 1;" 
"              END IF;" 
"            END IF;" 
"          END IF;" 
"        END IF;" 
"      END IF;" 
"    /* The verb REPEAT is a troublemaker." 
"       First, because it could be mixed up with the function REPEAT()." 
"       Second, because UNTIL does not end with ';'." 
"       For both cases, we need to look at the next token in the coming checks." 
"       Fetching 'next next' could cause the NOT FOUND handler to set eof = 1 so restore it. */" 
"    IF eof = 0 THEN" 
"      SELECT value INTO v_value_of_next_token FROM xxxmdbug.tokens WHERE token_number = v_token_number+1;" 
"      SELECT value INTO v_value_of_next_next_token FROM xxxmdbug.tokens WHERE token_number = v_token_number+2;" 
"      SET eof = 0;" 
"    ELSE" 
"      SET v_value_of_next_token = '';" 
"      END IF;" 
"    IF eof = 1" 
"    OR v_value  = ';'"
"    OR v_value  = ':' /* Treat 'label:' as a statement, though of course not executable */"
"    /* Some sequences get special treatment -- end of non-debuggable. */" 
"    OR v_value   in ('BEGIN', 'LOOP') /* standalone */"
//"    OR v_value  = 'ELSE' and v_value_of_first_token   IN ('IF','ELSEIF','CASE','WHEN')"
"    OR v_value  = 'ELSE'"
"    OR v_value  = 'REPEAT' AND v_value_of_next_token  <> '(' /* standalone */"
"    OR v_value  = 'DO' and v_value_of_first_token  = 'WHILE'"
"    OR v_value_of_next_token  = 'END' and v_value_of_first_token  = 'UNTIL' and v_value_of_next_next_token  = 'REPEAT'"
"    /* todo: figure out why you have 'CASE' here -- how is it possible? */" 
"    OR v_value  = 'THEN' and v_value_of_first_token   IN ('IF','ELSEIF','CASE','WHEN')"
"    OR end_of_declare_handler = 1" 
"    THEN" 
"      /* This is the end of a statement */" 
"      SET v_previous_statement_type = v_statement_type;" 
"      SET v_statement_type = 'unknown';" 
"      IF v_value_of_first_token  = 'DECLARE' THEN"
"        IF v_value_of_third_token  = 'HANDLER' THEN SET v_statement_type = 'declare_handler';"
"          ELSEIF v_value_of_third_token  = 'CONDITION' THEN SET v_statement_type = 'declare_condition';"
"          ELSEIF v_value_of_third_token  = 'CURSOR' THEN SET v_statement_type = 'declare_cursor';"
"          ELSE SET v_statement_type = 'declare_variable';" 
"          END IF;" 
"        END IF;" 
"      /* todo: think about 'LEAVE' and 'ITERATE'. maybe they should be flow_control rather than debuggable? */" 
"      /* todo: check whether ELSE and ELSEIF could be caught here, probably we are calling them 'unknown' but maybe it is deliberate */" 
//"      IF v_value_of_first_token IN ('BEGIN','CASE','IF','LOOP','REPEAT','WHILE') THEN"
"      IF v_value_of_first_token   IN ('BEGIN','CASE','ELSE','IF','LOOP','REPEAT','WHILE') THEN"
"        set v_statement_type = 'flow_control';" 
"        END IF;" 
"      /* TODO: check this list against all verbs in 5.6. */" 
"      /* Some of these verbs are not legal in prepared statements or routines, but let us anticipate change. */" 
"      IF @xxxmdbug_track_statements>0 THEN                               /* see setup_switches comments */" 
"        IF v_value_of_first_token   IN ('ALTER','ANALYZE','BACKUP','CACHE','CALL','CHANGE','CHECK','CHECKSUM',"
"                                      'CLOSE','CREATE','DEALLOCATE','DELETE','DESCRIBE','DO','DROP','EXECUTE','EXPLAIN','FETCH'," 
"                                      'FLUSH','GET','GRANT','HANDLER','HELP','INSERT','KILL','LOAD','LOCK','OPEN'," 
"                                      'OPTIMIZE','PREPARE','PURGE','RENAME','REPAIR','REPLACE','RESET','RESIGNAL','RESTORE'," 
"                                      'RETURN','REVOKE','ROLLBACK','SAVEPOINT','SELECT','SHOW','SIGNAL','START','STOP'," 
"                                      'TRUNCATE','UNLOCK','UPDATE','USE','XA') THEN" 
"          SET v_statement_type = 'debuggable';" 
"          END IF;" 
"        END IF;" 
"      IF @xxxmdbug_track_statements>1 THEN" 
"        IF v_value_of_first_token   IN ('ITERATE','LEAVE','SET') THEN"
"          SET v_statement_type = 'debuggable';" 
"          END IF;" 
"        END IF;" 
"      IF v_statement_type  = 'debuggable' THEN"
"        IF v_previous_statement_type = 'declare_handler' OR v_previous_statement_type IS NULL THEN" 
"          /* The immediately previous statement was nothing or was DECLARE ... HANDLER." 
"             That means that the debuggable statement which we see now is not in a compound statement." 
"             That means LEAVE is illegal. But that's okay, we can generate as we do for 'skip'" 
"             if we see that v_is_leave_possible = 0. */" 
"          SET v_is_leave_possible = 0;" 
"          END IF;" 
"        END IF;" 
"      INSERT INTO xxxmdbug.statements VALUES (" 
"      v_statement_number, /* statement_number */" 
"      mysql_proc_db, /* schema_identifier */" 
"      mysql_proc_name, /* routine_identifier */" 
"      'ROUTINE', /* routine_type */" 
"      v_statement_number, /* statement_number_within_routine */" 
"      v_token_number_of_first_token, /* token_number_of_first_token */" 
"      v_line_number_of_first_token, /* line_number_of_start_of_first_token */" 
"      v_offset_of_first_token, /* character_number_of_start_of_first_token */" 
"      v_token_number, /* token_number_of_last_token */" 
"      v_line_number, /* line_number_of_end_of_last_token */" 
"      v_offset+LENGTH(v_value), /* character_number_of_end_of_last_token */" 
"      v_statement_type, /* type */" 
"      v_is_leave_possible); /* is_leave_possible */" 
"      SET last_token_was_end_of_statement = 1;" 
"      END IF;" 
"    IF eof = 1 THEN LEAVE x; END IF;" 
"    END LOOP;" 
"  CLOSE c;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Most of insert_into_variables_parameters() is for parsing" 
"   parameter declarations which have the form" 
"   \"[ IN | OUT | INOUT ] param_name type [,...]\"" 
"   If the user said call setup('-track_declared_variables=0 ...') then we do nothing" 
"   For declared variables, see insert_into_variables_declared_variables" 
"   For user variables, see insert_into_variables_user_variables." 
"   */" 
"CREATE PROCEDURE xxxmdbug.insert_into_variables_parameters (mysql_proc_db VARCHAR(66) CHARACTER SET utf8, mysql_proc_name VARCHAR(66) CHARACTER SET utf8)" 
"BEGIN"
"  DECLARE v_token_number INT;"
"  DECLARE v_is_ENUM TINYINT;"
"  DECLARE v_token_number_of_first_token INT;" 
"  DECLARE v_value VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE eof INT DEFAULT 0;" 
"  DECLARE v_type VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_variable_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE c CURSOR FOR SELECT token_number, value FROM xxxmdbug.tokens" 
"  WHERE line_number = 0 AND schema_identifier COLLATE utf8_general_ci= mysql_proc_db AND routine_identifier = mysql_proc_name"
"  ORDER BY token_number;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1;" 
"  SET v_is_ENUM = 0;"
"  IF @xxxmdbug_track_declared_variables>0 THEN" 
"    OPEN c;" 
"    x: LOOP" 
"      FETCH c INTO v_token_number_of_first_token, v_value;" 
"      IF eof = 1 THEN LEAVE x; END IF;" 
"      IF v_value   = 'IN' OR v_value  = 'OUT' OR v_value  = 'INOUT' THEN ITERATE x; END IF;"
"      SET v_variable_identifier = v_value;" 
"      CALL xxxmdbug.add_delimiters(v_variable_identifier);" 
"      SET v_type = '';        /* we're about to see the type */" 
"      y: LOOP" 
"        FETCH c INTO v_token_number, v_value;" 
"        IF eof = 1 THEN LEAVE y; END IF;" 
"        IF v_value  = '(' THEN SET v_is_ENUM = 1; END IF;"
"        IF v_value  = ')' THEN SET v_is_ENUM = 0; END IF;"
"        IF (v_value  = ',' AND v_is_ENUM = 0) THEN LEAVE y; END IF;"
"        SET v_type = CONCAT(v_type,' ',v_value);" 
"        END LOOP;" 
"      INSERT INTO xxxmdbug.variables VALUES (" 
"      mysql_proc_db, /* schema_identifier */" 
"      mysql_proc_name, /* routine_identifier */" 
"      'ROUTINE', /* routine_type */" 
"      0, /* token_number_of_declare */" 
"      v_variable_identifier, /* variable_identifier */" 
"      TRIM(v_type), /* data_type */" 
"      NULL, /* value */" 
"      NULL, /* old_value */" 
"      NULL, /* is_in_scope */" 
"      NULL, /* is_settable */" 
"      NULL); /* is_updated_by_set */" 
"      END LOOP;" 
"    CLOSE c;" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Most of insert_into_variables_declared_variables() is for parsing" 
"   declared-variable declarations which have the form" 
"   \"DECLARE var_name [, var_name] ... type [DEFAULT value];\"." 
"   For user variables, see insert_into_variables_user_variables." 
"  If the user said call setup('-track_declared_variables=0 ...') then we do nothing" 
"   */" 
"CREATE PROCEDURE xxxmdbug.insert_into_variables_declared_variables (mysql_proc_db VARCHAR(66) CHARACTER SET utf8, mysql_proc_name VARCHAR(66) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_token_number_of_first_token INT;" 
"  DECLARE v_token_number_of_last_token INT;" 
"  DECLARE eof INT DEFAULT 0;" 
"  DECLARE v_token_number_x INT;" 
"  DECLARE v_type VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_variable_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE c CURSOR FOR SELECT token_number_of_first_token, token_number_of_last_token FROM xxxmdbug.statements" 
"  WHERE statement_type  = 'declare_variable' AND schema_identifier COLLATE utf8_general_ci = mysql_proc_db AND routine_identifier  = mysql_proc_name"
"  ORDER BY token_number_of_first_token;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1;" 
"  IF @xxxmdbug_track_declared_variables>0 THEN" 
"    OPEN c;" 
"    x: LOOP" 
"      FETCH c INTO v_token_number_of_first_token, v_token_number_of_last_token;" 
"      IF eof = 1 THEN LEAVE x; END IF;" 
"      SET v_token_number_x = v_token_number_of_first_token;       /* first_token = token number of declare */" 
"      x2: LOOP" 
"        SET v_token_number_x = v_token_number_x + 2;              /* token #x is a variable */" 
"        SET @xxxmdbug_x = (SELECT value FROM xxxmdbug.tokens WHERE token_number = v_token_number_x);" 
"        IF @xxxmdbug_x  <> ',' THEN LEAVE x2; END IF;                       /* (token (#x) is not ',' */"
"        END LOOP;" 
"      SET v_type = '';                                            /* we're about to see the type */" 
"      x3: LOOP" 
"        SET @xxxmdbug_x = (SELECT value FROM xxxmdbug.tokens WHERE token_number = v_token_number_x);" 
"        IF @xxxmdbug_x  = ';' OR @xxxmdbug_x  = 'DEFAULT' THEN LEAVE x3; END IF;      /* (token (#x+1) is not statement end */"
"        SET v_type = CONCAT(v_type,' ',@xxxmdbug_x);" 
"        SET v_token_number_x = v_token_number_x + 1;" 
"        END LOOP;" 
"      SET v_token_number_x = v_token_number_of_first_token;" 
"      x4: LOOP" 
"        SET v_token_number_x = v_token_number_x + 1;              /* token #x is a variable */" 
"        SET v_variable_identifier = (SELECT value FROM xxxmdbug.tokens WHERE token_number = v_token_number_x);" 
"        CALL xxxmdbug.add_delimiters(v_variable_identifier);" 
"        INSERT INTO xxxmdbug.variables VALUES (" 
"        mysql_proc_db, /* schema_identifier */" 
"        mysql_proc_name, /* routine_identifier */" 
"        'ROUTINE', /* routine_type */" 
"        v_token_number_of_first_token, /* token_number_of_declare */" 
"        v_variable_identifier, /* variable_identifier */" 
"        TRIM(v_type), /* data_type */" 
"        NULL, /* value */" 
"        NULL, /* old_value */" 
"        NULL, /* is_in_scope */" 
"        NULL, /* is_settable */" 
"        NULL); /* is_updated_by_set */" 
"        SET v_token_number_x = v_token_number_x + 1;" 
"        SET v_variable_identifier = (SELECT value FROM xxxmdbug.tokens WHERE token_number = v_token_number_x);" 
"        IF v_variable_identifier  <> ',' THEN LEAVE x4; END IF;"
"        END LOOP;" 
"      END LOOP;" 
"    CLOSE c;" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* We finished with declared variables." 
"   Now user variables, that is, any token that starts with '@'." 
"   Here we dump names that start with '@' into xxxmdbug.tmp_variables." 
"   Later we select distinct from xxxmdbug.tmp_variables and use the result as input for" 
"   generate_icc_core()." 
"   In the end the user sees these variables with command 'refresh user_variables'. */" 
"/* If the user said call setup('-track_user_variables=0 ...') then we do nothing. */" 
"/* todo: this is not handling already-delimited user variables correctly. */" 
"CREATE PROCEDURE xxxmdbug.insert_into_variables_user_variables ()" 
"BEGIN" 
"  DECLARE v_value VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE eof INT DEFAULT 0;" 
"  DECLARE c CURSOR FOR SELECT value FROM xxxmdbug.tokens; /* no order-by needed */" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1;" 
"  IF @xxxmdbug_track_user_variables > 0 THEN" 
"    OPEN c;" 
"    x: LOOP" 
"      FETCH c INTO v_value;" 
"      IF eof = 1 THEN LEAVE x; END IF;" 
"      IF LEFT(v_value,1)  = '@' AND SUBSTRING(v_value FROM 2 FOR 1) <> '@' THEN"
"        CALL xxxmdbug.add_delimiters(v_value);" 
"        /* If it's already in, don't insert duplicates. */" 
"        INSERT INTO xxxmdbug.tmp_user_variables VALUES (v_value);" 
"        END IF;" 
"      END LOOP;" 
"    CLOSE c;" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/*" 
"TODO:" 
"* ... it should be a setup option whether to check" 
"* you need to preserve that there was a warning, if any" 
"" 
"\"Checking if the routine is still valid\"" 
"Todo: test whether the select from information_schema.routines works even if you have no privilege for the routine now." 
"Todo: test whether you still have privilege for the routine now." 
"Todo: consider whether it is worth checking whether the routine has really changed significantly." 
"TODO: routine_entry() could also take a list of pre-set commands " 
"*/" 
"/* Given a string with token_number_of_declare,variable_identifier,data_type" 
"   for example '2,a. int;13,b. int;', insert into a VARIABLES table." 
"   warning: the number of tokens in data_type is unknown (think of ENUM), so proceed till you see ',' or ';' or end" 
"*/" 
"" 
"CREATE PROCEDURE xxxmdbug.routine_entry (" 
"                       mysql_proc_db VARCHAR(66) CHARACTER SET utf8," 
"                       mysql_proc_name VARCHAR(66) CHARACTER SET utf8," 
"                       mysql_proc_type VARCHAR(66) CHARACTER SET utf8," 
"                       debugger_version VARCHAR(66) CHARACTER SET utf8," 
"                       v_generated_time DATETIME," 
"                       variable_string VARCHAR(10000) CHARACTER SET utf8)" 
"routine_entry:" 
"BEGIN" 
"/*" 
"  for (each variable-name data-type declare-number)" 
"    \"insert into variables\" (i.e. add to linked list)" 
"    but skip if it already exists" 
"  No need to call xxxmdbug.add_delimiters since ``s were already added" 
"*/" 
"  DECLARE k INT;" 
"  DECLARE dummy INT;" 
"  DECLARE v_token_number_of_declare VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_variable_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_data_type VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_n INT;" 
"  DECLARE v_flags INT;" 
"  DECLARE v_table_variable_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_schema_identifier_of_original VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_table_routine_identifier_of_original VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE is_invoked_before INT DEFAULT 0;" 
"" 
"  /* If this is not being called by a debuggee, do nothing. This check also occurs in routine_exit()." 
"     Todo: decide if you should do error checking anyway." 
"     Todo: check other places and decide whether to check there too if @xxxmdbug_is_debuggee=0." 
"     Todo: decide whether we really should be calling is_debuggee_and_is_attached() ... I don't think so. */" 
"  IF @xxxmdbug_is_debuggee=0 OR @xxxmdbug_is_debuggee IS NULL THEN LEAVE routine_entry; END IF;" 
"" 
"  /* To check if routine has been invoked before:" 
"  /* SELECT 1 INTO is_invoked_before" 
"     FROM routines" 
"     WHERE schema_identifier_of_original COLLATE utf8_general_ci = mysql_proc_db"
"     AND routine_identifier_of_original  = mysql_proc_name"
"     LIMIT 1; */" 
"  SET v_n=0;" 
"  xr: LOOP" 
"    CALL xxxmdbug.fixed_select(@xxxmdbug_routines_routine_identifier_of_original,80,v_n,v_table_routine_identifier_of_original,v_flags);" 
"    IF v_flags=-1 THEN LEAVE xr; END IF;" 
"    IF v_table_routine_identifier_of_original =mysql_proc_name THEN"
"      CALL xxxmdbug.fixed_select(@xxxmdbug_routines_schema_identifier_of_original,80,v_n,v_table_schema_identifier_of_original,v_flags);" 
"      IF v_table_schema_identifier_of_original COLLATE utf8_general_ci=mysql_proc_db THEN"
"        /* todo: check routine_type */" 
"        SET is_invoked_before = 1;" 
"        LEAVE xr;" 
"        END IF;" 
"      END IF;" 
"    SET v_n=v_n+1;" 
"    END LOOP;" 
"" 
"  /* If this routine has been invoked before, then checks are already done, variables are already inserted. */" 
"  IF is_invoked_before = 0 THEN" 
"" 
"    SET @xxxmdbug_linked_list_for_routine_entry='';" 
"    CALL xxxmdbug.insert_into_tokens_linked_list(variable_string,@xxxmdbug_linked_list_for_routine_entry);" 
"    SET k = 1;" 
"    x: LOOP" 
"      CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list_for_routine_entry,k,v_token_number_of_declare,dummy);" 
"      IF v_token_number_of_declare = '' THEN LEAVE x; END IF;" 
"      SET k = k + 1;" 
"      CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list_for_routine_entry,k,@xxxmdbug_a2,dummy);" 
"      SET k = k + 1;" 
"      CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list_for_routine_entry,k,v_variable_identifier,dummy);" 
"      SET k = k + 1;" 
"      CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list_for_routine_entry,k,@xxxmdbug_a4,dummy);" 
"      SET k = k + 1;" 
"" 
"      SET v_data_type='';" 
"      y: LOOP" 
"        CALL xxxmdbug.get_from_linked_list(@xxxmdbug_linked_list_for_routine_entry,k,@xxxmdbug_a5,dummy);" 
"        SET k = k + 1;" 
"        IF @xxxmdbug_a5 ='*' OR @xxxmdbug_a5 =';' OR @xxxmdbug_a5 ='' THEN LEAVE y; END IF;"
"        SET v_data_type=CONCAT(v_data_type,' ',@xxxmdbug_a5);" 
"      END LOOP;" 
"      SET v_data_type=TRIM(v_data_type);" 
"" 
"      /* INSERT INTO xxxmdbug.variables (schema_identifier,routine_identifier,routine_type,token_number_of_declare,variable_identifier,data_type)" 
"      VALUES (mysql_proc_db,mysql_proc_name,v_token_number_of_declare,v_variable_identifier,v_data_type); */" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_variables_schema_identifier,80,mysql_proc_db);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_variables_routine_identifier,80,mysql_proc_name);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_variables_routine_type,80,mysql_proc_type);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_variables_token_number_of_declare,10,v_token_number_of_declare);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_variables_variable_identifier,80,v_variable_identifier);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_variables_data_type,80,v_data_type);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_variables_value,@xxxmdbug_value_length,'');" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_variables_old_value,@xxxmdbug_value_length,'');" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_variables_is_in_scope,5,0);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_variables_is_settable,5,0);" 
"      CALL xxxmdbug.fixed_insert(@xxxmdbug_variables_is_updated_by_set,5,0);" 
"" 
"      END LOOP;" 
"    /* INSERT INTO routines (schema_identifier_of_original,routine_identifier_of_original) VALUES" 
"       (mysql_proc_db,mysql_proc_name); */" 
"    CALL xxxmdbug.fixed_insert(@xxxmdbug_routines_schema_identifier_of_original,80,mysql_proc_db);" 
"    CALL xxxmdbug.fixed_insert(@xxxmdbug_routines_routine_identifier_of_original,80,mysql_proc_name);" 
"    CALL xxxmdbug.fixed_insert(@xxxmdbug_routines_routine_type_of_original,10,'');" 
"    /* todo: @xxxmdbug_routines_routine_type_of_original */" 
"" 
"    END IF; /* end for \"if is_invoked_before = 0\" */" 
"" 
"  /* \"Insert Into Call stack\" total size = 66+66+1+6." 
"     First replace the last 6 characters with the current line number, which (I hope) is line number of the invoking routine." 
"     Todo: I'm afraid this is too much overhead if we're not attached. Perhaps don't try to maintain call_stack if unattached? */" 
"  IF @xxxmdbug_call_stack >'' THEN"
"    SET @xxxmdbug_call_stack=LEFT(@xxxmdbug_call_stack,LENGTH(@xxxmdbug_call_stack)-6);" 
"    SET @xxxmdbug_call_stack=CONCAT(@xxxmdbug_call_stack,LPAD(@xxxmdbug_status_line_number,6,'0'));" 
"    END IF;" 
"  SET @xxxmdbug_call_stack=CONCAT(@xxxmdbug_call_stack,RPAD(mysql_proc_db,66,' '),RPAD(mysql_proc_name,66,' '),LEFT(mysql_proc_type,1),'000000');" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* called from generate_starter()." 
"   Job: make a string from the variables table." 
"   For example: '2,a. int;13,b. int;' */" 
"CREATE PROCEDURE xxxmdbug.generate_routine_entry_parameter (INOUT v_g LONGTEXT CHARACTER SET utf8," 
"                                                                       mysql_proc_db VARCHAR(66) CHARACTER SET utf8," 
"                                                                       mysql_proc_name VARCHAR(66) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_token_number_of_declare INT;" 
"  DECLARE v_variable_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_data_type VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE eof INT DEFAULT 0;" 
"  DECLARE c CURSOR FOR SELECT token_number_of_declare, variable_identifier, data_type" 
"                       FROM xxxmdbug.variables" 
"                       WHERE (schema_identifier COLLATE utf8_general_ci=mysql_proc_db AND routine_identifier =mysql_proc_name);"
"                       /* no order-by needed */" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1;" 
"  OPEN c;" 
"  x: LOOP" 
"    FETCH c INTO v_token_number_of_declare, v_variable_identifier, v_data_type;" 
"    IF eof = 1 THEN LEAVE x; END IF;" 
"    IF v_data_type IS NULL THEN SET v_data_type=''; END IF; /* @user_variable data type can be null */" 
"    SET v_data_type=REPLACE(v_data_type,'''',''''''); /* data type might be enum('string'...) or set('string...) */" 
"    SET v_g = CONCAT(v_g,v_token_number_of_declare, '*',v_variable_identifier, '*',v_data_type, ';');" 
"    END LOOP;" 
"  CLOSE c;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Some notes about the call stack." 
"   We have 66 characters for schema, 66 characters for routine, 1 for 'P' or 'F', 6 characters for line_number. 66+66+1+6=139." 
"   I insert into @xxxmdbug_call_stack during routine_entry(), which happens at the start of every routine." 
"   I delete from @xxxmdbug_call_stack during routine_exit(), which happens" 
"     (a) if it's a function and the command that's about to happen is RETURN" 
"     (b) if it's a routine that goes past the last line, which for a procedure is the normal way to end" 
"     (c) if it's an uncaught exception -- that's caught by the DECLARE EXIT HANDLER FOR SQLEXCEPTION placed at the start of every routine" 
"     (d) if it's a caught exception -- a user-entered DECLARE EXIT HANDLER causes falling out of the block, to past the last line." 
"   The inserting and deleting happen only if @xxxmdbug_is_debuggee > 0, but happen even if there's been no 'attach' (except if RETURN)." 
"   Todo: if 'attach' has not been done, then RETURN should cause \"call xxxmdbug.exit_routine();\" anyway." 
"   Todo: if there is an uncaught exception in a RETURN statement, I delete from the stack twice. */" 
"" 
"CREATE PROCEDURE xxxmdbug.routine_exit ()" 
"routine_exit:" 
"BEGIN" 
"  IF @xxxmdbug_is_debuggee=0 OR @xxxmdbug_is_debuggee IS NULL THEN LEAVE routine_exit; END IF;" 
"  /* todo: think: should send_statement_status be called after reducing call stack? */" 
"  CALL xxxmdbug.icc_send_statement_status('routine_exit');" 
"  SET @xxxmdbug_call_stack=LEFT(@xxxmdbug_call_stack,LENGTH(@xxxmdbug_call_stack)-(66+66+1+6));" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* \"Generate: starter\". Called from generate() */" 
"CREATE PROCEDURE xxxmdbug.generate_starter (INOUT v_g LONGTEXT CHARACTER SET utf8, p_routine_identifier VARCHAR(66) CHARACTER SET utf8, mysql_proc_db VARCHAR(66) CHARACTER SET utf8, mysql_proc_name VARCHAR(66) CHARACTER SET utf8, mysql_proc_type VARCHAR(66) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_generated_time DATETIME;" 
"  SET v_generated_time = @xxxmdbug_timestamp;" 
"" 
"  /* \"Commenting\" */" 
"  /* We will use the contents of xxxmdbug_comment to find surrogates, or to check version number. So do not change here! */" 
"  SET v_g = CONCAT(v_g,@xxxmdbug_lf,'BEGIN ');" 
"  SET v_g = CONCAT(v_g,@xxxmdbug_lf,'DECLARE xxxmdbug_comment VARCHAR(1000) DEFAULT ');" 
"  SET v_g = CONCAT(v_g,@xxxmdbug_lf,'''Surrogate routine for ',mysql_proc_db,'.',p_routine_identifier);" 
"  SET v_g = CONCAT(v_g,@xxxmdbug_lf,'Generated by ',@xxxmdbug_debugger_name,' Version ',@xxxmdbug_debugger_version);" 
"  SET v_g = CONCAT(v_g,@xxxmdbug_lf,'Generated on ',v_generated_time,''';');" 
"" 
"  /* \"Handling the signal number\" */" 
"  SET v_g = CONCAT(v_g,@xxxmdbug_lf,'DECLARE EXIT HANDLER FOR ',@xxxmdbug_signal_errno,' BEGIN CALL xxxmdbug.routine_exit(); RESIGNAL; END;');" 
"  SET v_g = CONCAT(v_g,@xxxmdbug_lf,'DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN CALL xxxmdbug.routine_exit(); RESIGNAL; END;');" 
"" 
"  /* \"call routine_entry(variable-list,command-list)\". includes \"Insert Into Call stack\". */" 
"  SET v_g = CONCAT(v_g,@xxxmdbug_lf," 
"                       'CALL xxxmdbug.routine_entry('," 
"                       '''',mysql_proc_db ,''','," 
"                       '''',p_routine_identifier,''','," 
"                       '''',mysql_proc_type,''','," 
"                       '''',@xxxmdbug_debugger_version,''','," 
"                       '''',v_generated_time,''',''');" 
"  CALL xxxmdbug.generate_routine_entry_parameter(v_g,mysql_proc_db,mysql_proc_name);" 
"  /* TODO: routine_entry() should have another parameter for pre-set commands. */" 
"  SET v_g = CONCAT(v_g,''');',@xxxmdbug_lf);" 
"" 
"  /* A breakpoint on line 0 is possible. There are no settable variables," 
"     but the user can see what the routine is, and can set breakpoints." 
"     breakpoint_check() always stops for line 0 right after 'debug' command. */" 
"  SET v_g = CONCAT(v_g,'IF xxxmdbug.is_debuggee_and_is_attached()=1 THEN CALL xxxmdbug.'," 
"                       @xxxmdbug_icc_core_surrogate_name,'(0);'," 
"                       'END IF;',@xxxmdbug_lf);" 
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* \"Generate: label\": Called from generate()" 
"    Whenever you see WHILE or LOOP or BEGIN or REPEAT, make|copy a label and add to label list" 
"    Whenever you see END (but not END IF), remove last item in label list" 
"    LEAVE will use the latest item in label list." 
"    */" 
"CREATE PROCEDURE xxxmdbug.generate_label (INOUT v_g LONGTEXT CHARACTER SET utf8, p_token_value VARCHAR(66) CHARACTER SET utf8, v_statement_number INT," 
"                                 v_token_number_of_first_token INT)" 
"BEGIN" 
"  DECLARE v_label VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_token_value_of_previous_token VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_token_value_of_next_token VARCHAR(66) CHARACTER SET utf8;" 
"  IF p_token_value IN ('WHILE','LOOP','BEGIN','REPEAT') THEN" 
"    /* If the previous token was ':', that is, there's a label here already, use it. Otherwise generate a new one. */" 
"    SET v_token_value_of_previous_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_first_token - 1);"
"    IF v_token_value_of_previous_token  = ':' THEN"
"      SET v_label = (SELECT value FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_first_token - 2);" 
"    ELSE" 
"      SET v_label = CONCAT('xxxmdbug_label_',v_statement_number);" 
"      SET v_g = CONCAT(v_g,' ',v_label,':'); /* the ' ' is necessary if the while/loop/begin/repeat is not at start of line */" 
"      END IF;" 
"    SET @xxxmdbug_label_list = CONCAT(@xxxmdbug_label_list,RPAD(v_label,64,' '));" 
"    END IF;" 
"  IF p_token_value  = 'END' THEN"
"    SET v_token_value_of_next_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_first_token + 1);" 
"    IF v_token_value_of_next_token   NOT IN ('IF','CASE') THEN"
"      SET @xxxmdbug_label_list = LEFT(@xxxmdbug_label_list,LENGTH(@xxxmdbug_label_list)-64);" 
"      END IF;" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
//strcpy(x,
//""
//"/* \"Generate: handlers\" */"
//"/* The handlers"
//"   We do not just generate the statement. We also generate the three"
//"   generic condition handlers, so that, when we insert in the"
//"   statements_executed table, we can say something in the result column."
//"   The handlers will not catch note-level warnings, for example"
//"   'drop table if exists no_such_table;' is not handled"
//"   (todo: consider looking at @@warning_count)."
//"   The handlers will not catch conditions if there is a more specific"
//"   handler in the user's program, but that is okay because we debug"
//"   the handler statements (todo: if you enter a specific handler,"
//"   change statements_executed)."
//"   The handlers should not catch the specific condition @xxxmdbug_signal_errno"
//"   which usually is 5678; that is caused by 'exit' (exit everything)."
//"   todo: consider setting @@sql_notes=0 so debugger's own SET statements are harmless */"
//"/* Why the handler code has been (hopefully temporarily) commented out:"
//"   It appears that doing RESIGNAL from within a loop, if caught by a user-written handler,"
//"   can awaken sleeping bugs in both MySQL and MariaDB."
//"   todo: send a bug report and note bug number here. */"
//"/*"
//"CREATE PROCEDURE xxxmdbug.generate_handlers (INOUT v_g LONGTEXT CHARACTER SET utf8,v_line_number_of_start_of_first_token INT)"
//"BEGIN"
//"  SET v_g = CONCAT(v_g,@xxxmdbug_lf,'BEGIN');"
//"  SET v_g = CONCAT(v_g,@xxxmdbug_lf,'DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN CALL xxxmdbug.update_statements_executed(1); RESIGNAL; END;');"
//"  SET v_g = CONCAT(v_g,@xxxmdbug_lf,'DECLARE EXIT HANDLER FOR SQLWARNING BEGIN CALL xxxmdbug.update_statements_executed(2); RESIGNAL; END;');"
//"  SET v_g = CONCAT(v_g,@xxxmdbug_lf,'DECLARE EXIT HANDLER FOR NOT FOUND BEGIN CALL xxxmdbug.update_statements_executed(3); RESIGNAL; END;');"
//"  END"
//"*/"
//);

//if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* \"Generate: statement text\" */" 
"" 
"CREATE PROCEDURE xxxmdbug.generate_statement_text (INOUT v_g LONGTEXT CHARACTER SET utf8," 
"                                          v_token_number_of_first_token INT," 
"                                          v_token_number_of_last_token INT," 
"                                          mysql_proc_db VARCHAR(66) CHARACTER SET utf8," 
"                                          mysql_proc_body LONGTEXT CHARACTER SET utf8," 
"                                          mysql_proc_sql_mode VARCHAR(512) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE y INT;" 
"  DECLARE v_first_token VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE statement_might_contain_routine_invocation INT;" 
"  DECLARE v_routine_identifier_of_surrogate VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE spacing INT;" 
"" 
"  /* Todo: rather than a line feed every time, copy line feeds and indentation of the original */" 
"  SET v_g = CONCAT(v_g,@xxxmdbug_lf);" 
"" 
"  SET y = v_token_number_of_first_token;" 
"" 
"  SET v_first_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = y);" 
"" 
"  /* \"special handling of RETURN\" -- remove the function name from the call stack before returning." 
".    we also do delete from call stack at the end of the routine, due to generate_ender. */" 
"  /* todo: more special handling of RETURN: we pointlessly generate" 
"           CALL xxxmdbug.update_statements_executed(0);\\" 
"           LEAVE xxxmdbug_inner_loop_label_2;\\ */" 
"  IF v_first_token  = 'RETURN' THEN"
"    SET v_g = CONCAT(v_g,'CALL xxxmdbug.routine_exit();',@xxxmdbug_lf);" 
"    END IF;" 
"" 
"  /* I don't think EXPLAIN matters. */" 
"  /* DECLARE can be either declare_variable or declare_cursor */" 
"  /* I can't do anything with PREPARE at this stage because its argument might not be literal. */" 
"  /* Although flow-control statements are not debuggable, their condition expressions might refer to functions. */" 
"  IF v_first_token   IN ('CALL','CASE','CREATE','DECLARE','DELETE','DO','ELSEIF','IF','INSERT',"
"                       'REPLACE','RETURN','SELECT','SET','UNTIL','UPDATE','WHILE') THEN" 
"    SET statement_might_contain_routine_invocation=1;" 
"  ELSE" 
"    SET statement_might_contain_routine_invocation=0;" 
"    END IF;" 
"  WHILE y <= v_token_number_of_last_token DO"
"    SELECT value,offsetx INTO @xxxmdbug_x,@xxxmdbug_xoffset FROM xxxmdbug.tokens WHERE token_number = y;"
"    IF statement_might_contain_routine_invocation = 1 THEN"
"      /* Might this token be an identifier? If it is, then 'CREATE DATABASE token' is illegal, so prepare will fail."
"         But I won't call preparer(), I'm thinking that if it's not truly valid then the surrogate won't be found. */"
"      /* Todo: exclude identifiers that start with digits but contain non-digits"
"         Todo: don't replace something that has the same name as a built-in function"
"         I also look for \"\"s if ansi_quotes is one of the routine's characteristics. */"
"      IF LEFT(@xxxmdbug_x,1)   BETWEEN 'A' AND 'Z'"
"      OR LEFT(@xxxmdbug_x,1)   BETWEEN '0' AND '9'"
"      OR LEFT(@xxxmdbug_x,1)  = '$'"
"      OR HEX(LEFT(@xxxmdbug_x,1))  >= '80'"
"      OR LEFT(@xxxmdbug_x,1) ='`'"
"      OR (LEFT(@xxxmdbug_x,1) ='\"' AND mysql_proc_sql_mode   LIKE '%ansi_quotes%') THEN"
"        IF v_first_token ='CALL' OR (SELECT value FROM xxxmdbug.tokens WHERE token_number = y+1)  = '(' THEN"
"          SET @xxxmdbug_invocations_of_routines_in_any_group=@xxxmdbug_invocations_of_routines_in_any_group+1;"
"          IF (SELECT value FROM xxxmdbug.tokens WHERE token_number = y-1)  = '.' THEN"
"            SET @xxxmdbug_x2 = (SELECT value FROM xxxmdbug.tokens WHERE token_number = y-2);"
"          ELSE"
"            SET @xxxmdbug_x2 = mysql_proc_db;"
"            END IF;"
""
"          SET v_routine_identifier_of_surrogate=''; /* unnecessary, if select returns no rows the result will be null */"
"          SELECT routine_identifier_of_surrogate"
"          INTO v_routine_identifier_of_surrogate"
"          FROM xxxmdbug.routines"
"          WHERE (TRIM(BOTH '`' FROM routine_identifier_of_original)  = TRIM(BOTH '`' FROM @xxxmdbug_x)"
"                OR"
"                TRIM(BOTH '`' FROM routine_identifier_of_original) = TRIM(BOTH '\"' FROM @xxxmdbug_x))"
"          AND (TRIM(BOTH '`' FROM schema_identifier_of_original) COLLATE utf8_general_ci= TRIM(BOTH '`' FROM @xxxmdbug_x2)"
"              OR"
"              TRIM(BOTH '`' FROM schema_identifier_of_original) COLLATE utf8_general_ci = TRIM(BOTH '\"' FROM @xxxmdbug_x2));"
"          IF v_routine_identifier_of_surrogate <> '' THEN"
"            /* We're looking at a token which is followed by '(',"
"               inside a statement that might contain a routine reference,"
"               which matches the name of a routine in the group specified by the setup() parameter."
"               So replace with surrogate routine name."
"               Todo: DO NOT necessarily replace with surrogate routine name. We might have put it in directly."
"               Todo: check that argument count = parameter count."
"               Todo: handle possible qualifier."
"               Todo: handle possible delimiter."
"               Todo: check that function name <> built-in name, in that case it's ignored (detectable at CREATE time). */"
"            SET @xxxmdbug_invocations_of_routines_in_same_group=@xxxmdbug_invocations_of_routines_in_same_group+1;"
"            SET @xxxmdbug_x=v_routine_identifier_of_surrogate;"
"            END IF;"
"          END IF;"
"        END IF;"
"      END IF;"
"    SET v_g = CONCAT(v_g,@xxxmdbug_x);"
"    /* If the original text had something between this token and the next one, put it in."
"       It's important to preserve spaces in case sql_mode ignore_space is off."
"       It's not important to preserve comments because if they start with !version-number they're stripped, but we preserve anyway. */"
"    IF y <> v_token_number_of_last_token THEN"
"      SET spacing = (SELECT offsetx FROM xxxmdbug.tokens WHERE token_number = y+1) - (LENGTH(@xxxmdbug_x)+@xxxmdbug_xoffset);"
"      SET v_g = CONCAT(v_g,SUBSTRING(mysql_proc_body FROM (LENGTH(@xxxmdbug_x)+@xxxmdbug_xoffset) FOR spacing));"
"      END IF;"
"    if v_g is null then signal sqlstate '56780' set mysql_errno=@xxxmdbug_signal_errno, message_text='assert 46'; end if;"
"    SET y = y + 1;"
"    END WHILE;"
"  END");


if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* \"Generate: statement text\" but without any changes or special handling." 
"   This is for \"if (statement is being debugged) is false\" */" 
"CREATE PROCEDURE xxxmdbug.generate_statement_text_as_is (INOUT v_g LONGTEXT CHARACTER SET utf8," 
"                                          v_token_number_of_first_token INT," 
"                                          v_token_number_of_last_token INT," 
"                                          mysql_proc_db VARCHAR(66) CHARACTER SET utf8," 
"                                          mysql_proc_body LONGTEXT CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_first_offset INT;" 
"  DECLARE v_last_offset INT;" 
"  DECLARE v_last_length INT;" 
"" 
"  SELECT offsetx INTO v_first_offset FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_first_token;" 
"  SELECT offsetx,LENGTH(value) INTO v_last_offset,v_last_length FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_last_token;" 
"  /* Todo: rather than a line feed every time, copy line feeds and indentation of the original */" 
"  SET v_g = CONCAT(v_g,@xxxmdbug_lf," 
"                       SUBSTRING(mysql_proc_body FROM v_first_offset FOR (v_last_offset+v_last_length)-v_first_offset)," 
"                       @xxxmdbug_lf);" 
"  if v_g is null then signal sqlstate '56780' set mysql_errno=@xxxmdbug_signal_errno, message_text='assert 47'; end if;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* \"Generate: ender\": Called from generate()." 
"   We call this for the last line of a routine." 
"   We also change call stack (without calling this) for special handling of RETURN.*/" 
"CREATE PROCEDURE xxxmdbug.generate_ender (INOUT v_g LONGTEXT CHARACTER SET utf8)" 
"BEGIN" 
"  IF RIGHT(v_g,1)<>';'  then SET v_g = CONCAT(v_g,';'); END IF;" 
"  SET v_g = CONCAT(v_g,@xxxmdbug_lf);" 
"  /* \"Delete From Call Stack\" */" 
"  SET v_g = CONCAT(v_g,'CALL xxxmdbug.routine_exit();',@xxxmdbug_lf);" 
"  SET v_g = CONCAT(v_g,'END');" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* 'attach'" 
"   todo: lock while attaching, disallow multiple attach" 
"   todo: call reset(1) to initialize variables, erase leftovers e.g. temporary 'send' breakpoints" 
"   todo: check if already attached, if debuggee is waiting for you particularly, if privileges are okay" 
"   todo: send connection_id along with attach message" 
"   todo: check whether we allow information status without attach, that would probably be OK" 
"   todo: pass and check user id?" 
"   todo: figure out what should cancel attach" 
"   A problem with most of these 'todo' items is that we only get here if we're not already attached." 
"   Perhaps the solution is to let icc_get_process_user_command() see 'attach' commands." 
" */" 
"CREATE PROCEDURE xxxmdbug.icc_process_user_command_attach ()" 
"BEGIN" 
"  SET @xxxmdbug_status_last_command=@xxxmdbug_message;" 
"  CALL xxxmdbug.icc_change_statement_status('OK');       /* ?? Maybe icc_get_user_command() already did this? */" 
"  SET @xxxmdbug_is_attached=1;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* called by debuggee_wait_loop, and also generated for every debuggable statement */" 
"CREATE FUNCTION xxxmdbug.is_debuggee_and_is_attached () RETURNS INT DETERMINISTIC "
"BEGIN" 
"  DECLARE v_message_start INT;" 
"  DECLARE v_prefix VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_message VARCHAR(66) CHARACTER SET utf8;" 
"" 
"  IF @xxxmdbug_is_debuggee=0 OR @xxxmdbug_is_debuggee IS NULL THEN" 
"    /* The caller is not a debuggee (has not called become_debuggee_connection)." 
"       The objective is to run just the same as if this was the original routine," 
"       with the slight overhead caused by this function and by DECLAREs. */" 
"    RETURN 0;" 
"    END IF;" 
"  IF @xxxmdbug_is_attached=0 THEN" 
"    /* The caller is a debuggee (has called become_debuggee_connection)" 
"       but nothing has sent 'attach' yet." 
"       Again objective is to run just the same as if this was the original routine," 
"       with more overhead to see if an attach is in the pipe," 
"       If there are messages in the pipe on this channel, but they are not 'attach', they are ignored and erased." 
"       todo: find out why there was a leading space. bug? */" 
"    x: LOOP" 
"      SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_command); /* 'C ' */" 
"      CALL xxxmdbug.dbms_pipe_receive(v_prefix,0,v_message,v_message_start);" 
"      IF v_message_start=0 THEN RETURN 0; END IF;" 
"      CALL xxxmdbug.icc_get_user_command(0);" 
"      IF @xxxmdbug_token_value_1  = LEFT('attach',LENGTH(@xxxmdbug_token_value_1)) THEN LEAVE x; END IF;"
"      END LOOP;" 
"    CALL xxxmdbug.icc_process_user_command_attach();" 
"" 
"    /* Obsolete code, to be removed soon" 
"    x: LOOP" 
"      SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_command);" 
"      CALL xxxmdbug.dbms_pipe_receive(v_prefix,1,v_message,v_message_start);" 
"      IF v_message_start=0 THEN RETURN 0; END IF;" 
"      SET v_message=TRIM(v_message);" 
"      IF v_message >'' AND v_message =LEFT('attach',LENGTH(v_message)) THEN LEAVE x; END IF;"
"      END LOOP;" 
"    SET @xxxmdbug_status_last_command=v_message;" 
"    CALL xxxmdbug.icc_change_statement_status('OK');" 
"    SET @xxxmdbug_is_attached=1; */" 
"    END IF;" 
"  RETURN 1;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;

#ifndef FLAG_VERSION_MYSQL_8_0
strcpy(x,
"" 
"/* This generates the debuggee procedure that will handle the 'refresh server_variables'" 
"   command. It is better to generate rather than have a fixed set of" 
"   statements, because the server variables depend on the version and" 
"   on what engines or plugins are installed. An example first line:" 
"   SET v_ret=CONCAT(v_ret,'\"@@ARIA_BLOCK_SIZE\",','\"',@@ARIA_BLOCK_SIZE,'\";');" 
"   todo: watch for v_ret overflow */" 
"CREATE PROCEDURE xxxmdbug.generate_icc_process_user_command_r_server_variables ()" 
"BEGIN" 
"  DECLARE mysql_proc_name VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE mysql_proc_db VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE mysql_proc_type VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_variable_name VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE eof INT DEFAULT 0;" 
"  DECLARE v_g LONGTEXT CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_offset_of_begin INT;" 
"  DECLARE v_is_settable INT;" 
"  DECLARE v_data_type VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_junk VARCHAR(256) CHARACTER SET utf8;" 
"  DECLARE c CURSOR FOR SELECT DISTINCT variable_identifier" 
"                   FROM xxxmdbug.tmp_user_variables" 
"                   ORDER BY variable_identifier;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1;" 
"" 
"  CALL xxxmdbug.create_tmp_user_variables_table();"
"  BEGIN"
"    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION"
"    INSERT INTO xxxmdbug.tmp_user_variables"
"    SELECT CONCAT('@@',variable_name) FROM information_schema.session_variables;"
"    INSERT INTO xxxmdbug.tmp_user_variables"
"    SELECT CONCAT('@@',variable_name) FROM performance_schema.session_variables;"
"  END;"
"" 
"  SET mysql_proc_name='icc_process_user_command_r_user_variables'; /* todo: this is a lie. the original is for server_variables. */" 
"  SET @xxxmdbug_surrogate_routine_identifier='icc_process_user_command_r_server_variables';" 
"" 
"  SET mysql_proc_db='xxxmdbug';" 
"" 
"  SET mysql_proc_type = 'PROCEDURE';" 
"" 
"  /* Opening matches what is in generate(). */" 
"  SET v_g = CONCAT('DROP ',mysql_proc_type,' IF EXISTS ',mysql_proc_db,'.',@xxxmdbug_surrogate_routine_identifier,';',@xxxmdbug_lf);" 
"" 
"  SET v_g = CONCAT(v_g,'CREATE ');" 
"" 
"  SET v_g = CONCAT(v_g," 
"                   mysql_proc_type," 
"                   ' '," 
"                   mysql_proc_db,'.',@xxxmdbug_surrogate_routine_identifier," 
"                   '() ');" 
"" 
"  SET v_offset_of_begin=LENGTH(v_g)+LENGTH(@xxxmdbug_lf);" 
"" 
"  SET v_g = concat(v_g,'BEGIN',@xxxmdbug_lf," 
"                   'DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT ''''; ',@xxxmdbug_lf,        /* todo: try TEXT */" 
"                   'DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;',@xxxmdbug_lf);" 
"" 
"  OPEN c;" 
"  x: LOOP" 
"    FETCH c INTO v_variable_name;" 
"    IF eof = 1 THEN LEAVE x; END IF;" 
"" 
"    /* Test whether one can assign to the variable. If an exception happens," 
"       it is almost certainly because the variable is read-only." 
"       ERROR 1238 (HY000): Variable 'warning_count' is a read only variable." 
"       In that case 'refresh server_variables' will show that is_settable = 0." 
"       Do not check @@timestamp because SET TIMESTAMP freezes the clock." 
"       Todo: actually a new column 'read only' would be smarter, here and for parameters. */" 
"    BEGIN" 
"      DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET v_is_settable = 0;" 
"      SET v_is_settable = 1;" 
"      IF v_variable_name <>'@@timestamp' THEN"
"        SET @xxxmdbug_test_setting = CONCAT('SET ',v_variable_name,'=',v_variable_name);" 
"        PREPARE xxxmdbug_stmt FROM @xxxmdbug_test_setting;" 
"        EXECUTE xxxmdbug_stmt;" 
"        END IF;" 
"      END;" 
"" 
"    /* Determine the type by creating a table." 
"       Earlier I tried making based on a select of the variable," 
"       then looking at information_schema." 
"       That is more reliable, but incredibly slow on Windows." 
"       So I'll call what I use for user variables, and then" 
"       throw away everything except the type. */" 
"    BEGIN" 
"      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET v_data_type = 'unknown';" 
"      DECLARE EXIT HANDLER FOR NOT FOUND SET v_data_type = 'unknown';" 
"      SET v_data_type='unknown';" 
"      SET @xxxmdbug_test_setting = CONCAT('SET @xxxmdbug_uvar=',v_variable_name);" 
"      PREPARE xxxmdbug_stmt FROM @xxxmdbug_test_setting;" 
"      EXECUTE xxxmdbug_stmt;" 
"      CALL xxxmdbug.uvar(v_junk,'');" 
"      SET v_data_type=@xxxmdbug_uvar_type;" 
"      END;" 
"" 
"    SET v_g = CONCAT(v_g,'SET v_ret=CONCAT(v_ret,''\"'," 
"                         v_variable_name," 
"                         '\",'',''\"'',HEX(IFNULL(LEFT('," 
"                         v_variable_name," 
"                         ',66),''NULL'')),''\",'," 
"                         v_is_settable," 
"                         ',\"',v_data_type,'\"'," 
"                         ';'');'," 
"                         @xxxmdbug_lf" 
"                         );" 
"" 
"    END LOOP;" 
"  CLOSE c;" 
"" 
"  SET v_g = CONCAT(v_g,'SET v_prefix = CONCAT(''xxxmdbug_'',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_server_variables);',@xxxmdbug_lf," 
"                       'CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);',@xxxmdbug_lf," 
"                       'CALL xxxmdbug.icc_change_statement_status(''OK'');',@xxxmdbug_lf," 
"                       'END;',@xxxmdbug_lf);" 
"" 
"  INSERT INTO xxxmdbug.routines" 
"  VALUES (mysql_proc_db,mysql_proc_name,@xxxmdbug_surrogate_routine_identifier,@xxxmdbug_timestamp,'','',mysql_proc_type,v_g,v_g,v_offset_of_begin);" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
#endif /* #ifndef FLAG_VERSION_MYSQL_8_0 */

#ifndef FLAG_VERSION_MYSQL_8_0
strcpy(x,
""
"/* This generates the debuggee procedure that will handle the 'set @@server_variable=...'"
"   command. It is better to generate rather than have a fixed set of"
"   statements, because the server variables depend on the version and"
"   on what engines or plugins are installed. An example first line:"
"   IF @token_value_2 = '@@ARIA_BLOCK_SIZE' THEN SET @@ARIA_BLOCK_SIZE=@xxxmdbug_token_value_4a; END IF; */"
"/* Wrong type or wrong value will cause a severe error, we handle it, but the warning list is cleared.*/"
"CREATE PROCEDURE xxxmdbug.generate_icc_process_user_command_set_server_variables ()"
"BEGIN"
"  DECLARE mysql_proc_name VARCHAR(66) CHARACTER SET utf8;"
"  DECLARE mysql_proc_db VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE mysql_proc_type VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_variable_name VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE eof INT DEFAULT 0;" 
"  DECLARE v_g LONGTEXT CHARACTER SET utf8 DEFAULT '';" 
"  DECLARE v_offset_of_begin INT;" 
"  DECLARE v_is_settable INT;" 
"  DECLARE c CURSOR FOR SELECT DISTINCT variable_identifier" 
"                   FROM xxxmdbug.tmp_user_variables" 
"                   ORDER BY variable_identifier;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1;" 
"" 
"  CALL xxxmdbug.create_tmp_user_variables_table();" 
"  BEGIN"
"    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION"
"    INSERT INTO xxxmdbug.tmp_user_variables"
"    SELECT CONCAT('@@',variable_name) FROM information_schema.session_variables;"
"    INSERT INTO xxxmdbug.tmp_user_variables"
"    SELECT CONCAT('@@',variable_name) FROM performance_schema.session_variables;"
"  END;"
"  SET mysql_proc_name='icc_process_user_command_r_user_variables'; /* todo: this is a lie. the original is for server_variables. */" 
"  SET @xxxmdbug_surrogate_routine_identifier='icc_process_user_command_set_server_variables';" 
"" 
"  SET mysql_proc_db='xxxmdbug';" 
"" 
"  SET mysql_proc_type = 'PROCEDURE';" 
"" 
"  /* Opening matches what is in generate(). */" 
"  SET v_g = CONCAT('DROP ',mysql_proc_type,' IF EXISTS ',mysql_proc_db,'.',@xxxmdbug_surrogate_routine_identifier,';',@xxxmdbug_lf);" 
"" 
"  SET v_g = CONCAT(v_g,'CREATE ');" 
"" 
"  SET v_g = CONCAT(v_g," 
"                   mysql_proc_type," 
"                   ' '," 
"                   mysql_proc_db,'.',@xxxmdbug_surrogate_routine_identifier," 
"                   '() ');" 
"" 
"  SET v_offset_of_begin=LENGTH(v_g)+LENGTH(@xxxmdbug_lf);" 
"" 
"  SET v_g = concat(v_g,'BEGIN',@xxxmdbug_lf," 
"                       'DECLARE EXIT HANDLER FOR SQLEXCEPTION CALL xxxmdbug.icc_change_statement_status(''Fail'');',@xxxmdbug_lf," 
"                       'SET @xxxmdbug_tmp_for_set = ''Fail'';',@xxxmdbug_lf);" 
"" 
"  OPEN c;" 
"  x: LOOP" 
"    FETCH c INTO v_variable_name;" 
"    IF eof = 1 THEN LEAVE x; END IF;" 
"    /* Test whether one can assign to the variable. If an exception happens," 
"       it is almost certainly because the variable is read-only." 
"       ERROR 1238 (HY000): Variable 'warning_count' is a read only variable." 
"       In that case 'refresh server_variables' will show that is_settable = 0." 
"       Todo: actually a new column 'read only' would be smarter, here and for parameters. */" 
"    BEGIN" 
"      DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET v_is_settable = 0;" 
"      SET v_is_settable = 1;" 
"      IF v_variable_name<>'@@timestamp' THEN" 
"        SET @xxxmdbug_test_setting = CONCAT('SET ',v_variable_name,'=',v_variable_name);" 
"        PREPARE xxxmdbug_stmt FROM @xxxmdbug_test_setting;" 
"        EXECUTE xxxmdbug_stmt;" 
"        END IF;" 
"      END;" 
"    IF v_is_settable = 0 THEN ITERATE x; END IF;" 
"    SET v_g = CONCAT(v_g,'IF @xxxmdbug_token_value_2 = '''," 
"                         v_variable_name," 
"                         ''' THEN SET '," 
"                         v_variable_name," 
"                         '= @xxxmdbug_token_value_4a; SET @xxxmdbug_tmp_for_set = ''OK''; END IF;',@xxxmdbug_lf);" 
"    END LOOP;" 
"  CLOSE c;" 
"  SET v_g = CONCAT(v_g,'CALL xxxmdbug.icc_change_statement_status(@xxxmdbug_tmp_for_set);',@xxxmdbug_lf);" 
"  SET v_g = CONCAT(v_g,'END;',@xxxmdbug_lf);" 
"" 
"  INSERT INTO xxxmdbug.routines" 
"  VALUES (mysql_proc_db,mysql_proc_name,@xxxmdbug_surrogate_routine_identifier,@xxxmdbug_timestamp,'','',mysql_proc_type,v_g,v_g,v_offset_of_begin);" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
#endif /* #ifndef FLAG_VERSION_MYSQL_8_0 */

strcpy(x,
"" 
"/* todo: decide whether setup() should create with definer privileges or sql security invoker" 
"   todo: prevent replication" 
"*/" 
"CREATE PROCEDURE xxxmdbug.become_debuggee_connection (xxxmdbug_channel VARCHAR(66) CHARACTER SET utf8)" 
"BEGIN" 
"  CALL xxxmdbug.reset(xxxmdbug_channel,0);" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;

strcpy(x,
"" 
"/* become_debuggee_connection calls reset(0) which initializes everything including breakpoints" 
"   debuggee_wait_loop calls reset(1) which initializes everything but leaves breakpoints mostly intact */" 
"CREATE PROCEDURE xxxmdbug.reset (xxxmdbug_channel VARCHAR(66) CHARACTER SET utf8, flags INT)" 
"BEGIN" 
"  DECLARE v_breakpoint_identifier INT;" 
"  DECLARE v INT;" 
"  DECLARE v_command VARCHAR(14) CHARACTER SET utf8;" 
"  DECLARE v_n INT;" 
"  DECLARE v_flags INT;" 
"" 
"  /* todo: this is wrong, it is too generic, it handles signal 5678 even */" 
"  DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN select 'Failure. Check privileges.'; RESIGNAL; END;" 
"  CALL xxxmdbug.initialize_variables();" 
"  /* Following was shifted from initialize_variables() because for John's sake we only will clear last_command for reset(0) */" 
"  IF flags=0 THEN" 
"    SET @xxxmdbug_status_last_command = '';" 
"    SET @xxxmdbug_status_last_command_result = '';" 
"    END IF;" 
"  CALL xxxmdbug.privilege_checks();" 
"" 
"  /* todo: privilege tests for other routines */" 
"  /* okay, checks indicate that it's possible to become debuggee. */" 
"  CALL xxxmdbug.setxxxmdbug_channel(xxxmdbug_channel); /* set @xxxmdbug_channel = user() etc. */" 
"  CALL xxxmdbug.fixed_routines_clear();" 
"  CALL xxxmdbug.fixed_variables_clear();" 
"  IF flags = 0 OR @xxxmdbug_breakpoints_breakpoint_identifier IS NULL THEN" 
"    CALL xxxmdbug.fixed_breakpoints_clear();" 
"    SET @xxxmdbug_commands_count=0;" 
"  ELSE" 
"    SET v_n=0;" 
"    x: LOOP" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_breakpoint_identifier,10,v_n,v_breakpoint_identifier,v_flags);" 
"      IF v_flags=-1 THEN LEAVE x; END IF;" 
"      CALL xxxmdbug.fixed_update(@xxxmdbug_breakpoints_is_matching_location,5,v_n,0);" 
"      CALL xxxmdbug.fixed_update(@xxxmdbug_breakpoints_hit_count,10,v_n,0);" 
"      CALL xxxmdbug.fixed_update(@xxxmdbug_breakpoints_is_matching_condition,5,v_n,0);" 
"      CALL xxxmdbug.fixed_select(@xxxmdbug_breakpoints_command,20,v_n,v_command,v_flags);" 
"      IF v_command ='step' OR v_command ='next' THEN"
"        CALL xxxmdbug.breakpoint_delete(v_n);" 
"        SET v_n=v_n-1;" 
"        END IF;" 
"      SET v_n=v_n+1;" 
"      END LOOP;" 
"    END IF;" 
"  CALL xxxmdbug.fixed_statements_executed_clear();" 
"  CALL xxxmdbug.fixed_prepared_statements_clear();" 
"" 
"  SET @xxxmdbug_is_debuggee=1;" 
"  SET @xxxmdbug_is_attached=0;" 
"" 
"  end");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* debuggee_stop() should cancel any effects of any calls to any debugger/debuggee" 
"   routines done by the current session. That is: erase every message in a channel," 
"   drop every temporary table, deallocate every prepared statement, and set all" 
"   user variables to NULL. */" 
"CREATE PROCEDURE xxxmdbug.debuggee_stop ()" 
"BEGIN" 
"  DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_message_start INT;" 
"  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END;" 
"  /* Erase every message in channel @xxxmdbug_channel */" 
"  IF @xxxmdbug_channel IS NOT NULL AND @@init_connect IS NOT NULL THEN" 
"    x: LOOP" 
"      SET @xxxmdbug_message = ''; /* unnecessary? */" 
"      SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel);" 
"      CALL xxxmdbug.dbms_pipe_receive(v_prefix,1,@xxxmdbug_message,v_message_start);" 
"      IF v_message_start = 0 THEN LEAVE x; END IF;" 
"      END LOOP;" 
"    END IF;" 
"  /* Drop every temporary table mentioned in install.sql */" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.breakpoints;" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.call_stack;" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.information_status;" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.prepared_statements;" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.routines;" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.schemas_and_objects;" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.server_variables;" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.statements;" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.statements_executed;" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.tokens;" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.tmp_user_variables;" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.tmp_variables;" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.user_variables;" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.variables;" 
"  /* Deallocate every prepared statement mentioned in install.sql */" 
"  DEALLOCATE PREPARE xxxmdbug_stmt;" 
"  DEALLOCATE PREPARE xxxmdbug_stmt_for_x;" 
"  /* Set every user variable mentioned in install.sql to NULL */" 
"  SET @xxxmdbug_2_chars=NULL;" 
"  SET @xxxmdbug_3_chars=NULL;" 
"  SET @xxxmdbug_a2=NULL;" 
"  SET @xxxmdbug_a4=NULL;" 
"  SET @xxxmdbug_a5=NULL;" 
"  SET @xxxmdbug_breakpoints_breakpoint_identifier=NULL;" 
"  SET @xxxmdbug_breakpoints_call_stack_depth_when_set=NULL;" 
"  SET @xxxmdbug_breakpoints_command=NULL;" 
"  SET @xxxmdbug_breakpoints_condition_identifier=NULL;" 
"  SET @xxxmdbug_breakpoints_condition_operator=NULL;" 
"  SET @xxxmdbug_breakpoints_condition_value=NULL;" 
"  SET @xxxmdbug_breakpoints_hit_count=NULL;" 
"  SET @xxxmdbug_breakpoints_is_matching_condition=NULL;" 
"  SET @xxxmdbug_breakpoints_is_matching_location=NULL;" 
"  SET @xxxmdbug_breakpoints_is_temporary=NULL;" 
"  SET @xxxmdbug_breakpoints_is_temporary_and_to_be_cleared=NULL;" 
"  SET @xxxmdbug_breakpoints_last_insert_id=NULL;" 
"  SET @xxxmdbug_breakpoints_line_number_maximum=NULL;" 
"  SET @xxxmdbug_breakpoints_line_number_minimum=NULL;" 
"  SET @xxxmdbug_breakpoints_routine_identifier=NULL;" 
"  SET @xxxmdbug_breakpoints_routine_type=NULL;" 
"  SET @xxxmdbug_breakpoints_schema_identifier=NULL;" 
"  SET @xxxmdbug_breakpoint_check_result=NULL;" 
"  SET @xxxmdbug_call_stack=NULL;" 
"  SET @xxxmdbug_channel=NULL;" 
"  SET @xxxmdbug_char=NULL;" 
"  SET @xxxmdbug_char_in_string=NULL;" 
"  SET @xxxmdbug_copyright=NULL;" 
"  SET @xxxmdbug_commands_count=NULL;" 
"  SET @xxxmdbug_debugger_name=NULL;" 
"  SET @xxxmdbug_debugger_version=NULL;" 
"  SET @xxxmdbug_default_schema=NULL;" 
"  SET @xxxmdbug_end_char=NULL;" 
"  SET @xxxmdbug_error_message=NULL;" 
"  SET @xxxmdbug_function_result=NULL;" 
"  SET @xxxmdbug_icc_core_surrogate_name=NULL;" 
"  SET @xxxmdbug_icc_count=NULL;" 
"  SET @xxxmdbug_invocations_of_routines_in_any_group=NULL;" 
"  SET @xxxmdbug_invocations_of_routines_in_same_group=NULL;" 
"  SET @xxxmdbug_is_attached=NULL;" 
"  SET @xxxmdbug_is_debuggee=NULL;" 
"  SET @xxxmdbug_label_list=NULL;" 
"  SET @xxxmdbug_last_command=NULL;" 
"  SET @xxxmdbug_last_was_debug=NULL;" 
"  SET @xxxmdbug_linked_list=NULL;" 
"  SET @xxxmdbug_linked_list_for_routine_entry=NULL;" 
"  SET @xxxmdbug_lf=NULL;" 
"  SET @xxxmdbug_max_executed_statements_rows=NULL;" 
"  SET @xxxmdbug_message=NULL;" 
"  SET @xxxmdbug_old_uvar=NULL;" 
"  SET @xxxmdbug_number_of_last_status_message=NULL;" 
"  SET @xxxmdbug_part1=NULL;" 
"  SET @xxxmdbug_part2=NULL;" 
"  SET @xxxmdbug_prepared_statements_statement_name=NULL;" 
"  SET @xxxmdbug_prepared_statements_statement_text=NULL;" 
"  SET @xxxmdbug_prefix_end_for_command=NULL;" 
"  SET @xxxmdbug_prefix_end_for_r_breakpoints=NULL;" 
"  SET @xxxmdbug_prefix_end_for_r_call_stack=NULL;" 
"  SET @xxxmdbug_prefix_end_for_r_prepared_statements=NULL;" 
"  SET @xxxmdbug_prefix_end_for_r_server_variables=NULL;" 
"  SET @xxxmdbug_prefix_end_for_r_statements_executed=NULL;" 
"  SET @xxxmdbug_prefix_end_for_r_user_variables=NULL;" 
"  SET @xxxmdbug_prefix_end_for_r_variables=NULL;" 
"  SET @xxxmdbug_prefix_end_for_statement_status=NULL;" 
"  SET @xxxmdbug_routine=NULL;" 
"  SET @xxxmdbug_routines_routine_identifier_of_original=NULL;" 
"  SET @xxxmdbug_routines_schema_identifier_of_original=NULL;" 
"  SET @xxxmdbug_routines_routine_type_of_original=NULL;" 
"  SET @xxxmdbug_routine_identifier=NULL;" 
"  SET @xxxmdbug_saved_sql_mode=NULL;" 
"  SET @xxxmdbug_saved_sql_mode_before_prepare=NULL;" 
"  SET @xxxmdbug_schema=NULL;" 
"  SET @xxxmdbug_setup_group_name=NULL;" 
"  SET @xxxmdbug_signal_errno=NULL;" 
"  SET @xxxmdbug_sleep_time=NULL;" 
"  SET @xxxmdbug_sleep_time_for_john=NULL;" 
"  SET @xxxmdbug_start_timestamp=NULL;" 
"  SET @xxxmdbug_statements_executed_caught_by_no_handler=NULL;" 
"  SET @xxxmdbug_statements_executed_caught_by_not_found_handler=NULL;" 
"  SET @xxxmdbug_statements_executed_caught_by_sqlexception_handler=NULL;" 
"  SET @xxxmdbug_statements_executed_caught_by_sqlwarning_handler=NULL;" 
"  SET @xxxmdbug_statements_executed_caught_by_user_written_handler=NULL;" 
"  SET @xxxmdbug_statements_executed_number=NULL;" 
"  SET @xxxmdbug_statements_executed_routine_identifier=NULL;" 
"  SET @xxxmdbug_statements_executed_routine_type=NULL;" 
"  SET @xxxmdbug_statements_executed_row_count=NULL;" 
"  SET @xxxmdbug_statements_executed_schema_identifier=NULL;" 
"  SET @xxxmdbug_status_breakpoint_check_result=NULL;" 
"  SET @xxxmdbug_status_last_command=NULL;" 
"  SET @xxxmdbug_status_last_command_result=NULL;" 
"  SET @xxxmdbug_status_line_number=NULL;" 
"  SET @xxxmdbug_stmt_for_x=NULL;" 
"  SET @xxxmdbug_surrogate_routine_identifier=NULL;" 
"  SET @xxxmdbug_test_setting=NULL;" 
"  SET @xxxmdbug_timeout_for_r_commands=NULL;" 
"  SET @xxxmdbug_timestamp=NULL;" 
"  SET @xxxmdbug_tmp_1=NULL;" 
"  SET @xxxmdbug_tmp_2=NULL;" 
"  SET @xxxmdbug_tmp_for_set=NULL;" 
"  SET @xxxmdbug_token_type=NULL;" 
"  SET @xxxmdbug_token_value_1=NULL;" 
"  SET @xxxmdbug_token_value_1_length=NULL;" 
"  SET @xxxmdbug_token_value_1_offset=NULL;" 
"  SET @xxxmdbug_token_value_2=NULL;" 
"  SET @xxxmdbug_token_value_2_length=NULL;" 
"  SET @xxxmdbug_token_value_2_offset=NULL;" 
"  SET @xxxmdbug_token_value_3=NULL;" 
"  SET @xxxmdbug_token_value_3_length=NULL;" 
"  SET @xxxmdbug_token_value_3_offset=NULL;" 
"  SET @xxxmdbug_token_value_4=NULL;" 
"  SET @xxxmdbug_token_value_4_length=NULL;" 
"  SET @xxxmdbug_token_value_4_offset=NULL;" 
"  SET @xxxmdbug_token_value_4a=NULL;" 
"  SET @xxxmdbug_track_declared_variables=NULL;" 
"  SET @xxxmdbug_track_statements=NULL;" 
"  SET @xxxmdbug_track_user_variables=NULL;" 
"  SET @xxxmdbug_uvar=NULL;" 
"  SET @xxxmdbug_uvar_type=NULL;" 
"  SET @xxxmdbug_value_length=NULL;" 
"  SET @xxxmdbug_variables_data_type=NULL;" 
"  SET @xxxmdbug_variables_is_in_scope=NULL;" 
"  SET @xxxmdbug_variables_is_settable=NULL;" 
"  SET @xxxmdbug_variables_is_updated_by_set=NULL;" 
"  SET @xxxmdbug_variables_old_value=NULL;" 
"  SET @xxxmdbug_variables_routine_identifier=NULL;" 
"  SET @xxxmdbug_variables_routine_type=NULL;" 
"  SET @xxxmdbug_variables_schema_identifier=NULL;" 
"  SET @xxxmdbug_variables_token_number_of_declare=NULL;" 
"  SET @xxxmdbug_variables_value=NULL;" 
"  SET @xxxmdbug_variables_variable_identifier=NULL;" 
"  SET @xxxmdbug_warning_count=NULL;" 
"  SET @xxxmdbug_what_to_call=NULL;" 
"  SET @xxxmdbug_x=NULL;" 
"  SET @xxxmdbug_x2=NULL;" 
"  SET @xxxmdbug_xoffset=NULL;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* todo: require fully qualified name for 'debug' */" 
"/* todo: need a parameter for a list of breakpoint commands that must happen before entering the routine */" 
"/* todo: need a parameter for memory size, you can set max_allowed_packet accordingly */" 
"/* The debuggee_wait_loop() code expects 'attach'," 
"   then 'debug', then 'continue'. */" 
"/* TODO: the newer idea is that one becomes a debuggee by" 
"         setting @xxxmdbug_is_debuggee=1 and @xxxmdbug_channel" 
"         and (I hope!) something that changes max_packet_size." 
"         But then one can either call a loop-and-wait-for-debug procedure," 
"         or call a surrogate directly (it will break on line 0)." 
"         There is no need for 'attach'. It's less stateful." 
"         The new way leads to many-to-one sessions (multiple debuggee sessions for one debugger), which is useful." 
"         It also leads to one-to-many sessions (multiple debugger sessions for one debuggee), which is not useful. */" 
"CREATE PROCEDURE xxxmdbug.debuggee_wait_loop ()" 
"BEGIN" 
"  DECLARE sleep_result INT;" 
"  DECLARE routine_type VARCHAR(1) CHARACTER SET utf8; /* 'F' or 'P', taken from surrogate routine identifier */"
"  DECLARE v_exception INT;" 
"  DECLARE v_surrogate_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_surrogate_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_remainder_of_original_name VARCHAR(8192) CHARACTER SET utf8;" 
"" 
"  IF @xxxmdbug_is_debuggee=0 OR @xxxmdbug_is_debuggee IS NULL THEN" 
"    /* Can't use @xxxmdbug_signal_errno because haven't called initialize() yet. */" 
"    SIGNAL SQLSTATE '05678' SET mysql_errno=5678, message_text = 'xxxmdbug_is_debuggee=0. probably become_debuggee_connection() has not been done.';" 
"    END IF;" 
"" 
"  /* Loop waiting for 'attach'. It is possible that it is already attached." 
"     todo: think about timeout */" 
"  wait_for_attach: LOOP" 
"    IF SLEEP(@xxxmdbug_sleep_time) = 1 THEN" 
"      /* Usually ^C causes error 1317, but just in case it doesn't ... */" 
"      SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno,message_text='sleep interrupted, probably due to control C';" 
"      END IF;" 
"    IF xxxmdbug.is_debuggee_and_is_attached()=1 THEN LEAVE wait_for_attach; END IF;" 
"    END LOOP;" 
"  /* obsolete: SET @xxxmdbug_status_last_command = 'attach'; */" 
"  /* obsolete: SET @xxxmdbug_status_last_command_result='OK'; */" 
"  CALL xxxmdbug.icc_send_statement_status('debuggee_wait_loop');" 
"" 
"  /* Everything is in a loop. The only ways to get out of it are:" 
"     ^C, which unfortunately will not always work." 
"     kill, which might leave the debugger looping for a response that will never come unless the debuggee restarts" 
"     error 5678, which is probably due to 'exit' command */" 
"" 
"  x: LOOP" 
"    BEGIN" 
"      /* We are not expecting an error except from PREPARE or EXECUTE, which are handled." 
"         But error 5678 (@xxxmdbug_signal_errno) is due to 'exit' and so we catch it separately and exit." 
"         Todo: handle other errors that should stop the show. */" 
"      DECLARE EXIT HANDLER FOR 1317 BEGIN select '1317'; SET v_exception = 1317; END; /* ^C */" 
"      DECLARE EXIT HANDLER FOR 5678 BEGIN select '5678'; SET v_exception = 5678; END; /* exit or debugger error */" 
"      DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN select 'sqlexception'; /* send a message that exit is happening */ END;" 
"" 
"      CALL xxxmdbug.reset(@xxxmdbug_channel,1); /* a fresh start for each loop iteration. */" 
"" 
"      SET @xxxmdbug_is_attached=1; /* reset() sets this to 0, unnecessarily */" 
"" 
"      /* Get a command. If it is not 'debug' then ignore it (but send a message), it is probably a leftover." 
"         Exceptions: 'exit' is never ignored, 'attach' is always successful. */" 
"" 
"      /* The normal thing is to get a command \"with wait\". But John Morris, for the sake of the Eclipse GUI," 
"         requested a way to make debuggee_wait_loop() wait for only a timeout period. If the timeout expires:" 
"         SELECT what information_status would give, and exit from debuggee_wait_loop(). Not documented. */" 
"      IF @xxxmdbug_sleep_time_for_john IS NULL THEN" 
"        CALL xxxmdbug.icc_get_user_command(1); /* 1 means \"wait\". Wait till 'debug procedure_name'. */" 
"      ELSE" 
"        CALL xxxmdbug.icc_get_user_command(0); /* 0 means \"no wait\" */" 
"        IF @xxxmdbug_message  = '' THEN"
"          DO SLEEP(@xxxmdbug_sleep_time_for_john);" 
"          CALL xxxmdbug.icc_get_user_command(0);" 
"          END IF;" 
"        IF @xxxmdbug_message  = '' THEN"
"          SELECT @xxxmdbug_debugger_name AS debugger_name," 
"                 @xxxmdbug_debugger_version AS debugger_version," 
"                 CURRENT_TIMESTAMP AS timestamp_of_status_message," 
"                 @xxxmdbug_number_of_last_status_message AS number_of_status_message," 
"                 @xxxmdbug_icc_count AS icc_count," 
"                 '' as schema_identifier," 
"                 '' as routine_identifier," 
"                 @xxxmdbug_status_line_number AS line_number," 
"                 0 AS is_at_breakpoint," 
"                 0 AS is_at_tbreakpoint," 
"                 0 AS is_at_routine_exit," 
"                 0 AS stack_depth," 
"                 @xxxmdbug_status_last_command AS last_command," 
"                 @xxxmdbug_status_last_command_result AS last_command_result," 
"                 @xxxmdbug_commands_count AS commands_count;" 
"          LEAVE x;" 
"          END IF;" 
"        END IF;" 
"" 
"      IF @xxxmdbug_token_value_1 ='attach' THEN"
"        /* obsolete: SET @xxxmdbug_status_last_command = @xxxmdbug_message; */" 
"        /* obsolete: CALL xxxmdbug.icc_change_statement_status('\"OK\"'); */" 
"        CALL xxxmdbug.icc_send_statement_status('debuggee_wait_loop');" 
"        ITERATE x;" 
"        END IF;" 
"      IF @xxxmdbug_token_value_1 ='exit' THEN"
"        SIGNAL SQLSTATE '56780' set mysql_errno=@xxxmdbug_signal_errno,message_text='exit command received';" 
"        END IF;" 
"      IF @xxxmdbug_token_value_1   IN ('breakpoint','tbreakpoint','clear','refresh','delete','execute') THEN"
"        IF @xxxmdbug_token_value_2  = 'user_variables' THEN"
"          CALL xxxmdbug.icc_process_user_command_r_user_variables();" 
"        ELSE" 
"          CALL xxxmdbug.icc_process_user_command();" 
"          END IF;" 
"        CALL xxxmdbug.icc_send_statement_status('debuggee_wait_loop');" 
"        ITERATE x;" 
"        END IF;" 
"      /* some commands are meaningless before 'debug' and icc_change_statement_status has already been called (?) somewhere. */" 
"      IF @xxxmdbug_token_value_1   IN ('continue','leave','next','skip','step') THEN "
"        SET @xxxmdbug_status_last_command = @xxxmdbug_message;" 
"        SET @xxxmdbug_status_last_command_result='\"Failed, the expected command is debug\"';" 
"        CALL xxxmdbug.icc_send_statement_status('debuggee_wait_loop');" 
"        ITERATE x;" 
"        END IF;" 
"      IF @xxxmdbug_token_value_1 <>'debug' THEN"
"        SET @xxxmdbug_status_last_command = @xxxmdbug_message;" 
"        CALL xxxmdbug.icc_change_statement_status('\"Failed, the expected command is debug\"');" 
"        CALL xxxmdbug.icc_send_statement_status('debuggee_wait_loop');" 
"        ITERATE x;" 
"        END IF;" 
"      /* 'debug'. Find the routine and find the surrogate name. */" 
"      /* We used to call name_parser() but now let us assume we have no privilege to create temporary tables." 
"         Whatever follows 'debug ' is supposed to be [schema_identifier.]routine_identifier [(parameters)]. */" 
"       IF @xxxmdbug_token_value_3 ='.' THEN"
"        SET @xxxmdbug_schema=@xxxmdbug_token_value_2;" 
"        SET @xxxmdbug_routine=@xxxmdbug_token_value_4;" 
"      ELSE" 
"        SET @xxxmdbug_schema=@xxxmdbug_default_schema;" 
"        SET @xxxmdbug_routine=@xxxmdbug_token_value_2;" 
"        END IF;" 
"" 
"      CALL xxxmdbug.debuggee_get_surrogate_name(RIGHT(@xxxmdbug_message,LENGTH(@xxxmdbug_message)-(INSTR(@xxxmdbug_message,'debug')+LENGTH('debug')))," 
"                                                @xxxmdbug_default_schema," 
"                                                v_surrogate_schema_identifier," 
"                                                v_surrogate_routine_identifier," 
"                                                routine_type," 
"                                                v_remainder_of_original_name);" 
"" 
"      /* Todo: this checks whether we have a privilege for routines in the group," 
"         but should make sure we can execute them, and the parameter count is right. */" 
"      CALL xxxmdbug.check_surrogate_routine(v_surrogate_schema_identifier,v_surrogate_routine_identifier,@xxxmdbug_status_last_command_result);" 
"      IF @xxxmdbug_status_last_command_result  > '' THEN"
"        SET @xxxmdbug_status_last_command = @xxxmdbug_message;" 
"        CALL xxxmdbug.icc_change_statement_status(@xxxmdbug_status_last_command_result);" 
"        CALL xxxmdbug.icc_send_statement_status('debuggee_wait_loop');" 
//"        ITERATE x;"
"        LEAVE x;"
"        END IF;" 
"" 
"      /* Put together: '`schema`' + '.' + '`routine`' + remainder of original string */" 
"      SET @xxxmdbug_routine_surrogate= CONCAT('`'," 
"                              TRIM(BOTH '`' FROM v_surrogate_schema_identifier)," 
"                              '`.`'," 
"                              v_surrogate_routine_identifier," 
"                              '`'," 
"                              v_remainder_of_original_name);" 
"" 
"      /* Cause breakpoint_check() to say yes at line 0, i.e. before start." 
"         So, before 'continue', one can say 'breakpoint' or 'delete' or 'tbreakpoint' etc.. */" 
"      SET @xxxmdbug_last_was_debug=1;" 
"" 
"      /* Side effect of @xxxmdbug_last_was_debug=1:" 
"         In icc_breakpoint_check(), which will be called by icc_core(0) as the breakpoint for line 0," 
"         knowing that @xxxmdbug_is_debuggee=1 and @xxxmdbug_is_attached=1," 
"         this must mean that debuggee_wait_loop()'s EXECUTE xxxmdbug_stmt" 
"         (where xxxmdbug_stmt is the CALL or the SET for the routine being debugged)." 
"         succeeded, we didn't get an error due to bad parameter/privilege/etc." 
"         So there in icc_breakpoint_check we'll CALL xxxmdbug.change_statement_status('OK')." 
"         But if EXECUTE fails, and if the EXECUTE fails in a way that prevents us from ever" 
"         reaching line 0 of the routine (and that again is checkable by looking if" 
"         @xxxmdbug_last_was_debug=1), then change statement status to 'Fail' and set @xxxmdbug_last_was_debug=0," 
"         because 'debug' failed. Doing it this way we keep track of @xxxmdbug_commands_count better. */" 
"" 
"      IF routine_type  = 'P' THEN"
"        SET @xxxmdbug_what_to_call = CONCAT('CALL ',@xxxmdbug_routine_surrogate);" 
"      ELSE /* IF routine_type  = 'F' */"
"        SET @xxxmdbug_what_to_call = CONCAT('SET @xxxmdbug_function_result = ',@xxxmdbug_routine_surrogate);" 
"      END IF;" 
"" 
"      BEGIN" 
"        DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN" 
"          /* Todo: check the error number. Probably the parameter count is wrong. */" 
"          SET @xxxmdbug_last_was_debug=0;" 
"          SET @xxxmdbug_status_last_command = @xxxmdbug_message; /* i.e. 'debug ...' */" 
"          CALL xxxmdbug.icc_change_statement_status(CONCAT('\"PREPARE failed for ',@xxxmdbug_what_to_call,'\"'));" 
"          CALL xxxmdbug.icc_send_statement_status('debuggee_wait_loop');" 
"          END;" 
//"        PREPARE xxxmdbug_stmt FROM @xxxmdbug_what_to_call;"
"          LEAVE x;"
"        END;" 
"      BEGIN" 
"        DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN" 
"          /* Todo: more specific error number. */" 
"          /* Todo: maybe this should cause is_at_routine_exit='yes'? */" 
"          IF @xxxmdbug_last_was_debug=1 THEN" 
"            SET @xxxmdbug_last_was_debug=0;" 
"            SET @xxxmdbug_status_last_command = @xxxmdbug_message; /* i.e. 'debug ...' */" 
"            CALL xxxmdbug.icc_change_statement_status(CONCAT('\"EXECUTE failed for ',@xxxmdbug_what_to_call,'\"'));" 
"          ELSE" 
"            SET @xxxmdbug_status_last_command_result=CONCAT('\"EXECUTE failed after ',@xxxmdbug_what_to_call,'\"');" 
"            END IF;" 
"          CALL xxxmdbug.icc_send_statement_status('debuggee_wait_loop');" 
"          END;" 
"        EXECUTE xxxmdbug_stmt;" 
"        /* todo: show what the call did, and/or what the function returned, then pause before iterating */" 
"        /* SET @xxxmdbug_status_last_command = 'debug'; */" 
"        SET @xxxmdbug_status_breakpoint_check_result = 0;" 
"        SET @xxxmdbug_status_line_number = 999999;" 
"        SET @xxxmdbug_status_last_command_result=CONCAT('\"completed ',@xxxmdbug_what_to_call,'\"');" 
"        CALL xxxmdbug.icc_send_statement_status('debuggee_wait_loop');" 
"        END;" 
"      END;" 
"" 
"    /* If there was a severe exception, leave. */" 
"    IF v_exception = 1317 OR v_exception = 5678 THEN LEAVE x; END IF;" 
"    END LOOP;" 
"" 
//"  /* The following settings for icc_send_statement_status() are supposed to help the checks"
//"     in dbms_pipe_receive_with_timeout() realize that 'refresh' commands should give up. */"
//"  SET @xxxmdbug_status_breakpoint_check_result = 0;"
//"  SET @xxxmdbug_call_stack='';"
//"  SET @xxxmdbug_status_last_command = 'exit'; /* todo: be more specific, maybe it was ^C */"
//"  /* Do not call xxxxmdbug.icc_change_statement_status() because commands_count should not go up */"
//"  SET @xxxmdbug_status_last_command_result = '\"debuggee_wait_loop() termination\"';"
//"  CALL xxxmdbug.icc_send_statement_status('routine_exit');"
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Pass: original name e.g. 'test.p'." 
"   Return: surrogate name e.g. 'test','xxxmdbug001Pp','P','()' or NULL if there is none" 
"   There might be further decoration e.g. 'test.p(@a,5)', if so keep it. If not, add '()'." 
"   If the name already has a surrogate format, return it without change.*/" 
"CREATE PROCEDURE xxxmdbug.debuggee_get_surrogate_name (original_name VARCHAR(8192) CHARACTER SET utf8," 
"                                                       default_schema_identifier VARCHAR(66) CHARACTER SET utf8," 
"                                                       OUT p_schema_identifier VARCHAR(66) CHARACTER SET utf8," 
"                                                       OUT p_surrogate_routine_identifier VARCHAR(66) CHARACTER SET utf8," 
"                                                       OUT p_routine_type VARCHAR(1) CHARACTER SET utf8," 
"                                                       OUT p_remainder_of_original_name VARCHAR(8192) CHARACTER SET utf8)" 
"debuggee_get_surrogate_name:" 
"BEGIN" 
"  DECLARE v_linked_list VARCHAR(21000) CHARACTER SET utf8;" 
"  DECLARE v_token_value_1,v_token_value_2,v_token_value_3 VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_token_value_1_offset,v_token_value_2_offset,v_token_value_3_offset INT;" 
"  DECLARE v_schema_identifier,v_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_schema_identifier2,v_routine_identifier2 VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_surrogate_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_type VARCHAR(1) CHARACTER SET utf8;" 
"  DECLARE v_remainder_of_original_name VARCHAR(8192) CHARACTER SET utf8;" 
"  DECLARE a INT;" 
"" 
"  /* If input is null or blank, output is NULL. */" 
"  IF original_name IS NULL OR original_name  = '' THEN"
"    SET p_surrogate_routine_identifier=NULL;" 
"    LEAVE debuggee_get_surrogate_name;" 
"    END IF;" 
"  /* Tokenize." 
"     We already did this during get_user_command() but that depended too much on globals. */" 
"  SET v_linked_list = '';" 
"  CALL xxxmdbug.insert_into_tokens_linked_list(original_name,v_linked_list);" 
"  CALL xxxmdbug.get_from_linked_list(v_linked_list,1,v_token_value_1,v_token_value_1_offset);" 
"  CALL xxxmdbug.get_from_linked_list(v_linked_list,2,v_token_value_2,v_token_value_2_offset);" 
"  CALL xxxmdbug.get_from_linked_list(v_linked_list,3,v_token_value_3,v_token_value_3_offset);" 
"  /* If second token is '.' then this should be [schema.]routine, otherwise it should be routine in default schema. */" 
"  IF v_token_value_2 ='.' THEN"
"    SET v_schema_identifier=v_token_value_1;" 
"    SET v_routine_identifier=v_token_value_3;" 
"  ELSE" 
"    SET v_schema_identifier=default_schema_identifier; /* todo: maybe you should pass current database to the wait loop */" 
"    SET v_routine_identifier=v_token_value_1;" 
"    END IF;" 
"" 
"  SET a=INSTR(original_name,v_routine_identifier)+LENGTH(v_routine_identifier);" 
"  SET v_remainder_of_original_name=RIGHT(original_name,(LENGTH(original_name)-a)+1);" 
"  SET a=INSTR(v_remainder_of_original_name,'(');" 
"  SET v_remainder_of_original_name=RIGHT(v_remainder_of_original_name,(LENGTH(v_remainder_of_original_name)-a)+1);" 
"  SET v_remainder_of_original_name=TRIM(v_remainder_of_original_name);" 
"  IF v_remainder_of_original_name='' THEN SET v_remainder_of_original_name='()'; END IF;" 
"  IF v_routine_identifier ='' OR v_routine_identifier IS NULL THEN"
"    SET p_surrogate_routine_identifier=NULL;" 
"    LEAVE debuggee_get_surrogate_name;" 
"    END IF;" 
"  SET v_routine_identifier=TRIM(BOTH '`' FROM v_routine_identifier);" 
"" 
"  /* If input is a surrogate name, then output = input. */" 
"  IF v_routine_identifier   LIKE 'xxxmdbug___P%' OR v_routine_identifier   LIKE 'xxxmdbug___F%' THEN"
"    SET v_surrogate_routine_identifier = v_routine_identifier;" 
"  ELSE" 
"    /* Suppose you have multiple surrogates produced at different times, e.g." 
"       (using the form that is decided during insert_into_routines)" 
"       xxxmdbug001Pp" 
"       xxxmdbug002Pp" 
"" 
"       You want the latest one." 
"       Todo: appropriate error if SELECT returns nothing." 
"       Todo: feedback for 'i status' showing the choice. */" 
"    /* Todo: this is wrong, what you really should do for lookup is" 
"       search through information_schema.routines for something whose" 
"       name starts with 'xxxmdbug', and contains" 
"    DECLARE xxxmdbug_comment VARCHAR(1000) DEFAULT             " 
"    'Surrogate routine for test.f1                                 " 
"    Generated by THE MDBUG CORE DEBUGGER ... */" 
"" 
"    /* In the following LIKE search, the problem is that v_routine_identifier might" 
"       contain '_', which will match 'X', so looking for 'a_b' we will find 'aXb'." 
"       This can be solved by escaping. Change '_'s to '\\_'s, change '%'s to '\\%'s." 
"       Todo: worry about '\\' existing in the identifier, but that's rare, eh? */" 
"     SET v_schema_identifier2=REPLACE(v_schema_identifier,'_','\\_');" 
"     SET v_schema_identifier2=REPLACE(v_schema_identifier,'%','\\%');" 
"     SET v_routine_identifier2=REPLACE(v_routine_identifier,'_','\\_');" 
"     SET v_routine_identifier2=REPLACE(v_routine_identifier,'%','\\%');" 
"" 
"     SELECT MAX(routine_name)" 
"     INTO v_surrogate_routine_identifier" 
"     FROM information_schema.routines" 
"     WHERE routine_schema  COLLATE utf8_general_ci LIKE TRIM(BOTH '`' FROM v_schema_identifier2)"
"     AND (routine_name   LIKE CONCAT('xxxmdbug___P',v_routine_identifier2)"
"          OR routine_name   LIKE CONCAT('xxxmdbug___F',v_routine_identifier2));"
"" 
"     /* if result is NULL, that simply means no match was found */" 
"    IF v_surrogate_routine_identifier IS NULL THEN" 
"      SET p_surrogate_routine_identifier=NULL;" 
"      LEAVE debuggee_get_surrogate_name;" 
"      END IF;" 
"    END IF;" 
"" 
"  SET p_schema_identifier = v_schema_identifier;" 
"  SET p_surrogate_routine_identifier = v_surrogate_routine_identifier;" 
"  SET p_routine_type = SUBSTRING(v_surrogate_routine_identifier FROM LENGTH('xxxmdbug____') FOR 1); /* 'P' or 'F' */" 
"  SET p_remainder_of_original_name = v_remainder_of_original_name;" 
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.check_surrogate_routine (p_schema_identifier VARCHAR(66) CHARACTER SET utf8," 
"                                                   p_routine_identifier VARCHAR(66) CHARACTER SET utf8," 
"                                                   OUT p_return VARCHAR(8192) CHARACTER SET utf8)" 
"check_surrogate_routine:" 
"BEGIN" 
"  DECLARE v_group_name VARCHAR(3) CHARACTER SET utf8;" 
"  DECLARE v_timestamp_when_setup_procedure_was_run DATETIME;" 
"  DECLARE v_version_number_of_debugger CHAR(5) CHARACTER SET utf8;" 
"  DECLARE v_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_original_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_surrogate_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE eof INT;" 
"  DECLARE v_last_altered DATETIME;" 
"  DECLARE v_routine_type VARCHAR(1) CHARACTER SET utf8;" 
"  DECLARE c CURSOR FOR SELECT timestamp_when_setup_procedure_was_run," 
"                              schema_identifier," 
"                              original_routine_identifier," 
"                              surrogate_routine_identifier" 
"                       FROM xxxmdbug.setup_log" 
"                       WHERE group_name = v_group_name;" 
"  DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN" 
"    SET p_return=CONCAT(p_return,'Error reading setup_log.');" 
"    END;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1;" 
"" 
"  SET p_return='';" 
"  IF p_schema_identifier COLLATE utf8_general_ci IS NULL OR p_routine_identifier IS NULL THEN"
"    SET p_return=CONCAT(p_return,'schema or routine is null.');" 
"    LEAVE check_surrogate_routine;" 
"    END IF;" 
"  SET p_schema_identifier=TRIM(BOTH '`' FROM p_schema_identifier);" 
"  SET p_routine_identifier=TRIM(BOTH '`' FROM p_routine_identifier);" 
"  /* Surrogate identifier format should be 'xxxmdbug___P' or 'xxxmdbug___F' where '___' is the group name */" 
"  IF p_routine_identifier   NOT LIKE 'xxxmdbug___P%' AND p_routine_identifier   NOT LIKE 'xxxmdbug___F%' THEN"
"    SET p_return=CONCAT(p_return,p_routine_identifier,' is incorrect format for a surrogate identifier.');" 
"    END IF;" 
"" 
"  /* Surrogate routine should be noted in setup_log */" 
"  SELECT version_number_of_debugger" 
"  INTO v_version_number_of_debugger" 
"  FROM xxxmdbug.setup_log" 
"  WHERE TRIM(BOTH '`' FROM surrogate_routine_identifier) =p_routine_identifier"
"  AND TRIM(BOTH '`' FROM schema_identifier) COLLATE utf8_general_ci =p_schema_identifier;"
"  IF v_version_number_of_debugger IS NULL THEN" 
"    SET p_return=CONCAT(p_return,p_routine_identifier,'    ');"
"    END IF;" 
"  IF v_version_number_of_debugger  < @xxxmdbug_debugger_version THEN"
"    SET p_return=CONCAT(p_return,p_routine_identifier,' was set up with an older debugger version.');" 
"    END IF;" 
"  SET v_group_name = SUBSTRING(p_routine_identifier FROM LENGTH('xxxmdbug')+1 FOR 3);" 
"  OPEN c;" 
"  x: LOOP" 
"    SET eof = 0;" 
"    FETCH c INTO v_timestamp_when_setup_procedure_was_run," 
"                 v_schema_identifier," 
"                 v_original_routine_identifier," 
"                 v_surrogate_routine_identifier;" 
"    IF eof = 1 THEN LEAVE x; END IF;" 
"    SET v_routine_type = SUBSTRING(TRIM(BOTH '`' FROM v_surrogate_routine_identifier) FROM LENGTH('xxxmdbug____') FOR 1); /* 'P' or 'F' */" 
"    /* this fails if debuggee user has no privilege on the routine, and that is good */" 
"    SET v_last_altered=NULL; /* This should not be necessary, but it is. */" 
"    SELECT last_altered INTO v_last_altered FROM information_schema.routines" 
"           WHERE routine_schema COLLATE utf8_general_ci =TRIM(BOTH '`' FROM v_schema_identifier)"
"           AND routine_name =TRIM(BOTH '`' FROM v_original_routine_identifier)"
"           AND LEFT(routine_type,1) =v_routine_type;"
"    IF v_last_altered IS NULL THEN" 
"      SET p_return=CONCAT(p_return,v_schema_identifier,'.',v_original_routine_identifier,' original was not found.');" 
"      END IF;" 
"    IF v_last_altered  > v_timestamp_when_setup_procedure_was_run THEN"
"      SET p_return=CONCAT(p_return,v_schema_identifier,'.',v_original_routine_identifier,' original was altered.');" 
"      END IF;" 
"    SET v_last_altered=NULL; /* This should not be necessary, but it is. */" 
"    SELECT last_altered INTO v_last_altered FROM information_schema.routines" 
"           WHERE routine_schema COLLATE utf8_general_ci=TRIM(BOTH '`' FROM v_schema_identifier)"
"           AND routine_name=TRIM(BOTH '`' FROM v_surrogate_routine_identifier)" 
"           AND LEFT(routine_type,1) =v_routine_type;"
"    IF v_last_altered IS NULL THEN" 
"      SET p_return=CONCAT(p_return,v_schema_identifier,'.',v_surrogate_routine_identifier,' surrogate was not found.');" 
"      END IF;" 
"    END LOOP;" 
"  CLOSE c;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.generate (mysql_proc_db VARCHAR(66) CHARACTER SET utf8, mysql_proc_name VARCHAR(66) CHARACTER SET utf8," 
"                                               mysql_proc_definer VARCHAR(66) CHARACTER SET utf8, mysql_proc_param_list VARCHAR(8192) CHARACTER SET utf8," 
"                                               mysql_proc_returns VARCHAR(66) CHARACTER SET utf8, mysql_proc_type VARCHAR(66) CHARACTER SET utf8," 
"                                               mysql_proc_sql_mode VARCHAR(512) CHARACTER SET utf8,mysql_proc_comment VARCHAR(8192) CHARACTER SET utf8," 
"                                               mysql_proc_is_deterministic VARCHAR(66) CHARACTER SET utf8, mysql_proc_sql_data_access VARCHAR(66) CHARACTER SET utf8," 
"                                               mysql_proc_security_type VARCHAR(66) CHARACTER SET utf8," 
"                                               mysql_proc_body LONGTEXT CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_statement_number INT;" 
"  DECLARE v_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_type VARCHAR(10) CHARACTER SET utf8;" 
"  DECLARE v_statement_number_within_routine INT;" 
"  DECLARE v_token_number_of_first_token INT;" 
"  DECLARE v_line_number_of_start_of_first_token INT;" 
"  DECLARE v_character_number_of_start_of_first_token INT;" 
"  DECLARE v_token_number_of_last_token INT;" 
"  DECLARE v_line_number_of_end_of_last_token INT;" 
"  DECLARE v_character_number_of_end_of_last_token INT;" 
"  DECLARE v_statement_type enum('flow_control','declare_variable','declare_handler','declare_condition','declare_cursor','debuggable','unknown');" 
"  DECLARE v_previous_statement_type enum('flow_control','declare_variable','declare_handler','declare_condition','declare_cursor','debuggable','unknown');" 
"  DECLARE v_token_number INT;" 
"  DECLARE v_offset INT;" 
"  DECLARE v_line_number INT;" 
"  DECLARE v_g LONGTEXT CHARACTER SET utf8;" 
"  DECLARE eof INT DEFAULT 0;" 
"  DECLARE inner_loop_label VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_statement_end_character VARCHAR(1) CHARACTER SET utf8;" 
"  DECLARE v_is_leave_possible INT;" 
"  DECLARE v_value_of_first_token,v_value_of_second_token,v_value_of_third_token,v_value_of_fourth_token VARCHAR(16) CHARACTER SET utf8;" 
"  DECLARE v_offset_of_begin INT;" 
"  DECLARE ipos INT;"
"  DECLARE c CURSOR FOR SELECT *" 
"                       FROM xxxmdbug.statements" 
"                       WHERE schema_identifier COLLATE utf8_general_ci=mysql_proc_db AND routine_identifier =mysql_proc_name"
"                       ORDER BY statement_number;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1;" 
"" 
"  SET @xxxmdbug_routine_identifier = mysql_proc_name;" 
"" 
"  SET @xxxmdbug_label_list = '';" 
"" 
"  /* Todo: consider whether you should drop it immediately rather than putting DROP in the script." 
"     Todo: maybe there should be a separate 'cleanup' procedure? */" 
"  SET v_g = CONCAT('DROP ',mysql_proc_type,' IF EXISTS ',mysql_proc_db,'.',@xxxmdbug_surrogate_routine_identifier,';',@xxxmdbug_lf);" 
"" 
"  SET v_g = CONCAT(v_g,'SET session sql_mode = ''',mysql_proc_sql_mode,''';',@xxxmdbug_lf);" 
"" 
"  SET v_g = CONCAT(v_g,'CREATE ');" 
"" 
"  /* The definer clause, as in \"CREATE definer=root@localhost PROCEDURE p\"." 
"     SHOW CREATE PROCEDURE would change root@localhost to `root`@`localhost`. It was necessary."
"     The IF ... ENDIF statement here is a fix for github bug#1."
"     Todo: check privileges. If you don't have the right to do this CREATE later, you should"
"           generate 'DEFINER=CURRENT_USER' and put a note in the setup_log." 
"           It might not matter much if SQL SECURITY INVOKER anyway. */" 
"  SET v_g = CONCAT(v_g,'DEFINER=');"
"  SET ipos = INSTR(mysql_proc_definer,'@');"
"  IF ipos > 0 AND INSTR(mysql_proc_definer,'`') = 0 THEN "
"    SET v_g = CONCAT(v_g,'`');"
"    SET v_g = CONCAT(v_g,LEFT(mysql_proc_definer,ipos-1));"
"    SET v_g = CONCAT(v_g,'`@`');"
"    SET v_g = CONCAT(v_g,RIGHT(mysql_proc_definer,LENGTH(mysql_proc_definer)-ipos));"
"    SET v_g = CONCAT(v_g,'` ');"
"  ELSE "
"    SET v_g = CONCAT(v_g,mysql_proc_definer,' ');"
"  END IF;"
"" 
"  SET v_g = CONCAT(v_g," 
"                   mysql_proc_type," 
"                   ' '," 
"                   mysql_proc_db,'.',@xxxmdbug_surrogate_routine_identifier," 
"                   '(',mysql_proc_param_list,') ');" 
"  IF mysql_proc_returns  > ' ' THEN SET v_g = CONCAT(v_g,'RETURNS ',mysql_proc_returns,' '); END IF;"
"" 
"  /* characteristic: COMMENT 'string' */" 
"  IF mysql_proc_comment  > '' THEN"
"    SET v_g = CONCAT(v_g,'''',REPLACE(mysql_proc_comment,'''',''''''),''' ');" 
"    END IF;" 
"  /* characteristic: [NOT] DETERMINISTIC */" 
"  SET v_g = CONCAT(v_g,case mysql_proc_is_deterministic when 'NO' THEN 'NOT DETERMINISTIC ' else 'DETERMINISTIC ' end);" 
"  /* characteristic: { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } */" 
"  SET v_g = CONCAT(v_g,REPLACE(mysql_proc_sql_data_access,'_',' '),' ');" 
"  /* characteristic: SQL SECURITY { DEFINER | INVOKER } */" 
"  SET v_g = CONCAT(v_g,'SQL SECURITY ',mysql_proc_security_type,' ');" 
"" 
"  /* Todo: mysql.proc.character_set_client, mysql.proc.collation_connection, mysql.proc.db_collation */" 
"" 
"  /* Save the offset of the BEGIN that generate_starter() is about to generate, it is the actual start of the routine body. */" 
"  SET v_offset_of_begin=LENGTH(v_g)+LENGTH(@xxxmdbug_lf);" 
"" 
"  CALL xxxmdbug.generate_starter(v_g,@xxxmdbug_routine_identifier,mysql_proc_db,mysql_proc_name,mysql_proc_type);" 
"" 
"  if v_g is null then signal sqlstate '56780' set mysql_errno=@xxxmdbug_signal_errno,message_text='assert 49'; end if;" 
"" 
"  OPEN c;" 
"  x: LOOP" 
"    FETCH c INTO v_statement_number," 
"                 v_schema_identifier," 
"                 v_routine_identifier," 
"                 v_routine_type," 
"                 v_statement_number_within_routine," 
"                 v_token_number_of_first_token," 
"                 v_line_number_of_start_of_first_token," 
"                 v_character_number_of_start_of_first_token," 
"                 v_token_number_of_last_token," 
"                 v_line_number_of_end_of_last_token," 
"                 v_character_number_of_end_of_last_token," 
"                 v_statement_type," 
"                 v_is_leave_possible;" 
"    IF eof = 1 THEN LEAVE x; END IF;" 
"SET @xxxmdbug_x = (SELECT value FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_first_token);" 
"" 
"    CALL xxxmdbug.generate_label(v_g,@xxxmdbug_x,v_statement_number,v_token_number_of_first_token);" 
"  if v_g is null then signal sqlstate '56780' set mysql_errno=@xxxmdbug_signal_errno,message_text='assert 49'; end if;" 
"" 
"    /* \"if (statement is debuggable)\" */" 
"    IF v_statement_type  = 'debuggable' THEN"
"      BEGIN" 
"        /* generate 'call icc_copy_variable_to_table_row' for each variable that's in scope */" 
"        DECLARE v_token_number_of_declare INT;" 
"        DECLARE v_variable_identifier VARCHAR(66) CHARACTER SET utf8;" 
"        DECLARE v_value VARCHAR(66) CHARACTER SET utf8;" 
"        DECLARE variables_eof INT DEFAULT 0;" 
"        DECLARE is_first_statement_in_a_declare_handler INT;" 
"        DECLARE v_verb VARCHAR(16) CHARACTER SET utf8; /* first word in statement must be the verb, eh? */" 
"        DECLARE c_variables CURSOR FOR SELECT token_number_of_declare,variable_identifier" 
"                                       FROM xxxmdbug.variables" 
"                                       WHERE is_in_scope = 1; /* no order-by needed */" 
"        DECLARE CONTINUE HANDLER FOR NOT FOUND SET variables_eof = 1;" 
"        /* starts \"if statement is being debugged\" */" 
"        SET v_g = CONCAT(v_g,@xxxmdbug_lf,'IF xxxmdbug.is_debuggee_and_is_attached()=1 THEN',@xxxmdbug_lf);" 
"" 
"        if v_g is null then signal sqlstate '56780' set mysql_errno=@xxxmdbug_signal_errno, message_text='assert 60'; end if;" 
"" 
"        /* inner_loop: generate 'xxxmdbug_inner_loop_x: LOOP' */" 
"        SET inner_loop_label = CONCAT('xxxmdbug_inner_loop_label_',v_statement_number_within_routine);" 
"        SET v_g = CONCAT(v_g,inner_loop_label,': LOOP',@xxxmdbug_lf);" 
"" 
"        if v_g is null then signal sqlstate '56780' set mysql_errno=@xxxmdbug_signal_errno, message_text='assert 61'; end if;" 
"" 
"        /* Save @@warning_count. */" 
"        SET v_verb = (SELECT value FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_first_token);" 
"        IF v_previous_statement_type  = 'declare_handler' THEN"
"          SET is_first_statement_in_a_declare_handler = 1;" 
"        ELSE" 
"          SET is_first_statement_in_a_declare_handler = 0;" 
"          END IF;" 
"        SET v_g = CONCAT(v_g,@xxxmdbug_lf,'CALL xxxmdbug.icc_start('," 
"                                               v_line_number_of_start_of_first_token," 
"                                               ','," 
"                                               is_first_statement_in_a_declare_handler," 
"                                               ');',@xxxmdbug_lf);" 
"" 
"        if v_g is null then signal sqlstate '56780' set mysql_errno=@xxxmdbug_signal_errno, message_text='assert 62'; end if;" 
"" 
"        CALL xxxmdbug.determine_what_variables_are_in_scope(v_token_number_of_first_token,mysql_proc_db,mysql_proc_name);" 
"        OPEN c_variables;" 
"        y: LOOP" 
"          FETCH c_variables INTO v_token_number_of_declare,v_variable_identifier;" 
"          IF variables_eof = 1 THEN LEAVE y; END IF;" 
"          CALL xxxmdbug.overflow_check(v_g);" 
"          SET v_g = CONCAT(v_g,@xxxmdbug_lf,'CALL xxxmdbug.icc_copy_variable_to_table_row('," 
"                               '''',v_variable_identifier,'''',','," 
"                               v_token_number_of_declare,','," 
"                               v_variable_identifier,');',@xxxmdbug_lf);" 
"" 
"          END LOOP;" 
"" 
"        if v_g is null then signal sqlstate '56780' set mysql_errno=@xxxmdbug_signal_errno, message_text='assert 63'; end if;" 
"" 
"        CLOSE c_variables;" 
"        /* generate 'call icc_core' */" 
"        SET v_g = CONCAT(v_g,'CALL xxxmdbug.'," 
"                             @xxxmdbug_icc_core_surrogate_name,'('," 
"                             v_line_number_of_start_of_first_token,');');" 
"" 
"        if v_g is null then signal sqlstate '56780' set mysql_errno=@xxxmdbug_signal_errno, message_text='assert 66'; end if;" 
"" 
"        /* Generate: \"if (exit) signal\" */" 
"        /* todo: consider doing the signal in icc_core or icc_process_user_command but maybe then it won't be handled. */" 
"        SET v_g = CONCAT(v_g,@xxxmdbug_lf," 
"        'IF @xxxmdbug_token_value_1  = ''exit'' THEN SIGNAL sqlstate ''56780'' SET mysql_errno = @xxxmdbug_signal_errno; END IF;');"
"" 
"        /* generate 'call icc_copy_table_row_to_variable' for each variable that's in scope */" 
"        SET variables_eof = 0;" 
"        OPEN c_variables;" 
"        y2: LOOP" 
"          FETCH c_variables INTO v_token_number_of_declare,v_variable_identifier;" 
"          IF variables_eof = 1 THEN LEAVE y2; END IF;" 
"          CALL xxxmdbug.overflow_check(v_g);" 
"          SET v_g = CONCAT(v_g,@xxxmdbug_lf,'CALL xxxmdbug.icc_copy_table_row_to_variable('," 
"                               '''',v_variable_identifier,'''',','," 
"                               v_token_number_of_declare,','," 
"                               v_variable_identifier,');');" 
"" 
"          if v_g is null then signal sqlstate '56780' set mysql_errno=@xxxmdbug_signal_errno, message_text='assert 67'; end if;" 
"" 
"          END LOOP;" 
"        CLOSE c_variables;" 
"" 
"        if v_g is null then signal sqlstate '56780' set mysql_errno=@xxxmdbug_signal_errno, message_text='assert 65'; end if;" 
"" 
"        /* inner_loop: 'SET' and 'EXECUTE' might change variables that we're watching." 
"           So if they happened, go back and copy the variables again." 
"           Todo: think: should this happen after non-debuggable statements too? */" 
"        SET v_g = CONCAT(v_g,'IF @xxxmdbug_breakpoint_check_result>0 AND (@xxxmdbug_token_value_1 = ''set'' OR @xxxmdbug_token_value_1 = ''execute'') THEN ITERATE ',inner_loop_label,'; END IF;',@xxxmdbug_lf);" 
"" 
"        /* Check @@warning_count. */" 
"        SET v_g = CONCAT(v_g,@xxxmdbug_lf,'CALL xxxmdbug.icc_end();',@xxxmdbug_lf);" 
"" 
"        /* Generate: \"if (leave) leave\" i.e. leave outer loop */" 
"        /* Sometimes LEAVE is illegal, see insert_into_statements comments. If so act as if 'leave' is 'skip'. */" 
"" 
"        IF v_is_leave_possible = 1 THEN" 
"          SET v_g = CONCAT(v_g,@xxxmdbug_lf,'IF @xxxmdbug_token_value_1 = ''leave'' THEN LEAVE '," 
"                           RTRIM(RIGHT(@xxxmdbug_label_list,64)),'; END IF;',@xxxmdbug_lf);" 
"        ELSE" 
"          SET v_g = CONCAT(v_g,@xxxmdbug_lf,'IF @xxxmdbug_token_value_1 = ''leave'' THEN LEAVE '," 
"                           inner_loop_label,'; END IF;',@xxxmdbug_lf);" 
"           END IF;" 
"        END;" 
"" 
"      if v_g is null then signal sqlstate '56780' set mysql_errno=@xxxmdbug_signal_errno, message_text='assert 44'; end if;" 
"      /* inner_loop: by leaving inner_loop before doing the instruction, we \"skip over\" it */" 
"      SET v_g = CONCAT(v_g,'IF @xxxmdbug_token_value_1 = ''skip'' THEN LEAVE ',inner_loop_label,'; END IF;',@xxxmdbug_lf);" 
"" 
"      /* If the original routine contained only one statement which was not compound and which" 
"         did not end with ';', add ';'. */" 
"      IF (SELECT value FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_last_token) <>';' THEN"
"        SET v_statement_end_character = ';';" 
"      ELSE" 
"        SET v_statement_end_character = '';" 
"        END IF;" 
"" 
"      /* generate: handlers */" 
"      /* removed. see notes before generate_handlers(). CALL xxxmdbug.generate_handlers(v_g,v_line_number_of_start_of_first_token); */" 
"      CALL xxxmdbug.overflow_check(v_g);" 
"      CALL xxxmdbug.generate_statement_text(v_g,v_token_number_of_first_token,v_token_number_of_last_token,mysql_proc_db,mysql_proc_body," 
"                                            mysql_proc_sql_mode);" 
"      SET v_g = CONCAT(v_g,v_statement_end_character);" 
"" 
"      /* END the BEGIN that generate_handlers() generated */" 
"      /* removed. see notes before generate_handlers(). SET v_g = CONCAT(v_g,@xxxmdbug_lf,'END;'); */" 
"" 
"      /* generate something to insert if statement is 'prepare' or delete if statement is 'deallocate'" 
"         todo: think about the execution path if there is a user-written warning */" 
"      SET v_value_of_first_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_first_token);" 
"      IF v_value_of_first_token  = 'PREPARE' THEN"
"        SET v_value_of_second_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_first_token+1);" 
"        SET v_value_of_fourth_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_first_token+3);" 
"        SET v_g = CONCAT(v_g,@xxxmdbug_lf,'CALL xxxmdbug.insert_into_prepared_statements('''," 
"                                              v_value_of_second_token," 
"                                              ''','''," 
"                                              TRIM(BOTH '''' FROM v_value_of_fourth_token)," 
"                                              ''');');" 
"        END IF;" 
"      IF v_value_of_first_token  = 'DROP' THEN"
"        /* A little-known alternative syntax for DEALLOCATE PREPARE is DROP PREPARE. */" 
"        SET v_value_of_second_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_first_token+1);" 
"        IF v_value_of_second_token  = 'PREPARE' THEN SET v_value_of_first_token = 'DEALLOCATE'; END IF;"
"        END IF;" 
"      IF v_value_of_first_token  = 'DEALLOCATE' THEN"
"        SET v_value_of_third_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = v_token_number_of_first_token+2);" 
"        SET v_g = CONCAT(v_g,@xxxmdbug_lf,'CALL xxxmdbug.delete_from_prepared_statements('''," 
"                                              v_value_of_third_token," 
"                                              ''');');" 
"        END IF;" 
"" 
"      /* generate 'update statements_executed' */" 
"      SET v_g = CONCAT(v_g,@xxxmdbug_lf,'CALL xxxmdbug.update_statements_executed(0);');" 
"" 
"      /* inner_loop: leave the loop after doing the original statement once */" 
"      SET v_g = CONCAT(v_g,@xxxmdbug_lf,'LEAVE ',inner_loop_label,';',@xxxmdbug_lf);" 
"      /* inner loop: ends */" 
"      SET v_g = CONCAT(v_g,'END LOOP;',@xxxmdbug_lf);" 
"" 
"      SET v_g = CONCAT(v_g,@xxxmdbug_lf,'ELSE'); /* terminates \"if statement is being debugged\" */" 
"      /* \"generate the statement text\" for when we're not debugging */" 
"      CALL xxxmdbug.overflow_check(v_g);" 
"      CALL xxxmdbug.generate_statement_text_as_is(v_g,v_token_number_of_first_token,v_token_number_of_last_token,mysql_proc_db, mysql_proc_body);" 
"      SET v_g = CONCAT(v_g,v_statement_end_character);" 
"      SET v_g = CONCAT(v_g,@xxxmdbug_lf,'END IF;');" 
"    ELSE" 
"      CALL xxxmdbug.generate_statement_text(v_g,v_token_number_of_first_token,v_token_number_of_last_token,mysql_proc_db,mysql_proc_body," 
"                                            mysql_proc_sql_mode);" 
"      END IF; /* matches \"if (statement is debuggable) ... else ...\" */" 
"" 
"    SET v_previous_statement_type = v_statement_type;" 
"" 
"    END LOOP;" 
"    if v_g is null then signal sqlstate '56780' set mysql_errno=@xxxmdbug_signal_errno, message_text='assert 45'; end if;" 
"  CLOSE c;" 
"  CALL xxxmdbug.generate_ender(v_g);" 
"  UPDATE xxxmdbug.routines" 
"  SET definition_of_surrogate_routine = v_g, offset_of_begin = v_offset_of_begin" 
"  WHERE routine_identifier_of_original = mysql_proc_name AND schema_identifier_of_original = mysql_proc_db;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* We occasionally pass a value to overflow_check() to see whether it is about to overflow." 
"   LONGTEXT variables cannot be longer than the read-only variable @@max_allowed_packet," 
"   which has a default value of 1MB, which is not a lot considering how much we add to a routine body." 
"   Attempts to make v_g longer with CONCAT will cause v_g to be NULL," 
"   and that will also cause an error, but if it's after-the-fact then we will not know" 
"   for sure that the problem was overflow." 
"   If overflow happens, remedies are: restart mysqld with --max_allowed_packet," 
"   redo setup() with -track_user_variables|track_declared_variables|track_statements" 
"   set to lower values. */" 
"/* todo: use this to check at runtime if there are too many variables / breakpoints / other fixed areas. */" 
"CREATE PROCEDURE xxxmdbug.overflow_check (param1 LONGTEXT CHARACTER SET utf8)" 
"BEGIN" 
"" 
"  IF OCTET_LENGTH(param1) + 10000 > @@max_allowed_packet THEN" 
"    SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno,message_text='Overflow';" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.view_and_trigger_and_event_check() BEGIN END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"CREATE PROCEDURE xxxmdbug.checks_and_warnings(database_name CHAR(255) CHARACTER SET utf8) BEGIN END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Set @xxxmdbug_channel." 
"   If user passes NULL, then set to default = user()." 
"   Create session variable @xxxmdbug_channel." 
"" 
"TODO: Fulfill the great vision behind xxxmdbug_channel." 
"      It can be any string. Usually there's a \"mutual agreement\" between debugger and debuggee about the value." 
"      The default is user name, specifically USER() -- not CURRENT_USER which would be routine's definer." 
"      Todo: decide whether to strip hostname from user name." 
"      Suppose it's 'X'." 
"      Then dbms_pipe_send and dbms_pipe_receive will always have a prefix that starts with 'xxxmdbug_X'." 
"" 
"      For debuggee, it means \"I will only accept commands that start with 'xxxmdbug_X'." 
"      In dbms_pipe_send + dbms_pipe_receive: It means channel identifier. Ignore anything that doesn't have X in the prefix." 
"      For command('X','a'): It means \"I want to attach to whoever is listening as X\"." 
"      If the debugger dies and comes back to life on another connection_id, or if there are two debuggers, that's okay." 
"      .... I'm starting to think that 'connection_id' doesn't even matter." 
"      There is automatic truncation to 64 characters. There is always trimming of lead or trail spaces." 
" */" 
"CREATE PROCEDURE xxxmdbug.setxxxmdbug_channel (xxxmdbug_channel VARCHAR(66) CHARACTER SET utf8)" 
"BEGIN" 
"  IF xxxmdbug_channel IS NULL THEN" 
"    SET @xxxmdbug_channel = USER();" 
"  ELSE" 
"    SET @xxxmdbug_channel = xxxmdbug_channel;" 
"    END IF;" 
"  SET @xxxmdbug_channel=TRIM(@xxxmdbug_channel);" 
"  IF LENGTH(@xxxmdbug_channel)=0 THEN SIGNAL SQLSTATE '56780' SET mysql_errno = @xxxmdbug_signal_errno; END IF;" 
"  CALL xxxmdbug.dbms_pipe_clean(@xxxmdbug_channel); /* replace * or / with _ */" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
//strcpy(x,
//""
//"/* We run into identifiers with setup(original_routine_identifier, with 'd routine_name', etc."
//"   Names might have two parts (schema_identifier.object_identifier), and either part may be '*'."
//"   Default schema_identifier is current database."
//"   Todo: case-sensitivity problems, character-set problems, delimiter problems. */"
//"/*"
//"CREATE PROCEDURE xxxmdbug.name_parser (original_string VARCHAR(66) CHARACTER SET utf8, OUT schema_identifier VARCHAR(66) CHARACTER SET utf8, OUT object_name VARCHAR(66) CHARACTER SET utf8)"
//"BEGIN"
//"  DECLARE v_token_count INT;"
//"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.tokens;"
//"  CREATE TEMPORARY TABLE xxxmdbug.tokens (schema_identifier VARCHAR(66) CHARACTER SET utf8,"
//"                       routine_identifier VARCHAR(66) CHARACTER SET utf8,"
//"                       token_number int primary key auto_increment,"
//"                       offsetx int,"
//"                       line_number int,"
//"                       value VARCHAR(16384)) engine=memory;"
//"  CALL xxxmdbug.insert_into_tokens(NULL,NULL,original_string,1);"
//""
//"  SET v_token_count = (SELECT COUNT(*) FROM xxxmdbug.tokens);"
//"  IF v_token_count = 1 THEN"
//"    SET schema_identifier = @xxxmdbug_default_schema;"
//"    SET object_name = (SELECT value FROM xxxmdbug.tokens);"
//"  ELSE"
//"    SET schema_identifier = (SELECT value FROM xxxmdbug.tokens LIMIT 1);"
//"    SET object_name = (SELECT value FROM xxxmdbug.tokens LIMIT 1 OFFSET 2);"
//"    END IF;"
//"  DROP TEMPORARY TABLE xxxmdbug.tokens;"
//"  END"
//"*/");

//if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* When there's a comma-separated list with multiple names, name_parser() isn't good enough." 
"   Instead setup() will call multiple_name_parser() and return multiple names in table schemas_and_objects." 
"   Todo: allow type specification i.e. 'procedure' or 'function' */" 
"CREATE PROCEDURE xxxmdbug.multiple_name_parser (original_string VARCHAR(8192) CHARACTER SET utf8)" 
"multiple:" 
"BEGIN" 
"  DECLARE v_value VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_dummy VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_schema_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_object_identifier VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_token_number INT;" 
"  DECLARE v_original_string_copy VARCHAR(8192) CHARACTER SET utf8;" 
"" 
"  DROP TEMPORARY TABLE IF EXISTS xxxmdbug.schemas_and_objects;" 
"  CREATE TEMPORARY TABLE xxxmdbug.schemas_and_objects (" 
"                       s_schema_identifier VARCHAR(66) CHARACTER SET utf8," 
"                       s_routine_identifier VARCHAR(66) CHARACTER SET utf8," 
"                       s_routine_type VARCHAR(10) CHARACTER SET utf8) engine=memory;" 
"  IF original_string IS NULL THEN" 
"    INSERT INTO xxxmdbug.schemas_and_objects VALUES ('%','%','%');" 
"    LEAVE multiple;" 
"    END IF;" 
"" 
"  CALL xxxmdbug.create_tokens_table();" 
"" 
"  /* Unfortunately insert_into_tokens will think % is a separate token, so replace it and restore it afterwards. */" 
"  SET v_original_string_copy = REPLACE(original_string,'%','xxxmdbug$_');" 
"  CALL xxxmdbug.insert_into_tokens(NULL,NULL,v_original_string_copy,1);" 
"  UPDATE xxxmdbug.tokens SET value = REPLACE(value,'xxxmdbug$_','%');" 
"  UPDATE xxxmdbug.tokens SET value = TRIM(BOTH '`' FROM value);" 
"" 
"  SET v_token_number = 1;" 
"  x: LOOP" 
"    SET v_value='';" 
"    SELECT value INTO v_value FROM xxxmdbug.tokens WHERE token_number = v_token_number;" 
"    IF v_value IS NULL OR v_value  <= '' THEN LEAVE x; END IF;"
"    SET v_dummy='';" 
"    SELECT value INTO v_dummy FROM xxxmdbug.tokens WHERE token_number = v_token_number+1;" 
"    IF v_dummy  = '.' THEN"
"      SET v_schema_identifier = v_value;" 
"      SET v_object_identifier='';" 
"      SELECT value INTO v_object_identifier FROM xxxmdbug.tokens WHERE token_number = v_token_number+2;" 
"      SET v_token_number = v_token_number + 3;" 
"    ELSE" 
"      SET v_schema_identifier = @xxxmdbug_default_schema;" 
"      SET v_object_identifier = v_value;" 
"      SET v_token_number = v_token_number + 1;" 
"      END IF;" 
"    INSERT INTO xxxmdbug.schemas_and_objects VALUES (v_schema_identifier,v_object_identifier,'ROUTINE');" 
"    SET v_value='';" 
"    SELECT value INTO v_value FROM xxxmdbug.tokens WHERE token_number = v_token_number;" 
"    IF v_value IS NULL OR v_value  <= '' THEN LEAVE x; END IF;"
"    IF v_value  = ',' THEN"
"      SET v_token_number = v_token_number + 1;" 
"      ITERATE x;" 
"      END IF;" 
"    SIGNAL SQLSTATE '05678' set message_text = 'invalid input string';" 
"    END LOOP;" 
"  DROP TEMPORARY TABLE xxxmdbug.tokens;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.setup (" 
"                        object_name_list VARCHAR(8192) CHARACTER SET utf8)" 
"BEGIN" 
"  CALL xxxmdbug.setup_internal(object_name_list,1);" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* todo: decide whether to use body or body_utf8 from mysql.proc. */" 
"/* todo: we could have an additional parameter for extra diagnostics from debug */" 
"" 
"CREATE PROCEDURE xxxmdbug.setup_internal (" 
"                        object_name_list VARCHAR(8192) CHARACTER SET utf8," 
"                        is_from_setup INT) /* 1 means do generating (we called setup), 0 means don't (we called command) */" 
"a:BEGIN" 
"  DECLARE mysql_proc_db VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE mysql_proc_name VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE mysql_proc_definer VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE mysql_proc_language enum('SQL');" 
"  DECLARE mysql_proc_param_list VARCHAR(8192) CHARACTER SET utf8;" 
"  DECLARE mysql_proc_returns VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE mysql_proc_type VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE mysql_proc_body LONGTEXT CHARACTER SET utf8;" 
"" 
"  DECLARE mysql_proc_sql_mode VARCHAR(512) CHARACTER SET utf8;" 
"  DECLARE mysql_proc_comment VARCHAR(8192) CHARACTER SET utf8;" 
"  DECLARE mysql_proc_is_deterministic VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE mysql_proc_sql_data_access VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE mysql_proc_security_type VARCHAR(66) CHARACTER SET utf8;" 
"" 
"  DECLARE v_schema_identifier_of_original VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_identifier_of_original VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_identifier_of_surrogate VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_object_name_list_copy VARCHAR(8192)  CHARACTER SET utf8;" 
"" 
"  DECLARE eof INT DEFAULT 0;" 
"  DECLARE c1 CURSOR FOR SELECT db,name,definer,language,param_list,returns,type,body," 
"                              sql_mode,comment,is_deterministic,sql_data_access,security_type" 
"                       FROM mysql.proc; /* no order-by needed */" 
"" 
"  DECLARE c2 CURSOR FOR SELECT schema_identifier_of_original, routine_identifier_of_original,routine_identifier_of_surrogate" 
"                       FROM xxxmdbug.routines; /* no order-by needed */" 
"" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1;" 
"  DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN" 
"    IF is_from_setup = 1 THEN DO RELEASE_LOCK('xxxmdbug_lock'); END IF;" 
"    RESIGNAL;" 
"    END;" 
"" 
"  IF is_from_setup = 1 THEN" 
"    IF GET_LOCK('xxxmdbug_lock',1) = 0 THEN" 
"      SIGNAL SQLSTATE '56780' SET message_text = 'get_lock() failed.';" 
"      END IF;" 
"" 
"    CALL xxxmdbug.initialize_variables(); /* todo: check if this should be outside the IF */" 
"" 
"    END IF;" 
"" 
"  SET v_object_name_list_copy = object_name_list; /* operate with copy -- we might edit it */" 
"" 
"  CALL xxxmdbug.setup_switches(v_object_name_list_copy); /* check and handle switches e.g. '-track_statements=1' */" 
"" 
"  /* Make sure object_name_list is schema_identifier.routine_identifier" 
"     or schema_identifier.% or %.%. Default is %.%." 
"     TODO: re-examine whether default schema identifier should be current database or %." 
"     TODO: re-examine whether wildcarding should be (% and _) or with *." 
"     Output is a temporary table schemas_and_objects. */" 
"  CALL xxxmdbug.multiple_name_parser(v_object_name_list_copy);" 
"" 
"  IF is_from_setup = 1 THEN" 
"    CALL xxxmdbug.privilege_checks();" 
"    CALL xxxmdbug.create_setup_log_table();" 
"    CALL xxxmdbug.get_setup_group_name(); /* returns @xxxmdbug_setup_group_name = 3-character string for new set name. */" 
"    IF @xxxmdbug_track_user_variables=1 THEN" 
"      SET @xxxmdbug_icc_core_surrogate_name=CONCAT('xxxmdbug',@xxxmdbug_setup_group_name,'P','icc_core');" 
"    ELSE" 
"      SET @xxxmdbug_icc_core_surrogate_name='icc_core';" 
"      END IF;" 
"  ELSE" 
"    SET @xxxmdbug_setup_group_name='000';" 
"    SET @xxxmdbug_icc_core_surrogate_name='icc_core';" 
"    END IF;" 
"" 
"  CALL xxxmdbug.create_routines_table();" 
"  CALL xxxmdbug.create_tokens_table(); /* ?? possibly this is unnecessary, it's done again later */" 
"  CALL xxxmdbug.create_statements_table(); /* ?? possibly this is unnecessary */" 
"  CALL xxxmdbug.create_variables_table(); /* ?? possibly this is unnecessary */" 
"  CALL xxxmdbug.create_tmp_user_variables_table();" 
"" 
"  /* For each routine in mysql.proc:" 
"     If there is a match with any one of the [schema.]name items" 
"     in the setup() parameter, insert in xxxmdbug.xxxmdbug_routines. */" 
"  OPEN c1;" 
"  SET eof = 0;" 
"  x1: LOOP" 
"    FETCH c1 INTO mysql_proc_db, mysql_proc_name, mysql_proc_definer, mysql_proc_language," 
"                 mysql_proc_param_list, mysql_proc_returns, mysql_proc_type, mysql_proc_body," 
"                 mysql_proc_sql_mode, mysql_proc_comment, mysql_proc_is_deterministic," 
"                 mysql_proc_sql_data_access, mysql_proc_security_type;" 
"    IF eof = 1 THEN LEAVE x1; END IF;" 
"    /* If the request has a % wildcard in the schema part, okay but exclude system databases. */" 
"    IF mysql_proc_db ='mysql'"
"    OR mysql_proc_db ='information_schema'"
"    OR mysql_proc_db ='performance_schema'"
"    OR mysql_proc_db ='xxxmdbug'"
"    THEN" 
"      ITERATE x1;" 
"      END IF;" 
"    IF mysql_proc_language  <> 'SQL' THEN ITERATE x1; END IF;"
"    IF mysql_proc_name   LIKE 'xxxmdbug___%' THEN ITERATE x1; END IF;"
"    /* Ignore routines whose surrogate names would be too long. Todo: put a notice in setup_log. */" 
"    IF LENGTH(mysql_proc_name)+LENGTH('xxxmdbugxxxP')>64 THEN ITERATE x1; END IF;" 
"    IF (SELECT COUNT(*)" 
"        FROM xxxmdbug.schemas_and_objects" 
"        WHERE mysql_proc_db  COLLATE utf8_general_ci LIKE s_schema_identifier"
"        AND mysql_proc_name   LIKE s_routine_identifier)=0 THEN ITERATE x1; END IF;"
"    CALL xxxmdbug.add_delimiters(mysql_proc_db);" 
"    CALL xxxmdbug.add_delimiters(mysql_proc_name);" 
"    CALL xxxmdbug.insert_into_routines(mysql_proc_db,mysql_proc_name," 
"    mysql_proc_language,mysql_proc_param_list,mysql_proc_returns,mysql_proc_type,mysql_proc_body);" 
"    END LOOP;" 
"" 
"  CLOSE c1;" 
"" 
"  /* !! Two more things to insert into routines: server_variables procedure if not done already," 
"     and user_variables procedure, in xxxmdbug schema. */" 
"" 
"  /* For each routine in xxxmdbug.routines:" 
"     generate.. */" 
"  OPEN c2;" 
"  SET eof = 0;" 
"  x2: LOOP" 
"    FETCH c2 INTO v_schema_identifier_of_original, v_routine_identifier_of_original, v_routine_identifier_of_surrogate;" 
"" 
"    IF eof = 1 THEN LEAVE x2; END IF;" 
"" 
"    SET @xxxmdbug_surrogate_routine_identifier = v_routine_identifier_of_surrogate;" 
"" 
"    /* Todo: this is just to get the fields that we already had in the first loop." 
"       We should have dumped them into xxxmdbug.routines, eh? */" 
"    SET mysql_proc_db='';" 
"    SELECT db,name,definer,language,param_list,returns,type,body," 
"                              sql_mode,comment,is_deterministic,sql_data_access,security_type" 
"    INTO mysql_proc_db, mysql_proc_name, mysql_proc_definer, mysql_proc_language," 
"                 mysql_proc_param_list, mysql_proc_returns, mysql_proc_type, mysql_proc_body," 
"                 mysql_proc_sql_mode, mysql_proc_comment, mysql_proc_is_deterministic," 
"                 mysql_proc_sql_data_access, mysql_proc_security_type" 
"    FROM mysql.proc" 
"    WHERE db  COLLATE utf8_general_ci = TRIM(BOTH '`' FROM v_schema_identifier_of_original)"
"    AND name  = TRIM(BOTH '`' FROM v_routine_identifier_of_original);"
"" 
"    CALL xxxmdbug.add_delimiters(mysql_proc_db);" 
"    CALL xxxmdbug.add_delimiters(mysql_proc_name);" 
"" 
"    /* Reset tokens+variables+statements tables for each routine." 
"       One effect is that @user_variables are only tracked in routines where they are mentioned." 
"       and we might want to change that if a non-default setup switch value is used." 
"       We do not reset if is_from_setup = 0 because for that we assume user wants to see all at once. */" 
"    IF is_from_setup = 1 THEN" 
"      CALL xxxmdbug.create_tokens_table();" 
"      CALL xxxmdbug.create_variables_table();" 
"      CALL xxxmdbug.create_statements_table();" 
"      END IF;" 
"" 
"    CALL xxxmdbug.insert_into_tokens(mysql_proc_db,mysql_proc_name,mysql_proc_param_list,0); /* \"tokenizer\" */" 
"    CALL xxxmdbug.insert_into_tokens(mysql_proc_db,mysql_proc_name,mysql_proc_body,1); /* \"tokenizer\" */" 
"    CALL xxxmdbug.insert_into_statements(mysql_proc_db, mysql_proc_name);" 
"    CALL xxxmdbug.insert_into_variables_parameters(mysql_proc_db, mysql_proc_name);" 
"    CALL xxxmdbug.insert_into_variables_declared_variables(mysql_proc_db, mysql_proc_name);" 
"    CALL xxxmdbug.insert_into_variables_user_variables();" 
"" 
"    IF is_from_setup = 1 THEN" 
"      SET @xxxmdbug_invocations_of_routines_in_any_group=0;" 
"      SET @xxxmdbug_invocations_of_routines_in_same_group=0;" 
"" 
"      CALL xxxmdbug.generate(mysql_proc_db,mysql_proc_name,mysql_proc_definer,mysql_proc_param_list," 
"                                      mysql_proc_returns,mysql_proc_type," 
"                                      mysql_proc_sql_mode, mysql_proc_comment, mysql_proc_is_deterministic," 
"                                      mysql_proc_sql_data_access, mysql_proc_security_type,mysql_proc_body);" 
"" 
"      INSERT INTO xxxmdbug.setup_log VALUES (" 
"      @xxxmdbug_setup_group_name, /* group_name */" 
"      current_user, /* user */" 
"      @xxxmdbug_debugger_version, /* version_number_of_debugger */" 
"      @xxxmdbug_timestamp, /* timestamp_when_setup_procedure_was_run */" 
"      object_name_list, /* arguments_passed_to_setup */" 
"      mysql_proc_type, /* routine_type */" 
"      mysql_proc_db, /* schema_identifier */" 
"      mysql_proc_name, /* original_routine_identifier */" 
"      @xxxmdbug_surrogate_routine_identifier, /* surrogate_routine_identifier */" 
"      'done', /* outcome */ /* todo: something informative, eh? */" 
"      @xxxmdbug_invocations_of_routines_in_same_group, /* invocations_of_routines_in_same_group */" 
"      @xxxmdbug_invocations_of_routines_in_any_group, /* invocations_of_routines_in_any_group */" 
"      NULL, /* comment_based_on_generate */" 
"      'thanks. copyright. gpl'); /* comment_based_on_readme */" 
"      END IF;" 
"" 
"    END LOOP;" 
"  CLOSE c2;" 
"" 
"" 
"  IF is_from_setup = 1 THEN" 
"" 
"    IF @xxxmdbug_track_user_variables=1 THEN" 
"      CALL xxxmdbug.generate_icc_core();" 
"      INSERT INTO xxxmdbug.setup_log VALUES (" 
"      @xxxmdbug_setup_group_name, /* group_name */" 
"      current_user, /* user */" 
"      @xxxmdbug_debugger_version, /* version_number_of_debugger */" 
"      @xxxmdbug_timestamp, /* timestamp_when_setup_procedure_was_run */" 
"      object_name_list, /* arguments_passed_to_setup */" 
"      mysql_proc_type, /* routine_type */" 
"      'xxxmdbug', /* schema_identifier */" 
"      'icc_core', /* original_routine_identifier */" 
"      @xxxmdbug_surrogate_routine_identifier, /* surrogate_routine_identifier */" 
"      'done', /* outcome */ /* todo: something informative, eh? */" 
"      @xxxmdbug_invocations_of_routines_in_same_group, /* invocations_of_routines_in_same_group */" 
"      @xxxmdbug_invocations_of_routines_in_any_group, /* invocations_of_routines_in_any_group */" 
"      NULL, /* comment_based_on_generate */" 
"      'thanks. copyright. gpl'); /* comment_based_on_readme */" 
"      END IF;" 
"" 
"    CALL xxxmdbug.generate_icc_process_user_command_r_server_variables();" 
"" 
"    CALL xxxmdbug.generate_icc_process_user_command_set_server_variables();" 
"" 
"    CALL xxxmdbug.view_and_trigger_and_event_check();" 
"    CALL xxxmdbug.checks_and_warnings(mysql_proc_db);" 
"" 
"" 
"" 
"    /* The writer of a high-level debugger may skip the following CALL," 
"       which inserts directly in mysql.proc, and instead execute what" 
"       is in xxxmdbug.routines.definition_of_surrogate_routine." 
"       See the comment preceding mysql_proc_insert. */" 
//"    CALL xxxmdbug.mysql_proc_insert_caller();"
"" 
"    /* TODO: drop temporary table xxxmdbug.variables */" 
"    /* TODO: drop temporary table xxxmdbug.routines */" 
"    /* TODO: drop temporary table xxxmdbug.statements */" 
"" 
"    DO RELEASE_LOCK('xxxmdbug_lock');" 
"    END IF;" 
"" 
"  /* This is a piece of nonsense to clear leftover warnings, we do not really care aout the count. */" 
"  SELECT COUNT(*) INTO eof FROM mysql.proc;" 
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* The 'track' switches exist so that one can reduce the amount of instrumenting," 
"   for space or speed reasons." 
"   @xxxmdbug_track_statements:            0=none, 1=base set, 2=+iterate/leave/set. default: 2." 
"   @xxxmdbug_track_user_variables:        0=none, 1=in same routine, 2=all (todo: allow 2). default=1." 
"   @xxxmdbug_track_declared_variables     0=none, 1=since last declare, 2=all. default: 2." 
"   Future switch: overwrite */" 
"CREATE PROCEDURE xxxmdbug.setup_switches (INOUT object_name_list VARCHAR(8192) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_token_value_1,v_token_value_2,v_token_value_3,v_token_value_4 VARCHAR(16384) CHARACTER SET utf8;" 
"  DECLARE v_token_offset_4 INT;" 
"  SET @xxxmdbug_track_statements=2;          /* default */" 
"  SET @xxxmdbug_track_user_variables=1;      /* default */" 
"  SET @xxxmdbug_track_declared_variables=2;  /* default */" 
"" 
"  x: LOOP" 
"    CALL xxxmdbug.create_tokens_table();       /* make a temporary tokens table from the setup argument */" 
"    CALL xxxmdbug.insert_into_tokens(NULL,NULL,object_name_list,1);" 
"    SELECT value INTO v_token_value_1 FROM xxxmdbug.tokens WHERE token_number = 1; /* get first four tokens */" 
"    SELECT value INTO v_token_value_2 FROM xxxmdbug.tokens WHERE token_number = 2;" 
"    SELECT value INTO v_token_value_3 FROM xxxmdbug.tokens WHERE token_number = 3;" 
"    SELECT value INTO v_token_value_4 FROM xxxmdbug.tokens WHERE token_number = 4;" 
"    SELECT offsetx INTO v_token_offset_4 FROM xxxmdbug.tokens WHERE token_number = 4;" 
"    IF v_token_value_1  <> '-' THEN LEAVE x; END IF; /* if next is not '-', there are no more switches */"
"    IF v_token_value_2  = 'track_statements' AND v_token_value_3  = '=' AND v_token_value_4 IN (0,1,2) THEN"
"      SET @xxxmdbug_track_statements=v_token_value_4; /* change from default */" 
"      SET object_name_list = RIGHT(object_name_list,LENGTH(object_name_list) -" 
"                                   (v_token_offset_4 + LENGTH(v_token_value_4) - 1)); /* remove switch from input string */" 
"      ITERATE x;" 
"      END IF;" 
"    IF v_token_value_2  = 'track_user_variables' AND v_token_value_3  = '=' AND v_token_value_4  IN (0,1) THEN"
"      SET @xxxmdbug_track_user_variables=v_token_value_4; /* change from default */" 
"      SET object_name_list = RIGHT(object_name_list,LENGTH(object_name_list) -" 
"                                   (v_token_offset_4 + LENGTH(v_token_value_4) - 1)); /* remove switch from input string */" 
"      ITERATE x;" 
"      END IF;" 
"    IF v_token_value_2  = 'track_declared_variables' AND v_token_value_3  = '=' AND v_token_value_4 IN (0,1,2) THEN"
"      SET @xxxmdbug_track_declared_variables=v_token_value_4; /* change from default */" 
"      SET object_name_list = RIGHT(object_name_list,LENGTH(object_name_list) -" 
"                                   (v_token_offset_4 + LENGTH(v_token_value_4) - 1)); /* remove switch from input string */" 
"      ITERATE x;" 
"      END IF;" 
"    SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno,message_text='invalid switch';" 
"    END LOOP;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* setup() and command() call initialize_variables(), which contains the line" 
"   IF @xxxmdbug_default_schema IS NULL THEN SET @xxxmdbug_default_schema='test'; END IF;" 
"   so the default schema name is ordinarily 'test'. But one can change it permanently" 
"   to 'X' by saying CALL xxxmdbug.set_default_schema('X'). */" 
"CREATE PROCEDURE xxxmdbug.set_default_schema (default_schema VARCHAR(66) CHARACTER SET utf8)" 
"BEGIN" 
"  SET @xxxmdbug_default_schema=default_schema;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Initialize some variables. Called from setup(), command(), and become_debuggee_connection()." 
"   Start with some error checks." 
"   Any names that start with @xxxmdbug are reserved." 
"   Some of the variables set in this procedure are \"constants\". */" 
"/* For debugger purposes, the pipe prefix forms are:" 
"   'xxxmdbug_' + @xxxmdbug_prefix_endxxx e.g. 'B '" 
"   The 'R ' messages are status sendings which the debugger may or may not choose to receive (the debuggee may overwrite them)." 
"   The @xxxmdbug_prefix_end_for_rxxx messages are responses to specific questions which the debugger is expecting." 
"*/" 
"" 
"CREATE PROCEDURE xxxmdbug.initialize_variables ()" 
"BEGIN" 
"" 
"  /* constants */" 
"  SET @xxxmdbug_sleep_time = 0.1; /* arbitrary wait time = 1/10 second */" 
"  SET @xxxmdbug_lf = 0x0a; /* constant: Line Feed. add carriage return if desired */" 
"  SET @xxxmdbug_debugger_name = 'THE MDBUG CORE DEBUGGER';" 
"  SET @xxxmdbug_debugger_version = '0.3'; /* Must be format 'n.n'. */" 
"  SET @xxxmdbug_value_length = 80; /* All ..._value fields for fixed_... routines have this length */" 
"  SET @xxxmdbug_signal_errno = 5678; /* All debugger-generated SIGNAL statements use this value for mysql_errno. */" 
"  SET @xxxmdbug_max_executed_statements_rows = 100; /* Do not let the statements_executed table grow indefinitely. */" 
"  /* @xxxmdbug_default_schema is the assumed database for commands that use [schema.]identifier syntax */" 
"  IF @xxxmdbug_default_schema IS NULL THEN SET @xxxmdbug_default_schema='test'; END IF;" 
"  SET @xxxmdbug_timeout_for_r_commands=1000; /* commands like 'r breakpoints' should give up after 1000 seconds */" 
"" 
"  SET @xxxmdbug_prefix_end_for_r_call_stack = 'A '; /* for dbms_send|receive, response to 'r call_stack' */" 
"  SET @xxxmdbug_prefix_end_for_r_breakpoints = 'B '; /* for dbms_send|receive, response to 'r breakpoints' */" 
"  SET @xxxmdbug_prefix_end_for_command = 'C '; /* for dbms_send|receive, debugger command */" 
"  SET @xxxmdbug_prefix_end_for_r_prepared_statements = 'P '; /* for dbms_send|receive, response to 'r prepared_statements' */" 
"  SET @xxxmdbug_prefix_end_for_statement_status = 'R '; /* for dbms_send|receive, send_statement_status() */" 
"  SET @xxxmdbug_prefix_end_for_r_server_variables = 'S '; /* for dbms_send|receive, response to 'r server_variables' */" 
"  SET @xxxmdbug_prefix_end_for_r_user_variables = 'U '; /* for dbms_send|receive, response to 'r user_variables' */" 
"  SET @xxxmdbug_prefix_end_for_r_variables = 'V '; /* for dbms_send|receive, response to 'r variables' */" 
"  SET @xxxmdbug_prefix_end_for_r_statements_executed = 'X '; /* for dbms_send|receive, response to 'r statements_executed' */" 
"" 
"  /* globals */" 
"  SET @xxxmdbug_routine = ''; /* procedure or function currently being debugged */" 
"  SET @xxxmdbug_message = ''; /* last message received */" 
"  SET @xxxmdbug_call_stack='';" 
"  SET @xxxmdbug_timestamp = current_timestamp;" 
"  SET @xxxmdbug_status_line_number = '';" 
"  /* SET @xxxmdbug_status_last_command = ''; removed, this is now done in reset() */" 
"  /* SET @xxxmdbug_status_last_command_result = ''; removed, this is now done in reset() */" 
"  SET @xxxmdbug_status_breakpoint_check_result = 0;" 
"  SET @xxxmdbug_warning_count=0;" 
"  SET @xxxmdbug_last_was_debug=0;" 
"  IF @xxxmdbug_number_of_last_status_message IS NULL THEN SET @xxxmdbug_number_of_last_status_message=0; END IF;" 
"  IF @xxxmdbug_icc_count IS NULL THEN SET @xxxmdbug_icc_count=0; END IF;" 
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* called from install_check, setup, become_debuggee_connection, and command." 
"   more tests:" 
"    (version)" 
"    (privileges) super. test by sending a message to self." 
"    (privileges) execute on xxxmdbug routines" 
"    up to date?" 
"    setup done?" 
"    warn if packet size small?" 
"    warn if timeout e.g. @@innodb_lock_wait_timeout small?" 
"    todo: check max_heap_size */" 
"CREATE PROCEDURE xxxmdbug.privilege_checks ()" 
"BEGIN" 
"  DECLARE v_prefix VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_test_message VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_dummy INT;" 
"  DECLARE v_error_message VARCHAR(128) CHARACTER SET utf8;" 
"  DECLARE v_major_version,v_minor_version,v_position_of_dot INT;" 
"  DECLARE EXIT HANDLER FOR 1227 BEGIN" 
"    SET v_error_message = CONCAT('The installer user ',CURRENT_USER,' cannot change init_connect. Probably lacks SUPER privilege.');" 
"    SIGNAL SQLSTATE '05678' SET mysql_errno = @xxxmdbug_signal_errno, message_text = v_error_message;" 
"    END;" 
"  /* For both MariaDB and MySQL, the major version must be > 5, or the major version must be = 5 and the minor version >= 5. */" 
"  SET v_position_of_dot=INSTR(VERSION(),'.');" 
"  IF v_position_of_dot=0 THEN SET v_position_of_dot=LENGTH(VERSION()+1); END IF;" 
"  SET v_major_version=LEFT(VERSION(),v_position_of_dot);" 
"  SET v_minor_version=SUBSTRING(VERSION() FROM v_position_of_dot+1 FOR 1);" 
"  IF v_major_version<5 OR (v_major_version=5 AND v_minor_version<5) THEN" 
"    SIGNAL SQLSTATE '56780' SET mysql_errno=@xxxmdbug_signal_errno, message_text = 'DBMS Version must be 5.5 or later';" 
"    END IF;" 
"  IF @xxxmdbug_value_length - 3 < 66 THEN" 
"    SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno,message_text='@xxxmdbug_value_length is too small';" 
"    END IF;" 
//"  SET GLOBAL init_connect = @@init_connect; /* this should cause 1227 if installer lacks SUPER privilege */"
//""
//"  SET v_prefix = CONCAT('!test!',connection_id());"
//"  CALL xxxmdbug.dbms_pipe_send(v_prefix,'test message');"
//"  CALL xxxmdbug.dbms_pipe_receive(v_prefix,1,v_test_message,v_dummy);"
//"  IF v_test_message <> 'test message' THEN SIGNAL SQLSTATE '05678' SET mysql_errno=@xxxmdbug_signal_errno, message_text = 'send+receive failure'; END IF;"
"  BEGIN" 
"    DECLARE v_is_install_script_done INT DEFAULT 0;" 
"    BEGIN" 
"      DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END;" 
"      SET v_is_install_script_done = (SELECT is_install_script_done FROM xxxmdbug.readme);" 
"      END;" 
"    IF v_is_install_script_done = 0 THEN" 
"      SIGNAL SQLSTATE '56780' SET mysql_errno = @xxxmdbug_signal_errno, message_text = 'install script not complete';" 
"      END IF;" 
"    END;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Fixed lists" 
"   For breakpoints, variables, and routines. By debuggee." 
"   Debuggee does not use temporary tables because I ran into a" 
"   frustrating problem with ERROR 1137 (HY000): Can't reopen table: 'variables' etc." 
"   when debugging a function. And using non-temporary tables" 
"   would lead to much greater complexity, plus locking." 
"   Finally, any use of tables can change the warning/error list." 
"   So we maintain a large number of fixed lists, one list per column" 
"   in the table we are trying to emulate. For example, because the" 
"   breakpoints table has an is_temporary column, there is a list" 
"   @xxxmdbug_breakpoints_is_temporary, and its entry size is always 5," 
"   and the first three bytes are size (999 means null), and then there is" 
"   a fixed-length value padded with spaces on the right." 
"   There are routines to clear all, delete, update, insert, and select. */" 
"/* todo: figure out a way to clear this */" 
"CREATE PROCEDURE xxxmdbug.fixed_variables_clear () /* \"delete\" from variables */" 
"BEGIN" 
"  SET @xxxmdbug_variables_schema_identifier=''; /* schema_identifier VARCHAR(66) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_variables_routine_identifier='';  /* routine_identifier VARCHAR(66) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_variables_routine_type='';  /* routine_type VARCHAR(10) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_variables_token_number_of_declare=''; /* token_number_of_declare INT */" 
"  SET @xxxmdbug_variables_variable_identifier=''; /* variable_identifier VARCHAR(66) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_variables_data_type=''; /* data_type VARCHAR(66) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_variables_value=''; /* value VARCHAR(66) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_variables_old_value=''; /* old_value VARCHAR(66) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_variables_is_in_scope=''; /* is_in_scope INT */" 
"  SET @xxxmdbug_variables_is_settable=''; /* is_settable INT */" 
"  SET @xxxmdbug_variables_is_updated_by_set=''; /* is_updated_by_set INT */" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"CREATE PROCEDURE xxxmdbug.fixed_breakpoints_clear () /* \"delete\" from breakpoints */" 
"BEGIN  " 
"  SET @xxxmdbug_breakpoints_breakpoint_identifier=''; /* breakpoint_identifier INT primary key auto_increment */" 
"  SET @xxxmdbug_breakpoints_schema_identifier=''; /*  schema_identifier VARCHAR(66) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_breakpoints_routine_identifier=''; /* routine_identifier VARCHAR(66) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_breakpoints_routine_type=''; /* routine_type VARCHAR(10) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_breakpoints_line_number_minimum=''; /* line_number_minimum INT */" 
"  SET @xxxmdbug_breakpoints_line_number_maximum=''; /* line_number_maximum INT */" 
"  SET @xxxmdbug_breakpoints_condition_identifier=''; /* condition_identifier VARCHAR(66) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_breakpoints_condition_operator=''; /* condition_operator VARCHAR(2) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_breakpoints_condition_value=''; /* condition_value VARCHAR(66) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_breakpoints_hit_count=''; /* hit_count INT */" 
"  SET @xxxmdbug_breakpoints_is_temporary=''; /* is_temporary INT */" 
"  SET @xxxmdbug_breakpoints_is_temporary_and_to_be_cleared=''; /* is_temporary_and_to_be_cleared INT */" 
"  SET @xxxmdbug_breakpoints_is_matching_location=''; /* is_matching_location INT */" 
"  SET @xxxmdbug_breakpoints_is_matching_condition=''; /* is_matching_condition INT */" 
"  SET @xxxmdbug_breakpoints_call_stack_depth_when_set=''; /* call_stack_depth_when_set INT */" 
"  SET @xxxmdbug_breakpoints_command=''; /* command VARCHAR(14) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_breakpoints_last_insert_id=0; /* value for breakpoint_identifier */" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"CREATE PROCEDURE xxxmdbug.fixed_routines_clear () /* \"delete\" from routines */" 
"BEGIN  " 
"  SET @xxxmdbug_routines_schema_identifier_of_original=''; /* schema_identifier_of_original VARCHAR(66) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_routines_routine_identifier_of_original=''; /* routine_identifier_of_original VARCHAR(66) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_routines_routine_type_of_original=''; /* routine_type_of_original VARCHAR(10) CHARACTER SET utf8 */" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"CREATE PROCEDURE xxxmdbug.fixed_statements_executed_clear () /* \"delete\" from routines */" 
"BEGIN" 
"  SET @xxxmdbug_statements_executed_schema_identifier=''; /* schema_identifier VARCHAR(66) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_statements_executed_routine_identifier=''; /* routine_identifier VARCHAR(66) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_statements_executed_routine_type=''; /* routine_type VARCHAR(10) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_statements_executed_number=''; /* number INT */" 
"  SET @xxxmdbug_statements_executed_caught_by_no_handler=''; /* caught_by_no_handler INT */" 
"  SET @xxxmdbug_statements_executed_caught_by_sqlwarning_handler=''; /* caught_by_sqlwarning_handler INT */" 
"  SET @xxxmdbug_statements_executed_caught_by_sqlexception_handler=''; /* caught_by_sqlexception_handler INT */" 
"  SET @xxxmdbug_statements_executed_caught_by_not_found_handler=''; /* caught_by_not_found_handler INT */" 
"  SET @xxxmdbug_statements_executed_caught_by_user_written_handler=''; /* caught_by_user_written_handler INT */" 
"  SET @xxxmdbug_statements_executed_row_count=''; /* row_count INT */" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"CREATE PROCEDURE xxxmdbug.fixed_prepared_statements_clear () /* \"delete\" from routines */" 
"BEGIN  " 
"  SET @xxxmdbug_prepared_statements_statement_name=''; /* statement_name VARCHAR(66) CHARACTER SET utf8 */" 
"  SET @xxxmdbug_prepared_statements_statement_text=''; /* statement_text VARCHAR(66) CHARACTER SET utf8 */" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.fixed_delete (" 
"                 INOUT p_list TEXT,p_entry_length INT,p_n INT)" 
"BEGIN" 
"  SET p_list=CONCAT(LEFT(p_list,(p_entry_length*p_n))," 
"                    RIGHT(p_list,LENGTH(p_list)-p_entry_length*(p_n+1)));" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"CREATE PROCEDURE xxxmdbug.fixed_update (" 
"                 INOUT p_list TEXT,p_entry_length INT,p_n INT,new_value VARBINARY(998))" 
"BEGIN" 
"  DECLARE v_length VARCHAR(3) CHARACTER SET utf8;" 
"  IF new_value IS NULL THEN" 
"    SET p_list=CONCAT(LEFT(p_list,(p_entry_length*p_n))," 
"                      '999',RPAD('0',p_entry_length-3,' ')," 
"                      RIGHT(p_list,LENGTH(p_list)-p_entry_length*(p_n+1)));" 
"  ELSE" 
"    SET v_length=LENGTH(new_value);" 
"    SET p_list=CONCAT(LEFT(p_list,(p_entry_length*p_n))," 
"                      RPAD(v_length,3,' '),RPAD(new_value,p_entry_length-3,' ')," 
"                      RIGHT(p_list,LENGTH(p_list)-p_entry_length*(p_n+1)));" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"CREATE PROCEDURE xxxmdbug.fixed_insert (" 
"                 INOUT p_list TEXT,p_entry_length INT,new_value VARBINARY(998))" 
"BEGIN" 
"  DECLARE v_length VARCHAR(3) CHARACTER SET utf8;" 
"  IF new_value IS NULL THEN" 
"    SET p_list=CONCAT(p_list,'999',RPAD('0',p_entry_length-3,' '));" 
"  ELSE" 
"    SET v_length=LENGTH(new_value);" 
"    SET p_list=CONCAT(p_list,RPAD(v_length,3,' '),RPAD(new_value,p_entry_length-3,' '));" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"CREATE PROCEDURE xxxmdbug.fixed_select (" 
"                 p_list TEXT,p_entry_length INT,p_n INT,OUT new_value VARBINARY(998)," 
"                 OUT flags INT) /* flags=-1 else length. todo: -2 for null */" 
"BEGIN" 
"  DECLARE v_length INT;" 
"  IF LENGTH(p_list)<=p_entry_length*p_n THEN" 
"    SET new_value='0'; /* todo: actually it would be better to check for eof without trying to select */" 
"    SET flags=-1;" 
"  ELSE" 
"    SET v_length=SUBSTRING(p_list FROM (p_entry_length*p_n)+1 for 3);" 
"    IF v_length=999 THEN" 
"      SET new_value=NULL;" 
"      SET flags=-2;" 
"    ELSE" 
"      SET new_value=SUBSTRING(p_list FROM (p_entry_length*p_n)+4 for v_length);" 
"      SET flags=v_length;" 
"      END IF;" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.breakpoint_delete (v_n INT)" 
"BEGIN" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_breakpoint_identifier,10,v_n);" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_schema_identifier,80,v_n);" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_routine_identifier,80,v_n);" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_routine_type,16,v_n);" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_line_number_minimum,10,v_n);" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_line_number_maximum,10,v_n);" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_condition_identifier,80,v_n);" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_condition_operator,10,v_n);" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_condition_value,@xxxmdbug_value_length,v_n);" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_hit_count,10,v_n);" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_is_temporary,5,v_n);" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_is_temporary_and_to_be_cleared,5,v_n);" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_is_matching_location,5,v_n);" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_is_matching_condition,5,v_n);" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_call_stack_depth_when_set,10,v_n);" 
"  CALL xxxmdbug.fixed_delete(@xxxmdbug_breakpoints_command,20,v_n);" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE TABLE xxxmdbug.readme (" 
"  name VARCHAR(66) CHARACTER SET utf8," 
"  authors VARCHAR(66) CHARACTER SET utf8," 
"  version_of_debugger VARCHAR(66) CHARACTER SET utf8," 
"  date_of_last_revision_of_debugger DATE," 
"  copyright VARCHAR(66) CHARACTER SET utf8," 
"  release_notes VARCHAR(66) CHARACTER SET utf8," 
"  link_to_documentation VARCHAR(66) CHARACTER SET utf8," 
"  is_install_script_done INT)");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CALL xxxmdbug.initialize_variables()  /* So @@xxxmdbug_debugger_version and @xxxmdbug_debugger_name will be correct */");
if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* todo: this is obsolete. Now there is a copyright table. */" 
"" 
"INSERT INTO xxxmdbug.readme VALUES (" 
"  @xxxmdbug_debugger_name, /* name, e.g. 'THE MDBUG CORE DEBUGGER' */" 
"  'Peter Gulutzan', /* authors */" 
"  @xxxmdbug_debugger_version, /* version_of_debugger */" 
"  '2012-09-11'," 
"  'All routines are copyrighted. See COPYRIGHTS table.'," 
"  'Release notes = No behaviour changes since previous version.'," 
"  'Documentation exists in file debuggercore_manual.txt.'," 
"  1)");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"/* Strip ``s when:" 
"  todo: insert into routines (schema_identifier_of_original,routine_identifier_of_original)" 
"  insert into variables (variable_identifier)" 
"  breakpoints (condition name)" 
"... check what happens with `s inside ``s" 
"... watch out for name_parser" 
"  todo: Watch out for @`user_variable` which is the same as @user_variable" 
"  This will apply for \"\"s too -- a real parser would have to take ansi_quotes into account," 
"  but we know we are looking at an identifier. */" 
"CREATE PROCEDURE xxxmdbug.add_delimiters (INOUT identifier VARCHAR(66) CHARACTER SET utf8)" 
"BEGIN" 
"  IF identifier <>''                  /* skip if nothing here (could happen with condition_identifier) */"
"  AND LEFT(identifier,1) <>'@'        /* skip if user variable */"
"  AND LEFT(identifier,1) <>'`' THEN   /* skip if noalready delimited */"
"    IF LEFT(identifier,1) ='\"' AND RIGHT(identifier,1) ='\"' THEN SET identifier=TRIM(BOTH '\"' FROM identifier); END IF;"
"    SET identifier=CONCAT('`',identifier,'`');" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
/* The following two routines -- mysql_proc_insert() and mysql_proc_insert_caller() -- are called for generate.
   They take each row in xxxmdbug.routines and INSERT an appropriate row in mysql.proc.
   That's bad! One should not fool with tables in the mysql database! And the trick will not work for triggers!
   However, I hope these excuses are convincing:
     * We don't UPDATE or DELETE, we only INSERT. So the stored-procedure cache will not be totally wrecked. I hope.
     * There just is no way to do a bunch of CREATE PROCEDURE statements with only the mysqld server and mysql client.
       The server can't prepare such statements. The mysql client can't execute statements from a table.
       (I originally was dumping the statements with SELECT ... INTO OUTFILE <file> FROM xxxmdbug.routines
       and executing them with SOURCE <file>, but that only works when client and server are on the same machine.)
   The better solution is to have a client that can execute strings that come from xxxmdbug_routines,
   but until that happens, we are stuck with this. */
/* For the record: this is how I used to do it, and it still probably works.
   CALL setup('test . p',null,null,null)//
   SET @xxxmdbug_saved_sql_mode=@@sql_mode//
   system rm /home/pgulutzan/data1/maria-5.5/XR.sql
   SELECT CONCAT(definition_of_surrogate_routine,'//')
   INTO OUTFILE '/home/pgulutzan/data1/maria-5.5/XR.sql'
   FROM xxxmdbug.routines//
   source /home/pgulutzan/data1/maria-5.5/XR.sql//
   set @@sql_mode=''//
   set session sql_mode=@xxxmdbug_saved_sql_mode// */
/* todo: change 'created' and 'modified' columns */

strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.mysql_proc_insert (p_db char(66) CHARACTER SET utf8," 
"                                             p_name char(66) CHARACTER SET utf8," 
"                                             p_new_name char(66) CHARACTER SET utf8," 
"                                             p_new_body LONGTEXT CHARACTER SET utf8)                  " 
"BEGIN" 
"  DECLARE v_db char(66) CHARACTER SET utf8 COLLATE utf8_bin;" 
"  DECLARE v_name char(66) CHARACTER SET utf8;" 
"  DECLARE v_type enum('FUNCTION','PROCEDURE');" 
"  DECLARE v_specific_name char(66) CHARACTER SET utf8;" 
"  DECLARE v_language enum('SQL');" 
"  DECLARE v_sql_data_access enum('CONTAINS_SQL','NO_SQL','READS_SQL_DATA','MODIFIES_SQL_DATA');" 
"  DECLARE v_is_deterministic enum('YES','NO');" 
"  DECLARE v_security_type enum('INVOKER','DEFINER');" 
"  DECLARE v_param_list blob;" 
"  DECLARE v_returns longblob;" 
"  DECLARE v_body longblob;" 
"  DECLARE v_definer char(77) CHARACTER SET utf8 COLLATE utf8_bin;" 
"  DECLARE v_created timestamp;" 
"  DECLARE v_modified timestamp;" 
"  DECLARE v_sql_mode set('REAL_AS_FLOAT','PIPES_AS_CONCAT','ANSI_QUOTES','IGNORE_SPACE','IGNORE_BAD_TABLE_OPTIONS','ONLY_FULL_GROUP_BY','NO_UNSIGNED_SUBTRACTION','NO_DIR_IN_CREATE','POSTGRESQL','ORACLE','MSSQL','DB2','MAXDB','NO_KEY_OPTIONS','NO_TABLE_OPTIONS','NO_FIELD_OPTIONS','MYSQL323','MYSQL40','ANSI','NO_AUTO_VALUE_ON_ZERO','NO_BACKSLASH_ESCAPES','STRICT_TRANS_TABLES','STRICT_ALL_TABLES','NO_ZERO_IN_DATE','NO_ZERO_DATE','INVALID_DATES','ERROR_FOR_DIVISION_BY_ZERO','TRADITIONAL','NO_AUTO_CREATE_USER','HIGH_NOT_PRECEDENCE','NO_ENGINE_SUBSTITUTION','PAD_CHAR_TO_FULL_LENGTH');   " 
"  DECLARE v_comment text CHARACTER SET utf8 COLLATE utf8_bin;" 
"  DECLARE v_character_set_client char(32) CHARACTER SET utf8 COLLATE utf8_bin;" 
"  DECLARE v_collation_connection char(32) CHARACTER SET utf8 COLLATE utf8_bin;" 
"  DECLARE v_db_collation char(32) CHARACTER SET utf8 COLLATE utf8_bin;" 
"  DECLARE v_body_utf8 LONGTEXT CHARACTER SET utf8;" 
"" 
"SELECT "
"db,"
"name," 
"type, " 
"specific_name," 
"language," 
"sql_data_access," 
"is_deterministic," 
"security_type," 
"param_list," 
"returns," 
"body," 
"definer," 
"created," 
"modified," 
"sql_mode," 
"comment," 
"character_set_client,                       " 
"collation_connection,              " 
"db_collation," 
"body_utf8 "
"INTO "
"v_db,"
"v_name," 
"v_type, " 
"v_specific_name," 
"v_language," 
"v_sql_data_access," 
"v_is_deterministic," 
"v_security_type," 
"v_param_list," 
"v_returns," 
"v_body," 
"v_definer," 
"v_created," 
"v_modified," 
"v_sql_mode," 
"v_comment," 
"v_character_set_client,                       " 
"v_collation_connection,              " 
"v_db_collation," 
"v_body_utf8 "
"FROM mysql.proc "
"WHERE db=p_db AND name=p_name "
"LIMIT 1; "
"" 
"SET v_name=p_new_name;" 
"SET v_body=p_new_body;" 
"SET v_body_utf8=p_new_body;" 
"" 
"INSERT INTO mysql.proc" 
"(" 
"db,                                             " 
"name," 
"type, " 
"specific_name," 
"language," 
"sql_data_access," 
"is_deterministic," 
"security_type," 
"param_list," 
"returns," 
"body," 
"definer," 
"created," 
"modified," 
"sql_mode," 
"comment," 
"character_set_client,                       " 
"collation_connection,              " 
"db_collation," 
"body_utf8" 
")" 
" VALUES (" 
"v_db," 
"v_name," 
"v_type," 
"v_specific_name," 
"v_language," 
"v_sql_data_access," 
"v_is_deterministic," 
"v_security_type," 
"v_param_list," 
"v_returns," 
"v_body," 
"v_definer," 
"v_created," 
"v_modified," 
"v_sql_mode," 
"v_comment," 
"v_character_set_client," 
"v_collation_connection," 
"v_db_collation," 
"v_body_utf8);" 
"" 
"  end");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.mysql_proc_insert_caller ()" 
"BEGIN" 
"  DECLARE v_schema_identifier_of_original VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_identifier_of_original VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_routine_identifier_of_surrogate VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE v_definition_of_surrogate_routine LONGTEXT CHARACTER SET utf8;" 
"  DECLARE v_offset_of_begin INT;" 
"  DECLARE eof INT DEFAULT 0;" 
"" 
"  DECLARE c CURSOR FOR" 
"  SELECT TRIM(BOTH '`' FROM schema_identifier_of_original)," 
"         TRIM(BOTH '`' FROM routine_identifier_of_original)," 
"         TRIM(BOTH '`' FROM routine_identifier_of_surrogate)," 
"         definition_of_surrogate_routine," 
"         offset_of_begin" 
"  FROM xxxmdbug.routines;" 
"  DECLARE CONTINUE HANDLER FOR NOT FOUND SET eof = 1;" 
"" 
"  OPEN c;" 
"  x: LOOP" 
"    FETCH c " 
"    INTO v_schema_identifier_of_original," 
"         v_routine_identifier_of_original," 
"         v_routine_identifier_of_surrogate," 
"         v_definition_of_surrogate_routine," 
"         v_offset_of_begin;" 
"    IF eof = 1 THEN LEAVE x; END IF;" 
"" 
"    IF v_routine_identifier_of_surrogate  = 'icc_process_user_command_r_server_variables'"
"    OR v_routine_identifier_of_surrogate  = 'icc_process_user_command_set_server_variables' THEN"
"      /* We will not insert icc_process_user_command_r_server_variables" 
"         or icc_process_user_command_set_server_variables into mysql.proc" 
"         if it already exists. This is okay as long as there is no change of" 
"         DBMS server version or engine or plugin. But recommend always:" 
"         DROP PROCEDURE xxxmdbug.icc_process_user_command_r_server_variables; */" 
"      IF (SELECT COUNT(*)" 
"          FROM mysql.proc" 
"          WHERE db = 'xxxmdbug' AND name = v_routine_identifier_of_surrogate" 
"          LIMIT 1) = 1 THEN" 
"        ITERATE x;" 
"        END IF;" 
"      END IF;" 
"" 
"    SET v_definition_of_surrogate_routine=RIGHT(v_definition_of_surrogate_routine,(LENGTH(v_definition_of_surrogate_routine)-v_offset_of_begin)+1);" 
"    CALL xxxmdbug.mysql_proc_insert(" 
"    v_schema_identifier_of_original," 
"    v_routine_identifier_of_original," 
"    v_routine_identifier_of_surrogate," 
"    v_definition_of_surrogate_routine);" 
"    END LOOP;" 
"  CLOSE c;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;

strcpy(x,
"" 
"/* PREPARE depends on sql_mode value at time of CREATE PROCEDURE." 
"   So we have two PREPARE procedures, one for sql_mode=ansi_quotes, one for sql_mode<>ansi_quotes." 
"   We perhaps should also care about ignore_space, no_backslash_escapes, and pipes_as_concat. */" 
"SET @xxxmdbug_saved_sql_mode_before_prepare=@@sql_mode");
if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;

strcpy(x,
"SET sql_mode='ansi_quotes'");
if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;

strcpy(x,
"CREATE PROCEDURE xxxmdbug.prepare_while_ansi_quotes_yes () PREPARE xxxmdbug_stmt FROM @xxxmdbug_test_setting;");
if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;

strcpy(x,
"SET sql_mode=''");
if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;

strcpy(x,
"CREATE PROCEDURE xxxmdbug.prepare_while_ansi_quotes_no () PREPARE xxxmdbug_stmt FROM @xxxmdbug_test_setting;");
if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;

strcpy(x,
"CREATE PROCEDURE xxxmdbug.preparer (sql_mode VARCHAR(512) CHARACTER SET utf8)" 
"BEGIN" 
"  IF sql_mode   LIKE '%ansi_quotes%' THEN CALL xxxmdbug.prepare_while_ansi_quotes_yes();"
"  ELSE CALL xxxmdbug.prepare_while_ansi_quotes_no();" 
"  END IF;" 
"  END");
if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;

strcpy(x,
"SET sql_mode=@xxxmdbug_saved_sql_mode_before_prepare");
if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;

strcpy(x,
"" 
"/*" 
"2012-07-04" 
"Hi Sushil," 
"" 
"On the telephone on Tuesday John said he wanted an SQL routine which, with input = SQL statement, outputs SQL statement where routine names" 
"are replaced by surrogate routine names. Okay. The routine looks like this:" 
"CREATE PROCEDURE xxxmdbug.statement_change (INOUT v_g LONGTEXT CHARACTER SET utf8, * output *" 
"                                           sql_mode VARCHAR(132) CHARACTER SET utf8, * always \"@@sql_mode\" *" 
"                                           mysql_proc_db VARCHAR(66) CHARACTER SET utf8, * always \"DATABASE()\" *" 
"                                           mysql_proc_body LONGTEXT CHARACTER SET utf8, * input *" 
"                                           p_group_name VARCHAR(3) CHARACTER SET utf8) * e.g. '000' *" 
"Parameter 1: this is the output, so there has to be a valid target here, usually a user variable" 
"Parameter 2: this never changes, just say @@sql_mode every time" 
"Parameter 3: this never changes, just say DATABASE() every time (it tells the procedure what the default database is)" 
"Parameter 4: this  is the input, it must be an SQL statement" 
"Parameter 5: this is the group name, the surrogate routine(s) must be in this group." 
"For example, supposing that the user input is 'SELECT k()', and there's a surrogate for [current_schema.]k in group '005':" 
"CALL xxxmdbug.statement_change(@output," 
"                               @@sql_mode," 
"                               DATABASE()," 
"                               'SELECT k()'," 
"                               '005');" 
"Afterwards @output will contain SELECT `xxxmdbug005Fk`()." 
"If there is a problem, such as bad syntax, the result will be error 5678." 
"" 
"The changed install.sql is in launchpad now." 
"" 
"Peter Gulutzan" 
"" 
"*/" 
"" 
"CREATE PROCEDURE xxxmdbug.statement_change (INOUT v_g LONGTEXT CHARACTER SET utf8, /* output */" 
"                                           sql_mode VARCHAR(512) CHARACTER SET utf8, /* always \"@@sql_mode\" */" 
"                                           mysql_proc_db VARCHAR(66) CHARACTER SET utf8, /* always \"DATABASE()\" */" 
"                                           mysql_proc_body LONGTEXT CHARACTER SET utf8, /* input */" 
"                                           p_group_name VARCHAR(3) CHARACTER SET utf8) /* e.g. '000' */" 
"BEGIN" 
"  DECLARE v_token_number_of_last_token INT;" 
"  DECLARE v_first_token VARCHAR(66) CHARACTER SET utf8;" 
"  DECLARE x INT;" 
"  SET v_g = '';" 
"  BEGIN" 
"    /* 1064 is \"You have an error in your SQL syntax ...\" */" 
"    DECLARE EXIT HANDLER FOR 1064 SET x=1;"
"    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END;" 
"    SET x=0;"
"    SET @xxxmdbug_test_setting = mysql_proc_body;" 
"    CALL xxxmdbug.preparer(sql_mode);/* PREPARE xxxmdbug_stmt FROM @xxxmdbug_test_setting; */  /* Ensure that the statement is valid SQL. */" 
"    END;" 
"  IF x=1 THEN SIGNAL SQLSTATE '05678' SET mysql_errno=5678, message_text = 'Not a valid SQL statement.'; END IF;" 
"  CALL xxxmdbug.initialize_variables();" 
"  CALL xxxmdbug.privilege_checks();" 
"" 
"  CALL xxxmdbug.create_tokens_table();" 
"  CALL xxxmdbug.insert_into_tokens('','',mysql_proc_body,0);" 
"" 
"  SET v_first_token = (SELECT value FROM xxxmdbug.tokens WHERE token_number = 1);" 
"  IF v_first_token   IN ('CALL','CASE','CREATE','DECLARE','DELETE','DO','ELSEIF','IF','INSERT',"
"                       'REPLACE','RETURN','SELECT','SET','UNTIL','UPDATE','WHILE') THEN" 
"    SET v_token_number_of_last_token=(SELECT COUNT(*) FROM xxxmdbug.tokens);" 
"    CALL xxxmdbug.create_routines_table();" 
"    INSERT INTO xxxmdbug.routines (schema_identifier_of_original, routine_identifier_of_original,routine_identifier_of_surrogate)" 
"    SELECT schema_identifier, original_routine_identifier, surrogate_routine_identifier" 
"    FROM xxxmdbug.setup_log" 
"    WHERE group_name=p_group_name;" 
"    CALL xxxmdbug.generate_statement_text(v_g,1,v_token_number_of_last_token,mysql_proc_db,mysql_proc_body,sql_mode);" 
"    IF LEFT(v_g,1)=@xxxmdbug_lf THEN SET v_g=RIGHT(v_g,LENGTH(v_g)-1); END IF;" 
"  ELSE" 
"    SET v_g=mysql_proc_body; /* if statement isn't something that can contain a routine reference, output = input */" 
"    END IF;" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;

/* The walkthrough() procedure is an example and a tool.
   It sends 'debug', then it goes into a loop
   sending 'information status' and 'step' until the routine ends.
   The display is routine + line-number + first-declared-variable
   afer each step. To see how it works, get the debuggee going
   with "call become_debuggee_connection('xxx') and "call debuggee_wait_loop()"
   and then do this on the debugger connection:

delimiter //
drop function test.f//
drop procedure test.p//
create function test.f () returns int deterministic
begin
  set @x=7;
  return @x;
  end//
create procedure test.p ()
begin
  declare x int default 0;
  set x=x+5;
  do f();
  end//
call xxxmdbug.setup('test.p,test.f')//
call xxxmdbug.walkthrough('debug test.p')//

*/

strcpy(x,
"" 
"CREATE PROCEDURE xxxmdbug.walkthrough (arg VARCHAR(8192) CHARACTER SET utf8)" 
"BEGIN" 
"  DECLARE v_line_number INT;" 
"  DECLARE v_icc_count,v_previous_icc_count INT DEFAULT -1;" 
"  DECLARE v_is_at_breakpoint VARCHAR(3) CHARACTER SET utf8 DEFAULT 'NO';" 
"  DECLARE v_is_at_routine_exit VARCHAR(3) CHARACTER SET utf8;" 
"  DECLARE v_routine_identifier VARCHAR(64) CHARACTER SET utf8;" 
"  DECLARE v_number_of_status_message,v_previous_number_of_status_message INT DEFAULT -1;" 
"  DECLARE v_last_command VARCHAR(64) CHARACTER SET utf8;" 
"  DECLARE v_last_command_result VARCHAR(64) CHARACTER SET utf8;" 
"  DECLARE v_commands_count INT;" 
"  DECLARE v_variable_identifier VARCHAR(64) CHARACTER SET utf8;" 
"  DECLARE v_variable_value VARCHAR(64) CHARACTER SET utf8;" 
"" 
"  CALL xxxmdbug.command('XXX','l');" 
"  CALL xxxmdbug.command('XXX','a');" 
"  CALL xxxmdbug.command('XXX',arg);" 
"" 
"  /* Loop until you get a response to the 'debug' command */" 
"  z: LOOP" 
"    DO sleep(0.1);" 
"    CALL xxxmdbug.command('XXX','i status');         " 
"    SELECT routine_identifier, line_number,is_at_routine_exit,number_of_status_message,icc_count,is_at_breakpoint,last_command,last_command_result,commands_count" 
"    INTO v_routine_identifier, v_line_number,v_is_at_routine_exit,v_number_of_status_message,v_icc_count,v_is_at_breakpoint,v_last_command,v_last_command_result,v_commands_count" 
"    FROM xxxmdbug.information_status;" 
"    IF v_number_of_status_message <> v_previous_number_of_status_message AND v_last_command='debug' THEN LEAVE z; END IF;" 
"    SELECT 'waiting for response from debuggee';" 
"    END LOOP;" 
"" 
"  IF v_last_command_result  <> 'OK' THEN"
"    SELECT 'debug failed',v_last_command_result;" 
"    SIGNAL SQLSTATE '99999';" 
"    END IF;" 
"" 
"  SET v_is_at_breakpoint='NO';" 
"" 
"  x: LOOP" 
"" 
"    IF v_is_at_breakpoint ='YES' AND v_icc_count<>v_previous_icc_count THEN"
"      CALL xxxmdbug.command('XXX','step');" 
"      SET v_previous_icc_count=v_icc_count;" 
"      END IF;" 
"    y: LOOP" 
"      DO sleep(0.1);" 
"      CALL xxxmdbug.command('XXX','i status');         " 
"      SELECT routine_identifier, line_number,is_at_routine_exit,number_of_status_message,icc_count,is_at_breakpoint,last_command_result,commands_count" 
"      INTO v_routine_identifier, v_line_number,v_is_at_routine_exit,v_number_of_status_message,v_icc_count,v_is_at_breakpoint,v_last_command_result,v_commands_count" 
"      FROM xxxmdbug.information_status;" 
"      IF v_number_of_status_message <> v_previous_number_of_status_message THEN LEAVE y; END IF;" 
"      SELECT 'waiting for response from debuggee';" 
"      END LOOP;" 
"    SET v_previous_number_of_status_message=v_number_of_status_message;" 
"" 
"    IF v_is_at_routine_exit  = 'yes' THEN select 'exit'; LEAVE x; END IF; /* fails to check stack_depth */"
"    IF v_last_command_result   LIKE '%Failed%' THEN select 'fail'; LEAVE x; END IF;"
"    IF v_last_command_result='\"ignored, the expected command is debug\"' THEN select 'end'; LEAVE x; END IF;" 
"    IF v_line_number=999999 THEN SELECT '999999'; LEAVE x; END IF;" 
"" 
"    IF v_icc_count=v_previous_icc_count THEN ITERATE x; END IF;" 
"    IF v_line_number>0 THEN" 
"      CALL xxxmdbug.command('XXX','refresh variables');" 
"      SELECT variable_identifier,value INTO v_variable_identifier,v_variable_value FROM xxxmdbug.variables WHERE is_in_scope=1 LIMIT 1;" 
"      END IF;" 
"    SELECT v_routine_identifier AS routine_identifier," 
"           v_line_number AS line_number," 
"           v_variable_identifier AS variable_identifier," 
"           v_variable_value AS variable_value;" 
"    END LOOP;" 
"" 
"  END");

if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;

/* Todo: restore this, we'd like to have some sort of check, but for now SELECT within a procedure is a no-no. */

//strcpy(x,
//""
//"SET SESSION sql_mode=@xxxmdbug_saved_sql_mode");
//
//if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
//strcpy(x,
//""
//"CREATE PROCEDURE xxxmdbug.install_check ()"
//"BEGIN"
//"  CALL xxxmdbug.privilege_checks();"
//"  SELECT COUNT(*) AS procedure_count"
//"  FROM information_schema.routines"
//"  WHERE routine_schema = 'xxxmdbug'"
//"  AND created BETWEEN @xxxmdbug_start_timestamp AND CURRENT_TIMESTAMP;"
//"  END");

//if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
//strcpy(x,
//"CALL xxxmdbug.install_check()");

//if (lmysql->ldbms_mysql_real_query(mysql, x, strlen(x))) return -1;
  return 0;
}
/* End of debug_mdbug_install_sql(). End of effect of licence of install_sql function contents. */
#endif


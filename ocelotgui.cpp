/*
  ocelotgui -- GUI Front End for MySQL or MariaDB

   Version: 1.9.0
   Last modified: March 14 2023
*/
/*
  Copyright (c) 2023 by Peter Gulutzan. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
*/

/*
   The class named CodeEditor inside the ocelotgui program is taken and modified from
   http://qt-project.org/doc/qt-4.8/widgets-codeeditor.html
   and therefore CodeEditor's maker's copyright and BSD license provisions
   are reproduced below. These provisions apply only for the
   part of the CodeEditor class which is included by #include "codeeditor.h".
   The program as a whole is copyrighted by Peter Gulutzan and
   licensed under GPL version 2 as stated above.
 **
 ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
 ** Contact: http://www.qt-project.org/legal
 **
 ** $QT_BEGIN_LICENSE:BSD$
 **
 ** "Redistribution and use in source and binary forms, with or without
 ** modification, are permitted provided that the following conditions are
 ** met:
 **   * Redistributions of source code must retain the above copyright
 **     notice, this list of conditions and the following disclaimer.
 **   * Redistributions in binary form must reproduce the above copyright
 **     notice, this list of conditions and the following disclaimer in
 **     the documentation and/or other materials provided with the
 **     distribution.
 **   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names
 **     of its contributors may be used to endorse or promote products derived
 **     from this software without specific prior written permission.
 **
 **
 ** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 ** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 ** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 ** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 ** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 ** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 ** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
 **
 ** $QT_END_LICENSE$
*/

#if (OCELOT_MYSQL_DEBUGGER == 1)
/*
  The routine named debug_mdbug_install inside this program is taken and modified from
  https://launchpad.net/mdbug, specifically http://bazaar.launchpad.net/~hp-mdbug-team/mdbug/trunk/view/head:/install.sql,
  and therefore MDBug's maker's copyright and GPL version 2 license provisions
  are reproduced below. These provisions apply only for the
  part of the debug_mdbug_install routine which is marked within the program.
  The program as a whole is copyrighted by Peter Gulutzan and
  licensed under GPL version 2 as stated above.

  This file is part of MDBug.

  (c) Copyright 2012 Hewlett-Packard Development Company, L.P.

  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; version 2 of the License.

  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

  You should have received a copy of the GNU General Public License along with this program; if not, see
  <http://www.gnu.org/licenses>.

  Linking MDBug statically or dynamically with other modules is making a combined work based on MDBug. Thus, the terms and
  conditions of the GNU General Public License cover the whole combination.

  In addition, as a special exception, the copyright holders of MDBug give you permission to combine MDBug with free
  software programs or libraries that are released under the GNU LGPL and with code included in the standard release
  of Eclipse under the Eclipse Public License version 1.0 (or modified versions of such code, with unchanged license).
  You may copy and distribute such a system following the terms of the GNU GPL for MDBug and the licenses of the other
  code concerned, provided that you include the source code of that other code when and as the GNU GPL requires
  distribution of source code.

  Note that people who make modified versions of MDBug are not obligated to grant this special exception for their
  modified versions; it is their choice whether to do so. The GNU General Public License gives permission to release a
  modified version without this exception; this exception also makes it possible to release a modified version which
  carries forward this exception.
*/
#endif

/*
  On Windows, ocelotgui is statically linked with libraries
  MariaDB Connector C and Qt. See COPYING.thirdparty.
*/

/*
  General comments

  These are comments about the code.
  The user manual and blog comments are elsewhere; look at README.htm or README.md or manual.htm
  or README.txt or ocelot.ca or ocelot.ca/blog or the repository that
  this program was downloaded from, probably github.com/ocelot-inc/ocelotgui.

  The code files are:
    ocelotgui.pro       small. used by Qt qmake
    ocelotgui.h         headers but also quite a lot of executable
    ocelotgui.cpp       executable
    install_sql.cpp     for creating debugger routines
    ocelotgui.ui        small. used to make ui_ocelotgui.h
    codeeditor.h        small. separated so license applicability is clear
    hparse.h            the recognizer
    ostrings.h          strings that contain English translatable text

  There are three main widgets, which generally appear top-to-bottom on
  the screen: history_edit_widget = an uncomplicated text edit which gets
  retired statements and diagnostic messages; statement_edit_widget =
  a class derived from text edit ("CodeEditor") which has code for a
  prompt on the left and for syntax highlighting; result_grid_table_widget =
  a class derived from widget ("ResultGrid") which has code for tabular
  display of a result set and manipulation thereof. The result grid is
  not based on Qt's high-level tools like QTableView, it is constructed
  from basic building blocks (scroll bars and repeatedly-occurring
  QTextEdits within QFrames). There is no use of Qt's "MySQL driver".
  The code includes a tokenizer and recognizer for MySQL syntax.
  The coding style is generally according to MySQL coding guidelines
  http://dev.mysql.com/doc/internals/en/coding-guidelines.html
  but lines may be long, and sometimes spaces occur at ends of lines,
  and "if (x) y" may be preferred to "if (x) <newline> y".

  The code was written by Peter Gulutzan, except
  for about 50 lines in the codeeditor.h CodeEditor section (Digia copyright / BSD license),
  and except for most of the lines in install_sql.cpp (HP copyright / GPL license).
  Other contributors will be acknowledged here and/or in a "Help" display.

  The code #includes header files from MySQL/Oracle and from Qt/Digia,
  and may rely on MySQL or MariaDB libraries if it connects to MySQL or MariaDB servers,
  and relies on the Qt core, gui, and widgets libraries.
  Builds have been successful with several Linux distros and gcc 4.6/4.7/7.3.
  Build instructions are in the user manual or in a readme file.

  There are many comments. Searching for the word "Todo:" in the comments
  will give some idea of what's especially weak and what's planned.

  UTF8 Conversion
  Everything which will be passed to MySQL will first be converted to UTF8.
  Todo: Ensure that sending/receiving character set is UTF8, regardless of data language.
        Currently we do say ocelot_set_charset_name= "utf8"; which is passed to mysql_options()
        but the user can explicitly override that.
  Todo: When receiving, only convert characters, not binary or numeric.
  Todo: Handle Qt codecs for other character sets.
  Todo: Figure out how to handle a literal preceded by an _introducer.
  A typical set of instructions will look like this and have the comment
  "See comment "UTF8 Conversion".
     int tmp_len= QStr.toUtf8().size());                  ... See how big UTF8 will be
     char *tmp= new char[tmp_len + 1];                      ... Allocate that amount
     memcpy(tmp, QStr.toUtf8().constData()), tmp_len + 1);  ... Copy including trail '\0' byte
     ... And later, say "delete []tmp" or hope for garbage collection

  Todo: when I started, I wasn't aware that I could say
        QString::fromUtf8 to copy a C string to a QString.
        So there are several places where I copy to another temporary
        C string and then assign. Such code should be replaced.

  Todo: Allow right-click for changing individual widgets.

  See end of program for comments re valgrind.

  The usual ways to build are described in README.htm (copied to README.md or README.txt).
  An unusual way would be with Qt 4.8 source-code libraries supplied by Digia:
      Download 4.8 libraries via http://qt-project.org/downloads
         This is a source download; you'll need to do ./configure and make.
         Follow instructions in http://qt-project.org/doc/qt-4.8/install-x11.html
         After make and make install you'll have /usr/local/Trolltech/Qt-4.8.6
         At this point I got totally stuck with Qt Creator -- it refused to try to build with Qt 4.8.
         And yes, I changed the kit, I changed the paths, but it was all a waste of a lot of time.
         Well, if anyone else succeeds, let me know.
         But I "succeeded" by exiting Qt Creator, creating a new make file, and building from the shell.
         (I copy and then remove ui_ocelotgui.h, which may or may not have some importance that I missed.)
         cd ~/ocelotgui
         mv ui_ocelotgui.h ui_ocelotgui.h.bak
         /usr/local/Trolltech/Qt-4.8.6/bin/qmake ocelotgui.pro
         make
        ./ocelotgui
        That ruins what Qt Creator expects when I get back to Qt Creator, so I get back to 5.1 with:
        cd ~/ocelotgui
        /home/pgulutzan/Qt/5.1.1/gcc_64/bin/qmake ./ocelotgui.pro
        mv ui_ocelotgui.h ui_ocelotgui.h.bak
        rm ui_ocelotgui.h
        make (ignore failure)
        re-enter Qt Creator. Build | Clean all. Build all. Run.
*/

#define MYSQL_MAIN_CONNECTION 0
#define MYSQL_DEBUGGER_CONNECTION 1
#define MYSQL_KILL_CONNECTION 2
#define MYSQL_REMOTE_CONNECTION 3
#define MYSQL_MAX_CONNECTIONS 4

#include "ostrings.h"
#include "ocelotgui.h"
#include "ui_ocelotgui.h"

/* Whenever you see STRING_LENGTH_512, think: here's a fixed arbitrary allocation, which should be be fixed up. */
#define STRING_LENGTH_512 512

/* MAX_HPARSE_ERRMSG_LENGTH should be enough for all keywords that begin with "OCELOT_" */
#define MAX_HPARSE_ERRMSG_LENGTH 4320

/* Connect arguments and options */
  static char* ocelot_host_as_utf8= 0;                  /* --host=s */
  static char* ocelot_database_as_utf8= 0;              /* --database=s */
  static char* ocelot_user_as_utf8= 0;                  /* --user=s */
  static char* ocelot_password_as_utf8= 0;              /* --password[=s] */
  static unsigned short ocelot_port= MYSQL_PORT;        /* --port=n */
  static char* ocelot_unix_socket_as_utf8= 0;           /* --socket=s */
  static unsigned int ocelot_protocol_as_int= 0;        /* --protocol=s for MYSQL_OPT_PROTOCOL */
  static char* ocelot_init_command_as_utf8= 0;          /* --init_command=s for MYSQL_INIT_COMMAND */
  /* Connect arguments below this point are minor and many are unsupported. */
  static unsigned short ocelot_abort_source_on_error= 0;   /* --abort_source_on_error (MariaDB) */
  static unsigned short ocelot_auto_rehash= 1;             /* --auto_rehash */
  static unsigned short ocelot_auto_vertical_output= 0;    /* --auto_vertical_output */
  static unsigned short ocelot_batch= 0;                   /* --batch */
  static unsigned short ocelot_binary_mode= 0;             /* --binary_mode */
  /* QString ocelot_bind_address */                        /* --bind_address=s */
  static char* ocelot_set_charset_dir_as_utf8= 0;         /* --character_sets_dir=s for MYSQL_SET_CHARSET_DIR */
  static unsigned short ocelot_result_grid_column_names= 1;/* --column_names */
  static unsigned short ocelot_column_type_info= 0;        /* --column_type_info */
  static unsigned short ocelot_comments= 0;               /* --comments */
  static unsigned short ocelot_opt_compress= 0;           /* --compress for MYSQL_OPT_COMPRESS */
  static unsigned long int ocelot_opt_connect_timeout= 0;  /* --connect_timeout = n for MYSQL_OPT_CONNECT_TIMEOUT */
  /* QString ocelot_debug */                               /* --debug[=s] */
  static unsigned short ocelot_debug_check= 0;             /* --debug_check */
  static unsigned short ocelot_debug_info= 0;              /* --debug_info */
  static char* ocelot_default_auth_as_utf8= 0;      /* --default_auth=s for MYSQL_DEFAULT_AUTH */
  static char* ocelot_set_charset_name_as_utf8= 0;  /* --default_character_set=s for MYSQL_SET_CHARSET_NAME */
  /* exists as QString */                    /* --defaults_extra_file=s */
  /* exists as QString */                    /* --defaults_file=s */
  /* exists as QString */                    /* --defaults_group_suffix=s */
  /* exists as QString */                    /* --delimiter=s */
  static unsigned short ocelot_enable_cleartext_plugin= 0;  /* --enable_cleartext_plugin for MYSQL_ENABLE_CLEARTEXT_PLUGIN */
  /* QString ocelot_execute */               /* --execute=s */
  static unsigned short ocelot_force= 0;     /* --force */
  static unsigned short ocelot_help= 0;      /* --help */
  static bool ocelot_history_hist_file_is_open= false;
  static bool ocelot_history_hist_file_is_copied= false;
  /* exists as QString */                    /* --histfile=s */
  /* exists as QString */                    /* --histignore=s */
  static unsigned short ocelot_html= 0;      /* --html */
  static unsigned short ocelot_ignore_spaces= 0;  /* --ignore_spaces */
  /* QString ocelot_ld_run_path */                /* --ld_run_path=s */
  static unsigned short ocelot_line_numbers= 0;   /* --line_numbers */
  static unsigned short ocelot_opt_local_infile= 0;    /* --local_infile[=n]  for MYSQL_OPT_LOCAL_INFILE */
  /* QString ocelot_login_path */            /* --login_path=s */
  static unsigned short int ocelot_log_level= 100;          /* --ocelot_log_level */
  static unsigned short int ocelot_max_conditions= 5;
  static unsigned long int ocelot_max_allowed_packet= 16777216; /* --max_allowed_packet=n */
  static unsigned long int ocelot_max_join_size= 1000000; /* --max_join_size = n */
  static unsigned short ocelot_named_commands= 0;         /* --named_commands */
  static unsigned long int ocelot_net_buffer_length= 16384; /* --net_buffer_length=n */
  static unsigned short ocelot_no_beep= 0;                /* --no_beep */
  static unsigned short ocelot_no_defaults= 0;            /* --no_defaults */
  /* QString ocelot_dbms */
  static unsigned short ocelot_one_database= 0;           /* --one-database */
  /* QString ocelot_pager */                              /* --pager[=s] */
  static unsigned short ocelot_pipe= 0;                   /* --pipe */
  static char* ocelot_plugin_dir_as_utf8= 0;        /* --plugin_dir=s for MYSQL_PLUGIN_DIR */
  static unsigned short ocelot_print_defaults= 0;   /* --print_defaults */
  /* QString ocelot_prompt */                       /* --prompt=s */
  static bool ocelot_prompt_is_default= true;
  static unsigned short ocelot_quick= 0;            /* --quick */
  static unsigned short ocelot_raw= 0;              /* --raw */
  static unsigned int ocelot_opt_reconnect= 0;      /* --reconnect for MYSQL_OPT_RECONNECT */                                           /* --reconnect */
  static unsigned short ocelot_safe_updates= 0;           /* --safe-updates or --i-am-a-dummy */
  static unsigned short ocelot_secure_auth= 1;             /* --secure_auth for MYSQL_SECURE_AUTH (default=true if version >= 5.6.5) */
  static unsigned long int ocelot_select_limit= 0;  /* --select_limit = n */
  static char* ocelot_server_public_key_as_utf8= 0; /* --server_public_key=s for MYSQL_SERVER_PUBLIC_KEY */
  static char* ocelot_shared_memory_base_name_as_utf8= 0; /* --shared_memory_base_name=s for MYSQL_SHARED_MEMORY_BASE_NAME */
  static unsigned short ocelot_history_includes_warnings= 0; /* --show_warnings include warning(s) returned from statement? default = no. */
  static unsigned short ocelot_sigint_ignore= 0;          /* --sigint_ignore */
  static unsigned short ocelot_silent= 0;                 /* --silent */
  static char* ocelot_opt_ssl_as_utf8= 0;           /* --ssl for CONNECT */
  static char* ocelot_opt_ssl_ca_as_utf8= 0;        /* --ssl-ca for MYSQL_OPT_SSL_CA */
  static char* ocelot_opt_ssl_capath_as_utf8= 0;    /* --ssl-capath for MYSQL_OPT_SSL_CAPATH. */
  static char* ocelot_opt_ssl_cert_as_utf8= 0;      /* --ssl-cert for MYSQL_OPT_SSL_CERT */
  static char* ocelot_opt_ssl_cipher_as_utf8= 0;    /* --ssl-cipher for MYSQL_OPT_SSL_CIPHER */
  static char* ocelot_opt_ssl_crl_as_utf8= 0;       /*  --ssl-crl for MYSQL_OPT_SSL_CRL */
  static char* ocelot_opt_ssl_crlpath_as_utf8= 0;   /* --ssl-crlpath for MYSQL_OPT_SSL_CRLPATH */
  static char* ocelot_opt_ssl_key_as_utf8= 0;       /* --ssl-key for MYSQL_OPT_SSL_KEY */
  static char* ocelot_opt_ssl_mode_as_utf8= 0;      /* --ssl-mode for MYSQL_OPT_SSL_MODE */
  static unsigned short int ocelot_opt_ssl_verify_server_cert= 0;  /* --ssl-verify-server-cert for MYSQL_OPT_SSL_VERIFY_SERVER_CERT. --ssl-verify-server-cert (5.7) */
  static unsigned short ocelot_syslog= 0;           /* --syslog (5.7) */
  static unsigned short ocelot_table= 0;            /* --table */
  static bool ocelot_history_tee_file_is_open= false;            /* --tee for tee  ... arg=history_tee_file_name*/
  static unsigned short ocelot_unbuffered= 0;       /* --unbuffered */
  static unsigned short ocelot_verbose= 0;          /* --verbose */
  static unsigned short ocelot_version= 0;          /* --version */
  static unsigned short ocelot_vertical= 0;               /* --vertical */
  static unsigned short ocelot_wait= 0;                   /* --wait ... actually this does nothing */
  static unsigned short ocelot_xml= 0;                    /* --xml */

  /*
    For MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS + --connect-expired-password.
    mysql client has this off by default, but ocelotgui has it on by default
    so to turn it off say ocelotgui --skip_connect_expired_password
  */
  static unsigned short ocelot_opt_can_handle_expired_passwords= 1;

  /* Some items we allow, which are not available in mysql client */
  static char* ocelot_opt_bind_as_utf8= 0;              /* for MYSQL_OPT_BIND */
  static char* ocelot_opt_connect_attr_delete_as_utf8= 0;  /* for MYSQL_OPT_CONNECT_ATTR_DELETE */
  static unsigned short int ocelot_opt_connect_attr_reset= 0; /* for MYSQL_OPT_CONNECT_ATTR_RESET */
  static char* ocelot_read_default_file_as_utf8= 0; /* for MYSQL_READ_DEFAULT_FILE */
  static char* ocelot_read_default_group_as_utf8= 0;/* for MYSQL_READ_DEFAULT_GROUP */
  static unsigned int ocelot_opt_read_timeout= 0;          /* for MYSQL_OPT_READ_TIMEOUT */
  static unsigned short int ocelot_report_data_truncation= 0; /* for MYSQL_REPORT_DATA_TRUNCATION */
  static unsigned short int ocelot_opt_use_result= 0; /* for MYSQL_OPT_USE_RESULT */
  /* It's easy to increase ocelot_grid_tabs so more multi results are seen but don't make it ridiculous. */
  static unsigned short int ocelot_grid_tabs= 16;
  static unsigned short int ocelot_grid_actual_tabs= 0; /* Todo: move this, it's not an option. */
  static unsigned short int ocelot_client_side_functions= 1;
  static unsigned short int ocelot_completer_timeout= 10;
  static char ocelot_shortcut_connect[80]= "default";
  static char ocelot_shortcut_exit[80]= "default";
  static char ocelot_shortcut_undo[80]= "default";
  static char ocelot_shortcut_redo[80]= "default";
  static char ocelot_shortcut_cut[80]= "default";
  static char ocelot_shortcut_copy[80]= "default";
  static char ocelot_shortcut_paste[80]= "default";
  static char ocelot_shortcut_select_all[80]= "default";
  static char ocelot_shortcut_history_markup_previous[80]= "default";
  static char ocelot_shortcut_history_markup_next[80]= "default";
  static char ocelot_shortcut_format[80]= "default";
  static char ocelot_shortcut_zoomin[80]= "default";
  static char ocelot_shortcut_zoomout[80]= "default";
  static char ocelot_shortcut_autocomplete[80]= "default";
  static char ocelot_shortcut_find[80]= "default";
  static char ocelot_shortcut_execute[80]= "default";
  static char ocelot_shortcut_kill[80]= "default";
  static char ocelot_shortcut_next_window[80]= "default";
  static char ocelot_shortcut_previous_window[80]= "default";
#if (OCELOT_MYSQL_DEBUGGER == 1)
  static char ocelot_shortcut_breakpoint[80]= "default";
  static char ocelot_shortcut_continue[80]= "default";
  static char ocelot_shortcut_next[80]= "default";
  static char ocelot_shortcut_step[80]= "default";
  static char ocelot_shortcut_clear[80]= "default";
  static char ocelot_shortcut_debug_exit[80]= "default";
  static char ocelot_shortcut_information[80]= "default";
  static char ocelot_shortcut_refresh_server_variables[80]= "default";
  static char ocelot_shortcut_refresh_user_variables[80]= "default";
  static char ocelot_shortcut_refresh_variables[80]= "default";
  static char ocelot_shortcut_refresh_call_stack[80]= "default";
#endif
  static char ocelot_shortcut_batch[80]= "default";
  static char ocelot_shortcut_horizontal[80]= "default";
  static char ocelot_shortcut_html[80]= "default";
  static char ocelot_shortcut_htmlraw[80]= "default";
  static char ocelot_shortcut_raw[80]= "default";
  static char ocelot_shortcut_vertical[80]= "default";
  static char ocelot_shortcut_xml[80]= "default";

  /* Some items we allow, but the reasons we allow them are lost in the mists of time */
  /* I gather that one is supposed to read the charset file. I don't think we do. */
  static unsigned short ocelot_opt_named_pipe;          /* for MYSQL_OPT_NAMED_PIPE */
  static unsigned int ocelot_opt_write_timeout= 0; /* for MYSQL_OPT_WRITE_TIMEOUT */

  static bool ocelot_detach_history_widget= false;
  static bool ocelot_detach_result_grid_widget= false;
#if (OCELOT_MYSQL_DEBUGGER == 1)
  static bool ocelot_detach_debug_widget= false;
#endif
  static bool ocelot_detach_statement_edit_widget= false;
#if (OCELOT_EXPLORER == 1)
  static bool ocelot_detach_explorer_widget= false;
#endif

  static int is_libmysqlclient_loaded= 0;
#if (OCELOT_MYSQL_INCLUDE == 1)
  static int is_libcrypto_loaded= 0;
  static void *libmysqlclient_handle= NULL;
  static void *libcrypto_handle= NULL;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
  static int is_libtarantool_loaded= 0;
  //static int is_libtarantoolnet_loaded= 0;
  static void *libtarantool_handle= 0;
  //static void *libtarantoolnet_handle= 0;
  /* Todo: these shouldn't be global */
  //static tnt_reply *tarantool_tnt_for_new_result_set;
  static bool tarantool_start_transaction_seen= false;
  static char tarantool_box_execute[16]= "box.execute"; /* can be changed to "box.sql.execute" */
#endif

  static  unsigned int rehash_result_column_count= 0; /* Todo: check: why isn't this long unsigned int? */
  static unsigned int rehash_result_row_count= 0;
  static char *rehash_result_set_copy= 0;       /* gets a copy of mysql_res contents, if necessary */
  static char **rehash_result_set_copy_rows= 0; /* dynamic-sized list of result_set_copy row offsets, if necessary */

  int options_and_connect(unsigned int connection_number, char *database_as_utf8);

  /* This should correspond to the version number in the comment at the start of this program. */
  static const char ocelotgui_version[]="1.9.0"; /* For --version. Make sure it's in manual too. */
  unsigned int dbms_version_mask= FLAG_VERSION_DEFAULT;

/* Global mysql definitions */
#if (OCELOT_MYSQL_INCLUDE == 1)
  static MYSQL mysql[MYSQL_MAX_CONNECTIONS];
  static int connected[MYSQL_MAX_CONNECTIONS]= {0, 0, 0, 0};
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  pthread_t debug_thread_id;
  bool debug_thread_exists= false;
  static int connections_is_connected[MYSQL_MAX_CONNECTIONS];  /* == 1 if is connected */
  static int connections_dbms[MYSQL_MAX_CONNECTIONS];          /* == DBMS_MYSQL or other DBMS_... value */
#ifdef DBMS_TARANTOOL
/* Global Tarantool definitions */
  static struct tnt_stream *tnt[MYSQL_MAX_CONNECTIONS];
  static int tarantool_errno[MYSQL_MAX_CONNECTIONS];
  static char tarantool_errmsg[MAX_HPARSE_ERRMSG_LENGTH];
  QString tarantool_server_name= "";
  static long unsigned int tarantool_row_count[MYSQL_MAX_CONNECTIONS];
#endif

  static ldbms *lmysql= 0;
#if (OCELOT_MYSQL_INCLUDE == 1)
  static bool is_mysql_library_init_done= false;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  unsigned int mysql_errno_result= 0;

#if (OCELOT_IMPORT_EXPORT == 1)
  /* Accessed both in ocelotgui.h and ocelotgui.cpp */
  struct export_settings main_exports;
#endif

  static QString hparse_text_copy;
  static QString hparse_token;
  static int hparse_i;
  static QString hparse_expected;
  static int hparse_errno; /* 0=ok, 1=error, 2=error-unrecoverable */
  static int hparse_errno_count;
  static int hparse_token_type;
  static int hparse_statement_type= -1;
  static bool sql_mode_ansi_quotes= false;
  /* hparse_f_accept can dump many expected tokens in hparse_errmsg */
  static char hparse_errmsg[MAX_HPARSE_ERRMSG_LENGTH];
  static QString hparse_next_token, hparse_next_next_token;
  static int hparse_next_token_type, hparse_next_next_token_type;
  static QString hparse_next_next_next_token, hparse_next_next_next_next_token;
  static int hparse_next_next_next_token_type, hparse_next_next_next_next_token_type;
  static int hparse_begin_count;
  static bool hparse_as_seen;
  static bool hparse_create_trigger_seen;
  static int hparse_count_of_accepts;
  static int hparse_i_of_statement;
  static int hparse_i_of_last_accepted;
  static QString hparse_prev_token;
  static bool hparse_like_seen;
  static bool hparse_subquery_is_allowed;
  static bool hparse_variable_is_allowed;
  static bool hparse_variable_must_be_int;
  static QString hparse_delimiter_str;
  static bool hparse_sql_mode_ansi_quotes= false;
  static unsigned int hparse_dbms_mask= FLAG_VERSION_DEFAULT;
  static bool hparse_is_in_subquery= false;
  static QString hparse_specified_schema;
  static QStringList hparse_specified_list;

/* Variables used by kill thread, but which might be checked by debugger */
#define KILL_STATE_CONNECT_THREAD_STARTED 0
#define KILL_STATE_CONNECT_FAILED 1
#define KILL_STATE_IS_CONNECTED 2
#define KILL_STATE_MYSQL_REAL_QUERY_ERROR 3
#define KILL_STATE_ENDED 4
int volatile kill_state;
int volatile kill_connection_id;

#define LONG_QUERY_STATE_STARTED 0
#define LONG_QUERY_STATE_ENDED 1
char *dbms_query;
int dbms_query_len;
int dbms_query_connection_number;
volatile int dbms_long_query_result;
volatile int dbms_long_query_state= LONG_QUERY_STATE_ENDED;

/*
   Suppress useless messages
   https://bugreports.qt.io/browse/QTBUG-57180  (Windows startup)
   https://github.com/MartinBriza/QGnomePlatform/issues/23 (Fedora)
   Originally we only suppressed if Windows but then it started to apper for Linux too.
   There's not much I can do except maybe replace all native dialogs (such as QFontDialog)
   with substitutes in this program. Qutie a lot of work just to suppress a useless message, eh?
   Todo: Failed to load module "canberra-gtk-module" which has something to do with sound
         https://cromwell-intl.com/open-source/missing-gtk-modules.html
         We don't need special sounds so suppressing would be okay.
         But I didn't bother because I only saw it with Linux + Qt4.
   Todo: consider also suppressing "OpenType support missing for script"
   Todo: Since version 1.5 I no longer use QFontDialog, maybe that means some of this is unnecessary.
*/
#if (QT_VERSION >= 0x50000)
void dump_qtmessage(QtMsgType type, const QMessageLogContext &context, const QString &msg)
{
  (void) context;
  if (type == QtWarningMsg)
  {
    if (msg.contains("CreateFontFaceFromHDC")) return;
    if (msg.contains("GtkDialog mapped without a transient parent")) return;
  }
  QByteArray localMsg = msg.toLocal8Bit();
  if (type == QtFatalMsg) abort();
}
#endif

int main(int argc, char *argv[])
{
#if (QT_VERSION >= 0x50000)
  qInstallMessageHandler(dump_qtmessage);
#endif

  QApplication main_application(argc, argv);
  MainWindow w(argc, argv);
  /* We depend on w being maximized in resizeEvent() */
  w.showMaximized();
  return main_application.exec();
}


MainWindow::MainWindow(int argc, char *argv[], QWidget *parent) :
  QMainWindow(parent),
  ui(new Ui::MainWindow)
{
  log("MainWindow start", 90); /* Ordinarily this is less than ocelot_log_level so won't appear */
  initial_asserts();  /* Check that some defined | constant values are okay. */
  /* Initialization */

  main_window_maximum_width= 0;
  main_window_maximum_height= 0;
  main_token_max_count= 0;

  /*
    setupUi() is in ui_ocelotgui.h, which is generated by a tool named "uic",
    which is called by qmake because there is a line in ocelotgui.pro:
    FORMS    += ocelotgui.ui
    I would love to get rid of the file and just put setupUi in ocelotgui.h,
    but different versions of qmake produce different contents for ui_ocelotgui.h.
    This is the routine that attaches the menubar to MainWindow, among other things.
  */
  ui->setupUi(this);

/*
  The Menu Bar did not appear with Ubuntu 14.04.
  This might be the horrific bug
  https://bugs.launchpad.net/ubuntu/+source/appmenu-qt5/+bug/1307619
  But QT_QPA_PLATFORMTHEME= did not solve.
  So insist that the menu goes in MainWindow.
*/
#ifdef OCELOT_OS_LINUX
  ui->menuBar->setNativeMenuBar(false);
#endif
  create_menu();

  setWindowTitle("ocelotgui");

  connections_is_connected[0]= 0;
  mysql_res= 0;
  /* client variable defaults */
  /* Most settings done here might be overridden when connect_mysql_options_2 reads options. */
  /* Todo: in fact connect_mysql_options_2 says ocelot_dbms= "" so check whether setting here is useful. */
#if (OCELOT_MYSQL_INCLUDE == 1)
  ocelot_dbms= "mysql";
  connections_dbms[0]= DBMS_MYSQL;
#else
  ocelot_dbms= "tarantool";
  connections_dbms[0]= DBMS_TARANTOOL;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

  ocelot_grid_max_row_lines= 5; /* obsolete? */               /* maximum number of lines in 1 row. warn if this is exceeded? */
  ocelot_statement_prompt_background_color= s_color_list[COLOR_LIGHTGRAY*2 + 1]; /* set early because initialize_widget_statement() depends on this */
  ocelot_grid_focus_cell_background_color= s_color_list[COLOR_WHEAT*2 + 1];;
  ocelot_grid_header_background_color= s_color_list[COLOR_LIGHTGRAY*2 + 1];
  ocelot_grid_outer_color= s_color_list[COLOR_LIGHTBLUE*2 + 1];;
  ocelot_grid_cell_border_color= s_color_list[COLOR_BLACK*2 + 1];
  ocelot_grid_cell_border_size= "1";
//  ocelot_grid_cell_drag_line_size= "5";
//  ocelot_grid_cell_width= "default";
  ocelot_grid_height= ocelot_grid_left= ocelot_grid_top= ocelot_grid_width= "default";
  ocelot_grid_html_effects= "no";
  ocelot_grid_detached= "no";
  /* Probably result_grid_table_widget_saved_font only matters if the connection dialog box has to go up. */
  QFont tmp_font;
//  QFont *saved_font;
//  tmp_font= this->font();
//  saved_font=&tmp_font;
//  result_grid_table_widget= new ResultGrid(0, saved_font, this, 0);

#if (OCELOT_EXPLORER == 1)
  ocelot_explorer_height= ocelot_explorer_left= ocelot_explorer_top= ocelot_explorer_width= "default";
  ocelot_explorer_detached= "no";
  ocelot_explorer_visible= "no";
  ocelot_explorer_sort= "no";
  /* ocelot_explorer_query is set up elsewhere, I hope (e.g. in initialize_widget_explorer) */
  explorer_widget= NULL;
#endif
  result_grid_tab_widget= new QTabWidget48(this); /* 2015-08-25 added "this" */
  result_grid_tab_widget->hide();
  main_layout= new QVBoxLayout();
  history_edit_widget= new TextEditHistory(this);         /* 2015-08-25 added "this" */
  statement_edit_widget= new CodeEditor(this);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  statement_edit_widget->is_debug_widget= false;
#endif
  QFont fixed_font= get_fixed_font();
  history_edit_widget->setFont(fixed_font);
  statement_edit_widget->setFont(fixed_font);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  create_widget_debug();
#endif
  main_window= new QWidget(this);                  /* 2015-08-25 added "this" */

  completer_widget= new Completer_widget(); completer_widget->construct(this);
  c_widget= new C_widget(); c_widget->construct(this); c_widget->setFont(fixed_font); c_widget->hide();

  ocelot_grid_cell_height= "default";              /* todo: should be changeable with Settings menu item */
  ocelot_grid_cell_width= "default";               /* todo: should be changeable with Settings menu item */
  /*
    Defaults for items that can be changed with Settings menu item.
    First we get current values, after processing of any Qt options on the command line.
    Then we make arbitrary colors for details that current values probably didn't supply.
    The settings Red=string DarkGreen=Comment Green=object Blue=keyword DarkGray=operator
    have been seen elsewhere, and also pink|magenta=built-in-function so keep that in reserve.
    Then we read option files.
  */
  set_current_colors_and_font(fixed_font); /* set ocelot_statement_text_color, ocelot_grid_text_color, etc. */
  ocelot_statement_border_color= s_color_list[COLOR_BLACK*2 + 1];
  ocelot_statement_highlight_literal_color= s_color_list[COLOR_RED*2 + 1];
  ocelot_statement_highlight_identifier_color= s_color_list[COLOR_GREEN*2 + 1];
  ocelot_statement_highlight_comment_color= s_color_list[COLOR_LIMEGREEN*2 + 1];
  ocelot_statement_highlight_operator_color= s_color_list[COLOR_DARKGRAY*2 + 1];;
  ocelot_statement_highlight_keyword_color= s_color_list[COLOR_BLUE*2 + 1];
  ocelot_statement_highlight_current_line_color= s_color_list[COLOR_YELLOW*2 + 1];
  ocelot_statement_highlight_function_color= s_color_list[COLOR_FUCHSIA*2 + 1];
  ocelot_statement_syntax_checker= "1";
  ocelot_statement_format_statement_indent= "2";
  ocelot_statement_format_clause_indent= "4";
  ocelot_statement_format_rule= "keyword becomes keyword-upper;";
#if (OCELOT_IMPORT_EXPORT == 1)
  import_export_rule_set("");
#endif
  ocelot_statement_height= ocelot_statement_left= ocelot_statement_top= ocelot_statement_width= "default";
  ocelot_statement_detached= "no";
  ocelot_debug_height= ocelot_statement_height;
  ocelot_debug_left= ocelot_statement_left;
  ocelot_debug_top= ocelot_statement_top;
  ocelot_debug_width= ocelot_statement_width;
  ocelot_debug_detached= ocelot_statement_detached;

  ocelot_history_border_color= s_color_list[COLOR_BLACK*2 + 1];
  ocelot_menu_border_color= s_color_list[COLOR_BLACK*2 + 1];
  ocelot_history_height= ocelot_history_left= ocelot_history_top= ocelot_history_width= "default";
  ocelot_history_max_row_count= "0";
  ocelot_history_detached= "no";
  ocelot_histfileflags= "L";
  ocelot_histfilesize= "2000000000";
  ocelot_histsize= "500";
  lmysql= new ldbms();                               /* lmysql will be deleted in action_exit(). */
  xsettings_widget= new XSettings(this);
  /* picking up possible settings options from argc+argv after setting _ defaults, so late */
  /* as a result, ocelotgui --version and ocelotgui --help will look slow */
  connect_mysql_options_2(argc, argv);               /* pick up my.cnf and command-line MySQL-related options, if any */
  if (ocelot_version != 0)                           /* e.g. if user said "ocelotgui --version" */
  {
    print_version();
    exit(0);
  }
  if (ocelot_help != 0)                              /* e.g. if user said "ocelotgui --help" */
  {
    print_help();
    exit(0);
  }
  for (int q_i= 0; strcmp(string_languages[q_i]," ") > 0; ++q_i)
  {
    QString s= string_languages[q_i];
    if (QString::compare(ocelot_language, s, Qt::CaseInsensitive) == 0)
    {
      er_off= ER_END * q_i;
      color_off= COLOR_END * q_i;
      menu_off= MENU_END * q_i;
    }
  }

  set_dbms_version_mask(ocelot_dbms, 0);
  for (int q_i= color_off; strcmp(s_color_list[q_i]," ") > 0; ++q_i) q_color_list.append(s_color_list[q_i]);
  assign_names_for_colors();
  make_style_strings();
  //main_window->setStyleSheet(ocelot_menu_style_string);
  ui->menuBar->setStyleSheet(ocelot_menu_style_string);
  initialize_widget_history();
  initialize_widget_statement();
  /*
    2018-10-08 setFont() before adding tab with ResultGrid, in hope that ResultGrid
    will inherit and that will fix the bug where initial height is too small.
    Actually I now think that the fix this day in ocelotgui.h, where we're creating
    ResultGrid, solves the bug. But leave setFont() in for luck.
  */
  QFont grid_font= get_font_from_style_sheet(ocelot_grid_style_string);
  result_grid_tab_widget->setFont(grid_font);
  result_grid_add_tab();
  main_layout->addWidget(history_edit_widget);
  main_layout->addWidget(result_grid_tab_widget);
  main_layout->addWidget(statement_edit_widget);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  main_layout->addWidget(debug_top_widget);
#endif
#if (OCELOT_FIND_WIDGET == 1)
  find_widget= new Find_widget(this);
  main_layout->addWidget(find_widget);
#endif
#if (OCELOT_EXPLORER == 1)
  explorer_widget= new ResultGrid(lmysql, this, true, EXPLORER_WIDGET);
  //explorer_widget->setStyleSheet(ocelot_explorer_style_string);
  explorer_widget->html_text_edit->explorer_context_menu->setStyleSheet(ocelot_explorer_style_string);
  initialize_widget_explorer();
  QHBoxLayout *upper_layout= new QHBoxLayout();
  QWidget *upper_widget= new QWidget();
  upper_widget->setLayout(main_layout);
  upper_layout->addWidget(explorer_widget);

  upper_layout->addWidget(upper_widget);
  main_window->setLayout(upper_layout);
#else
  main_window->setLayout(main_layout);
#endif
  setCentralWidget(main_window);

  fill_menu();    /* Do this at a late stage because widgets must exist before we call connect() */
  history_edit_widget->setContextMenuPolicy(Qt::CustomContextMenu);
  connect(history_edit_widget, SIGNAL(customContextMenuRequested(const QPoint &)),
      this, SLOT(menu_context(const QPoint &)));
  statement_edit_widget->setContextMenuPolicy(Qt::CustomContextMenu);
  connect(statement_edit_widget, SIGNAL(customContextMenuRequested(const QPoint &)),
      this, SLOT(menu_context(const QPoint &)));
  /*
    If the command-line option was -p but not a password, then password input is necessary
    so put up the connection dialog box. Otherwise try immediately to connect.
    Todo: better messages so the user gets the hint: connection is necessary / password is necessary.
    Todo: check: Can you handle password with special characters?
  */
  if (ocelot_password_was_specified != 2)
  {
    statement_edit_widget->insertPlainText("CONNECT");
    action_execute(1);
  }
  else
  {
    action_connect();
  }
  statement_edit_widget->setFocus(); /* Show user we're ready to accept a statement in the statement edit widget */

  QTimer::singleShot(0, this, SLOT(initialize_after_main_window_show()));

  log("MainWindow end", 90);
}


MainWindow::~MainWindow()
{
  delete ui;
}

/*
  Some actions must wait till after MainWindow::MainWindow() has made the main window.
  E.g. if ocelotgui --ocelot_statement_detach='yes', detaching won't work right until widget sizes are known.
  Qt manuals say "A QTimer with a timeout interval of 0 will time out as soon as all the events
  in the window system's event queue have been processed." so I expect that, given that we invoke with
  QTimer::singleShot(0, this, SLOT(initialize_after_main_window_show()));
  this will happen only after all the main events (show, paint, focusin, etc.) have already been processed.
  But I still needed to issue Messagebox_flash, a drastic way to force an update.
  There will be a lot of blinking. Probably not worth worrying about.
*/
void MainWindow::initialize_after_main_window_show()
{
  if ((ocelot_history_detached == "yes")
      || (ocelot_grid_detached == "yes")
#if (OCELOT_MYSQL_DEBUGGER == 1)
      || (ocelot_debug_detached == "yes")
#endif
      || (ocelot_statement_detached == "yes"))
  {
    Messagebox_flash msgbox;
    msgbox.setText("Detaching ...");
    msgbox.exec(); /* This should display for 1 second then disappear. */
  }
  if (ocelot_history_detached == "yes") action_option_detach_history_widget(true);
  if (ocelot_grid_detached == "yes") action_option_detach_result_grid_widget(true);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  if (ocelot_debug_detached == "yes") action_option_detach_debug_widget(true);
#endif
  if (ocelot_statement_detached == "yes") action_option_detach_statement_widget(true);
#if (OCELOT_EXPLORER == 1)
  if (ocelot_explorer_detached == "yes") action_option_detach_explorer_widget(true);
#endif
}

/*
  We want to know the maximum widget size for dialog boxes.
  We can get this from the second time resizeEvent happens
  on MainWindow, which is asserted to be maximized.
*/
void MainWindow::resizeEvent(QResizeEvent *ev)
{
  QSize main_window_size= size();
  if (main_window_size.width() > main_window_maximum_width)
    main_window_maximum_width= main_window_size.width();
  if (main_window_size.height() > main_window_maximum_height)
    main_window_maximum_height= main_window_size.height();
  QMainWindow::resizeEvent(ev);
}

/*
  Normally there is only one result set, and therefore only one tab,
  and we hide the tabbing if there is only one tab. Abnormally there
  is more than one because a stored procedure does more than one SELECT.
  We call this at start, and we call this when we need a new tab.
  We never delete. That might be bad because Settings changes will be slower.
  We have:
  ocelot_grid_tabs. The maximum. Default 16. Settable with --ocelot_grid_tabs=n.
  result_grid_tab_widget. What we add the tabs to.
  ocelot_grid_actual_tabs. When we successfully add a tab, this goes up.
  Return 0 for success, 1 for failure (failure is probably because we hit maximum).
*/
int MainWindow::result_grid_add_tab()
{
  ResultGrid *r;
  int i_r= ocelot_grid_actual_tabs;
  if ((ocelot_grid_actual_tabs >= ocelot_grid_tabs)
  && (ocelot_grid_tabs != 0))
    return 1;
  {
    r= new ResultGrid(lmysql, this, true, 0);
    int new_tab_index= result_grid_tab_widget->addTab(r, QString::number(i_r + 1));
#if defined(NDEBUG)
    if (new_tab_index != i_r) {printf("assert(new_tab_index == i_r);"); exit(1); }
#else
    assert(new_tab_index == i_r);
#endif
    r->hide(); /* Maybe this isn't necessary */
  }
  {
    /* Todo: is this pointless? I don't catch fontchange anyway! */
    r= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(i_r));
    assert(r != 0);
    r->installEventFilter(this); /* must catch fontChange, show, etc. */
    r->grid_vertical_scroll_bar->installEventFilter(this);
  }
  {
    r= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(i_r));
    r->set_all_style_sheets(ocelot_grid_style_string, 0, 0, false);
  }
  ++ocelot_grid_actual_tabs;
  return 0;
}

/*
  Initialize statement_edit_widget. Assume "statement_edit_widget= new CodeEditor();" already done.
  All user SQL input goes into statement_edit_widget.
  This will be a CodeEditor, which is a class derived from QTextEdit, with a prompt on the left.
  Todo: Check: after font change or main window resize, are line numbers and text in sync?
*/
void MainWindow::initialize_widget_statement()
{

  statement_edit_widget_setstylesheet();

  statement_edit_widget->setLineWrapMode(QPlainTextEdit::NoWrap);
  /* statement_edit_widget->setAcceptRichText(false); */ /* Todo: test whether this works */
  connect(statement_edit_widget->document(), SIGNAL(contentsChange(int,int,int)), this, SLOT(action_statement_edit_widget_text_changed(int,int,int)));
  statement_edit_widget_text_changed_flag= 0;

  /*
    Defaults.
    The prompt can be changed with a "prompt" statement or by my.cnf contents.
    The widget-left i.e. prompt bgcolor can be changed with a menu item.
  */
  statement_edit_widget->statement_edit_widget_left_bgcolor= QColor(ocelot_statement_prompt_background_color);
  statement_edit_widget->statement_edit_widget_left_treatment1_textcolor= QColor(ocelot_statement_text_color);

  statement_edit_widget->prompt_default= ocelot_prompt;     /* Todo: change to "\N [\d]>"? */
  statement_edit_widget->prompt_as_input_by_user= statement_edit_widget->prompt_default;

  statement_edit_widget->statement_count= 0;
  statement_edit_widget->dbms_version= (QString)"";
  statement_edit_widget->dbms_database= (QString)"";
  statement_edit_widget->dbms_port= (QString)"";
  statement_edit_widget->dbms_host= (QString)"";
  statement_edit_widget->dbms_current_user= (QString)"";
  statement_edit_widget->dbms_current_user_without_host= (QString)"";
  statement_edit_widget->delimiter= ocelot_delimiter_str;
  statement_edit_widget->result= (QString)"";

  /*
    Problem: the above statements don't cause recalculation of width of prompt on the left.
    (Original calculation happens when widget is created.)
    I can force recalculation by doing an "emit" here.
    But I'm not sure this is the right way to do it.
  */
  emit statement_edit_widget->update_prompt_width(0);

  statement_edit_widget->installEventFilter(this);
  statement_edit_widget->setMouseTracking(true);
}


/* Statement widget and debug widgets both use ocelot_statement_style_string. */
void MainWindow::statement_edit_widget_setstylesheet()
{
  statement_edit_widget->setStyleSheet(ocelot_statement_style_string);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  for (int debug_widget_index= 0; debug_widget_index < DEBUG_TAB_WIDGET_MAX; ++debug_widget_index)
  {
    if (debug_widget[debug_widget_index] != 0)
    {
      debug_widget[debug_widget_index]->setStyleSheet(ocelot_statement_style_string);
    }
  }
#endif
  completer_widget->initialize(STATEMENT_WIDGET);
}

/*
  Formatter -- minimal, but this format might be okay for debugger users.
  It only works if the statement has been recognized.
  All we're trying to accomplish is
    "different statements different lines"
    "block start causes indent"
    "token replacement rules user-settable"
    "lists of columns lined up in select/update/insert/set".
  Cursor will go back to start.
  Indentation is meaningless unless there is a fixed font.
  Menu item is Edit|Format and shortcut key (which is done with setShortcut not
  eventfilter, I forget why) is Alt+Shift+F. Statements which can affect it are
    SET ocelot_statement_format_clause_indent = integer 0-8; default='4'
    SET ocelot_statement_format_statement_indent = integer 0-8; default='2'
    SET ocelot_statement_format_rule = e.g. 'identifier becomes identifier-upper'
  Todo: stop giving up when you see DELIMITER, it can be figured out.
  Todo: max_rule_tokens is # of characters, we only need # of tokens.
  Todo: worry: can output_offsets overflow?
*/
void MainWindow::statement_edit_widget_formatter()
{
  log("statement_edit_widget_formatter", 15);
  if (((ocelot_statement_syntax_checker.toInt()) & FLAG_FOR_HIGHLIGHTS) == 0) return;
  int max_rule_tokens= ocelot_statement_format_rule.size();
  int *rule_token_offsets= new int[max_rule_tokens];
  int *rule_token_lengths= new int[max_rule_tokens];
  int *rule_token_types= new int[max_rule_tokens];
  tokenize(ocelot_statement_format_rule.data(),
           ocelot_statement_format_rule.size(),
           &rule_token_lengths[0], &rule_token_offsets[0], max_rule_tokens - 1,
          (QChar*)"33333", 1, "", 1);
  for (int i2= 0; rule_token_lengths[i2] != 0; ++i2)
  {
    QString rule_token= ocelot_statement_format_rule.mid(rule_token_offsets[i2], rule_token_lengths[i2]);
    int t= token_type(rule_token.data(), rule_token_lengths[i2], sql_mode_ansi_quotes);
    if ((t == TOKEN_TYPE_OTHER) && (rule_token_lengths[i2] < MAX_KEYWORD_LENGTH))
    {
      char key1[MAX_KEYWORD_LENGTH + 1];
      char key2[MAX_KEYWORD_LENGTH + 1];
      strcpy(key1, rule_token.toUtf8());
      t= get_keyword_index(key1, key2);
    }
    rule_token_types[i2]= t;
  }
  int *output_offsets;
  int i;
  for (i= 0; main_token_lengths[i] != 0; ++i) ;
  output_offsets= new int[i + 1];

  QString text= statement_edit_widget->toPlainText(); /* or I could just pass this to tokenize() directly */
  QString output= "";
  int indent_base= 0;
  int statement_indent= ocelot_statement_format_statement_indent.toInt();
  int clause_indent= ocelot_statement_format_clause_indent.toInt();

  int token;
  QString s;
  int token_type;
  for (i= 0; main_token_lengths[i] != 0; ++i)
  {
    if ((main_token_flags[i] & TOKEN_FLAG_IS_ERROR) != 0)
    {
      int st= 0;
      if (i > 0) st= main_token_offsets[i - 1] + main_token_lengths[i - 1];
      s= text.right(text.length() - st);
      output.append(s);
      break; /* Give up */
    }
    token_type= 0;
    token= main_token_types[i];
    if (token == TOKEN_TYPE_DELIMITER)
    {
      QString d= text.mid(main_token_offsets[i], main_token_lengths[i]);
      output.append(d);
      continue;
    }
    if (text.mid(main_token_offsets[i], 2).toUpper() == "\\G")
    {
      output.append(text.mid(main_token_offsets[i], 2));
      ++i;
      continue;
    }
    if ((main_token_flags[i] & TOKEN_FLAG_IS_START_IN_COLUMN_LIST) != 0)
      output_offsets[i]= output.length();
    if ((main_token_flags[i] & TOKEN_FLAG_IS_END_IN_COLUMN_LIST) != 0)
    {
      output.append(",");
      /* indent to where the column list began */
      int indent_of_column= 0;
      for (int k= i - 1; k >= 0; --k)
      {
        if ((main_token_flags[k] & TOKEN_FLAG_IS_START_IN_COLUMN_LIST) != 0)
        {
          int l= output_offsets[k];
          for (; (l < output.length()) && (output.mid(l, 1) <= " "); ++l) ;
          for (int m= l; ; --m)
          {
            if ((output.mid(m, 1) == "\n") || (m == 0))
            {
              if (m != 0) ++m;
              indent_of_column= l - m;
              break;
            }
          }
          break;
        }
      }
      output.append("\n");
      for (int n= 0; n < indent_of_column; ++n) output.append(" ");
    }
    else
    {
      if (token == TOKEN_KEYWORD_DELIMITER)
      {
        if (output != "") output.append("\n");
        QString d;
        d= text.mid(main_token_offsets[i], main_token_lengths[i]);
        QString e= d.toUpper();
        if (e == "DELIMITER") output.append(e);
        else output.append(d);
        if (main_token_lengths[i + 1] != 0)
        {
          int j= main_token_offsets[i] + main_token_lengths[i];
          d= text.mid(j, main_token_offsets[i + 1] - j);
          if (d.contains("\n"))
          {
            continue; /* delimiter \n = an error, but possible */
          }
          output.append(" ");
          ++i;
          d= text.mid(main_token_offsets[i], main_token_lengths[i]);
          output.append(d);
          while ((main_token_lengths[i + 1] != 0)
           && (main_token_offsets[i + 1] == main_token_offsets[i] + main_token_lengths[i]))
          {
            d= text.mid(main_token_offsets[i + 1], main_token_lengths[i + 1]);
            output.append(d);
            ++i;
          }
          continue;
        }
      }
      if (token == TOKEN_KEYWORD_PROMPT)
      {
        if (output != "") output.append("\n");
        QString d;
        d= text.mid(main_token_offsets[i], main_token_lengths[i]);
        QString e= d.toUpper();
        if (e == "PROMPT") output.append(e);
        else output.append(d);
        int k= i + 1;
        while ((main_token_lengths[k] != 0)
            && ((main_token_flags[k] & TOKEN_FLAG_IS_START_STATEMENT) == 0)
            && ((main_token_flags[k] & TOKEN_FLAG_IS_ERROR) == 0))
          ++k;
        --k;
        if (k != i)
        {
          int j;
          j= main_token_offsets[k] - (main_token_offsets[i] + main_token_lengths[i]) + main_token_lengths[k];
          d= text.mid(main_token_offsets[i] + main_token_lengths[i], j);
          output.append(d);
        }
        i= k;
        continue;
      }
      if (((main_token_flags[i] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
       || ((main_token_flags[i] & TOKEN_FLAG_IS_START_CLAUSE) != 0))
      {
        token_type= 1;
        if ((token == TOKEN_KEYWORD_BEGIN)
        || (token == TOKEN_KEYWORD_CASE)
        || (token == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT) /* will only be true if MariaDB 10.3 */
        || (token == TOKEN_KEYWORD_IF)
        || (token == TOKEN_KEYWORD_LOOP)
        || (token == TOKEN_KEYWORD_REPEAT)
        || (token == TOKEN_KEYWORD_WHILE))
          token_type= 3;
      }
      if (token_type > 0)
      {
        /* todo: check if (not already at indent-base) */
        if (output != "") output.append("\n");
        for (int k= 0; k < indent_base; ++k) output.append(" ");
        if ((main_token_flags[i] & TOKEN_FLAG_IS_START_CLAUSE) != 0)
        {
          for (int k= 0; k < clause_indent; ++k) output.append(" ");
        }
        if (token == TOKEN_KEYWORD_END)
        {
          indent_base-= statement_indent;
        }
        if (token_type == 3)
        {
          indent_base+= statement_indent;
        }
      }
      s= text.mid(main_token_offsets[i], main_token_lengths[i]);
      QString p= "";
      int p_flags= 0;
      int p_type= 0;
      if (i > 0)
      {
        p= text.mid(main_token_offsets[i - 1], main_token_lengths[i - 1]);
        p_flags= main_token_flags[i - 1];
        p_type= main_token_types[i - 1];
      }

      if (output.right(1) == "\\")
      {
        if (main_token_offsets[i] == main_token_offsets[i - 1] + main_token_lengths[i - 1])
        {
          output.append(s);
          continue;
        }
      }

      if (output.right(1) > " ")
      {
        if (main_token_types[i] == TOKEN_TYPE_OPERATOR)
        {
          if ((s == ",") || (s == ";") || (s == ")") || (s == "}") || (s == ".") || (s == ":")) {;}
          else if (s == "(")
          {
            /* no space between function name and '('. mandatory. */
            if ((p_flags & TOKEN_FLAG_IS_FUNCTION) != 0)
            {
              ;
            }
            else if (p_type == TOKEN_TYPE_IDENTIFIER)
            {
              ;
            }
            else if ((p_flags & TOKEN_FLAG_IS_DATA_TYPE) != 0)
            {
              ;
            }
            else if ((p != "(")
             && ((main_token_flags[i] & TOKEN_FLAG_IS_NOT_AFTER_SPACE) == 0))
              output.append(" ");
          }
          else output.append(" ");
        }
        else
        {
          if ((p == "(") || (p == "{") || (p == ".") || (p == "@") || (p == "~")) {;}
          else if ((p == "-") || (p == "+"))
          {
            if ((main_token_flags[i - 1] & TOKEN_FLAG_IS_BINARY_PLUS_OR_MINUS) != 0)
            {
              output.append(" ");
            }
          }
          else if (s == "@") {;}
          else output.append(" ");
        }
      }
      s= statement_format_rule_apply(s, main_token_types[i], main_token_reftypes[i], main_token_flags[i], rule_token_offsets, rule_token_lengths, rule_token_types);
      output.append(s);
    }
  }
  /* Change statement widget contents with possibility of "undo" later */
  QTextCursor cur(statement_edit_widget->textCursor());
  cur.beginEditBlock();
  cur.setPosition(0);
  cur.select(QTextCursor::Document);
  cur.removeSelectedText();
  cur.insertText(output);
  cur.endEditBlock();
  delete [] output_offsets;
  delete [] rule_token_types;
  delete [] rule_token_lengths;
  delete [] rule_token_offsets;
  action_statement_edit_widget_text_changed(0, 0, 0); /* This is new, trying to solve the ^Z problem */
}

/*
  ocelot_statement_format_rule_set()
  This will help with implementation of the format rules described by
  Descriptive SQL Style Guide
  https://github.com/pgulutzan/descriptive-sql-style-guide/blob/master/style.md
  The rules are applied to a current statement when user chooses Edit|Format.
  See statement_edit_widget_formatter() above.

  Rules are for replacing tokens.
  They are applied once per token. If rule doesn't match, skip. If does match, replace and skip the rest.

  Client statement =
  SET STATEMENT_FORMAT_RULE rule [, rule ...] ;

  rule =
  token-or-category BECOMES zero or more tokens or categories

  token-or-category =
  category name i.e. COMMENT | IDENTIFIER | KEYWORD | LITERAL| OPERATOR
  token i.e. anything that is legal in an SQL statement e.g. THEN or 'THEN', or character name
        optionally followed by modifier(s)

  character name = COMMA | NEWLINE | SEMICOLON | SPACE | TAB but these cannot be tokens

  modifier = -UPPER | -LOWER

  Default rule is keyword becomes keyword-upper;

  Tips:
    To add a newline after THEN: THEN BECOMES THEN NEWLINE
    To say that all keywords are upper case etc.: KEYWORD BECOMES KEYWORD-UPPER
    To say that != should be <>: != BECOMES <>
    To say that INT should be INTEGER: INT BECOMES INTEGER
    To say 'x' should be 'y': SET ocelot_statement_format_rule 'x' BECOMES 'y';
    So far: success with:
    SET ocelot_statement_format_rule 'x' becomes 'y';
    SET ocelot_statement_format_rule 'm' becomes 'y' 'z', 'x' becomes 'k';
    set ocelot_statement_format_rule identifier becomes identifier 5;
    set ocelot_statement_format_rule identifier becomes identifier-upper;
    SET ocelot_statement_format_rule comment becomes ;
    SET ocelot_statement_format_rule IDENTIFIER-LOWER BECOMES IDENTIFIER-UPPER;
  If there is more than one rule:
    If the token does not match, then the rule is ignored.
    If the token does match, then the token is replaced and all subsequent rules are ignored.
    Therefore sensible people will put specific rules before category rules.
    For example
      SET OCELOT_STATEMENT_FORMAT_RULE THEN BECOMES SPACE THEN, KEYWORD BECOMES KEYWORD;
      means when you see THEN you apply the first rule, therefore you do not apply the second rule.
  It's also possible to set with --ocelot_statement_format_rule='rule'
  Todo: consider escape character e.g. \; and escape reserved word e.g. \IDENTIFIER
        consider doing rules at start rather than at end
  Todo: OK message should say how many times rules were applied.
  Todo: additional modifiers:
        (KEYWORD) -RESERVED -CAPITALIZED -DATATYPE -VERB -CLAUSE_START -STATEMENT_START -IN_COMPOUND
        (COMMENT) -BRACKETED -SIMPLE -OCTOTHORPE
        (LITERAL) -STRING -FLOAT -DECIMAL -BINARY -LONG -DOUBLEQUOTED -ORDINAL
        (OPERATOR) -ARITHMETIC -COMPARISON -PUNCTUATION
        (IDENTIFIER) -DELIMITED -REGULAR -QUOTED -BACKTICKED -TABLE -COLUMN -ROUTINE
  Todo: rules for INDENT and WHITESPACE
  Todo: Additional categories: STATEMENT CLAUSE EXPRESSION SUBQUERY LIST
  Todo: Phrases e.g. CREATE ... TABLE or ALTER ... TABLE ... ADD
  Todo: just say what rules would be violated or applicable ("This is not formatted according to rules 1 and 77")
        or say what rules are being followed e.g. "To get this we would have to make these rules")
  PROBLEM: ACCEPTED: SET ocelot_statement_format_rule operator becomes identifier-upper;
  PROBLEM: MAYBE ^Z IS NOT CALLING HPARSE AGAIN? So you can't format twice.
*/

int MainWindow::statement_format_rule_set(QString text)
{
  if (((ocelot_statement_syntax_checker.toInt()) & FLAG_FOR_HIGHLIGHTS) == 0) return ER_FORMAT_RULE;
  int i;
  for (i= 0; main_token_lengths[i] != 0; ++i)
  {
    if (main_token_types[i] == TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_RULE)
    {
      ocelot_statement_format_rule= text.mid(main_token_offsets[i + 1]);
    }
  }
  return ER_OK;
}

#if (OCELOT_IMPORT_EXPORT == 1)
/*
  Called by import_export_rule_set().
  Change QString to utf8 and then to QByteArray.
  Or: if it is X'....', convert hex digits directly to QByteArray.
  Convert escapes, e.g. if QString contains \n, we want a byte value QChar::LineFeed
  According to https://dev.mysql.com/doc/refman/8.0/en/load-data.html the combinations that are escapes
  are \0 \b \n \r \t \z \N. But I haven't handled \N (NULL) yet (for IF NULL I'm taking it as two letters).
  Todo: Check: why are you saying \\Z not \\z?
  Todo: Check if there are other combinations that aren't documented.
*/
QByteArray MainWindow::to_byte_array(QString q)
{
  if ((q.mid(1, 1) == "'") && (QString::compare(q.mid(0, 1), "X", Qt::CaseInsensitive) == 0))
    return QByteArray::fromHex(q.toUtf8());
  QString s= q;
  s= s.replace("\\0", "\0");
  s= s.replace("\\b", "\b");
  s= s.replace("\\n", "\n");
  s= s.replace("\\r", "\r");
  s= s.replace("\\t", "\t");
  s= s.replace("\\Z", QChar(26)); /* should be interpreted as replacement character ^z, not checked. */
  return s.toUtf8();
}

/*
  SET ocelot_export ...; -- settings for dump of current result set, in one of several formats
  Many of the comments are about wishes that might never come true

  Some of the clauses are as in MySQL's INTO OUTPUT clauses but ocelotgui has more options and file can be local.
  (Of course one could say that about mysqldump too, but we're doing some things that mysqldump doesn't.)

  SET ocelot_export ::= 'string' | option-list
  Ordinarily one does not use 'string', but it is allowed because --ocelot_export = 'string' is allowed.
  Example: set by menu File|Export TEXT using the same default as the mysql client:
  SET ocelot_export = FORMAT 'TEXT'
    INTO 'STDOUT'
    COLUMNS TERMINATED BY X'09' ENCLOSED BY '' ESCAPED BY X'5C'
    LINES STARTING BY '' TERMINATED BY X'0A'
    MAX_ROW_COUNT 100000000 COLUMN_NAMES 'no'
    QUERY 'no' ROW_COUNT 'no' MARGIN 0 PAD 'no' LAST 'no' DIVIDER 'no' IF NULL '\N'
    IF FILE EXISTS 'append';
  SET ocelot_export = FORMAT 'TABLE'
      INTO STDOUT
      FIELDS TERMINATED BY '|' ENCLOSED BY '' ESCAPED BY ''
      LINES STARTING BY '|' TERMINATED BY X'0A';

  For most strings one can use X'....' e.g. x'09' instead of a tab character or '\t'.
  This overrides TEE and --html-raw and --xml and --raw and --batch.
  Types supported now: TEXT, TABLE, HTML, NONE
  Types to consider: JSON, YAML, LUA, HTML4, HTML5, DEFAULT (? and BATCH or RAW or XML?)
                     SQL | INSERT STATEMENTS, MSGPACK, LATEX, TROFF
  INTO 'filename' | STDOUT
    Alternatives to INTO: FILE, OUTFILE, INTO OUTFILE. hopefully '[literal]' is enough hint
    Alternatives to 'filename':| TEE | @variable | CLIPBOARD | TMPFILE | pipe/port | grid-widget | histfile
    INTO STDOUT is default
    Extra clauses to consider: IF EXISTS append | error | overwrite | add new + ordinal
                               [ADD TIMESTAMP] you could have multiple files,
                                               add timestamp or ordinal or random-string to each file name
                               [IF FILE EXISTS ERROR|APPEND|REPLACE]
                                               Default = APPEND though mysql client would say ERROR
                                               Perhaps TRUNCATE would be clearer than REPLACE
  'TEXT': (some call it DEP) (or DELIMITED?) (these defaults are for MySQL which is tab-separated but like CSV)
     MySQL Shell calls it "tabbed".
     The same items that are in MySQL/MariaDB output file, in order:
     FIELDS|COLUMNS TERMINATED BY string
     FIELDS|COLUMNS ESCAPED BY string
     FIELDS|COLUMNS [OPTIONALLY] ENCLOSED BY string
     LINES STARTING BY string TERMINATED BY string
   'TABLE': (or FIXED?) (or TABULAR?) (or PRETTY?) (or BOXES?)
     ClickHouse calls it PRETTY. MySQL Shell says result_format=table. (They also have "tabbed".)
     https://mariadb.com/kb/en/mysql-command-line-client/ says "ascii-table"
     This is the +----+ style with Box drawing as in https://en.wikipedia.org/wiki/Box-drawing_character
     (but really the +-----+ style is fixed-width, columns terminated by |, lines terminated by special-stuff)
     SET ... COLUMN BOUNDARIES '|' LINE BOUNDARIES '-' INTERSECTIONS '+' HEADER LINE BOUNDARIES '='
     Does not appply to history, which is like TABLE but has no options because we may depend on its format.
     FIELDS|COLUMNS TERMINATED BY string
     LINES TERMINATED BY '-' AND '+' (or '-+')
     HEADER LINES TERMINATED BY '=' AND '+'
     FILE STARTING BY '-' AND '+'
     FILE TERMINATED BY '-' AND '+'
   'HTML'
     This has to just dump what we got for result grid, but with different limit for max_row_count
     it's influenced by ocelot_grid_... settings
   'NONE':
     This is the default. Simple: there is no exporting.
   DEFAULT (no longer shown):
     TEE result set output will be like TABLE with -s and |s and +s, same as history output.
     So DEFAULT is what you are used to seeing with TEE.
   Applicable for all types: implemented:
     MAX ROW_COUNT n default 100000000, if it's 0 but INCLUDE QUERY then only query will go out
     COLUMN_NAMES 'yes' or 'no', if 'yes' then column names appear at start of result set
     QUERY 'yes' or 'no', if 'yes' then query appears before result set
           (default is true because exporting is like that, or false if DEFAULT)
     ROW_COUNT 'yes' or 'no', if 'yes' then row count appears before result set
     MARGIN n default 1 i.e. number of spaces before after each column, sometimes column-terminated-by does this
     PAD 'yes' or 'no'
     LAST 'yes' or 'no'
     DIVIDER 'yes' or 'no'
     IF NULL '\N' or it could be 'NULL' etc. but MySQL|MariaDB always say \N (or "fill with ****s"?) see also "Re IF NULL".
   Applicable for all types: not implemented:
     MAX_ROW_COUNT SELECTED ROWS instead of MAX_ROW_COUNT n
     WIDTH FIXED|MINIMAL|MAXIMAL i.e. should we fill in blanks with leading|trailing spaces, as if PAD ' '
       and if fixed: truncate | newline
     BINARY AS ascii | hex | 'binary' | according to MySQL 8.0 setting for mysql client
     MAXIMUM_BYTES, MAXIMUM_LINE_WIDTH
     CHARACTER SET character-set-name                       default is UTF8
     DOUBLE QUOTES     Whether it's okay to double a quote character inside quotes,
                       SQL-style, e.g. 'The''Rain'.
                       This makes no sense if ENCLOSED BY is not ", or if ESCAPED BY is operating. Override them?
                       Default = no.
     HEADER            Add Oracle-style Header separator?
     MAXIMUM_COLUMN_WIDTH = n or as-in-definition, and WRAP | WORD-WRAP | TRUNCATE, and PAD with spaces
     FLUSH AFTER EACH ROW | AT END         Default = after each row
     SKIP IF same-regexp-as-for-history    Default = nothing
                                           Or say EXCLUDE data-type
     ONLY SELECTED ROWS                    Ordinarily we always output when we have a selection
                                           So this would imply: do not output until user selects
                                           Initially nothing is selected.
                                           Would still be limited by MAX_ROW_COUNT
     ZIP or some other compression
   Re escapes within the literals in the SET statement (this is not about escapes in what's exported):
    Since tokenize() depends on (sql_mode_string.contains("NO_BACKSLASH_ESCAPES")),
    changing sql_mode can change the statement's meaning. It's best to use X'..' for single-character
    escaping. Apparently this is different from mysql client, which never escapes.
    So you can use \t for tab, just like what you see with INTO OUTFILE, but we won't recommend it.
    SELECT ... INTO OUTFILE also allows e.g. FIELDS TERMINATED BY X'0A'; so to that extent we're consistent.
    Also \ is a bit of a bother with Windows file names in the INTO clause.
    Therefore ESCAPED BY '\\' is okay just as in SELECT ... INTO OUTFILE, but we prefer X'5C'.
    Typical: X'00' nul (or \0), X'08' backspace (or \b), X'09' tab (or \t), X'0A' line feed (or \n),
             X'0D' carriage return (or \r), X'1A' control-Z (or \Z).  X'20' space (or \s),
             X'22' double quote (or \"), X'27' single quote (or \'), X'5C' (or \\)
    Warning: We do not escape what is in IF NULL strings.
    Todo: Think what to do if we're not connected to MySQL/MariaDB. Local setting? Allow set sql_mode anyway?
   Re FIELDS|COLUMNS TERMINATED BY:
     It comes at the end of every column -- except the last column! So default end-of-row is x0a not 0x090a.
     So LAST 'yes' should mean "include columns-terminated-by string after last column"
   Re ENCLOSED BY:
     OPTIONALLY means applicable for numbers but not DATE/TIME/TIMESTAMP/[VAR]CHAR/[VAR]BINARY,
     and what matters is the definition i.e. '55' is not enclosed for string columns, 1e44 is enclosed for
     numeric columns.
     NULLs are never enclosed.
   Re ESCAPED BY: (NB: import and export will differ, this is only what we do with export)
     default = \
     x'00' becomes escape+'0',
     fields-terminated-by becomes escape+fields-terminated-by e.g. x09 becomes escape+x09 (default),
     enclosed-by becomes escape+enclosed-by e.g. " becomes escape+" (there is no default),
     escaped-by becomes escape+escaped-by e.g. \ becomes escape+\ (default),
     lines-starting-by does not affect escaping,
     lines-terminated-by becomes escape+lines-terminated-by e.g. x0a becomes escape+0x0a (default)
       (but if there is more than one character then only the firstr character matters),
     But this is a reason that more than one character for enclosing makes no sense, usually.
     Re escape+'0': I guess it's rational if we say ESCAPED BY X'5C' because then the output is \0
    Re REPLACE:
      This is more flexible than ESCAPE, although may ESCAPE is a better word
      We don't need to escape "s because one can say REPLACE " WITH ""
      Sometimes that would be good because doubling "s is an expectation for some products.
    Re IF NULL:
     In MySQL/MariaDB INTO OUTFILE NULL becomes escape+N which ordinarily means \N but it's WN if ESCAPED BY 'W'
     but if ESCAPED BY '' then it should be NULL.
       (however since we have IF NULL we don't do that we take the exact if_null string),
      MySQL/MariaDB behaviour is: if ESCAPED BY is '' then say NULL, else say escaped-by-char + N.
      Saying '\N' or 'NULL' won't have that effect, so to replicate it say DEFAULT, which is default.
      We say if IF NULL value is DEFAULT then we'll do what MySQL/MariaDB do, else we output IF NULL value.
      Warning: we do not escape what is in null strings. That is:
               In copy_to_history() we do not check escapers for IF NULL values, so for
               TERMINATED BY 'U' ESCAPED BY 'U' IF NULL 'NULL'
                the result will be NULL it will not be N\ULL.
    Re ambiguity:
     mysql client can say "| Warning | 1475 | First character of the FIELDS TERMINATED string is ambiguous;
     please use non-optional and non-empty FIELDS ENCLOSED BY |".
     ... Because it's stupid if escaped-by = terminated-by = enclosed-by i.e. the same character twice.
+-
   Struct, or individual variables
     type = "TEXT", "TABLE", etc.
     maximum_rows = long unsigned int
     column_boundary = ',' (the CSV default) or '|' (the TABLE default) -- no, TEXT default is '' I guess
   Todo: Menu
     File | Export text etc.
     Dialog box for each type, with different names but affecting the same variables
     No shortcuts
     ostrings.h, French: Exportation, botes
   Todo: TEE
     Show file name that is actually used, dev/null does cancelling, temporary file is okay, pipe is okay
     Ignore trailing ;
     Allow more options after file name
     Diagnostic message if fopen failure, and warning if appending / overwriting old file
     Warn if there is a non-default export setting (display it?)
     The actual writing of the result set is currently happening in tee_export()
   Todo: skip if SELECT has an INTO OUTFILE clause
   Todo: rather than widget(0) use the rg of the current-displayed result grid, if it's tabbed.
   Todo: better error if we didn't go through hparse which is why FLAG_FOR_HIGHLIGHTS could be off
   Unlike MySQL|MariaDB, we do not say TERMINATED BY strings must be short ASCII.
   struct export_rule is defined at the start of ocelotgui.cpp, set up here, and read in ocelotgui.h
   Todo: MySQL has a warning: "Non-ASCII separator arguments are not fully supported".
         If we allow multi-byte, see the warning in copy_to_history().
         I'd like to do differently. But I'd have to know whether X'...' i.e. VARBINARY was used.
         Maybe I'd only have to insist that the escape character is ASCII. Or say it's bizarre.
   Todo: Check if user deletes or edits the output file. Currently we don't notice and there's no output.
   Todo: Maybe max_row_count could default to ocelot_history_max_row_count if we get that before calling this.
*/

void MainWindow::export_defaults(int passed_type, struct export_settings *exports)
{
  (*exports).type= passed_type;
  (*exports).file_name= "STDOUT";
  (*exports).columns_terminated_by= "|";
  (*exports).columns_optionally= false;
  (*exports).columns_escaped_by= "";
  (*exports).columns_enclosed_by= "";
  (*exports).lines_starting_by= "";
  (*exports).lines_terminated_by= "";
  (*exports).max_row_count= 100000000;
  (*exports).column_names= true;
  (*exports).query= true;
  (*exports).row_count= true;
  (*exports).margin= 1;
  (*exports).pad= true;
  (*exports).last= true;
  (*exports).divider= true;
  (*exports).if_null= "DEFAULT";
  (*exports).replace_string= "X'22'";
  (*exports).with_string= "X'22'";
  (*exports).if_file_exists= "append";
  if (passed_type == TOKEN_KEYWORD_TEXT)
  {
    (*exports).columns_enclosed_by= "";
    (*exports).columns_escaped_by= "X'5C'"; /* this will appear as \ */
    (*exports).column_names= 0;
    (*exports).columns_terminated_by= "X'09'";
    (*exports).lines_starting_by= "";
    (*exports).lines_terminated_by= "X'0A'";
    (*exports).query= false;
    (*exports).row_count= false;
    (*exports).max_row_count= 100000000;
    (*exports).margin= 0;
    (*exports).pad= false;
    (*exports).last= false;
    (*exports).divider= false;
  }
  if (passed_type == TOKEN_KEYWORD_TABLE)
  {
    (*exports).columns_escaped_by= "X'5C'";
    (*exports).lines_starting_by= "|";
    (*exports).lines_terminated_by= "X'0A'";
    /* (*exports).pad= true; should be unnecessary */
  }
  if (passed_type == TOKEN_KEYWORD_HTML)
  {
    (*exports).query= false;
    (*exports).row_count= false;
  }
}

/*
  Why recursion: We want to handle SET ocelot_export='format ''test'''; as well as ocelot_export=format 'test';
                 because --ocelot_export is possible. And it might be --ocelot_export="format 'test'"
  Why no checks: Ordinarily we've gone through hparse, eh? But we can unset that or have a command-line option.
                 Maybe that means result will be junk but I don't think there's a crash possibility.
                 Todo: We check some errors here but messages are terse English.
  Todo: I hope that if a file is already open it will be closed somewhere; I haven't checked.
  For some errors, we check at end because if a clause is duplicated it might be okay the final time.
*/
#define MAX_EXPORT_TOKENS 100 /* We could use 'new' + dynamic but with current syntax 100 is more than enough */
QString MainWindow::import_export_rule_set(QString text)
{
  log("import_export_rule_set", 15);
  struct export_settings local_exports;
  export_defaults(0, &local_exports);

  QString error_message= "";
  int export_token_offsets[MAX_EXPORT_TOKENS];
  int export_token_lengths[MAX_EXPORT_TOKENS];
  int export_token_types[MAX_EXPORT_TOKENS];
  int token;
  tokenize(text.data(),
           text.size(),
           &export_token_lengths[0], &export_token_offsets[0], MAX_EXPORT_TOKENS - 1,
          (QChar*)"33333", 1, "", 1);
  /* This next bit is pared down from tokens_to_keywords(). ansi_quotes=false so "..." might be acceptable */
  {
    char key2[MAX_KEYWORD_LENGTH + 1];
    int i2, t, index;
    QString s;
    for (i2= 0; export_token_lengths[i2] != 0; ++i2)
    {
      s= text.mid(export_token_offsets[i2], export_token_lengths[i2]);
      t= token_type(s.data(), export_token_lengths[i2], false);
      if (i2 == MAX_EXPORT_TOKENS - 4) error_message= "Too many tokens";
      export_token_types[i2]= t;
      if ((t == TOKEN_TYPE_OTHER) && (export_token_lengths[i2] < MAX_KEYWORD_LENGTH))
      {
        QByteArray key_as_byte_array= s.toLocal8Bit();
        const char *key= key_as_byte_array.data();
        index= get_keyword_index(key, key2);
        if (index != -1) export_token_types[i2]= index;
      }
    }
  }

  QString s;
  QString rr= "";
  int i, i_prev_1, i_prev_2, token_prev_2;
  int lines_or_columns= 0;

  if (text == "")
  {
    local_exports.type= TOKEN_KEYWORD_NONE;
    goto ok_ok_return; /* for default initialization we pass "" */
  }
  for (i= 0; export_token_lengths[i] != 0; ++i)
  {
    token= export_token_types[i];
    QString token_string= text.mid(export_token_offsets[i], export_token_lengths[i]);
    if (token_string == "=")
    {
      int tmp_i= next_i_v(i, +1, export_token_types, export_token_lengths);
      if ((export_token_types[tmp_i] == TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE)
       || (export_token_types[tmp_i] == TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE))
      {
        QString s= text.mid(export_token_offsets[tmp_i], export_token_lengths[tmp_i]);
        s= connect_stripper(s, true);
        error_message= import_export_rule_set(s); /* recursion */
        if (error_message > "") goto ok_return;
      }
    }
    if (token == TOKEN_KEYWORD_FORMAT)
    {
      i= next_i_v(i, +1, export_token_types, export_token_lengths);
      QString s= text.mid(export_token_offsets[i], export_token_lengths[i]);
      s= connect_stripper(s, false);
      s= s.toUpper();
      if (s == "TEXT") token= TOKEN_KEYWORD_TEXT;
      else if (s == "TABLE") token= TOKEN_KEYWORD_TABLE;
      else if (s == "HTML") token= TOKEN_KEYWORD_HTML;
      else token= TOKEN_KEYWORD_NONE;
    }

    if (token == TOKEN_KEYWORD_TABLE)
    {
      local_exports.type= TOKEN_KEYWORD_TABLE;
      /* rest is default initially */
    }
    if (token == TOKEN_KEYWORD_TEXT)
    {
      export_defaults(TOKEN_KEYWORD_TEXT, &local_exports);
    }
    if (token == TOKEN_KEYWORD_HTML)
    {
      export_defaults(TOKEN_KEYWORD_HTML, &local_exports);
    }
    if (token == TOKEN_KEYWORD_NONE)
    {
      break;
    }

    if (token == TOKEN_KEYWORD_INTO)
    {
      i= next_i_v(i, +1, export_token_types, export_token_lengths);
      local_exports.file_name= text.mid(export_token_offsets[i], export_token_lengths[i]);
      local_exports.file_name= connect_stripper(local_exports.file_name, false); /* todo: consider: should we pass true rather than false here? */
    }

    if ((token == TOKEN_KEYWORD_FIELDS) || (token == TOKEN_KEYWORD_COLUMNS))
      lines_or_columns= TOKEN_KEYWORD_COLUMNS;
    if (token == TOKEN_KEYWORD_LINES)
      lines_or_columns= TOKEN_KEYWORD_LINES;
    if (token == TOKEN_KEYWORD_OPTIONALLY)
      local_exports.columns_optionally= true;

    if ((token == TOKEN_KEYWORD_MAX_ROW_COUNT)
     || (token == TOKEN_KEYWORD_NULL)
     || (token == TOKEN_KEYWORD_EXISTS)
     || (token == TOKEN_KEYWORD_COLUMN_NAMES) || (token == TOKEN_KEYWORD_QUERY)
     || (token == TOKEN_KEYWORD_ROW_COUNT)
     || (token == TOKEN_KEYWORD_MARGIN) || (token == TOKEN_KEYWORD_PAD) || (token == TOKEN_KEYWORD_LAST)
     || (token == TOKEN_KEYWORD_DIVIDER) || (token == TOKEN_KEYWORD_REPLACE) || (token == TOKEN_KEYWORD_WITH))
    {
      lines_or_columns= 0;
      i= next_i_v(i, +1, export_token_types, export_token_lengths);
      s= text.mid(export_token_offsets[i], export_token_lengths[i]);
      s= connect_stripper(s, false);
      int s_as_int= s.toInt();
      bool s_as_bool;
      if (s == "yes") s_as_bool= true;
      else s_as_bool= false;
      for (int j= 0; j < s.size(); ++j)
      {
        if (s.at(j).unicode() > 127) { error_message= "Non-ASCII"; goto ok_return; }
      }
      if (token == TOKEN_KEYWORD_MAX_ROW_COUNT) local_exports.max_row_count= s_as_int;
      if (token == TOKEN_KEYWORD_NULL) local_exports.if_null= to_byte_array(s);
      if (token == TOKEN_KEYWORD_REPLACE)
      {
        local_exports.replace_string= to_byte_array(s);
        if (local_exports.replace_string.length() > 1)
        {
          error_message= "REPLACE string maximum length = 1";
          goto ok_return;
        }
      }
      if (token == TOKEN_KEYWORD_WITH)
      {
        local_exports.with_string= to_byte_array(s);
        if (local_exports.with_string.length() > 2)
        {
          error_message= "WITH string maximum length = 2";
          goto ok_return;
        }
      }
      if (token == TOKEN_KEYWORD_EXISTS)
      {
        local_exports.if_file_exists= to_byte_array(s);
      }
      if (token == TOKEN_KEYWORD_COLUMN_NAMES) local_exports.column_names= s_as_bool;
      if (token == TOKEN_KEYWORD_QUERY) local_exports.query= s_as_bool;
      if (token == TOKEN_KEYWORD_ROW_COUNT) local_exports.row_count= s_as_bool;
      if (token == TOKEN_KEYWORD_MARGIN) local_exports.margin= s.toInt();
      if (token == TOKEN_KEYWORD_PAD) local_exports.pad= s_as_bool;
      if (token == TOKEN_KEYWORD_LAST) local_exports.last= s_as_bool;
      if (token == TOKEN_KEYWORD_DIVIDER) local_exports.divider= s_as_bool;
    }
    /* Todo: what if it's a number? or a constant like FALSE? */
    if ((token == TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE) || (token == TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE))
    {
      s= text.mid(export_token_offsets[i], export_token_lengths[i]);
      s= connect_stripper(s, false);
      i_prev_1= next_i_v(i, -1, export_token_types, export_token_lengths);         /* presumably BY */
      i_prev_2= next_i_v(i_prev_1, -1, export_token_types, export_token_lengths);

      token_prev_2= export_token_types[i_prev_2];

      if (lines_or_columns == TOKEN_KEYWORD_COLUMNS)
      {
        if (token_prev_2 == TOKEN_KEYWORD_ENCLOSED) local_exports.columns_enclosed_by= to_byte_array(s);
        else if (token_prev_2 == TOKEN_KEYWORD_ESCAPED)
        {
          local_exports.columns_escaped_by= to_byte_array(s);
          if (local_exports.columns_escaped_by.length() > 1)
          {
            error_message= "ESCAPED BY maximum length = 1";
            goto ok_return;
          }
        }
        else if (token_prev_2 == TOKEN_KEYWORD_TERMINATED) local_exports.columns_terminated_by= to_byte_array(s);
        else { error_message= "COLUMNS BAD?"; goto ok_return; }
      }
      if (lines_or_columns == TOKEN_KEYWORD_LINES)
      {
        if (token_prev_2 == TOKEN_KEYWORD_STARTING) local_exports.lines_starting_by= to_byte_array(s);
        else if (token_prev_2 == TOKEN_KEYWORD_TERMINATED) local_exports.lines_terminated_by= to_byte_array(s);
        else { error_message= "LINES BAD?"; goto ok_return; }
      }
    }
  }

  if (local_exports.file_name != "")
  {
    main_exports= local_exports;
    if (history_file_start("TEE", local_exports.file_name, &rr) == 0)
    {
      make_and_put_open_message_in_result(ER_FILE_OPEN, 0, rr);
      goto ok_ok_return;
    }
    else
    {
      goto ok_return;
    }
  }
ok_return: /* bad name, might not be okay, error_message decides that */
  if (error_message > "")
  {
    /* Todo: you could add the word "Error" and the token number and the token string */
    /* You want make_and_put_message_in_result but with ostrings that expects %, unlike E_ERROR */
    error_message= "Error " + error_message;
    put_message_in_result(error_message);
    return error_message;
  }
  if (rr == "") make_and_put_message_in_result(ER_OK, 0, (char*)"");
  else make_and_put_open_message_in_result(ER_OK_PLUS, 0, rr);
ok_ok_return:
  main_exports= local_exports;
  export_set_checked();
  return error_message;
}

/*
  Called from import_export_rule_set() or when user choice = cancel for an export dialog box.
  Menu items are in a QActionGroup so setting one choice will unset other choices.
  Re menu: If we got to import_export_rule_set() because user clicked a choice, then that choice already
           has a check mark beside it, it happens before we get here. Usually that's fine, it's no change.
           But if we put up the dialog box and user chooses cancel, that's not fine, go back to prior choice.
*/
void MainWindow::export_set_checked()
{
  if (main_exports.type == TOKEN_KEYWORD_TEXT) menu_file_export_text_action->setChecked(true);
  if (main_exports.type == TOKEN_KEYWORD_TABLE) menu_file_export_table_action->setChecked(true);
  if (main_exports.type == TOKEN_KEYWORD_HTML) menu_file_export_html_action->setChecked(true);
  if (main_exports.type == TOKEN_KEYWORD_NONE) menu_file_export_none_action->setChecked(true);
}
#endif

/*
  Re TOKEN_KEYWORD_IMPORT:
    Currently for importing this is only called due to explorer_widget but probably it should be on main menu.
    We will recommend LOAD DATA because it is much much faster but import() may still be useful because:
    there are more options, every INSERT is loggable, special privilege is not required.
  Re TOKEN_KEYWORD_SOURCE:
    Todo: allow for comments and ;
    Todo: if we fill up the line, return an overflow message,
       or make line[] bigger and re-read the file.
    Executing the source-file statements is surprisingly easy: just put them in
       the statement widget. This should be activating action_statement_edit_widget_changed
       and that ultimately causes execution.
       Handling multiple statements per line is okay, but SOURCE may not be witin multi-line.
       Difference from mysql client: this puts source-file statements in history, mysql client puts "source" statement.
    Todo: stop recursion i.e. source statement within source statement. That's an error.
  TODO: Would it be good if we could abort source statements with ^C?
  TODO: Check for io error / premature eof
  TODO: This is skipping comment lines and blank lines, that's probably unnecessary.
  Todo: progress bar showing far we've progressed compared to file size in bytes.
  Todo: Kill should not just mean kill the last statement_widget sttement, it should mean kill the whole thing.
  Todo: Find out why make_and_put_open_message_in_result doesn't show up.
        Would it show up if we said action_execute(1)?
  Todo: Optional initial pass just to check whether everything is valid.
*/
int MainWindow::read_file(int keyword, QString s, QString table_name)
{
  log("read_file start", 70);
  QFile file(s);
  bool open_result= file.open(QIODevice::ReadOnly | QIODevice::Text);
  if (open_result == false)
  {
    make_and_put_open_message_in_result(ER_FILE_OPEN, 0, file.errorString());
    return 1;
  }
  /* Todo: this gets rid of SOURCE statement, but maybe it should be a comment in history. */
  statement_edit_widget->clear();
  QByteArray source_line;
  for (;;)
  {
    if (file.atEnd() == true) break;
    source_line= "";
    source_line= file.readLine();
    QString s= source_line;
    s= connect_stripper(s, false);
    if ((s != "") && (s.mid(0,1) != "#") && (s.mid(0,2) != "--"))
    {
      if (keyword == TOKEN_KEYWORD_SOURCE)
        statement_edit_widget->insertPlainText(s);
      else /* TOKEN_KEYWORD_IMPORT */
      {
        if (s.right(1) == "\n") s= s.left(s.size() - 1);
        if (s.right(1) == "\r") s= s.left(s.size() - 1);
        QString insert_statement= "INSERT INTO " + table_name + " VALUES (" + s + ");";
        statement_edit_widget->insertPlainText(insert_statement);
      }
      if (action_execute(0) == 2)
      {
        /*
          A DBMS-calling statement failed.
          This doesn't operate exactly as --abort-source-on-error
          would for MariaDB client, because we only return 2 for
          statements that call the server and are not multiple.
        */
        if (ocelot_abort_source_on_error > 0) break;
      }
   }
  }
  file.close();
  log("read_file end", 70);
  return 0;
}

QString MainWindow::statement_format_rule_apply(QString main_token, int main_token_type, unsigned char main_token_reftype, unsigned int main_token_flag, int *rule_token_offsets, int *rule_token_lengths, int *rule_token_types)
{
  (void) main_token_reftype; /* suppress "unused parameter" warning */
  (void) main_token_flag; /* suppress "unused parameter" warning */
  /* main_token_type might be an unreserved keyword but in context be used as an identifier */
  //if ((main_token_type >= TOKEN_KEYWORDS_START)
  // && ((main_token_flag & TOKEN_FLAG_IS_RESERVED) == 0)
  // && (main_token_reftype == TOKEN_REFTYPE_ANY))
  //  main_token_type= TOKEN_TYPE_IDENTIFIER;
  QString rule_token, replacee, replacer;
  int rule_type, rule_modifier_type;
  int i= 0;
  int match_type= 0; /* 0 is not match, 1 is = match, 2 is category match */
  for (; rule_token_lengths[i] != 0;)
  {
    replacee= "";
    replacer= "";
    bool is_becomes_seen= false;
    match_type= 0;
    for (; rule_token_lengths[i] != 0; ++i)
    {
      rule_token= ocelot_statement_format_rule.mid(rule_token_offsets[i], rule_token_lengths[i]);
      rule_type= rule_token_types[i];
      rule_modifier_type= 0;
      if ((rule_token_lengths[i + 1] == 1)
       && (ocelot_statement_format_rule.mid(rule_token_offsets[i + 1], 1) == "-")
       && (rule_token_lengths[i + 2] != 0))
      {
        i+= 2;
        rule_modifier_type= rule_token_types[i];
      }
      if (rule_type == TOKEN_KEYWORD_BECOMES)
      {
        is_becomes_seen= true;
        continue;
      }
      if (rule_type == TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_RULE) /* won't happen */
      {
        continue;
      }
      if ((rule_token == ",") || (rule_token == ";")) break;
      if (is_becomes_seen == false)
      {
        if (rule_type == TOKEN_KEYWORD_COMMENT)
        {
          if ((main_token_type >= TOKEN_TYPE_COMMENT_WITH_SLASH)
           && (main_token_type <= TOKEN_TYPE_COMMENT_WITH_MINUS))
          {
            replacee= main_token;
            match_type= 2;
          }
        }
        else if (rule_type == TOKEN_KEYWORD_IDENTIFIER)
        {
          if ((main_token_type >= TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK)
           && (main_token_type <= TOKEN_TYPE_IDENTIFIER_WITH_AT))
          {
            replacee= main_token;
            match_type= 2;
          }
        }
        if (rule_type == TOKEN_KEYWORD_KEYWORD)
        {
          if (main_token_type >= TOKEN_KEYWORDS_START)
          {
            replacee= main_token;
            match_type= 2;
          }
        }
        else if (rule_type == TOKEN_KEYWORD_LITERAL)
        {
          if ((main_token_type >= TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE)
           && (main_token_type <= TOKEN_TYPE_LITERAL_WITH_BRACE))
          {
            replacee= main_token;
            match_type= 2;
          }
        }
        if (rule_type == TOKEN_KEYWORD_OPERATOR)
        {
          if (main_token_type == TOKEN_TYPE_OPERATOR)
          {
            replacee= main_token;
            match_type= 2;
          }
        }
        else
        {
          if ((main_token == rule_token) && (rule_type != TOKEN_KEYWORD_KEYWORD))
          {
            replacee= rule_token;
            match_type= 1;
          }
        }
        if ((rule_modifier_type == TOKEN_KEYWORD_UPPER)
         && (main_token.toUpper() != main_token))
          match_type= 0;
        if ((rule_modifier_type == TOKEN_KEYWORD_LOWER)
         && (main_token.toLower() != main_token))
          match_type= 0;
      }
      else /* is_becomes_seen == true */
      {
        if (match_type > 0)
        {
          if (match_type == 2)
          {
            /* if category matched and this is category keyword */
            if ((rule_type == TOKEN_KEYWORD_COMMENT)
             || (rule_type == TOKEN_KEYWORD_IDENTIFIER)
             || (rule_type == TOKEN_KEYWORD_LITERAL)
             || (rule_type == TOKEN_KEYWORD_KEYWORD)
             || (rule_type == TOKEN_KEYWORD_OPERATOR))
            rule_token= replacee;
          }
          if (rule_modifier_type == TOKEN_KEYWORD_UPPER) rule_token= rule_token.toUpper();
          if (rule_modifier_type == TOKEN_KEYWORD_LOWER) rule_token= rule_token.toLower();
          if (rule_type == TOKEN_KEYWORD_COMMA) rule_token= ",";
          if (rule_type == TOKEN_KEYWORD_NEWLINE) rule_token= "\n";
          if (rule_type == TOKEN_KEYWORD_SEMICOLON) rule_token= ";";
          if (rule_type == TOKEN_KEYWORD_SPACE) rule_token= " ";
          if (rule_type == TOKEN_KEYWORD_TAB) rule_token= "\t";
          replacer.append(rule_token);
        }
      }
    }
    if (match_type > 0) break;
    if (rule_token == ";") break;
    ++i;
  }
  if (match_type > 0) return replacer;
  return main_token;
}

/*
  The event filter, for detecting:
    Has the user pressed on the vertical scroll bar of result_grid_widget?
    Has the user pressed Enter or return on statement_edit_widget?
      If the user presses Enter or Return on statement_edit_widget,
      and the last non-comment token is the delimiter (normally ";" unless DELIMITER happened),
      and the cursor is at the end i.e. after the delimiter,
      that should cause execution.
      Otherwise return false ...
      I've seen examples where, instead of "return false;", the
      instruction is "return QMainWindow::eventFilter(obj, event);".
      I think the idea there is to go direct to the main processor
      for text editing, bypassing other event filters.
  Note: statement_edit_widget mouseMoveEvent handling is in ocelotgui.h
  Todo: Consider: Perhaps this should not be in MainWindow:: but in CodeEditor::.
  Todo: Consider: Perhaps this should be a menu item, not a filter event.
                  (There's already a menu item, but it's not for Enter|Return.)
  There are a few "ocelotgui keyword" items that do not require ";" or delimiter
  provided they're the first word, for example "QUIT".
*/
bool MainWindow::eventFilter(QObject *obj, QEvent *event)
{
  return eventfilter_function(obj, event);
}

bool MainWindow::eventfilter_function(QObject *obj, QEvent *event)
{
  /*
    We got crashes in a long-running loop, ocelot_date_test().
    I figured it was because for long-running queries we set a flag and
    start a separate thread and loop with sleep + processEvents() so
    we can get here. I think this line added on 2019-01-01 prevents crashing.
    Todo: find out what the problem event is. Am I returning "true" wrongly?
    Warn: Now only shortcuts will work, the Ubuntu workaround won't be seen.
  */

  if (dbms_long_query_state == LONG_QUERY_STATE_STARTED) return false;

//  if (obj == result_grid_table_widget[0]->grid_vertical_scroll_bar)
//  {
//    /*
//      Probably some of these events don't cause scroll bar value to change,
//      I've only seen that happen for MouseMove and MouseButtonRelease.
//      But that's harmless, it only means we call scroll_event for nothing.
//    */
//    if ((event->type() == QEvent::KeyPress)
//    ||  (event->type() == QEvent::KeyRelease)
//    ||  (event->type() == QEvent::MouseButtonDblClick)
//    ||  (event->type() == QEvent::MouseButtonPress)
//    ||  (event->type() == QEvent::MouseButtonRelease)
//    ||  (event->type() == QEvent::MouseMove)
//    ||  (event->type() == QEvent::MouseTrackingChange)) return (result_grid_table_widget->scroll_event());
//  }
//  QString text; /* This is unused now */

  if (event->type() == QEvent::FocusIn)
  {
    menu_activations(obj, QEvent::FocusIn);
    if ((obj == statement_edit_widget) || (obj == completer_widget))
    {
      if (completer_widget->isHidden() == false)
      {
        completer_widget->timer_reset();
      }
    }
    else completer_widget->hide_wrapper();
    return false;
  }

  if (event->type() == QEvent::FocusOut)
  {
    menu_activations(obj, QEvent::FocusOut);
    return false;
  }

  {
    ResultGrid* r;
#if (OCELOT_EXPLORER == 1)
    for (int i_r= -1; i_r < ocelot_grid_actual_tabs; ++i_r)
#else
    for (int i_r= 0; i_r < ocelot_grid_actual_tabs; ++i_r)
#endif
    {
#if (OCELOT_EXPLORER == 1)
      if (i_r == -1) { r= explorer_widget; if (r == NULL) continue; }
      else
#endif
      r= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(i_r));
      if (obj == r)
      {
        if (event->type() == QEvent::FontChange) return (r->fontchange_event());
        if (event->type() == QEvent::Show) return (r->show_event());
      }
      if (obj == r->grid_vertical_scroll_bar)
      {
        return (r->vertical_scroll_bar_event(event, connections_dbms[0]));
      }
    }
  }
#if (OCELOT_MYSQL_DEBUGGER == 1)
  for (int debug_widget_index= 0; debug_widget_index < DEBUG_TAB_WIDGET_MAX; ++debug_widget_index)
  {
    if (obj == debug_widget[debug_widget_index])
    {
      if (event->type() == QEvent::MouseButtonPress)
      {
        action_debug_mousebuttonpress(event, debug_widget_index);
        return false;
      }
    }
  }
#endif

  if (event->type() != QEvent::KeyPress) return false;
  QKeyEvent *key= static_cast<QKeyEvent *>(event);
  /* See comment with label "Shortcut Duplication" */

  if (keypress_shortcut_handler(key, false) == true) return true;
  if (obj != statement_edit_widget) return false;
  if ((key->key() == Qt::Key_Down) && (completer_widget->key_up_or_down(+1))) return true;
  if ((key->key() == Qt::Key_Up) && (completer_widget->key_up_or_down(-1))) return true;
  if ((key->key() != Qt::Key_Enter) && (key->key() != Qt::Key_Return)) return false;
  /* No delimiter needed if Ctrl+Enter, which we'll regard as a synonym for Ctrl+E */
  if (key->modifiers() & Qt::ControlModifier)
  {
    action_execute(1);
    return true;
  }

  /*
    It's just Enter.
    If it's not at the end, not counting white space, don't try to execute.
    Anyway, don't force.
  */
  if (statement_edit_widget->textCursor().atEnd() == false)
  {
    int cursor_position= statement_edit_widget->textCursor().position();
    QString plain_text= statement_edit_widget->toPlainText();
    for (int i= cursor_position; i < plain_text.size(); ++i)
    {
      if (plain_text.mid(i, 1) > " ") return false;
    }
  }
  if (action_execute(0) == 1) return false;
  return true;
}

/*
  There are two reasons for keypress_shortcut_handler() to exist:
  1: see comment = "Shortcut duplication"
  2: we call not only from MainWindow::eventfilter_function()
     but also from TextEditWidget::keyPressEvent().
  If the keypress is a shortcut, we handle it and return true.
  If it's not, then it's probably text input, we return false.
  There is one situation that we do not handle:
    TextEditWidget handles ocelot_shortcut_copy_keysequence separately.
  Todo: Maybe event->matches() is a more standard way to compare.
  Todo: Now there's useless code -- we have setShortcut() for most of
        these combinations, but keypress_shortcut_handler() happens
        first (?? I think), so they're useless. But a few things are
        still handled by shortcuts, maybe, and if one fails try the other.
  Todo: can we get here for a disabled menu item? I think it's possible
        if we're coming not from edit filter but from textedit key press
        event, so we should check "isenabled()" for more things.
  Todo: if e.g. menu_edit_undo() does nothing because it can't find the
        classname, it should return false so keypress_shortcut_handler()
        can return false. Currently these things are all void.
  Todo: the system hasn't been tested with detached debugger widgets
        for which we've said SET ocelot_shortcut_...='something odd'.
*/
bool MainWindow::keypress_shortcut_handler(QKeyEvent *key, bool return_true_if_copy)
{
  Qt::KeyboardModifiers modifiers= key->modifiers();
  int qki= 0;
  if ((modifiers & Qt::ControlModifier) != 0) qki= (qki | Qt::CTRL);
  if ((modifiers & Qt::ShiftModifier) != 0) qki= (qki | Qt::SHIFT);
  if ((modifiers & Qt::AltModifier) != 0) qki= (qki | Qt::ALT);
  if ((modifiers & Qt::MetaModifier) != 0) qki= (qki | Qt::META);
  QKeySequence qk= QKeySequence(key->key() | qki);
#if (OCELOT_EXPLORER == 1)
  if (explorer_widget != NULL)
  {
    if (explorer_widget->html_text_edit->explorer_context_menu->shortcutter(qk) == true) return true;
  }
#endif
  if ((qk == ocelot_shortcut_copy_keysequence)
   && (return_true_if_copy)) return true;
  if (qk == ocelot_shortcut_connect_keysequence) { action_connect(); return true; }
  if (qk == ocelot_shortcut_exit_keysequence) { action_exit(); return true; }
  if (qk == ocelot_shortcut_undo_keysequence) { menu_edit_undo(); return true; }
  if (qk == ocelot_shortcut_redo_keysequence) { menu_edit_redo(); return true; }
  if (qk == ocelot_shortcut_cut_keysequence) { menu_edit_cut(); return true; }
  if (qk == ocelot_shortcut_copy_keysequence) { menu_edit_copy(); return true; }
  if (qk == ocelot_shortcut_paste_keysequence) { menu_edit_paste(); return true; }
  if (qk == ocelot_shortcut_select_all_keysequence) { menu_edit_select_all(); return true; }
  if (qk == ocelot_shortcut_history_markup_previous_keysequence) { history_markup_previous(); return true; }
  if (qk == ocelot_shortcut_history_markup_next_keysequence) { history_markup_next(); return true; }
  if (qk == ocelot_shortcut_execute_keysequence){ action_execute(1); return true; }
  if (qk == ocelot_shortcut_format_keysequence){ statement_edit_widget_formatter(); return true; }
  if (qk == ocelot_shortcut_zoomin_keysequence){menu_edit_zoomin(); return true; }
  if (qk == ocelot_shortcut_zoomout_keysequence){menu_edit_zoomout(); return true; }
  if (qk == ocelot_shortcut_autocomplete_keysequence)
  {
    return menu_edit_autocomplete();  /* even if menu_edit_action_autocomplete->isEnabled() == false */
  }
#if (OCELOT_FIND_WIDGET == 1)
  if (qk == ocelot_shortcut_find_keysequence){menu_edit_find(); return true; }
#endif
  if (menu_run_action_kill->isEnabled() == true)
  {
    if (qk == ocelot_shortcut_kill_keysequence) { action_kill(); return true; }
  }
  if (qk == ocelot_shortcut_next_window_keysequence){action_option_next_window(); return true; }
  if (qk == ocelot_shortcut_previous_window_keysequence){action_option_previous_window(); return true; }
  if (qk == ocelot_shortcut_batch_keysequence){action_option_batch(); return true; }
  if (qk == ocelot_shortcut_horizontal_keysequence){action_option_horizontal(); return true; }
  if (qk == ocelot_shortcut_html_keysequence){action_option_html(); return true; }
  if (qk == ocelot_shortcut_htmlraw_keysequence){action_option_htmlraw(); return true; }
  if (qk == ocelot_shortcut_raw_keysequence){action_option_raw(); return true; }
  if (qk == ocelot_shortcut_vertical_keysequence){action_option_vertical(); return true; }
  if (qk == ocelot_shortcut_xml_keysequence){action_option_xml(); return true; }
#if (OCELOT_MYSQL_DEBUGGER == 1)
  if (menu_debug_action_breakpoint->isEnabled())
    if (qk == ocelot_shortcut_breakpoint_keysequence) { action_debug_breakpoint(); return true; }
  if (menu_debug_action_continue->isEnabled())
    if (qk == ocelot_shortcut_continue_keysequence) { action_debug_continue(); return true; }
  if (menu_debug_action_next->isEnabled())
    if (qk == ocelot_shortcut_next_keysequence) { action_debug_next(); return true; }
  if (menu_debug_action_step->isEnabled())
    if (qk == ocelot_shortcut_step_keysequence) { action_debug_step(); return true; }
  if (menu_debug_action_clear->isEnabled())
    if (qk == ocelot_shortcut_clear_keysequence) { action_debug_clear(); return true; }
  if (menu_debug_action_exit->isEnabled())
    if (qk == ocelot_shortcut_debug_exit_keysequence) { action_debug_exit(); return true; }
  if (menu_debug_action_information->isEnabled())
    if (qk == ocelot_shortcut_information_keysequence) { action_debug_information(); return true; }
  if (menu_debug_action_refresh_server_variables->isEnabled())
    if (qk == ocelot_shortcut_refresh_server_variables_keysequence) { action_debug_refresh_server_variables(); return true; }
  if (menu_debug_action_refresh_user_variables->isEnabled())
    if (qk == ocelot_shortcut_refresh_user_variables_keysequence) { action_debug_refresh_user_variables(); return true; }
  if (menu_debug_action_refresh_variables->isEnabled())
    if (qk == ocelot_shortcut_refresh_variables_keysequence) { action_debug_refresh_variables(); return true; }
  if (menu_debug_action_refresh_call_stack->isEnabled())
    if (qk == ocelot_shortcut_refresh_call_stack_keysequence) { action_debug_refresh_call_stack(); return true; }
#endif
  return false;
}


/*
  We want to know: do we have a complete statement at the string start.
  So we find out how many tokens are in the (first) statement.
  We go forward to find the first non-comment token, the statement type.
  We go backward to find the final non-comment token, the ; or delimiter -- or not.
  Using these, and knowing what is ocelot_delimiter_str, we can decide if it's complete.
  We also check for \G or \g.
*/

bool MainWindow::is_statement_complete(QString text)
{
  int number_of_tokens_in_statement= 0;
  int returned_begin_count= 0;
  int i= 0;
  int first_token_type= -1;
  int first_token_i= 0;
  //int last_token_type= -1;
  QString first_token= "";
  QString last_token= "";
  QString second_last_token= "";
  number_of_tokens_in_statement= get_next_statement_in_string(0, &returned_begin_count, false);
  for (i= 0; i < number_of_tokens_in_statement; ++i)
  {
    int t= main_token_types[i];
    if (t == TOKEN_TYPE_COMMENT_WITH_SLASH) continue;
    if (t == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE) continue;
    if (t == TOKEN_TYPE_COMMENT_WITH_MINUS) continue;
    first_token_type= t;
    first_token= text.mid(main_token_offsets[i], main_token_lengths[i]);
    first_token_i= i;
    break;
  }
  for (i= number_of_tokens_in_statement - 1; i >= 0; --i)
  {
    int t= main_token_types[i];
    if (t == TOKEN_TYPE_COMMENT_WITH_SLASH) continue;
    if (t == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE) continue;
    if (t == TOKEN_TYPE_COMMENT_WITH_MINUS) continue;
    //last_token_type= t;
    last_token= text.mid(main_token_offsets[i], main_token_lengths[i]);
    if (i > 0) second_last_token= text.mid(main_token_offsets[i - 1], main_token_lengths[i - 1]);
    break;
  }
  /* No delimiter needed if first word in first statement of the input is an ocelotgui keyword e.g. QUIT */
  /* Todo: this means that a client statement cannot be spread over two lines but for SET client-statement we wait for ; */
  if (is_client_statement(first_token_type, first_token_i, text) == true)
  {
    if (first_token_type != TOKEN_KEYWORD_SET) return true;
  }

  /* "go" or "ego", alone on the line, if --named-commands, is statement end */
  /* Todo: but these are client statements so we won't ever get here */
  /* Todo: I forget why we care. Is it in fact because the token is \G or \g? */
  if ((ocelot_named_commands > 0)
  && ((first_token_type == TOKEN_KEYWORD_GO) || (first_token_type == TOKEN_KEYWORD_EGO)))
  {
    QString q;
    for (int i_off= main_token_offsets[i] - 1;; --i_off)
    {
      if (i_off < 0) q= "\n";
      else q= text.mid(i_off, 1);
      if ((q == "\n") || (q == "\r"))
      {
        return true;
      }
      if (q != " ") break;
    }
  }

  /* if create-routine && count-of-ENDs == count-of-BEGINS then ; is the end else ; is not the end */
  if (ocelot_delimiter_str != ";") returned_begin_count= 0;
  else
  {
    int token_count= get_next_statement_in_string(0, &returned_begin_count, false);
    if (returned_begin_count == 0)
    {
      if (QString::compare(last_token, ";", Qt::CaseInsensitive) == 0)
      {
        /* Warning: this only works if we've gone through hparse */
        /* plsql routines might have var|cursor|condition before begin */
        if ((main_token_flags[token_count - 1] & TOKEN_FLAG_IS_PLSQL_DECLARE_SEMICOLON) != 0)
        {
          for (int k= token_count - 1;;--k)
          {
            if (main_token_types[k] == TOKEN_KEYWORD_BEGIN) break;
            if (k == 0)
            {
              /* saw no begin but flag counts as a begin */
              ++returned_begin_count;
              break;
            }
          }
        }
        if (returned_begin_count == 0) return true;
      }
      if (QString::compare(last_token, "G", Qt::CaseInsensitive) == 0)
      {
        if (QString::compare(second_last_token, "\\", Qt::CaseInsensitive) == 0)
        {
          return true;
        }
      }
    }
  }
  if (last_token != ocelot_delimiter_str)
  {
    return false;
  }

  if (returned_begin_count > 0)
  {
    return false;
  }
  /* All conditions have been met. Tell caller to Execute, and eat the return key. */
  return true;
}


/*
  History
  =======

  The history widget history_edit_widget is an editable subclass of QTextEdit
  which contains retired statements + errors/warnings, scrolling
  so it looks not much different from the mysql retired-statement
  scrolling.
  However, our history does not include result sets (unless
  result_set_for_history, described later).
  These user-settable variables affect history_edit_widget:
  ocelot_history_text|background|border_color      default = system
  ocelot_history_font_family|size|style|weight     default = system
  ocelot_history_includes_warnings                 default = 0 (no)
  ocelot_history_max_row_count                     default = 0 (suppressed)
  ocelot_history_{left|top|width|height}           default
  ocelot_histfileflags                             (default is "L") see also HIST and HISTIGNORE
  ocelot_histfilesize                              (default is "2000000000")
  ocelot_histsize                                  (default is "500")

  The statement is always followed by an error message,
  but ocelot_history_includes_warnings is affected by ...
  warnings  (\W) Show warnings after every statement.
  nowarning (\w) Don't show warnings after every statement.
  If the prompt is included, then we should be saving time-of-day
  for the first statement-line prompt and doing prompt_translate()
  for each line of the statement when we copy it out.
  The history_edit_widget is TextEditHistory which is derived from
  QTextEdit, differing from statement_edit_widget which is CodeEditor
  which is derived from QPlainTextEdit.

  History menu items / commands:
  * The usual edit menu items = cut, copy, paste, etc.
    Therefore we don't really need to limit history size, users can clear.
  * Previous Statement ^P and Next Statement ^N
    ? Possible alternatives: alt+up-arrow|alt+down-arrow, PgUp|PgDn
    ? Possible alternative: up-arrow if we're at top of statement widget
      (which is more like what mysql client would do)
    * disable if there's no previous / next
    * if done on statement widget, brings in from history -- dunno if history should scroll when that happens
    ? when bringing in from history to statement, don't re-execute
    * if user executes a restated statement, there's a behaviour choice: now the restated statement is last statement, or now the last-picked statement is still last statement
  * Open | Save | Close | Delete (not implemented)
    * file items, with the intent of keeping history
    * you can go back in history by going back in a file
    * format should be the same as MySQL log history
      ? but in that case, should display look like MySQL log too?
    * Save means "save what's being shown, so it's affected by Hide
  * Find | Goto
    * you need these menu items for history soon, so might as well have them for statements too
  * Hide prompt + Hide result + Hide result set
  + Settings: History Widget has different colors for prompt/statement/result/result set

  Comments unrelated to HTML work:
  Possible difficulty: our history is statement-at-a-time, not screen-at-a-time", if there are multi statements
  Certain statements might be suppressed
    * should Quit and Source go in history?
    * should only data-change statements go in history?
    * should client-statements be suppressed?
    * this is a "Filter" matter
    ? to what extent is this useful for audit?
    Wherever there's a menu item, there should also be a client-statement
    * history must include comments even if they're not sent to the server (there's some mysql-option for that)
    * Delimiter might change, so when you copy from history to statement, what should you do?
    * When the debugger comes in, statements done by the debugger are a special history category

  HTML in the history widget
  Unlike statement_edit_widget, history_edit_widget is TextEditHistory
  derived from QTextEdit and allows rich text, editable, containing HTML.
  Each history entry has: prompt, statement, result, and possibly result set.
  (Result set depends on ocelot_history_max_row_count, 0 by default, and
  see copy_to_history, it's supposed to appear like mysql client result set.)
  There are two kinds of markup:
  (1) <span style="...">...</span> for changes to color + font.
      Currently this is only used for history prompt bgcolor = statement prompt bgcolor.
  (2) <a name='[mark]'> for showing what kind of text follows.
      The markups are <a name='STATEMENT START'> ... <a name='STATEMENT END'>
                <a name='PROMPT START'> ... <a name='PROMPT END'>
                <a name='RESULT'> (ends when statement ends)
                <a name='ENTITY'> (always an entity for a single & character)
      Digia does not document or guarantee what it will do with <a>
      and we're not using it for its intended function as anchor.
      Example: "SELECT * FROM t <br> WHERE x < '&';" becomes
      <a name='STATEMENT START'>
      <span ...><a name='PROMPT'>mysql&gt;<a name='PROMPT END'></span>
      SELECT * FROM t <br>
      <a name='PROMPT'>&gt;<a name='PROMPT END'>
      WHERE a &lt; '<a name='ENTITY'>&amp;';
      <span ...><a name='RESULT'>OK</span>
      <a name='STATEMENT END'>
  Handle PgUp | PgDn by picking up next | previous STATEMENT START ... END.
  When copying to history, change < and > and & to entities but mark if '&'.
    Also: change ' and " to entities.
  When copying from history, change entities to < and > and & unless marked.
  Todo: hide prompt + result by putting whole thing within <a name='...'>.
  In order to see the HTML, say:
    QMessageBox msgBox;
    msgBox.setTextFormat(Qt::PlainText);
    msgBox.setText(history_edit_widget->toHtml());
    msgBox.exec();
  History is editable.
    If the user inputs "<" when editing the history,
    change that to an entity immediately -- but maybe Qt will do that.
  Idea: use QTextCursor to change cursor in history if PgUp|PgDn in statement.
  Idea: multiple types of result: warning, error, result set
*/

void MainWindow::initialize_widget_history()
{
  history_edit_widget->setStyleSheet(ocelot_history_style_string);
  history_edit_widget->setReadOnly(false);       /* if history shouldn't be editable, set to "true" here */
  history_edit_widget->hide();                   /* hidden until a statement is executed */
  history_markup_make_strings();
  history_edit_widget->installEventFilter(this); /* must catch focusIn */
  return;
}


/*
  Set the strings that will be used for markup comments in history widget.
  Call history_markup_make_strings() at program start.
  Todo: At the moment these could be constants but I don't think they always will be.
  Note: <br> in history_markup_statement_start is necessary; else prompt_start is ignored.
*/
void MainWindow::history_markup_make_strings()
{
  history_markup_statement_start= "<a name=\"STATEMENT START\"></a><br>";
  history_markup_statement_end=   "<a name=\"STATEMENT END\"></a>";
  history_markup_prompt_start=    "<a name=\"PROMPT START\"></a>";
  history_markup_prompt_end=      "<a name=\"PROMPT END\"></a>";
  history_markup_result=          "<a name=\"RESULT\"></a>";
  history_markup_entity=          "<a name=\"ENTITY\"></a>";
}


/* The following will append the statement to history, line-at-a-time with prompts. */
/* It seems to work except that the prompt is not right-justified. */
/* is_interactive == false if we're reading from mysql_histfile during start */
/* Todo: right justify. Make it optional to show the prompt, unless prompt can be hidden. */
void MainWindow::history_markup_append(QString result_set_for_history, bool is_interactive)
{
  QString plainTextEditContents;
  QStringList statement_lines;
  int statement_line_index;
  QString history_statement;
  plainTextEditContents= query_utf16; /* Todo: consider: why bother copying rather than using query_uitf16? */
  statement_lines= plainTextEditContents.split("\n");
  //statement_line_index= 0;                                                          /* Todo throw this useless line away */
  /* Todo: There should be a better way to ensure that Qt realizes the whole widget is rich text. */
  /* Todo: Some of this could be at start of history_edit_widget but what would happen if I cleared the whole area? */
  /* Todo: background-color of prompt could be settable for history widget, rather than = statement background color. */
  history_statement= "<i></i>";                                           /* hint that what's coming is HTML */
  history_statement.append(history_markup_statement_start);

  for (statement_line_index= 0; statement_line_index < statement_lines.count(); ++statement_line_index)
  {
    history_statement.append("<span style=\" background-color:");
    history_statement.append(ocelot_statement_prompt_background_color);
    history_statement.append(";\">");
    history_statement.append(history_markup_prompt_start);
    if (is_interactive == true) history_statement.append(history_markup_copy_for_history(statement_edit_widget->prompt_translate(statement_line_index + 1)));
    else history_statement.append("-");
    history_statement.append(history_markup_prompt_end);
    history_statement.append("</span>");
    history_statement.append(history_markup_copy_for_history(statement_lines[statement_line_index]));
    history_statement.append("<br>");
  }

  history_statement.append(history_markup_result);
  if (is_interactive == true)
    history_statement.append(history_markup_copy_for_history(statement_edit_widget->result)); /* the main "OK" or error message */
  else history_statement.append("--");
  if (result_set_for_history > "")
  {
    history_statement.append("<pre>");
    history_statement.append(history_markup_copy_for_history(result_set_for_history));
    history_statement.append("</pre>");
  }

  history_statement.append(history_markup_statement_end);

  history_edit_widget->append(history_statement);

  history_markup_counter= 0;

  if (is_interactive == false) return;

  /*  not related to markup, just a convenient place to call */
  history_file_write("HIST", query_utf16, false);
}

void MainWindow::tee_export(QString result_set_for_history)
{
  if (main_exports.query == true) history_file_write("TEE", query_utf16, true);
  if (main_exports.row_count == true) history_file_write("TEE", statement_edit_widget->result, true);
  if (main_exports.max_row_count > 0) /* ? For some reason this was "if result_set_for_history > "" */
  {
#if (OCELOT_IMPORT_EXPORT == 1)
    if (main_exports.type == TOKEN_KEYWORD_HTML)
    {
      /* Todo: There's silly repetition here. You should pass rg to tee_export! */
      ResultGrid *rg;
      rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));
      rg->display_html(0, TOKEN_KEYWORD_OCELOT_EXPORT);
    }
    else if ((main_exports.type == TOKEN_KEYWORD_DEFAULT) || (main_exports.type == TOKEN_KEYWORD_NONE))
    {
      /* todo: TOKEN_KEYWORD_DEFAULT no longer has effect, maybe we'll revive though, as "same as history" */
      history_file_write("TEE", result_set_for_history, true);
    }
    else
    {
      /* assume TEXT or TABLE */
      ResultGrid *rg;
      QString result_set_for_history;
      bool is_vertical= false;
      char file_name[128]; /* should be in the dialog box */
      strcpy(file_name, main_exports.file_name.toUtf8());
      rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));
      result_set_for_history= rg->copy_to_history(main_exports.max_row_count, is_vertical, connections_dbms[0], file_name);
    }
  }
#else
  history_file_write("TEE", result_set_for_history, true);
#endif
}


/* When copying to history, change < and > and & and " to entities. */
/* Change on 2015-03-16: change newline to <br>. */
QString MainWindow::history_markup_copy_for_history(QString inputs)
{
  QString outputs;
  QString c;
  int i;

  outputs= "";
  for (i= 0; i < inputs.length(); ++i)
  {
    c= inputs.mid(i, 1);
    if (c == "<") c= "&lt;";
    if (c == ">") c= "&gt;";
    if (c == "&") c= "&amp;";
    if (c == "\"") c= "&quot;";
    if (c == "\n") c= "<br>";
    outputs.append(c);
  }
  return outputs;
}


/* In response to edit menu "Previous statement" or "Next statement",
   make statement widget contents = a previous statement from history,
   without executing.
   When copying from history, change entities to < and > and & and "
   But the job is much bigger than that.
   Find "STATEMENT START".
   Start copying.
   Skip everything between "PROMPT START" and "PROMPT END".
   Stop copying when you see "RESULT".
*/
void MainWindow::history_markup_previous()
{
  ++history_markup_counter;
  if (history_markup_previous_or_next() == -1) --history_markup_counter;
}


void MainWindow::history_markup_next()
{
  --history_markup_counter;
  if (history_markup_previous_or_next() == -1) ++history_markup_counter;
}


int MainWindow::history_markup_previous_or_next()
{
  QString outputs;
  QString final_outputs;
  int index_of_prompt_end;
  int index_of_a_gt, index_of_lt_a;
  int i;
  QString c;
  int search_start_point;

  QString s;
  int index_of_statement_start;
  int index_of_result;

  s= history_edit_widget->toHtml();
  search_start_point= -1;                                                    /* search starting from end of string */
  for (i= 0;;)
  {
    index_of_statement_start= s.lastIndexOf("\"STATEMENT START\"", search_start_point);
    if (index_of_statement_start == -1) return -1;                           /* (statement start not found) */
    index_of_result= s.indexOf("\"RESULT\"", index_of_statement_start);
    if (index_of_result == -1) return -1;                                    /* (result not found) */
    ++i;
    if (i >= history_markup_counter) break;                                  /* (we're at the right SELECT) */
    search_start_point= index_of_statement_start - 1;                        /* keep going back */
  }
  outputs= "";

  s= s.mid(index_of_statement_start, index_of_result - index_of_statement_start);

  /* At this point s = whatever's between statement start and result */
  /* But there might be a series of repeat(prompt-start prompt-end real-statement) till result */
  for (;;)
  {
    index_of_prompt_end= s.indexOf("\"PROMPT END\"", 0);
    if (index_of_prompt_end == -1) break;
    index_of_a_gt= s.indexOf("a>", index_of_prompt_end) + 2;
    if (index_of_a_gt == -1) break;
    index_of_lt_a= s.indexOf("<a", index_of_a_gt);
    if (index_of_lt_a == -1) break;
    outputs.append(s.mid(index_of_a_gt, index_of_lt_a - index_of_a_gt));
    s= s.mid(index_of_a_gt, -1);
  }

  /* At this point outputs = the statement but it might contain entities
     so reverse whatever happened in history_markup_copy_for_history(),
     and change <br> back to \r.
     Todo: check what happens if original statement contains an entity.
  */
  final_outputs= "";
  for (i= 0; i < outputs.length(); ++i)
  {
    if (outputs.mid(i, 4) == "<br>")
    {
      final_outputs.append("\r");
      i+= 3;
    }
    else if (outputs.mid(i, 6) == "<br />")
    {
      final_outputs.append("\r");
      i+= 5;
    }
    else if (outputs.mid(i, 4) == "&lt;")
    {
      final_outputs.append("<");
      i+= 3;
    }
    else if (outputs.mid(i, 4) == "&gt;")
    {
      final_outputs.append(">");
      i+= 3;
    }
    else if (outputs.mid(i, 5) == "&amp;")
    {
      final_outputs.append("&");
      i+= 4;
    }
    else if (outputs.mid(i, 6) == "&quot;")
    {
      final_outputs.append("\"");
      i+= 5;
    }
    else
    {
      c= outputs.mid(i, 1);
      final_outputs.append(c);
    }
  }

  statement_edit_widget->setPlainText(final_outputs);
  return 0;
}


/*
  tee+hist
  --------
  TEE
  * Code related to tee should have the comment somewhere = "for tee"
  * bool ocelot_history_tee_file_is_open initially is false
  * the options --tee=filename and --no-tee exist, and they are checked (I think)
  * the client statements tee filename and notee will be seen
  * there are no menu options (todo: decide whether this is a flaw)
  * apparently the mysql client would flush, therefore we call flush() after writing
  * the mysql client would include results from queries, but we do so only for TEE (todo: decide whether this is a flaw)
  * there might be html in the output (todo: decide whether this is a flaw)
  HIST
  * read http://ocelot.ca/blog/blog/2015/08/04/mysql_histfile-and-mysql_history/
  * bool ocelot_history_hist_file_is_open initially is false but it's opened if successful connect
  * --batch or --silent or setting name to /dev/null turns history off
  EITHER
  * Ignore if filename is "", is "/dev/null", or is a link to "/dev/null"
  HANDLE ^P AND ^N
    If a statement is multi-line:
      In history_file_write() if ocelot_histfileflags>"" (default is "L"), we precede with a comment:
      -- lines: n
      In history_file_to_history_widget() if we see "-- lines: " we read n lines together
  COMPATIBILITY:
    mysql and ocelotgui can both read and write .mysql_history
    mysql does not have our multi-line trick so won't show multi-line statements correctly
    mysql writes statements that fail, ocelotgui doesn't
    mysql will of course see our added comment line but user can ignore it, or set ocelot_histfileflags
   QRegExp is unavailable in Qt 6. Todo: We have never tested the replacemnt QRegularExpression code.
*/
void MainWindow::history_file_write(QString history_type, QString text_line, bool nflag)  /* see comment=tee+hist */
{
  if (history_type == "TEE")
  {
    if (ocelot_history_tee_file_is_open == false) return;
  }
  else
  {
    if (ocelot_history_hist_file_is_open == false) return;
    /* see Wildcard Matching section in http://doc.qt.io/qt-4.8/qregexp.html */
    int qfrom= 0;
    int qindex;
    QString qs;
    for (;;)
    {
#if (QT_VERSION >= 0x60000)
      QRegularExpression rx;
#else
      QRegExp rx;
#endif
      if (qfrom >= ocelot_histignore.length()) break;
      qindex= ocelot_histignore.indexOf(":", qfrom, Qt::CaseInsensitive);
      if (qindex == -1) qindex= ocelot_histignore.length();
      qs= ocelot_histignore.mid(qfrom, qindex - qfrom);
#if (QT_VERSION >= 0x60000)
      rx= QRegularExpression(qs, QRegularExpression::CaseInsensitiveOption);
      QRegularExpressionMatch match = rx.match(text_line);
      if (match.hasMatch() == true) return;
#else
      rx= QRegExp(qs);
      rx.setPatternSyntax(QRegExp::Wildcard);
      rx.setCaseSensitivity(Qt::CaseInsensitive);
      if (rx.exactMatch(text_line) == true) return;
#endif
      qfrom= qindex + 1;
    }
  }

  QString s= text_line;
  int query_len= s.toUtf8().size();                  /* See comment "UTF8 Conversion" */
  char *query= new char[query_len + 1];
  memcpy(query, s.toUtf8().constData(), query_len + 1);
  query[query_len]= '\0';                            /* todo: think: is this necessary? */
  if (history_type == "TEE")
  {
    ocelot_history_tee_file.write(query, strlen(query));
    /* We need the \n but not an extra \n if we append. */
    if ((main_exports.type == TOKEN_KEYWORD_DEFAULT) || (nflag == true))
    {
      ocelot_history_tee_file.write("\n", strlen("\n"));
    }
    ocelot_history_tee_file.flush();
  }
  else
  {
    if (ocelot_histfileflags > "")
    {
      char f_line[4096];
      int lines_count= 1;
      for (char *cquery= query; *cquery != '\0'; ++cquery) if (*cquery == '\n') ++lines_count;
      char prompt[64 * 3 + 1];
      if (ocelot_histfileflags.contains("P", Qt::CaseInsensitive) == true)
      {
        QString s_prompt= statement_edit_widget->prompt_translate(1);
        if (s_prompt.size() > 64) s_prompt= s_prompt.right(64);
        strcpy(prompt, s_prompt.toUtf8());
      }
      else prompt[0]= '\0';
      sprintf(f_line, "-- lines: %d %s\n", lines_count, prompt);
      ocelot_history_hist_file.write(f_line, strlen(f_line));
    }
    ocelot_history_hist_file.write(query, strlen(query));
    ocelot_history_hist_file.write("\n", strlen("\n"));
    ocelot_history_hist_file.flush();
  }
  delete []query;
}


/* Todo: we're returning a detailed error message for tee but not for hist */
int MainWindow::history_file_start(QString history_type, QString file_name, QString *rr) /* see comment=tee+hist */
{
  *rr= "";
  QString file_name_to_open;
  if (history_type == "TEE")
  {
    file_name_to_open= ocelot_history_tee_file_name;
    if (ocelot_history_tee_file_is_open == true)
    {
      ocelot_history_tee_file.close();
      ocelot_history_tee_file_is_open= false;
    }
  }
  else
  {
    file_name_to_open= ocelot_history_hist_file_name;
    if (ocelot_history_hist_file_is_open == true)
    {
      ocelot_history_hist_file.close();
      ocelot_history_hist_file_is_open= false;
    }
    if (ocelot_batch != 0) return 1;                     /* if --batch happened, no history */
    if (ocelot_silent != 0) return 1;                    /* if --silent happened, no history */
  }

  if (file_name != "") file_name_to_open= file_name;
  int query_len= file_name_to_open.toUtf8().size();  /* See comment "UTF8 Conversion" */
  char *query= new char[query_len + 1];
  memcpy(query, file_name_to_open.toUtf8().constData(), query_len + 1);
  query[query_len]= '\0';                            /* todo: think: is this necessary? */

  /* If file name == "/dev/null" or something that links to "/dev/null", don't try to open. */
  if (file_name_to_open == "/dev/null") { delete []query; return 0; }
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
  char tmp_link_file[9 + 1];
  if (readlink(query, tmp_link_file, 9 + 1) == 9)
  {
    if (memcmp(tmp_link_file, "/dev/null", 9) == 0) {delete []query; return 0; }
  }
#endif

  bool open_result;
  if (history_type == "TEE")
  {
    QString q_file_name= query;
    if (q_file_name.compare("stdout", Qt::CaseInsensitive) == 0)
    {
      /* todo: check: should I be adding other QIODevice flags? */
      open_result= ocelot_history_tee_file.open(stdout, QIODevice::WriteOnly);
      *rr= q_file_name;
    }
    else
    {
      QFileInfo file_info(query);
      QString absolute_file_path= file_info.absoluteFilePath();
      ocelot_history_tee_file.setFileName(query);
      if (strcmp(main_exports.if_file_exists.data(), "error") == 0)
      {
#if (QT_VERSION < 0x50b00)
        /* QT_VERSION < 5.11 at compile-time, but QIODevice::NewOnly was made legal in Qt 5.11 */
        if (file_info.exists() == true) open_result= false;
        else open_result= ocelot_history_tee_file.open(QIODevice::WriteOnly | QIODevice::Text);
#else
        open_result= ocelot_history_tee_file.open(QIODevice::NewOnly | QIODevice::Text);
#endif
      }
      else if (strcmp(main_exports.if_file_exists.data(), "replace") == 0)
      {
        open_result= ocelot_history_tee_file.open(QIODevice::ReadWrite | QIODevice::Truncate | QIODevice::Text);
      }
      else /* strcmp(main_exports.if_file_exists.data(), "append") == 0 */
        open_result= ocelot_history_tee_file.open(QIODevice::Append | QIODevice::Text);
      if (open_result == true) *rr= absolute_file_path;
      else *rr= absolute_file_path + " " + ocelot_history_tee_file.errorString();
    }
    delete []query;
    if (open_result == false) return 0;
    ocelot_history_tee_file_is_open= true;
    ocelot_history_tee_file_name= file_name_to_open;
    return 1;
  }
  else
  {
    ocelot_history_hist_file.setFileName(query);
    open_result= ocelot_history_hist_file.open(QIODevice::Append | QIODevice::Text);
    delete []query;
    if (open_result == false) return 0;
    ocelot_history_hist_file_is_open= true;
    ocelot_history_hist_file_name= file_name_to_open;
    return 1;
  }
  return 0;
}


void MainWindow::history_file_stop(QString history_type)   /* see comment=tee+hist */
{
  if (history_type == "TEE")
  {
    ocelot_history_tee_file.close();
    ocelot_history_tee_file_is_open= false;
  }
  else
  {
    ocelot_history_hist_file.close();
    ocelot_history_hist_file_is_open= false;
  }
}

/*
  This is putting in the history widget, indeed, BUT ...
  Todo: The history widget seems to grow when I type something for the first time
  Todo: Make sure there's no disaster if file is /dev/null or blank.
  We try to open the history file during each connect.
  If we successfully open, but only the first time, we copy its lines to the history widget.
  Re histsize: Read file backward searching for \n, then read forward dumping to history_widget.
  Re histfilesize: If we need to shrink, at end, re-open for write, copy what's kept, truncate.
  We back up statement-at-a-time rather than line-at-a-time if there are -- lines: comments.
  Todo: Do it all with QFile
*/
#define HISTORY_BUFFER_SIZE 8192
#define LINES_SIZE 10
void MainWindow::history_file_to_history_widget()         /* see comment=tee+hist */
{
  char history_buffer[HISTORY_BUFFER_SIZE + LINES_SIZE + 16];
  history_buffer[0]= '\0';
  FILE *history_file;
  if (ocelot_batch != 0) return;                          /* if --batch happened, no history */
  if (ocelot_silent != 0) return;                         /* if --silent happened, no history */
  if (ocelot_history_hist_file_is_copied == true) return;        /* we've alredy done this */
  //if (ocelot_history_hist_file_is_open == false) return;
  {
    int query_len= ocelot_history_hist_file_name.toUtf8().size();  /* See comment "UTF8 Conversion" */
    char *query= new char[query_len + 1];
    memcpy(query, ocelot_history_hist_file_name.toUtf8().constData(), query_len + 1);
    query[query_len]= '\0';                            /* todo: think: is this necessary? */
    history_file= fopen(query, "r");
    delete []query;
  }
  int histfilesize= ocelot_histfilesize.toInt();
  int histsize= ocelot_histsize.toInt();
  int file_size; /* could be size_t but history files won't be multi-gigabyte */
  int file_position;
  int file_position_at_histsize= -1;
  int file_position_at_histfilesize= -1;
  int line_counter= 0;
  if (history_file == NULL) goto returner;
  if (fseek(history_file, 0 , SEEK_END) != 0) {fclose(history_file); goto returner; }
  file_size= ftell(history_file);
  file_position= file_size;
  if (file_size <= histfilesize)
  {
    /* We will not need to truncate */
    if (histsize == 0) {fclose(history_file); goto returner; } /* Don't need to read or write */
    file_position_at_histfilesize= 0;
  }
  if (histsize == 0) file_position_at_histsize= file_size;
  if (histfilesize == 0) file_position_at_histfilesize= 0;
  if (histsize != 0) ++histsize; /* +1 because to go back 5 lines we skip 6 newlines */
  if (histfilesize != 0) ++histfilesize;
  for (;;)
  {
    int file_read_size;
    if (file_position > HISTORY_BUFFER_SIZE) file_read_size= HISTORY_BUFFER_SIZE;
    else file_read_size= file_position;
    file_position-= file_read_size;
    if (file_read_size == 0) break;
    memcpy(history_buffer + file_read_size, history_buffer, LINES_SIZE + 16);
    if (fseek(history_file, file_position, SEEK_SET) != 0) {fclose(history_file); goto returner; }
    int l= fread(history_buffer, 1, file_read_size, history_file);
    if (l != file_read_size) {fclose(history_file); goto returner; }
    for (int j= file_read_size - 1; j >= 0; --j)
    {
      if (*(history_buffer + j) == '\n')
      {
        ++line_counter;
        int statement_line_count= history_line(history_buffer + j + 1);
        if (statement_line_count > 0) line_counter-= statement_line_count; /* partial skip "lines: " */
        if ((line_counter == histsize) || (line_counter == histfilesize))
        {
          int file_position_at_lf= file_position + j;
          if (line_counter == histsize)
          {
            file_position_at_histsize= file_position_at_lf;
          }
          if (line_counter == histfilesize)
          {
            file_position_at_histfilesize= file_position_at_lf;
          }
          if ((file_position_at_histsize != -1) && (file_position_at_histfilesize != -1)) break;
        }
      }
    }
    if ((file_position_at_histsize != -1) && (file_position_at_histfilesize != -1)) break;
  }
  ++file_position_at_histsize; /* ?? what if there's nothing here? */
  if (fseek(history_file, file_position_at_histsize, SEEK_SET) != 0) {fclose(history_file); goto returner; }
  while (fgets(history_buffer, sizeof history_buffer, history_file) != NULL) /* put all non-"" in history  widget */
  {
    int statement_line_count= history_line(history_buffer);
    if (statement_line_count > 0)
    {
      query_utf16= "";
      for (int j= 0; j < statement_line_count; ++j)
      {
        if (fgets(history_buffer, sizeof history_buffer, history_file) == NULL) break;
        query_utf16.append(history_buffer);
      }
    }
    else query_utf16= history_buffer;
    query_utf16= query_utf16.trimmed();
    if (query_utf16 > "") history_markup_append("", false);
  }
  fclose(history_file);
  if ((file_position_at_histfilesize > 0) || (histfilesize == 0)) /* must we truncate the file? */
  {
    ocelot_history_hist_file.setFileName(ocelot_history_hist_file_name);
    if (ocelot_history_hist_file.open(QIODevice::ReadWrite | QIODevice::Text) == true)
    {
      int new_file_size;
      if (histfilesize == 0) new_file_size= 0;
      else
      {
        int o= file_position_at_histfilesize + 1;
        new_file_size= file_size - o;
        int n= 0;
        for (;;)
        {
          ocelot_history_hist_file.seek(o);
          int l= ocelot_history_hist_file.read(history_buffer, HISTORY_BUFFER_SIZE);
          if (l <= 0) break;
          o+= l;
          ocelot_history_hist_file.seek(n);
          int l2= ocelot_history_hist_file.write(history_buffer, l);
          n+= l2;
          if (l < HISTORY_BUFFER_SIZE) break;
        }
      }
      ocelot_history_hist_file.resize(new_file_size);
      ocelot_history_hist_file.close();
    }
  }
returner:
  ocelot_history_hist_file_is_copied= true;
  query_utf16= er_strings[er_off + ER_START_OF_SESSION];
  return;
}

/* Pass: history line, which might be -- lines: n */
/* Return: n. 0 if it isn't -- lines: n. */
int MainWindow::history_line(char *l)
{
  if (strncmp(l, "-- lines: ", LINES_SIZE) == 0)
  {
    char tmp[64];
    int i= 0;
    char *c;
    for (c= l + LINES_SIZE; isdigit(*c); ++c) tmp[i++]= *c;
    tmp[i]= '\0';
    return atoi(tmp);
   }
  return 0;
}

/*
  Shortcut duplication
  Example:
    In create_menu():
      connect(menu_file_action_exit, SIGNAL(triggered()), this, SLOT(action_exit()));
      menu_file_action_exit->setShortcut(QKeySequence::Quit);
    In eventFilter():
      if (key->matches(QKeySequence::Quit))
      {
        action_exit();
        return true;
      }
  With Ubuntu 12.04 the menu shortcut is executed.
  With Ubuntu 15.04 the event filter is executed.
  That is: the duplication in the event filter is a workaround for the fact that,
  on some distro versions, some menu shortcuts are missed. Maybe it's a Qt bug.
  Maybe it's an Ubuntu bug: https://bugs.launchpad.net/ubuntu/+source/texmaker/+bug/1386111
*/

/*
  Create the menu.
  Apparently the menubar already exists because of the call to UiSetup() earlier. Incomprehensible.
  Todo: Consider making a table with the menu settings. Something like this ...
  Table: ocelot.actions
  Window  Menu_position Menu_item_position Menu_name Menu_item_name Name  Caption/Hint    Menu   Key   Toolbar Action
  ------  ------------- ------------------ --------- -------------- ----  ------------    ----   ---   ------- ------
  Main                1                  1 File      E&xit                                                     exit
  Main    1             1                  File      Exitrun   Execute         Edit   &E    lightning-bolt
  This is creation -- assume there are no existing menus.
  There could also be alter -- wipe existing actions as part of user customization, then call this.
     We do not want users to get rid of "About" box that shows copyrights etc.
  ?? How do I get rid of a QAction?
    Also set up more with setShortcuts(), setStatusTip(), ...
    Also add action to toolbox
     This would addMenu() multiple times for the same menu, so I use a different name each time.
    I should show what the shortcuts are; unfortunately for most actions the shortcut differs according to platform
    Maybe instead of "Execute ctrl+E" I should be using "Run ctrl+R"
    Sure, I tried using & for various menu items e.g. E&xit -- but then Alt+x did not work!
  create_menu() makes a skeleton, fill_menu() comes when we know options from command-line and my.cnf
  Todo: The choices in the export-related exclusive QActionGroup should have radio buttons not check marks.
        Maybe figure out what went wrong, since illustrations suggested this would be automatic.
        Maybe try adding to ocelot_menu_style_string: QMenu::indicator:exclusive:checked{image: ...}.
        Maybe make your own icons and set them when checked.
*/
void MainWindow::create_menu()
{
  menu_file= ui->menuBar->addMenu("");
  /* Todo: consider adding fileMenu = new QMenu(tr("&File"), this); -*/
  menu_file_action_connect= menu_file->addAction("");
  menu_file_action_exit= menu_file->addAction("");
#if (OCELOT_IMPORT_EXPORT == 1)
  menu_file->addSeparator();
  menu_file_export= menu_file->addMenu("Export");
  menu_file_export->setEnabled(false);

  QActionGroup *menu_file_export_group= new QActionGroup(menu_file_export);
  menu_file_export_group->setEnabled(true);
  //menu_file_export_group->setExclusive(true); should be automatic
  menu_file_export_text_action= new QAction("text", this);
  menu_file_export->addAction(menu_file_export_text_action);
  menu_file_export_text_action->setActionGroup(menu_file_export_group);
  menu_file_export_table_action= new QAction("table", this);
  menu_file_export->addAction(menu_file_export_table_action);
  menu_file_export_html_action= new QAction("html", this);
  menu_file_export->addAction(menu_file_export_html_action);
  menu_file_export_none_action= new QAction("none", this);
  menu_file_export->addAction(menu_file_export_none_action);
  menu_file_export_text_action->setCheckable(true);
  menu_file_export_table_action->setCheckable(true);
  menu_file_export_html_action->setCheckable(true);
  menu_file_export_none_action->setCheckable(true);
  menu_file_export_group->addAction(menu_file_export_text_action);
  menu_file_export_group->addAction(menu_file_export_table_action);
  menu_file_export_group->addAction(menu_file_export_html_action);
  menu_file_export_group->addAction(menu_file_export_none_action);
#endif
  menu_edit= ui->menuBar->addMenu("");
  menu_edit_action_undo= menu_edit->addAction("");
  menu_edit_action_redo= menu_edit->addAction("");
  menu_edit->addSeparator();
  menu_edit_action_cut= menu_edit->addAction("");
  menu_edit_action_copy= menu_edit->addAction("");
  menu_edit_action_paste= menu_edit->addAction("");
  menu_edit->addSeparator();
  menu_edit_action_select_all= menu_edit->addAction("");
  menu_edit_action_history_markup_previous= menu_edit->addAction("");
  menu_edit_action_history_markup_next= menu_edit->addAction("");
  menu_edit_action_formatter= menu_edit->addAction("");
  menu_edit_action_zoomin= menu_edit->addAction("");
  menu_edit_action_zoomout= menu_edit->addAction("");
  menu_edit_action_autocomplete= menu_edit->addAction("");
  menu_edit_action_find= menu_edit->addAction("");
  menu_run= ui->menuBar->addMenu("");
  menu_run_action_execute= menu_run->addAction("");
  menu_run_action_kill= menu_run->addAction("");
  menu_settings= ui->menuBar->addMenu("");
  menu_settings_action_menu= menu_settings->addAction("");
  menu_settings_action_history= menu_settings->addAction("");
  menu_settings_action_grid= menu_settings->addAction("");
  menu_settings_action_statement= menu_settings->addAction("");
#if (OCELOT_MYSQL_DEBUGGER == 1)
  menu_settings_action_debug= menu_settings->addAction("");
#endif
  menu_settings_action_extra_rule_1= menu_settings->addAction("");
#if (OCELOT_EXPLORER == 1)
  menu_settings_action_explorer= menu_settings->addAction("");
#endif
  menu_options= ui->menuBar->addMenu("");
  menu_options_action_option_detach_history_widget= menu_options->addAction("");
  menu_options_action_option_detach_result_grid_widget= menu_options->addAction("");
#if (OCELOT_MYSQL_DEBUGGER == 1)
  menu_options_action_option_detach_debug_widget= menu_options->addAction("");
#endif
  menu_options_action_option_detach_statement_widget= menu_options->addAction("");
#if (OCELOT_EXPLORER == 1)
  menu_options_action_option_detach_explorer_widget= menu_options->addAction("");
#endif
  menu_options_action_next_window= menu_options->addAction("");
  menu_options_action_previous_window= menu_options->addAction("");
  menu_options_action_batch= menu_options->addAction("");
  menu_options_action_horizontal= menu_options->addAction("");
  menu_options_action_html= menu_options->addAction("");
  menu_options_action_htmlraw= menu_options->addAction("");
  menu_options_action_raw= menu_options->addAction("");
  menu_options_action_vertical= menu_options->addAction("");
  menu_options_action_xml= menu_options->addAction("");
#if (OCELOT_MYSQL_DEBUGGER == 1)
  menu_debug= ui->menuBar->addMenu("");
//  menu_debug_action_install= menu_debug->addAction("");
//  menu_debug_action_setup= menu_debug->addAction("");
//  menu_debug_action_debug= menu_debug->addAction("");
  menu_debug_action_breakpoint= menu_debug->addAction("");
  menu_debug_action_continue= menu_debug->addAction("");
//  menu_debug_action_leave= menu_debug->addAction("");
  menu_debug_action_next= menu_debug->addAction("");
//  menu_debug_action_skip= menu_debug->addAction("");
  menu_debug_action_step= menu_debug->addAction("");
  menu_debug_action_clear= menu_debug->addAction("");
//  menu_debug_action_delete= menu_debug->addAction("");
  menu_debug_action_exit= menu_debug->addAction("");
  menu_debug_action_information= menu_debug->addAction("");
  menu_debug_action_refresh_server_variables= menu_debug->addAction("");
  menu_debug_action_refresh_user_variables= menu_debug->addAction("");
  menu_debug_action_refresh_variables= menu_debug->addAction("");
  menu_debug_action_refresh_call_stack= menu_debug->addAction("");
#endif
  menu_help= ui->menuBar->addMenu("");
  menu_help_action_about= menu_help->addAction("");
  menu_help_action_the_manual= menu_help->addAction("");
  /* Qt says I should also do "addSeparator" if Motif style. Harmless. */
  ui->menuBar->addSeparator();
  /* exitAction->setPriority(QAction::LowPriority); */
#if (OCELOT_MYSQL_INCLUDE == 1)
  menu_help_action_libmysqlclient= menu_help->addAction("");
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  menu_help_action_settings= menu_help->addAction("");
}

/*
  This was split out from create_menu() because there are things we won't know till after
  we read .cnf files and command-line parameters.
*/
void MainWindow::fill_menu()
{
  menu_file->setTitle(menu_strings[menu_off + MENU_FILE]);
  menu_file_action_connect->setText(menu_strings[menu_off + MENU_FILE_CONNECT]);
  connect(menu_file_action_connect, SIGNAL(triggered()), this, SLOT(action_connect()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_CONNECT, "", false, true);
  menu_file_action_exit->setText(menu_strings[menu_off + MENU_FILE_EXIT]);
  connect(menu_file_action_exit, SIGNAL(triggered()), this, SLOT(action_exit()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_EXIT, "", false, true);
  menu_edit->setTitle(menu_strings[menu_off + MENU_EDIT]);
#if (OCELOT_IMPORT_EXPORT == 1)
  /* Todo: Put in ostrings.h and allow MENU_FILE_EXPORT */
  connect(menu_file_export_text_action, SIGNAL(triggered()), this, SLOT(action_export_text()));
  connect(menu_file_export_table_action, SIGNAL(triggered()), this, SLOT(action_export_table()));
  connect(menu_file_export_html_action, SIGNAL(triggered()), this, SLOT(action_export_html()));
  connect(menu_file_export_none_action, SIGNAL(triggered()), this, SLOT(action_export_none()));
#endif
  menu_edit_action_undo->setText(menu_strings[menu_off + MENU_EDIT_UNDO]);
  connect(menu_edit_action_undo, SIGNAL(triggered()), this, SLOT(menu_edit_undo()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_UNDO, "", false, true);
  menu_edit_action_redo->setText(menu_strings[menu_off + MENU_EDIT_REDO]);
  connect(menu_edit_action_redo, SIGNAL(triggered()), this, SLOT(menu_edit_redo()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_REDO, "", false, true);
  menu_edit_action_cut->setText(menu_strings[menu_off + MENU_EDIT_CUT]);
  connect(menu_edit_action_cut, SIGNAL(triggered()), this, SLOT(menu_edit_cut()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_CUT, "", false, true);
  menu_edit_action_copy->setText(menu_strings[menu_off + MENU_EDIT_COPY]);
  connect(menu_edit_action_copy, SIGNAL(triggered()), this, SLOT(menu_edit_copy()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_COPY, "", false, true);
  menu_edit_action_paste->setText(menu_strings[menu_off + MENU_EDIT_PASTE]);
  connect(menu_edit_action_paste, SIGNAL(triggered()), this, SLOT(menu_edit_paste()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_PASTE, "", false, true);
  menu_edit_action_select_all->setText(menu_strings[menu_off + MENU_EDIT_SELECT_ALL]);
  connect(menu_edit_action_select_all, SIGNAL(triggered()), this, SLOT(menu_edit_select_all()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_SELECT_ALL, "", false, true);
  menu_edit_action_history_markup_previous->setText(menu_strings[menu_off + MENU_EDIT_PREVIOUS_STATEMENT]);
  connect(menu_edit_action_history_markup_previous, SIGNAL(triggered()), this, SLOT(history_markup_previous()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_PREVIOUS, "", false, true);
  menu_edit_action_history_markup_next->setText(menu_strings[menu_off + MENU_EDIT_NEXT_STATEMENT]);
  connect(menu_edit_action_history_markup_next, SIGNAL(triggered()), this, SLOT(history_markup_next()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_NEXT, "", false, true);
  menu_edit_action_formatter->setText(menu_strings[menu_off + MENU_EDIT_FORMAT]);
  connect(menu_edit_action_formatter, SIGNAL(triggered()), this, SLOT(statement_edit_widget_formatter()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_FORMAT, "", false, true);
  menu_edit_action_zoomin->setText(menu_strings[menu_off + MENU_EDIT_ZOOMIN]);
  connect(menu_edit_action_zoomin, SIGNAL(triggered()), this, SLOT(menu_edit_zoomin()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMIN, "", false, true);
  menu_edit_action_zoomout->setText(menu_strings[menu_off + MENU_EDIT_ZOOMOUT]);
  connect(menu_edit_action_zoomout, SIGNAL(triggered()), this, SLOT(menu_edit_zoomout()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMOUT, "", false, true);
  menu_edit_action_autocomplete->setText(menu_strings[menu_off + MENU_EDIT_AUTOCOMPLETE]);
  connect(menu_edit_action_autocomplete, SIGNAL(triggered()), this, SLOT(menu_edit_autocomplete_via_menu()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_AUTOCOMPLETE, "", false, true);
#if (OCELOT_FIND_WIDGET == 1)
  menu_edit_action_find->setText(menu_strings[menu_off + MENU_EDIT_FIND]);
  connect(menu_edit_action_find, SIGNAL(triggered()), this, SLOT(menu_edit_find()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_FIND, "", false, true);
#endif
  menu_run->setTitle(menu_strings[menu_off + MENU_RUN]);
  menu_run_action_execute->setText(menu_strings[menu_off + MENU_RUN_EXECUTE]);
  connect(menu_run_action_execute, SIGNAL(triggered()), this, SLOT(action_execute_force()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_EXECUTE, "", false, true);
  menu_run_action_kill->setText(menu_strings[menu_off + MENU_RUN_KILL]);
  connect(menu_run_action_kill, SIGNAL(triggered()), this, SLOT(action_kill()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_KILL, "", false, true);
  menu_run_action_kill->setEnabled(false);
  menu_settings->setTitle(menu_strings[menu_off + MENU_SETTINGS]);
  menu_settings_action_menu->setText(menu_strings[menu_off + MENU_SETTINGS_MENU]);
  menu_settings_action_history->setText(menu_strings[menu_off + MENU_SETTINGS_HISTORY_WIDGET]);
  menu_settings_action_grid->setText(menu_strings[menu_off + MENU_SETTINGS_GRID_WIDGET]);
  menu_settings_action_statement->setText(menu_strings[menu_off + MENU_SETTINGS_STATEMENT_WIDGET]);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  menu_settings_action_debug->setText(menu_strings[menu_off + MENU_SETTINGS_DEBUG_WIDGET]);
#endif
  menu_settings_action_extra_rule_1->setText(menu_strings[menu_off + MENU_SETTINGS_EXTRA_RULE_1]);
#if (OCELOT_EXPLORER == 1)
  menu_settings_action_explorer->setText(menu_strings[menu_off + MENU_SETTINGS_EXPLORER_WIDGET]);
#endif
  connect(menu_settings_action_menu, SIGNAL(triggered()), this, SLOT(action_menu()));
  connect(menu_settings_action_history, SIGNAL(triggered()), this, SLOT(action_history()));
  connect(menu_settings_action_grid, SIGNAL(triggered()), this, SLOT(action_grid()));
  connect(menu_settings_action_statement, SIGNAL(triggered()), this, SLOT(action_statement()));
#if (OCELOT_MYSQL_DEBUGGER == 1)
  connect(menu_settings_action_debug, SIGNAL(triggered()), this, SLOT(action_debug()));
#endif
  connect(menu_settings_action_extra_rule_1, SIGNAL(triggered()), this, SLOT(action_extra_rule_1()));
#if (OCELOT_EXPLORER == 1)
  connect(menu_settings_action_explorer, SIGNAL(triggered()), this, SLOT(action_explorer()));
#endif
  menu_options->setTitle(menu_strings[menu_off + MENU_OPTIONS]);
  menu_options_action_option_detach_history_widget->setText(menu_strings[menu_off + MENU_OPTIONS_DETACH_HISTORY_WIDGET]);
  menu_options_action_option_detach_history_widget->setCheckable(true);
  menu_options_action_option_detach_history_widget->setChecked(ocelot_detach_history_widget);
  connect(menu_options_action_option_detach_history_widget, SIGNAL(triggered(bool)), this, SLOT(action_option_detach_history_widget(bool)));
  menu_options_action_option_detach_result_grid_widget->setText(menu_strings[menu_off + MENU_OPTIONS_DETACH_RESULT_GRID_WIDGET]);
  menu_options_action_option_detach_result_grid_widget->setCheckable(true);
  menu_options_action_option_detach_result_grid_widget->setChecked(ocelot_detach_result_grid_widget);
  connect(menu_options_action_option_detach_result_grid_widget, SIGNAL(triggered(bool)), this, SLOT(action_option_detach_result_grid_widget(bool)));
#if (OCELOT_MYSQL_DEBUGGER == 1)
  menu_options_action_option_detach_debug_widget->setText(menu_strings[menu_off + MENU_OPTIONS_DETACH_DEBUG_WIDGET]);
  menu_options_action_option_detach_debug_widget->setCheckable(true);
  menu_options_action_option_detach_debug_widget->setChecked(ocelot_detach_debug_widget);
  connect(menu_options_action_option_detach_debug_widget, SIGNAL(triggered(bool)), this, SLOT(action_option_detach_debug_widget(bool)));
#endif
  menu_options_action_option_detach_statement_widget->setText(menu_strings[menu_off + MENU_OPTIONS_DETACH_STATEMENT_WIDGET]);
  menu_options_action_option_detach_statement_widget->setCheckable(true);
  menu_options_action_option_detach_statement_widget->setChecked(ocelot_detach_statement_edit_widget);
  connect(menu_options_action_option_detach_statement_widget, SIGNAL(triggered(bool)), this, SLOT(action_option_detach_statement_widget(bool)));
#if (OCELOT_EXPLORER == 1)
  menu_options_action_option_detach_explorer_widget->setText(menu_strings[menu_off + MENU_OPTIONS_DETACH_EXPLORER_WIDGET]);
  menu_options_action_option_detach_explorer_widget->setCheckable(true);
  menu_options_action_option_detach_explorer_widget->setChecked(ocelot_detach_explorer_widget);
  connect(menu_options_action_option_detach_explorer_widget, SIGNAL(triggered(bool)), this, SLOT(action_option_detach_explorer_widget(bool)));
#endif
  menu_options_action_next_window->setText(menu_strings[menu_off + MENU_OPTIONS_NEXT_WINDOW]);
  connect(menu_options_action_next_window, SIGNAL(triggered(bool)), this, SLOT(action_option_next_window()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT_WINDOW, "", false, true);
  menu_options_action_previous_window->setText(menu_strings[menu_off + MENU_OPTIONS_PREVIOUS_WINDOW]);
  connect(menu_options_action_previous_window, SIGNAL(triggered(bool)), this, SLOT(action_option_previous_window()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_PREVIOUS_WINDOW, "", false, true);
  menu_options_action_batch->setText(menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_BATCH]);
  connect(menu_options_action_batch, SIGNAL(triggered(bool)), this, SLOT(action_option_batch()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_BATCH, "", false, true);
  menu_options_action_horizontal->setText(menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_HORIZONTAL]);
  connect(menu_options_action_horizontal, SIGNAL(triggered(bool)), this, SLOT(action_option_horizontal()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_HORIZONTAL, "", false, true);
  menu_options_action_html->setText(menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_HTML]);
  connect(menu_options_action_html, SIGNAL(triggered(bool)), this, SLOT(action_option_html()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_HTML, "", false, true);
  menu_options_action_htmlraw->setText(menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_HTMLRAW]);
  connect(menu_options_action_htmlraw, SIGNAL(triggered(bool)), this, SLOT(action_option_htmlraw()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_HTMLRAW, "", false, true);
  menu_options_action_raw->setText(menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_RAW]);
  connect(menu_options_action_raw, SIGNAL(triggered(bool)), this, SLOT(action_option_raw()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_RAW, "", false, true);
  menu_options_action_vertical->setText(menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_VERTICAL]);
  connect(menu_options_action_vertical, SIGNAL(triggered(bool)), this, SLOT(action_option_vertical()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_VERTICAL, "", false, true);
  menu_options_action_xml->setText(menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_XML]);
  connect(menu_options_action_xml, SIGNAL(triggered(bool)), this, SLOT(action_option_xml()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_XML, "", false, true);
#if (OCELOT_MYSQL_DEBUGGER == 1)
menu_debug->setTitle(menu_strings[menu_off + MENU_DEBUG]);
//  menu_debug_action_install->setText(menu_strings[menu_off + MENU_DEBUG_INSTALL]);
//  connect(menu_debug_action_install, SIGNAL(triggered()), this, SLOT(action_debug_install()));
//=shortcut(?)  menu_debug_action_install->setShortcut(QKeySequence(tr("Alt+A")));
//  menu_debug_action_setup->setText(tr("Setup"));
//  connect(menu_debug_action_setup, SIGNAL(triggered()), this, SLOT(action_debug_setup()));
//=shortcut(?)  menu_debug_action_setup->setShortcut(QKeySequence(tr("Alt+5")));
//  menu_debug_action_debug->setText(menu_strings[menu_off + MENU_DEBUG]);
//  connect(menu_debug_action_debug, SIGNAL(triggered()), this, SLOT(action_debug_debug()));
//=shortcut(?)  menu_debug_action_debug->setShortcut(QKeySequence(tr("Alt+3")));
  menu_debug_action_breakpoint->setText(menu_strings[menu_off + MENU_DEBUG_BREAKPOINT]);
  connect(menu_debug_action_breakpoint, SIGNAL(triggered()), this, SLOT(action_debug_breakpoint()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_BREAKPOINT, "", false, true);
  menu_debug_action_continue->setText(menu_strings[menu_off + MENU_DEBUG_CONTINUE]);
  connect(menu_debug_action_continue, SIGNAL(triggered()), this, SLOT(action_debug_continue()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_CONTINUE, "", false, true);
//  menu_debug_action_leave->setText(menu_strings[menu_off + MENU_DEBUG_LEAVE);
//  connect(menu_debug_action_leave, SIGNAL(triggered()), this, SLOT(action_debug_leave()));
//=shortcut(?)  menu_debug_action_leave->setShortcut(QKeySequence(tr("Alt+B")));
  menu_debug_action_next->setText(menu_strings[menu_off + MENU_DEBUG_NEXT]);
  connect(menu_debug_action_next, SIGNAL(triggered()), this, SLOT(action_debug_next()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT, "", false, true);
//  menu_debug_action_skip->setText(menu_strings[menu_off + MENU_DEBUG_SKIP);
//  connect(menu_debug_action_skip, SIGNAL(triggered()), this, SLOT(action_debug_skip()));
//=shortcut(?)  menu_debug_action_skip->setShortcut(QKeySequence(tr("Alt+4")));
  menu_debug_action_step->setText(menu_strings[menu_off + MENU_DEBUG_STEP]);
  connect(menu_debug_action_step, SIGNAL(triggered()), this, SLOT(action_debug_step()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_STEP, "", false, true);
  menu_debug_action_clear->setText(menu_strings[menu_off + MENU_DEBUG_CLEAR]);
  connect(menu_debug_action_clear, SIGNAL(triggered()), this, SLOT(action_debug_clear()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_CLEAR, "", false, true);
//  menu_debug_action_delete->setText(menu_strings[menu_off + MENU_DEBUG_DELETE]);
//  connect(menu_debug_action_delete, SIGNAL(triggered()), this, SLOT(action_debug_delete()));
//=shortcut(?)  menu_debug_action_delete->setShortcut(QKeySequence(tr("Alt+G")));
  menu_debug_action_exit->setText(menu_strings[menu_off + MENU_DEBUG_EXIT]);
  connect(menu_debug_action_exit, SIGNAL(triggered()), this, SLOT(action_debug_exit()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_DEBUG_EXIT, "", false, true);
  menu_debug_action_information->setText(menu_strings[menu_off + MENU_DEBUG_INFORMATION]);
  connect(menu_debug_action_information, SIGNAL(triggered()), this, SLOT(action_debug_information()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_INFORMATION, "", false, true);
  menu_debug_action_refresh_server_variables->setText(menu_strings[menu_off + MENU_DEBUG_REFRESH_SERVER_VARIABLES]);
  connect(menu_debug_action_refresh_server_variables, SIGNAL(triggered()), this, SLOT(action_debug_refresh_server_variables()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_SERVER_VARIABLES, "", false, true);
  menu_debug_action_refresh_user_variables->setText(menu_strings[menu_off + MENU_DEBUG_REFRESH_USER_VARIABLES]);
  connect(menu_debug_action_refresh_user_variables, SIGNAL(triggered()), this, SLOT(action_debug_refresh_user_variables()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_USER_VARIABLES, "", false, true);
  menu_debug_action_refresh_variables->setText(menu_strings[menu_off + MENU_DEBUG_REFRESH_VARIABLES]);
  connect(menu_debug_action_refresh_variables, SIGNAL(triggered()), this, SLOT(action_debug_refresh_variables()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_VARIABLES, "", false, true);
  menu_debug_action_refresh_call_stack->setText(menu_strings[menu_off + MENU_DEBUG_REFRESH_CALL_STACK]);
  connect(menu_debug_action_refresh_call_stack, SIGNAL(triggered()), this, SLOT(action_debug_refresh_call_stack()));
  shortcut(TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_CALL_STACK, "", false, true);
  debug_menu_enable_or_disable(TOKEN_KEYWORD_BEGIN); /* Disable most of debug menu */
#endif
  menu_help->setTitle(menu_strings[menu_off + MENU_HELP]);
  menu_help_action_about->setText(menu_strings[menu_off + MENU_HELP_ABOUT]);
  connect(menu_help_action_about, SIGNAL(triggered()), this, SLOT(action_about()));
  menu_help_action_the_manual->setText(menu_strings[menu_off + MENU_HELP_THE_MANUAL]);
  connect(menu_help_action_the_manual, SIGNAL(triggered()), this, SLOT(action_the_manual()));
  /* Qt says I should also do "addSeparator" if Motif style. Harmless. */
  /* exitAction->setPriority(QAction::LowPriority); */
#if (OCELOT_MYSQL_INCLUDE == 1)
  menu_help_action_libmysqlclient->setText(menu_strings[menu_off + MENU_HELP_LIBMYSQLCLIENT]);
  connect(menu_help_action_libmysqlclient, SIGNAL(triggered()), this, SLOT(action_libmysqlclient()));
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  menu_help_action_settings->setText(menu_strings[menu_off + MENU_HELP_SETTINGS]);
  connect(menu_help_action_settings, SIGNAL(triggered()), this, SLOT(action_settings()));
}

/*
  Shortcuts -- set variable value, or do setShortcut().
  Example:
    At the beginning of this program we have a declaration
    static char ocelot_shortcut_exit[80]= "default";
    The figure 80 is big enough for "Ctrl+Shift+Alt+F12\0" (19) 4 times
    but not for multiple keys.
    We can change it with a setting in a .cnf file e.g. .my.cnf:
    ocelot_shortcut_key = 'Alt+L'
    We can change it with a SET statement:
    SET ocelot_shortcut_exit = 'Ctrl+q';
    or
    SET ocelot_shortcut_exit = 'default';
    or
    SET ocelot_shortcut_exit = 'ALT+A,Alt+B';
  See also http://doc.qt.io/qt-4.8/qkeysequence.html#fromString
  I have tested
  SET ocelot_shortcut_exit = 'Alt+L';
  and it works (File|Exit menu shows Alt+L, and Alt+L causes quit).
  Thus this changes what's in create_menu(), above.
  Called from create_menu(),execute_client_statement(),connect_set_variable().
  Return 1 if it's ocelot_shortcut_exit etc., even if it fails.
  You might want to "set" e.g. ocelot_shortcut_exit= value;
  You might want to "do" e.g. menu_file_action_exit->setShortcut(value);
  You might want to both "set" and "do".
  Todo: ensure two keys don't have the same action (error check).
        We already have an ambiguity for ^C = Copy and ^C = Kill,
        but we try to solve that by disabling Copy before executing.
  Todo: Ensure string is valid -- error checks and warnings|errors.
        I commented out the check for displayable ASCII or F1-F12
        because e.g. Ctrl+Tab is okay. But I don't know a way to
        check whether the window manager will grab a key sequence
        so we won't see it (e.g. Alt+Tab on X11).
  Todo: syntax checker should see this.
  Todo: all the other shortcut keys.
  Todo: also, something for "what to execute" e.g. SQL statement.
  Todo: return 0 if token1 first characters are not "ocelot_shortcut_"
  Todo: There is no GUI "shortcut editor" here, but such things exist:
        see doc.qt.io/qt-5/qkeysequenceedit.html#details.
        We could show a table with current settings, and let
        users pick or type in a key sequence.
  Warn: Although we can handle multiple-key shortcuts,
        the workaround for the Qt/Ubuntu bug in eventfilter_function
        only looks at one key.
  Warn: We don't say default = QKeySequence::Zoomin for zoomin, because
        it is Ctrl++ (Qt::CTRL + Qt::Key_Plus). But + requires shift.
        It seems more common to use without shift, which is Ctrl+=.
        http://doc.qt.io/archives/qt-4.8/qkeysequence.html section
        "Keyboard Layout Issues" mentions this but I didn't understand.
  Warn: There are some slightly-standardized keysequences, see them in
        Qt https://doc-snapshots.qt.io/qt5-5.9/qkeysequence.html#StandardKey-enum
        Eclipse http://help.eclipse.org/mars/index.jsp?topic=%2Forg.eclipse.platform.doc.user%2Freference%2Fref-keybindings.htm
        Visual Studio https://code.visualstudio.com/docs/getstarted/keybindings
        Wikipedia https://en.wikipedia.org/wiki/Table_of_keyboard_shortcuts
        In the past we failed to follow. In the future we should follow.
*/
int MainWindow::shortcut(int target, QString token3, bool is_set, bool is_do)
{
  QString source;
  char source_as_utf8[80*4];
  //if (target.mid(0, 16) != "ocelot_shortcut_") return 0;
  if (is_set)
  {
    source= connect_stripper(token3, false);
    if (source.length() >= 80) return -1;
    source= source.toLower();
    strcpy(source_as_utf8, source.toUtf8());
    if (strlen(source_as_utf8) >= 80) return -1;
    if (strcmp(source_as_utf8, "default") != 0)
    {
      QKeySequence k= QKeySequence(source_as_utf8);
      if ((k.count() < 1) || (k.count() > 4)) return -1;
      if (k.isEmpty()) return -1;
      if (k.toString() < " ") return -1;
//      for (unsigned int i= 0; i < (unsigned) k.count(); ++i)
//      {
//        int qi= k.operator[](i);
//        qi= (qi & ~(Qt::CTRL | Qt::SHIFT | Qt::ALT | Qt::META));
//        bool is_ok= false;
//        if ((qi >= Qt::Key_Space) && (qi <= Qt::Key_ydiaeresis)) is_ok= true;
//        if ((qi >= Qt::Key_F1) && (qi <= Qt::Key_F12)) is_ok= true;
//        if (is_ok == false) return -1;
//      }
    }
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_CONNECT)
  {
    if (is_set) strcpy(ocelot_shortcut_connect, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_connect, "default") == 0)
        ocelot_shortcut_connect_keysequence= QKeySequence::Open;
      else
        ocelot_shortcut_connect_keysequence= QKeySequence(ocelot_shortcut_connect);
      menu_file_action_connect->setShortcut(ocelot_shortcut_connect_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_EXIT)
  {
    if (is_set) strcpy(ocelot_shortcut_exit, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_exit, "default") == 0)
        /* With Puppy Linux --non-KDE non-Gnome -- QKeySequence::Quit fails. */
        ocelot_shortcut_exit_keysequence= QKeySequence("Ctrl+Q");
      else
        ocelot_shortcut_exit_keysequence= QKeySequence(ocelot_shortcut_exit);
      menu_file_action_exit->setShortcut(ocelot_shortcut_exit_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_UNDO)
  {
    if (is_set) strcpy(ocelot_shortcut_undo, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_undo, "default") == 0)
        ocelot_shortcut_undo_keysequence= QKeySequence::Undo;
      else
        ocelot_shortcut_undo_keysequence= QKeySequence(ocelot_shortcut_undo);
      menu_edit_action_undo->setShortcut(ocelot_shortcut_undo_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_REDO)
  {
    if (is_set) strcpy(ocelot_shortcut_redo, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_redo, "default") == 0)
        ocelot_shortcut_redo_keysequence= QKeySequence::Redo;
      else
        ocelot_shortcut_redo_keysequence= QKeySequence(ocelot_shortcut_redo);
      menu_edit_action_redo->setShortcut(ocelot_shortcut_redo_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_CUT)
  {
    if (is_set) strcpy(ocelot_shortcut_cut, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_cut, "default") == 0)
        ocelot_shortcut_cut_keysequence= QKeySequence::Cut;
      else
        ocelot_shortcut_cut_keysequence= QKeySequence(ocelot_shortcut_cut);
      menu_edit_action_cut->setShortcut(ocelot_shortcut_cut_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_COPY)
  {
    if (is_set) strcpy(ocelot_shortcut_copy, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_copy, "default") == 0)
        ocelot_shortcut_copy_keysequence= QKeySequence::Copy;
      else
        ocelot_shortcut_copy_keysequence= QKeySequence(ocelot_shortcut_copy);
      menu_edit_action_copy->setShortcut(ocelot_shortcut_copy_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_PASTE)
  {
    if (is_set) strcpy(ocelot_shortcut_paste, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_paste, "default") == 0)
        ocelot_shortcut_paste_keysequence= QKeySequence::Paste;
      else
        ocelot_shortcut_paste_keysequence= QKeySequence(ocelot_shortcut_paste);
      menu_edit_action_paste->setShortcut(ocelot_shortcut_paste_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_SELECT_ALL)
  {
    if (is_set) strcpy(ocelot_shortcut_select_all, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_select_all, "default") == 0)
        ocelot_shortcut_select_all_keysequence= QKeySequence::SelectAll;
      else
        ocelot_shortcut_select_all_keysequence= QKeySequence(ocelot_shortcut_select_all);
      menu_edit_action_select_all->setShortcut(ocelot_shortcut_select_all_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_PREVIOUS)
  {
    if (is_set) strcpy(ocelot_shortcut_history_markup_previous, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_history_markup_previous, "default") == 0)
        ocelot_shortcut_history_markup_previous_keysequence= QKeySequence("Ctrl+P");
      else
        ocelot_shortcut_history_markup_previous_keysequence= QKeySequence(ocelot_shortcut_history_markup_previous);
      menu_edit_action_history_markup_previous->setShortcut(ocelot_shortcut_history_markup_previous_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_NEXT)
  {
    if (is_set) strcpy(ocelot_shortcut_history_markup_next, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_history_markup_next, "default") == 0)
        ocelot_shortcut_history_markup_next_keysequence= QKeySequence("Ctrl+N");
      else
        ocelot_shortcut_history_markup_next_keysequence= QKeySequence(ocelot_shortcut_history_markup_next);
      menu_edit_action_history_markup_next->setShortcut(ocelot_shortcut_history_markup_next_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_FORMAT)
  {
    if (is_set) strcpy(ocelot_shortcut_format, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_format, "default") == 0)
        ocelot_shortcut_format_keysequence= QKeySequence("Alt+Shift+F");
      else
        ocelot_shortcut_format_keysequence= QKeySequence(ocelot_shortcut_format);
      menu_edit_action_formatter->setShortcut(ocelot_shortcut_format_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMIN)
  {
    if (is_set) strcpy(ocelot_shortcut_zoomin, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_zoomin, "default") == 0)
        ocelot_shortcut_zoomin_keysequence= QKeySequence("Ctrl+=");
      else
        ocelot_shortcut_zoomin_keysequence= QKeySequence(ocelot_shortcut_zoomin);
      menu_edit_action_zoomin->setShortcut(ocelot_shortcut_zoomin_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMOUT)
  {
    if (is_set) strcpy(ocelot_shortcut_zoomout, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_zoomout, "default") == 0)
        ocelot_shortcut_zoomout_keysequence= QKeySequence::ZoomOut;
      else
        ocelot_shortcut_zoomout_keysequence= QKeySequence(ocelot_shortcut_zoomout);
      menu_edit_action_zoomout->setShortcut(ocelot_shortcut_zoomout_keysequence);
    }
    return 1;
  }
  /* Todo: Tab is like mysql but a poor default choice. Try Ctrl+Space? */
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_AUTOCOMPLETE)
  {
    if (is_set) strcpy(ocelot_shortcut_autocomplete, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_autocomplete, "default") == 0)
        ocelot_shortcut_autocomplete_keysequence= QKeySequence("Tab");
      else
        ocelot_shortcut_autocomplete_keysequence= QKeySequence(ocelot_shortcut_autocomplete);
      menu_edit_action_autocomplete->setShortcut(ocelot_shortcut_autocomplete_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_FIND)
  {
    if (is_set) strcpy(ocelot_shortcut_find, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_find, "default") == 0)
        ocelot_shortcut_find_keysequence= QKeySequence("Ctrl+F");
      else
        ocelot_shortcut_find_keysequence= QKeySequence(ocelot_shortcut_find);
      menu_edit_action_find->setShortcut(ocelot_shortcut_find_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_EXECUTE)
  {
    if (is_set) strcpy(ocelot_shortcut_execute, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_execute, "default") == 0)
        ocelot_shortcut_execute_keysequence= QKeySequence("Ctrl+E");
      else
        ocelot_shortcut_execute_keysequence= QKeySequence(ocelot_shortcut_execute);
      menu_run_action_execute->setShortcut(ocelot_shortcut_execute_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_KILL)
  {
    if (is_set) strcpy(ocelot_shortcut_kill, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_kill, "default") == 0)
        ocelot_shortcut_kill_keysequence= QKeySequence("Ctrl+C");
      else
        ocelot_shortcut_kill_keysequence= QKeySequence(ocelot_shortcut_kill);
      menu_run_action_kill->setShortcut(ocelot_shortcut_kill_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT_WINDOW)
  {
    if (is_set) strcpy(ocelot_shortcut_next_window, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_next_window, "default") == 0)
        ocelot_shortcut_next_window_keysequence= QKeySequence::NextChild;
      else
        ocelot_shortcut_next_window_keysequence= QKeySequence(ocelot_shortcut_next_window);
      menu_options_action_next_window->setShortcut(ocelot_shortcut_next_window_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_PREVIOUS_WINDOW)
  {
    if (is_set) strcpy(ocelot_shortcut_previous_window, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_previous_window, "default") == 0)
        ocelot_shortcut_previous_window_keysequence= QKeySequence::PreviousChild;
      else
        ocelot_shortcut_previous_window_keysequence= QKeySequence(ocelot_shortcut_previous_window);
      menu_options_action_previous_window->setShortcut(ocelot_shortcut_previous_window_keysequence);
    }
    return 1;
  }

  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_BATCH)
  {
    if (is_set) strcpy(ocelot_shortcut_batch, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_batch, "default") == 0)
        ocelot_shortcut_batch_keysequence= QKeySequence("Alt+Shift+1");
      else
        ocelot_shortcut_batch_keysequence= QKeySequence(ocelot_shortcut_batch);
      menu_options_action_batch->setShortcut(ocelot_shortcut_batch_keysequence);
    }
    return 1;
  }

  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_HORIZONTAL)
  {
    if (is_set) strcpy(ocelot_shortcut_horizontal, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_horizontal, "default") == 0)
        ocelot_shortcut_horizontal_keysequence= QKeySequence("Alt+Shift+2");
      else
        ocelot_shortcut_horizontal_keysequence= QKeySequence(ocelot_shortcut_horizontal);
      menu_options_action_horizontal->setShortcut(ocelot_shortcut_horizontal_keysequence);
    }
    return 1;
  }

  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_HTML)
  {
    if (is_set) strcpy(ocelot_shortcut_html, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_html, "default") == 0)
        ocelot_shortcut_html_keysequence= QKeySequence("Alt+Shift+3");
      else
        ocelot_shortcut_html_keysequence= QKeySequence(ocelot_shortcut_html);
      menu_options_action_html->setShortcut(ocelot_shortcut_html_keysequence);
    }
    return 1;
  }

  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_HTMLRAW)
  {
    if (is_set) strcpy(ocelot_shortcut_htmlraw, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_htmlraw, "default") == 0)
        ocelot_shortcut_htmlraw_keysequence= QKeySequence("Alt+Shift+4");
      else
        ocelot_shortcut_htmlraw_keysequence= QKeySequence(ocelot_shortcut_htmlraw);
      menu_options_action_htmlraw->setShortcut(ocelot_shortcut_htmlraw_keysequence);
    }
    return 1;
  }

  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_RAW)
  {
    if (is_set) strcpy(ocelot_shortcut_raw, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_raw, "default") == 0)
        ocelot_shortcut_raw_keysequence= QKeySequence("Alt+Shift+5");
      else
        ocelot_shortcut_raw_keysequence= QKeySequence(ocelot_shortcut_raw);
      menu_options_action_raw->setShortcut(ocelot_shortcut_raw_keysequence);
    }
    return 1;
  }

  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_VERTICAL)
  {
    if (is_set) strcpy(ocelot_shortcut_vertical, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_vertical, "default") == 0)
        ocelot_shortcut_vertical_keysequence= QKeySequence("Alt+Shift+6");
      else
        ocelot_shortcut_vertical_keysequence= QKeySequence(ocelot_shortcut_vertical);
      menu_options_action_vertical->setShortcut(ocelot_shortcut_vertical_keysequence);
    }
    return 1;
  }

  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_XML)
  {
    if (is_set) strcpy(ocelot_shortcut_xml, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_xml, "default") == 0)
        ocelot_shortcut_xml_keysequence= QKeySequence("Alt+Shift+7");
      else
        ocelot_shortcut_xml_keysequence= QKeySequence(ocelot_shortcut_xml);
      menu_options_action_xml->setShortcut(ocelot_shortcut_xml_keysequence);
    }
    return 1;
  }

#if (OCELOT_MYSQL_DEBUGGER == 1)
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_BREAKPOINT)
  {
    if (is_set) strcpy(ocelot_shortcut_breakpoint, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_breakpoint, "default") == 0)
        ocelot_shortcut_breakpoint_keysequence= QKeySequence("Alt+1");
      else
        ocelot_shortcut_breakpoint_keysequence= QKeySequence(ocelot_shortcut_breakpoint);
      menu_debug_action_breakpoint->setShortcut(ocelot_shortcut_breakpoint_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_CONTINUE)
  {
    if (is_set) strcpy(ocelot_shortcut_continue, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_continue, "default") == 0)
        ocelot_shortcut_continue_keysequence= QKeySequence("Alt+2");
      else
        ocelot_shortcut_continue_keysequence= QKeySequence(ocelot_shortcut_continue);
      menu_debug_action_continue->setShortcut(ocelot_shortcut_continue_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT)
  {
    if (is_set) strcpy(ocelot_shortcut_next, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_next, "default") == 0)
        ocelot_shortcut_next_keysequence= QKeySequence("Alt+3");
      else
        ocelot_shortcut_next_keysequence= QKeySequence(ocelot_shortcut_next);
      menu_debug_action_next->setShortcut(ocelot_shortcut_next_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_STEP)
  {
    if (is_set) strcpy(ocelot_shortcut_step, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_step, "default") == 0)
        ocelot_shortcut_step_keysequence= QKeySequence("Alt+5");
      else
        ocelot_shortcut_step_keysequence= QKeySequence(ocelot_shortcut_step);
      menu_debug_action_step->setShortcut(ocelot_shortcut_step_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_CLEAR)
  {
    if (is_set) strcpy(ocelot_shortcut_clear, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_clear, "default") == 0)
        ocelot_shortcut_clear_keysequence= QKeySequence("Alt+6");
      else
        ocelot_shortcut_clear_keysequence= QKeySequence(ocelot_shortcut_clear);
      menu_debug_action_clear->setShortcut(ocelot_shortcut_clear_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_DEBUG_EXIT)
  {
    if (is_set) strcpy(ocelot_shortcut_debug_exit, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_debug_exit, "default") == 0)
        ocelot_shortcut_debug_exit_keysequence= QKeySequence("Alt+7");
      else
        ocelot_shortcut_debug_exit_keysequence= QKeySequence(ocelot_shortcut_debug_exit);
      menu_debug_action_exit->setShortcut(ocelot_shortcut_debug_exit_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_INFORMATION)
  {
    if (is_set) strcpy(ocelot_shortcut_information, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_information, "default") == 0)
        ocelot_shortcut_information_keysequence= QKeySequence("Alt+8");
      else
        ocelot_shortcut_information_keysequence= QKeySequence(ocelot_shortcut_information);
      menu_debug_action_information->setShortcut(ocelot_shortcut_information_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_SERVER_VARIABLES)
  {
    if (is_set) strcpy(ocelot_shortcut_refresh_server_variables, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_refresh_server_variables, "default") == 0)
        ocelot_shortcut_refresh_server_variables_keysequence= QKeySequence("Alt+9");
      else
        ocelot_shortcut_refresh_server_variables_keysequence= QKeySequence(ocelot_shortcut_refresh_server_variables);
      menu_debug_action_refresh_server_variables->setShortcut(ocelot_shortcut_refresh_server_variables_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_USER_VARIABLES)
  {
    if (is_set) strcpy(ocelot_shortcut_refresh_user_variables, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_refresh_user_variables, "default") == 0)
        ocelot_shortcut_refresh_user_variables_keysequence= QKeySequence("Alt+0");
      else
        ocelot_shortcut_refresh_user_variables_keysequence= QKeySequence(ocelot_shortcut_refresh_user_variables);
      menu_debug_action_refresh_user_variables->setShortcut(ocelot_shortcut_refresh_user_variables_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_VARIABLES)
  {
    if (is_set) strcpy(ocelot_shortcut_refresh_variables, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_refresh_variables, "default") == 0)
        ocelot_shortcut_refresh_variables_keysequence= QKeySequence("Alt+A");
      else
        ocelot_shortcut_refresh_variables_keysequence= QKeySequence(ocelot_shortcut_refresh_variables);
      menu_debug_action_refresh_variables->setShortcut(ocelot_shortcut_refresh_variables_keysequence);
    }
    return 1;
  }
  if (target == TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_CALL_STACK)
  {
    if (is_set) strcpy(ocelot_shortcut_refresh_call_stack, source_as_utf8);
    if (is_do)
    {
      if (strcmp(ocelot_shortcut_refresh_call_stack, "default") == 0)
        ocelot_shortcut_refresh_call_stack_keysequence= QKeySequence("Alt+B");
      else
        ocelot_shortcut_refresh_call_stack_keysequence= QKeySequence(ocelot_shortcut_refresh_call_stack);
      menu_debug_action_refresh_call_stack->setShortcut(ocelot_shortcut_refresh_call_stack_keysequence);
    }
    /* todo: check why there is no "return 1;" here. */
  }
#endif // if (OCELOT_MYSQL_DEBUGGER == 1)
  return 0;
}

/*
  Edit Menu Dispatcher

  We have only one edit menu, but we have multiple edit widgets.
  So the connect-signal-slot code in create_menu() jumps to menu_edit slots.
  The alternatives were: Multiple Document Interface, or multiple windows. I thought this was easier.
  For example, for cut: the slot is menu_edit_cut, it gets the focused widget and calls its cut().
  But Undo and Redo are complicated: for some widgets they're enabled, for some widgets they're not.
  TODO: We are not enabling|disabling edit menu items properly. We should be saying (examples):
        Initially, menu_edit_action_cut->setEnabled(false);
        When creating any editor widget,
          connect(widget, SIGNAL(copyAvailable(bool)),menu_edit_action_cut, SLOT(setEnabled(bool)));
        When we want to know if something can be pasted,
          connect(QApplication::clipboard(), SIGNAL(dataChanged()), this, SLOT(processClipboardChange()));
          qMimeData* x= clipboard->mimeData();
          qStringList* y= x->formats();
          int z= y->size();
          if (z > 0) menu_edit_action_paste->setEnabled();                 << wrong, you only know if paste is possible
        If something is selected and focus changes: de-select      
  TODO: I have no idea what "else if (strcmp(class_name, "+") == 0)"
        is for, maybe it's a bug. Compare menu_edit_redo().
*/
void MainWindow::menu_edit_undo()
{
  QWidget* focus_widget= QApplication::focusWidget();
  const char *class_name= focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
    action_undo();
  else if (strcmp(class_name, "Result_qtextedit") == 0)
    qobject_cast<Result_qtextedit*>(focus_widget)->undo();
  else if (strcmp(class_name, "TextEditHistory") == 0)
    qobject_cast<TextEditHistory*>(focus_widget)->undo();
  else if (strcmp(class_name, "QTextEdit") == 0)
    qobject_cast<QTextEdit*>(focus_widget)->undo();
  else if (strcmp(class_name, "+") == 0)
    qobject_cast<QTextEdit*>(focus_widget)->undo();
}
void MainWindow::menu_edit_redo()
{
  QWidget* focus_widget= QApplication::focusWidget();
  if (focus_widget == 0) return; /* This would be unexpected */
  const char *class_name= focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
    action_redo();
  else if (strcmp(class_name, "Result_qtextedit") == 0)
    qobject_cast<Result_qtextedit*>(focus_widget)->redo();
  else if (strcmp(class_name, "TextEditHistory") == 0)
    qobject_cast<TextEditHistory*>(focus_widget)->redo();
  else if (strcmp(class_name, "QTextEdit") == 0)
    qobject_cast<QTextEdit*>(focus_widget)->redo();
}
void MainWindow::menu_edit_cut()
{
  QWidget* focus_widget= QApplication::focusWidget();
  if (focus_widget == 0) return; /* This would be unexpected */
  const char *class_name= focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
    qobject_cast<CodeEditor*>(focus_widget)->cut();
  else if (strcmp(class_name, "Result_qtextedit") == 0)
    qobject_cast<Result_qtextedit*>(focus_widget)->cut();
  else if (strcmp(class_name, "TextEditHistory") == 0)
    qobject_cast<TextEditHistory*>(focus_widget)->cut();
  else if (strcmp(class_name, "QTextEdit") == 0)
    qobject_cast<QTextEdit*>(focus_widget)->cut();
}
void MainWindow::menu_edit_copy()
{
  QWidget* focus_widget= QApplication::focusWidget();
  if (focus_widget == 0) return; /* This would be unexpected */
  const char *class_name= focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
    qobject_cast<CodeEditor*>(focus_widget)->copy();
  else if (strcmp(class_name, "Result_qtextedit") == 0)
    /* see Result_qtextedit::copy() later in this file */
    qobject_cast<Result_qtextedit*>(focus_widget)->copy();
  else if (strcmp(class_name, "TextEditHistory") == 0)
    qobject_cast<TextEditHistory*>(focus_widget)->copy();
  else if (strcmp(class_name, "QTextEdit") == 0)
    qobject_cast<QTextEdit*>(focus_widget)->copy();
}
void MainWindow::menu_edit_paste()
{
  QWidget* focus_widget= QApplication::focusWidget();
  if (focus_widget == 0) return; /* This would be unexpected */
  const char *class_name= focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
    qobject_cast<CodeEditor*>(focus_widget)->paste();
  else if (strcmp(class_name, "Result_qtextedit") == 0)
    /* see Result_qtextedit::paste() later in this file */
    qobject_cast<Result_qtextedit*>(focus_widget)->paste();
  if (strcmp(class_name, "TextEditHistory") == 0)
    qobject_cast<TextEditHistory*>(focus_widget)->paste();
  else if (strcmp(class_name, "QTextEdit") == 0)
    qobject_cast<QTextEdit*>(focus_widget)->paste();
}
void MainWindow::menu_edit_select_all()
{
  QWidget* focus_widget= QApplication::focusWidget();
  if (focus_widget == 0) return; /* This would be unexpected */
  const char *class_name= focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
    qobject_cast<CodeEditor*>(focus_widget)->selectAll();
  else if (strcmp(class_name, "Result_qtextedit") == 0)
    qobject_cast<Result_qtextedit*>(focus_widget)->selectAll();
  else if (strcmp(class_name, "TextEditHistory") == 0)
    qobject_cast<TextEditHistory*>(focus_widget)->selectAll();
  else if (strcmp(class_name, "QTextEdit") == 0)
    qobject_cast<QTextEdit*>(focus_widget)->selectAll();
}
/*
  zoom in/out won't work by calling default zoomIn()/zoomOut(), probably
  because we use style sheets. So we'll get the current style
  sheet, add an increment (currently always +1 or -1), change
  the style sheet. This does not affect what's set with Settings.
  That's deliberate. Zooming is temporary, setting is permanent.
  Re extracting: Compare what we do with get_font_from_style_sheet().
  Todo: Changing font size won't affect images, we need special handling.
  Todo: Maybe we should qobject_cast for setStyleSheet() too.
  Todo: BUG: If you just click on a ResultGrid cell, thinking you have
        given it the focus, and then you click Ctrl++ or Ctrl-- i.e.
        the shortcut not the menu item, it doesn't recognize it.
        Click away, then come back, and it does recognize it.
  Re Result_qtextedit:
    For unknown reasons qobject_cast<Result_qtextedit*>(focus_widget)->styleSheet() returns blank.
    Maybe it has something to do with setHtml(). Anyway, we have a workaround that increases/decreases
    font size for all result grids. This might be okay temporarily but it doesn't generate a SET statement,
    and it would be fine to have something that increased cell size as well as font (especially fine if
    there is an image, and it would be fine to have something that zooms only to the cell in focus.
*/
void MainWindow::menu_edit_zoominorout(int increment)
{
  QWidget* focus_widget= QApplication::focusWidget();
  if (focus_widget == 0) return; /* This would be unexpected */
  QString old_stylesheet;
  const char *class_name= focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
    old_stylesheet= qobject_cast<CodeEditor*>(focus_widget)->styleSheet();
  else if (strcmp(class_name, "Result_qtextedit") == 0)
    old_stylesheet= ocelot_grid_style_string;
  else if (strcmp(class_name, "TextEditHistory") == 0)
    old_stylesheet= qobject_cast<TextEditHistory*>(focus_widget)->styleSheet();
  else if (strcmp(class_name, "QTextEdit") == 0)
    old_stylesheet= qobject_cast<QTextEdit*>(focus_widget)->styleSheet();
  else return; /* This would be unexpected. */
  int i= old_stylesheet.indexOf("font-size:");
  if (i == -1) return;
  i+= sizeof("font-size:");
  int j= old_stylesheet.indexOf("pt", i);
  if (j == -1) return;
  QString old_font_size= old_stylesheet.mid(i-1, j-(i-1));
  int font_size= old_font_size.toInt();
  font_size+= increment;
  if (font_size < FONT_SIZE_MIN) font_size= FONT_SIZE_MIN;
  if (font_size > FONT_SIZE_MAX) font_size= FONT_SIZE_MAX;
  QString new_stylesheet= old_stylesheet.mid(0, i-1);
  new_stylesheet.append(QString::number(font_size));
  new_stylesheet.append(old_stylesheet.mid(j,old_stylesheet.size()-j));
  focus_widget->setStyleSheet(new_stylesheet);
  if (strcmp(class_name, "Result_qtextedit") == 0)
    xsettings_widget->ocelot_variable_set(TOKEN_KEYWORD_OCELOT_GRID_FONT_SIZE, QString::number(font_size));
  return;
}
void MainWindow::menu_edit_zoomin()
{
  menu_edit_zoominorout(FONT_SIZE_ZOOM_INCREMENT);
}
void MainWindow::menu_edit_zoomout()
{
  menu_edit_zoominorout(-FONT_SIZE_ZOOM_INCREMENT);
}

/*
  The autocomplete shortcut is handled by event filter which
  calls keypress_shortcut_handler() which calls menu_edit_autocomplete()
  directly. Therefore we can only get here if the user chooses
  the autocomplete menu item rather than press a shortcut key.
  And in that case we don't care if the return is false.
*/
void MainWindow::menu_edit_autocomplete_via_menu()
{
  if (completer_widget->shortcut_override(menu_edit_action_autocomplete->shortcut()) == true) return;
  menu_edit_autocomplete();
}

/*
  Called from edit menu choice = autocomplete or keypress_shortcut_handler().
  Depends on rehash, ocelot_auto_rehash etc. e.g. was REHASH called.
  The extra checking here applies because default key is Tab Qt::Key_Tab,
  we want to return false if we don't handle it as a shortcut,
  so that it will simply be added to the widget contents.
  Put ``s or ""s around if they appear to be necessary.
  Todo: in MySQL/MariaDB lower-case letters might apper in regular identifiers, depending on settings.
  Todo: should we be using sql_mode_ansi_quotes or hparse_sql_mode_ansi_quotes?
*/
bool MainWindow::menu_edit_autocomplete()
{
  QString text;
  {
    if (completer_widget->isHidden() == false)
    {
      if (statement_edit_widget->hasFocus() == true)
      {
        QString tool_tip;
        QString word= completer_widget->get_selected_item(&tool_tip);
        int i;
        for (i= 0; main_token_lengths[i] != 0; ++i)
        {
          if ((main_token_flags[i] & TOKEN_FLAG_IS_ERROR) != 0) break;
        }
        if ((main_token_flags[i] & TOKEN_FLAG_IS_ERROR) == 0) return true;
        text= statement_edit_widget->toPlainText();
        if (tool_tip == "i")
        {
          bool is_regular= true;
          for (int i= 0; i < word.length(); ++i)
          {
            QChar c= word.at(i);
            if (c.isLetter())
            {
              if (c.isLower()) {is_regular= false; break; }
            }
            else if (c.isNumber())
            {
              if (i == 0) {is_regular= false; break; }
            }
            else if (c == '_')
            {
              continue;
            }
            else
            {
              is_regular= false; break;
            }
          }
          if (is_regular == false)
          {
            if (sql_mode_ansi_quotes == true) word= "\"" + word + "\"";
            else word= "`" + word + "`";
          }
        }
        if (word.left(1) != "[")
        {
          int offset;
          if (main_token_lengths[i] == 0)
          {
            offset= text.size();
            word= " " + word;
          }
          else offset= main_token_offsets[i];
          QString new_text= text.left(offset);
          new_text.append(word);
          int rest_start= offset + main_token_lengths[i];
          new_text.append(text.right(text.size() - rest_start));
          statement_edit_widget->setPlainText(new_text);
          QTextCursor c= statement_edit_widget->textCursor();
          c.movePosition(QTextCursor::End);
          statement_edit_widget->setTextCursor(c);
          completer_widget->updater();
          return true;
        }
      }
    }
  }
  return false;
}

#if (OCELOT_FIND_WIDGET == 1)
void MainWindow::menu_edit_find()
{
  find_widget->find_widget_activate();
}
#endif

/*
  The required size of main_token_offsets|lengths|types|flags is
  #-of-tokens + 1. We allocate lots more than enough after calculating
  x = (size-in-bytes + 1) rounded up to nearest 1000.
  We never reduce and perhaps that will appear to be a memory leak.
  todo: check if 'new' fails.
*/
void MainWindow::main_token_new(int text_size)
{
  unsigned int desired_count;
  desired_count= text_size + 1;
  if (desired_count >= main_token_max_count)
  {
    if (main_token_max_count != 0)
    {
      delete [] main_token_offsets;
      delete [] main_token_lengths;
      delete [] main_token_types;
      delete [] main_token_flags;
      delete [] main_token_pointers;
      delete [] main_token_reftypes;
    }
    desired_count= (desired_count - (desired_count % 1000)) + 1000;
    main_token_offsets= new int[desired_count];
    main_token_lengths= new int[desired_count];
    main_token_lengths[0]= 0;
    main_token_types= new int[desired_count];
    main_token_flags= new unsigned int[desired_count];
    main_token_pointers= new int[desired_count];
    main_token_reftypes= new unsigned char[desired_count];
    main_token_max_count= desired_count;
  }
}

/* I'm now defining HAVE_PUSH_AND_POP for the debugger stub */
#define HAVE_PUSH_AND_POP 1
#ifdef HAVE_PUSH_AND_POP
/*
  Saving and restoring the main_token variables.
  This was conceived for a trick with subqueries that I didn't do,
  but $setup uses it now. The problem is that main_token_*
  variables are global (okay, bad early laziness, but refactoring
  now would be hard). So save them when you're about to parse
  something else e.g. a local subquery, and restore when the
  subquery is done. Optimistically I call this push + pop, but
  in fact can only save one level. Expect text to be saved elsewhere.
*/
void MainWindow::main_token_push()
{
  assert(sizeof(main_token_offsets[0] == sizeof(int)));
  assert(sizeof(main_token_lengths[0] == sizeof(int)));
  assert(sizeof(main_token_types[0] == sizeof(int)));
  assert(sizeof(main_token_flags[0] == sizeof(unsigned int)));
  assert(sizeof(main_token_pointers[0] == sizeof(int)));
  assert(sizeof(main_token_reftypes[0] == sizeof(unsigned char)));
  saved_main_token_count_in_all= main_token_count_in_all;
  saved_main_token_count_in_statement= main_token_count_in_statement;
  saved_main_token_number= main_token_number;
  saved_main_token_offsets= new int[saved_main_token_count_in_all];
  saved_main_token_lengths= new int[saved_main_token_count_in_all];
  saved_main_token_types= new int[saved_main_token_count_in_all];
  saved_main_token_flags= new unsigned int[saved_main_token_count_in_all];
  saved_main_token_pointers= new int[saved_main_token_count_in_all];
  saved_main_token_reftypes= new unsigned char[saved_main_token_count_in_all];
  memcpy(saved_main_token_offsets, main_token_offsets, saved_main_token_count_in_all * sizeof(int));
  memcpy(saved_main_token_lengths, main_token_lengths, saved_main_token_count_in_all * sizeof(int));
  memcpy(saved_main_token_types, main_token_types, saved_main_token_count_in_all * sizeof(int));
  memcpy(saved_main_token_flags, main_token_flags, saved_main_token_count_in_all * sizeof(unsigned int));
  memcpy(saved_main_token_pointers, main_token_pointers, saved_main_token_count_in_all * sizeof(int));
  memcpy(saved_main_token_reftypes, main_token_reftypes, saved_main_token_count_in_all * sizeof(unsigned char));
}
void MainWindow::main_token_pop()
{
  memcpy(main_token_offsets, saved_main_token_offsets, saved_main_token_count_in_all * sizeof(int));
  memcpy(main_token_lengths, saved_main_token_lengths, saved_main_token_count_in_all * sizeof(int));
  memcpy(main_token_types, saved_main_token_types, saved_main_token_count_in_all * sizeof(int));
  memcpy(main_token_flags, saved_main_token_flags, saved_main_token_count_in_all * sizeof(unsigned int));
  memcpy(main_token_pointers, saved_main_token_pointers, saved_main_token_count_in_all * sizeof(int));
  memcpy(main_token_reftypes, saved_main_token_reftypes, saved_main_token_count_in_all * sizeof(unsigned char));
  delete [] saved_main_token_reftypes;
  delete [] saved_main_token_pointers;
  delete [] saved_main_token_flags;
  delete [] saved_main_token_types;
  delete [] saved_main_token_lengths;
  delete [] saved_main_token_offsets;
  main_token_count_in_all= saved_main_token_count_in_all;
  main_token_count_in_statement= saved_main_token_count_in_statement;
  main_token_number= saved_main_token_number;
}
#endif


/*
  ACTIONS
  ! All action_ functions must be in the "public slots" area of ocelotgui.h
*/

/*
  action_statement_edit_widget_text_changed() is a slot.
  Actually the connect() was for statement_edit_widget->document()'s
  contentsChange(), rather than statement_edit_widget's textChanged(),
  but I don't see any difference.
  This routine can cause the document to change, causing a signal
  and we get action_statement_edit_widget_text_changed() again.
  It would be infinite. We have two ways to prevent the loop, and we
  use them both (yes it's redundant but this loop really worries me):
    exit if a global flag is on
    disconnect to ensure this slot won't be activated by signals that it itself generates.
  Todo: A hang occurs sometimes, and log() suggests it's in this routine.
        That's why there are so many log() and assert() invocations.
  Until May 2017 I used blockSignals(true)+blockSignals(false) instead
  of disconnect+connect; also I set statement_edit_widget_text_changed_flag= 1;
  within the routine; I hope these changes are safe.
*/
void MainWindow::action_statement_edit_widget_text_changed(int position,int chars_removed,int chars_added)
{
  log("action_statement_edit_widget_text_changed start", 90);
  if (statement_edit_widget_text_changed_flag != 0)
  {
    position_for_redo= position;
    chars_removed_for_redo= chars_removed;
    chars_added_for_redo= chars_added;
    return;
  }
  log("action_statement_edit_widget_text_changed after flag check", 90);
  //statement_edit_widget_text_changed_flag= 1;
  //statement_edit_widget->document()->blockSignals(true);
  disconnect(statement_edit_widget->document(), SIGNAL(contentsChange(int,int,int)), this, SLOT(action_statement_edit_widget_text_changed(int,int,int)));

  QString text;
  int i;
  int pos;

  /* Syntax highlighting */
  text= statement_edit_widget->toPlainText(); /* or I could just pass this to tokenize() directly */

  /* Todo: avoid total tokenize() + tokens_to_keywords() if user is just adding at end */
  main_token_new(text.size());
  tokenize(text.data(),
           text.size(),
           main_token_lengths, main_token_offsets, main_token_max_count,
           (QChar*)"33333", 1, ocelot_delimiter_str, 1);

  tokens_to_keywords(text, 0, sql_mode_ansi_quotes);
  if (((ocelot_statement_syntax_checker.toInt()) & FLAG_FOR_HIGHLIGHTS) != 0)
  {
    hparse_f_multi_block(text); /* recognizer */
  }
  log("action_statement_edit_widget_text_changed after hparse_f_multi_block", 90);
  completer_widget->updater();
  /* This "sets" the colour, it does not "merge" it. */
  /* Do not try to set underlines, they won't go away. */
  QTextDocument *pDoc= statement_edit_widget->document();
  QTextCursor cur(pDoc);

  /* cur.select (QTextCursor::Document); */ /* desperate attempt to fix so undo/redo is not destroyed ... does not work */

  QTextCharFormat format_of_other;
  format_of_other.setForeground(QColor(qt_color(ocelot_statement_text_color)));

  pos= 0;
  /* cur.setPosition(pos, QTextCursor::KeepAnchor); */

  cur.joinPreviousEditBlock(); /* was cur.beginEditBlock() till 2017-07-23 */
  /* ought to affect undo/redo stack? */

  {
    /* This sets everything to normal format / no underline. Gets overridden by token formats. */
    QTextCharFormat format_of_white_space;
    cur.setPosition(0, QTextCursor::MoveAnchor);
    cur.setPosition(text.size(), QTextCursor::KeepAnchor);
    format_of_white_space= format_of_other;
    format_of_white_space.setUnderlineStyle(QTextCharFormat::NoUnderline);
    cur.setCharFormat(format_of_white_space);
  }

  log("action_statement_edit_widget_text_changed loop start", 90);

  for (i= 0; main_token_lengths[i] != 0; ++i)
  {
    assert(main_token_lengths[i] > 0);
    assert(main_token_lengths[i] <= text.size());
    assert(main_token_offsets[i] >= 0);
    assert(main_token_offsets[i] <= text.size());
    assert(pos >= 0);
    assert(pos <= text.size());
    assert(i >= 0);
    assert(i <= (int) main_token_max_count);
    QTextCharFormat format_of_current_token;
    /* Todo: find out why this is necessary. It looks redundant but without it there's trouble. */
    for (; pos < main_token_offsets[i]; ++pos)
    {
      cur.setPosition(pos, QTextCursor::MoveAnchor);
      format_of_current_token= format_of_other;
      format_of_current_token.setUnderlineStyle(QTextCharFormat::NoUnderline);
      cur.setCharFormat(format_of_current_token);
      /* cur.clearSelection(); */
    }
    QString mid_next_token= "";
    if (main_token_lengths[i + 1] == 1) mid_next_token= text.mid(main_token_offsets[i + 1], 1);
    format_of_current_token= get_format_of_current_token(main_token_types[i], main_token_flags[i], mid_next_token);
    /* Todo: consider using SpellCheckUnderline instead of WaveUnderline. */
    if ((main_token_flags[i] & TOKEN_FLAG_IS_ERROR) != 0)
    {
      format_of_current_token.setUnderlineStyle(QTextCharFormat::WaveUnderline);
      format_of_current_token.setUnderlineColor(Qt::red);
    }
    else
    {
      //format_of_current_token.setUnderlineStyle(QTextCharFormat::NoUnderline);
    }

    cur.setPosition(pos, QTextCursor::MoveAnchor);
    cur.setPosition(pos + main_token_lengths[i], QTextCursor::KeepAnchor);
    cur.setCharFormat(format_of_current_token);
    pos+= main_token_lengths[i];
  }

  log("action_statement_edit_widget_text_changed loop end", 90);
  cur.endEditBlock();

  /* Todo: consider what to do about trailing whitespace. */

  widget_sizer(); /* Perhaps adjust relative sizes of the main widgets. */
  log("action_statement_edit_widget_text_changed after widget_sizer", 90);
  //statement_edit_widget->document()->blockSignals(false);
  connect(statement_edit_widget->document(), SIGNAL(contentsChange(int,int,int)), this, SLOT(action_statement_edit_widget_text_changed(int,int,int)));
  //statement_edit_widget_text_changed_flag= 0;
  log("action_statement_edit_widget_text_changed end", 90);
}


QTextCharFormat MainWindow::get_format_of_current_token(int token_type, int token_flags, QString mid_next_token)
{
  QTextCharFormat format_of_literal;
  format_of_literal.setForeground(QColor(qt_color(ocelot_statement_highlight_literal_color)));
  QTextCharFormat format_of_identifier;
  format_of_identifier.setForeground(QColor(qt_color(ocelot_statement_highlight_identifier_color)));
  QTextCharFormat format_of_comment;
  format_of_comment.setForeground(QColor(qt_color(ocelot_statement_highlight_comment_color)));
  QTextCharFormat format_of_operator;
  format_of_operator.setForeground(QColor(qt_color(ocelot_statement_highlight_operator_color)));
  QTextCharFormat format_of_reserved_word;
  format_of_reserved_word.setForeground(QColor(qt_color(ocelot_statement_highlight_keyword_color)));
  QTextCharFormat format_of_function;
  format_of_function.setForeground(QColor(qt_color(ocelot_statement_highlight_function_color)));
  QTextCharFormat format_of_other;
  format_of_other.setForeground(QColor(qt_color(ocelot_statement_text_color)));
  QTextCharFormat format_of_current_token;
  int t= token_type;
  if (t == TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE) format_of_current_token= format_of_literal;
  if (t == TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE) format_of_current_token= format_of_literal;
  if (t == TOKEN_TYPE_LITERAL_WITH_DIGIT) format_of_current_token= format_of_literal;
  /* literal_with_brace == literal */
  if (t == TOKEN_TYPE_LITERAL_WITH_BRACE) format_of_current_token= format_of_literal; /* obsolete? */
  if (t == TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK) format_of_current_token= format_of_identifier;
  if (t == TOKEN_TYPE_IDENTIFIER_WITH_DOUBLE_QUOTE) format_of_current_token= format_of_identifier;
  if (t == TOKEN_TYPE_IDENTIFIER) format_of_current_token= format_of_identifier;
  if (t == TOKEN_TYPE_IDENTIFIER_WITH_AT) format_of_current_token= format_of_identifier;
  if (t == TOKEN_TYPE_COMMENT_WITH_SLASH) format_of_current_token= format_of_comment;
  if (t == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE) format_of_current_token= format_of_comment;
  if (t == TOKEN_TYPE_COMMENT_WITH_MINUS) format_of_current_token= format_of_comment;
  if (t == TOKEN_TYPE_OPERATOR) format_of_current_token= format_of_operator;
  if (t >= TOKEN_KEYWORDS_START)
  {
    if (((token_flags & TOKEN_FLAG_IS_FUNCTION) != 0)
     && (mid_next_token == "("))
    {
      format_of_current_token= format_of_function;
    }
    else format_of_current_token= format_of_reserved_word;
  }
  if (t == TOKEN_TYPE_OTHER) format_of_current_token= format_of_other;

  return format_of_current_token;
}

/*
  For menu item "connect" we said connect(...SLOT(action_connect())));
  By default this is on and associated with File|Connect menu item.
  Actually connect will be attempted depending on defaults and command-line parameters.
*/
void MainWindow::action_connect()
{
  action_connect_once(tr("File|Connect"));
}


/*
  If we're connecting, action_connect() calls action_connect_once with arg = "File|Connect".
  If we're printing for --help, print_help calls action_connect_once with arg = "Print".
  Todo:
  If user types OK and there's an error, repeat the dialog box with a new message e.g. "Connect failed ...".
  This is called from program-start!
  This should put "CONNECT" in the statement widget and cause its execution, so it shows up on the history widget.
*/

void MainWindow::action_connect_once(QString message)
{
  int column_count;
  QString *row_form_label;
  int *row_form_type;
  int *row_form_is_password;
  QString *row_form_data;
  QString *row_form_width;
  QString row_form_title;
  QString row_form_message;
  int i;
  Row_form_box *co;
  row_form_label= 0;
  row_form_type= 0;
  row_form_is_password= 0;
  row_form_data= 0;
  row_form_width= 0;
  column_count= 85; /* If you add or remove items, you have to change this */
  row_form_label= new QString[column_count];
  row_form_type= new int[column_count];
  row_form_is_password= new int[column_count];
  row_form_data= new QString[column_count];
  row_form_width= new QString[column_count];
  row_form_label[i=0]= QString(strvalues[TOKEN_KEYWORD_HOST].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_host; row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PORT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_port); row_form_width[i]= '\x04';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_USER].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_user; row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DATABASE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_database; row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SOCKET].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_unix_socket; row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PASSWORD].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 1; row_form_data[i]= ocelot_password; row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PROTOCOL].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_protocol; row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_INIT_COMMAND].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_init_command; row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_ABORT_SOURCE_ON_ERROR].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_abort_source_on_error); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_AUTO_REHASH].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_auto_rehash); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_AUTO_VERTICAL_OUTPUT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_auto_vertical_output); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_BATCH].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_batch); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_BINARY_MODE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_binary_mode); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_BIND_ADDRESS].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_bind_address; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_CHARACTER_SETS_DIR].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_set_charset_dir; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_COLUMN_NAMES].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_result_grid_column_names); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_COLUMN_TYPE_INFO].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_column_type_info); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_COMMENTS].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_comments); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_COMPRESS].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_opt_compress); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_CONNECT_EXPIRED_PASSWORD].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_opt_can_handle_expired_passwords); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_CONNECT_TIMEOUT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_opt_connect_timeout); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEBUG].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_debug; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEBUG_CHECK].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_debug_check); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEBUG_INFO].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_debug_info); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEFAULT_AUTH].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_default_auth; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEFAULT_CHARACTER_SET].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_set_charset_name; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEFAULTS_EXTRA_FILE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_defaults_extra_file; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEFAULTS_FILE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_defaults_file; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEFAULTS_GROUP_SUFFIX].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_defaults_group_suffix; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DELIMITER].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_delimiter_str; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_ENABLE_CLEARTEXT_PLUGIN].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_enable_cleartext_plugin); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_EXECUTE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_execute; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_FORCE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_force); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_HELP].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0;  row_form_data[i]= QString::number(ocelot_help); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_HISTFILE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_history_hist_file_name; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_HISTIGNORE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_histignore; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_HTML].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_html); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_IGNORE_SPACES].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ignore_spaces); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_LD_RUN_PATH].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_ld_run_path; row_form_width[i]= '\x05';
  if (is_libmysqlclient_loaded != 0) row_form_type[i]= (row_form_type[i] | READONLY_FLAG);
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_LINE_NUMBERS].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_line_numbers); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_LOCAL_INFILE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_opt_local_infile); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_LOGIN_PATH].chars).toLower();; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_login_path; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_MAX_ALLOWED_PACKET].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_max_allowed_packet); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_MAX_JOIN_SIZE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_max_join_size); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_NAMED_COMMANDS].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_named_commands); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_NET_BUFFER_LENGTH].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_net_buffer_length); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_NO_BEEP].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_no_beep); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_NO_DEFAULTS].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_no_defaults); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_OCELOT_DBMS].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_dbms; row_form_width[i]= '\x09';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_ONE_DATABASE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_one_database); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PAGER].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_pager; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PIPE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_pipe); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PLUGIN_DIR].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_plugin_dir; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PRINT_DEFAULTS].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_print_defaults); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PROMPT].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_prompt; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_QUICK].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_quick); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_RAW].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_raw); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_RECONNECT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_opt_reconnect); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SAFE_UPDATES].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_safe_updates); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SECURE_AUTH].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_secure_auth); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SELECT_LIMIT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_select_limit); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SERVER_PUBLIC_KEY].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_server_public_key; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SHARED_MEMORY_BASE_NAME].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_shared_memory_base_name; row_form_width[i]= '\x05';
  /* It used to crash if I said number(ocelot_history_includes_warnings). Problem has disappeared. */
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SHOW_WARNINGS].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_history_includes_warnings); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SIGINT_IGNORE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_sigint_ignore); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SILENT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_silent); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_CA].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_ca; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_CAPATH].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_capath; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_CERT].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_cert; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_CIPHER].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_cipher; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_CRL].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_crl; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_CRLPATH].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_crlpath; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_KEY].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_key; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_MODE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_mode; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_VERIFY_SERVER_CERT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_opt_ssl_verify_server_cert); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SYSLOG].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_syslog); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_TABLE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_table); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_TEE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_history_tee_file_name; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_UNBUFFERED].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_unbuffered); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_VERBOSE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_verbose); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_VERSION].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_version); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_VERTICAL].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_vertical); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_WAIT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_wait); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_XML].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_xml); row_form_width[i]= '\x05';
  assert(i == column_count - 1);
  if (message == "Print")
  {
    char output_string[5120];
    for (int j= 0; j < i; ++j)
    {
      strcpy(output_string, row_form_label[j].toUtf8());
      printf("%-34s", output_string);
      strcpy(output_string, row_form_data[j].toUtf8());
      printf("%s\n", output_string);
    }
  }
  else /* if (message == "File|Connect") */
  {

    row_form_title= menu_strings[menu_off + MENU_CONNECTION_DIALOG_BOX];
    row_form_message= message;

    co= new Row_form_box(column_count, row_form_label,
                                       row_form_type,
                                       row_form_is_password, row_form_data,
  //                                     row_form_width,
                                       row_form_title,
                                       menu_strings[menu_off + MENU_FILE_CONNECT_HEADING],
                                       this);
    co->exec();

    if (co->is_ok == 1)
    {
      ocelot_host= row_form_data[0].trimmed();
      ocelot_port= to_long(row_form_data[1].trimmed());
      ocelot_user= row_form_data[2].trimmed();
      ocelot_database= row_form_data[3].trimmed();
      ocelot_unix_socket= row_form_data[4].trimmed();
      ocelot_password= row_form_data[5].trimmed();
      ocelot_protocol= row_form_data[6].trimmed(); ocelot_protocol_as_int= get_ocelot_protocol_as_int(ocelot_protocol);
      ocelot_init_command= row_form_data[7].trimmed();
      ocelot_abort_source_on_error= to_long(row_form_data[8].trimmed());
      ocelot_auto_rehash= to_long(row_form_data[9].trimmed());

      i= 10;
      ocelot_auto_vertical_output= to_long(row_form_data[i++].trimmed());
      ocelot_batch= to_long(row_form_data[i++].trimmed());
      ocelot_binary_mode= to_long(row_form_data[i++].trimmed());
      ocelot_bind_address= row_form_data[i++].trimmed();
      ocelot_set_charset_dir= row_form_data[i++].trimmed(); /* "character_sets_dir" */
      ocelot_result_grid_column_names= to_long(row_form_data[i++].trimmed());
      ocelot_column_type_info= to_long(row_form_data[i++].trimmed());
      ocelot_comments= to_long(row_form_data[i++].trimmed());
      ocelot_opt_compress= to_long(row_form_data[i++].trimmed());
      ocelot_opt_can_handle_expired_passwords= to_long(row_form_data[i++].trimmed());
      ocelot_opt_connect_timeout= to_long(row_form_data[i++].trimmed());
      ocelot_debug= row_form_data[i++].trimmed();
      ocelot_debug_check= to_long(row_form_data[i++].trimmed());
      ocelot_debug_info= to_long(row_form_data[i++].trimmed());
      ocelot_default_auth= row_form_data[i++].trimmed();
      ocelot_set_charset_name= row_form_data[i++].trimmed(); /* "default_character_set" */
      ocelot_defaults_extra_file= row_form_data[i++].trimmed();
      ocelot_defaults_file= row_form_data[i++].trimmed();
      ocelot_defaults_group_suffix= row_form_data[i++].trimmed();
      ocelot_delimiter_str= row_form_data[i++].trimmed();
      ocelot_enable_cleartext_plugin= to_long(row_form_data[i++].trimmed());
      ocelot_execute= row_form_data[i++].trimmed();
      ocelot_force= to_long(row_form_data[i++].trimmed());
      ocelot_help= to_long(row_form_data[i++].trimmed());
      ocelot_history_hist_file_name= row_form_data[i++].trimmed();
      ocelot_histignore= row_form_data[i++].trimmed();
      ocelot_html= to_long(row_form_data[i++].trimmed());
      ocelot_ignore_spaces= to_long(row_form_data[i++].trimmed());
      ocelot_ld_run_path= row_form_data[i++].trimmed();
      ocelot_line_numbers= to_long(row_form_data[i++].trimmed());
      ocelot_opt_local_infile= to_long(row_form_data[i++].trimmed());
      ocelot_login_path= row_form_data[i++].trimmed();
      ocelot_max_allowed_packet= to_long(row_form_data[i++].trimmed());
      ocelot_max_join_size= to_long(row_form_data[i++].trimmed());
      ocelot_named_commands= to_long(row_form_data[i++].trimmed());
      ocelot_net_buffer_length= to_long(row_form_data[i++].trimmed());
      ocelot_no_beep= to_long(row_form_data[i++].trimmed());
      ocelot_no_defaults= to_long(row_form_data[i++].trimmed());
      connect_set_variable("ocelot_dbms", "=", row_form_data[i++].trimmed());
      ocelot_one_database= to_long(row_form_data[i++].trimmed());
      ocelot_pager= row_form_data[i++].trimmed();
      ocelot_pipe= to_long(row_form_data[i++].trimmed());
      ocelot_plugin_dir= row_form_data[i++].trimmed();
      ocelot_print_defaults= to_long(row_form_data[i++].trimmed());
      ocelot_prompt= row_form_data[i++].trimmed();
      ocelot_quick= to_long(row_form_data[i++].trimmed());
      ocelot_raw= to_long(row_form_data[i++].trimmed());
      ocelot_opt_reconnect= to_long(row_form_data[i++].trimmed());
      ocelot_safe_updates= to_long(row_form_data[i++].trimmed());
      ocelot_secure_auth= to_long(row_form_data[i++].trimmed());
      ocelot_select_limit= to_long(row_form_data[i++].trimmed());
      ocelot_server_public_key= row_form_data[i++].trimmed();
      ocelot_shared_memory_base_name= row_form_data[i++].trimmed();
      ocelot_history_includes_warnings= to_long(row_form_data[i++].trimmed());
      ocelot_sigint_ignore= to_long(row_form_data[i++].trimmed());
      ocelot_silent= to_long(row_form_data[i++].trimmed());
      ocelot_opt_ssl= row_form_data[i++].trimmed();
      ocelot_opt_ssl_ca= row_form_data[i++].trimmed();
      ocelot_opt_ssl_capath= row_form_data[i++].trimmed();
      ocelot_opt_ssl_cert= row_form_data[i++].trimmed();
      ocelot_opt_ssl_cipher= row_form_data[i++].trimmed();
      ocelot_opt_ssl_crl= row_form_data[i++].trimmed();
      ocelot_opt_ssl_crlpath= row_form_data[i++].trimmed();
      ocelot_opt_ssl_key= row_form_data[i++].trimmed();
      ocelot_opt_ssl_mode= row_form_data[i++].trimmed();
      ocelot_opt_ssl_verify_server_cert= to_long(row_form_data[i++].trimmed());
      ocelot_syslog= to_long(row_form_data[i++].trimmed());
      ocelot_table= to_long(row_form_data[i++].trimmed());
      ocelot_history_tee_file_name= row_form_data[i++].trimmed();
      ocelot_unbuffered= to_long(row_form_data[i++].trimmed());
      ocelot_verbose= to_long(row_form_data[i++].trimmed());
      ocelot_version= row_form_data[i++].trimmed().toInt();
      ocelot_vertical= to_long(row_form_data[i++].trimmed());
      ocelot_wait= to_long(row_form_data[i++].trimmed());
      ocelot_xml= to_long(row_form_data[i++].trimmed());
      assert(i == column_count);
      /* This should ensure that a record goes to the history widget */
      /* Todo: clear statement_edit_widget first */
      statement_edit_widget->insertPlainText("CONNECT");
      action_execute(1);
      if (ocelot_init_command > "")
      {
        statement_edit_widget->insertPlainText(ocelot_init_command);
        action_execute(1);
      }
    }
    delete(co);
  }

  if (row_form_width != 0) delete [] row_form_width;
  if (row_form_data != 0) delete [] row_form_data;
  if (row_form_is_password != 0)  delete [] row_form_is_password;
  if (row_form_type != 0) delete [] row_form_type;
  if (row_form_label != 0) delete [] row_form_label;
}

/*
  For menu item "exit" we said connect(...SLOT(action_exit())));
  By default this is on and associated with File|Exit menu item.
  Stop the program.
  Re result_grid_tab_widget->close():
    MainWindow close will close children anyway but this forces a certain ordering.
    If result grid is not closed first, you can get a crash by selecting, then
    detaching, then setting focus to the result grid, then ^Q to exit.
    Todo: since this is a kludge not a fix, investigate more. Maybe valgrind would help.
*/
void MainWindow::action_exit()
{
  log("action_exit start", 90);
  if (ocelot_dbms.contains("tarantool", Qt::CaseInsensitive))
  {
    /* Todo: if there was a successful connection, close it */
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
#ifdef DBMS_TARANTOOL
#if (OCELOT_THIRD_PARTY != 1)
    if (is_libtarantool_loaded == 1) { dlclose(libtarantool_handle); is_libtarantool_loaded= 0; }
    //if (is_libtarantoolnet_loaded == 1) { dlclose(libtarantoolnet_handle); is_libtarantoolnet_loaded= 0; }
#endif
#endif
#endif
  }
#if (OCELOT_MYSQL_INCLUDE == 1)
  else
  {
#if (OCELOT_MYSQL_DEBUGGER == 1)
    /* Get rid of debuggee if it's still around. */
    /* Todo: this might not be enough. Maybe you should be intercepting the "close window" event. */
    if (menu_debug_action_exit->isEnabled() == true) action_debug_exit();
#endif
    /* Usually this closes main connection, kill connection or debug connection probably are = 0 */
    for (int i= 0; i < MYSQL_MAX_CONNECTIONS; ++i)
    {
      if (connected[i] != 0)
      {
        lmysql->ldbms_mysql_close(&mysql[i]);
        connected[i]= 0;
      }
    }
    if (is_mysql_library_init_done == true)
    {
      /*
        This assumes mysql_thread_end() was done for any debugger or kill threads,
        but we don't call mysql_thread_end() for the main thread (is that okay?).
        If we don't call mysql_library_end(), we'll get a few extra valgrind complaints.
      */
      lmysql->ldbms_mysql_library_end();
      is_mysql_library_init_done= false;
    }
    /* Some code added 2015-08-25 due to valgrind */
    if (lmysql != 0) { delete lmysql; lmysql= 0; }
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
    if (is_libmysqlclient_loaded == 1) { dlclose(libmysqlclient_handle); is_libmysqlclient_loaded= 0; }
    if (is_libcrypto_loaded == 1) { dlclose(libcrypto_handle); is_libcrypto_loaded= 0; }
#endif
  }
#endif //if (OCELOT_MYSQL_INCLUDE == 1)
  delete_utf8_copies();
  log("action_exit mid", 90);
  result_grid_tab_widget->close(); /* See the comment before the start of this function */
  close(); /* Assuming quitOnLastWindowClosed is applicable, the program should exit so log won't happen */
  log("action_exit end", 90);
}

#if (OCELOT_IMPORT_EXPORT == 1)

/*
  Especially for dialog boxes, there will be times that we want a list box of possibilities.
  I'd like to produce the list once and consistently.
  And I know that hparse can figure out what's possible.
  Example: I want to get a list of the export types.
           Pass SET ocelot_export = format
           Result: TEXT or TABLE or HTML or NONE (and maybe someday DEFAULT) will be in hparse_expected.
           Split that  into a QStringList with " or " as separator with QString::split().
           Warning: It's case sensitive so OR won't split, but " or " within a string or name will split.
  Todo: Figure out how dangerous this is and when it is possible to call it safely.
        In mitigation, notice that the plan is to call this when we're going to generate a new statement.
  Todo: Doubtless there will be more than one fake statement, so figure out how to decrease overhead.
  Todo: Watch for overflow, don't pass big fake statements, we're expecting main_token_ stuff is sufficient.
  Todo: Save completer_widget, or use it rather than hparse_expected, or make sure you don't call it.
  Todo: Once this is okay, row_form_box() should be able to take a combo box based on
        a fake statement that produces the choices for a list box,
        and the initial list box choice is the fake statement to produce the choices,
        and is_password is no longer a flag, there's either password-type or normal-text or combo box.
*/
QStringList MainWindow::fake_statement(QString fake_statement_text)
{
  log("fake_statement", 15);
  main_token_push();
  main_token_lengths[0]= 0;
  tokenize(fake_statement_text.data(),
           fake_statement_text.size(),
           &main_token_lengths[0], &main_token_offsets[0], 10,
          (QChar*)"33333", 1, ocelot_delimiter_str, 1);
  tokens_to_keywords(fake_statement_text, 0, sql_mode_ansi_quotes);
  main_token_number= 0;
  hparse_f_multi_block(fake_statement_text);
  QStringList string_list= hparse_expected.split(" or ");
  main_token_pop();
  return string_list;
}

/*
  Called from: action_export_text() action_export_table() action_export_html()
  For menu item "export ..." we said connect(...SLOT(action_export_...())));
  This is on (if there is a result set to export, and associated with File|Export submenu items.
  passed_type = TOKEN_KEYWORD_TEXT | TABLE | HTML | etc. i.e. the submenu choice
  Very similar to action_connect_once(QString message)
  Todo: Use menu_strings[menu_off + n] as we do in action_connect_once().
  When row_form_password[]==2, row_form_box() will call fake_statement to produce possibilities for a combo box.
  Warning: clicking the menu item causes it to be checked, which isn't what I want if dialog box result = cancel.
  Warning: we only pass TOKEN_KEYWORD_EXPORT, the plan for TOKEN_KEYWORD_IMPORT is rather long-term.
*/

int MainWindow::action_export_function(int export_or_import, int passed_type)
{
  (void)export_or_import;
  struct export_settings local_exports;
  export_defaults(passed_type, &local_exports);

  QString message= "export";
  int column_count;
  QString row_form_title;
  QString row_form_message;
  int i;
  Row_form_box *co;
  int co_is_ok;
  if ((passed_type == TOKEN_KEYWORD_TEXT) || (passed_type == TOKEN_KEYWORD_TABLE))
    column_count= 19; /* If you add or remove items, you have to change this */
  else
    column_count= 4;
  QString *row_form_label= new QString[column_count];
  int *row_form_type= new int[column_count];
  int *row_form_is_password= new int[column_count];
  QString *row_form_data= new QString[column_count];
  QString *row_form_width= new QString[column_count];
  row_form_label[i=0]= "into"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= local_exports.file_name; row_form_width[i]= '\x04';
  if ((passed_type == TOKEN_KEYWORD_TEXT) || (passed_type == TOKEN_KEYWORD_TABLE))
  {
    row_form_label[++i]= "columns terminated by"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_export_function_value(local_exports.columns_terminated_by); row_form_width[i]= '\x04';
    row_form_label[++i]= "columns enclosed by"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_export_function_value(local_exports.columns_enclosed_by); row_form_width[i]= '\x04';
    row_form_label[++i]= "  (optionally)"; row_form_type[i]= 0; row_form_is_password[i]= 3; row_form_data[i]= bool_to_string(local_exports.columns_optionally); row_form_width[i]= '\x04';
    row_form_label[++i]= "columns escaped by"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_export_function_value(local_exports.columns_escaped_by); row_form_width[i]= '\x04';
    row_form_label[++i]= "lines starting by"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_export_function_value(local_exports.lines_starting_by); row_form_width[i]= '\x04';
    row_form_label[++i]= "lines terminated by"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_export_function_value(local_exports.lines_terminated_by); row_form_width[i]= '\x04';
  }
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_MAX_ROW_COUNT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(local_exports.max_row_count); row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_COLUMN_NAMES].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 3; row_form_data[i]= bool_to_string(local_exports.column_names); row_form_width[i]= '\x50';
  if ((passed_type == TOKEN_KEYWORD_TEXT) || (passed_type == TOKEN_KEYWORD_TABLE))
  {
    row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_QUERY].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 3; row_form_data[i]= bool_to_string(local_exports.query); row_form_width[i]= '\x50';
    row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_ROW_COUNT].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 3; row_form_data[i]= bool_to_string(local_exports.row_count); row_form_width[i]= '\x50';
    row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_MARGIN].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(local_exports.margin); row_form_width[i]= '\x50';
    row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PAD].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 3; row_form_data[i]= bool_to_string(local_exports.pad); row_form_width[i]= '\x50';
    row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_LAST].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 3; row_form_data[i]= bool_to_string(local_exports.last); row_form_width[i]= '\x50';
    row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DIVIDER].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 3; row_form_data[i]= bool_to_string(local_exports.divider); row_form_width[i]= '\x50';
    row_form_label[++i]= "if null"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_export_function_value(local_exports.if_null); row_form_width[i]= '\x04';
    row_form_label[++i]= "replace"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_export_function_value(local_exports.replace_string); row_form_width[i]= '\x04';
    row_form_label[++i]= "  with"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_export_function_value(local_exports.with_string); row_form_width[i]= '\x04';
  }
  row_form_label[++i]= "if file exists"; row_form_type[i]= 0; row_form_is_password[i]= 4; row_form_data[i]= action_export_function_value(local_exports.if_file_exists); row_form_width[i]= '\x04';
  assert(i == column_count - 1);
  /* if (message == "File|Connect") */
  {
    row_form_title= "Export Dialog Box"; /* todo: there should be something in ostrings.h for this */
    row_form_message= message;

    co= new Row_form_box(column_count, row_form_label,
                                       row_form_type,
                                       row_form_is_password, row_form_data,
  //                                     row_form_width,
                                       row_form_title,
                                       "options (often the defaults are good so you can just press OK)",
                                       this);
    co->exec();
    co_is_ok= co->is_ok;
    if (co->is_ok == 1)
    {
      /* local_exports.type= TOKEN_KEYWORD_TEXT|TABLE|HTML|NONE */
      local_exports.type= passed_type;
      local_exports.file_name= row_form_data[i=0].trimmed();
      ++i;
      if ((passed_type == TOKEN_KEYWORD_TEXT) || (passed_type == TOKEN_KEYWORD_TABLE))
      {
        local_exports.columns_terminated_by= row_form_data[i++].trimmed().toUtf8();
        local_exports.columns_enclosed_by= row_form_data[i++].trimmed().toUtf8();
        local_exports.columns_optionally= string_to_bool(row_form_data[i++]); /* don't need to trim? */
        local_exports.columns_escaped_by= row_form_data[i++].trimmed().toUtf8();
        local_exports.lines_starting_by= row_form_data[i++].trimmed().toUtf8();
        local_exports.lines_terminated_by= row_form_data[i++].trimmed().toUtf8();
      }
      local_exports.max_row_count= to_long(row_form_data[i++].trimmed());
      local_exports.column_names= string_to_bool(row_form_data[i++]);
      if ((passed_type == TOKEN_KEYWORD_TEXT) || (passed_type == TOKEN_KEYWORD_TABLE))
      {
        local_exports.query= string_to_bool(row_form_data[i++]);
        local_exports.row_count= string_to_bool(row_form_data[i++]);
        local_exports.margin= row_form_data[i++].trimmed().toUtf8().toInt();
        local_exports.pad= string_to_bool(row_form_data[i++]);
        local_exports.last= string_to_bool(row_form_data[i++]);
        local_exports.divider= string_to_bool(row_form_data[i++]);
        local_exports.if_null= row_form_data[i++].trimmed().toUtf8();
        local_exports.replace_string= row_form_data[i++].trimmed().toUtf8();
        local_exports.with_string= row_form_data[i++].trimmed().toUtf8();
      }
      local_exports.if_file_exists= row_form_data[i++].trimmed().toUtf8();
      /* todo: maybe I should be appending with row_form_data[] and letting the statement be not fake */
      QString text;
      QString token;
      text= "SET ocelot_export = FORMAT ";
      main_token_count_in_statement= 4;
      if (local_exports.type == TOKEN_KEYWORD_TEXT) token= "'text' ";
      else if (local_exports.type == TOKEN_KEYWORD_TABLE) token= "'table' ";
      else if (local_exports.type == TOKEN_KEYWORD_HTML) token= "'html' ";
      text= text + token;
      ++main_token_count_in_statement;
      text= text + action_export_function_clause("INTO", local_exports.file_name);
      main_token_count_in_statement+= 2;
      if ((local_exports.type == TOKEN_KEYWORD_TEXT) || (local_exports.type == TOKEN_KEYWORD_TABLE))
      {
        /* e.g. X'09' tab for text or '|' for table */
        text= text + action_export_function_clause("\nCOLUMNS TERMINATED BY", local_exports.columns_terminated_by);
        /* e.g. '' for text or '' for table */
        if (local_exports.columns_optionally == true) text= text + " OPTIONALLY ";
        text= text + action_export_function_clause("ENCLOSED BY", local_exports.columns_enclosed_by);
        /* e.g. '\' for text or '' for table */
        text= text + action_export_function_clause("ESCAPED BY", local_exports.columns_escaped_by);
        /* e.g. '' for text or '|' for table */
        text= text + action_export_function_clause("LINES STARTING BY", local_exports.lines_starting_by);
        /* e.g. X'0A' line feed for text or X'0A' for table */
        text= text + action_export_function_clause("TERMINATED BY", local_exports.lines_terminated_by);
        main_token_count_in_statement+= 3 + 1 + 2 + 1 + 2 + 1 + 3 + 1 + 2 + 1;
      }
      text= text + action_export_function_clause_i("\nMAX_ROW_COUNT", local_exports.max_row_count);
      text= text + action_export_function_clause_b("COLUMN_NAMES", local_exports.column_names);
      main_token_count_in_statement+= 1 + 1 + 1 + 1;
      if ((local_exports.type == TOKEN_KEYWORD_TEXT) || (local_exports.type == TOKEN_KEYWORD_TABLE))
      {
        text= text + action_export_function_clause_b("QUERY", local_exports.query);
        text= text + action_export_function_clause_b("ROW_COUNT", local_exports.row_count);
        text= text + action_export_function_clause_i("MARGIN", local_exports.margin);
        text= text + action_export_function_clause_b("PAD", local_exports.pad);
        text= text + action_export_function_clause_b("LAST", local_exports.last);
        text= text + action_export_function_clause_b("DIVIDER", local_exports.divider);
        text= text + action_export_function_clause("\nIF NULL", local_exports.if_null);
        text= text + action_export_function_clause("\nREPLACE", local_exports.replace_string);
        text= text + action_export_function_clause("WITH", local_exports.with_string);
        main_token_count_in_statement+= 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 2 + 1 + 1;
      }
      text= text + action_export_function_clause("\nIF FILE EXISTS", local_exports.if_file_exists);
      main_token_count_in_statement+= 3 + 1;
      text= text + ";";
      ++main_token_count_in_statement;
      action_change_one_setting_execute(text);
      /* menu_file_export_..._action->setChecked(...) has happened if the execution succeeded */
    }
    else
    {
      /* user chose cancel, so the check mark should go back to the original place */
      export_set_checked();
    }
    delete(co);
  }

  if (row_form_width != 0) delete [] row_form_width;
  if (row_form_data != 0) delete [] row_form_data;
  if (row_form_is_password != 0)  delete [] row_form_is_password;
  if (row_form_type != 0) delete [] row_form_type;
  if (row_form_label != 0) delete [] row_form_label;
  return co_is_ok;
}

const char *MainWindow::bool_to_string(bool input)
{
  if (input == true) return "yes"; /* TEST!!! */
  else return "'no'";
}

bool MainWindow::string_to_bool(QString input)
{
  if (input == "yes") return true;
  else return false;
}


/*
  Called from: action_export_function(), for assigning values that might contain characters that don't display.
  Todo: there's a reverse of this somewhere, not what it is.
*/
QString MainWindow::action_export_function_value(QString input)
{
  QString token_for_value= "";
  QString c2;
  for (int i= 0; i < input.size(); ++i)
  {
    c2= input.mid(i, 1);
    if (c2 == "\x08") { token_for_value= token_for_value + "\\b"; continue; }
    if (c2 == "\x09") { token_for_value= token_for_value + "\\t"; continue; }
    if (c2 == "\x0a") { token_for_value= token_for_value + "\\n"; continue; }
    if (c2 == "\x0d") { token_for_value= token_for_value + "\\r"; continue; }
    /* nothing needed for \, I think */
    if (c2 == "\x20") { token_for_value= token_for_value + "\\s"; continue; }
    token_for_value= token_for_value + c2;
  }
  return token_for_value;
}

/*
  An export row_form_box string can be unquoted or hex-quoted, e.g. D or X'44'.
  If it's unquoted, change ' inside the string to '' and surround with ''s.
  If it's hex-quoted, don't change.
  Apparently it's already stripped.
  Todo: This doesn't have to be just for export, it could be good for all row_form_box strings.
*/
QString MainWindow::action_export_function_clause(QString keywords, QString literal)
{
  if ((literal.mid(1, 1) == "'") && (QString::compare(literal.mid(0, 1), "X", Qt::CaseInsensitive) == 0))
    return " " + keywords + " " + literal + " ";
  QString escaped_literal= "";
  for (int i= 0; i < literal.size(); ++i)
  {
    QString c= literal.mid(i, 1);
    //if (c == "\\") escaped_literal= escaped_literal + c;
    if (c == "'") escaped_literal= escaped_literal + c;
    escaped_literal= escaped_literal + c;
  }
  return " " + keywords + " '" + escaped_literal + "' ";
}

QString MainWindow::action_export_function_clause_i(QString keywords, int literal)
{
  return " " + keywords + " " + QString::number(literal) + " ";
}

QString MainWindow::action_export_function_clause_b(QString keywords, bool literal)
{
  QString r= "'yes'";
  if (literal == false) r= "'no'";
  return " " + keywords + " " + r + " ";
}


void MainWindow::action_export_text()
{
  action_export_function(TOKEN_KEYWORD_EXPORT, TOKEN_KEYWORD_TEXT);
}

void MainWindow::action_export_table()
{
  action_export_function(TOKEN_KEYWORD_EXPORT, TOKEN_KEYWORD_TABLE);
}

void MainWindow::action_export_html()
{
  action_export_function(TOKEN_KEYWORD_EXPORT, TOKEN_KEYWORD_HTML);
}

void MainWindow::action_export_none()
{
  main_token_count_in_statement= 5;
  action_change_one_setting_execute("SET OCELOT_EXPORT = NONE;");
}


#endif

/*
  detach
  For SET ocelot_statement_detached (etc.) = "yes|no"; perhaps caused by menu item = Options|detach statement widget
  Major changes for version 1.7 May+June 2022:
    Separate functions for each widget type were consolidated into one function, detach_widget().
    Method "hide + setGeometry + show" worked on only some distros, failed especially badly with Kaos.
    Possibly windows maximized flag was part of the problem, so showNormal() instead.
    Also the height was confusing because when a widget gets detached it increases by title bar size at least.
  Major changes for version 1.8 November 2022:
    Explorer.
  widget_type = TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED or TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED or TOKEN_KEYWORD_OCELOT_GRID_DETACHED or TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED
  TODO: Don't shrink so much that you lose something major in main window
        (maybe expand main window to include title bar size?)
        However, result isn't disastrous if main window is currently too small.
  Would "floating" be a better word than "detached"? or "undock"? or "detachable"?
  Todo: Change border, size, title, frame width, position. Perhaps in Settings dialog.
        Update: now Settings dialog does allow for change of size and position.
  Todo: Menu keys should be slotted to the new window as well as the main window. E.g. control-Q.
        Update: that's what the detach is for.
  Todo: How to bring to front / bring to back? Currently it's always in front of main widget.
  Todo: title bar of result grid widget could show part of query and number of rows.
  Todo: Maybe these should be detached by default, or always detached.
  Todo: Check: Do you lose the parent? If that happens, there will be memory leaks.
  Todo: Detached widgets optionally could have their own menus. Lots of work.
        * Similar to create_menu() with all addActions() work, but mostly
          we can (after separating actions and adding #defines) copy with
          QAction *actionb = menu_edit->actions().at(EDIT_MENU_UNDO);
        * In every routine that uses action_edit_menu_undo etc., pass
          QMenu object so you can use actions().at.
        Otherwise click on menu changes focus to undetached widget.
  Todo: stop using setText("literal"), put translatable messages in ostrings.h
  If top = 'default' then shrink main and put revised widget at bottom.
  If left|width|height = 'default' then we keep current values after detaching.
  Remember: x is left-right axis, y is top-bottom
  Todo: options|detach_history_widget is now useless and obsolete! SET is what matters!
        but we keep options in case we want to make a shortcut
  Todo: support other values: 'current', 'max', 'min', 'always on top', 'no buttons', '30%'
  Todo: (static) main must go back to original size if 'attach'
  Todo: I'm confused: include or exclude window frame? See http://doc.qt.io/qt-5/application-windows.html#window-geometry
  Todo: Equivalent of detach_start and detach_stop for grid widget + debug widget (+ statement widget?)
  Todo: We lose current focus when we detach. Save and restore it.
  Todo: indicate how many pixels each item takes currently, by adding to the combobox
  Todo: * ctrl + tab, ctrl + backtab ... don't work with detached, I tried for a while but gave up
  Todo: * a shortcut for bring to top and focus
  Todo: example.cnf: ocelot_{history|grid|debug_statement}_{detached|top|left|height|width} = n
  Todo: * In ostrings.h: add "attach ..."
  Todo: * Some shortcuts for attach|detach
  Todo: * check again re example.cnf and documentation
  Todo: Possible bug: Kaos only (?): check mark doesn't appear before the word "attach" on options menu
  Todo: bug: if we detach with command-line option, and prompt has time-of-day, time-of-day won't change
*/

/*
  Flags for setWindowFlags().
  Doesn't include Qt::WindowCloseButtonHint so there will be no close button.
  Doesn't include Qt::WindowStaysOnTopHint but in fact it will be on top of other widgets of app.
*/
#define DETACHED_WINDOW_FLAGS Qt::CustomizeWindowHint | Qt::WindowTitleHint | Qt::WindowMinMaxButtonsHint | Qt::WindowSystemMenuHint

void MainWindow::action_option_detach_history_widget(bool checked)
{
  if (checked)
  {
    ocelot_history_detached= "no";
    new_ocelot_history_detached= "yes";
  }
  else
  {
    ocelot_history_detached= "yes";
    new_ocelot_history_detached= "no";
  }
  action_change_one_setting(ocelot_history_detached, new_ocelot_history_detached, TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED);
}

void MainWindow::action_option_detach_result_grid_widget(bool checked)
{
  if (checked)
  {
    ocelot_grid_detached= "no";
    new_ocelot_grid_detached= "yes";
  }
  else
  {
    ocelot_grid_detached= "yes";
    new_ocelot_grid_detached= "no";
  }
  action_change_one_setting(ocelot_grid_detached, new_ocelot_grid_detached, TOKEN_KEYWORD_OCELOT_GRID_DETACHED);
}

#if (OCELOT_MYSQL_DEBUGGER == 1)
void MainWindow::action_option_detach_debug_widget(bool checked)
{
  if (checked)
  {
    ocelot_debug_detached= "no";
    new_ocelot_debug_detached= "yes";
  }
  else
  {
    ocelot_debug_detached= "yes";
    new_ocelot_debug_detached= "no";
  }
  action_change_one_setting(ocelot_debug_detached, new_ocelot_debug_detached, TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED);
}
#endif

void MainWindow::action_option_detach_statement_widget(bool checked)
{
  if (checked)
  {
    ocelot_statement_detached= "no";
    new_ocelot_statement_detached= "yes";
  }
  else
  {
    ocelot_statement_detached= "yes";
    new_ocelot_statement_detached= "no";
  }
  action_change_one_setting(ocelot_statement_detached, new_ocelot_statement_detached, TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED);
}

#if (OCELOT_EXPLORER == 1)
void MainWindow::action_option_detach_explorer_widget(bool checked)
{
  if (checked)
  {
    ocelot_explorer_detached= "no";
    new_ocelot_explorer_detached= "yes";
  }
  else
  {
    ocelot_explorer_detached= "yes";
    new_ocelot_explorer_detached= "no";
  }
  action_change_one_setting(ocelot_explorer_detached, new_ocelot_explorer_detached, TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED);
}
#endif

/*
  See comments preceding action_option_detach_history_widget().
*/
void MainWindow::detach_widget(int widget_type, bool checked)
{
  if (isVisible() == false) return; /* this can be false if main window hasn't appeared yet */
  static int shrink= 0; /* I forget why this is static, but it shouldn't matter. */
  QWidget *widget; /* = statement_edit_widget etc. */
  QString widget_left, widget_top, widget_width, widget_height; /* integer values or "default" */
  QAction *menu_options_action_option_detach_widget; /* e.g. *menu_options_action_option_detach_statement_widget */
  int menu_options_detach_widget; /* e.g. MENU_OPTIONS_DETACH_STATEMENT_WIDGET */
  QString widget_text; /* e.g. "statement widget" */
  int x, y, w, h;
  if (widget_type == TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED)
  {
    widget= (QWidget*) statement_edit_widget;
    menu_options_action_option_detach_widget= menu_options_action_option_detach_statement_widget;
    widget_text= "statement widget";
    menu_options_detach_widget= MENU_OPTIONS_DETACH_STATEMENT_WIDGET;
    widget_left= ocelot_statement_left; widget_top= ocelot_statement_top; widget_width= ocelot_statement_width; widget_height= ocelot_statement_height;
    ocelot_detach_statement_edit_widget= checked;
  }
#if (OCELOT_MYSQL_DEBUGGER == 1)
  else if (widget_type == TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED)
  {
    widget= (QWidget*) debug_tab_widget;
    menu_options_action_option_detach_widget= menu_options_action_option_detach_debug_widget;
    widget_text= "debug widget";
    menu_options_detach_widget= MENU_OPTIONS_DETACH_DEBUG_WIDGET;
    widget_left= ocelot_debug_left; widget_top= ocelot_debug_top; widget_width= ocelot_debug_width; widget_height= ocelot_debug_height;
    ocelot_detach_statement_edit_widget= checked; /* Todo: should this be ocelot_detach_debug_widget= checked? */
  }
#endif
#if (OCELOT_EXPLORER == 1)
  else if (widget_type == TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED)
  {
    widget= (QWidget*) explorer_widget;
    menu_options_action_option_detach_widget= menu_options_action_option_detach_explorer_widget;
    widget_text= "explorer widget";
    menu_options_detach_widget= MENU_OPTIONS_DETACH_EXPLORER_WIDGET;
    widget_left= ocelot_explorer_left; widget_top= ocelot_explorer_top; widget_width= ocelot_explorer_width; widget_height= ocelot_explorer_height;
    ocelot_detach_explorer_widget= checked;
  }
#endif
  else if (widget_type == TOKEN_KEYWORD_OCELOT_GRID_DETACHED)
  {
    widget= (QWidget*) result_grid_tab_widget;
    menu_options_action_option_detach_widget= menu_options_action_option_detach_result_grid_widget;
    widget_text= "result grid widget";
    menu_options_detach_widget= MENU_OPTIONS_DETACH_RESULT_GRID_WIDGET;
    widget_left= ocelot_grid_left; widget_top= ocelot_grid_top; widget_width= ocelot_grid_width; widget_height= ocelot_grid_height;
    ocelot_detach_result_grid_widget= checked;
  }
  else /* if (widget_type == TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED) */
  {
    widget= (QWidget*) history_edit_widget;
    menu_options_action_option_detach_widget= menu_options_action_option_detach_history_widget;
    widget_text= "history widget";
    menu_options_detach_widget= MENU_OPTIONS_DETACH_HISTORY_WIDGET;
    widget_left= ocelot_history_left; widget_top= ocelot_history_top; widget_width= ocelot_history_width; widget_height= ocelot_history_height;
    ocelot_detach_history_widget= checked;
  }

  QPoint widget_point= widget->mapToGlobal(QPoint(0, 0));
  QRect widget_rect= widget->rect();
  if (widget_left == "default") x= widget_point.x();
  else x= widget_left.toInt();
  if (widget_top == "default") y= widget_point.y();
  else y= widget_top.toInt();
  if (widget_width == "default") w= widget_rect.width();
  else w= widget_width.toInt();
  if (widget_height == "default") h= widget_rect.height();
  else h= widget_height.toInt();
  bool is_visible= widget->isVisible();
  QPoint main_point= mapToGlobal(QPoint(0, 0));
  QRect main_rect= rect();
  if (checked)
  {
    menu_options_action_option_detach_widget->setText("attach " + widget_text);
    widget->setWindowFlags(Qt::Window | DETACHED_WINDOW_FLAGS);
    widget->setWindowTitle(widget_text);
    if (widget_top == "default")
    {
      shrink= widget_rect.height();
      shrink+= QApplication::style()->pixelMetric(QStyle::PM_TitleBarHeight);
      int main_rect_height= main_rect.height() - shrink;
      showNormal();
      //hide();
      setGeometry(main_point.x(), main_point.y(), main_rect.width(), main_rect_height);
      //show();
      y= main_point.y() + main_rect_height + QApplication::style()->pixelMetric(QStyle::PM_TitleBarHeight);
    }
    else shrink= 0;
    if (is_visible)
    {
      //widget->hide();
      widget->setGeometry(x, y, w, h - QApplication::style()->pixelMetric(QStyle::PM_TitleBarHeight));
      if (widget_type == TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED) history_edit_widget->detach_start();
      //widget->show();
    }
  }
  else
  {
    if (shrink != 0)
    {
      int main_rect_height= main_rect.height() + shrink;
      setGeometry(main_point.x(), main_point.y(), main_rect.width(), main_rect_height);
      shrink= 0;
    }
    menu_options_action_option_detach_widget->setText(menu_strings[menu_off + menu_options_detach_widget]);
    widget->setWindowFlags(Qt::Widget);
    if (widget_type == TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED) history_edit_widget->detach_stop();
  }
  if (is_visible) widget->show();
}

/*
  Next/Prev focus widget. Qt hardcodes tab | Shift+Tab (backtab) see
  http://www.vikingsoft.eu/keyboard-navigation-and-the-event-system/
  but we want to allow putting tab in any editable window, that is,
  we hardcode autocomplete shortcut = tab but allow it to go in.
  I'm confused about whether the window manager e.g. KDE always will
  override (as it does for Alt+Tab), but I know that if I try
  SET ocelot_shortcut_autocomplete = 'Alt+Tab';
  I get an error message = Illegal value.
  Row_form_box uses setTabChangesFocus() but nothing else does.
  In result grid, maybe we could have Tab for "next cell" and
  shift+tab for "next window". and something else for "Next Tab".
  But, mainly: next/prev is done with a customizable shortcut
  associated with QKeySequence::NextChild / QKeySequence::PreviousChild
  focusNextPrevChild(true) focusNextPrevChild(false).
  See also "Navigating Between Window Panes" according to Microsoft
  https://msdn.microsoft.com/en-us/library/ms971323.aspx
  Todo: for detached windows:
    We can switch to a detached window with setActiveWindow (setFocus won't do,
    something to do with lack of parent). But we would have to keep track of
    whether we want from grid to statement (or tried to), and how to go to the
    first cell in a grid from history. It could be more complicated if
    there are more detached windows, and some might be hidden
    e.g. completer_widget.
    Trick: by comparing QApplication::focusWidget() you can see if focus changed.
    Trick: by seeing if focusNextPrevChild returned false you can see if focus changed.
    But how do you specify you are going to a grid from history?
    I tried going through children till there were no more children, that just crashed.
*/

void MainWindow::action_option_next_window()
{
  focusNextPrevChild(true);
  return;
}

void MainWindow::action_option_previous_window()
{
  focusNextPrevChild(false);
}

/*
  User chose Options|result_display_html|result_display_horizontal|result_display_vertical etc.
  So we change display type, and display again.
  If there is no current widget, the display type changes but there is nothing to re-display.
  Todo: if no change, do nothing
        i.e. compare new and old -- but we ought to be disabling the menu choices anyway
  Todo: show starting with row at current location, not at start
        i.e. change vertial scroll bar
  Todo: disable menu if no current display
  Todo: this isn't doing a permanent change, and maybe that's wrong
        (if you want permanent change, try SET ocelot_batch=1; etc.)
  Todo: there's some checking here to prevent a crash if no result set is on display,
        but I'm not at all sure that it's enough
*/
void MainWindow::action_option_change_result_display(QString next)
{
  int current_index= result_grid_tab_widget->currentIndex();
  if ((current_index >= 0)
   && (current_index <= (ocelot_grid_actual_tabs - 1)))
  {
    ResultGrid *rg;
    rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(current_index));
    if ((rg != NULL) && (rg->isVisible()))
    {
      unsigned short int new_ocelot_batch= 0;
      unsigned short int new_ocelot_html= 0;
      unsigned short int new_ocelot_raw= 0;
      unsigned short int new_ocelot_vertical= 0;
      unsigned short int new_ocelot_xml= 0;
      //unsigned short int old_ocelot_batch= rg->copy_of_ocelot_batch;
      //unsigned short int old_ocelot_html= rg->copy_of_ocelot_html;
      //unsigned short int old_ocelot_raw= rg->copy_of_ocelot_raw;
      //unsigned short int old_ocelot_vertical= rg->copy_of_ocelot_vertical;
      //unsigned short int old_ocelot_xml= rg->copy_of_ocelot_xml;
      if (next == "batch") {new_ocelot_batch= 1; }
      if (next == "horizontal") {;}
      if (next == "html") {new_ocelot_html= 1; }
      if (next == "htmlraw") {new_ocelot_html= 1; new_ocelot_raw= 1; }
      if (next == "raw") {new_ocelot_raw= 1; }
      if (next == "vertical") {new_ocelot_vertical= 1;  }
      if (next == "xml") {new_ocelot_xml= 1;  }
      rg->display(1,
                  new_ocelot_vertical,
                  new_ocelot_batch, new_ocelot_html, new_ocelot_raw, new_ocelot_xml,
                  ocelot_result_grid_column_names);
    }
  }
}

void MainWindow::action_option_batch()
{
  action_option_change_result_display("batch");
}
void MainWindow::action_option_horizontal()
{
    action_option_change_result_display("horizontal");
}
void MainWindow::action_option_html()
{
    action_option_change_result_display("html");
}
void MainWindow::action_option_htmlraw()
{
      action_option_change_result_display("htmlraw");
}
void MainWindow::action_option_raw()
{
      action_option_change_result_display("raw");
}
void MainWindow::action_option_vertical()
{
      action_option_change_result_display("vertical");
}
void MainWindow::action_option_xml()
{
      action_option_change_result_display("xml");
}


/*
  Called from action_about("ocelotgui_logo.png") and action_the_manual("README.htm").
  We might assume that the docs including .png or .jpg files are on application_dir_path
  -- applicationDirPath() ""Returns the directory that contains the application executable" --
  but at build time one can pass -DOCELOTGUI_DOCDIR=x, indeed this is what happens with
  an install via cmake+cpack because they want the docs on /usr/share/doc not /usr/bin.
  But maybe cmake said it would go to /usr/local/share/doc but in fact it went to /usr/share/doc.
  So if we fail once, we try again after stripping /local from the path.
  Todo: have more choice where to look for README.htm
        we could try: according to an option = "documentation" directory
                      ld_run_path, ocelot_login_path, ocelot_plugin_dir
                      some other path used by Qt or MySQL or Linux
                      (prefer the path that has everything)
   We used to look for README.md but Debian gzips that, it doesn't gzip README.htm.
*/
QString MainWindow::get_doc_path(QString file_name)
{
#ifdef OCELOTGUI_DOCDIR
  QString application_dir_path= OCELOTGUI_DOCDIR;
#else
  QString application_dir_path= QCoreApplication::applicationDirPath();
#endif
  QString readme_path= application_dir_path;
  readme_path.append("/");
  readme_path.append(file_name);
  QFile file(readme_path);
  if (file.open(QIODevice::ReadOnly | QIODevice::Text))
  {
    file.close();
    return application_dir_path;
  }
 #ifdef OCELOTGUI_DOCDIR
  int index_of_local= application_dir_path.indexOf("/local/");
  if (index_of_local != -1)
  {
    QString left_path= application_dir_path.left(index_of_local);
    QString right_path= application_dir_path.right(application_dir_path.length() - (index_of_local + strlen("/local")));
    application_dir_path= left_path + right_path;
    readme_path= application_dir_path;
    readme_path.append("/");
    readme_path.append(file_name);
    file.setFileName(readme_path);
    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
      file.close();
      return application_dir_path;
    }
  }
#endif
  return "";
}


void MainWindow::action_about()
{
  QString the_text= "\
<img src=\"./ocelotgui_logo.png\" alt=\"ocelotgui_logo.png\">\
<b>ocelotgui -- Graphical User Interface</b><br>Copyright (c) 2023 by Peter Gulutzan.<br>\
This program is free software: you can redistribute it and/or modify \
it under the terms of the GNU General Public License as published by \
the Free Software Foundation, version 2 of the License,<br>\
<br>\
This program is distributed in the hope that it will be useful, \
but WITHOUT ANY WARRANTY; without even the implied warranty of \
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the \
GNU General Public License for more details.<br>\
<br>\
You should have received a copy of the GNU General Public License \
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.";

  the_text.append("<br><br>");
  the_text.append(get_version());
#if (OCELOT_MYSQL_INCLUDE == 1)
  if (is_mysql_library_init_done == true)
  {
    the_text.append("<br>using DBMS client library version ");
    the_text.append(lmysql->ldbms_mysql_get_client_info());
#ifdef OCELOT_OS_LINUX
#if (OCELOT_STATIC_LIBRARY==0)
    /* RDLD_DI_ORIGIN gives only library. RDLD_DI_LINKMAP gives all but needs #include <link.h>. */
    if (is_libmysqlclient_loaded == 1)
    {
       struct link_map *map;
       the_text.append("(");
       if (dlinfo(libmysqlclient_handle, RTLD_DI_LINKMAP, &map) != -1)
       {
         if (map != NULL) the_text.append(map->l_name);
       }
       the_text.append(")");
    }
#endif
#endif
  }
#endif //if (OCELOT_MYSQL_INCLUDE == 1)
  if (statement_edit_widget->dbms_version > "")
  {
    the_text.append("<br>using ");
    the_text.append(dbms_name()); /* "mysql" or "mariadb" or "tarantool" */
    the_text.append(" DBMS server version ");
    the_text.append(statement_edit_widget->dbms_version);
  }
#if (OCELOT_MYSQL_DEBUGGER == 1)
  the_text.append("<br>Some source code related to the debugger feature is ");
  the_text.append("<br>(c) Copyright 2012 Hewlett-Packard Development Company, L.P.");
#endif
#if (OCELOT_STATIC_LIBRARY == 1)
  the_text.append("<br>Static-linked to MariaDB Connector C library");
  the_text.append("<br>Copyright (C) 2000 MySQL AB & MySQL Finland AB & TCX DataKonsult AB");
  the_text.append("<br>Static-linked to Qt's GUI library");
  the_text.append("<br>Copyright 2008-2014 Digia Plc. All rights reserved.");
#endif
  QString application_dir_path= get_doc_path("ocelotgui_logo.png");
  if (application_dir_path != "")
  {
    QString img_path= "img src=\"";
    img_path.append(application_dir_path);
    img_path.append("/");
    the_text.replace("img src=\"", img_path);
  }
  Message_box *message_box;
  message_box= new Message_box("Help|About", the_text, 500, "", er_strings[er_off + ER_OK], "", this);
  message_box->exec();
  delete message_box;
}


/*
  the_manual_widget will be shown when user clicks Help | The Manual.
  It does not inherit the fonts+colors settings of the main window (that's a message_box todo).
  It reads the manual from README.htm.
  It uses HTML.
  README.htm refers to img src="...png|jpg" files, we expect them on the same directory as README.htm.
   Todo: Help | X should find X in the manual and display only X.
*/
void MainWindow::action_the_manual()
{
  QString the_text="\
  <BR><h1>ocelotgui</h1>  \
  <BR>  \
  <BR>Version 1.9.0, March 7 2022  \
  <BR>  \
  <BR>  \
  <BR>Copyright (c) 2023 by Peter Gulutzan. All rights reserved.  \
  <BR>  \
  <BR>This program is free software; you can redistribute it and/or modify  \
  <BR>it under the terms of the GNU General Public License as published by  \
  <BR>the Free Software Foundation; version 2 of the License.  \
  <BR>  \
  <BR>This program is distributed in the hope that it will be useful,  \
  <BR>but WITHOUT ANY WARRANTY; without even the implied warranty of  \
  <BR>MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the  \
  <BR>GNU General Public License for more details.  \
  <BR>  \
  <BR>You should have received a copy of the GNU General Public License  \
  <BR>along with this program; if not, write to the Free Software  \
  <BR>Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA  \
  <BR>  \
  <BR>  \
  <BR>For the most recent version of the manual, see \
  <BR>https://github.com/ocelot-inc/ocelotgui#user-manual \
    ";
  QString application_dir_path= get_doc_path("README.htm");
  if (application_dir_path != "")
  {
    QString readme_path= application_dir_path;
    readme_path.append("/");
    readme_path.append("README.htm");
    QFile file(readme_path);
    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
      QString line;
      QTextStream in(&file);
      the_text= "";
      while(!in.atEnd())
      {
        line= in.readLine();
        the_text.append(line);
        the_text.append(" ");
      }
      file.close();
      QString img_path= "img src=\"";
      img_path.append(application_dir_path);
      img_path.append("/");
      the_text.replace("img src=\"", img_path);
    }
  }
  Message_box *message_box;
  /* Don't use width=960 if screen width is smaller, e.g. on a VGA screen. */
#if (QT_VERSION >= 0x50000)
  QScreen *screen= QGuiApplication::primaryScreen();
  int desktop_width= screen->availableGeometry().width();
#else
  QDesktopWidget desktop;
  int desktop_width= desktop.availableGeometry().width();
#endif
  if (desktop_width > (960 + 50)) message_box= new Message_box("Help|The Manual", the_text, 960, "", er_strings[er_off + ER_OK], "", this);
  else message_box= new Message_box("Help|The Manual", the_text, desktop_width - 50, "", er_strings[er_off + ER_OK], "", this);
  message_box->exec();
  delete message_box;
}

#if (OCELOT_MYSQL_INCLUDE == 1)
void MainWindow::action_libmysqlclient()
{
  QString the_text= "<b>libmysqlclient</b><br>\
  Before ocelotgui can try to connect to a MySQL server, \
  it needs a shared library named libmysqlclient \
  (file name on Linux is 'libmysqlclient.so' and/or 'libmysqlclient.so.18'). \
  If a mysql client was installed, possibly due to install \
  of a package named 'libmysqlclient-dev' or something similar, \
  then this file exists ... somewhere. \
  ocelotgui searches for libmysqlclient.so in these directories:<br> \
  (1) as specified by environment variable LD_RUN_PATH<br> \
  (2) as specified by environment variable LD_LIBRARY_PATH<br> \
  (3) as specified during build in file ocelotgui.pro, \
  which are by default hard-coded as: /usr/local/lib \
  /usr/mysql/lib /usr/local/mysql/lib /usr/lib /usr/local/lib/mysql \
  /usr/lib/mysql /usr/local /usr/local/mysql /usr/local /usr, etc.<br> \
  If a message appears saying libmysqlclient cannot be found, \
  or if there is a suspicion that an obsolete copy of libmysqlclient \
  was found, a possible solution is:<br> \
  1. Find the right libmysqlclient.so with Linux 'find' or 'locate'. \
  Suppose it is /home/jeanmartin/libmysqlclient.so.<br> \
  2. Specify the library when starting ocelotgui, thus:<br> \
  LD_RUN_PATH=/home/jeanmartin ocelotgui<br> \
  ... ocelotgui will also look for libmariadbclient.so or \
  libmariadb.so in the same fashion but will look first for \
  libmysqlclient.so unless one starts with ocelot_dbms='mariadb'.";
  Message_box *message_box;
  message_box= new Message_box("Help|libmysqlclient", the_text, 500, "", er_strings[er_off + ER_OK], "", this);
  message_box->exec();
  delete message_box;
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

void MainWindow::action_settings()
{
  QString the_text= "<b>settings</b><br>\
  For all widgets, the color and font are changeable.<br>\
          <br>\
  CHANGING COLORS<br>\
  For example, to change the statement background color to dark blue:<br>\
  * Click the menu item Settings<br>\
    then click Statement Widget<br>\
    then click the box on the right of the Statement Background Color line<br>\
    then click on the word 'DarkBlue' in the list of choices<br>\
    then click OK to confirm<br>\
  * Or, Start ocelotgui with a parameter:<br>\
    ocelotgui --ocelot_statement_background-color='DarkBlue'<br>\
  * Or, put a line permanently in an option file such as ~/.my.cnf<br>\
    [ocelot]<br>\
    ocelot_statement_background_color='DarkBlue'<br>\
  * Or, execute a statement<br>\
    SET ocelot_statement_background_color='DarkBlue';<br>\
  Color names may be any of the many names listed on this W3C chart: \
  http://www.w3.org/wiki/CSS/Properties/color/keywords \
  as well as additions from this unofficial X11 chart: \
  https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart. \
  Hexadecimal-RGB values for example '#0000FE' are allowed in parameters or statements. \
  <br>\
  <br>\
  CHANGING FONTS<br>\
  For example, to change the menu font to italic:<br>\
  * Click the menu item Settings<br>\
    then click Menu<br>\
    then click the Font box <br>\
    then scroll to and click on an italic choice<br>\
    then click OK to confirm<br>\
  * Or, Start ocelotgui with a parameter:<br>\
    ocelotgui --ocelot_menu_font_style='italic'<br>\
  * Or, put a line permanently in an option file such as ~/.my.cnf<br>\
    [ocelot]<br>\
    ocelot_menu_font_style='italic'<br>\
  * Or, execute a statement<br>\
    SET ocelot_menu_font_style = 'italic';<br>\
  Some font changes do not take effect until after the next statement \
  is executed. \
  Some extremely large font sizes will be accepted but \
  the results will be ugly.";
  Message_box *message_box;
  message_box= new Message_box("Help|libmysqlclient", the_text, 500, "", er_strings[er_off + ER_OK], "", this);
  message_box->exec();
  delete message_box;
}


/*
  Problem: to do syntax highlighting, one must have a slot
  action_statement_edit_widget_text_changed() to intercept
  every change in action_statement_edit_widget. But, when
  user chooses Undo, that interception happens again, which
  negates the effects of undo. Therefore, instead of getting
  slot() invoked directly, I get to action_undo() which temporarily
  disables use of action_statement_edit_widget_changed().
  And of course the same considerations apply for redo().
  KLUDGE #1: In action_statement_edit_widget_changed(), change
             cur.beginEditBlock() to cur.joinPreviousEditBlock()
             so the syntax-highlight will be merged with the
             content change.
  KLUDGE #2: If a change is done via key stroke, then the stack
             gets 2 items, one of which is junk (just moving the
             cursor to after the first word), and wow, I wish I
             knew why. If a change is done via cut-and-paste,
             there's only one item. So I have to look at what
             the change was, and discard the junk item if I find
             it with undo, or put it back on the stack if I find
             it with redo.
  KLUDGE #3: Usually redo() moves the cursor the end, and wow, I
             wish I knew why. So I calculate where it should be =
             position of the first character that differs, plus
             (chars added - chars removed) (if positive).
  Todo: consider: will there be a bug if syntax highlighting is disabled?
        (currently it seems that disabling doesn't work so I can't test)
  Todo: see what happens for other situations besides
        key stroke | cut | paste. E.g. we get rid of a
        statement at a time in multi-statement sendings.
  Todo: menu item enable|disable -- not simple, it will
        depend what has focus
*/
void MainWindow::action_undo()
{
  log("action_undo start", 90);
  statement_edit_widget_text_changed_flag= 1;
  QString text_before= statement_edit_widget->toPlainText();
  statement_edit_widget->undo();
  QString text_after= statement_edit_widget->toPlainText();
  if (text_before == text_after)
    statement_edit_widget->undo();
  statement_edit_widget_text_changed_flag= 0;
  log("action_undo end", 90);
}

void MainWindow::action_redo()
{
  log("action_redo start", 90);
  QTextCursor cur= statement_edit_widget->textCursor();
  QString text_before= statement_edit_widget->toPlainText();
  statement_edit_widget_text_changed_flag= 1;
  statement_edit_widget->redo();
  int final_pos_for_redo;
  QString text_after_1= statement_edit_widget->toPlainText();
  statement_edit_widget->redo();
  QString text_after_2= statement_edit_widget->toPlainText();
  if (text_after_2 != text_after_1)
    statement_edit_widget->undo();
  statement_edit_widget_text_changed_flag= 0;
  for (final_pos_for_redo= 0; final_pos_for_redo < text_before.length(); ++final_pos_for_redo)
  {
    if (text_before.mid(final_pos_for_redo,1) != text_after_1.mid(final_pos_for_redo,1))
      break;
  }
  if (chars_added_for_redo > chars_removed_for_redo)
    final_pos_for_redo+= (chars_added_for_redo - chars_removed_for_redo);
  if (final_pos_for_redo > text_after_1.length())
  {
    log("FINAL_POS_FOR_REDO WAS ADJUSTED", 90);
    final_pos_for_redo= text_after_1.length();
  }
  cur.setPosition(final_pos_for_redo);
  statement_edit_widget->setTextCursor(cur);
  log("action_redo end", 90);
}

/*
  When focusOut happens for one of the main widgets (the ones that have
  an event filter on them), we might be switching to the menu bar.
  (I wish I knew for sure, but if it's to something else, no harm done.)
  On the edit menu, some items should be enabled or disabled (gray).
  Inefficient, but these actions don't happen dozens of times per second.
  Incredibly, installeventfilter for menuBar + look for focusIn or
  focusOut on menuBar didn't work, so this will have to do.
  Objects with event filters are: ResultGrid, CodeEditor,
  QScrollBar, TextEditHistory, so they all cause a call to here,
  but we only care about CodeEditor and TextEditHistory. Also we
  call from TextEditWidget::focusOutEvent(), an override rather
  than an editfilter event.
  Warn: TextEditWidget::focusInEvent() is also an override rather than
        an editfilter event, because (I don't know why) otherwise we
        don't see when TextEditWidget get focus or loses focus.
        This is the only time when QEvent::focusIn matters. So usually
        menu_activations() for menu_activations(QEvent::focusIn)
        is a waste of time. Remember, though, that shortcuts often won't
        work if the menu item is disabled.
  Todo: Incredibly, availableRedoSteps() only works for CodeEditor i.e.
        statement_edit_widget. I wish I knew why, but rather than spend
        more hours, will just assume redo is otherwise always okay.
        Maybe someday look harder.
  Todo: Saving the object so you'd know to setFocus to it after being on
        the menu would be good, at the moment it isn't automatic if the
        widget is detached.
  Todo: Other edit menu items can be enabled|disabled:
        previous statement, next statement.
  Todo: if font_size already <= FONT_SIZE_MIN, disable zoomout.
        if font_size already >= FONT_SIZE_MAX, disable zoomout.
        (Get the widget's ->styleSheet() as you do elsewhere.)
  Todo: check if ExpectedWidget can be affected here
  Todo: we could have is_can_find for menu_edit_action_find but at the moment it's always enabled
*/
void MainWindow::menu_activations(QObject *focus_widget, QEvent::Type qe)
{
  bool is_can_undo= true, is_can_redo= true;
  bool is_can_copy= false, is_can_cut= false, is_can_paste= false;
  bool is_can_format= false, is_can_zoomin= false, is_can_zoomout= false;
  bool is_can_autocomplete= false;
  const char *class_name= focus_widget->metaObject()->className();
#if (OCELOT_FIND_WIDGET == 1)
  if (qe == QEvent::FocusOut)
  {
    last_focus_widget= focus_widget;
  }
#endif
  // Todo: This is odd. if (qe == QEvent::FocusIn) isn't checked
  if (strcmp(class_name, "CodeEditor") == 0)
  {
    CodeEditor *t= qobject_cast<CodeEditor*>(focus_widget);
    QTextDocument *doc= t->document();
    if (doc->availableUndoSteps() <= 0) is_can_undo= false;
    if (doc->availableRedoSteps() <= 0) is_can_redo= false;
    is_can_copy= is_can_cut= t->textCursor().hasSelection();
    is_can_paste= t->canPaste();
    is_can_format= is_can_zoomin= is_can_zoomout= !doc->isEmpty();
    is_can_autocomplete= !completer_widget->isHidden();
  }
  else if (strcmp(class_name, "TextEditHistory") == 0)
  {
    TextEditHistory *t= qobject_cast<TextEditHistory*>(focus_widget);
    QTextDocument *doc= t->document();
    if (doc->availableUndoSteps() <= 0) is_can_undo= false;
    is_can_copy= is_can_cut= t->textCursor().hasSelection();
    is_can_paste= t->canPaste();
    is_can_format= false;
    is_can_zoomin= is_can_zoomout= !doc->isEmpty();
  }
  else if (strcmp(class_name, "Result_qtextedit") == 0)
  {
    Result_qtextedit *t= qobject_cast<Result_qtextedit*>(focus_widget);
    QTextDocument *doc= t->document();
    if (doc->availableUndoSteps() <= 0) is_can_undo= false;
    if (doc->availableRedoSteps() <= 0) is_can_redo= false;
    is_can_copy= is_can_cut= t->textCursor().hasSelection();
    is_can_paste= t->canPaste();
    is_can_format= false;
    is_can_zoomin= is_can_zoomout= !doc->isEmpty();
  }
  else
  {
    return;
  }
  menu_edit_action_undo->setEnabled(is_can_undo);
  menu_edit_action_redo->setEnabled(is_can_redo);
  menu_edit_action_cut->setEnabled(is_can_cut);
  menu_edit_action_copy->setEnabled(is_can_copy);
  menu_edit_action_paste->setEnabled(is_can_paste);
  menu_edit_action_formatter->setEnabled(is_can_format);
  menu_edit_action_zoomin->setEnabled(is_can_zoomin);
  menu_edit_action_zoomout->setEnabled(is_can_zoomout);
  menu_edit_action_autocomplete->setEnabled(is_can_autocomplete);
}


/*
  Comments relevant to action_statement(), action_grid(), action_history(), action_menu() ...
  These let the user select the colors and font for some widgets.
  Qt documentation says: "QApplication maintains a system/theme font which serves as a default for all widgets."
  So I'll assume that the Main Window always has that font, but let user change widgets that are within it.
  It's best to use a fixed-width font for most widgets, but I won't force that.
  Todo: consider: Should we pass default = current font (what we changed to last time) rather than default = main window font?
  Todo: Looks like there's a small problem with the history_edit_widget -- it might scroll.
        Probably what we want is: if we're at the bottom before the font change, then move to the bottom after the change.
*/
/* Todo: before se->delete(), check if WA_DeleteOnClose is off, always, for sure. */
/* Todo: edit_widget_text_changed() etc. should only be done if one of the ocelot_statement_highlight variables changed */
/* Todo: edit_widget_text_changed() etc. should be preceded by "emit"? */
/* Todo: put setStyleSheet() in an "if": only redo if ocelot_statement_style_string changed. */
/* Todo: after doing a setStyleSheet() change, put in history as "SET @..." statements. */
/* Todo: make sure there's no need to call set_current_colors_and_font(); */
/*
   Todo: Get default color too.
   I can get colors too, based on
   color= widget.palette().color(QPalette::Window);            formerly known as QPalette::Background
   color= widget.palette().color(QPalette::WindowText);           formerly known as QPalette::Foreground
   but    color.name() gives the color as "#RRGGBB" -- but I want a name!
   But your problem is: it might be RGB originally. You'd have to accept RGB.
   Luckily setStyleSheet will accept it, e.g. statement_edit_widget->setStyleSheet("background:rgb(200,100,150);");
   See also http://www.w3.org/TR/SVG/types.html#ColorKeywords "recognized color keyword names".
*/

/* NB: ocelot_statement_detached should be set after setting top|left|width|height not before */
void MainWindow::action_statement()
{
  Settings *se= new Settings(STATEMENT_WIDGET, this);
  int result= se->exec();
  if (result == QDialog::Accepted)
  {
    //make_style_strings();
    //statement_edit_widget_setstylesheet();
    /* For each changed Settings item, produce and execute a settings-change statement. */
    action_change_one_setting(ocelot_statement_text_color, new_ocelot_statement_text_color,TOKEN_KEYWORD_OCELOT_STATEMENT_TEXT_COLOR);
    action_change_one_setting(ocelot_statement_background_color, new_ocelot_statement_background_color,TOKEN_KEYWORD_OCELOT_STATEMENT_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_statement_border_color, new_ocelot_statement_border_color,TOKEN_KEYWORD_OCELOT_STATEMENT_BORDER_COLOR);
    action_change_one_setting(ocelot_statement_font_family, new_ocelot_statement_font_family,TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_FAMILY);
    action_change_one_setting(ocelot_statement_font_size, new_ocelot_statement_font_size,TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_SIZE);
    action_change_one_setting(ocelot_statement_font_style, new_ocelot_statement_font_style,TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_STYLE);
    action_change_one_setting(ocelot_statement_font_weight, new_ocelot_statement_font_weight,TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_WEIGHT);
    action_change_one_setting(ocelot_statement_highlight_literal_color, new_ocelot_statement_highlight_literal_color,TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_LITERAL_COLOR);
    action_change_one_setting(ocelot_statement_highlight_identifier_color, new_ocelot_statement_highlight_identifier_color,TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_IDENTIFIER_COLOR);
    action_change_one_setting(ocelot_statement_highlight_comment_color, new_ocelot_statement_highlight_comment_color,TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_COMMENT_COLOR);
    action_change_one_setting(ocelot_statement_highlight_operator_color, new_ocelot_statement_highlight_operator_color,TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_OPERATOR_COLOR);
    action_change_one_setting(ocelot_statement_highlight_keyword_color, new_ocelot_statement_highlight_keyword_color,TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_KEYWORD_COLOR);
    action_change_one_setting(ocelot_statement_prompt_background_color, new_ocelot_statement_prompt_background_color,TOKEN_KEYWORD_OCELOT_STATEMENT_PROMPT_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_statement_highlight_current_line_color, new_ocelot_statement_highlight_current_line_color,TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR);
    action_change_one_setting(ocelot_statement_highlight_function_color, new_ocelot_statement_highlight_function_color,TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_FUNCTION_COLOR);
    action_change_one_setting(ocelot_statement_syntax_checker, new_ocelot_statement_syntax_checker,TOKEN_KEYWORD_OCELOT_STATEMENT_SYNTAX_CHECKER);

    /* Todo: consider: maybe you have to do a restore like this */
    //text= statement_edit_widget->toPlainText(); /* or I could just pass this to tokenize() directly */
    //tokenize(text.data(),
    //         text.size(),
    //         main_token_lengths, main_token_offsets, MAX_TOKENS, (QChar*)"33333", 1, ocelot_delimiter_str, 1);
    //tokens_to_keywords(text);
    /* statement_edit_widget->statement_edit_widget_left_bgcolor= QColor(ocelot_statement_prompt_background_color); */
    statement_edit_widget->statement_edit_widget_left_treatment1_textcolor= QColor(ocelot_statement_text_color);
    action_statement_edit_widget_text_changed(0, 0, 0);            /* only for highlight? repaint so new highlighting will appear */
    /* Todo: Check: Do we need to change style settings for this stuff? */
    action_change_one_setting(ocelot_statement_height, new_ocelot_statement_height, TOKEN_KEYWORD_OCELOT_STATEMENT_HEIGHT);
    action_change_one_setting(ocelot_statement_left, new_ocelot_statement_left, TOKEN_KEYWORD_OCELOT_STATEMENT_LEFT);
    action_change_one_setting(ocelot_statement_top, new_ocelot_statement_top, TOKEN_KEYWORD_OCELOT_STATEMENT_TOP);
    action_change_one_setting(ocelot_statement_width, new_ocelot_statement_width, TOKEN_KEYWORD_OCELOT_STATEMENT_WIDTH);
    action_change_one_setting(ocelot_statement_detached, new_ocelot_statement_detached, TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED);
  }
  delete(se);
}

/*
  The setstylesheet here could take a long time if there are many child widgets being displayed.
*/
/* NB: ocelot_history_detached should be set after setting top|left|width|height not before */
void MainWindow::action_grid()
{
  Settings *se= new Settings(GRID_WIDGET, this);
  int result= se->exec();
  if (result == QDialog::Accepted)
  {
    //make_style_strings();                                                      /* I think this should be commented out */
    //result_grid_tab_widget[0]->set_all_style_sheets();
    /* For each changed Settings item, produce and execute a settings-change statement. */
    action_change_one_setting(ocelot_grid_text_color, new_ocelot_grid_text_color, TOKEN_KEYWORD_OCELOT_GRID_TEXT_COLOR);
    action_change_one_setting(ocelot_grid_focus_cell_background_color, new_ocelot_grid_focus_cell_background_color, TOKEN_KEYWORD_OCELOT_GRID_FOCUS_CELL_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_grid_background_color, new_ocelot_grid_background_color, TOKEN_KEYWORD_OCELOT_GRID_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_grid_header_background_color, new_ocelot_grid_header_background_color, TOKEN_KEYWORD_OCELOT_GRID_HEADER_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_grid_font_family, new_ocelot_grid_font_family, TOKEN_KEYWORD_OCELOT_GRID_FONT_FAMILY);
    action_change_one_setting(ocelot_grid_font_size, new_ocelot_grid_font_size, TOKEN_KEYWORD_OCELOT_GRID_FONT_SIZE);
    action_change_one_setting(ocelot_grid_font_style, new_ocelot_grid_font_style, TOKEN_KEYWORD_OCELOT_GRID_FONT_STYLE);
    action_change_one_setting(ocelot_grid_font_weight, new_ocelot_grid_font_weight, TOKEN_KEYWORD_OCELOT_GRID_FONT_WEIGHT);
    action_change_one_setting(ocelot_grid_cell_border_color, new_ocelot_grid_cell_border_color, TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_COLOR);
    action_change_one_setting(ocelot_grid_outer_color, new_ocelot_grid_outer_color, TOKEN_KEYWORD_OCELOT_GRID_OUTER_COLOR);
    action_change_one_setting(ocelot_grid_cell_height, new_ocelot_grid_cell_height, TOKEN_KEYWORD_OCELOT_GRID_CELL_HEIGHT);
    action_change_one_setting(ocelot_grid_cell_border_size, new_ocelot_grid_cell_border_size, TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_SIZE);
    action_change_one_setting(ocelot_grid_cell_width, new_ocelot_grid_cell_width, TOKEN_KEYWORD_OCELOT_GRID_CELL_WIDTH);
    /* Todo: check: do we need to change style sheet for this stuff? */
    action_change_one_setting(ocelot_grid_height, new_ocelot_grid_height, TOKEN_KEYWORD_OCELOT_GRID_HEIGHT);
    action_change_one_setting(ocelot_grid_left, new_ocelot_grid_left, TOKEN_KEYWORD_OCELOT_GRID_LEFT);
    action_change_one_setting(ocelot_grid_top, new_ocelot_grid_top, TOKEN_KEYWORD_OCELOT_GRID_TOP);
    action_change_one_setting(ocelot_grid_width, new_ocelot_grid_width, TOKEN_KEYWORD_OCELOT_GRID_WIDTH);
    action_change_one_setting(ocelot_grid_html_effects, new_ocelot_grid_html_effects, TOKEN_KEYWORD_OCELOT_GRID_HTML_EFFECTS);
    action_change_one_setting(ocelot_grid_detached, new_ocelot_grid_detached, TOKEN_KEYWORD_OCELOT_GRID_DETACHED);
  }
  delete(se);
}

#if (OCELOT_MYSQL_DEBUGGER == 1)
/* !!!!! FIX !!!!! */
void MainWindow::action_debug()
{
  Settings *se= new Settings(DEBUG_WIDGET, this);
  int result= se->exec();
  if (result == QDialog::Accepted)
  {
    /* Todo: check: do we need to change style sheet for this stuff? */
    action_change_one_setting(ocelot_debug_height, new_ocelot_debug_height, TOKEN_KEYWORD_OCELOT_DEBUG_HEIGHT);
    action_change_one_setting(ocelot_debug_left, new_ocelot_debug_left, TOKEN_KEYWORD_OCELOT_DEBUG_LEFT);
    action_change_one_setting(ocelot_debug_top, new_ocelot_debug_top, TOKEN_KEYWORD_OCELOT_DEBUG_TOP);
    action_change_one_setting(ocelot_debug_width, new_ocelot_debug_width, TOKEN_KEYWORD_OCELOT_DEBUG_WIDTH);
    action_change_one_setting(ocelot_debug_detached, new_ocelot_debug_detached, TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED);
 }
  delete(se);
}
#endif

#if (OCELOT_EXPLORER == 1)
/* !!!!! FIX !!!!! */
void MainWindow::action_explorer()
{
  Settings *se= new Settings(EXPLORER_WIDGET, this);
  int result= se->exec();
  if (result == QDialog::Accepted)
  {
    ocelot_explorer_sort= new_ocelot_explorer_sort;
    if (ocelot_explorer_query != new_ocelot_explorer_query)
    {
      /* Todo: if the query is invalid, QDialog::Accepted shouldn't matter, this should fail */
      if (explorer_query() == true) ocelot_explorer_query= new_ocelot_explorer_query;
    }
    action_change_one_setting(ocelot_explorer_text_color, new_ocelot_explorer_text_color, TOKEN_KEYWORD_OCELOT_EXPLORER_TEXT_COLOR);
    action_change_one_setting(ocelot_explorer_background_color, new_ocelot_explorer_background_color, TOKEN_KEYWORD_OCELOT_EXPLORER_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_explorer_font_family, new_ocelot_explorer_font_family, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_FAMILY);
    action_change_one_setting(ocelot_explorer_font_size, new_ocelot_explorer_font_size, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_SIZE);
    action_change_one_setting(ocelot_explorer_font_style, new_ocelot_explorer_font_style, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_STYLE);
    action_change_one_setting(ocelot_explorer_font_weight, new_ocelot_explorer_font_weight, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_WEIGHT);
    action_change_one_setting(ocelot_explorer_visible, new_ocelot_explorer_visible, TOKEN_KEYWORD_OCELOT_EXPLORER_VISIBLE);
    action_change_one_setting(ocelot_explorer_height, new_ocelot_explorer_height, TOKEN_KEYWORD_OCELOT_EXPLORER_HEIGHT);
    action_change_one_setting(ocelot_explorer_left, new_ocelot_explorer_left, TOKEN_KEYWORD_OCELOT_EXPLORER_LEFT);
    action_change_one_setting(ocelot_explorer_top, new_ocelot_explorer_top, TOKEN_KEYWORD_OCELOT_EXPLORER_TOP);
    action_change_one_setting(ocelot_explorer_width, new_ocelot_explorer_width, TOKEN_KEYWORD_OCELOT_EXPLORER_WIDTH);
    action_change_one_setting(ocelot_explorer_detached, new_ocelot_explorer_detached, TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED);
  }
  delete(se);
}
#endif

/*
  TODO: extra_rule_1 could affect statement | prompt | word, not just cell
  TODO: Action could be to invoke a Lua procedure, not just char/hex/image
  TODO: There are lots of things to add to Condition and to Display As
*/
void MainWindow::action_extra_rule_1()
{
  Settings *se= new Settings(EXTRA_RULE_1, this);
  int result= se->exec();
  if (result == QDialog::Accepted)
  {
    action_change_one_setting(ocelot_extra_rule_1_condition, new_ocelot_extra_rule_1_condition, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_CONDITION);
    action_change_one_setting(ocelot_extra_rule_1_text_color, new_ocelot_extra_rule_1_text_color, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_TEXT_COLOR);
    action_change_one_setting(ocelot_extra_rule_1_background_color, new_ocelot_extra_rule_1_background_color, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_extra_rule_1_display_as, new_ocelot_extra_rule_1_display_as, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_DISPLAY_AS);
 }
  delete(se);
}

/* NB: ocelot_history_detached should be set after setting top|left|width|height not before */
void MainWindow::action_history()
{
  Settings *se= new Settings(HISTORY_WIDGET, this);
  int result= se->exec();
  if (result == QDialog::Accepted)
  {
    //make_style_strings();
    //history_edit_widget->setStyleSheet(ocelot_history_style_string);
    action_change_one_setting(ocelot_history_text_color, new_ocelot_history_text_color, TOKEN_KEYWORD_OCELOT_HISTORY_TEXT_COLOR);
    action_change_one_setting(ocelot_history_background_color, new_ocelot_history_background_color, TOKEN_KEYWORD_OCELOT_HISTORY_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_history_border_color, new_ocelot_history_border_color, TOKEN_KEYWORD_OCELOT_HISTORY_BORDER_COLOR);
    action_change_one_setting(ocelot_history_font_family, new_ocelot_history_font_family, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_FAMILY);
    action_change_one_setting(ocelot_history_font_size, new_ocelot_history_font_size, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_SIZE);
    action_change_one_setting(ocelot_history_font_style, new_ocelot_history_font_style, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_STYLE);
    action_change_one_setting(ocelot_history_font_weight, new_ocelot_history_font_weight, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_WEIGHT);
    action_change_one_setting(ocelot_history_height, new_ocelot_history_height, TOKEN_KEYWORD_OCELOT_HISTORY_HEIGHT);
    action_change_one_setting(ocelot_history_left, new_ocelot_history_left, TOKEN_KEYWORD_OCELOT_HISTORY_LEFT);
    action_change_one_setting(ocelot_history_max_row_count, new_ocelot_history_max_row_count, TOKEN_KEYWORD_OCELOT_HISTORY_MAX_ROW_COUNT);
    action_change_one_setting(ocelot_history_top, new_ocelot_history_top, TOKEN_KEYWORD_OCELOT_HISTORY_TOP);
    action_change_one_setting(ocelot_history_width, new_ocelot_history_width, TOKEN_KEYWORD_OCELOT_HISTORY_WIDTH);
    action_change_one_setting(ocelot_history_detached, new_ocelot_history_detached, TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED);
  }
  delete(se);
}

/* We used to change main_window but there's too much inheriting. Really, menu is what matters. */
void MainWindow::action_menu()
{
  Settings *se= new Settings(MAIN_WIDGET, this);
  int result= se->exec();
  if (result == QDialog::Accepted)
  {
    //make_style_strings();
    //main_window->setStyleSheet(ocelot_menu_style_string);
    //ui->menuBar->setStyleSheet(ocelot_menu_style_string);
      action_change_one_setting(ocelot_menu_text_color, new_ocelot_menu_text_color, TOKEN_KEYWORD_OCELOT_MENU_TEXT_COLOR);
      action_change_one_setting(ocelot_menu_background_color, new_ocelot_menu_background_color, TOKEN_KEYWORD_OCELOT_MENU_BACKGROUND_COLOR);
      action_change_one_setting(ocelot_menu_border_color, new_ocelot_menu_border_color, TOKEN_KEYWORD_OCELOT_MENU_BORDER_COLOR);
      action_change_one_setting(ocelot_menu_font_family, new_ocelot_menu_font_family, TOKEN_KEYWORD_OCELOT_MENU_FONT_FAMILY);
      action_change_one_setting(ocelot_menu_font_size, new_ocelot_menu_font_size, TOKEN_KEYWORD_OCELOT_MENU_FONT_SIZE);
      action_change_one_setting(ocelot_menu_font_style, new_ocelot_menu_font_style, TOKEN_KEYWORD_OCELOT_MENU_FONT_STYLE);
      action_change_one_setting(ocelot_menu_font_weight, new_ocelot_menu_font_weight, TOKEN_KEYWORD_OCELOT_MENU_FONT_WEIGHT);
  }
  delete(se);
}

/*
  If a Settings-menu use has caused a change:
  Produce a settings-change SQL statement, e.g.
  SET ocelot_statement_background_color = 'red'
  and execute it.
  If it's a color, it might be an RGB, in that case change to name first.
*/
void MainWindow::action_change_one_setting(QString old_setting,
                                           QString new_setting,
                                           int keyword_index)
{
  if (old_setting != new_setting)
  {
    QString text;
    {
      old_setting= new_setting;
      main_token_number= 0;
      text= "SET ";
      text.append(strvalues[keyword_index].chars);
      text.append(" = ");
      text.append("'");
      QString source= new_setting;
      if (xsettings_widget->ocelot_variable_is_color(keyword_index) == true)
        source= rgb_to_color(new_setting);
      for (int i= 0; i < source.length(); ++i)
      {
        QString c= source.mid(i, 1);
        text.append(c);
        if (c == "'") text.append(c);
      }
      text.append("';");
      main_token_count_in_statement= 5;
    }
    action_change_one_setting_execute(text);
  }
}

/*
  called from action_change_one_setting due to most menu items that require change
  called from action_export_function due to menu item that requires change for export (in that case it's fake)
*/
void MainWindow::action_change_one_setting_execute(QString text)
{
  log("action_change_one_setting_execute", 15);
  main_token_new(text.size());
  tokenize(text.data(),
           text.size(),
           main_token_lengths, main_token_offsets,
           main_token_max_count, (QChar*)"33333", 1,
           ocelot_delimiter_str, 1);
  tokens_to_keywords(text, 0, sql_mode_ansi_quotes);
  action_execute_one_statement(text);
  history_edit_widget->verticalScrollBar()->setValue(history_edit_widget->verticalScrollBar()->maximum());
}

/*
  Pass QString with rgb name '#RRGGBB'.
  Find that string in q_color_list.
  If it's not there: add it.
*/
QString MainWindow::q_color_list_name(QString rgb_name)
{
  for (int i= 1; i < q_color_list.size(); i+= 2)
  {
    if (QString::compare(rgb_name, q_color_list[i], Qt::CaseInsensitive) == 0) return rgb_name;
  }
  q_color_list.append(rgb_name);
  q_color_list.append(rgb_name);
  return rgb_name;
}

/*
  It's possible to say SET [ocelotgui color name] = rgb_name e.g. "#FFFFFF"
  or have rgb_name in an options file or get an RGB name with set_current_colors_and_fonts().
  We'd prefer to show as W3C names where possible, X11 names as second choice, if English.
  But where the color is not in the W3C or X11 lists, we'll add.
*/
void MainWindow::assign_names_for_colors()
{
  if (ocelot_statement_text_color.left(1) == "#") ocelot_statement_text_color= q_color_list_name(ocelot_statement_text_color);
  if (ocelot_statement_background_color.left(1) == "#") ocelot_statement_background_color= q_color_list_name(ocelot_statement_background_color);
  if (ocelot_statement_border_color.left(1) == "#") ocelot_statement_border_color= q_color_list_name(ocelot_statement_border_color);
  if (ocelot_statement_highlight_literal_color.left(1) == "#") ocelot_statement_highlight_literal_color= q_color_list_name(ocelot_statement_highlight_literal_color);
  if (ocelot_statement_highlight_identifier_color.left(1) == "#") ocelot_statement_highlight_identifier_color= q_color_list_name(ocelot_statement_highlight_identifier_color);
  if (ocelot_statement_highlight_comment_color.left(1) == "#") ocelot_statement_highlight_comment_color= q_color_list_name(ocelot_statement_highlight_comment_color);
  if (ocelot_statement_highlight_operator_color.left(1) == "#") ocelot_statement_highlight_operator_color= q_color_list_name(ocelot_statement_highlight_operator_color);
  if (ocelot_statement_highlight_keyword_color.left(1) == "#") ocelot_statement_highlight_keyword_color= q_color_list_name(ocelot_statement_highlight_keyword_color);
  if (ocelot_statement_prompt_background_color.left(1) == "#") ocelot_statement_prompt_background_color= q_color_list_name(ocelot_statement_prompt_background_color);
  if (ocelot_statement_highlight_current_line_color.left(1) == "#") ocelot_statement_highlight_current_line_color= q_color_list_name(ocelot_statement_highlight_current_line_color);
  if (ocelot_statement_highlight_function_color.left(1) == "#") ocelot_statement_highlight_function_color= q_color_list_name(ocelot_statement_highlight_function_color);
  if (ocelot_grid_text_color.left(1) == "#") ocelot_grid_text_color= q_color_list_name(ocelot_grid_text_color);
  if (ocelot_grid_focus_cell_background_color.left(1) == "#") ocelot_grid_focus_cell_background_color= q_color_list_name(ocelot_grid_focus_cell_background_color);
  if (ocelot_grid_background_color.left(1) == "#") ocelot_grid_background_color= q_color_list_name(ocelot_grid_background_color);
  if (ocelot_grid_header_background_color.left(1) == "#") ocelot_grid_header_background_color= q_color_list_name(ocelot_grid_header_background_color);
  if (ocelot_grid_cell_border_color.left(1) == "#") ocelot_grid_cell_border_color= q_color_list_name(ocelot_grid_cell_border_color);
  if (ocelot_grid_outer_color.left(1) == "#") ocelot_grid_outer_color= q_color_list_name(ocelot_grid_outer_color);
  if (ocelot_history_text_color.left(1) == "#") ocelot_history_text_color= q_color_list_name(ocelot_history_text_color);
  if (ocelot_history_background_color.left(1) == "#") ocelot_history_background_color= q_color_list_name(ocelot_history_background_color);
  if (ocelot_history_border_color.left(1) == "#") ocelot_history_border_color= q_color_list_name(ocelot_history_border_color);
  if (ocelot_menu_text_color.left(1) == "#") ocelot_menu_text_color= q_color_list_name(ocelot_menu_text_color);
  if (ocelot_menu_background_color.left(1) == "#") ocelot_menu_background_color= q_color_list_name(ocelot_menu_background_color);
  if (ocelot_menu_border_color.left(1) == "#") ocelot_menu_border_color= q_color_list_name(ocelot_menu_border_color);
  if (ocelot_extra_rule_1_text_color.left(1) == "#") ocelot_extra_rule_1_text_color= q_color_list_name(ocelot_extra_rule_1_text_color);
  if (ocelot_extra_rule_1_background_color.left(1) == "#") ocelot_extra_rule_1_background_color= q_color_list_name(ocelot_extra_rule_1_background_color);
#if (OCELOT_EXPLORER == 1)
  if (ocelot_explorer_text_color.left(1) == "#") ocelot_explorer_text_color= q_color_list_name(ocelot_explorer_text_color);
  if (ocelot_explorer_background_color.left(1) == "#") ocelot_explorer_background_color= q_color_list_name(ocelot_explorer_background_color);
#endif
}


/*
  Todo: something has to be figured out about border width and border colors.
  I think, uncertainly, that the default border width is 0 and the color is Palette:shadow i.e. black.
  Possibly I could get the original value from QWidget::styleSheet() is some startup parameter changed it?
  Possibly I'd need to get a QFrame with a lineWidth() and frameWidth()?
  Possibly I should just assume that border width = 0px except for main window, and
  take out any mention of border in the Settings dialogs.
*/
void MainWindow::set_current_colors_and_font(QFont fixed_font)
{
  QFont font;

  QWidget *widget= new QWidget(); /* A dummy to which Qt will assign default settings for palette() etc. */
  ocelot_statement_text_color= statement_edit_widget->palette().color(QPalette::WindowText).name(); /* = QPalette::Foreground */
  ocelot_statement_background_color= statement_edit_widget->palette().color(QPalette::Window).name(); /* = QPalette::Background */
  font= statement_edit_widget->font();
  ocelot_statement_font_family= font.family();
  ocelot_statement_font_style= get_font_style_as_string(font);
  ocelot_statement_font_size= QString::number(font.pointSize()); /* Warning: this returns -1 if size was specified in pixels */
  ocelot_statement_font_weight= canonical_font_weight(QString::number(font.weight()));

  ocelot_grid_text_color= widget->palette().color(QPalette::WindowText).name(); /* = QPalette::Foreground */
  ocelot_grid_background_color= widget->palette().color(QPalette::Window).name(); /* = QPalette::Background */
  font= fixed_font;
  ocelot_grid_font_family= font.family();
  ocelot_grid_font_style= get_font_style_as_string(font);
  ocelot_grid_font_size= QString::number(font.pointSize()); /* Warning: this returns -1 if size was specified in pixels */
  ocelot_grid_font_weight= canonical_font_weight(QString::number(font.weight()));

  ocelot_history_text_color= history_edit_widget->palette().color(QPalette::WindowText).name(); /* = QPalette::Foreground */
  ocelot_history_background_color=history_edit_widget->palette().color(QPalette::Window).name(); /* = QPalette::Background */
  font= history_edit_widget->font();
  ocelot_history_font_family= font.family();
  ocelot_history_font_style= get_font_style_as_string(font);
  ocelot_history_font_size= QString::number(font.pointSize()); /* Warning: this returns -1 if size was specified in pixels */
  ocelot_history_font_weight= canonical_font_weight(QString::number(font.weight()));

  ocelot_menu_text_color= ui->menuBar->palette().color(QPalette::WindowText).name(); /* = QPalette::Foreground */
  ocelot_menu_background_color= ui->menuBar->palette().color(QPalette::Window).name(); /* = QPalette::Background */
  font= ui->menuBar->font();
  ocelot_menu_font_family= font.family();
  ocelot_menu_font_style= get_font_style_as_string(font);
  ocelot_menu_font_size= QString::number(font.pointSize()); /* Warning: this returns -1 if size was specified in pixels */
  ocelot_menu_font_weight= canonical_font_weight(QString::number(font.weight()));

  ocelot_extra_rule_1_text_color= widget->palette().color(QPalette::WindowText).name(); /* = QPalette::Foreground */
  ocelot_extra_rule_1_background_color= widget->palette().color(QPalette::Window).name(); /* = QPalette::Background */
  ocelot_extra_rule_1_condition= "data_type LIKE '%BLOB'";
  ocelot_extra_rule_1_display_as= "char";

#if (OCELOT_EXPLORER == 1)
  ocelot_explorer_text_color= ui->menuBar->palette().color(QPalette::WindowText).name(); /* = QPalette::Foreground */
  ocelot_explorer_background_color= ui->menuBar->palette().color(QPalette::Window).name(); /* = QPalette::Background */
  font= fixed_font;
  ocelot_explorer_font_family= font.family();
  ocelot_explorer_font_style= get_font_style_as_string(font);
  ocelot_explorer_font_size= QString::number(font.pointSize()); /* Warning: this returns -1 if size was specified in pixels */
  ocelot_explorer_font_weight= canonical_font_weight(QString::number(font.weight()));
#endif

  delete widget;
}

QString MainWindow::get_font_style_as_string(QFont font)
{
  if (font.style() == QFont::StyleNormal) return "normal";
  if (font.style() == QFont::StyleItalic) return "italic";
  return "oblique";
}

/*
  Call this for the initial default font, which we want as fixed pitch.
  It can be overridden by command-line options, SET statements, etc.
  Usually by default Qt will make a widget with a non-fixed font,
  this might be controlled by qtconfig-qt4 if Qt4,
  this might be controlled by (say) Gnome|KDE settings if Qt5.
  Do not use
    #if QT_VERSION >= 0x50200
    QFontDatabase::systemFont(QFontDatabase::FixedFont)
    #endif
    because Qt5 distribution is for "Qt5", not "Qt5.2+",
    but we can find the default by making a dummy with "NoSuchFont".
  If default is fixed: good, return it.
  Else search QFontDatabase for the font with the most points
  Else return the default.
  Points:
    If (first word match) +3 e.g. if default="Ubuntu" "Ubuntu Mono" wins
    If (dummy default match) +2 e.g. "DejaVu Sans Mono" often wins
    If (exact size match) +1
    If (close size match) +1
    If (weight match) +1
    If (italic match) +1
    If not ("*Webdings*" or "*Wingdings*" or "*Dingbats* or "*emoji" or "*orya*") +2
    ... But first part of the calculation differs in Windows because we got "MS Gothic" (yuck).
        Instead it is: If (Consolas | Lucida Console | Courier New) +3
  After you get it, it should determine the initial style sheets.
  Windows generates warnings if I don't exclude some fonts,
  but I suppress some of the warnings.
  Todo: consider changing QApplication font rather than individual fonts.
  Todo: there's a memory leak, though unimportant (we only call once)
  Todo: maybe consider italic == oblique and vice versa
*/
QFont MainWindow::get_fixed_font()
{
  QWidget *w1= new QWidget();
  QFont f1= w1->font();
  QFontInfo fi(f1);
  if (fi.fixedPitch()) return f1;
  int point_size= fi.pointSize();
  int weight= fi.weight();
  QFont::Style font_style= fi.style();
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
  QString first_word= fi.family();
  if (first_word.indexOf(" ") != -1)
    first_word= first_word.left(first_word.indexOf(" "));
  first_word= first_word.toUpper();
  int first_word_length= first_word.length();
#endif
  QFontDatabase database;
  QPlainTextEdit plain;
  QFont fo3("NoSuchFont", point_size, weight);
  fo3.setStyle(font_style);
  fo3.setStyleHint(QFont::TypeWriter);
  plain.setFont(fo3);
  QString recommended_family= plain.fontInfo().family();
  QString winner_font_family= "";
  int winner_font_point_size= 0;
  int winner_font_weight= 0;
  QFont::Style winner_font_font_style= QFont::StyleNormal;
  int winner_font_points= 0;
  foreach (const QString &family, database.families())
  {
#ifdef OCELOT_OS_NONLINUX
    {
      QString f= family.toUpper();
      if ((family == "FIXEDSYS") || (family == "MODERN")
       || (family == "SANS SERIF") || (family == "MS SERIF")
       || (family == "ROMAN") || (family == "SCRIPT")
       || (family == "SMALL FONTS") || (family == "SYSTEM")
       || (family == "TERMINAL"))
         continue;
    }
#endif
    int this_points= 0;
    QFont fo1= QFont(family, point_size, weight);
    fo1.setStyle(font_style);
    fo1.setStyleHint(QFont::TypeWriter);
    plain.setFont(fo1);
    if ((plain.fontInfo().fixedPitch())
     && (plain.fontInfo().pointSize() > 5))
    {
      if ((plain.fontInfo().family().toUpper().contains("WINGDING"))
       || (plain.fontInfo().family().toUpper().contains("WEBDING"))
       || (plain.fontInfo().family().toUpper().contains("EMOJI"))
       || (plain.fontInfo().family().toUpper().contains("ORYA"))
       || (plain.fontInfo().family().toUpper().contains("DINGBAT")))
       ;
      else this_points+= 2;
      if (plain.fontInfo().family() == recommended_family)
        this_points+= 2;
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
      if (plain.fontInfo().family().left(first_word_length).toUpper() == first_word)
        this_points+= 3;
#else
      QString f= plain.fontInfo().family();
      f= f.toUpper();
      if ((f == "CONSOLAS") || (f == "COURIER NEW") || (f == "LUCIDA CONSOLE"))
        this_points+= 3;
#endif
      if (plain.fontInfo().pointSize() == point_size)
        this_points+= 1;
      if ((plain.fontInfo().pointSize() >= (point_size * 0.9))
       && (plain.fontInfo().pointSize() <= (point_size * 1.2)))
        this_points+= 1;
      if (plain.fontInfo().weight() == weight)
        this_points+= 1;
      if (plain.fontInfo().style() == font_style)
        this_points+= 1;
      if (this_points > winner_font_points)
      {
        winner_font_family= plain.fontInfo().family();
        winner_font_point_size= plain.fontInfo().pointSize();
        winner_font_weight= plain.fontInfo().weight();
        winner_font_font_style= plain.fontInfo().style();
        winner_font_points= this_points;
      }
    }
  }
  if (winner_font_points == 0) return f1;
  QFont winner_font= QFont(winner_font_family,
                           winner_font_point_size,
                           winner_font_weight);
  winner_font.setStyle(winner_font_font_style);
  return winner_font;
}

/*
  Given RGB, return color name for current language
  If current language is not English, this may not be the
  canonical color name.
  It might be a bug if we don't find the rgb in s_color_list,
  but there a few extra RGBs in q_color_list.
  Todo: I think there's redundancy somewhere, that is,
        some other procedure does the same thing.
*/
/*
  Test: change q_i = 0 to q_i= color_off
        change q_i + color_off to q_i
*/
QString MainWindow::rgb_to_color(QString rgb)
{
  char rgb_as_utf8[128]; /* actually max rgb len = 7, allow for error */
  strcpy(rgb_as_utf8, rgb.toUpper().toUtf8());
  for (int q_i= color_off; strcmp(s_color_list[q_i]," ") > 0; q_i+= 2)
  {
    if (strcmp(s_color_list[q_i + 1], rgb_as_utf8) == 0)
    {
      QString color_name= s_color_list[q_i];
      return color_name;
    }
  }
  return rgb;
}


/*
  Pass: a string which is supposed to have a color name.
  Return: a canonical color name, i.e. an RGB value.
  1. Check color_list (names). If match, return RGB. Might be a case change e.g. Gray not gray.
  2. Accept some color name variants, e.g. Gray not grey, return RGB.
     They appear in http://www.w3.org/TR/SVG/types.html#ColorKeywords.
  3. Put the color in a QColor. If result is invalid, return "" which means invalid.
  4. Get the color back as #RRGGBB
  5. Return the #RRGGBB color.
  This does not mean that absolutely no synonyms are allowed
  -- two names may have the same #RRGGBB, as with Fuchsia|Magenta.
*/
QString MainWindow::canonical_color_name(QString color_name_string)
{
  QString s;
  QString co;

  co= color_name_string;

  if (co.left(1) != "#")
  {
    /*
      Todo: This appears to work for setting colors that contain ''
      but what if I SET ... = "...''..." elsewhere?
      Also: I think co.replace() does the job, I don't need to assign.
    */
    if (co.contains("''")) co= co.replace("''", "'");

    /* Search #1: in the color list for the current language offset. */
    for (int i= color_off; strcmp(s_color_list[i], "") > 0; i+= 2)
    {
      s= s_color_list[i];
      if (QString::compare(co, s, Qt::CaseInsensitive) == 0)
      {
        s= s_color_list[i + 1];                /* Return the RGB */
        return s;
      }
    }

    /* Search #2: Fixed list of variants equivalent to some W3C words */
    if (QString::compare(color_name_string, "Cornflower", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_CORNFLOWERBLUE*2 + 1];
    if (QString::compare(color_name_string, "Darkgrey", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_DARKGRAY*2 + 1];
    if (QString::compare(color_name_string, "DarkSlateGrey", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_DARKSLATEGRAY*2 + 1];
    if (QString::compare(color_name_string, "DimGrey", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_DIMGRAY*2 + 1];
    if (QString::compare(color_name_string, "Grey", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_GRAY*2 + 1];
    if (QString::compare(color_name_string, "LightGoldenrod", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_LIGHTGOLDENRODYELLOW*2 + 1];
    if (QString::compare(color_name_string, "LightGrey", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_LIGHTGRAY*2 + 1];
    if (QString::compare(color_name_string, "LightSlateGrey", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_LIGHTSLATEGRAY*2 + 1];
    if (QString::compare(color_name_string, "NavyBlue", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_NAVY*2 + 1];
    if (QString::compare(color_name_string, "SlateGrey", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_SLATEGRAY*2 + 1];

    /* Search #3: in the color list for all languages */
    {
      int lc;
      for (lc= 0; strcmp(string_languages[lc], "") != 0; ++lc) ;
      for (int j= 0; j < lc; ++j)
      {
        for (int i= j * COLOR_END; strcmp(s_color_list[i], "") > 0; i+= 2)
        {
          s= s_color_list[i];
          if (QString::compare(co, s, Qt::CaseInsensitive) == 0)
          {
            s= s_color_list[i + 1];                /* Return the RGB */
            return s;
          }
        }
      }
    }
  }

  /*
    It's not in any of our color lists, but it might be a name that Qt
    will accept anyway (e.g. in some version that I'm unaware of),
    or it was passed with an initial # so it's some variant of #RGB.
    But make sure it's valid, and convert to the canonical: #RRGGBB.
    NB: returning "" means error but not every caller checks for that.
  */

  QColor qq_color;
  qq_color.setNamedColor(co);
  if (qq_color.isValid() == false) return "";                 /* bad color, maybe bad format */
  QString qq_color_name= qq_color.name();                      /* returns name as "#RRGGBB" */

  //for (int i= color_off + 1; strcmp(s_color_list[i], "") > 0; i+= 2)
  //{
  //  s= s_color_list[i];
  //  if (QString::compare(qq_color_name, s, Qt::CaseInsensitive) == 0)
  //  {
  //    s= s_color_list[i - 1];
  //    return s;
  //  }
  //}
  return qq_color_name;
}


/* Called from: make_style_strings(). We allow sixteen color names that Qt doesn't like. */
QString MainWindow::qt_color(QString color_name)
{
  if (QString::compare(color_name, "Aqua", Qt::CaseInsensitive) == 0) return "#00FFFF"; /* = Cyan */
  if (QString::compare(color_name, "Fuchsia", Qt::CaseInsensitive) == 0) return "#FF00FF"; /* = Magenta */
  if (QString::compare(color_name, "GrayX11", Qt::CaseInsensitive) == 0) return "#BEBEBE";
  if (QString::compare(color_name, "GreenX11", Qt::CaseInsensitive) == 0) return "#00FF00";
  if (QString::compare(color_name, "Indigo", Qt::CaseInsensitive) == 0) return "#4B0082";
  if (QString::compare(color_name, "Lime", Qt::CaseInsensitive) == 0) return "#00FF00"; /* = Green */
  if (QString::compare(color_name, "MaroonX11", Qt::CaseInsensitive) == 0) return "#B03060";
  if (QString::compare(color_name, "Olive", Qt::CaseInsensitive) == 0) return "#808000";
  if (QString::compare(color_name, "PurpleX11", Qt::CaseInsensitive) == 0) return "#A020F0";
  if (QString::compare(color_name, "RebeccaPurple", Qt::CaseInsensitive) == 0) return "#663399";
  if (QString::compare(color_name, "Silver", Qt::CaseInsensitive) == 0) return "#C0C0C0";
  if (QString::compare(color_name, "Teal", Qt::CaseInsensitive) == 0) return "#008080";
  if (QString::compare(color_name, "WebGray", Qt::CaseInsensitive) == 0) return "#808080";
  if (QString::compare(color_name, "WebGreen", Qt::CaseInsensitive) == 0) return "#008000";
  if (QString::compare(color_name, "WebMaroon", Qt::CaseInsensitive) == 0) return "#7F0000";
  if (QString::compare(color_name, "WebPurple", Qt::CaseInsensitive) == 0) return "#7F007F";
  return color_name;
}


/*
  Pass: a string which is supposed to have a font weight. Return: a canonical font weight, a css number.
  See comment in ocelotgui.h that begins with the words "Font comments"
*/
QString MainWindow::canonical_font_weight(QString font_weight_string)
{
  int fwi= fontweights_index_via_chars(font_weight_string);
  int font_weight_as_int= fontweightsvalues[fwi].css_number; /* e.g. if font is "Light" we get 300 */
  char tmp_font_weight_string[64];
  strcpy(tmp_font_weight_string, font_weight_string.toUtf8());
  return QString::number(font_weight_as_int);
}

/* Pass: weight string. */
/* Return: offset within fontweightsvalues so e.g. you can get fontweightsvalues[i].qt_number. Or: -1. */
/* If it is a number less than 100 we assume that it's a QFont value, else we assume that it's a css value. */
/* todo: maybe if it's not a known name we should return the index for "normal"? */
int MainWindow::fontweights_index_via_chars(QString weight_string)
{
  QString weight_lower= weight_string.toLower();
  for (int i= 0; i <= FONTWEIGHTSVALUES_SIZE; ++i)
  {
    if ((weight_lower == fontweightsvalues[i].chars)
     || (weight_lower == fontweightsvalues[i].alternate_chars))
      return i;
  }
  bool ok;
  int weight_as_int= weight_lower.toInt(&ok);
  if (ok == false) return -1;
  if (weight_as_int < 100) return fontweights_index_via_qt_number(weight_as_int);
  return fontweights_index_via_css_number(weight_as_int);
}

/*
  Pass: int for QFont to recognize, e.g. QFont::Light | Qt::Bold
  Return: index of e.g. Qt::Bold within fontweightvalues so we can get chars or css_number
  If the value is < Qt::Bold but >= Qt::DemiBold return index of Qt::DemiBold
*/
int MainWindow::fontweights_index_via_qt_number(int qt_number)
{
  int i;
  for (i= 1; i <= FONTWEIGHTSVALUES_SIZE; ++i)
  {
    if (qt_number < (int)fontweightsvalues[i].qt_number) break;
  }
  return i - 1;
}

/*
  Pass: int for css to recognize, e.g. 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900
  Return: index of e.g. 700 ("bold") within fontweightvalues so we can get chars or qt_number
  If the value is < 700 but >= 600 return index of 600
*/
int MainWindow::fontweights_index_via_css_number(int css_number)
{
  int i;
  for (i= 1; i <= FONTWEIGHTSVALUES_SIZE; ++i)
  {
    if (css_number < (int)fontweightsvalues[i].css_number) break;
  }
  return i - 1;
}


/*
  Pass font_family. Return font_family lower case stripped, or if it is invalid return "".
  This may also change font_style.
  If you set to a family that has neither "italic" nor "oblique", style should be "normal".
  Re Qt "font matching algorithm":
    There is no function that checks whether a family exists. We tried looking up the family
    via QFontDatabase but then QFontDialog can fail, for example "sans serif" is in QFontDatabase but not in QFontDialog,
    "sans regular" is in QFontDialog but not in QFontDatabase.
    Todo: make your own QFontDialog that depends on QFontDatabase. (This was done in version 1.5.)
  Switching to QFontinfo family solves the problem that QDialogBox has alias 'Sans', it's really 'DejaVu Sans'.
  Unfortunately QFontInfo also changes 'Ubuntu Light' to 'Ubuntu' but I will insist on using QFontInfo()'s decisions.
  Unfortunately 'padmaa italic' is in QFontDialog but QFontDatabase has only 'Regular' and 'Normal'.
*/
QString MainWindow::canonical_font_family(QString font_family_string, QString* font_style_string)
{
  QString new_font_family_string= connect_stripper(font_family_string, false);
  QFontDatabase font_database;
  QFont font= QFont(new_font_family_string);
  QFontInfo qfontinfo= QFontInfo(font);
  new_font_family_string= qfontinfo.family();
  const QStringList font_styles= font_database.styles(new_font_family_string);
  if (font_styles.count() == 0) return ""; /* Actually I don't think this is possible */
  QString new_font_style_string= canonical_font_style(new_font_family_string, *font_style_string);
  if (new_font_style_string == "") new_font_style_string= canonical_font_style(new_font_family_string, "normal");
  *font_style_string= new_font_style_string;
  return new_font_family_string;
}

/*
  Pass: a string which is supposed to have a font style. Return: a canonical font style.
  If it's not an expected value, return "normal" even though it might be invalid.
  We might change "italic" to "oblique" or vice versa depending on family --
  although you could set italic for a font that allows only oblique,
  later QDialogBox wouldn't find it.
  If the return is "" then I think it's safest to ignore and leave unchanged.
  Some QFontDatabase entries are "Regular" "Bold Oblique" "Light" etc. We only care about "Italic" and/or "Oblique".
  I don't use QStringList::contains() because it is new in Qt 5.12.
  Todo: This doesn't allow for families that have both italic and oblique. Prefer what is passed.
*/
QString MainWindow::canonical_font_style(QString font_family_string, QString font_style_string)
{
  QFontDatabase font_database;
  const QStringList font_styles= font_database.styles(font_family_string);
  if (font_styles.count() == 0) return ""; /* Presumably if there are no styles that means no such family */
  QString new_font_style_string= font_style_string.toLower();
  if (new_font_style_string == "normal") return new_font_style_string;
  if ((new_font_style_string == "italic")
   || (new_font_style_string == "oblique"))
  {
    QString font_database_name;
    for (int i= 0; i < font_styles.count(); ++i)
    {
      font_database_name= font_styles.at(i);
      if (QString::compare(font_styles.at(i), "italic", Qt::CaseInsensitive) == 0) return "italic";
      if (QString::compare(font_styles.at(i), "oblique", Qt::CaseInsensitive) == 0) return "oblique";
    }
  }
  /* Some fonts allow italics in QFontDialog but don't show italics in QFontDatabase. */
  if (new_font_style_string == "italic")
  {
    QFont font_of_family= QFont(font_family_string);
    font_of_family.setStyle(QFont::StyleItalic);
    QFont::Style style_of_family= font_of_family.style();
    if (style_of_family == QFont::StyleItalic) return "italic";
  }

  return "";
}


/* Called from: action_statement() etc. Make a string that setStyleSheet() can use. */
/*
  Todo: I wasn't able to figure out a simple way to emphasize widget title, for example make it bold.
  Todo: Notice hardcoded "gray" for QMenu::item:disabled? We could have
        more selectable options for that, and for other QMenu::item
        pseudo- stuff, and QMenu::separator.
        E.g. QMenu:item:selected if you can decide on a colour.
  TODO: Also for QTextedit we should have ...:selected because right now
        when you select and then change focus, you lose the colour.
  Todo: Consider: font-size can be [ small | medium | large | x-large | xx-large ] | <size>pt | <size>px
  Warning: Changing border:1px could affect Completer_widget::size_and_position_change()
*/
void MainWindow::make_style_strings()
{
  make_one_style_string(&ocelot_statement_style_string,
                        qt_color(ocelot_statement_text_color),
                        qt_color(ocelot_statement_background_color),
                        "1",
                        qt_color(ocelot_statement_border_color),
                        ocelot_statement_font_family,
                        ocelot_statement_font_size,
                        ocelot_statement_font_style,
                        ocelot_statement_font_weight,
                           false);
  make_one_style_string(&ocelot_grid_style_string,
                        qt_color(ocelot_grid_text_color),
                        qt_color(ocelot_grid_background_color),
                        ocelot_grid_cell_border_size,
                        qt_color(ocelot_grid_focus_cell_background_color),
                        ocelot_grid_font_family,
                        ocelot_grid_font_size,
                        ocelot_grid_font_style,
                        ocelot_grid_font_weight,
                        false);
  make_one_style_string(&ocelot_history_style_string,
                        qt_color(ocelot_history_text_color),
                        qt_color(ocelot_history_background_color),
                        "1",
                        qt_color(ocelot_history_border_color),
                        ocelot_history_font_family,
                        ocelot_history_font_size,
                        ocelot_history_font_style,
                        ocelot_history_font_weight,
                        false);
  make_one_style_string(&ocelot_grid_header_style_string,
                        qt_color(ocelot_grid_text_color),
                        qt_color(ocelot_grid_header_background_color),
                        ocelot_grid_cell_border_size,
                        qt_color(ocelot_grid_focus_cell_background_color),
                        ocelot_grid_font_family,
                        ocelot_grid_font_size,
                        ocelot_grid_font_style,
                        ocelot_grid_font_weight,
                        false);
  make_one_style_string(&ocelot_menu_style_string,
                        qt_color(ocelot_menu_text_color),
                        qt_color(ocelot_menu_background_color),
                        "1",
                        qt_color(ocelot_menu_border_color),
                        ocelot_menu_font_family,
                        ocelot_menu_font_size,
                        ocelot_menu_font_style,
                        ocelot_menu_font_weight,
                        true);
  make_one_style_string(&ocelot_extra_rule_1_style_string,
                        qt_color(ocelot_extra_rule_1_text_color),
                        qt_color(ocelot_extra_rule_1_background_color),
                        ocelot_grid_cell_border_size,
                        qt_color(ocelot_grid_focus_cell_background_color),
                        ocelot_grid_font_family,
                        ocelot_grid_font_size,
                        ocelot_grid_font_style,
                        ocelot_grid_font_weight,
                        false);
#if (OCELOT_EXPLORER == 1)
  make_one_style_string(&ocelot_explorer_style_string,
                        qt_color(ocelot_explorer_text_color),
                        qt_color(ocelot_explorer_background_color),
                        "1",
                        qt_color(ocelot_menu_border_color),
                        ocelot_explorer_font_family,
                        ocelot_explorer_font_size,
                        ocelot_explorer_font_style,
                        ocelot_explorer_font_weight,
                        false);
#endif
}

/* called from make_style_strings (above) and Settings function text_for_font_example_filler in ocelotgui.h */
/* We enclose font-family in ''s because some names country [foundry] */
void MainWindow::make_one_style_string(QString *style_string,
                                       QString text_color,
                                       QString background_color,
                                       QString border_size,
                                       QString border_color,
                                       QString font_family,
                                       QString font_size,
                                       QString font_style, QString font_weight, bool is_menu)
{
  *style_string= "";
  if (is_menu)   (*style_string).append("* {");
  (*style_string).append("color:"); (*style_string).append(text_color);
  (*style_string).append(";background-color:"); (*style_string).append(background_color);
  (*style_string).append(";border:");
  (*style_string).append(border_size);
  (*style_string).append("px solid ");
  (*style_string).append(border_color);
  font_family= font_family.trimmed();
  font_family= connect_stripper(font_family, false);
  font_family= "'" + font_family + "'";
  (*style_string).append(";font-family:"); (*style_string).append(font_family);
  (*style_string).append(";font-size:"); (*style_string).append(font_size);
  (*style_string).append("pt;font-style:"); (*style_string).append(font_style);
  font_weight= font_weight.trimmed();
  (*style_string).append(";font-weight:"); (*style_string).append(canonical_font_weight(font_weight));
  if (is_menu)
  {
    (*style_string).append("} ");
    (*style_string).append("QMenu::item:disabled {");
    (*style_string).append("background-color:gray");
    (*style_string).append("}");
  }
}


/*
  Use: ocelot_grid_style string. Return: max height of one char, and combined height of borders.
  Assume that ocelot_grid_style_string also has "...border:...px...".

  This is always a problem.
  Simply doing QFontMetrics() for the widget you're working on won't work till show() happens.
  Todo: probably the spacing could look a little tidier.
  Todo: right now we do nothing with width, we could add that later
        (for one Latin character, or for a passed string).
  Todo: Find out why one must magic numbers to prevent vertical scroll bars from appearing.
        It seems to depend on font size -- with bigger fonts I could add smaller numbers.
  Todo: This is working for Row_form_box, now get it working for the result grid.
  Beware: height() is internal height but setMinimumSize() may depend on external height.
*/
void MainWindow::component_size_calc(int *character_height, int *borders_height)
{
  {
    QFont font= get_font_from_style_sheet(ocelot_grid_style_string);
    QFontMetrics fm(font);
    *character_height= fm.lineSpacing();
    /* See also the  kludge in grid_column_size_calc */
  }
  {
    int border_size_start= ocelot_grid_style_string.indexOf("border:");
    int border_size_end= ocelot_grid_style_string.indexOf("px", border_size_start);
    QString border_size= ocelot_grid_style_string.mid(border_size_start + 7, border_size_end - (border_size_start + 7));
    border_size= border_size.trimmed(); /* probably unnecessary */
    bool ok;
    int border_size_as_int= border_size.toInt(&ok);
    assert(ok == true);
    assert(border_size_as_int >= 0);
    *borders_height= border_size_as_int * 2 + 9;
  }
}


/*
  Pass: style_string. Return: QFont.
  In practice we always pass ocelot_grid_style_string and all we care about is height.
  Assume that style string always has "font-family... font-size:...pt;...font-weight:...".
  style_string has points not pixels, because the dialog box for getting a font always uses points.
  Here we make a new QFont based on font-family, font-size, font-weight (NB: all are necessary);
  from this font we can calculate a widget's internal height in pixels.
  Alternative: we could create a widget, apply style_string to it, then ask what its font is,
  but that's probably a bit slower because we have to show() the widget first.
  Some font weights are Qt 5.6: https://doc-snapshots.qt.io/qt5-5.6/qfont.html#Weight-enum
  Todo: we are tokenizing klunkily. This caused an assert with
        ... ;font-weight:400} QMenu::item:disabled {background-color:gray}
        because we expected either ; or end-of-string. So we added a check for } there too.
        But there are other things that could be wrong with strings.
*/
QFont MainWindow::get_font_from_style_sheet(QString style_string)
{
  QString font_family= "";
  int font_size_as_int= -1;
  bool font_style_as_bool= false;
  int font_weight_as_int= -1;
  {
    int font_family_start= style_string.indexOf("font-family:");
    int font_family_end= style_string.indexOf(";", font_family_start);
    font_family= style_string.mid(font_family_start + 12, font_family_end - (font_family_start + 12));
    font_family= font_family.trimmed();
    assert(font_family > "");
  }
  {
    int font_size_start= style_string.indexOf("font-size:");
    int font_size_end= style_string.indexOf("pt", font_size_start);
    QString font_size= style_string.mid(font_size_start + 10, font_size_end - (font_size_start + 10));
    font_size= font_size.trimmed();
    bool ok;
    font_size_as_int= font_size.toInt(&ok);
    assert(ok == true);
    assert(font_size_as_int >= 1);
  }
  {
    int font_style_start= style_string.indexOf("font-style:");
    int font_style_end= style_string.indexOf(";", font_style_start);
    QString font_style= style_string.mid(font_style_start + 11, font_style_end - (font_style_start + 11));
    font_style= font_style.trimmed();
    assert(font_style > "");
    if (QString::compare(font_style,"normal",Qt::CaseInsensitive) == 0) font_style_as_bool= false;
    if (QString::compare(font_style,"italic",Qt::CaseInsensitive) == 0) font_style_as_bool= true;
    if (QString::compare(font_style,"oblique",Qt::CaseInsensitive) == 0) font_style_as_bool= true;
  }
  {
    int font_weight_start= style_string.indexOf("font-weight:");
    int font_weight_end= style_string.indexOf(";", font_weight_start);
    if (font_weight_end < 0) font_weight_end= style_string.indexOf("}", font_weight_start);
    if (font_weight_end < 0) font_weight_end= style_string.length();
    QString font_weight= style_string.mid(font_weight_start + 12, font_weight_end - (font_weight_start + 12));
    font_weight= font_weight.trimmed();
    int fwi= fontweights_index_via_chars(font_weight);
    font_weight_as_int= fontweightsvalues[fwi].qt_number; /* e.g. if font is "Light" we get QFont::Light */
    assert(font_weight_as_int >= 0);
  }
  QFont font(font_family, font_size_as_int, font_weight_as_int, font_style_as_bool);
  return font;
}

/* Warning: assumption that color: comes before background-color: */
QString MainWindow::get_color_from_style_sheet(QString style_string)
{
  int color_start= style_string.indexOf("color:");
  int color_end= style_string.indexOf(";", color_start);
  QString color= style_string.mid(color_start + 6, color_end - (color_start + 6));
  return color;
}

QString MainWindow::get_background_color_from_style_sheet(QString style_string)
{
  int background_color_start= style_string.indexOf("background-color:");
  int background_color_end= style_string.indexOf(";", background_color_start);
  QString color= style_string.mid(background_color_start + 17, background_color_end - (background_color_start + 17));
  return color;
}

/*
  Get the next statement in a string.
  Pass: string, offset within string. Or: main_token number.
  Return: length i.e. # of tokens including delimiter or ; so offset can be right next time
          length == 0 would mean end-of-string
  Re how to find the end of a statement:
     For each token
       If (token == BEGIN or ELSEIF or IF or LOOP or REPEAT or WHILE) ++begin_count
       If (token == END --begin_count
     If (token == delimiter) this is the end
     If (no more tokens) this is the end
     If (token == ';' and begin_count == 0) this is the end
     Todo: What about \G etc.?
     NB: it's an error if begin_count>0 and this is the end, caller might return client error
  Re CLIENT_MULTI_STATEMENT: this would work too, but in the long term I'll want to
     know for sure: which statement returned result set X? Since a CALL can return
     multiple result sets, I didn't see a way to figure that out.
  Re: Don't bother with begin_count if PROCEDURE or FUNCTION or TRIGGER
      or EVENT hasn't been seen. But sometimes BEGIN or DECLARE can be
      starts of compound statements.
  Re: package_executable_section_begin_seen. CREATE PACKAGE BODY can end
      with END, or with BEGIN END. In the latter case we have too many
      BEGINs because we count CREATE PACKAGE as equivalent to BEGIN.
      So anything associated with this variable is an attempt to avoid
      the miscount.
  Beware: insert into t8 values (5); prompt w (unlike mysql client we wait for ';' here)
  Beware: create procedure p () begin end// select 5//
  Beware: input might be a file dump, and statements might be long.
  Todo: think about delimiter. Maybe delimiters don't count if you're in a delimiter statement?
  Todo: this doesn't allow for the possibility of "END comment WHILE|LOOP|REPEAT;"
  Todo: although label:begin declare v1 int; end; is illegal, it's confusing to miss the begin.
        we end up splitting the "end;" into a separate statement.
*/
int MainWindow::get_next_statement_in_string(int passed_main_token_number,
                                             int *returned_begin_count,
                                             bool check_if_client)
{
  int i;
  int begin_count= 0;
  QString last_token, second_last_token;
  QString text;
  int i_of_first_non_comment_seen= -1;
  bool begin_seen= false;
  text= statement_edit_widget->toPlainText(); /* Todo: decide whether I'm doing this too often */
  /*
    First, check for client statement, because the rules for client statement end are:
    ; OR delimiter OR \n OR \n\r
    but a DELIMITER statement ends with first whitespace after its argument
    or next client statement? or next statement of any kind?
  */
  bool client_statement_seen= false;
  bool create_package_seen= false;
  bool package_executable_section_begin_seen= false;
  for (i= passed_main_token_number; main_token_lengths[i] != 0; ++i)
  {
    int token= main_token_types[i];
    if ((token == TOKEN_TYPE_COMMENT_WITH_SLASH)
     || (token == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
     || (token == TOKEN_TYPE_COMMENT_WITH_MINUS))
      continue;
    if (is_client_statement(token, i, text) == true) client_statement_seen= true;
    break;
  }
  if ((client_statement_seen == true) && (check_if_client == true))
  {
    int client_statement_type= main_token_types[i];
    for (i= i; main_token_lengths[i] != 0; ++i)
    {
      /* Client statements can end with \n alone but SET (which is Ocelot-specific not defined by MySQL) needs ; */
      if ((main_token_lengths[i + 1] != 0) && (client_statement_type != TOKEN_KEYWORD_SET))
      {
        int j= main_token_offsets[i] + main_token_lengths[i];
        bool line_break_seen= false;
        while (j < main_token_offsets[i + 1])
        {
          if (j >= text.size()) break; /* I think this is impossible but added for safety on 2021-08-13 */
          if (text.mid(j, 1) == "\n")
          {
            line_break_seen= true;
            break;
          }
          ++j;
        }
        if (line_break_seen == true)
        {
          ++i;
          break;
        }
      }
      int token= main_token_types[i];
      if ((token == TOKEN_TYPE_COMMENT_WITH_SLASH)
       || (token == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
       || (token == TOKEN_TYPE_COMMENT_WITH_MINUS))
      {
        continue;
      }
      last_token= text.mid(main_token_offsets[i], main_token_lengths[i]);
      if (QString::compare(ocelot_delimiter_str, ";") != 0)
      {
        if (QString::compare(last_token, ocelot_delimiter_str) == 0)
        {
          ++i; break;
        }
      }
      if (QString::compare(last_token, ";") == 0)
      {
        ++i; break;
      }
    }
  }
  else
  {
    bool is_maybe_in_compound_statement= false;
    bool is_create_trigger= false;
    bool is_create_routine= false;
    int statement_type= -1;
    if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0)
    {
      QString word0= "", word1= "", word2= "";
      int word_number= 0;
      for (i= passed_main_token_number; main_token_lengths[i] != 0; ++i)
      {
        if ((main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_SLASH)
         || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
         || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_MINUS))
          continue;
        if (word_number == 0) word0= text.mid(main_token_offsets[i], main_token_lengths[i]);
        if (word_number == 1) word1= text.mid(main_token_offsets[i], main_token_lengths[i]);
        if (word_number == 2)
        {
          word2= text.mid(main_token_offsets[i], main_token_lengths[i]);
          break;
        }
        ++word_number;
      }
      statement_type= get_statement_type_low(word0, word1, word2);
    }
    last_token= "";
    for (i= passed_main_token_number; main_token_lengths[i] != 0; ++i)
    {
      if ((hparse_dbms_mask & FLAG_VERSION_PLSQL) != 0)
      {
        if (main_token_types[i] == TOKEN_KEYWORD_DECLARE)
        {
          is_maybe_in_compound_statement= true;
        }
        if (main_token_types[i] == TOKEN_KEYWORD_BEGIN)
        {
          begin_seen= true;
        }
      }
      second_last_token= last_token;
      last_token= text.mid(main_token_offsets[i], main_token_lengths[i]);
      if (QString::compare(ocelot_delimiter_str, ";") != 0)
      {
        if (QString::compare(last_token, ocelot_delimiter_str) == 0)
        {
          ++i; break;
        }
      }
      if ((QString::compare(last_token, "G", Qt::CaseInsensitive) == 0)
       && (QString::compare(second_last_token, "\\", Qt::CaseInsensitive) == 0))
      {
        ++i; break;
      }
      if ((QString::compare(last_token, ";") == 0) && (begin_count == 0))
      {
        if (((dbms_version_mask & FLAG_VERSION_PLSQL) != 0)
         && (is_maybe_in_compound_statement == true)
         && (begin_seen == false))
        {
          ; /* pl/sql: e.g. skip ; if it's between declare and begin */
        }
        else
        {
          ++i; break;
        }
      }
      if (i_of_first_non_comment_seen != -1)
      {
        if (main_token_types[i_of_first_non_comment_seen] == TOKEN_KEYWORD_CREATE)
        {
          if (main_token_types[i] == TOKEN_KEYWORD_TRIGGER)
          {
            is_maybe_in_compound_statement= true;
            is_create_trigger= true;
          }
          if ((main_token_types[i] == TOKEN_KEYWORD_PROCEDURE)
          ||  (main_token_types[i] == TOKEN_KEYWORD_FUNCTION)
          ||  (main_token_types[i] == TOKEN_KEYWORD_EVENT))
          {
            is_maybe_in_compound_statement= true;
            is_create_routine= true;
          }
          if (main_token_types[i] == TOKEN_KEYWORD_PACKAGE) /* new */
          { /* new */
            is_maybe_in_compound_statement= true; /* new */
            ++begin_count;       /* new */
            begin_seen= true; /* new */
            create_package_seen= true;
          } /* new */
        }
      }
      if (i_of_first_non_comment_seen == -1)
      {
        if (((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0) && (is_create_routine == false))
        {
          if (statement_type == TOKEN_KEYWORD_DO_LUA)
          {
            is_maybe_in_compound_statement= true;
          }
        }
        else
        {
          /* Following should only occur if we're sure it's MariaDB */
          if ((main_token_types[i] == TOKEN_KEYWORD_BEGIN)
          ||  (main_token_types[i] == TOKEN_KEYWORD_CASE)
          ||  (main_token_types[i] == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT)
          ||  (main_token_types[i] == TOKEN_KEYWORD_IF)
          ||  (main_token_types[i] == TOKEN_KEYWORD_LOOP)
          ||  (main_token_types[i] == TOKEN_KEYWORD_REPEAT)
          ||  (main_token_types[i] == TOKEN_KEYWORD_WHILE))
          {
            is_maybe_in_compound_statement= true;
          }
        }
        if ((main_token_types[i] != TOKEN_TYPE_COMMENT_WITH_SLASH)
         && (main_token_types[i] != TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
         && (main_token_types[i] != TOKEN_TYPE_COMMENT_WITH_MINUS))
        {
          i_of_first_non_comment_seen= i;
        }
      }
      /* For some reason the following was checking TOKEN_KEYWORD_ELSEIF too. Removed. */
      if (is_maybe_in_compound_statement == true)
      {
        if (((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0) && (is_create_routine == false))
        {
          if (statement_type == TOKEN_KEYWORD_DO_LUA)
          {
            if ((main_token_types[i] == TOKEN_KEYWORD_DO_LUA)
            ||  (main_token_types[i] == TOKEN_KEYWORD_IF)
            ||  (main_token_types[i] == TOKEN_KEYWORD_FUNCTION)
            ||  (main_token_types[i] == TOKEN_KEYWORD_REPEAT))
            {
              ++begin_count;
            }
            if ((main_token_types[i] == TOKEN_KEYWORD_END)
            ||  (main_token_types[i] == TOKEN_KEYWORD_UNTIL))
            {
              --begin_count;
            }
          }
          else if (is_create_trigger == true)
          {
            if (main_token_types[i] == TOKEN_KEYWORD_BEGIN)
            {
              ++begin_count;
            }
            if (main_token_types[i] == TOKEN_KEYWORD_END)
            {
              --begin_count;
            }
          }
        }
        else
        {
          if ((main_token_types[i] == TOKEN_KEYWORD_BEGIN)
          ||  ((main_token_types[i] == TOKEN_KEYWORD_CASE)   && ((i == i_of_first_non_comment_seen) || (main_token_types[i - 1] != TOKEN_KEYWORD_END)))
          ||  ((main_token_types[i] == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT) && ((i == i_of_first_non_comment_seen) || (main_token_types[i - 1] != TOKEN_KEYWORD_END)))
          ||  ((main_token_types[i] == TOKEN_KEYWORD_IF)     && ((i == i_of_first_non_comment_seen) || (main_token_types[i - 1] != TOKEN_KEYWORD_END)))
          ||  ((main_token_types[i] == TOKEN_KEYWORD_LOOP)   && ((i == i_of_first_non_comment_seen) || (main_token_types[i - 1] != TOKEN_KEYWORD_END)))
          ||  ((main_token_types[i] == TOKEN_KEYWORD_REPEAT) && ((i == i_of_first_non_comment_seen) || (main_token_types[i - 1] != TOKEN_KEYWORD_END)))
          ||  ((main_token_types[i] == TOKEN_KEYWORD_WHILE)  && ((i == i_of_first_non_comment_seen) || (main_token_types[i - 1] != TOKEN_KEYWORD_END))))
          {
            if ((create_package_seen)
             && (main_token_types[i] == TOKEN_KEYWORD_BEGIN)
             && (begin_count == 1))
            {
              int j= next_i(i, -1);
              if ((main_token_types[j] != TOKEN_KEYWORD_AS)
               && (main_token_types[j] != TOKEN_KEYWORD_IS))
                package_executable_section_begin_seen= true;
            }
            ++begin_count;
          }
          if ((main_token_types[i] == TOKEN_KEYWORD_END)
           || (main_token_types[i] == TOKEN_KEYWORD_END_IN_CREATE_STATEMENT)) /* new */
          {
            --begin_count;
            if ((package_executable_section_begin_seen)
             && (begin_count == 1))
              --begin_count;
          }
        }
      }
    }
  }
  *returned_begin_count= begin_count;

  /* If delimiter follows ; then it's part of the statement, to be stripped later. */
  bool delimiter_seen= false;
  if (text.mid(main_token_offsets[i], main_token_lengths[i]) == ocelot_delimiter_str)
  {
    delimiter_seen= true;
  }

  /*
    If comment follows ; on the same line, then we'll take it as part of the statement.
    But if it comes after delimiter other than ; then we won't take it as part of the
    statement, because we have to strip delimiters before sending to the server,
    and for that we expect the delimiter token to be the last token in the statement.
    Todo: it might be better to not expect token to be the last token in the statement.
    Todo: there might be more than one comment.
  */
  bool comment_seen= false;
  if ((i > 0)
   && (main_token_lengths[i] != 0)
   && ((ocelot_delimiter_str == ";")
    || (text.mid(main_token_offsets[i - 1], main_token_lengths[i - 1]) != ocelot_delimiter_str))
   //&& ((i < 2)
   // || (text.mid(main_token_offsets[i - 1], main_token_lengths[i - 1]).toUpper() != "G")
   // || (text.mid(main_token_offsets[i - 2], main_token_lengths[i - 2]) != "\\"))
          )

  {
    if ((main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_SLASH)
     || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
     || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_MINUS))
    {
      comment_seen= true;
      int j= main_token_offsets[i - 1] + main_token_lengths[i - 1];
      while (j < main_token_offsets[i])
      {
        if (text.mid(j,1) == "\n")
        {
          comment_seen= false;
        }
        ++j;
      }
    }
  }
  if ((delimiter_seen == true) || (comment_seen == true)) ++i;
  return i - passed_main_token_number;
}


/*
  Make statement ready to send to server: strip comments and delimiter, output UTF8.
  We have an SQL statement that's ready to go to the server.
  We have a guarantee that the result i.e. "char *query" is big enough.
  Rremove comments if that's what the user requested with --skip-comments which is default.
  Remove final token if it's delimiter but not ';'.
  Ignore last token(s) if delimiter, \G, \g, or (sometimes) go, ego.
  Todo: there's a conversion to UTF8 but it should be to what server expects.
  Todo: um, in that case, make server expect UTF8.
  Re comment stripping: currently this is default because in mysql client it's default
    but there should be no assumption that this will always be the case,
    so some sort of warning might be good. The history display has to include
    the comments even if they're not sent to the server, so the caller of this
    routine will use both (original string,offset,length) and (returned string).
    Comments should be replaced with a single space.
    Do not strip comments that start with / * ! or / * M !
  Re Tarantool comment stripping: "#" does not begin a comment,
    and inline comments will be trouble if ocelot_comments <> 0
    because they're not legal in Lua (we don't try to solve that).
  Todo: Tarantool comments are different, eh?
  Todo: It's silly to call this every time you call real_query.
        Do it once, and you don't even need to call tokenize() again.
*/
int MainWindow::make_statement_ready_to_send(QString text, char *dbms_query, int dbms_query_len, int connection_number)
{
  log("make_statement_ready_to_send start", 80);
  int  *token_offsets;
  int  *token_lengths;
  int desired_count;
  unsigned int i;
  QString q;
  char *tmp;
  int tmp_len;
  //unsigned int token_count;
  desired_count= dbms_query_len + 1;
  token_offsets= new int[desired_count];
  token_lengths= new int[desired_count];
  token_lengths[0]= 0;
  tokenize(text.data(),
           text.size(),
           &token_lengths[0], &token_offsets[0], desired_count - 1,
          (QChar*)"33333", 1, ocelot_delimiter_str, 1);
  dbms_query[0]= '\0';
  for (i= 0; token_lengths[i] != 0; ++i)
  {
    if (ocelot_comments == 0)
    {
      /* TOKEN_TYPE_COMMENT_WITH_SLASH */
      /* or TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE */
      /* or TOKEN_TYPE_COMMENT_WITH_MINUS */
      if ((text.mid(token_offsets[i], 2) == "/*")
       || (text.mid(token_offsets[i], 2) == "--")
       || ((text.mid(token_offsets[i], 1) == "#")
           && (connections_dbms[connection_number] != DBMS_TARANTOOL)))
      {
        if ((text.mid(token_offsets[i], 3) != "/*!")
         && (text.mid(token_offsets[i], 4) != "/*M!"))
        {
          strcat(dbms_query," ");
          continue;
        }
      }
    }
    /* Don't send \G or \g */
    if ((token_lengths[i + 1] == 1)
     && (text.mid(token_offsets[i], 2).toUpper() == "\\G"))
    {
      ++i;
      continue;
    }
    /* Don't send delimiter unless it is ; */
    if ((ocelot_delimiter_str != ";")
     && (text.mid(token_offsets[i], ocelot_delimiter_str.length()) == ocelot_delimiter_str))
    {
      break;
    }
    /* Preserve whitespace after a token, unless this is the last token */
    int token_length;
    if (token_lengths[i + 1] == 0) token_length= token_lengths[i];
    else token_length= token_offsets[i + 1] - token_offsets[i];
    q= text.mid(token_offsets[i], token_length);
    tmp_len= q.toUtf8().size();           /* See comment "UTF8 Conversion" */
    tmp= new char[tmp_len + 1];
    memcpy(tmp, q.toUtf8().constData(), tmp_len);
    tmp[tmp_len]= 0;
    assert(strlen(dbms_query) + strlen(tmp) <= (unsigned int) dbms_query_len);
    strcat(dbms_query, tmp);
    delete [] tmp;
  }
  delete [] token_offsets;
  delete [] token_lengths;
  log("make_statement_ready_to_send end", 80);
  return (strlen(dbms_query));
}

#if (OCELOT_MYSQL_INCLUDE == 1)
/*
  select_1_row() is a convenience routine, made because frequently there are single-row selects.
  And if they are multiple-row selects, we can always do them one-at-a-time with limit and offset clauses.
  Pass: select statement. Return: unexpected_error, expected to be ""
  And up to 5 string variables from the first row that gets selected.
  This should be used only if you know that no fields are null.
*/
QString select_1_row_result_1, select_1_row_result_2, select_1_row_result_3, select_1_row_result_4, select_1_row_result_5;
QString MainWindow::select_1_row(const char *select_statement)
{
  MYSQL_RES *res= NULL;
  MYSQL_ROW row= NULL;
  const char *unexpected_error= NULL;
  QString s;
  unsigned int num_fields;

  if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], select_statement, strlen(select_statement)))
  {
    unexpected_error= "select failed";
  }

  if (unexpected_error == NULL)
  {
    res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
    if (res == NULL)
    {
      unexpected_error= "mysql_store_result failed";
    }
  }

  if (unexpected_error == NULL)
  {
    num_fields= lmysql->ldbms_mysql_num_fields(res);
  }

  if (unexpected_error == NULL)
  {
    row= lmysql->ldbms_mysql_fetch_row(res);
    if (row == NULL)
    {
      unexpected_error= er_strings[er_off + ER_MYSQL_FETCH_ROW_FAILED]; /* Beware! Look for a proc that compares routine with this string value! */
    }
    else
    {
      if (num_fields > 0) select_1_row_result_1= QString::fromUtf8(row[0]);
      if (num_fields > 1) select_1_row_result_2= QString::fromUtf8(row[1]);
      if (num_fields > 2) select_1_row_result_3= QString::fromUtf8(row[2]);
      if (num_fields > 3) select_1_row_result_4= QString::fromUtf8(row[3]);
      if (num_fields > 4) select_1_row_result_5= QString::fromUtf8(row[4]);
    }
  }

  if (res != NULL) lmysql->ldbms_mysql_free_result(res);

  if (unexpected_error != NULL) s= unexpected_error;
  else s= "";
  return s;
}
#endif //if (OCELOT_MYSQL_INCLUDE == 1)

/* volatile ints were here. moved up on 2019-01-01 */

#if (OCELOT_MYSQL_DEBUGGER == 1)

/*
  Debug

  Re debug_top_widget: It's a QWidget which contains a status line and debug_tab_widget.

  Re debug_tab_widget: It's a QTabWidget which may contain more than one debug_widget.

  Re debug_widget: it's derived from CodeEditor just as statement_edit_widget is, and it uses the
  same stylesheet as statement_edit_widget. It starts hidden, but debug|initialize shows it.
  It will contain the text of a procedure which is being debugged.
  Actually debug_widget[] occurs 10 times -- todo: there's no check for overflow.

  Re statements that come via statement_edit_widget: suppose the statement is "$DEB p8;".
  During tokens_to_keywords() we recognize that this is TOKEN_KEYWORD_DEBUG_DEBUG and highlight appropriately.
  During execute_client_statement(), after we check if statement_type == TOKEN_DEBUG_DEBUG_DEBUG and find that
  it's true, there's a call to action_debug_debug() followed by "return 1". When we're in action_debug_debug(),
  we have access to main_tokens so we can say things like "QString s= text.mid(main_token_offsets[i], main_token_lengths[i]);".
*/

/* This means "while debugger is going check status 20 times per second" (50 = 50 milliseconds). */
#define DEBUG_TIMER_INTERVAL 50

#define DEBUGGEE_STATE_0 0
#define DEBUGGEE_STATE_CONNECT_THREAD_STARTED 1
#define DEBUGGEE_STATE_BECOME_DEBUGEE_CONNECTION 2
#define DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP 3
#define DEBUGGEE_STATE_CONNECT_FAILED -1
#define DEBUGGEE_STATE_MYSQL_REAL_QUERY_ERROR -2
#define DEBUGGEE_STATE_MYSQL_STORE_RESULT_ERROR -3
#define DEBUGGEE_STATE_MYSQL_FETCH_ROW_ERROR -4
#define DEBUGGEE_STATE_BECOME_DEBUGGEE_CONNECTION_ERROR -5
#define DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP_ERROR -6
#define DEBUGGEE_STATE_END -7

char debuggee_channel_name[128]= "";
int volatile debuggee_state= DEBUGGEE_STATE_0;
char debuggee_state_error[STRING_LENGTH_512]= "";
char debuggee_information_status_debugger_name[32];
char debuggee_information_status_debugger_version[8];
char debuggee_information_status_timestamp_of_status_message[32];
char debuggee_information_status_number_of_status_message[8];
char debuggee_information_status_icc_count[8];
char debuggee_information_status_schema_identifier[256];
char debuggee_information_status_routine_identifier[256];
char debuggee_information_status_line_number[8];
char debuggee_information_status_is_at_breakpoint[8];
char debuggee_information_status_is_at_tbreakpoint[8];
char debuggee_information_status_is_at_routine_exit[8];
char debuggee_information_status_stack_depth[8];
char debuggee_information_status_last_command[256];
char debuggee_information_status_last_command_result[256];
char debuggee_information_status_commands_count[8];
char debuggee_database[256];

QString debug_routine_schema_name[DEBUG_TAB_WIDGET_MAX + 1];
QString debug_routine_name[DEBUG_TAB_WIDGET_MAX + 1];

QString debug_q_schema_name_in_statement;
QString debug_q_routine_name_in_statement;
QString debug_statement;

QTimer *debug_timer;                                    /* For calling action_debug_timer_status() every 1/10 seconds */
int debug_timer_old_line_number;
char debug_timer_old_schema_identifier[256];
char debug_timer_old_routine_identifier[256];
int volatile debuggee_connection_id;                             /* Save this if you need to kill the debuggee (an unusual need) */
int debug_timer_old_commands_count;
int debug_timer_old_number_of_status_message;
int debug_timer_old_icc_count;
int debug_timer_old_debug_widget_index;



/*
  Enable or disable debug menu items.
  If debug succeeds: most items after debug are enabled. (Todo: eventually all should be enabled.)
  If exit succeeds: most items after debug are disabled.
*/
void MainWindow::debug_menu_enable_or_disable(int statement_type)
{
  bool e;

  if (statement_type == TOKEN_KEYWORD_BEGIN) e= false;
  if (statement_type == TOKEN_KEYWORD_DEBUG_DEBUG) e= true;
  if (statement_type == TOKEN_KEYWORD_DEBUG_EXIT) e= false;

//  menu_debug_action_install->setEnabled(e);
//  menu_debug_action_setup->setEnabled(e);
//  menu_debug_action_debug->setEnabled(e);
  menu_debug_action_breakpoint->setEnabled(e);
  menu_debug_action_continue->setEnabled(e);
//  menu_debug_action_leave->setEnabled(e);
  menu_debug_action_next->setEnabled(e);
//  menu_debug_action_skip->setEnabled(e);
  menu_debug_action_step->setEnabled(e);
  menu_debug_action_clear->setEnabled(e);
//  menu_debug_action_delete->setEnabled(e);
  menu_debug_action_exit->setEnabled(e);                                      /* everything after debug goes gray after this succeeds */
  menu_debug_action_information->setEnabled(e);
  menu_debug_action_refresh_server_variables->setEnabled(e);
  menu_debug_action_refresh_user_variables->setEnabled(e);
  menu_debug_action_refresh_variables->setEnabled(e);
  menu_debug_action_refresh_call_stack->setEnabled(e);
}


void MainWindow::create_widget_debug()
{
  /* We make debug_tab_widget now but we don't expect anyone to see it until debug|setup happens. */
  /* Todo: should you create with an initially-hidden flag? */
  debug_top_widget= new QWidget(this);              /* 2015-08-25 added "this" */
  debug_top_widget->hide();                         /* hidden until debug|initialize is executed */

  /*
    Todo: check: am I doing it right by saying parent = debug_top_widget
    i.e. will automatic delete happen when debug_top_widget is deleted?
    or will there be a memory leak?
    Hmm, why do I care? I don't delete debug_top_widget anyway, do I?
    Hmm Hmm, yes I do but it must be an error.
  */

  debug_line_widget= new QLineEdit(debug_top_widget);
  debug_line_widget->setText("Debugger Status = Inactive");
  debug_tab_widget= new QTabWidget(debug_top_widget);

  debug_top_widget_layout= new QVBoxLayout(debug_top_widget);
  debug_top_widget_layout->addWidget(debug_line_widget);
  debug_top_widget_layout->addWidget(debug_tab_widget);
  debug_top_widget->setLayout(debug_top_widget_layout);

  /* We make debug_timer now but we don't start it until debug status can be shown. */
  debug_timer= new QTimer(this);
  connect(debug_timer, SIGNAL(timeout()), this, SLOT(action_debug_timer_status()));

  /* This must be done before we set statement stylesheet. */
  for (int i= 0; i < DEBUG_TAB_WIDGET_MAX; ++i) debug_widget[i]= 0;

}


//#include <pthread.h>

/*
  The debuggee is a separate thread and makes its own connection using ocelot_ parameters just like the main connection.
  Problem: debuggee_thread() cannot be in MainWindow (at least, I didn't figure out how to make it in MainWindow).
  That explains why I made a lot of things global.
  Todo: Check: Why do you end statements with ";"?
  Todo: If an error occurs, copy the whole thing into a fixed-size char so debugger can see it.
        And notice that the result is that the thread ends, so beware of racing and worry about cleanup.
*/

void* debuggee_thread(void* unused)
{
  (void) unused; /* suppress "unused parameter" warning */
  char call_statement[512];
  int is_connected= 0;
  MYSQL_RES *debug_res= NULL;
  MYSQL_ROW debug_row= NULL;
  const char *unexpected_error= NULL;

  debuggee_connection_id= 0;

  memset(debuggee_state_error, 0, STRING_LENGTH_512);
  debuggee_state= DEBUGGEE_STATE_CONNECT_THREAD_STARTED;

  for (;;)
  {
    /*
      The debuggee connection.
      Todo: the_connect() could easily fail: parameters are changed, # of connections = max, password no longer works, etc.
            ... so you should try to pass back a better explanation if the_connect() fails here.
    */
    if (options_and_connect(MYSQL_DEBUGGER_CONNECTION, debuggee_database))
    {
       debuggee_state= DEBUGGEE_STATE_CONNECT_FAILED;
       strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
       break;
    }
    is_connected= 1;

    /* Get connection_id(). This is only in case regular "exit" fails and we have to issue a kill statement. */
    strcpy(call_statement, "select connection_id();");
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_DEBUGGER_CONNECTION], call_statement, strlen(call_statement)))
    {
      debuggee_state= DEBUGGEE_STATE_MYSQL_REAL_QUERY_ERROR;
      strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
      break;
    }
    debug_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_DEBUGGER_CONNECTION]);
    if (debug_res == NULL)
    {
      debuggee_state= DEBUGGEE_STATE_MYSQL_STORE_RESULT_ERROR;
      strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
      break;
    }
    debug_row= lmysql->ldbms_mysql_fetch_row(debug_res);
    if (debug_row == NULL)
    {
      debuggee_state= DEBUGGEE_STATE_MYSQL_FETCH_ROW_ERROR;
      strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
      lmysql->ldbms_mysql_free_result(debug_res);
      break;
    }
    debuggee_connection_id= atoi(debug_row[0]);
    lmysql->ldbms_mysql_free_result(debug_res);

    strcpy(call_statement, "call xxxmdbug.become_debuggee_connection('");
    strcat(call_statement, debuggee_channel_name);
    strcat(call_statement, "');");
    debuggee_state= DEBUGGEE_STATE_BECOME_DEBUGEE_CONNECTION;
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_DEBUGGER_CONNECTION], call_statement, strlen(call_statement)))
    {
      debuggee_state= DEBUGGEE_STATE_BECOME_DEBUGGEE_CONNECTION_ERROR;
      strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
      break;
    }
    /*
      Originally we just had debuggee_wait_loop here.
      Then the PREPARE+EXECUTE failed because of a procedure that contained a SELECT.
      So I replaced debuggee_wait_loop()'s PREPARE with "LEAVE".
      The actual execution will be done here in C.
      Todo: Replace all debuggee_wait_loop() with a C routine.
      Todo: Catch errors -- debuggee_wait_loop() didn't necessarily end via LEAVE x.
    */
    strcpy(call_statement, "call xxxmdbug.debuggee_wait_loop();");
    debuggee_state= DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP;
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_DEBUGGER_CONNECTION], call_statement, strlen(call_statement)))
    {
      debuggee_state= DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP_ERROR;
      strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
      break;
    }
    {
      char xxxmdbug_status_last_command_result[512];
      if (lmysql->ldbms_mysql_query(&mysql[MYSQL_DEBUGGER_CONNECTION], "select @xxxmdbug_status_last_command_result"))
      {
        /* This can happen, for example if debug command failed. */
        debuggee_state= DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP_ERROR;
        unexpected_error=" select @xxxmdbug_status_last_command_result failed";
        strcpy(debuggee_state_error, "no result from last command");
        break;
      }
      debug_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_DEBUGGER_CONNECTION]);
      if (debug_res == NULL)
      {
        unexpected_error= "mysql_store_result failed";
      }
      if (lmysql->ldbms_mysql_num_fields(debug_res) != 1)
      {
        unexpected_error= "wrong field count";
        lmysql->ldbms_mysql_free_result(debug_res);
        break;
      }
      debug_row= lmysql->ldbms_mysql_fetch_row(debug_res);
      if (debug_row == NULL)
      {
        unexpected_error= "mysql_fetch_row failed";
        lmysql->ldbms_mysql_free_result(debug_res);
       break;
      }
      strcpy(xxxmdbug_status_last_command_result, debug_row[0]);
      lmysql->ldbms_mysql_free_result(debug_res);
      /* There are various errors that xxxmdbug.check_surrogate_routine could have returned. */
      if ((strstr(xxxmdbug_status_last_command_result,"Error reading setup log") != 0)
       || (strstr(xxxmdbug_status_last_command_result,"is incorrect format for a surrogate identifier") != 0)
       || (strstr(xxxmdbug_status_last_command_result,"is not found once in xxxmdbug.setup_log") != 0)
       || (strstr(xxxmdbug_status_last_command_result,"was set up with an older debugger version") != 0)
       || (strstr(xxxmdbug_status_last_command_result,"original was not found") != 0)
       || (strstr(xxxmdbug_status_last_command_result,"original was altered") != 0)
       || (strstr(xxxmdbug_status_last_command_result,"surrogate was not found") != 0))
      {
        debuggee_state= DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP_ERROR;
        strncpy(debuggee_state_error, xxxmdbug_status_last_command_result, STRING_LENGTH_512 - 1);
        break;
      }
    }
    if (lmysql->ldbms_mysql_query(&mysql[MYSQL_DEBUGGER_CONNECTION], "select @xxxmdbug_what_to_call"))
    {
      unexpected_error=" select @xxxmdbug_what_to_call failed";
      break;
    }
    debug_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_DEBUGGER_CONNECTION]);
    if (debug_res == NULL)
    {
      unexpected_error= "mysql_store_result failed";
    }
    if (lmysql->ldbms_mysql_num_fields(debug_res) != 1)
    {
      unexpected_error= "wrong field count";
      lmysql->ldbms_mysql_free_result(debug_res);
      break;
    }
    debug_row= lmysql->ldbms_mysql_fetch_row(debug_res);
    if (debug_row == NULL)
    {
      unexpected_error= "mysql_fetch_row failed";
      lmysql->ldbms_mysql_free_result(debug_res);
      break;
    }
    strcpy(call_statement, debug_row[0]);
    lmysql->ldbms_mysql_free_result(debug_res);
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_DEBUGGER_CONNECTION], call_statement, strlen(call_statement)))
    {
      debuggee_state= DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP_ERROR;
      strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
    }
    else
    {
        /*
          Following is pretty much the same as for MYSQL_MAIN_CONNECTION.
          We're just throwing result sets away. NB: the statement has not
          really ended -- when there's a result set MySQL temporarily drops
          out of the procedure, and resumes during each iteration of this loop.
          Todo: we can put each result into the result grid widget as it comes;
          we'll have to decide whether the debugger should do it, or the main.
        */
        if (lmysql->ldbms_mysql_more_results(&mysql[MYSQL_DEBUGGER_CONNECTION]))
        {
          debug_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_DEBUGGER_CONNECTION]);
          if (debug_res != 0)
          {
            lmysql->ldbms_mysql_free_result(debug_res);

            if (lmysql->ldbms_mysql_more_results(&mysql[MYSQL_DEBUGGER_CONNECTION]))
            {
              while (lmysql->ldbms_mysql_next_result(&mysql[MYSQL_DEBUGGER_CONNECTION]) == 0)
              {
                debug_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_DEBUGGER_CONNECTION]);
                if (debug_res != 0) lmysql->ldbms_mysql_free_result(debug_res);
              }
              debug_res= 0;
            }
          }
        }
      debuggee_state= DEBUGGEE_STATE_END;
    }
    break;
  }

  /* Todo: Even after failure, get rid of result sets. But, oddly, lmysql->ldbms_mysql_next_result() never returns anything. */
  /* This just would throw any results away, which is what happens also with MYSQL_MAIN_CONNECTION. */
  /* What I'd have liked to do is: have the main connection put the result set up on the main screen. */
  //while (lmysql->ldbms_mysql_next_result(&mysql[MYSQL_DEBUGGER_CONNECTION]) == 0) ;
  //if (lmysql->ldbms_mysql_more_results(&mysql[MYSQL_DEBUGGER_CONNECTION]))
  //{
  //  while (lmysql->ldbms_mysql_next_result(&mysql[MYSQL_DEBUGGER_CONNECTION]) == 0)
  //  {
  //    debug_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_DEBUGGER_CONNECTION]);
  //    if (debug_res != 0) lmysql->ldbms_mysql_free_result(debug_res);
  //  }
  //  debug_res= 0;
  //}
  if (unexpected_error != NULL)
  {
    strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
  }
  /* Cleanup */
  /* Shut the connection, which seems to cause disconnect automatically. */
  if (is_connected == 1) lmysql->ldbms_mysql_close(&mysql[MYSQL_DEBUGGER_CONNECTION]);

  /* Typically we'll reach this point with last_command_result = "debuggee_wait_loop() termination" */

  /* Here I am overwriting DEBUGGEE_WAIT_LOOP_ERROR / DEBUGGEE_STATE_END. Maybe they're informative but they caused trouble. */
  //debuggee_state= DEBUGGEE_STATE_0;
  /* options_and_connect called mysql_init which called mysql_thread_init, so cancel it */
  lmysql->ldbms_mysql_thread_end();
  /* The thread will end. */
  return ((void*) NULL);
}


/*
  Debug|Install -- install the debugger routines and tables in xxxmdbug.
  The actual CREATE statements are all xxxmdbug_install_sql in
  a separate file, install_sql.cpp, so that it's clear what the HP-licence part is.
  debug|install menu item is commented out, one must say $INSTALL
  Todo: decide what to do if it's already installed.
  Todo: privilege check
  Todo: what we really should be doing: passing the original command, in all cases.
*/
//void MainWindow::action_debug_install()
//{
//  statement_edit_widget->setPlainText("$INSTALL");
//  action_execute(1);
//}

void MainWindow::debug_install_go()
{
  char x[32768];
  char command_string[2048];
  QString qstring_error_message;

  if (debug_error((char*)"") != 0) return;

  if ((statement_edit_widget->dbms_version.mid(1,1) == ".")
  &&  (statement_edit_widget->dbms_version < "5.5"))
  {
    strcpy(command_string, er_strings[er_off + ER_DEBUGGER_REQUIRES]);
    if (debug_error(command_string) != 0) return;
  }

  qstring_error_message= debug_privilege_check(TOKEN_KEYWORD_DEBUG_INSTALL);
  if (qstring_error_message != "")
  {
    strcpy(command_string, qstring_error_message.toUtf8());
    if (debug_error(command_string) != 0) return; /* setup wouldn't be able to operate so fail */
  }

  if (debug_mdbug_install_sql(&mysql[MYSQL_MAIN_CONNECTION], x) < 0)
  {
      put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
      return;
    //if (debug_error((char*)"Install failed") != 0) return;
  }
  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
}

/* For copyright and license notice of debug_mdbug_install function contents, see beginning of this program. */
void debug_mdbug_install()
{
  ;
}
/* End of debug_mdbug_install. End of effect of licence of debug_mdbug_install_function contents. */


/*
  Debug|Setup
  Format =  $setup [options] object-name-list;
  debug|setup menu item is removed, one must say $SETUP ...

  Todo: This should put up a list box with the routines which the user can execute. No hard coding of test.p8 and test.p9.
        Or, it should look in the log for the last setup by this user, and re-do it.
  Todo: Shortcut = Same as last time.
  Todo: Search for schema name not just routine name.
  Todo: $setup does a GET_LOCK() so that two users won't do $setup at
        the same time. Figure out a better way.
  Todo: Check that 'install' has happened -- but for now it's OK, at least we return some sort of error.

  May 2018: $setup had to be totally rewritten, because it wouldn't work
  with MySQL 8.0. For explanation read
  https://ocelot.ca/blog/blog/2017/08/22/no-more-mysql-proc-in-mysql-8-0
  So the old unused code in install_sql.cpp still exists, and if we say
  #define NEW_SETUP 0 then it will still be invoked for test purposes,
  but now $setup code is entirely in ocelotgui.cpp (and incidentally
  is entirely written by Peter Gulutzan, only the old
  code in install_sql.cpp was written for HP).
*/
#define NEW_SETUP 1

#if (NEW_SETUP == 0)
void MainWindow::debug_setup_go(QString text)
{
  if (hparse_dbms_mask & FLAG_VERSION_MYSQL_8_0)
  {
    QMessageBox msgbox;
     QString s= "Sorry, the ocelotgui debugger won't work with MySQL 8.0. ";
     s.append("For explanation read https://ocelot.ca/blog/blog/2017/08/22/no-more-mysql-proc-in-mysql-8-0/");
     s.append("We have replacement code that we believe will work -- ");
     s.append("try rebuilding ocelotgui after changing the line saying ");
     s.append("#define NEW_SETUP 0 to #define NEW_SETUP 1.");
     msgbox.setText(s);
     msgbox.exec();
     return;
  }
  char command_string[512];
  int index_of_number_1, index_of_number_2;
  QString qstring_error_message;
  QString q_routine_schema, q_routine_name;

  /* Todo: Check that 'install' has happened -- but for now it's OK, at least we return some sort of error. */
  /* Todo: use debug_error instead, provided debug_error gets rid of any problematic ''s */
  qstring_error_message= debug_privilege_check(TOKEN_KEYWORD_DEBUG_SETUP);
  if (qstring_error_message != "")
  {
    strcpy(command_string, qstring_error_message.toUtf8());
    if (debug_error(command_string) != 0) return; /* setup wouldn't be able to operate so fail */
  }
  if (debug_parse_statement(text, command_string, &index_of_number_1, &index_of_number_2) < 0)
  {
    if (debug_error(command_string) != 0) return;
  }

  q_routine_schema= debug_q_schema_name_in_statement;
  q_routine_name= debug_q_routine_name_in_statement;
  if ((q_routine_schema == "") || (q_routine_name == ""))
  {
    if (debug_error((char*)er_strings[er_off + ER_MISSING_ROUTINE_NAMES]) != 0) return;
  }
  /* Todo: since yes there is a bug, but we want to get this out, just release the lock instead of doing the right thing. */
  {
    QString result_string= select_1_row("SELECT is_free_lock('xxxmdbug_lock')");
    if (select_1_row_result_1.toInt() != 0)
    {
      //if (debug_error((char*)"Another user has done $setup and caused a lock. This might be an ocelotgui bug.") != 0) return;
      result_string= select_1_row("SELECT release_lock('xxxmdbug_lock')");
    }
  }

  /* Throw away the first word i.e. "$setup" and execute "call xxxmdbug.setup('...')". */
  char call_statement[512 + 128];
  strcpy(call_statement, "call xxxmdbug.setup('");
  strcat(call_statement, strstr(command_string, " ") + 1);
  strcat(call_statement, "')");

  if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement)))
  {
    put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
    return;
    //if (debug_error((char*)"call xxxmdbug.setup() failed.") != 0) return;
  }
  debug_setup_mysql_proc_insert();
}
#endif


/*
  The following routine replaces the procedures xxxmdbug.mysql_proc_insert()
  and xxxmdbug.mysql_proc_insert_caller() in install_sql.cpp, which are no
  longer called from xxxmdbug.setup(). The effect is the same,
  but there is no INSERT into a mysql-database table.
  Also: definition_of_surrogate_routine will have three statements: DROP IF EXISTS, SET, CREATE.
        I could execute them all at once, but prefer to separate. Assume original name didn't contain ;.
        ... For icc_core routines the SET statement might be missing, I don't know why.
*/
/* TODO: THIS IS NO GOOD! YOU DO NOT WANT TO INSERT INTO MYSQL.PROC! */
void MainWindow::debug_setup_mysql_proc_insert()
{
  log("debug_setup_mysql_proc_insert start", 90);
  char command[512];
  MYSQL_RES *res= NULL;
  MYSQL_ROW row= NULL;
  const char *unexpected_error= NULL;
  unsigned int num_fields;
  unsigned int num_rows;
  QString definition_of_surrogate_routine;
  int it_is_ok_if_proc_is_already_there;
  QString list_of_drop_statements= "";

  lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "select * from xxxmdbug.routines");
  res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
  if (res != NULL)
  {
    num_rows= lmysql->ldbms_mysql_num_rows(res);
    lmysql->ldbms_mysql_free_result(res);
    res= NULL;
    if (num_rows - 3 >= DEBUG_TAB_WIDGET_MAX)
    {
      sprintf(command, er_strings[er_off + ER_SETUP], num_rows - 3, DEBUG_TAB_WIDGET_MAX - 1);
      put_message_in_result(command);
      return;
    }
  }
  lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "SET @xxxmdbug_saved_sql_mode=@@sql_mode");
  /*
    Go through all the rows of mysql.proc, doing DROP IF EXISTS and CREATE.
    If a create fails, we will later have a cleanup which should drop what we created.
  */
  int index_of_semicolon, index_of_set, index_of_create;
  QString first_query, second_query, third_query;
  //int second_iteration_is_necessary= 0;
  res= NULL;
  //for (int iteration=0; iteration <= 1; ++iteration)
  {
    //if ((iteration == 1) && (second_iteration_is_necessary == 0))
    //{
    //  break;
    //}
    if (res != NULL)
    {
      lmysql->ldbms_mysql_free_result(res);
      res= NULL;
    }
    row= NULL;

    strcpy(command,
    "SELECT TRIM(BOTH '`' FROM schema_identifier_of_original),"
    "       TRIM(BOTH '`' FROM routine_identifier_of_original),"
    "       TRIM(BOTH '`' FROM routine_identifier_of_surrogate),"
    "       definition_of_surrogate_routine,"
    "       offset_of_begin "
    "FROM xxxmdbug.routines");

    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], command, strlen(command)))
    {
      unexpected_error= "select failed";
    }
    if (unexpected_error == NULL)
    {
      res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
      if (res == NULL) unexpected_error= "mysql_store_result failed";
    }
    if (unexpected_error == NULL)
    {
      num_fields= lmysql->ldbms_mysql_num_fields(res);
      if (num_fields != 5) unexpected_error= "wrong field count";
    }

    if (unexpected_error == NULL)
    {
      MYSQL_RES *res_2= NULL;
      for (;;)
      {
        row= lmysql->ldbms_mysql_fetch_row(res);
        if (row == NULL) break;
        it_is_ok_if_proc_is_already_there= 0;
        /* todo: make sure row[2] i.e. routine_identifier_of_surrogate is not null */
        if ((strcmp(row[2], "icc_process_user_command_r_server_variables") == 0)
         || (strcmp(row[2], "icc_process_user_command_set_server_variables") == 0))
        {
          /* We will not insert icc_process_user_command_r_server_variables
             or icc_process_user_command_set_server_variables into mysql.proc
             if it already exists. This is okay as long as there is no change of
             DBMS server version or engine or plugin. But recommend always:
             DROP PROCEDURE xxxmdbug.icc_process_user_command_r_server_variables; */
          it_is_ok_if_proc_is_already_there= 1;
        }
        else
        {
          /* MDBug might not care if the routine definition was blank, but we do. */
          char tmp[512];
          MYSQL_ROW row_2= NULL;
          unsigned int num_rows_2= 0;
          strcpy(tmp, "select routine_definition from information_schema.routines where routine_schema='");
          strcat(tmp, row[0]);
          strcat(tmp, "' and routine_name='");
          strcat(tmp, row[1]);
          strcat(tmp, "'");
          if (lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], tmp)) num_rows_2= 0;
          else
          {
            res_2= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
            if (res_2 != NULL)
            {
              num_rows_2= lmysql->ldbms_mysql_num_rows(res_2);
            }
          }
          if (num_rows_2 == 1)
          {
            row_2= lmysql->ldbms_mysql_fetch_row(res_2);
            if ((row_2 == NULL) || (row_2[0] == NULL) || (strcmp(row_2[0],"") == 0))
            {
              lmysql->ldbms_mysql_free_result(res_2);
              res_2= NULL;
              /* ""Could not get a routine definition for %s.%s" ... */
              sprintf(tmp, er_strings[er_off + ER_COULD_NOT_GET], row[0], row[1]);
              /* Todo: merge this sort of stuff into debug_error() */
              unexpected_error= "create failed";
              put_message_in_result(tmp);
              //second_iteration_is_necessary= 1;
              break;
            }
          }
          if (res_2 != NULL)
          {
            lmysql->ldbms_mysql_free_result(res_2);
            res_2= NULL;
          }
        }
        definition_of_surrogate_routine= QString::fromUtf8(row[3]);
        index_of_semicolon= definition_of_surrogate_routine.indexOf(";");
        index_of_set= definition_of_surrogate_routine.indexOf("SET session sql_mode = '", index_of_semicolon);
        if (index_of_set == -1) index_of_create= definition_of_surrogate_routine.indexOf("CREATE ", index_of_semicolon);
        else index_of_create= definition_of_surrogate_routine.indexOf("CREATE ", index_of_set);
        if (index_of_create == -1) unexpected_error= "bad definition_of_surrogate_routine";
        if (unexpected_error == NULL)
        {
          if (index_of_set == -1) first_query= definition_of_surrogate_routine.mid(0, index_of_create - 1);
          else first_query= definition_of_surrogate_routine.mid(0, index_of_set - 1);
          if (index_of_set != -1) second_query= definition_of_surrogate_routine.mid(index_of_set, index_of_create - index_of_set);
          third_query= definition_of_surrogate_routine.mid(index_of_create, -1);
          if (it_is_ok_if_proc_is_already_there == 0)
          {
            if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], first_query.toUtf8(), strlen(first_query.toUtf8())))
            {
              /* Actually, a failed drop will have to be considered to be okay. */
            }
          }
          if ((unexpected_error == NULL) && (index_of_set != -1))
          {
            if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], second_query.toUtf8(), strlen(second_query.toUtf8())))
            {
              unexpected_error= "set failed";
              break;
            }
          }
          if (unexpected_error == NULL)
          {
            //if (iteration == 0)
            {
              /* Kludge. If we have DEFINER=@ we have to change to DEFINER=''@''. */
              {
                int i;
                i= third_query.indexOf("DEFINER=@");
                if (i > 0)
                {
                  third_query.insert(i + 8, "''");
                }
                i=third_query.indexOf("@ PROCEDURE `");
                if (i < 0) i=third_query.indexOf("@ FUNCTION `");
                if (i < 0) i=third_query.indexOf("@ TRIGGER `");
                if (i > 0)
                {
                  third_query.insert(i + 1, "''");
                }
              }
              if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], third_query.toUtf8(), strlen(third_query.toUtf8())))
              {
                /* If there's an error, the diagnostics here should go all the way back up to the user. */
                if (it_is_ok_if_proc_is_already_there == 0)
                {
                  unexpected_error= "create failed";
                  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
                  //second_iteration_is_necessary= 1;
                  if (res != NULL)
                  {
                    lmysql->ldbms_mysql_free_result(res);
                    res= NULL;
                  }
                  break;
                }
              }
              list_of_drop_statements.append(first_query);
            }
          }
        }
      }
      if (res != NULL)
      {
        lmysql->ldbms_mysql_free_result(res);
        res= NULL;
      }
      if (res_2 != NULL)
      {
        lmysql->ldbms_mysql_free_result(res_2);
        res_2= NULL;
      }
    }
    if (res != NULL)
    {
      lmysql->ldbms_mysql_free_result(res);
      res= NULL;
    }
  }
  if (res != NULL)
  {
    lmysql->ldbms_mysql_free_result(res);
    res= NULL;
  }

  log("debug_setup_mysql_proc_insert end", 90);
  lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "set session sql_mode=@xxxmdbug_saved_sql_mode");

  if (unexpected_error != NULL)
  {
    while (list_of_drop_statements > " ")
    {
      int i= list_of_drop_statements.indexOf(";") + 1;
      if (i <= 0) break;
      QString first_query= list_of_drop_statements.left(i);
      if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], first_query.toUtf8(), strlen(first_query.toUtf8())))
      {
        ; /* create failed, cleanup failed, but what can I do? */
      }
      list_of_drop_statements= list_of_drop_statements.right(list_of_drop_statements.size() - i);
    }
    if (strcmp(unexpected_error, "create failed") ==0) return; /* we already have the diagnostics */
    put_message_in_result(unexpected_error);
    return;
  }
  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
}


/*
  debug_privilege_check() -- check in advance whether some debuggee-related privileges exist
  It will be more convenient if the user is told in advance, and is told multiple problems at once.
  Of course I could search for the grants, but it's easier to try it and see what happens.
  However, this doesn't consider all possibilities and is only called before initializing.
  To see if you have execute privilege, see if you can select from information_schema.routines, rather than execute.
  A variant of that would be selecting where routine_definition > '' if you want to look for all privileges.
  As well as the checks here, $setup also needs routine_definition > '' i.e. you must be routine creator
  or you must have select privilege on mysql.proc.
  Todo: check other possible things that the debuggee could do, and check all routines not just xxxmdbug.command.
        one way would be to say 'command' OR 'other_routine' ... but putting into a loop would be better, I think.
  Todo: xxxmdbug.command calls xxxmdbug.privilege_checks which will generate a signal,
        but I'm wondering whether it's good because it sends messages using init_connect every time.
  statement_type = TOKEN_KEYWORD_DEBUG_DEBUG or TOKEN_KEYWORD_DEBUG_SETUP or TOKEN_KEYWORD_DEBUG_INSTALL.
*/
QString MainWindow::debug_privilege_check(int statement_type)
{
  QString s= "";
  char call_statement[512];
  unsigned int num_rows;
  MYSQL_RES *res;
  QString result_string;

  if (connections_is_connected[0] != 1)
  {
    s.append("Not connected");
    return s;
  }

  if (statement_type == TOKEN_KEYWORD_DEBUG_INSTALL)
  {
    /* Somebody has to have said: grant create, drop, create routine, alter routine, select, insert, update, delete, select on xxxmdbug.* ... */
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "create database xxxmdbug");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need create privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "drop table if exists xxxmdbug.xxxmdbug");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "create table xxxmdbug.xxxmdbug (s1 int)");
    if ((s == "") && (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142)) s.append("Need create privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'select * from xxxmdbug.xxxmdbug'");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need select privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'insert into xxxmdbug.xxxmdbug values (1)'");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need insert privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'delete from xxxmdbug.xxxmdbug'");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need delete privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'update xxxmdbug.xxxmdbug set s1 = 1'");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need update privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "drop table xxxmdbug.xxxmdbug");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need drop privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "drop procedure if exists xxxmdbug.xxxmdbug");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "create procedure xxxmdbug.xxxmdbug () set @a = 1");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need create routine privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "drop procedure xxxmdbug.xxxmdbug");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1370) s.append("Need alter routine privilege on xxxmdbug.*. ");
    return s;
  }

  /* First make sure xxxmdbug exists */
  num_rows= 0;
  if (lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "select * from information_schema.schemata where schema_name = 'xxxmdbug'"))
  {
    s.append("Cannot select from information_schema");
    return s;
  }
  res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
  if (res != NULL)
  {
    num_rows= lmysql->ldbms_mysql_num_rows(res);
    lmysql->ldbms_mysql_free_result(res);
  }
  if (num_rows != 1)
  {
    s.append("Cannot access database xxxmdbug. Check that $install was done and privileges were granted.");
    return s;
  }

  if ((statement_type == TOKEN_KEYWORD_DEBUG_DEBUG) || (statement_type == TOKEN_KEYWORD_DEBUG_SETUP))
  {
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'select * from xxxmdbug.readme union all select * from xxxmdbug.copyright'");/* Returns 1142 if SELECT denied */
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need select privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'create temporary table xxxmdbug.xxxmdbug_tmp (s1 int)'");/* Returns 1044 if CREATE TEMPORARY denied */
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need create temporary privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
  }

  if (statement_type == TOKEN_KEYWORD_DEBUG_DEBUG)
  {
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'set global init_connect = @@init_connect'");/* Returns 1227 if you need SUPER */
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1227) s.append("Need super privilege. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'call xxxmdbug.command()'");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need execute privilege on xxxmdbug.command. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
  }

  if (statement_type == TOKEN_KEYWORD_DEBUG_SETUP)
  {
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare stmt1 from 'select * from mysql.proc'");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need select privilege on mysql.proc. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");

    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'create table xxxmdbug.xxxmdbug_nontmp (s1 int)'");/* Returns 1044 if CREATE TEMPORARY denied */
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need create privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");

    /* Can't prepare create-routine statements so test by actually creating and dropping a trivial for-test-only routine */
    sprintf(call_statement, "create procedure xxxmdbug.xxxmdbugp () set @a=@a");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement);
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need create routine privilege on xxxmdbug.*. ");
    else
    {
      sprintf(call_statement, "drop procedure xxxmdbug.xxxmdbugp");
      lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement);
      if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need drop routine privilege on xxxmdbug.*. ");
    }
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'call xxxmdbug.setup()'");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need execute privilege on xxxmdbug.setup. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");

    result_string= select_1_row("select count(*) from information_schema.tables where table_schema = 'xxxmdbug' and table_name = 'setup_log'" );
    if (result_string != "") s.append(result_string);
    else if (select_1_row_result_1.toInt() != 0)
    {
      lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'select * from xxxmdbug.setup_log'");
      if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need select privilege on xxxmdbug.setup_log. ");
      lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
      lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'insert into setup_log select * from xxxmdbug.setup_log'");
      if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need insert privilege on xxxmdbug.setup_log. ");
      lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
      /* Todo: Find out why repair table is sometimes necessary. I know it can get corrupted but don't yet know why. */
      if (lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "repair table xxxmdbug.setup_log"))
      {
        s.append("Repair Table xxxmdbug.setup_log failed");
      }
      else
      {
        res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
        if (res != NULL) lmysql->ldbms_mysql_free_result(res);
      }
    }
  }

  /* TODO: Following isn't good. */

  result_string= select_1_row("select count(*) from information_schema.routines where routine_schema = 'xxxmdbug' and routine_name = 'command'" );
  if (result_string != "") s.append(result_string);
  else if (select_1_row_result_1.toInt() == 0) s.append("Need execute privilege for xxxmdbug.*. ");
  return s;
}


/*
  Called from: debug_debug_go(), debug_breakpoint_or_clear_go(), or other debug_ routines that might contain arguments.
  An SQL statement may contain comments, plus semicolon and/or delimiter, which should be stripped before passing to xxxmdbug.
  Also these procedures need to know: which tokens (if any) are for schema, routine, start line number, end line number.
  For example from "$DEBUG x.y -- comment;", we want to produce "debug x.y" and the offsets of x and y.
  Possible are: breakpoint/tbreakpoint location information [condition information]
                clear [schema_identifier[.routine_identifier]] line_number_minimum [-line_number_maximum]
                debug [schema_identifier[.routine_identifier]
                delete breakpoint number
  This does not detect syntax errors, we assume xxxmdbug.command() will return an error immediately for a syntax error.
  So it's not really a parse, but should find the tokens that matter.
  (Of course, hparse code is called by default, so parsing will happen.)
  Todo: see if confusion happens if there's condition information, or parameters enclosed inside ''s.
  If there is clearly an error, debug_parse_statement() returns -1 and command_string has an error message.
  We pass text, but we tokenized, so we have main_token_* tables and
  main_token_number and main_token_count_in_statement.
*/
int MainWindow::debug_parse_statement(QString text,
                           char *command_string,
                           int *index_of_number_1,
                           int *index_of_number_2)
{
  char token[512];
  int i, s_len;
  int token_type;
  QString s;
//  int index_of_dot= -1;
//  int index_of_minus= -1;
  int statement_type= 0;
  //bool left_parenthesis_seen= false;
  bool name_is_expected= false; /* true if syntax demands [schema_name.]routine_name at this point */
  char default_schema_name[512];

  strcpy(default_schema_name, "");
  debug_q_schema_name_in_statement="";
  debug_q_routine_name_in_statement="";
  *index_of_number_1= -1;
  *index_of_number_2= -1;
  strcpy(command_string, "");
  int last_token= main_token_number + main_token_count_in_statement;
  for (i= main_token_number;
       ((main_token_lengths[i] != 0) && (i < last_token));
       ++i)
  {
    token_type= main_token_types[i];
    if ((token_type == TOKEN_TYPE_COMMENT_WITH_SLASH)
     || (token_type == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
     || (token_type == TOKEN_TYPE_COMMENT_WITH_MINUS)) continue;
    s= text.mid(main_token_offsets[i], main_token_lengths[i]);

    if ((token_type >= TOKEN_KEYWORD_DEBUG_BREAKPOINT)
     && (token_type <= TOKEN_KEYWORD_DEBUG_TBREAKPOINT)
     && (strcmp(command_string, "") == 0))
    {
      /* We're at the first word, which is the statement type. Write it in full. */
      statement_type= token_type;
      if (token_type == TOKEN_KEYWORD_DEBUG_BREAKPOINT) { strcpy(command_string, "breakpoint"); name_is_expected= true; }
      if (token_type == TOKEN_KEYWORD_DEBUG_CLEAR) { strcpy(command_string, "clear"); name_is_expected= true; }
      if (token_type == TOKEN_KEYWORD_DEBUG_CONTINUE) strcpy(command_string, "continue");
      if (token_type == TOKEN_KEYWORD_DEBUG_DEBUG) { strcpy(command_string, "debug"); name_is_expected= true; }
      if (token_type == TOKEN_KEYWORD_DEBUG_DELETE) strcpy(command_string, "delete");
      if (token_type == TOKEN_KEYWORD_DEBUG_EXECUTE) strcpy(command_string, "execute");
      if (token_type == TOKEN_KEYWORD_DEBUG_EXIT) strcpy(command_string, "exit");
      if (token_type == TOKEN_KEYWORD_DEBUG_INFORMATION) strcpy(command_string, "information");
      if (token_type == TOKEN_KEYWORD_DEBUG_INSTALL) strcpy(command_string, "install");
      if (token_type == TOKEN_KEYWORD_DEBUG_LEAVE) strcpy(command_string, "leave");
      if (token_type == TOKEN_KEYWORD_DEBUG_NEXT) strcpy(command_string, "next");
      if (token_type == TOKEN_KEYWORD_DEBUG_REFRESH) strcpy(command_string, "refresh");
      if (token_type == TOKEN_KEYWORD_DEBUG_SET) strcpy(command_string, "set");
      if (token_type == TOKEN_KEYWORD_DEBUG_SETUP) { strcpy(command_string, "setup"); name_is_expected= true; }
      if (token_type == TOKEN_KEYWORD_DEBUG_SKIP) strcpy(command_string, "skip");
      if (token_type == TOKEN_KEYWORD_DEBUG_SOURCE) strcpy(command_string, "source");
      if (token_type == TOKEN_KEYWORD_DEBUG_STEP) strcpy(command_string, "step");
      if (token_type == TOKEN_KEYWORD_DEBUG_TBREAKPOINT) { strcpy(command_string, "tbreakpoint"); name_is_expected= true; }
      continue;
    }

    s= text.mid(main_token_offsets[i], main_token_lengths[i]);
    s_len= s.toUtf8().size(); /* See comment "UTF8 Conversion" */
    if (s_len + 1 >= 512) { strcpy(command_string, "overflow"); return -1; }
    memcpy(token, s.toUtf8().constData(), s_len);
    token[s_len]= 0;
    if (token[0] == ';') continue;
    if (s == ocelot_delimiter_str) continue;
//    if (token[0] == '.') index_of_dot= i;
//    if (token[0] == '-') index_of_minus= i;
//    if (token[0] == '(') left_parenthesis_seen= true;
    if (name_is_expected)
    {
      if ((token_type == TOKEN_TYPE_OTHER)
       || (token_type == TOKEN_TYPE_IDENTIFIER)
       || (token_type == TOKEN_TYPE_IDENTIFIER_WITH_DOUBLE_QUOTE)
       || (token_type == TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK))
      {
        /* It's possibly a routine name, and we're expecting a routine name. */
        char tmp_schema_name[512];
        char tmp_routine_name[512];
        int s2_len;
        QString s2;
        if (text.mid(main_token_offsets[i + 1], 1) == ".")
        {
          /* schema-name . routine_name */
          if ((main_token_types[i + 2] == TOKEN_TYPE_OTHER)
           || (main_token_types[i + 2] == TOKEN_TYPE_IDENTIFIER)
           || (token_type == TOKEN_TYPE_IDENTIFIER_WITH_DOUBLE_QUOTE)
           || (main_token_types[i + 2] == TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK))
          {
            strcpy(tmp_schema_name, token);
            s2= text.mid(main_token_offsets[i + 2], main_token_lengths[i + 2]);
            s2_len= s2.toUtf8().size(); /* See comment "UTF8 Conversion" */
            if (s2_len + 1 + s_len + 1 >= 512) { strcpy(command_string, "overflow"); return -1; }
            memcpy(tmp_routine_name, s2.toUtf8().constData(), s2_len);
            tmp_routine_name[s2_len]= 0;
            i+= 2;
          }
          else
          {
            strcpy(command_string, "Expected routine-name after .");
            return -1;
          }
        }
        else
        {
          /* Just routine name. Fill in [default schema name]. Todo: shouldn't require a server request so frequently. */
          if (strcmp(default_schema_name, "") == 0)
          {
            QString result_string;
            select_1_row_result_1= "";
            result_string= select_1_row("select database()");
            if (result_string != "") { strcpy(command_string, "Need to know default database but select database() failed"); return -1; }
            if (select_1_row_result_1== "") { strcpy(command_string, "Need to know default database but select database() returned nothing"); return -1; }
            s2= select_1_row_result_1;
            s2_len= s2.toUtf8().size();
            if (s2_len + 1 + s_len + 1 >= 512) { strcpy(command_string, "overflow"); return -1; }
            memcpy(default_schema_name, s2.toUtf8().constData(), s2_len);
            default_schema_name[s2_len]= 0;
          }
          strcpy(tmp_routine_name, token);
          strcpy(tmp_schema_name, default_schema_name);
        }
        name_is_expected= false;

        QString aa= tmp_schema_name;
        aa= connect_stripper(aa, true);
        strcpy(tmp_schema_name, aa.toUtf8());
        aa= tmp_routine_name;
        aa= connect_stripper(aa, true);
        strcpy(tmp_routine_name, aa.toUtf8());

        strcpy(token, tmp_schema_name);
        strcat(token, ".");
        strcat(token, tmp_routine_name);

        {
          QString result_string;
          char query_for_select_check[1280];
          sprintf(query_for_select_check, "select count(*) from information_schema.routines where routine_schema='%s' and routine_name='%s'", tmp_schema_name, tmp_routine_name);
          result_string= select_1_row(query_for_select_check);
          if (result_string != "") { strcpy(command_string, "Tried to check routine name but select from information_schema.routines failed"); return -1; }
          if (select_1_row_result_1.toInt() == 0)
          {
            sprintf(command_string, "Could not find routine %s.%s", tmp_schema_name, tmp_routine_name);
            return -1;
          }

        }

        debug_q_schema_name_in_statement= tmp_schema_name;
        debug_q_routine_name_in_statement= tmp_routine_name;
      }
      else
      {
        /* It's not possibly a routine identifier, and we're expecting a routine identifier. */
        strcpy(command_string, "Expected a routine name"); return -1;
      }
    }
    if ((token[0] == ',') && (statement_type == TOKEN_KEYWORD_DEBUG_SETUP)) name_is_expected= true;

    if ((token_type == TOKEN_TYPE_LITERAL_WITH_DIGIT)
     || (token_type == TOKEN_TYPE_LITERAL))
    {
      if (*index_of_number_1 == -1) *index_of_number_1= i;
      else if (*index_of_number_2 == -1) *index_of_number_2= i;
    }
    if (strlen(command_string) + strlen(token) + 1 >= 512) { strcpy(command_string, "overflow"); return -1; }
    if (strcmp(command_string, "") != 0) strcat(command_string, " ");
    strcat(command_string, token);
  }
  return 0;
}


/*
  First: find the surrogate routine that debuggee will call (if it's not there, error = you should call setup).
  Todo: schema_name could be '.' i.e. default
  Then: put up debug_top_widget
  Then: execute xxxmdbug.command(...,'debug ...')
  Todo: check that surrogate routine is not obsolete, i.e. timestamp is after original routine's timestamp
  Todo: check that everything in the group is present and executable
  Todo: check that user is the same ... but how can you do that? Is it only in setup_log?
  Todo: get rid of initialize() from menu
  Todo: when starting, make sure debuggee is not already running -- even a finished routine is not over
  Todo: if clicking causes you to get to action_debug_debug() you must generate a $DEBUG statement -- but how click a list??
*/
//void MainWindow::action_debug_debug()
//{
//  /* Figure out what the parameter should be -- it's not text, eh? */
//  QString parameter;
//  debug_debug_go(parameter);
//}


/*
  Call debug_error((char*)"error-text") whenever, in one of the debug routines, you encounter an error.
  Call debug_error((char*)"") regardless, at the start of a debug routine, so basic prerequisite checks can happen.
  For example, if the user says "$debug test.x" and there is no surrogate for x, we want the user to see:
  Error 1644 (05678) Surrogate not found.
  TODO: make sure all the debug-routine failures go through here!
  Todo: if the error is due to a failure of the last call, add what that last call's error message was.
*/
int MainWindow::debug_error(char *text)
{
//  unsigned int statement_type;

  if (connections_is_connected[0] == 0)
  {
    /* Unfortunately this might not get through. */
    make_and_put_message_in_result(ER_NOT_CONNECTED, 0, (char*)"");
    return 1;
  }

  if (debuggee_state < 0)
  {
    char tmp_string[STRING_LENGTH_512]="";
    char tmp_string_2[STRING_LENGTH_512 + 64];
    if (debuggee_state != DEBUGGEE_STATE_END)
    {
      /* debuggee_state_error should tell us something, but remove all ' first */
      strcpy(tmp_string, debuggee_state_error);
      for (int i= 0; tmp_string[i] != '\0'; ++i) if (tmp_string[i] == '\047') tmp_string[i]= ' ';
    }
    if (debuggee_state == DEBUGGEE_STATE_END)
    {
      make_and_put_message_in_result(ER_ROUTINE_HAS_STOPPED, 0, (char*)"");
    }
    else
    {
      sprintf(tmp_string_2, "'%s %d. %s'", "debuggee_state:", debuggee_state, tmp_string);
      put_message_in_result(tmp_string_2);
    }
    return 1;
  }


  if (strcmp(text,"") != 0)
  {
    put_message_in_result(text);
    return 1;
  }

  return 0;
}


/* $DEBUG [schema.]routine [(parameters)] */
void MainWindow::debug_debug_go(QString text) /* called from execute_client_statement() or action_debug_debug() */
{
  log("debug_debug_go", 90);
  char routine_schema[512];
  char routine_name[512];
  char call_statement[512];
  QString result_string;
  QString qstring_error_message;
  int current_widget_index;
  QString q_routine_schema, q_routine_name;
  char command_string[2048];
  int index_of_number_1, index_of_number_2;
  /* Todo: Check that 'debug' has not happened */
  if (debug_parse_statement(text, command_string, &index_of_number_1, &index_of_number_2) < 0)
  {
    if (debug_error(command_string) != 0) return;
  }

  q_routine_schema= debug_q_schema_name_in_statement;
  q_routine_name= debug_q_routine_name_in_statement;

  if ((q_routine_schema == "") || (q_routine_name == ""))
  {
    if (debug_error((char*)er_strings[er_off + ER_MISSING_ROUTINE_NAME]) != 0) return;
  }

  /*
    If a $debug was started before, and didn't finish, we demand that the user do $exit.
    We could instead call debug_exit_go(1).
    Perhaps $exit will fail somehow, and users will be falsely told they can't debug.
    That's a bug but better than hanging, which is a risk if we make two debug threads.
  */
  if (debug_thread_exists == true)
  {
    if (debug_error((char*)er_strings[er_off + ER_DEBUG_IS_ALREADY_RUNNING]) != 0) return;
  }

  if (debuggee_state < 0) debuggee_state= DEBUGGEE_STATE_0;
  if (debuggee_state == DEBUGGEE_STATE_END) debuggee_state= DEBUGGEE_STATE_0;
  if (debug_error((char*)"") != 0) return;

  strcpy(routine_schema, q_routine_schema.toUtf8());
  strcpy(routine_name, q_routine_name.toUtf8());

  if (debuggee_state > 0)
  {
    if (debug_error((char*)er_strings[er_off + ER_DEBUG_IS_ALREADY_RUNNING]) != 0) return;
  }

  qstring_error_message= debug_privilege_check(TOKEN_KEYWORD_DEBUG_DEBUG);
  if (qstring_error_message != "")
  {
    strcpy(command_string, qstring_error_message.toUtf8());
    if (debug_error(command_string) != 0) return; /* debuggee wouldn't be able to operate so fail */
  }
  /* Call xxxmdbug.debuggee_get_surrogate_name */
  strcpy(call_statement, "CALL xxxmdbug.debuggee_get_surrogate_name('");
  strcat(call_statement, routine_name);
  strcat(call_statement, "','");
  strcat(call_statement, routine_schema);
  strcat(call_statement, "',@schema_identifier,@surrogate_routine_identifier,@routine_type,@remainder_of_original_name)");
if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement)))
  {
    if (debug_error((char*)er_strings[er_off + ER_SURROGATE]) != 0) return;
  }
  result_string= select_1_row("select @schema_identifier, concat(left(@surrogate_routine_identifier,11), '%'), @routine_type, @remainder_of_original_name, isnull(@schema_identifier)");
  if (result_string != "")
  {
    char char_result_string[512];
    strcpy(char_result_string, result_string.toUtf8());
    if (debug_error(char_result_string) != 0) return;
  }
  /* select_1_row_result_1 = @schema_identifier. select_1_row_result_2 = left(@surrogate_routine_identifier,11) || '%'. */

  /* Todo: this checks whether select returned null, good. But it should make even more certain that $debug will succeed. */
  if (select_1_row_result_5.toInt() == 1)
  {
    if (debug_error((char*)er_strings[er_off + ER_SURROGATE_NOT_FOUND]) != 0) return;
  }

  //QString routine_schema_name_for_search= select_1_row_result_1;
  QString routine_name_for_search= select_1_row_result_2;
  /*
    This will find all surrogate routines which have the same prefix, xxxmdbug___
    That means they're in the same group. Ignore icc_core.
    Get only the part that's not part of the prefix.
    Don't ask for schema name, group's routines can be in different schema.
    Interesting idea: you could have a way to show both the surrogate and the original.
  */
  int i, j;
  char i_as_string[16];
  /* Todo: n should not be hard-coded here, it limits us to only 10 routines can be searched */
  for (i= 0, j= 0; j < DEBUG_TAB_WIDGET_MAX; ++i)
  {
    sprintf(i_as_string, "%d", i);
    strcpy(call_statement, "select routine_schema, right(routine_name,length(routine_name)-12) from information_schema.routines ");
    strcat(call_statement, "where routine_name like '");
    strcat(call_statement, routine_name_for_search.toUtf8());
    strcat(call_statement, "' order by routine_name limit 1 offset ");
    strcat(call_statement, i_as_string);
    result_string= select_1_row(call_statement);
    if (result_string != "")
    {
      char char_result_string[512];
      if (result_string == er_strings[er_off + ER_MYSQL_FETCH_ROW_FAILED]) break;
      strcpy(char_result_string, result_string.toUtf8());
      if (debug_error(char_result_string) != 0) return;
    }
    if (select_1_row_result_2 != "icc_core")
    {
      /* Todo: debug_routine_schema_name and debug_routine_name are global so setup() will ruin them. Fix that! */
      debug_routine_schema_name[j]= select_1_row_result_1;
      debug_routine_name[j]= select_1_row_result_2;
      ++j;
    }
  }

  /* Todo: check: can this crash if there are DEBUG_TAB_WIDGET_MAX routines? Is this unnecessary if there are DEBUG_TAB_WIDGET_MAX routines? */
  debug_routine_name[j]= "";

  int debug_widget_index;

  /* Todo: check if this is useless. You're supposed to have called debug_delete_tab_widgets[] during $exit. */
  for (debug_widget_index= 0; debug_widget_index < DEBUG_TAB_WIDGET_MAX; ++debug_widget_index)
  {
    debug_widget[debug_widget_index]= 0;
  }
  /* After this point, some items that get created are persistent, so be sure to clear them if there's an error. */
  //MYSQL_RES *debug_res;
  //MYSQL_ROW row;
  QString routine_definition;
  current_widget_index= -1;
  for (debug_widget_index= 0; debug_widget_index < DEBUG_TAB_WIDGET_MAX; ++debug_widget_index)
  {
    if (strcmp(debug_routine_name[debug_widget_index].toUtf8(), "") == 0) break;
    strcpy(call_statement, "select routine_definition from information_schema.routines where routine_schema = '");
    strcat(call_statement, debug_routine_schema_name[debug_widget_index].toUtf8());
    strcat(call_statement, "' and routine_name = '");
    strcat(call_statement, debug_routine_name[debug_widget_index].toUtf8());
    strcat(call_statement, "'");
    QString error_return= select_1_row(call_statement);
    if (error_return != "")
    {
      debug_delete_tab_widgets();                          /* delete already-made widgets. Rest of 'exit' shouldn't happen. */
      {
        /* Could not find a routine in the $setup group: ... */
        char t_error_return[256];
        char t_schema_name[256];
        char t_routine_name[256];
        strcpy(t_error_return, error_return.toUtf8());
        strcpy(t_schema_name, debug_routine_schema_name[debug_widget_index].toUtf8());
        strcpy(t_routine_name, debug_routine_name[debug_widget_index].toUtf8());
        sprintf(call_statement,
                er_strings[er_off + ER_COULD_NOT_FIND_A_ROUTINE],
                t_error_return,
                t_schema_name,
                t_routine_name);
      }
      debug_error(call_statement);                         /* Todo: you forgot to look for icc_core */
      return;
    }
    routine_definition= select_1_row_result_1;             /* = information_schema.routines.routine_definition */

    if (routine_definition == "")
    {
      debug_delete_tab_widgets();
      {
        /* Could not get a routine definition for ... */
        char t_routine_name[256];
        strcpy(t_routine_name, debug_routine_name[debug_widget_index].toUtf8());
        sprintf(call_statement, er_strings[er_off + ER_COULD_NOT_GET], t_routine_name);
      }
      if (debug_error(call_statement)) return;
    }
    debug_widget[debug_widget_index]= new CodeEditor(this);
    debug_widget[debug_widget_index]->is_debug_widget= true;
    debug_widget[debug_widget_index]->statement_edit_widget_left_bgcolor= QColor(ocelot_statement_prompt_background_color);
    debug_widget[debug_widget_index]->statement_edit_widget_left_treatment1_textcolor= QColor(ocelot_statement_text_color);

    debug_maintain_prompt(0, debug_widget_index, 0); /* clear prompt_as_input_by_user */

    debug_widget[debug_widget_index]->setStyleSheet(ocelot_statement_style_string);

    /* todo: call 'refresh breakpoints' and debug_maintain_prompt() for breakpoints that already have been set up. */
    debug_widget[debug_widget_index]->prompt_default= (QString)"\\2 \\L";
    debug_widget[debug_widget_index]->result= (QString)"ABCDEFG";
    debug_widget[debug_widget_index]->setPlainText(routine_definition);

    debug_widget[debug_widget_index]->setReadOnly(false);                 /* if debug shouldn't be editable, set to "true" here */
    debug_widget[debug_widget_index]->installEventFilter(this);           /* is this necessary? */
    debug_tab_widget->addTab(debug_widget[debug_widget_index], debug_routine_name[debug_widget_index]);

    if ((QString::compare(debug_routine_name[debug_widget_index], q_routine_name, Qt::CaseInsensitive) == 0)
    &&  (QString::compare(debug_routine_schema_name[debug_widget_index], q_routine_schema, Qt::CaseInsensitive) == 0))
    {
      current_widget_index= debug_widget_index;
    }
  }
  if (current_widget_index == -1)
  {
    debug_delete_tab_widgets();
    if (debug_error((char*)er_strings[er_off + ER_ROUTINE_IS_MISSING])) return;
  }
  debug_tab_widget->setCurrentIndex(current_widget_index);

  /* Getting ready to create a separate thread for the debugger and 'attach' to it */

  char error_message[512];

  debuggee_state= DEBUGGEE_STATE_0;

  /*
    We want the debuggee default database to be the main default
    database, but that's not necessarily ocelot_database_as_utf8
    because maybe we had a USE statement.
    Todo: I'm a bit unclear what to do if this fails.
  */
  if (select_1_row("select database()") != "") debuggee_database[0]= '\0';
  else strcpy(debuggee_database, select_1_row_result_1.toUtf8());

  /*
    We want a channel name that will differ from what others might choose.
    Arbitrary decision = debug_channel_name will be "ch#" || connection-number-of-main-connection.
    It could be uniquified beyond that if necessary, e.g. add user name.
    Todo: this could be moved so it doesn't happen every time $debug happens. */

  sprintf(debuggee_channel_name, "ch#%d", statement_edit_widget->dbms_connection_id);

  /* Create a debuggee thread. */
  /* Todo: consider whether it would have been better to use the Qt QThread function */
  int pthread_create_result= pthread_create(&debug_thread_id, NULL, &debuggee_thread, NULL);
#if defined(NDEBUG)
    if (pthread_create_result != 0) {printf("assert(pthread_create_result == 0);"); exit(1); }
#else
    assert(pthread_create_result == 0);
#endif
  debug_thread_exists= true;
  /*
    Wait till debuggee has indicated that it is about to call debuggee_wait_loop().
    Todo: Give a better diagnostic if this doesn't happen.
    Todo: Is it possible to fail anyway? If so, sleep + repeat?
    Todo: This gives up after 1 second. Maybe on a heavily loaded machine that's too early?
  */
  for (int k= 0; k < 100; ++k)
  {
    QThread48::msleep(10);
    if (debuggee_state == DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP) break;
  }
  QThread48::msleep(10); /* in case debuggee_wait_loop() fails immediately */
  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    /* Todo: if somehow (bizarrely) debuggee_state >= 0, then the thread did not end and needs to be stopped. */
    debug_delete_tab_widgets();
    sprintf(error_message, er_strings[er_off + ER_DEBUGGEE_NOT_RESPONDING], debuggee_state);
    if (debug_error(error_message) != 0) return;
  }
  /*
    Attach to the debuggee.
    Todo: Check: is it possible for this to fail because thread has not connected yet? If so, sleep + repeat?
    Todo: Check: why use insertPlainText not setPlainText?
  */
  strcpy(call_statement, "call xxxmdbug.command('");
  strcat(call_statement, debuggee_channel_name);
  strcat(call_statement, "', 'attach');\n");
  if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement)))
  {
    /* Attach failed. Doubtless there's some sort of error message. Put it out now, debug_exit_go() won't override it. */
    put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
    debug_exit_go(1); /* This tries to tell the debuggee to stop, because we're giving up. */
    return;
  }
  debug_timer_old_line_number= -1;
  debug_timer_old_schema_identifier[0]= '\0';
  debug_timer_old_routine_identifier[0]= '\0';
  debug_timer_old_commands_count= -1;
  debug_timer_old_number_of_status_message= -1;
  debug_timer_old_icc_count= -1;
  debug_timer_old_debug_widget_index= -1;
  debug_timer->start(DEBUG_TIMER_INTERVAL);

  /* By the way, we fill in [schema.] if it's missing, because otherwise default would be 'test'. */

  //  strcpy(call_statement, "debug ");
  //if (strcmp(routine_schema, "") != 0)
  //{
  //  strcat(call_statement, routine_schema);
  //  strcat(call_statement, ".");
  //}
  //strcat(call_statement, routine_name);

  if (debug_call_xxxmdbug_command(command_string) != 0)
  {
    /* Debug failed. Doubtless there's some sort of error message. Put it out now, debug_exit_go() won't override it. */
    put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
    debug_exit_go(1); /* This tries to tell the debuggee to stop, because we're giving up. */
    return;
  }
  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
  /* TODO: next line was removed TEMPORARILY. But maybe highlighting will occur due to temporary breakpoint? */
  //debug_highlight_line(); /* highlight the first line. todo: should be the first executable line, no? */
  debug_top_widget->show(); /* Is this necessary? I think so because initially debug_window should be hidden. */
  debug_menu_enable_or_disable(TOKEN_KEYWORD_DEBUG_DEBUG);             /* Until now most debug menu items were gray. */
}


/*
  Change the contents of debug_widget[debug_widget_index]->prompt_as_input_by_user.
  action: 0 = initialize/clear, 1 = add breakpoint, 2 = delete breakpoint, 3 = add tbreakpoint
  line_number: irrelevant if action == 0, else line number for add/clear
  We have to set the prompt -- the separated-from-the-text stuff on the left -- so that it shows
  the line numbers with \2 \L, and shows the breakpoints with K(line-number).
  We avoid 'refresh breakpoints' because it waits for debuggee to be free; hope it doesn't get out of synch.
  We should end up with something like "\2 \L \K(5,red,) \K(4,red,)" if there are breakpoints on line 5 and line 4.
  Todo: Even if we're doing adds, do all the deletes first so that if this is called twice there won't be a duplicate.
        (Todo: I think the debuggee would not make duplicates, but that needs checking.)
  Todo: breakpoint and tbreakpoint look the same in this scheme.
*/
void MainWindow::debug_maintain_prompt(int action, int debug_widget_index, int line_number)
{
  if (action == 0)                                                         /* clear */
  {
    debug_widget[debug_widget_index]->prompt_as_input_by_user= (QString)"\\2 \\L";
    return;
  }
  QString prompt_including_symbol;
  QString breakpoint_symbol;

  prompt_including_symbol= (QString)" \\K(";
  prompt_including_symbol.append(QString::number(line_number));
  breakpoint_symbol= QChar(0x24b7);                                        /* CIRCLED LATIN CAPITAL LETTER B */
  prompt_including_symbol.append(",red,");
  prompt_including_symbol.append(breakpoint_symbol);
  prompt_including_symbol.append(")");

  if (action == 2)                                                        /* delete (well, actually: clear */
  {
    /* I don't expect that indexOf() could return -1, and I ignore it if it does happen. */
    int index_of_prompt;
    index_of_prompt= debug_widget[debug_widget_index]->prompt_default.indexOf(prompt_including_symbol);
    if (index_of_prompt >= 0) debug_widget[debug_widget_index]->prompt_default.remove(index_of_prompt, prompt_including_symbol.size());
    index_of_prompt= debug_widget[debug_widget_index]->prompt_as_input_by_user.indexOf(prompt_including_symbol);
    if (index_of_prompt >= 0) debug_widget[debug_widget_index]->prompt_as_input_by_user.remove(index_of_prompt, prompt_including_symbol.size());
  }
  if ((action == 1) || (action == 3))                                    /* add */
  {
    debug_widget[debug_widget_index]->prompt_default.append(prompt_including_symbol);
    debug_widget[debug_widget_index]->prompt_as_input_by_user.append(prompt_including_symbol);
  }
}


/*
  Find out what is current routine and current line, put a symbol beside it.
  Execute a command e.g. "debug test.p8 5".
  So far: we get block_number = current line number - 1.
  Todo: we don't show the B in a circle!
  Do not confuse with action_mousebuttonpress which also generates "$breakpoint ...".
*/
void MainWindow::action_debug_breakpoint()
{
  log("action_debug_breakpoint", 90);
  char command[512];
  int line_number;
  char line_number_as_string[10];

  int debug_widget_index= debug_tab_widget->currentIndex();
  /* I can't imagine how currentIndex() could be == -1, but if it is, do nothing. */
  if (debug_widget_index < 0) return;
  line_number= debug_widget[debug_widget_index]->block_number + 1;
  sprintf(line_number_as_string, "%d", line_number);
  strcpy(command, "$BREAKPOINT ");
  strcat(command, debug_routine_schema_name[debug_widget_index].toUtf8());
  strcat(command,".");
  strcat(command, debug_routine_name[debug_widget_index].toUtf8());
  strcat(command, " ");
  strcat(command, line_number_as_string);

  statement_edit_widget->setPlainText(command);
  action_execute(1);
}


/*
  "breakpoint" and "clear" and "tbreakpoint" have the same argument syntax so we use the same routine for all,
  passing statement_type == TOKEN_KEYWORD_DEBUG_BREAKPOINT or TOKEN_KEYWORD_DEBUG_CLEAR.
  Todo: "$breakpoint ... hit_count = N" is not working.
  Todo: "$breakpoint ... variable_name <> old" is not working.
*/
void MainWindow::debug_breakpoint_or_clear_go(int statement_type, QString text)
{
  char command_string[512];
  int index_of_number_1, index_of_number_2;
  QString routine_name;
  QString schema_name;

  /* Todo: Check that 'debug' has happened */
  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_error((char*)er_strings[er_off + ER_NO_DEBUG_SESSION]) != 0) return;
  }

  if (debug_parse_statement(text, command_string, &index_of_number_1, &index_of_number_2) < 0)
  {
    char error_message[512];
    if (statement_type == TOKEN_KEYWORD_DEBUG_BREAKPOINT)
      strcpy(error_message, er_strings[er_off + ER_BREAKPOINT_SYNTAX]);
    else if (statement_type == TOKEN_KEYWORD_DEBUG_TBREAKPOINT)
      strcpy(error_message, er_strings[er_off + ER_TBREAKPOINT_SYNTAX]);
    else
      strcpy(error_message, er_strings[er_off + ER_CLEAR_SYNTAX]);
    if (debug_error(error_message) != 0) return;
  }
  schema_name= debug_q_schema_name_in_statement;
  routine_name= debug_q_routine_name_in_statement;

  if ((schema_name == "") || (routine_name == ""))
  {
    if (debug_error((char*)er_strings[er_off + ER_MISSING_ROUTINE_NAME]) != 0) return;
  }

  if (debug_error((char*)"") != 0) return;

  if (debug_call_xxxmdbug_command(command_string) != 0)
  {
    put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
    return;
  }

  /* Figure out line number and debug_widget_index from the index variables. */
  /* Todo: This is failing to compare schema name. */

  int debug_widget_index;

  for (debug_widget_index= 0; debug_widget_index < DEBUG_TAB_WIDGET_MAX; ++debug_widget_index)
  {
    if (debug_widget[debug_widget_index] != 0)
    {
      if ((QString::compare(routine_name, debug_routine_name[debug_widget_index]) == 0)
       && (QString::compare(schema_name, debug_routine_schema_name[debug_widget_index]) == 0)) break;
    }
  }

  if (debug_widget_index == DEBUG_TAB_WIDGET_MAX)
  {
    if (debug_error((char*)"No such routine") != 0) return;
  }

  int line_number_1, line_number_2;
  QString q_line_number;
  q_line_number= text.mid(main_token_offsets[index_of_number_1], main_token_lengths[index_of_number_1]);
  line_number_1= q_line_number.toInt();
  if (index_of_number_2 == -1) line_number_2= line_number_1;
  else
  {
    q_line_number= text.mid(main_token_offsets[index_of_number_2], main_token_lengths[index_of_number_2]);
    line_number_2= q_line_number.toInt();
  }

  for (int i= line_number_1; i <= line_number_2; ++i)
  {
    if (i > debug_widget[debug_widget_index]->blockCount())
    {
      break;
    }
    if (statement_type == TOKEN_KEYWORD_DEBUG_BREAKPOINT) debug_maintain_prompt(1, debug_widget_index, i);
    if (statement_type == TOKEN_KEYWORD_DEBUG_CLEAR) debug_maintain_prompt(2, debug_widget_index, i);
    if (statement_type == TOKEN_KEYWORD_DEBUG_TBREAKPOINT) debug_maintain_prompt(3, debug_widget_index, i);
  }
  /*
    Todo: I have had trouble, sometimes the breakpoint symbols don't show up unless I click on the line.
          I think that one of these kludges is helping, but I don't know if it always helps,
          and I don't know which of the two lines is actually fixing the problem,
          and I don't know whether there's a better way. So find out, eh?
  */
  debug_widget[debug_widget_index]->repaint();
  debug_widget[debug_widget_index]->viewport()->update();
  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
}


/*
  Todo: The problem with "delete n" is we don't know which breakpoint is n.
  Of course it's in xxxmdbug.breakpoints, but "r breakpoints" only works if we're at a breakpoint.
*/
void MainWindow::debug_delete_go()
{
  make_and_put_message_in_result(ER_DELETE_STATEMENT, 0, (char*)"");
}


/*
  We will get here if mouse button pressed on debug_tab_widget (we don't know which debug_widget yet, possibly none of them).
  What's it good for? Probably this will be the main way to set a breakpoint.
  I think we'll need to find a right mousebutton press and put up a menu.
  But maybe it would be better if debug_window had a menu bar.
  In ddd, one of the many options is: double-click. But I didn't succeed with doubleclick.
  Todo: figure out what to do if there's already a breakpoint here. Clear it? Right now we're just duplicating it.
*/
void MainWindow::action_debug_mousebuttonpress(QEvent *event, int which_debug_widget_index)
{
  log("action_debug_mousebutonpress", 90);
  int line_number;
  char command[1280];
  char schema_name[512];
  char routine_name[512];
  int debug_widget_index;

  QMouseEvent *mouse_event= static_cast<QMouseEvent*> (event);            /* Get line number where mousepress happened */
  QPoint point= mouse_event->pos();
  debug_widget_index= debug_tab_widget->currentIndex();
  /* I saw a crash once so maybe these checks aren't to paranoid. But I don't know whether they avoid the crash. */
  if (debug_widget_index == -1) return;                                   /* Check for an impossible condition */
  if (debug_widget_index > DEBUG_TAB_WIDGET_MAX) return;                  /* "" */
  if (which_debug_widget_index >= debug_tab_widget->count()) return;      /* "" */
  if (which_debug_widget_index != debug_widget_index) return;             /* "" */
  QTextCursor text_cursor= debug_widget[debug_widget_index]->cursorForPosition(point);
  line_number= text_cursor.blockNumber() + 1;

  strcpy(schema_name, debug_routine_schema_name[debug_widget_index].toUtf8());
  strcpy(routine_name, debug_routine_name[debug_widget_index].toUtf8());

  sprintf(command, "$breakpoint %s.%s %d", schema_name, routine_name, line_number);
  statement_edit_widget->setPlainText(command);                           /* Execute "$breakpoint ..." */
  action_execute(1);
}


/*
  Debug|Clear
  Similar code is in action_debug_breakpoint().
  Do not confuse with Debug|Delete: "$delete 5" clears a breakpoint #5.
  Todo: Check that somewhere something says debug_maintain_prompt(2, debug_widget_index, line_number);
*/
void MainWindow::action_debug_clear()
{
  log("action_debug_clear", 90);
  char command[512];
  int line_number;
  char line_number_as_string[10];

  int debug_widget_index= debug_tab_widget->currentIndex();
  /* I can't imagine how currentIndex() could be == -1, but if it is, do nothing. */
  if (debug_widget_index < 0) return;
  line_number= debug_widget[debug_widget_index]->block_number + 1;
  sprintf(line_number_as_string, "%d", line_number);
  strcpy(command, "$CLEAR ");
  strcat(command, debug_routine_schema_name[debug_widget_index].toUtf8());
  strcat(command,".");
  strcat(command, debug_routine_name[debug_widget_index].toUtf8());
  strcat(command, " ");
  strcat(command, line_number_as_string);
  statement_edit_widget->setPlainText(command);
  action_execute(1);
}


/*
  Debug|Continue -- "CALL xxxmdbug.command([channel-name],'continue');" as a client statement
*/
void MainWindow::action_debug_continue()
{
  log("action_debug_continue", 90);
  statement_edit_widget->setPlainText("$CONTINUE");
  action_execute(1);
}

/*
  Debug|Step
  This is much like Debug|Continue, but we don't care if we end up on a permanent breakpoint.
*/
void MainWindow::action_debug_step()
{
  log("action_debug_step", 90);
  statement_edit_widget->setPlainText("$STEP");
  action_execute(1);
}

/*
  Debug|Leave
  This isn't working quite right. It gets out of loops, but if it's
  in a subroutine then it will try to execute all the way to the end
  of the main routine. (A breakpoint can stop that from happening.)
  So we will allow the $LEAVE statement but not advertise it on the menu.
*/
//void MainWindow::action_debug_leave()
//{
//    statement_edit_widget->setPlainText("$LEAVE");
//    action_execute(1);
//}


/* $SKIP seems to act like $CONT which isn't terribly useful */
void MainWindow::debug_skip_go()
{
  make_and_put_message_in_result(ER_SKIP_STATEMENT, 0, (char*)"");
}


void MainWindow::debug_source_go()
{
  make_and_put_message_in_result(ER_SOURCE_STATEMENT, 0, (char*)"");
}


/*
  $SET declared_variable_name = value;
  Todo: As an additional error check: look up declared_variable_name in xxxmdbug.variables.
  TODO: BUG: $set x = 'literal'; results in a syntax error so say only numbers are allowed.
*/
void MainWindow::debug_set_go(QString text)
{
  char command_string[5120];
  int index_of_number_1, index_of_number_2;

  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_error((char*)er_strings[er_off + ER_NO_DEBUG_SESSION]) != 0) return;
  }
  if (debug_parse_statement(text, command_string, &index_of_number_1, &index_of_number_2) < 0)
  {
    if (debug_error((char*)er_strings[er_off + ER_OVERFLOW]) != 0) return;
    return;
  }
  debug_call_xxxmdbug_command(command_string);
  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
}


/*
  $execute sql-statement
  todo: this will fail if first token is a comment
  todo: get rid of this, it fails
*/
void MainWindow::debug_execute_go()
{
  make_and_put_message_in_result(ER_EXECUTE_STATEMENT, 0, (char*)"");

//  QString s;
//  char command_string[5120];
//  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
//  {
//    if (debug_error((char*)"No debug session in progress") != 0) return;
//  }
//  if (debug_error((char*)"") != 0) return;
//
//  s= "execute ";
//  s.append(text.right(text.length() - (main_token_offsets[main_token_number] + main_token_lengths[main_token_number])));
//  QMessageBox msgbox;
//  msgbox.setText(s);
//  msgbox.exec();
//  strcpy(command_string, s.toUtf8());
//  printf("command_string=%s.\n", command_string);
//  debug_call_xxxmdbug_command(s.toUtf8());
//  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
////  put_message_in_result("This statement is not supported at this time");
}


/* For: $next, $continue, $refresh */
/* The following could be used for all the $... statements where one merely passes the command on to the debuggee */
/* We strip the comments and the ; but if there's junk after the first word it will cause an error, as it should. */
/* Todo: Should you add a semicolon? */
/* Todo: For some reason "$refresh variables;" returns a message with
   ok, 40 rows affected", I don't know where the 40 came from. */
void MainWindow::debug_other_go(QString text)
{
  char command_string[512];
  int index_of_number_1, index_of_number_2;
  QString q_schema_name, q_routine_name;

  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_error((char*)er_strings[er_off + ER_NO_DEBUG_SESSION]) != 0) return;
  }
  if (debug_parse_statement(text, command_string, &index_of_number_1, &index_of_number_2) < 0)
  {
    if (debug_error((char*)er_strings[er_off + ER_OVERFLOW]) != 0) return;
    return;
  }
  q_schema_name= debug_q_schema_name_in_statement;
  q_routine_name= debug_q_routine_name_in_statement;
  if (debug_error((char*)"") != 0) return;
  if (debug_call_xxxmdbug_command(command_string) != 0) return;
  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
}


/*
  Debug|Next
*/
void MainWindow::action_debug_next()
{
 log("action_debug_next", 90);
 statement_edit_widget->setPlainText("$NEXT");
 action_execute(1);
}


/*
  Debug|Skip
  Commented out -- not working at this time
*/
//void MainWindow::action_debug_skip()
//{
//  statement_edit_widget->setPlainText("$SKIP");
//  action_execute(1);
//}


/*
  Given 'information status' schema + routine name, find out what the tab number is and make it current.
  Then change the cursor to point to a particular line.
  After the cursor is set to the line, the CodeEditor's highlightCurrentLine wil highlight it.
  Remember, blockNumber() is base 0
  Todo: If the call was completed, you shouldn't be here -- the line number will be too big!
*/
void MainWindow::debug_highlight_line()
{
  QTextCursor cursor;
  int debug_widget_index;
  int new_line_number;
  QString debuggee_schema_identifier;
  QString debuggee_routine_identifier;

  for (debug_widget_index= 0; debug_widget_index < DEBUG_TAB_WIDGET_MAX; ++debug_widget_index)
  {
    debuggee_schema_identifier= debuggee_information_status_schema_identifier;
    debuggee_schema_identifier= connect_stripper(debuggee_schema_identifier, false);
    debuggee_routine_identifier= debuggee_information_status_routine_identifier;
    debuggee_routine_identifier= connect_stripper(debuggee_routine_identifier, false);
    if (QString::compare(debuggee_schema_identifier, debug_routine_schema_name[debug_widget_index]) == 0)
    {
      if (QString::compare(debuggee_routine_identifier, debug_routine_name[debug_widget_index]) == 0)
      {
        break; /* now we know that debug_widget_index is for the tab of the routine the debuggee's at */
      }
    }
  }

  if (debug_widget_index >= DEBUG_TAB_WIDGET_MAX)
  {
    /* I think it's impossible that routine won't be there, but if it isn't, do nothing. */
    /* Well, not quite impossible -- schema or routine might be "unknown" or "". That's probably harmless. */
    /* Todo: Change status line, on supposition that the routine has not started or has ended. */
      return;
  }

  debug_tab_widget->setCurrentWidget(debug_widget[debug_widget_index]);

  new_line_number= atoi(debuggee_information_status_line_number);

  --new_line_number;

  /*
    Something like QTextCursor::HighlightCurrentLine. Make the background light red.
    This cancels the "current line" background (which is light yellow), and can be cancelled by it -- I think that's okay.
  */

  /* If this is a different debug_widget than the last one, this should turn highlight off for the last one. */
  if (debug_widget_index != debug_timer_old_debug_widget_index)
  {
    if (debug_timer_old_debug_widget_index != -1)
    {
      if (debug_timer_old_debug_widget_index != -1)
      {
        QList<QTextEdit::ExtraSelection> old_extraSelections;
        debug_widget[debug_timer_old_debug_widget_index]->setExtraSelections(old_extraSelections);
      }
    }
    debug_timer_old_debug_widget_index= debug_widget_index;
  }

  QList<QTextEdit::ExtraSelection> extraSelections;

  QTextEdit::ExtraSelection selection;

  /* debug highlight color = current line color e.g. yellow, but faded */
  QColor lineColor= QColor(ocelot_statement_highlight_current_line_color).lighter(160);

  QTextDocument* doc= debug_widget[debug_widget_index]->document();
  QTextBlock block;
  /* new_line_number will be -2 if "debuggee_wait_loop ended". probably -1 is impossible */
  if (new_line_number == -2) block= doc->findBlockByNumber(doc->blockCount() - 1);
  else if (new_line_number < 0) block= doc->findBlockByNumber(0);
  else block= doc->findBlockByNumber(new_line_number);
  int pos= block.position();

  selection.format.setBackground(lineColor);
  selection.format.setProperty(QTextFormat::FullWidthSelection, true);
  selection.cursor= QTextCursor(doc);
  selection.cursor.setPosition(pos, QTextCursor::MoveAnchor);
  selection.cursor.setPosition(pos + 1, QTextCursor::KeepAnchor);
  selection.cursor.clearSelection();
  extraSelections.append(selection);
  debug_widget[debug_widget_index]->setExtraSelections(extraSelections);

  /*
    I don't understand why selection.cursor.setPosition(pos) does not
    really move the cursor, I think it's got do with whether the cursor
    is a copy. Anyway, without the following code, if the highlighted
    line moves off the screen, it won't be visible unless the user
    scrolls up or down.
    The user can move the cursor too, this only overrides temporarily.
  */
  QTextCursor c =  debug_widget[debug_widget_index]->textCursor();
  c.setPosition(pos);
  debug_widget[debug_widget_index]->setTextCursor(c);
  //debug_widget[debug_widget_index]->ensureCursorVisible(); /* I think we don't need this */
}


/*
  Debug|Delete
*/
//void MainWindow::action_debug_delete()
//{
//  printf("STUB: delete\n");
//}


/*
  Debug|Exit
  = "CALL xxxmdbug.command([channel-name],'exit');" as a client statement
  Check debuggee_state. If it's not DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP, debuggee_wait_loop() is not going on. THIS APPLIES FOR MANY COMMANDS!
  Send "exit" command, which should cause debuggee to exit debuggee_wait_loop() and return from the thread function.
  Wait up to 1 second for "exit" to work.
  If it didn't work, "kill debuggee-connection-id".
  TODO: If debuggee fails to respond, it's up to you to kill it.
  TODO: Call this when main window exits, otherwise the thread's connection is immortal.
  TODO: I wish there was some way to clear up init_connect now too.
  Todo: menu item to shut down debugger, and hide debug_tab_widget, close the connection, and kill the thread.
  Todo: when would you like to get rid of debug_widgets[]?
  We call debug_menu_enable_or_disable(TOKEN_KEYWORD_DEBUG_EXIT) after calling debug_exit_go().
*/
void MainWindow::action_debug_exit()
{
  log("action_debug_exit", 90);
  statement_edit_widget->setPlainText("$EXIT");
  action_execute(1);
}


/* flagger == 0 means this is a regular $exit; flagger == 1 means we're getting rid of stuff due to a severe severe error */
void MainWindow::debug_exit_go(int flagger)
{
  log("debug_exit_go", 90);
  char call_statement[512];

  if (flagger == 0)
  {
    /* Todo: merge this with debug_error somehow, and make sure nothing's enabled/disabled unless debug/exit succeeded! */
    if (menu_debug_action_exit->isEnabled() == false)
    {
      make_and_put_message_in_result(ER_DEBUG_NOT_DONE, 0, (char*)"");
      return;
    }
  }

  debug_top_widget->hide();
  debug_timer->stop();
  /* Todo: more cleanup e.g. kill the debuggee thread, close the connection, even if it's not responding */
  /* Todo: yet more cleanup if you want to get rid of the setup result */

  debug_delete_tab_widgets();

  if (debuggee_state == DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_call_xxxmdbug_command("exit") != 0)
    {
      put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
      return;
    }
    for (int kk= 0; kk < 10; ++kk) {QThread48::msleep(100); if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP) break; }
    if ((debuggee_state == DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP) && (debuggee_connection_id != 0))
    {
      sprintf(call_statement, "kill %d", debuggee_connection_id);

      if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement)))
      {
        sprintf(call_statement, "SIGNAL SQLSTATE '05678' SET message_text='exit failed and kill failed -- try executing manually: kill %d'", debuggee_connection_id);
        lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement));
      }
    }
  }

  /* This should erase left-over messages in the pipe, such as the 'i status' message. Probably there's only one. */
  QString error_return;
  sprintf(call_statement, "%s%s%s","call xxxmdbug.dbms_pipe_receive('xxxmdbug_",debuggee_channel_name,
          "', 1, @xxxmdbug_tmp_1, @xxxmdbug_tmp_2)");
  for (int i= 0; i < 50; ++i)                                              /* 50 is an arbitrary big number */
  {
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement))) break;
    error_return= select_1_row("select @xxxmdbug_tmp_1");
    if (error_return != "") break;
    if (select_1_row_result_1 == "") break;
  }

  /* $install was saying "Suggested next step is: $EXIT" even though $EXIT was already done. */
  debuggee_state= DEBUGGEE_STATE_0;

  /*
     We call pthread_join so that memory is freed.
     But it might wait forever if debug thread is loopy.
     Perhaps we should kill the thread if we suspect that.
     Anyway: $exit is slow, and pthread_join is probably the cause.
  */
  if (debug_thread_exists == true)
  {
    int pthread_join_result= pthread_join(debug_thread_id, NULL);
#if defined(NDEBUG)
    if (pthread_join_result != 0) {printf("assert(pthread_join_result == 0);"); exit(1); }
#else
    assert(pthread_join_result == 0);
#endif
    debug_thread_exists= false;
  }

  if (flagger == 0)
  {
    put_diagnostics_in_result(MYSQL_MAIN_CONNECTION); /* This should show the result of the final call or select, so it should be "ok" */
  }
}


/* This is called from $exit, but also might be called from $debug if $debug fails */
/* We're reversing the effects of "new CodeEditor() and "addTab()" in debug_debug_go(). */
void MainWindow::debug_delete_tab_widgets()
{
  debug_tab_widget->clear(); /* equivalent to removeTab() for all tab widgets */
  for (int debug_widget_index= 0; debug_widget_index < DEBUG_TAB_WIDGET_MAX; ++debug_widget_index)
  {
    if (debug_widget[debug_widget_index] != 0)
    {
      debug_widget[debug_widget_index]->removeEventFilter(this);
      delete debug_widget[debug_widget_index];
      debug_widget[debug_widget_index]= 0;
    }
  }
}


/*
  Debug|Information
*/
void MainWindow::action_debug_information()
{
  log("action_debug_information", 90);
  if (debug_call_xxxmdbug_command("information status") != 0) return;
  statement_edit_widget->insertPlainText("select * from xxxmdbug.information_status;");
  action_execute(1);
}


/*
  Debug|Refresh server variables
*/
void MainWindow::action_debug_refresh_server_variables()
{
  log("action_debug_refresh_server_variables", 90);
  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_error((char*)er_strings[er_off + ER_NO_DEBUG_SESSION]) != 0) return;
  }
  if (debug_call_xxxmdbug_command("refresh server_variables") != 0) return;
  statement_edit_widget->insertPlainText("select * from xxxmdbug.server_variables;");
  action_execute(1);
}


/*
  Debug|Refresh user variables
*/
void MainWindow::action_debug_refresh_user_variables()
{
  log("action_debug_refresh_user_variables", 90);
  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_error((char*)er_strings[er_off + ER_NO_DEBUG_SESSION]) != 0) return;
  }
  if (debug_call_xxxmdbug_command("refresh user_variables") != 0) return;
  statement_edit_widget->insertPlainText("select * from xxxmdbug.user_variables;");
  action_execute(1);
}


/*
  Debug|Refresh variables
*/
void MainWindow::action_debug_refresh_variables()
{
  log("action_debug_refresh_variables", 90);
  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_error((char*)er_strings[er_off + ER_NO_DEBUG_SESSION]) != 0) return;
  }
  if (debug_call_xxxmdbug_command("refresh variables") != 0) return;
  statement_edit_widget->insertPlainText("select * from xxxmdbug.variables;");
  action_execute(1);
}


/*
  Debug|Refresh call_stack
*/
void MainWindow::action_debug_refresh_call_stack()
{
  log("action_debug_refresh_call_stack", 90);
  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_error((char*)er_strings[er_off + ER_NO_DEBUG_SESSION]) != 0) return;
  }
  if (debug_call_xxxmdbug_command("refresh call_stack") != 0) return;
  statement_edit_widget->insertPlainText("select * from xxxmdbug.call_stack;");
  action_execute(1);
}


/*
  Called from: action_debug_exit(), action_debug_debug(), action_debug_information(),
  and anything else which requires xxxmdbug.command -- except 'attach', except
  'information status' from from action_debug_timer_status().
  Make the SQL statement that is actually executed, but don't trouble the user with
  the details by showing it. For example, if the user said "$DEBUG test.p8", we
  execute "call xxxmdbug.command('channel#...','debug test.p8')" and return the
  result from that.
  Todo: unstripper might be okay but if the command has ''s within ''s
        then converting to 0x... and hex bytes would maybe be better
        (I decided against connect_unstripper since it's not a QString.)
*/
int MainWindow::debug_call_xxxmdbug_command(const char *command)
{
  char call_statement[512];

  char command_unstripped[512];
  QString s= command;
  s= connect_unstripper(s);
  strcpy(command_unstripped, s.toUtf8());

  strcpy(call_statement, "call xxxmdbug.command('");
  strcat(call_statement, debuggee_channel_name);
  strcat(call_statement, "', ");
  strcat(call_statement, command_unstripped);
  strcat(call_statement, ");\n");

  if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement)))
  {
    /* Initially this can happen because we start the timer immediately after we call 'attach'. */
    put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
    return 1;
  }
  debug_statement= command;

  //put_diagnostics_in_result(MYSQL_MAIN_CONNECTION)???

  /* We no longer try to get the debuggee response with debug_information_status(). */
  //if (strcmp(command, "information status") != 0)
  //{
  //  QString debuggee_response= "Debuggee response = ";
  //  if (debug_information_status((char *)command) != 0)
  //    {
  //    debuggee_response.append("(none). Possibly debuggee is still executing the last command, which was: ");
  //    debuggee_response.append(debuggee_information_status_last_command);
  //  }
  //  else
  //  {
  //    debuggee_response.append(debuggee_information_status_last_command_result);
  //  }
  //  history_edit_widget->append(debuggee_response);
  //}
  return 0;
}


/*
  INFORMATION STATUS -- internal
  We should call this after 'attach' or after 'debug' to see whether there's been some success.
  Most contacts with the debugger should get a quick response, unless the last was 'continue' or 'step ...' (?)
  ... Actually, check that: maybe 'continue' acknowledges receipt before continuing.
  ... And I think that 'continue' will still cause messages, if it's inside stored-procedure code that's being debugged.
*/
int MainWindow::debug_information_status(char *last_command)
{
  int k;

  /* TODO: JUST GET RID OF THIS PROC. I NO LONGER SEE ANY POINT TO IT. */

  for (k= 0; k < 100; ++k)
  {
    /*
       By sleeping, we give the QTimer a chance to call action_debug_timer_status() and update status.
       But it doesn't work! I guess it's because sleeping doesn't restart the event loop!
    */
    QThread48::msleep(100);
    if (strcmp(debuggee_information_status_last_command, last_command) == 0)
    {
      /* todo: this is not enough! you should be checking also if the command number has gone up! */
      break;
    }
  }

  /* k >= 100 means the 100-iteration loop containing a 10-ms sleep has gone by without a match for last_commnd */
  /* the caller will probably generate a warning */
  if (k >= 100) return 1; else return 0;
}


/*
  QTimer *debug_timer: every 100 milliseconds (every 1/10 second), while the debuggee
  is running, the timer event will invoke action_debug_timer() which updates the status.
  Todo: Start it when debuggee starts, stop it when debuggee stops.
  If a new information status message has appeared, display it.
  Todo: make sure timer is stopped before debug_tab_window is closed.
  Todo: This won't necessarily catch errors, because of the 1/10 second intervals and
        because multiple commands can be sent asynchronously. Think of a way!
        Meanwhile, just say: "If you must know the result, you must wait after each command."
  Todo: It would be faster to interpret the 'information status' results in C code here,
        rather than using xxxmdbug.information_status repeatedly.
        Besides, selecting from xxxmdbug.information_status can change the state of the main mysql connection.
        Maybe you should create a different connection?
  Todo: Worry about race conditions. The main thread could look at a status variable before all
        the status variables are updaated by this function. This might be alleviated by
        updating the counter last, but some sort of mutex might have to be considered.
  Todo: Check whether something closes the connection.
        Maybe it would be safest to say that, once a connection is open, it stays open.
        Hmm, why is this a worry, since we're doing the searching on main connection not debuggee connection?
  Todo: I have seen the xxxmdbug.command() cause "send+receive error" meaning a change to init_connect failed.
        Maybe xxxmdbug.commnd() shouldn't try to change init_connect -- after all, we're not trying to send, only receive.
*/
void MainWindow::action_debug_timer_status()
{
  log("action_debug_timer_status", 20);
  char call_statement[512];
  MYSQL_RES *debug_res= NULL;
  MYSQL_ROW row= NULL;
  char unexpected_error[512];
  int unexpected_new_error= 0;
  /*
    DANGER
    When the main line is running SQL statements, it calls
    QApplication::processEvents(), so there can be horrible
    conflicts -- action_debug_timer_status() runs SQL too.
    Either we must disable the Run|Kill feature, or disable
    the timer. Here, we've chosen to disable the timer.
  */
  if (dbms_long_query_state == LONG_QUERY_STATE_STARTED)
  {
    log("action_debug_timer_status return", 20);
    return;
  }
  unexpected_error[0]= '\0';
  strcpy(call_statement, "call xxxmdbug.command('");
  strcat(call_statement, debuggee_channel_name);
  strcat(call_statement, "', 'information status')");

  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debuggee_state == DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP_ERROR)
    {
      char tmp[256];
      int l= strlen(debuggee_state_error);
      if (l > 255) l= 255;
      memcpy(tmp, debuggee_state_error, l);
      tmp[l]= '\0';
      sprintf(unexpected_error, er_strings[er_off + ER_DEBUGGEE_WAIT_LOOP], tmp);
    }
    else
    {
      if ((debuggee_state < 0) || (debuggee_state == DEBUGGEE_STATE_END)) strcpy(unexpected_error, "debuggee_wait_loop ended");
      else strcpy(unexpected_error, er_strings[er_off + ER_DEBUGGEE_WAIT_LOOP_IS_NOT]);
    }
  }
  if (unexpected_error[0] == '\0')
  {
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement)))
    {
      /* Initially this can happen because we start the timer immediately after we call 'attach'. */
      strcpy(unexpected_error, er_strings[er_off + ER_I_STATUS_FAILED]);
    }
  }
  if (unexpected_error[0]== '\0')
  {
    const char *query= "select * from xxxmdbug.information_status";
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], query, strlen(query)))
    {
      strcpy(unexpected_error, er_strings[er_off + ER_I_STATUS_FAILED_NOT_SEVERE]);
    }
  }
  if (unexpected_error[0] == '\0')
  {
    debug_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
    if (debug_res == NULL)
    {
      strcpy(unexpected_error, er_strings[er_off + ER_MYSQL_STORE_RESULT_FAILED]);
    }
  }
  if (unexpected_error[0] == '\0')
  {
    row= lmysql->ldbms_mysql_fetch_row(debug_res);
    if (row == NULL)
    {
      strcpy(unexpected_error, er_strings[er_off + ER_MYSQL_FETCH_ROW_FAILED]);
    }
    else
    {
      if (lmysql->ldbms_mysql_num_fields(debug_res) < 14)
      {
        strcpy(unexpected_error, er_strings[er_off + ER_MYSQL_NUM_FIELDS]);
      }
      else
      {
        /* Just kludging -- I think something is overflowing. Todo: Find out what's really going on. */
        memset(debuggee_information_status_debugger_name, 0, 32);
        memset(debuggee_information_status_debugger_version, 0, 8);
        memset(debuggee_information_status_timestamp_of_status_message, 0, 32);
        memset(debuggee_information_status_number_of_status_message, 0, 8);
        memset(debuggee_information_status_icc_count, 0, 8);
        memset(debuggee_information_status_schema_identifier, 0, 256);
        memset(debuggee_information_status_routine_identifier, 0, 256);
        memset(debuggee_information_status_line_number, 0, 8);
        memset(debuggee_information_status_is_at_breakpoint, 0, 8);
        memset(debuggee_information_status_is_at_tbreakpoint, 0, 8);
        memset(debuggee_information_status_is_at_routine_exit, 0, 8);
        memset(debuggee_information_status_stack_depth, 0, 8);
        memset(debuggee_information_status_last_command, 0, 256);
        memset(debuggee_information_status_last_command_result, 0, 256);
        memset(debuggee_information_status_commands_count, 0, 8);

        if (row[0] != NULL) strncpy(debuggee_information_status_debugger_name, row[0], 32 - 1);
        if (row[1] != NULL) strncpy(debuggee_information_status_debugger_version, row[1], 8 - 1);
        if (row[2] != NULL) strncpy(debuggee_information_status_timestamp_of_status_message, row[2], 32 - 1);
        if (row[3] != NULL) strncpy(debuggee_information_status_number_of_status_message, row[3], 8 - 1);
        if (row[4] != NULL) strncpy(debuggee_information_status_icc_count, row[4], 8 - 1);
        if (row[5] != NULL) strncpy(debuggee_information_status_schema_identifier, row[5], 256 - 1);
        if (row[6] != NULL) strncpy(debuggee_information_status_routine_identifier, row[6], 256 - 1);
        if (row[7] != NULL) strncpy(debuggee_information_status_line_number, row[7], 8 - 1);
        if (row[8] != NULL) strncpy(debuggee_information_status_is_at_breakpoint, row[8], 8 - 1);
        if (row[9] != NULL) strncpy(debuggee_information_status_is_at_tbreakpoint, row[9], 8 - 1);
        if (row[10] != NULL) strncpy(debuggee_information_status_is_at_routine_exit, row[10], 8 - 1);
        if (row[11] != NULL) strncpy(debuggee_information_status_stack_depth, row[11], 8 - 1);
        if (row[12] != NULL) strncpy(debuggee_information_status_last_command, row[12], 256 - 1);
        if (row[13] != NULL) strncpy(debuggee_information_status_last_command_result, row[13], 256 - 1);
        if (row[14] != NULL) strncpy(debuggee_information_status_commands_count, row[14], 8 - 1);
      }
    }
  }
  if (debug_res != NULL) lmysql->ldbms_mysql_free_result(debug_res);
  if (unexpected_error[0] != '\0')
  {
    if (strcmp(debuggee_information_status_last_command_result, unexpected_error) != 0)
    {
      /* This should be considered as a status change, as if it's a new i status message */
      unexpected_new_error= 1;
      int l= strlen(unexpected_error);
      if (l > 255) l= 255;
      memcpy(debuggee_information_status_last_command_result, unexpected_error, l);
      debuggee_information_status_last_command_result[l]= '\0';
    }
  }
    //printf("debuggee_information_status_debugger_name=%s.\n", debuggee_information_status_debugger_name);
    //printf("debuggee_information_status_debugger_version=%s.\n", debuggee_information_status_debugger_version);
    //printf("debuggee_information_status_timestamp_of_status_message=%s.\n", debuggee_information_status_timestamp_of_status_message);
    //printf("debuggee_information_status_number_of_status_message=%s.\n", debuggee_information_status_number_of_status_message);
    //printf("debuggee_information_status_icc_count=%s.\n", debuggee_information_status_icc_count);
    //printf("debuggee_information_status_schema_identifier=%s.\n", debuggee_information_status_schema_identifier);
    //printf("debuggee_information_status_routine_identifier=%s.\n", debuggee_information_status_routine_identifier);
    //printf("debuggee_information_status_line_number=%s.\n", debuggee_information_status_line_number);
    //printf("debuggee_information_status_is_at_breakpoint=%s.\n", debuggee_information_status_is_at_breakpoint);
    //printf("debuggee_information_status_is_at_tbreakpoint=%s.\n", debuggee_information_status_is_at_tbreakpoint);
    //printf("debuggee_information_status_is_at_routine_exit=%s.\n", debuggee_information_status_is_at_routine_exit);
    //printf("debuggee_information_status_stack_depth=%s.\n", debuggee_information_status_stack_depth);
    //printf("debuggee_information_status_last_command=%s.\n", debuggee_information_status_last_command);
    //printf("debuggee_information_status_last_command_result=%s.\n", debuggee_information_status_last_command_result);
    //printf("debuggee_information_status_commands_count=%s.\n", debuggee_information_status_commands_count);

  /* If a status message would probably confuse a rational user, change it. */
    if (strstr(debuggee_information_status_last_command_result, "completed CALL") != NULL)
      strcpy(debuggee_information_status_last_command_result, "Routine has stopped. Suggested next step is: $EXIT");

    if (strstr(debuggee_information_status_last_command_result, "Failed, the expected command is debug") != NULL)
      strcpy(debuggee_information_status_last_command_result, "Routine has stopped and continuing past the end is not possible.  Suggested next step is: $EXIT");

  /*
    When execution ends, we still have line number = 0 and "stopped at breakpoint".
    That's misleading, but rather than change MDBug, let's override what it returns.
    Also: last command isn't always updated if execution has ended.
  */
  if (strcmp(debuggee_information_status_last_command_result, "debuggee_wait_loop ended") == 0)
  {
    strcpy(debuggee_information_status_line_number, "-1");
    strcpy(debuggee_information_status_is_at_breakpoint, "no");
    strcpy(debuggee_information_status_is_at_routine_exit, "yes");
    strcpy(debuggee_information_status_last_command, debug_statement.toUtf8());
    /* todo: what about debuggee_information_status_last_command_result? */
  }
  /*
    Change line_edit i.e. status widget, and maybe change highlight, if there's a new message.
    It would be extremely wasteful to update every time, i.e. every 1/10 second, if there's no change.
    Apparently the change that you can depend on is icc_count, not commands_count or number_of_status_message.
    I don't think there's any need to check whether line number + routine name have changed, but see below.
  */
  if ((debug_timer_old_commands_count != atoi(debuggee_information_status_commands_count))
  ||  (debug_timer_old_number_of_status_message != atoi(debuggee_information_status_last_command))
  ||  (debug_timer_old_icc_count != atoi(debuggee_information_status_icc_count))
  ||  (debug_timer_old_line_number != atoi(debuggee_information_status_line_number))
  ||  (unexpected_new_error == 1))
  {
    char result[2048];
    strcpy(result, "Debugger status = ");
    if (strcmp(debuggee_information_status_schema_identifier, "unknown") != 0)
    {
      strcat(result, "(Current position: ");
      strcat(result, debuggee_information_status_schema_identifier);
      strcat(result, ".");
      strcat(result, debuggee_information_status_routine_identifier);
      strcat(result, " line ");
      strcat(result, debuggee_information_status_line_number);
      strcat(result, ")");
    }
    strcat(result, "(Last debug command: ");
    strcat(result, debuggee_information_status_last_command);
    strcat(result, ", result: ");
    strcat(result, debuggee_information_status_last_command_result);
    strcat(result, ")");

    if (strcmp(debuggee_information_status_is_at_breakpoint, "yes") == 0)
    {
      strcat(result, "(STOPPED AT BREAKPOINT)");
    }

    if (strcmp(debuggee_information_status_is_at_routine_exit, "yes") == 0)
    {
      strcat(result, "(STOPPED AT ROUTINE EXIT)");
    }
    debug_line_widget->setText(result);
    /*
      If and only if the line number or routine name or schema name has changed,
      highlight i.e. change background color in order to show where we're at now.
      Formerly this checked "if (strcmp(debuggee_information_status_is_at_breakpoint, "yes") == 0)"
      i.e. are we at a breakpoint, but I no longer see why that matters.
      Besides, '$breakpoint' does not move the position.
    */
    if ((debug_timer_old_line_number != atoi(debuggee_information_status_line_number))
     || (strcmp(debug_timer_old_schema_identifier, debuggee_information_status_schema_identifier) == 0)
     || (strcmp(debug_timer_old_routine_identifier, debuggee_information_status_routine_identifier) == 0))
    {
      debug_highlight_line();
      debug_timer_old_line_number= atoi(debuggee_information_status_line_number);
      strcpy(debug_timer_old_schema_identifier, debuggee_information_status_schema_identifier);
      strcpy(debug_timer_old_routine_identifier, debuggee_information_status_routine_identifier);
    }
    debug_timer_old_commands_count= atoi(debuggee_information_status_commands_count);
    debug_timer_old_number_of_status_message= atoi(debuggee_information_status_last_command);
    debug_timer_old_icc_count= atoi(debuggee_information_status_icc_count);
  }
  log("action_debug_timer_status end", 20);
}
#endif // if (OCELOT_MYSQL_DEBUGGER == 1)


/*
  For menu item "Execute|Kill" we must start another thread,
  which connects and issues a Kill query-id.
  The kill thread has a subset of the actions of the debug thread so see also debug_thread.
  Possible variant: keep it alive and use it for monitoring.
*/
void* kill_thread(void* unused)
{
  (void) unused; /* suppress "unused parameter" warning */
#if (OCELOT_MYSQL_INCLUDE == 1)
  char call_statement[512];
  int is_connected;
  is_connected= 0;
  kill_state= KILL_STATE_CONNECT_THREAD_STARTED;
  for (;;)
  {
    if (options_and_connect(MYSQL_KILL_CONNECTION, ocelot_database_as_utf8))
    {
      kill_state= KILL_STATE_CONNECT_FAILED;
      break;
    }
    is_connected= 1;
    kill_state= KILL_STATE_IS_CONNECTED;
    sprintf(call_statement, "kill query %d", kill_connection_id);
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_KILL_CONNECTION], call_statement, strlen(call_statement)))
    {
      kill_state= KILL_STATE_MYSQL_REAL_QUERY_ERROR;
      break;
    }
    kill_state= KILL_STATE_ENDED;
    break;
  }
  if (is_connected == 1) lmysql->ldbms_mysql_close(&mysql[MYSQL_KILL_CONNECTION]);
  lmysql->ldbms_mysql_thread_end();
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  return ((void*) NULL);
}

bool is_kill_requested;

/*
  Todo: This is no good if the running query isn't
  on the main connection.
*/
void MainWindow::action_kill()
{
  pthread_t thread_id;

  if (connections_is_connected[0] != 1) return; /* impossible */
  is_kill_requested= true;
  if (dbms_long_query_state == LONG_QUERY_STATE_STARTED)
  {
    kill_connection_id= statement_edit_widget->dbms_connection_id;
    pthread_create(&thread_id, NULL, &kill_thread, NULL);
    /* no pthread_join here -- what would be the point of waiting? */
  }
}

#if (OCELOT_MYSQL_INCLUDE == 1)
/*
  Implementing ^C i.e. control-C i.e. menu item Run|Kill ...
  Once an SQL statement or SQL statement series has been accepted, user input
  is restricted to "kill" (a few other events are tolerated but not ones that cause statements),
  so around the loop inside action_execute() there is some enabling and disabling.
  SQL statements are done in a separate thread, dbms_long_query();
  in the main thread there is a wait-loop which stops when the thread ends;
  the wait-loop includes QApplication::ProcessEvents() so a "Kill" will be seen.
  "Kill" causes the SQL statement to end (if there's one running).
  ^C is an appropriate shortcut although it usually means "clip".
  Kill sets a flag so that if there are multiple statements, they are all aborted.
  dbms_long_query is only for potentially-slow SQL statements that might need to be killed.
  Todo: this could be done via a permanently-existing thread or pool of threads.
  Todo: QThread is more portable than pthread, although it looks harder to understand.
  Todo: put this together with the dbms_* routines in ocelotgui.h in a separate class.
  Normally dbms_query_connection_number is for the main connection.
*/
void* dbms_long_query_thread(void* unused)
{
  (void) unused; /* suppress "unused parameter" warning */

  dbms_long_query_result= lmysql->ldbms_mysql_real_query(&mysql[dbms_query_connection_number], dbms_query, dbms_query_len);
  dbms_long_query_state= LONG_QUERY_STATE_ENDED;
  return ((void*) NULL);
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

#if (OCELOT_MYSQL_INCLUDE == 1)
/* Todo: This assumes connection_number must be MYSQL_MAIN_CONNECTION */
void* dbms_long_next_result_thread(void* unused)
{
  (void) unused; /* suppress "unused parameter" warning */

  dbms_long_query_result= lmysql->ldbms_mysql_next_result(&mysql[MYSQL_MAIN_CONNECTION]);
  dbms_long_query_state= LONG_QUERY_STATE_ENDED;
  return ((void*) NULL);
}
#endif //#if (ocelot_MYSQL_INCLUDE == 1)

void MainWindow::action_execute_force()
{
  action_execute(1);
}

/*
  For menu item "execute" we said (...SLOT(action_execute(1))));
  By default this is on and associated with File|Execute menu item.
  Execute what's in the statement widget.
  The statement widget might contain multiple statements.
  Return: 0 = ok, 1 = syntax checker failed with "No"; 2 = DBMS error
*/
int MainWindow::action_execute(int force)
{
  QString text;
  int return_value= 0;
  log("action_execute start", 90);
  for (;;)
  {
    int returned_begin_count;
    main_token_number= 0;
    text= statement_edit_widget->toPlainText(); /* or I could just pass this to tokenize() directly */

    main_token_count_in_statement= get_next_statement_in_string(main_token_number,
                                                                &returned_begin_count,
                                                                true);
    if (main_token_count_in_statement == 0) break;
    /* If the next statement is unfinished, we usually want to ignore it. */
    if ((force == 0) && (is_statement_complete(text) == false)) return 1;

    /*
      We probably call hparse_f_multi_block continuously during statement edit,
      but this redundancy is harmless (we're not short of time, eh?).
      This checks for errors in the whole string, not just the first statement.
    */
    if (((ocelot_statement_syntax_checker.toInt()) & FLAG_FOR_ERRORS) != 0)
    {
      hparse_f_multi_block(text);
      /* TODO: QMessageBox jiggle, it displays then moves to centre */
      if ((hparse_errno != 0) || (hparse_errno_count != 0))
      {
        Message_box *message_box;
        message_box= new Message_box(er_strings[er_off + ER_THE_SYNTAX_CHECKER_THINKS], hparse_errmsg, 500,
                                     er_strings[er_off + ER_DO_YOU_WANT_TO_CONTINUE],
                                     er_strings[er_off + ER_YES], er_strings[er_off + ER_NO],
                                     this);
        message_box->exec();
        if (message_box->result == 2)
        {
          delete message_box;
          return 1;
        }
        delete message_box;
      }
      log("FLAG_FOR_ERRORS seen. end of if", 90);
    }
    /* While executing, we allow no more statements, but a few things are enabled. */
    /* This makes the menu seem to blink. If that's not OK, turn off sub-items not main menu items. */
    /* Todo: maybe other things should be disabled|enabled as we do with is_can_copy. */
    bool is_can_copy= menu_edit_action_copy->isEnabled();
    menu_file->setEnabled(false);
    menu_edit->setEnabled(false);
    menu_edit_action_copy->setEnabled(false);    
    menu_run_action_execute->setEnabled(false);
    if (ocelot_sigint_ignore == 0) menu_run_action_kill->setEnabled(true);
    menu_settings->setEnabled(false);
#if (OCELOT_MYSQL_DEBUGGER == 1)
    menu_debug->setEnabled(false);
#endif
    menu_help->setEnabled(false);
    statement_edit_widget->setReadOnly(true);
    is_kill_requested= false;
    return_value= action_execute_one_statement(text);
    menu_file->setEnabled(true);
    menu_edit->setEnabled(true);
    menu_edit_action_copy->setEnabled(is_can_copy);
    menu_run_action_execute->setEnabled(true);
    menu_run_action_kill->setEnabled(false);
    menu_settings->setEnabled(true);
#if (OCELOT_MYSQL_DEBUGGER == 1)
    menu_debug->setEnabled(true);
#endif
    menu_help->setEnabled(true);
    statement_edit_widget->setReadOnly(false);
    /*
      In remove_statement there is a removeSelectedText() call, which
      causes action_statement_edit_widget_text_changed() -- twice.
      We only want it to happen once, so we'll control it ourselves.
      Importantly, it will call tokenize() and hparse_f_multi_block()
      so main_token_... variables will all change.
      Todo: check again, I think the above statement might be false.
    */
    log("before remove_statement", 90);
    statement_edit_widget_text_changed_flag= 1;
    remove_statement(text);
    statement_edit_widget_text_changed_flag= 0;
    log("after remove_statement", 90);
    action_statement_edit_widget_text_changed(0, 0, 0);
    //widget_sizer();
    /* Try to set history cursor at end so last line is visible. Todo: Make sure this is the right time to do it. */
    history_edit_widget->verticalScrollBar()->setValue(history_edit_widget->verticalScrollBar()->maximum());
    history_edit_widget->show(); /* Todo: find out if this is really necessary */
    if (is_kill_requested == true) break;
  }
  log("action_execute end", 90);
  if (return_value != 0)
  {
    return 2;
  }
  return 0;
}

/*
  Remove the first statement in statement_edit_widget,
  including any whitespace after the statement end.
  This is equivalent to statement_edit_widget->clear() if there is only one statement.
  But when a user has cut-and-pasted several statements, we execute one at a time.
  There are other ways to do this e.g. clear() followed by insertText().
  Unanswered question: do we want to clear undo/redo history?
  Unanswered question: do we want to clear selection?
  Unanswered question: do we want to move the visible cursor?
*/
void MainWindow::remove_statement(QString text)
{
  //statement_edit_widget->clear(); /* ?? this is supposed to be a slot. does that matter? */

  QTextCursor q= statement_edit_widget->textCursor();

  int offset_of_statement_end= 0;

  if (main_token_count_in_statement > 0)
  {
    offset_of_statement_end= main_token_offsets[main_token_count_in_statement - 1]
                             + main_token_lengths[main_token_count_in_statement - 1];
  }

  for (;;)
  {
    QString c= text.mid(offset_of_statement_end, 1);
    if (c == "") break;
    if (c > " ") break;\
    ++offset_of_statement_end;
  }

  q.setPosition(0, QTextCursor::MoveAnchor);
  q.setPosition(offset_of_statement_end, QTextCursor::KeepAnchor);
  q.removeSelectedText();


  //q.select(QTextCursor::LineUnderCursor);

  //statement_edit_widget->textCursor().insertText(text);
}

/*
  Todo: There are a few things yet to be considered.
     I'm not 100% confident about the way I'm clearing the old results out, e.g. "delete result_form_text[...]".
     Would it be more efficient to remove only the ones between new column count and old column count?
       No, because data type can change, it might not be a text field the next time around.
     Should I be saying "delete later" somehow?
     Does memory leak?
*/
int MainWindow::action_execute_one_statement(QString text)
{
  log("action_execute_one_statement", 80);
  log(".. raw:: html", 1000);
  //QString text;
  MYSQL_RES *mysql_res_for_new_result_set= NULL;
  unsigned short int is_vertical= ocelot_vertical; /* true if --vertical or \G or ego */
  unsigned int ecs= 0; /* 1 means "is client statement" */
  unsigned return_value= 0;
  int ocelot_query_result= 0;
  ++statement_edit_widget->statement_count;
  /*
    Todo: There should be an indication that something is being executed.
    Possibly, on the title bar, setPlainText(tr("Executing ...")
    Possibly there should be a status widget or a progress bar.
    Whatever it is, turn it on now and turn it off when statement is done.
    Update: the Run|Execute menu item changes, which is slightly helpful.
  */
  /* Apparently there is no need for a call to tokenize() here, it seems certain that it's already been called. */
  int query_utf16_len= main_token_offsets[main_token_number+main_token_count_in_statement - 1]
                       + main_token_lengths[main_token_number+main_token_count_in_statement - 1]
                       - main_token_offsets[main_token_number];

  query_utf16= text.mid(main_token_offsets[main_token_number], query_utf16_len);

  QString last_token;
  bool strip_last_token= false;
  int length_of_last_token_in_statement= main_token_lengths[main_token_number + main_token_count_in_statement - 1];
  int type_of_last_token_in_statement= main_token_types[main_token_number + main_token_count_in_statement - 1];
  last_token= text.mid(main_token_offsets[main_token_number+main_token_count_in_statement - 1],
                       length_of_last_token_in_statement);
  if ((length_of_last_token_in_statement == 1) && ((type_of_last_token_in_statement == TOKEN_KEYWORD_EGO) || (type_of_last_token_in_statement == TOKEN_KEYWORD_GO)))
  {
    length_of_last_token_in_statement= 2;
    strip_last_token= true;
    if (type_of_last_token_in_statement == TOKEN_KEYWORD_EGO) is_vertical= 1;
  }

  /* Strip last word if it's delimiter or (when --named-commands, not only token) go|ego. */
  /* todo: this is obsolete now */
  if (last_token == ocelot_delimiter_str) strip_last_token= true;
  else if ((ocelot_named_commands > 0) && (main_token_count_in_statement > 1))
  {
    if (type_of_last_token_in_statement == TOKEN_KEYWORD_GO) strip_last_token= true;
    if (type_of_last_token_in_statement == TOKEN_KEYWORD_EGO)
    {
      strip_last_token= true;
      is_vertical= 1;
    }
  }
  if (strip_last_token == true)
  {
    query_utf16_copy= text.mid(main_token_offsets[main_token_number], query_utf16_len-length_of_last_token_in_statement);
  }
  else query_utf16_copy= query_utf16;

  statement_edit_widget->start_time= QDateTime::currentMSecsSinceEpoch(); /* will be used for elapsed-time display */
  int additional_result= 0;
  ecs= execute_client_statement(text, &additional_result);
  QString result_set_for_history= "";
  if (ecs != 1)
  {
    /* The statement was not handled entirely by the client, it must be passed to the DBMS. */

    bool do_something= true;

    /* If DBMS is not (yet) connected, except for certain SET ocelot_... statements, this is an error. */
    if (connections_is_connected[0] == 0)
    {
      if (ecs == 2) make_and_put_message_in_result(ER_OK, 0, (char*)"");
      else make_and_put_message_in_result(ER_NOT_CONNECTED, 0, (char*)"");
      do_something= false;
    }
    /* If --one-database, and USE caused default database to change, error */
    if ((ocelot_one_database > 0) && (ocelot_database != statement_edit_widget->dbms_database))
    {
      make_and_put_message_in_result(ER_ONE_DATABASE, 0, (char*)"");
      do_something= false;
    }

    if (do_something == true)
    {
      /* Look for a CREATE TABLE statement with a SERVER clause. */
      /* Todo: Make sure you only execute what's in utf16_copy */
      bool is_create_table_server;
#ifdef DBMS_TARANTOOL
      int result= create_table_server(text, &is_create_table_server, main_token_number, main_token_count_in_statement);
      dbms_long_query_result= result;
#else
      dbms_long_query_result= 0;
      is_create_table_server= false;
#endif
      if (is_create_table_server == false)
      {
        ocelot_query_result= execute_ocelot_query(query_utf16, MYSQL_MAIN_CONNECTION, &text);
        if (ocelot_query_result == ER_ERROR)
        {
          is_create_table_server= true; /* Fake. it's not create table server but should have same effect. */
          dbms_long_query_result= ocelot_query_result;
        }
        else
        {
          if (ocelot_query_result == -1) execute_real_query(query_utf16, MYSQL_MAIN_CONNECTION, &text);
          else dbms_long_query_result= ocelot_query_result;
        }
      }
      if (dbms_long_query_result)
      {
        /* beep() hasn't been tested because getting sound to work on my computer is so hard */
        if (ocelot_no_beep == 0) QApplication::beep();
        return_value= 1;
        if (is_create_table_server == false)
          put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
      }
      else {
        /*
          It was a successful SQL statement, and now look if it returned a result.
          If it did, as determined by looking at the mysql_res that lmysql->ldbms_mysql_store_result() returns,
          then free the previous mysql_res and delete the previous result grid,
          before setting up new ones.
          This means that statements which don't return result sets don't cause clearing
          of old result sets from the screen, e.g. SET has no effect on result grid.
          This means that momentarily there will be an old mysql_res and a new mysql_res.
          That takes up memory. If it were easy to check in advance whether a statement
          caused a result set (e.g. with mysql_next_result or by looking at whether the
          statement is SELECT SHOW etc.), that would be better.
        */
#ifdef DBMS_TARANTOOL
        if (connections_dbms[0] == DBMS_TARANTOOL)
        {
          if (tarantool_get_result_set(0, 0) == 0) goto statement_is_over; /* if zero result sets, stop */
          mysql_res_for_new_result_set= 0;
//          unsigned int main_token_flags_first;
//          int statement_type= get_statement_type(main_token_number, main_token_count_in_statement, &main_token_flags_first);
//          if ((statement_type == TOKEN_KEYWORD_SELECT)
//           || (statement_type == TOKEN_KEYWORD_VALUES)
//           || (statement_type == TOKEN_KEYWORD_LUA)
//           || ((main_token_flags_first & TOKEN_FLAG_IS_LUA) != 0))
          {
            int result_set_type;
            tarantool_result_set_init(0,&tarantool_row_count[MYSQL_MAIN_CONNECTION],&result_set_type);
            if ((result_set_type == RESULT_TYPE_0) || (result_set_type == RESULT_TYPE_1))
              mysql_res_for_new_result_set= 0;
            else
            {
              /* Yes mysql_res_for_new_result_set will be invalid. Fix, eh? */
              {
                MYSQL_RES r;
                mysql_res_for_new_result_set= &r;
              }
            }
          }
        }
        if (connections_dbms[0] != DBMS_TARANTOOL)
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
        mysql_res_for_new_result_set= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
#else
        {;}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
        if (mysql_res_for_new_result_set == 0)
        {
          /*
            Last statement did not cause a result set. We could hide the grid and shrink the
            central window with "result_grid_tab_widget[0]->hide()", but we don't.
          */
#if (OCELOT_MYSQL_INCLUDE == 1)
          get_sql_mode(main_token_types[main_token_number], text, false, main_token_number);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
          put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
        }
        else
        {
#ifdef DBMS_TARANTOOL
          if (connections_dbms[0] == DBMS_TARANTOOL)
          {
            /* TODO: Free the last reply, equivalent to mysql_free_result */
            /* (but not this early, because we might call extra_result_sets() */
          }
          else
#endif
          {
          if (mysql_res != 0)
            {
#if (OCELOT_MYSQL_INCLUDE == 1)
              lmysql->ldbms_mysql_free_result(mysql_res); /* This is the place we free if myql_more_results wasn't true, see below. */
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
            }
#if (OCELOT_MYSQL_INCLUDE == 1)
            mysql_res= mysql_res_for_new_result_set;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
            /* We need to think better what to do if we exceed MAX_COLUMNS */
            /* ... or maybe not, it seems we got rid of MAX_COLUMNS */
            /*
              Todo: consider whether it would be appropriate to set grid width with
              result_grid_tab_widget[0]->result_column_count= lmysql->ldbms_mysql_num_fields(mysql_res);
              but it may be unnecessary, and may cause a crash in garbage_collect()
            */
#if (OCELOT_MYSQL_INCLUDE == 1)
            result_row_count= lmysql->ldbms_mysql_num_rows(mysql_res);                /* this will be the height of the grid */
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
          }
          ResultGrid *rg;
          {
            for (int i_r= 0; i_r < ocelot_grid_actual_tabs; ++i_r)
            {
              rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(i_r));
              rg->is_paintable= 0;
              rg->fillup_garbage_collect(false);
              rg->display_garbage_collect(false);
            }
            rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));
            //QFont tmp_font;
            //tmp_font= rg->font();
            QString fillup_result= rg->fillup(mysql_res,
                      //&tarantool_tnt_reply,
                      connections_dbms[0],
                      //this,
                      lmysql, ocelot_client_side_functions,
                      MYSQL_MAIN_CONNECTION,
                      true);
            if (fillup_result != "OK")
            {
              /* fillup() failure is unexpected so this is crude */
              put_message_in_result(fillup_result);
              return_value= 1;
              goto statement_is_aborted;
            }
            rg->display(0,
                        ocelot_vertical,
                        ocelot_batch, ocelot_html, ocelot_raw, ocelot_xml,
                        ocelot_result_grid_column_names);
            result_grid_tab_widget->setCurrentWidget(rg);
            result_grid_tab_widget->tabBar()->hide();
            /* next line redundant? display() ends with show() */
            rg->show();
            result_grid_tab_widget->show(); /* Maybe this only has to happen once */
          }
          /*
            Following is no-op by default because ocelot_history_max_row_count=0
          */
          log("copy_to_history (before)", 80);
          if ((ocelot_grid_actual_tabs > 0)
           && (result_set_for_history == ""))
          {
            rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));
            result_set_for_history= rg->copy_to_history(ocelot_history_max_row_count.toLong(), is_vertical, connections_dbms[0], NULL);
          }
          log("copy_to_history (after)", 80);
          /* Todo: small bug: elapsed_time calculation happens before lmysql->ldbms_mysql_next_result(). */
          /* You must call lmysql->ldbms_mysql_next_result() + lmysql->ldbms_mysql_free_result() if there are multiple sets */
          put_diagnostics_in_result(MYSQL_MAIN_CONNECTION); /* Do this while we still have number of rows */
          //history_markup_append(result_set_for_history, true);
          int result_grid_table_widget_index= 1;
#ifdef DBMS_TARANTOOL
          if (connections_dbms[0] == DBMS_TARANTOOL)
          {
            int result_set_type;
            for (;;)
            {
              if (tarantool_get_result_set(0, result_grid_table_widget_index) == 0) break;
              tarantool_result_set_init(0,&tarantool_row_count[MYSQL_MAIN_CONNECTION],&result_set_type);
              extra_result_set(result_grid_table_widget_index, is_vertical);
              ++result_grid_table_widget_index;
            }
          }
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
          if ((connections_dbms[0] != DBMS_TARANTOOL)
           && (lmysql->ldbms_mysql_more_results(&mysql[MYSQL_MAIN_CONNECTION])))
          {
            lmysql->ldbms_mysql_free_result(mysql_res);
            /*
              We started with CLIENT_MULTI_RESULT flag (not CLIENT_MULTI_STATEMENT).
              We expect that a CALL to a stored procedure might return multiple result sets
              plus a status result at the end. The following lines try to pick up and display
              the extra result sets, up to a fixed maximum, and just throw away everything
              after that, to avoid the dreaded out-of-sync error message.
              If it's an ordinary select, lmysql->ldbms_mysql_free_result(mysql_res) happens later, see above.
            */
            log("sleep loop start", 90);
            for (;;)
            {
              dbms_long_query_state= LONG_QUERY_STATE_STARTED;
              pthread_t thread_id;
              pthread_create(&thread_id, NULL, &dbms_long_next_result_thread, NULL);

              for (;;)
              {
                QThread48::msleep(10);
                if (dbms_long_query_state == LONG_QUERY_STATE_ENDED) break;
                QApplication::processEvents();
              }
              pthread_join(thread_id, NULL);

              if (dbms_long_query_result != 0)
              {
                return_value= 1;
                /* If mysql_next_result) == 1 means error, -1 means no more. */
                /* TODO: don't do this for SOURCE. Check for beep. */
                if (dbms_long_query_result == 1)
                {
                  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
                  //history_markup_append("", true);
                }
                break;
              }
              mysql_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
              if (mysql_res == NULL) continue;
              extra_result_set(result_grid_table_widget_index, is_vertical);
              ++result_grid_table_widget_index;
              if (mysql_res != 0) lmysql->ldbms_mysql_free_result(mysql_res);
            }
            log("sleep loop end", 90);
            mysql_res= 0;
          }
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
        }
      }
      //put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
    }
  }
statement_is_over:
  /* statement is over */
  /* todo: bug: start of session has an elapsed time */
  if ((ecs == 0) && (connections_dbms[0] == DBMS_TARANTOOL) && (ocelot_query_result != ER_ERROR))
    put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
statement_is_aborted:
  log("action_execute_one_statement end", 80);
  if (additional_result != TOKEN_KEYWORD_SOURCE)
  {
    history_markup_append(result_set_for_history, true); /* add prompt+statement+result to history, with markup */
    tee_export(result_set_for_history);
  }
  return return_value;
}

/*
  Call this if there is more than one result set.
  From MySQL|MariaDB this can happen if a stored procedure has multiple SELECTs.
  From Tarantool this can happen if a start transaction ... commit|rollback block has multiple SELECTs.
  Make a tabbed widget and put the new result set in the latest tab.
  There is a maximum = result_grid_tabs. There are more commens preceding result_grid_add_tab().
*/
void MainWindow::extra_result_set(int result_grid_table_widget_index, unsigned short int is_vertical)
{
  /* todo: consider appending row count to result message */
  /* I think the following will help us avoid the "status" return. */
  if (result_grid_table_widget_index == ocelot_grid_actual_tabs)
  {
    result_grid_add_tab();
  }

  if (result_grid_table_widget_index < ocelot_grid_actual_tabs)
  {
    ResultGrid* r;
    r= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(result_grid_table_widget_index));
    result_grid_tab_widget->tabBar()->show(); /* is this in the wrong place? */
    if (connections_dbms[0] == DBMS_TARANTOOL)
    { result_row_count= 1; } /* TODO: YOU OUGHT TO BE DOING SOMETHING! */
#if (OCELOT_MYSQL_INCLUDE == 1)
    else
      result_row_count= lmysql->ldbms_mysql_num_rows(mysql_res);                /* this will be the height of the grid */
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
    QString fillup_result= r->fillup(mysql_res,
              //&tarantool_tnt_reply,
              connections_dbms[0],
              //this,
              lmysql,
              ocelot_client_side_functions,
              MYSQL_MAIN_CONNECTION,
              true);

    /* TODO: Check that fillup() returned "OK" before you call display() */
    /*       If fillup_result <> "Ok" pass back up the line */
    /* TODO: this had rg-> rather than r->. I don't know why. Do we need to do more checking? */
    r->display(0,
                is_vertical,
                ocelot_batch, ocelot_html, ocelot_raw, ocelot_xml,
                ocelot_result_grid_column_names);
    /* next line redundant? display() ends with show() */
    /* what is r? */
    /* TODO: REMOVE IT!!!! */
//    r->show();

    //Put in something based on this if you want extra results to go to history:
    //... result_grid_table_widget[result_grid_table_widget_index]->copy_to_history(); etc.
  }
}

/*
  Bottom-level call to DBMS.
  We call this when we know that there will be no more change
  to the query (no local-subquery substitution, but maybe
  stripping of comments and delimiters other than ;).
  During this query we allocate or use globals:
  dbms_query, dbms_query_len, dbms_query_connection.
  The query might go to either the main or the local
  connection, the local connection might be either
  mysql or tarantool.
  Todo: Tarantool can't be killed so easily. Make a fiber?
*/
int MainWindow::execute_real_query(QString query, int connection_number, const QString *alltext)
{
  log("execute_real_query start", 80);
#if (OCELOT_MYSQL_INCLUDE == 1)
  /*
    If the last error was CR_SERVER_LOST 2013 or CR_SERVER_GONE_ERROR 2006,
    and it might be possible to reconnect, try.
    But if mysql_ping() fails, I don't see much that we can do.
  */
  if ((mysql_errno_result == 2006) || (mysql_errno_result == 2013))
  {
    if (ocelot_opt_reconnect > 0) lmysql->ldbms_mysql_ping(&mysql[MYSQL_MAIN_CONNECTION]);
  }
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  /* todo: figure out why you used global dbms_query for this */
  /* TODO: BUG. This statement caused a crash when ocelot_comments == 0:
         create procedure p27 ()
           begin
           declare xxx int;
           declare yyy int;
           set xxx = 0;
           while xxx < 1000 do
             set xxx = xxx;
             set xxx = xxx + 1;
             end while;
           end
      We work around it by allocating double what we need for dbms_query. */
  dbms_query_len= query.toUtf8().size();           /* See comment "UTF8 Conversion" */
  dbms_query= new char[(dbms_query_len + 1) * 2];
  dbms_query_len= make_statement_ready_to_send(query,
                                               dbms_query,
                                               dbms_query_len + 1,
                                               connection_number);
  assert(strlen(dbms_query) < ((unsigned int) dbms_query_len + 1) * 2);
  dbms_query_connection_number= connection_number;
#ifdef DBMS_TARANTOOL
  /* todo: for tarantool as for mysql, call with a separate thread so it's killable and so processsEvents() happens. */
  if (connections_dbms[connection_number] == DBMS_TARANTOOL)
  {
    dbms_long_query_result= tarantool_real_query(dbms_query, dbms_query_len, MYSQL_MAIN_CONNECTION, main_token_number, main_token_count_in_statement, alltext);
    dbms_long_query_state= LONG_QUERY_STATE_ENDED;
  }
  else
#endif
  {
#if (OCELOT_MYSQL_INCLUDE == 1)
    pthread_t thread_id;
    dbms_long_query_state= LONG_QUERY_STATE_STARTED;
    pthread_create(&thread_id, NULL, &dbms_long_query_thread, NULL);
    for (;;)
    {
      QThread48::msleep(10);
      if (dbms_long_query_state == LONG_QUERY_STATE_ENDED) break;
      QApplication::processEvents();
    }
    pthread_join(thread_id, NULL);
    //     dbms_long_query_result= lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], dbms_query, dbms_query_len);
    //     dbms_long_query_state= LONG_QUERY_STATE_ENDED;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  }
  delete []dbms_query;
  log("execute_real_query return", 80);
  return dbms_long_query_result;
}

/*
  Called from ocelot_execute_one_statement(), check for "SET ocelot_query =" before calling execute_real_query.
  At the last moment, hijack what's intended for execute_real_query, do whatever is in the string after "=",
  and return something that will look as if we did execute_real_query with the query that the user asked for
  (we actually return a union of selects of literals thus avoiding need for create privileges).
  So far this is only for SET ocelot_query = show foreign keys of [table_schema.]table_name; and
                          SET ocelot_query = show erdiagram of table_schema [options];
  The statement can be generated by an explorer option.
  Todo: "Foreign Key Relationship Diagram" (like an Entity-Relationship Diagram) (idea may be superseded now?)
        Show one table with mono-font ASCII text and arrows (later see how to show with HTML)
        Outgoing and incoming arrows on the right.
        Different colour for each FK.
        Adherence to ER pattern requirements as much as seems reasonable.
        If connected to Tarantool, or unexpected format, just call execute_real_query.
        Allow SHOW INDEXES OF table, + show procedure and trigger relationships somehow
        If a table has more than one foreign key we could do a horizontal rather than vertical display e.g.
            Table#1      Foreign Key #1   Foreign Key #2
                         On Table #2      On Table #2
            -----        --------------   --------------
            Column#1     Column           Column
            Column#2     Column
            Column#3                      Column
  Todo: As in crlf() we could say sorry this won't work unless syntax checker on, or maybe we could call
        hparse_f_multi, instead of doing the specific parsing in this function.
  Todo: This is a bit obsolete now because when we make explorer visible we permanently set up oei_fk[]
*/
/* 10 is enough but there might be comments. (No, I think tokenize() will ignore comments.) */
#define MAX_OCELOT_STATEMENT_TOKENS 20
int MainWindow::execute_ocelot_query(QString query, int connection_number, const QString *alltext)
{
  char error_or_ok_message[ER_MAX_LENGTH];
#ifdef DBMS_TARANTOOL
//  if (connections_dbms[connection_number] == DBMS_TARANTOOL) return -1;
#endif
  int real_return;
  int token_offsets[MAX_OCELOT_STATEMENT_TOKENS];
  int token_lengths[MAX_OCELOT_STATEMENT_TOKENS];
  tokenize(query.data(),
           query.size(),
           &token_lengths[0], &token_offsets[0], MAX_OCELOT_STATEMENT_TOKENS - 1,
          (QChar*)"33333", 2, "", 1);
  int query_type= 0;
  unsigned int i;
  QString table_name= "";
  QString schema_name= "";
  bool is_invalid_query= false;
//  int option= 0;
  for (int j= 0;; ++j)
  {
    QString token= query.mid(token_offsets[j], token_lengths[j]);
    token= token.toUpper();
    if ((j == 0) && (token != "SET")) {is_invalid_query= true; break; }
    if ((j == 1) && (token != "OCELOT_QUERY")) {is_invalid_query= true; break; }
    if ((j == 2) && (token != "=")) {is_invalid_query= true; break; }
    if ((j == 3) && (token != "SHOW")) {is_invalid_query= true; break; }
    if ((j == 4) && (token != "FOREIGN")) {is_invalid_query= true; break; }
    if ((j == 5) && (token != "KEYS")) {is_invalid_query= true; break; }
    if ((j == 6) && (token != "OF")) {is_invalid_query= true; break; }
    if (j == 7) table_name= token;
    if ((j == 8) && (token != ".")) break;
    if (j == 9) {schema_name= table_name; table_name= token; break; }
  }
  if (is_invalid_query == false) query_type= TOKEN_KEYWORD_FOREIGN;
  else
  {
    is_invalid_query= false;
    for (int j= 0;; ++j)
    {
      QString token= query.mid(token_offsets[j], token_lengths[j]);
      token= token.toUpper();
      if ((j == 0) && (token != "SET")) {is_invalid_query= true; break; }
      if ((j == 1) && (token != "OCELOT_QUERY")) {is_invalid_query= true; break; }
      if ((j == 2) && (token != "=")) {is_invalid_query= true; break; }
      if ((j == 3) && (token != "SHOW")) {is_invalid_query= true; break; }
      if ((j == 4) && (token != "ERDIAGRAM")) {is_invalid_query= true; break; }
      if ((j == 5) && (token != "OF")) {is_invalid_query= true; break; }
      if (j == 6)
      {
        if (token_lengths[j] == 0) {is_invalid_query= true; break; }
        schema_name= query.mid(token_offsets[j], token_lengths[j]);
      }
      if (j == 7) break;
    }
    if (is_invalid_query == true) return -1;
    query_type= TOKEN_KEYWORD_ERDIAGRAM;
  }
  if (query_type == TOKEN_KEYWORD_ERDIAGRAM)
  {
    if (ocelot_explorer_visible == "no")
    {
      put_message_in_result("Error. SHOW ERDIAGRAM only works if explorer is visible. To make it visible, use Settings|Explorer or SET ocelot_explorer_visible='yes';");
      return ER_ERROR;
    }
#if (OCELOT_ERDIAGRAM == 1)
  if (oei_count != 0) /* Actually, since explorer is visible, we can be sure oei_count != 0, eh? */
  {
    schema_name= connect_stripper(schema_name, false);
    ERDiagram *erdiagram_widget= new ERDiagram(this, schema_name, query);
    erdiagram_widget->exec(); /* or maybe I should say open() and setModal(false)? */
  }
#endif
    return 1;
  }

  /* rest of this routine is for query_type == TOKEN_KEYWORD_FOREIGN */

  table_name= connect_stripper(table_name, false);
  schema_name= connect_stripper(schema_name, false);
  if (table_name == "") return -1;
  unsigned int saved_rehash_result_row_count= result_row_count;
  QString query2= "SELECT 'D',database(),'','','','' "
                  "UNION ALL "
                  "SELECT table_name, column_name, ordinal_position, "
                  "constraint_name, "
                  "referenced_table_name, referenced_column_name "
                  "FROM information_schema.key_column_usage "
                  "WHERE table_name = '";
   query2= query2 + table_name;
   query2= query2 + "' AND referenced_column_name IS NOT NULL ";
   if (schema_name == "") query2= query2 + " AND table_schema = database() ";
   else query2= query2 + " AND table_schema = '" + schema_name + "' ";
   query2= query2 + " ORDER BY 4, 3;";

  int rehash_scan_result= rehash_scan(error_or_ok_message, query2);
  if (rehash_scan_result != ER_OK_REHASH)
  {
    put_message_in_result(error_or_ok_message);
    return 1;
  }
  long int r;
  char *row_pointer;
  int column_length;
  QString d_table_name, d_column_name, d_ordinal_position, d_constraint_name, d_referenced_table_name, d_referenced_column_name;
  QString fks= "";
  int counter= 0;
  for (r= 0; r < rehash_result_row_count; ++r)
  {
    row_pointer= rehash_result_set_copy_rows[r];
    for (i= 0; i < rehash_result_column_count; ++i)
    {
      memcpy(&column_length, row_pointer, sizeof(unsigned int));
      //char flag= *(row_pointer + sizeof(unsigned int));
      row_pointer+= sizeof(unsigned int) + sizeof(char);
      /* Now row_pointer points to contents, length has # of bytes */
      QByteArray m(row_pointer, column_length);
      if (i == 0) d_table_name= QString(m);
      if (i == 1) d_column_name= QString(m);
      if (i == 2) d_ordinal_position= QString(m);
      if (i == 3) d_constraint_name= QString(m);
      if (i == 4) d_referenced_table_name= QString(m);
      if (i == 5) d_referenced_column_name= QString(m);
      row_pointer+= column_length;
    }
    if (r == 0) continue;
    if (counter > 0)
      fks= fks + "UNION ALL\n";
//    if ((counter != 0) && (d_ordinal_position == "1"))
//    {
//      fks= fks + "SELECT '', '', '', '', ''\n";
//      fks= fks + "UNION ALL\n";
//    }
    if (d_ordinal_position == "1")
    {
      fks= fks + "SELECT '" + d_constraint_name + "' AS `Name`,'" + d_table_name + "' AS `Table`,'" + d_column_name + "' AS `Column`,'" + d_referenced_table_name + "' AS `Referenced Table`,'" + d_referenced_column_name + "' AS `Referenced column`\n";
    }
    else
    {
      fks= fks + "SELECT '" + d_constraint_name + "' AS `Name`,'" + d_table_name + "' AS `Table`,'" + d_column_name + "' AS `Column`,'" + d_referenced_table_name + "' AS `Referenced Table`,'" + d_referenced_column_name + "' AS `Referenced column`\n";
    }
    ++counter;
  }
  fks= fks + ";";

  /* If we wrecked the global rehash_scan result that's used ordinarily we'll have to call rehash_scan again. */
  if (saved_rehash_result_row_count != 0) rehash_scan(error_or_ok_message, "");
  else rehash_garbage_collect();

  int fks_query_len= fks.toUtf8().size();                  /* See comment "UTF8 Conversion" */
  char *fks_query= new char[fks_query_len + 1];
  strcpy(fks_query, fks.toUtf8());
  real_return= execute_real_query(fks_query, connection_number, alltext);
  delete []fks_query;
  return real_return;
}

/*
  We see "DELIMITER".
  If the thing that follows is 'literal' or "literal" or `identifier`: that's the delimiter.
  Otherwise delimiter is what follows as far as next whitespace or eof or ;
  DELIMITER ; means "go back to the default i.e. ;".
  This is called from hparse_f_client_statement() because it affects parse of later statements.
  This is called from execute_client_statement() because DELIMITER is a client statement.
  One difference from mysql client:
    If mysql client sees "DELIMITER <return>" or "DELIMITER ''" it's an error.
    But we consider that equivalent to "DELIMITER ;"
  We return ";" if nothing follows or quoted blank string follows; mysql client would say error.
*/
QString MainWindow::get_delimiter(QString token, QString text, int offset)
{
  QString token_to_return;
  if ((token.mid(0, 1) == "`") || (token.mid(0, 1) == "'") || (token.mid(0, 1) == "\""))
  {
    token_to_return= connect_stripper(token, false);
  }
  else
  {
    token_to_return= "";
    for (int i= offset;; ++i)
    {
      QString c= text.mid(i, 1);
      if (c <= " ") break;
      if (c == ";")
      {
        if (token_to_return == "") token_to_return= ";";
        break;
      }
      token_to_return.append(c);
    }
  }
  return token_to_return;
}


/*
  Get a value that would be would be legal as input.
  Called from execute_client_statement()
  Legal values are: "yes" or "no"
  Return = input (stripped, lower case if string), or "" which means "INVALID"
*/
QString MainWindow::detached_value(QString input)
{
  QString ccn= connect_stripper(input, false);
  ccn= ccn.toLower();
  if ((ccn == "no") || (ccn == "yes")) return ccn;
  return "";
}

/*
  Get a value that would be would be legal as input.
  Called from execute_client_statement()
  Legal values are: "default" or integer >= 0
  Return = input (stripped, lower case if string), or "" which means "INVALID"
*/
QString MainWindow::rect_value(QString input)
{
  QString ccn= connect_stripper(input, false);
  ccn= ccn.toLower();
  if (ccn == "default") return ccn;
  bool toint_is_ok;
  int toint_result;
  toint_result= ccn.toInt(&toint_is_ok);
  if ((toint_is_ok == false) || (toint_result < 0)) return "";
  return ccn;
}


/*
 Handle "client statements" -- statements that the client itself executes.
  Possible client statements:
  DELIMITER delimiter
  CONNECT ... (Todo: CONNECT depends entirely on settings, it should be possible to have arguments)
*/


/*
  Todo: We want all the mysql commands to work just the way that they work in mysql.
        We will not depend on TOKEN_KEYWORD_... for this because "\" and "q" are separate tokens,
        and "q| is case sensitive.
*/

#define MAX_SUB_TOKENS 22
int MainWindow::execute_client_statement(QString text, int *additional_result)
{
  log("execute_client_statement", 70);
//  int i= 0;
  int i2= 0;
  int  sub_token_offsets[MAX_SUB_TOKENS + 2];
  int  sub_token_lengths[MAX_SUB_TOKENS + 2];
  int  sub_token_types[MAX_SUB_TOKENS + 2];
  int true_text_size, true_token_count; /* size and count ignoring delimiter */
  //QString text;                      /* Todo: see if text should be a global */
  unsigned int statement_type;

  for (int i= main_token_number;; ++i)
  {
    if (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_SLASH
    ||  main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE
    ||  main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_MINUS) continue;
    if (main_token_lengths[i] == 0)
    {
      statement_type= 0;
      break;
    }
    statement_type= main_token_types[i];
    break;
  }

  //text= statement_edit_widget->toPlainText(); /* or I could just pass this to tokenize() directly */

  /* Calculate size. Don't count delimiter unless it's a delimiter statement. */
  true_text_size= query_utf16_copy.size();

  int query_utf16_size= query_utf16.size();
  int query_utf16_copy_size= query_utf16_copy.size();
  if ((query_utf16_size == query_utf16_copy_size) || (statement_type == TOKEN_KEYWORD_DELIMITER))
  {
    /* there was no delimiter, or there was a delimiter but it's a delimiter statement */
    true_text_size= query_utf16_size;
    true_token_count= main_token_count_in_statement;
  }
  else
  {
    /* There was a delimiter, and it's not a delimiter statement */
    true_text_size= query_utf16_copy_size;
    true_token_count= main_token_count_in_statement - 1;
  }

  /* Make a copy of the first few tokens, ignoring comments. */
  /* And ignore the first token if it is \ because second token is the same */
  for (unsigned int i= main_token_number; /* main_token_lengths[i] != 0 && */ i < main_token_number + true_token_count; ++i)
  {
    /* Todo: find out why you have to figure out type again -- isn't it already known? */
    QString s= text.mid(main_token_offsets[i], main_token_lengths[i]);
    int t= token_type(s.data(), main_token_lengths[i], sql_mode_ansi_quotes);
    if (t == TOKEN_TYPE_COMMENT_WITH_SLASH
    ||  t == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE
    ||  t == TOKEN_TYPE_COMMENT_WITH_MINUS) continue;
    if ((i2 == 0) && (s == "\\"))
    {
      continue;
    }
    sub_token_offsets[i2]= main_token_offsets[i];
    sub_token_lengths[i2]= main_token_lengths[i];
    sub_token_types[i2]= main_token_types[i];
    ++i2;
    if (i2 > MAX_SUB_TOKENS) break;
  }
  sub_token_offsets[i2]= 0;
  sub_token_lengths[i2]= 0;
  sub_token_types[i2]= 0;

  /*
    CONNECT or \r.
    Defaults should have been set earlier. The user had a chance to change the defaults with SET.
    Currently the only possible dbms is "mysql", otherwise nothing happens.
    (or Tarantool, eh?)
    Ignore any other words in the statement.
    Todo: accept the mysql-client syntax, which has a few extras on it for reconnect.
    Todo: connect_mysql() returns an int, find out why you're not looking at it
  */
  /* Todo: We could easily modify so that we don't need sub_token_..., we could just skip comments. */
  if (statement_type == TOKEN_KEYWORD_CONNECT)
  {
    history_file_to_history_widget(); /* TODO: Maybe this is the wrong time to call? */
    QString rr;
    history_file_start("HIST", ocelot_history_hist_file_name, &rr);
#if (OCELOT_MYSQL_INCLUDE == 0)
    if ((ocelot_dbms.contains("mysql", Qt::CaseInsensitive) == true) || (ocelot_dbms.contains("mariadb", Qt::CaseInsensitive) == true))
    {
      printf("Built with OCELOT_MYSQL_INCLUDE=0 so ocelot_dbms cannot be 'mysql' or 'mariadb'.\n");
      exit(1);
    }
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
    if (connections_dbms[0] == DBMS_MYSQL) connect_mysql(MYSQL_MAIN_CONNECTION);
#ifdef DBMS_MARIADB
    if (connections_dbms[0] == DBMS_MARIADB) connect_mysql(MYSQL_MAIN_CONNECTION);
#endif
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
    if (connections_dbms[0] == DBMS_TARANTOOL) connect_tarantool(MYSQL_MAIN_CONNECTION, "DEFAULT", "DEFAULT", "DEFAULT", "DEFAULT");
#endif
    if (ocelot_prompt_is_default == true) prompt_default();
    return 1;
  }
  /* Todo: this isn't robust, it will fail if we ever allow other words e.g. IF NOT EXISTS after CREATE. */
  if ((statement_type == TOKEN_KEYWORD_CREATE)
   && (sub_token_types[1] == TOKEN_KEYWORD_LUA))
  {
    if ((sub_token_types[2] == TOKEN_KEYWORD_PROCEDURE)
     || (sub_token_types[2] == TOKEN_KEYWORD_FUNCTION))
    {
      clf(text);
      return 1;
    }
  }


#ifdef DBMS_TARANTOOL
  /*
    CREATE SERVER id FOREIGN DATA WRAPPER tarantool
    OPTIONS (PORT ..., HOST ..., PASSWORD, ... USER ...)
    Do Tarantool connect for the sake of create_table_server.
    Todo: check port isn't re-used
  */
  if ((statement_type == TOKEN_KEYWORD_CREATE)
   && (sub_token_types[1] == TOKEN_KEYWORD_SERVER)
   && (sub_token_lengths[2] != 0)
   && (sub_token_types[3] == TOKEN_KEYWORD_FOREIGN)
   && (sub_token_lengths[4] != 0)
   && (sub_token_types[5] != 0)
   && (sub_token_lengths[6] != 0))
  {
    QString wrapper_name= text.mid(sub_token_offsets[6], sub_token_lengths[6]);
    wrapper_name= connect_stripper(wrapper_name, true);
    wrapper_name= wrapper_name.toUpper();
    if (wrapper_name == "OCELOT_TARANTOOL")
    {
      QString create_server_port= "DEFAULT";
      QString create_server_host= "DEFAULT";
      QString create_server_password= "DEFAULT";
      QString create_server_user= "DEFAULT";
      QString curr, prev;
      for (int i= 9; ; ++i)
      {
        if ((i >= MAX_SUB_TOKENS) || (sub_token_lengths[i] == 0))
        {
          make_and_put_message_in_result(ER_CREATE_SERVER_SYNTAX, 0, (char*)"");
          return 1;
        }
        curr= text.mid(sub_token_offsets[i], sub_token_lengths[i]);
        if (curr == ")") break;
        if ((main_token_types[i] >= TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE)
         && (main_token_types[i] <= TOKEN_TYPE_LITERAL_WITH_BRACE))
        {
          if (prev == "PORT") create_server_port= connect_stripper(curr, true);
          if (prev == "HOST") create_server_host= connect_stripper(curr, true);
          if (prev == "PASSWORD") create_server_password= connect_stripper(curr, true);
          if (prev == "USER") create_server_user= connect_stripper(curr, true);
        }
        prev= curr.toUpper();
      }
      int result= connect_tarantool(MYSQL_REMOTE_CONNECTION,
                                    create_server_port,
                                    create_server_host,
                                    create_server_password,
                                    create_server_user);
      if (result == 0)
      {
        tarantool_server_name= connect_stripper(text.mid(sub_token_offsets[2], sub_token_lengths[2]), true);
        connections_dbms[MYSQL_REMOTE_CONNECTION]= DBMS_TARANTOOL;
      }
      else
      {
        tarantool_server_name= "";
        connections_dbms[MYSQL_REMOTE_CONNECTION]= 0;
      }
      return 1;
    }
  }
#endif

  /* QUIT or \q. mysql equivalent. Todo: add to history box before exiting. */
  if ((statement_type == TOKEN_KEYWORD_QUIT)
  ||  (statement_type == TOKEN_KEYWORD_EXIT))
  {
    action_exit();
    return 1;
  }

  /*
     CLEAR or \c: mysql equivalent.
     Really this just means "ignore the statement".
     It goes into history though.
  */
  if (statement_type == TOKEN_KEYWORD_CLEAR)
  {
    return 1;
  }

#if (OCELOT_MYSQL_INCLUDE == 1)
  /* USE or \u: mysql equivalent. */
  if (statement_type == TOKEN_KEYWORD_USE)
  {
    QString s;
    int mysql_select_db_result;
    if ((i2 >= 2) && (sub_token_types[0] == TOKEN_KEYWORD_USE)) s= text.mid(sub_token_offsets[1], sub_token_lengths[1]);
    else if (i2 >= 3) s= text.mid(sub_token_offsets[2], sub_token_lengths[2]);
    else
    {
      make_and_put_message_in_result(ER_USE, 0, (char*)"");
      return 1;
    }
    /* If database name is in quotes or delimited, strip. Todo: stripping might be necessary in lots of cases. */
    s= connect_stripper(s, false);
    int query_len= s.toUtf8().size();                  /* See comment "UTF8 Conversion" */
    char *query= new char[query_len + 1];
    memcpy(query, s.toUtf8().constData(), query_len + 1);

    mysql_select_db_result= lmysql->ldbms_mysql_select_db(&mysql[MYSQL_MAIN_CONNECTION], query);
    delete []query;
    if (mysql_select_db_result != 0) put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
    else
    {
      statement_edit_widget->dbms_database= s;
      if (ocelot_auto_rehash != 0)
      {
        char error_or_ok_message[ER_MAX_LENGTH];
        int i= rehash_scan(error_or_ok_message, "");
        if (i == ER_OK_REHASH)
        {
          put_message_in_result(error_or_ok_message);
          return 1;
        }
      }
      make_and_put_message_in_result(ER_DATABASE_CHANGED, 0, (char*)"");
    }
    return 1;
  }
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

  /* SOURCE or \.: mysql equivalent. */
  if (statement_type == TOKEN_KEYWORD_SOURCE)
  {
    /* Everything as far as statement end is source file name. Todo: so why connect_stripper? */
    QString s;
    unsigned statement_length= /* text.size() */ true_text_size;
    if (i2 >= 2) s= text.mid(sub_token_offsets[1], statement_length - (sub_token_offsets[1] - sub_token_offsets[0]));
    else
    {
      make_and_put_message_in_result(ER_SOURCE, 0, (char*)"");
      return 1;
    }
    s= connect_stripper(s, true);
    read_file(TOKEN_KEYWORD_SOURCE, s, "");
    /* Without the following, the final line of source would go into the history twice. */
    *additional_result= TOKEN_KEYWORD_SOURCE;
    return 1;
  }

  /* PROMPT or \R: mysql equivalent. */
  /* This overrides the default setting which is made from ocelot_prompt during connect. */
  if (statement_type == TOKEN_KEYWORD_PROMPT)
  {
    QString s;
    unsigned statement_length= true_text_size /* text.size() */;
    if ((i2 >= 2) && (sub_token_types[1] != TOKEN_KEYWORD_USE))
      s= text.mid(sub_token_offsets[1], statement_length - (sub_token_offsets[1] - sub_token_offsets[0]));
    else if (i2 >= 3) s= text.mid(sub_token_offsets[2], statement_length - (sub_token_offsets[1] - sub_token_offsets[0]));
    else if (i2 == 1)
    {
      prompt_default(); /* Just "prompt" or "prompt;" with no args */
      return 1;
    }
    else
    {
      ocelot_prompt_is_default= false; /* todo: check: shouldn't this be true? */
      statement_edit_widget->prompt_as_input_by_user= statement_edit_widget->prompt_default;
      ocelot_prompt= statement_edit_widget->prompt_default;
    emit statement_edit_widget->update_prompt_width(0); /* not necessary with Qt 5.2 */
      /* Todo: output a message */
      return 1;
    }
    statement_edit_widget->prompt_as_input_by_user= s;
    ocelot_prompt= s;
    emit statement_edit_widget->update_prompt_width(0); /* not necessary with Qt 5.2 */
    ocelot_prompt_is_default= false;
    make_and_put_message_in_result(ER_OK, 0, (char*)"");
    return 1;
  }

  /* WARNINGS or \W: mysql equivalent. This overrides a command-line option. */
  if (statement_type == TOKEN_KEYWORD_WARNINGS)
  {
    ocelot_history_includes_warnings= 1;
    make_and_put_message_in_result(ER_OK, 0, (char*)"");
    return 1;
  }

  /* NOWARNING or \w: mysql equivalent. This overrides a command-line option. */
  if (statement_type == TOKEN_KEYWORD_NOWARNING)
  {
    ocelot_history_includes_warnings= 0;
    make_and_put_message_in_result(ER_OK, 0, (char*)"");
    return 1;
  }

  /* DELIMITER or \d: mysql equivalent. */
  if (statement_type == TOKEN_KEYWORD_DELIMITER)
  {
    QString s= text.mid(sub_token_offsets[1], sub_token_lengths[1]);
    QString s_result= get_delimiter(s, text, sub_token_offsets[1]);
    if (s_result == "")
    {
      make_and_put_message_in_result(ER_DELIMITER, 0, (char*)"");
      return 1;
    }
    ocelot_delimiter_str= s_result;
    make_and_put_message_in_result(ER_OK, 0, (char*)"");
    return 1;
    }

  /* Todo: the following are placeholders, we want actual actions like what mysql would do. */
  if (statement_type == TOKEN_KEYWORD_QUESTIONMARK)
  {
    make_and_put_message_in_result(ER_HELP, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_CHARSET)
  {
    make_and_put_message_in_result(ER_CHARSET, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_EDIT)
  {
    make_and_put_message_in_result(ER_EDIT, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_EGO)
  {
    make_and_put_message_in_result(ER_EGO, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_GO)
  {
    make_and_put_message_in_result(ER_GO, 0, (char*)"");
  }
  if (statement_type == TOKEN_KEYWORD_HELP_IN_CLIENT)
  {
    make_and_put_message_in_result(ER_HELP, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_NOPAGER)
  {
    make_and_put_message_in_result(ER_NOPAGER, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_NOTEE) /* see comment=tee+hist */
  {
    history_file_stop("TEE");
    make_and_put_message_in_result(ER_OK, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_PAGER)
  {
    make_and_put_message_in_result(ER_PAGER, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_PRINT)
  {
    make_and_put_message_in_result(ER_PRINT, 0, (char*)"");
    return 1;
  }
#if (OCELOT_EXPLORER == 1)
  if (statement_type == TOKEN_KEYWORD_REFRESH)
   {
     char error_or_ok_message[ER_MAX_LENGTH];
     explorer_refresh_caller(error_or_ok_message); /* todo: this returns an int result which we don't use */
     put_message_in_result(error_or_ok_message);
     return 1;
   }
#endif
  if (statement_type == TOKEN_KEYWORD_REHASH)   /* Regardless whether ocelot_auto_rehash = 1 */
  {
    char error_or_ok_message[ER_MAX_LENGTH];
    rehash_scan(error_or_ok_message, ""); /* We don't check if return = ER_OK but if it failed then rehash_result_row_count = 0 */
    put_message_in_result(error_or_ok_message);
    return 1;
  }
  /* TODO: "STATUS" should output as much information as the mysql client does. */
  /* Todo: connections_is_connected is still 1 after lost connection or SHUTDOWN, fix that somewhere */
  if (statement_type == TOKEN_KEYWORD_STATUS)
  {
    if (connections_is_connected[0] != 1) make_and_put_message_in_result(ER_NOT_CONNECTED, 0, (char*)"");
    else
    {
      char dbms_version[256];
      char dbms_host[256];
      char dbms_port[256];
      char buffer[1024];
      strcpy(dbms_version, statement_edit_widget->dbms_version.toUtf8());
      strcpy(dbms_host, statement_edit_widget->dbms_host.toUtf8());
      strcpy(dbms_port, statement_edit_widget->dbms_port.toUtf8());
      sprintf(buffer, er_strings[er_off + ER_STATUS], dbms_version, dbms_host, dbms_port);
#ifdef DBMS_TARANTOOL
      if (connections_dbms[0] == DBMS_TARANTOOL)
      {
        char tmp[32];
        sprintf(tmp, " iproto_schema_version = %lu", (long) tarantool_tnt_reply.schema_id);
        strcat(buffer, tmp);
      }
#endif
      put_message_in_result(buffer);
    }
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_SYSTEM)
  {
    /*
      With mysql client "system ls" would do an ls with system. We use popen not system.
      I don't know whether there is a Windows equivalent; mysql client doesn't support one.
      So the easiest thing for a Windows port is:
      make_and_put_message_in_result(tr("SYSTEM is not implemented."));
      Todo: allow "kill" -- some research required about how to stop a shell command.
      Todo: reconsider: maybe output should go to result grid rather than history.
    */
    QString s;
    unsigned statement_length= true_text_size /* text.size() */;
    s= text.mid(sub_token_offsets[1], statement_length - (sub_token_offsets[1] - sub_token_offsets[0]));
    char *command_string= new char[s.size() + 1];
    memcpy(command_string, s.toUtf8().constData(), s.size() + 1);
    put_message_in_result(""); /* unnecessary? */
    FILE *fp;
    int status;
    char result_line[STRING_LENGTH_512]; /* arbitrary maximum expected line length */
    fp= popen(command_string, "r");
    if (fp == NULL) make_and_append_message_in_result(ER_POPEN_FAILED, 0, (char*)"");
    else
    {
      while (fgets(result_line, STRING_LENGTH_512, fp) != NULL)
      {
        statement_edit_widget->result.append(result_line);
      }
      status= pclose(fp);
      if (status == -1) make_and_append_message_in_result(ER_PCLOSE_FAILED, 0, (char*)"");
      /* We do not bother to check whether the command failed, display will be blank. */
    }
    delete [] command_string;
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_TEE) /* see comment=tee+hist */
  {
    /* Everything as far as statement end is tee file name. Compare how we do SOURCE file name. */
    QString s;
    unsigned statement_length= /* text.size() */ true_text_size;
    if (i2 >= 2) s= text.mid(sub_token_offsets[1], statement_length - (sub_token_offsets[1] - sub_token_offsets[0]));
    else s= "";
    QString rr;
    if (history_file_start("TEE", s, &rr) == 0)
    {
      make_and_put_open_message_in_result(ER_FILE_OPEN, 0, rr);
    }
    else
    {
      make_and_put_open_message_in_result(ER_OK_PLUS, 0, rr);
    }
    return 1;
  }
#if (OCELOT_MYSQL_DEBUGGER == 1)
  if (statement_type == TOKEN_KEYWORD_DEBUG_DEBUG)
  {
    debug_debug_go(text);
    return 1;
  }
  if ((statement_type == TOKEN_KEYWORD_DEBUG_BREAKPOINT)
   || (statement_type == TOKEN_KEYWORD_DEBUG_CLEAR)
   || (statement_type == TOKEN_KEYWORD_DEBUG_TBREAKPOINT))
  {
    debug_breakpoint_or_clear_go(statement_type, text);
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_SETUP)
  {
    debug_setup_go(text);
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_INSTALL)
  {
    debug_install_go();
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_EXIT)
  {
    debug_exit_go(0);
    debug_menu_enable_or_disable(TOKEN_KEYWORD_DEBUG_EXIT);
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_DELETE)
  {
    debug_delete_go();
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_EXECUTE)
  {
    debug_execute_go();
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_SKIP)
  {
    debug_skip_go();
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_SET)
  {
    debug_set_go(text);
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_SOURCE)
  {
    debug_source_go();
    return 1;
  }
  if ((statement_type == TOKEN_KEYWORD_DEBUG_CONTINUE)
   || (statement_type == TOKEN_KEYWORD_DEBUG_EXECUTE)
   || (statement_type == TOKEN_KEYWORD_DEBUG_INFORMATION)
   || (statement_type == TOKEN_KEYWORD_DEBUG_LEAVE)
   || (statement_type == TOKEN_KEYWORD_DEBUG_NEXT)
   || (statement_type == TOKEN_KEYWORD_DEBUG_REFRESH)
   || (statement_type == TOKEN_KEYWORD_DEBUG_STEP))
  {
    /* All the other debug commands go to the same place. */
    debug_other_go(text);
    return 1;
  }
#endif
  /* See whether general format is SET ocelot_... = value ;". Read comment with label = "client variables" */
  if (i2 >= 4)
  {
    if (sub_token_types[0] == TOKEN_KEYWORD_SET)
    {
      if (sub_token_types[1] == TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_RULE)
      {
        int er= statement_format_rule_set(text);
        make_and_put_message_in_result(er, 0, (char*)"");
        return 1;
      }
#if (OCELOT_IMPORT_EXPORT == 1)
      if (sub_token_types[1] == TOKEN_KEYWORD_OCELOT_EXPORT)
      {
        import_export_rule_set(text);
        /* make_and_put_message_in_reult is done within import_export_rule_set */
        return 1;
      }
#endif
      if (sub_token_types[1] == TOKEN_KEYWORD_OCELOT_MAX_CONDITIONS)
      {
        QString new_value_string= text.mid(sub_token_offsets[3], sub_token_lengths[3]);
        int candidate= new_value_string.toInt();
        ocelot_max_conditions= candidate;
        if (candidate > MAX_MAX_CONDITIONS)
        {
          char tmp_for_error[256];
          sprintf(tmp_for_error, "Error. MAX_MAX_CONDITIONS = %d\n", MAX_MAX_CONDITIONS);
          put_message_in_result(tmp_for_error);
          return 1;
        }
        if (conditional_settings.count() > ocelot_max_conditions)
        {
          while (conditional_settings.count() > ocelot_max_conditions) /* remove existing in reverse order */
            conditional_settings.removeAt(0);
          explorer_show_after_change();
        }
        put_message_in_result("OK");
        return 1;
      }
      // todo: I think we won't get here if name doesn't start with ocelot_, but maybe make sure again
      if ((sub_token_types[4] == TOKEN_KEYWORD_WHERE) || (text.mid(sub_token_offsets[4], sub_token_lengths[4]) == ","))
      {
        if (conditional_settings.count() >= ocelot_max_conditions)
        {
          char msg[512];
          sprintf(msg, "Error: maximum number of conditional statements is %d. To increase, say SET ocelot_max_conditions=N;", ocelot_max_conditions);
          put_message_in_result(msg);
          return 1;
        }
        int er= conditional_settings_insert(text);
        if (er != ER_OVERFLOW)
        {
          explorer_show_after_change();
          make_and_put_message_in_result(er, 0, (char*)"");
          return 1;
        }
      }
      else
      {
        int er= xsettings_widget->ocelot_variable_set(sub_token_types[1], text.mid(sub_token_offsets[3], sub_token_lengths[3]));
        if (er != ER_OVERFLOW)
        {
          make_and_put_message_in_result(er, 0, (char*)"");
          return 1;
        }
      }
    }
  }
  return 0;
}

/*
  Called from prompt_default() and action_about (for Help|About)
  Return "tarantool" or "mysql" or "mariadb".
  If connected to MariaDB, dbms_version will contain that. But if connected to MySQL, we have only numbers.
*/
QString MainWindow::dbms_name()
{
  QString s= ocelot_dbms;
  QString dbms_name;
  if (s.contains("Tarantool", Qt::CaseInsensitive)) dbms_name= "tarantool";
  else
  {
    if (connections_is_connected[0] == 1) s= statement_edit_widget->dbms_version;
    if (s.contains("MariaDB", Qt::CaseInsensitive)) dbms_name= "mariadb";
    else dbms_name= "mysql";
  }
  return dbms_name;
}

bool MainWindow::is_context_menu_name(int token_type)
{
  if ((token_type== TOKEN_KEYWORD_OCELOT_EXPLORER_ACTION)
   || (token_type == TOKEN_KEYWORD_OCELOT_EXPLORER_APPLICABLE_DBMSS)
   || (token_type == TOKEN_KEYWORD_OCELOT_EXPLORER_APPLICABLE_TYPES)
   || (token_type == TOKEN_KEYWORD_OCELOT_EXPLORER_ENABLED)
   || (token_type == TOKEN_KEYWORD_OCELOT_EXPLORER_SHORTCUT)
   || (token_type == TOKEN_KEYWORD_OCELOT_EXPLORER_TEXT))
    return true;
  return false;
}

/*
  Set prompt to default default.
  Do this if (user says prompt;) or (at start if ocelot_prompt_is_default == true)
  If --ocelot_dbms was specified: ocelot_dbms + >
  Else if connection happened to MariaDB: MariaDB>
  Else mysql>
*/
void MainWindow::prompt_default()
{
  ocelot_prompt= dbms_name() + ">"; /* e.g. "mysql>" */
  ocelot_prompt_is_default= true;
  statement_edit_widget->prompt_default= ocelot_prompt;
  statement_edit_widget->prompt_as_input_by_user= statement_edit_widget->prompt_default;
  emit statement_edit_widget->update_prompt_width(0); /* not necessary with Qt 5.2 */
}

/*
  For a client statement: SET target = 'literal' WHERE x opr y [AND x opr y...]; + comments
  Canonize so that style_sheet_setter() can parse easily.
  Probably hparse will catch errors before we get here but maybe we don't call hparse.
  Todo: Everything could be fixed-size (space padded) except the final comparand to make it even easier for style_sheet_setter().
        And you could disallow ''s in the final comparand.
*/
#define MAX_CONDITIONAL_STATEMENT_TOKENS 100
int MainWindow::conditional_settings_insert(QString text)
{
  log("conditional_settings_insert", 15);
  int token_offsets[MAX_CONDITIONAL_STATEMENT_TOKENS];
  int token_lengths[MAX_CONDITIONAL_STATEMENT_TOKENS];
  tokenize(text.data(),
           text.size(),
           &token_lengths[0], &token_offsets[0], MAX_CONDITIONAL_STATEMENT_TOKENS - 1,
          (QChar*)"33333", 2, "", 1);
  QString o= "";
  QString token;
  QString token_2;
  int expected_token= 1;
  for (int i= 0;; ++i)
  {
    token= text.mid(token_offsets[i], token_lengths[i]);
    if ((token.mid(0, 2) == "/*") || (token.mid(0, 2) == "--") || (token.mid(0, 1) == "#")) continue; /* skip comments */
    QString token_upper= token.toUpper();
    if (expected_token == 1)
    {
      if (token_upper != "SET") return ER_ERROR;
      o.append(token_upper + " ");
      expected_token= 2;
      continue;
    }
    if (expected_token == 2)
    {
     int token_type= get_keyword_index_from_qstring(token_upper);
      /* Checking that it's OCELOT_EXPLORER_BACKGROUND_COLOR, OCELOT_GRID_FONT_STYLE, etc. */
      if ((strvalues[token_type].reserved_flags & FLAG_VERSION_CONDITIONAL) == 0)
         return ER_ERROR;
      token_2= token_upper;
      o.append(token_upper + " ");
      expected_token= 3;
      continue;
    }
    if (expected_token == 3)
    {
      if (token != "=") return ER_ERROR;
      o.append(token_upper + " ");
      expected_token= 4;
      continue;
    }
    if (expected_token == 4)
    {
      /* e.g. font_..., tooltip, cell_height, cell_width -- anything that does not mention color */
      if (token_2.contains("COLOR") == false) o.append(token + " ");
      else {
        if ((token.left(1) != "'") || (token.right(1) != "'")) return ER_ILLEGAL_VALUE;
        token= token.mid(1, token.size() -2);
        QString ccn= canonical_color_name(token);
        if (ccn == "") return ER_UNKNOWN_COLOR;
        o.append("'" + ccn.toLower() + "' ");
      }
      expected_token= 5;
      continue;
    }
    if (expected_token == 5)
    {
      if (token == ",")
      {
        o.append(", ");
        expected_token= 2;
        continue;
      }
      if (token_upper != "WHERE") return ER_ERROR;
      o.append(token_upper + " ");
      expected_token= 6;
      continue;
    }
    if (expected_token == 6)
    {
      if ((token_upper != "COLUMN_NAME")
       && (token_upper != "COLUMN_NUMBER")
       && (token_upper != "COLUMN_TYPE")
       && (token_upper != "ROW_NUMBER")
       && (token_upper != "VALUE")) /* the only permissible explorer word */
        return ER_ERROR;
      o.append(token_upper + " ");
      expected_token= 7;
      continue;
    }
    if (expected_token == 7)
    {
      if ((token_upper != "=")
       && (token_upper != ">=")
       && (token_upper != ">")
       && (token_upper != "<=")
       && (token_upper != "<")
       && (token_upper != "<>")
       && (token_upper != "==")
       && (token_upper != "!=")
       && (token_upper != "IS")
       && (token_upper != "REGEXP"))
        return ER_ERROR;
      o.append(token_upper + " ");
      expected_token= 8;
      continue;
    }
    if (expected_token == 8)
    {
      if (token.size() == 0) return ER_ILLEGAL_VALUE;
      o.append(token + " ");
      expected_token= 9;
      continue;
    }
    if (expected_token == 9)
    {
      if (token == ";")
      {
        o.append(";");
        break;
      }
      else if ((token_upper == "AND") || (token_upper == "OR"))
      {
        o.append(token_upper + " ");
        expected_token= 6;
        continue;
      }
      else return ER_ERROR;
    }
  }
  /* Increase conditional_settings.count() which could slow display so ocelot_max_conditionals should be small. */
  conditional_settings.append(o);
  /* Immediate evaluation for explorer action | shortcut | text which are permanent */
  for (int i_of_cmi= 0; i_of_cmi < explorer_widget->html_text_edit->explorer_context_menu->cmi_count; ++i_of_cmi)
  {
    bool result_of_evaluate= false;
    QString cs_new_style_sheet;
    QString style_string= ocelot_explorer_style_string;
    QString cs_new_tooltip;
    QString cs_new_cell_height;
    QString cs_new_cell_width;
    QString cs_new_action= "[]";
    QString cs_new_enabled= "[]";
    QString cs_new_shortcut= "[]";
    QString cs_new_text= "[]";
    QString string= explorer_widget->html_text_edit->explorer_context_menu->cmi[i_of_cmi].text;
    /* Todo: Stripping lead+trail spaces does not remove a shortcut. Should we remove shortcuts? */
    //string= string.trimmed(); unnecessary?
    QByteArray string_utf8= string.toUtf8();
    result_of_evaluate= explorer_widget->conditional_setting_evaluate(conditional_settings.count() - 1,
                                        1,           /* i.e. result set column number */
                                        1,       /* e.g. text_frame->ancestor_grid_result_row_number */
                                        string_utf8.data(),       /* e.g. text_frame->content_pointer */
                                        0,          /* e.g. FIELD_VALUE_FLAG_IS_NULL */
                                        string_utf8.size(), /* e.g. text_frame->content_length */
                                        TEXTEDITFRAME_CELL_TYPE_DETAIL,  /* e.g. text_frame->cell_type */
                                        style_string,
                                        false,
                                        &cs_new_tooltip,
                                        &cs_new_style_sheet,
                                        &cs_new_cell_height,
                                        &cs_new_cell_width,
                                        &cs_new_action,
                                        &cs_new_enabled,
                                        &cs_new_shortcut,
                                        &cs_new_text);
    if (result_of_evaluate == true)
    {
      if (cs_new_action != "[]") explorer_widget->html_text_edit->explorer_context_menu->cmi[i_of_cmi].action= cs_new_action;
      if (cs_new_enabled != "[]") explorer_widget->html_text_edit->explorer_context_menu->cmi[i_of_cmi].enabled= cs_new_enabled.toLower();
      if (cs_new_shortcut != "[]") explorer_widget->html_text_edit->explorer_context_menu->cmi[i_of_cmi].shortcut= cs_new_shortcut;
      if (cs_new_text != "[]") explorer_widget->html_text_edit->explorer_context_menu->cmi[i_of_cmi].text= cs_new_text;
    }
  }
  return 0;
}


/*
  REHASH
  Make a cache of all objects in the current database.
  Not a great name, but mysql client requires "rehash" for something
  vaguely similar (they store some column names with a hash) (we don't).
  Currently we're taking in table_name, column_name from information_schema
  for the current database, into result_set_copy.
  Called if: REHASH statement, USE statement + auto_rehash > 0. and connect?
             Or for explorer, or for set ocelot_query = show foreign keys
  Todo: Allow REHASH [TABLES|TRIGGERS|etc.] [database.]name or *
        There might be multiple databases and multiple connections
  Todo: Allow triggers events procedures functions indexes
  Todo: Hover provides more information about the object
  Todo: We know declared variables or other things made within a
        routine (see hparse_f_labels etc.) but didn't merge with
        the results of this routine
  Todo: add rehash to Options menu
  Todo: see correlations | aliases
  Todo: error messages
  Todo: information_schema.engines if MySQL version >= 5.6
  Todo: information_schema.character_sets if MySQL version >= 5.?
  Beware: You don't have read access for everything.
  Beware: Names might be case sensitive.
  Beware: Qualifier might indicate a different database.
  Columns are "table.column"
  Symbols: 'D' database 'C' column 'T' table 'F' function 'P' procedure 't' trigger 'E' event 'I' index
           'K' keyword and 'i' identifier-unknown-type (temporary) 'V' variable
   When is rehash_scan() called:
    Only the "REHASH" statement does anything for sure.
    During connect | reconnect | "use" statement, we look at
    --auto-rehash or --no-auto-rehash or --skip-auto-rehash. We do.
    During "use" statement, we could redo rehashing. We do.
    So default = TRUE which is like --auto-rehash being default but only if connect.
    This affects unsigned short ocelot_auto_rehash.
  When is rehash_search() called:
    When user hits ` i.e. backtick show the choices.
    When user hits ocelot_shortcut_autocomplete_keysequence which by
    default is \t i.e. tab Qt::Key_Tab, if there's an unambiguous name,
    fill it in (don't worry about what happens if user hits tab twice).
  Why we do a single unioned search with unnecessary columns:
    If we did multiple searches, we would affect MAX_QUERIES_PER_HOUR
    more. But this means there could be thousands of entries
    in the cache, and searches are sequential.
    Todo: add an order-by in the select, and do binary searches.
  Todo: if error, show results of mysql_error as well (as we do when user-input statements fail)
*/

int MainWindow::rehash_scan(char *error_or_ok_message, QString alternate_query)
{
#ifdef DBMS_TARANTOOL
  if ((connections_is_connected[0] == 1) && (connections_dbms[0] == DBMS_TARANTOOL))
    return rehash_scan_for_tarantool(error_or_ok_message, alternate_query);
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
  MYSQL_RES *res= NULL;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  ResultGrid *rg= NULL;
//  QString s;
  int er;                                                  /* for errors e.g. ER_NOT_CONNECTED */
#if (OCELOT_MYSQL_INCLUDE == 1)
  unsigned int *result_max_column_widths;                     /* dynamic-sized list of actual maximum widths in detail columns */
  result_max_column_widths= 0;
  int count_of_columns= 0;
  int count_of_tables= 0;
  int count_of_functions= 0;
  int count_of_procedures= 0;
  int count_of_triggers= 0;
  int count_of_events= 0;
  int count_of_indexes= 0;
#endif //#OCELOT_MYSQL_INCLUDE == 1)
  rehash_garbage_collect(); /* garbage_collect from the last rehash, if any. */

  if (connections_is_connected[0] != 1)
  {
    er= ER_NOT_CONNECTED;
    goto error_return;
  }
#if (OCELOT_MYSQL_INCLUDE == 1)
  /* Todo: Now 1024 isn't big enough if alternate_query <> NULL, because user can make up something big. */
  char query[1024];
if (alternate_query == "")
  sprintf(query, "select 'D',database(),'','' "
                 "union all "
                 "select 'C',table_name,column_name,'' "
                   "from information_schema.columns "
                 "where table_schema = database() "
                 "union all "
                 "select 'T',table_name,table_type,'' "
                 "from information_schema.tables "
                 "where table_schema = database() "
                 "union all "
                 "select 'F',routine_name,routine_type,'' "
                 "from information_schema.routines "
                 "where routine_schema = database() and routine_type = 'FUNCTION' "
                 "union all "
                 "select 'P',routine_name,routine_type,'' "
                 "from information_schema.routines "
                 "where routine_schema = database() and routine_type = 'PROCEDURE' "
                 "union all "
                 "select 't',trigger_name,'','' "
                 "from information_schema.triggers "
                 "where trigger_schema = database() "
                 "union all "
                 "select 'E',event_name,'','' "
                 "from information_schema.events "
                 "where event_schema = database() "
                 "union all "
                 "select 'I',table_name,index_name,column_name "
                 "from information_schema.statistics "
                 "where table_schema = database() "
         );
else
{
  strcpy(query, alternate_query.toUtf8());
}
  if (lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], query))
  {
    er= ER_SELECT_FAILED;
    goto error_return;
  }
  res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
  if (res == NULL)
  {
    er= ER_MYSQL_STORE_RESULT_FAILED;
    goto error_return;
  }
  rehash_result_column_count= lmysql->ldbms_mysql_num_fields(res);
  rehash_result_row_count= lmysql->ldbms_mysql_num_rows(res);
  if ((rehash_result_column_count == 0) || (rehash_result_row_count == 0))
  {
    lmysql->ldbms_mysql_free_result(res);
    er= ER_0_ROWS_RETURNED;
    goto error_return;
  }

  result_max_column_widths= new unsigned int[rehash_result_column_count];
  ResultGrid* result_grid;
  result_grid= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));
  {
    result_grid->scan_rows(
            rehash_result_column_count, /* result_column_count, */
            rehash_result_row_count, /* result_row_count, */
            res, /* grid_mysql_res, */
            &rehash_result_set_copy,
            &rehash_result_set_copy_rows,
            &result_max_column_widths);
    lmysql->ldbms_mysql_free_result(res);
  }
  delete [] result_max_column_widths;
  /* First set of rows is 'D',database(),''. If it's null, error. */
  char database_name[512];
  {
    rehash_get_database_name(database_name);
    if (database_name[0] == '\0')
    {
      er= ER_NO_DATABASE_SELECTED;
      goto error_return;
    }
  }
  long unsigned int r;
  for (r= 0; r < rehash_result_row_count; ++r)
  {
    char *row_pointer;
    unsigned int column_length;
    char column_value[512];
    row_pointer= rehash_result_set_copy_rows[r];
    memcpy(&column_length, row_pointer, sizeof(unsigned int));
    row_pointer+= sizeof(unsigned int) + sizeof(char);
    strncpy(column_value, row_pointer, column_length);
    column_value[column_length]= '\0';
    /* Todo: If explorer, we should count "S" schema and "V" view and "T" triggers as well. */
    if (strcmp(column_value, "C") == 0) ++count_of_columns;
    if (strcmp(column_value, "T") == 0) ++count_of_tables;
    if (strcmp(column_value, "F") == 0) ++count_of_functions;
    if (strcmp(column_value, "P") == 0) ++count_of_procedures;
    if (strcmp(column_value, "t") == 0) ++count_of_triggers;
    if (strcmp(column_value, "E") == 0) ++count_of_events;
    if (strcmp(column_value, "I") == 0) ++count_of_indexes;
  }
  if (rg != NULL) delete rg;

  er= ER_OK_REHASH;
  sprintf(error_or_ok_message, er_strings[er_off + er],
          database_name, count_of_tables, count_of_columns, count_of_functions, count_of_procedures, count_of_triggers, count_of_events, count_of_indexes);
  return er;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
error_return:
  if (rg != 0) delete rg;
  rehash_garbage_collect();
  strcpy(error_or_ok_message, er_strings[er_off + er]);
  return er;
}

/* Call if rehash_scan starts, rehash_scan fails, explorer or "show foreign keys" wipes out rehash_scan result */
/* Todo: maybe we should be garbage-collecting when disconnecting too */
void MainWindow::rehash_garbage_collect()
{
  if (rehash_result_set_copy != 0) { delete [] rehash_result_set_copy; rehash_result_set_copy= 0; }
  if (rehash_result_set_copy_rows != 0) { delete [] rehash_result_set_copy_rows; rehash_result_set_copy_rows= 0; }
  rehash_result_column_count= 0;
  rehash_result_row_count= 0;
}

#ifdef DBMS_TARANTOOL
int MainWindow::rehash_scan_for_tarantool(char *error_or_ok_message, QString alternate_query)
{
  (void)alternate_query;
  int count_of_columns= 0;
  int count_of_tables= 0;
  int count_of_functions= 0;
  int count_of_procedures= 0;
  int count_of_triggers= 0;
//  int count_of_fk_constraints= 0;
  int count_of_events= 0;
  int count_of_indexes= 0;
  int er;                                                  /* for errors e.g. ER_NOT_CONNECTED */
  {
    if (strcmp(tarantool_box_execute, "No SQL") == 0)
    {
      tarantool_errno[0]= 9998;
      er= ER_SELECT_FAILED;
      goto error_return;
    }

    /* We replaced eval() with tnt_select calls so we can use fewer privileges. */
    tarantool_table_ids.clear(); tarantool_table_names.clear();
    tarantool_column_table_names.clear(); tarantool_column_names.clear();
#if (OCELOT_EXPLORER == 1)
    tarantool_type_names.clear(); tarantool_table_engines.clear(); tarantool_index_column_numbers.clear();
#endif
    tarantool_index_table_names.clear(); tarantool_index_names.clear();
    tarantool_trigger_names.clear();
    tarantool_fk_constraint_names.clear();
    tarantool_fk_constraint_child_ids.clear();
    tarantool_fk_constraint_parent_ids.clear();
    rehash_scan_one_space(281); /* 281 is "_vspace" */
    rehash_scan_one_space(289); /* 289 is "_vindex" */
    rehash_scan_one_space(328); /* 328 is "_trigger" */
    rehash_scan_one_space(356); /* 356 is "_fk_constraint" */
    count_of_tables= tarantool_table_names.count();
    count_of_columns= tarantool_column_names.count();
    count_of_indexes= tarantool_index_names.count();
    count_of_triggers= tarantool_trigger_names.count();
//    count_of_fk_constraints= tarantool_fk_constraint_names.count();
#ifdef OLD_STYLE
    /*
      This is how to use Lua to produce what looks like an SQL result set.
      Todo:: This does 'C', 'T', 't', 'I'. It could do more, see MySQL/MariaDB SELECT below.
    */
    char lua_request[]=
       "do\
         local output_tuple\
         local output_table_of_tuples = {}\
         local vspace_list = {}\
         local x, y\
         local vspace_row_number, vspace_row, vspace_name, vspace_row_column_count, vspace_row_column_number\
         local vindex_list = {}\
         local vindex_row_number, vindex_row, vindex_name\
         local trigger_list = {}\
         local trigger_row_number, trigger_row, trigger_name\
         x, y = pcall(function () vspace_list = box.space._vspace:select() end)\
         if x then\
           for vspace_row_number = 1,#vspace_list do\
             vspace_row = vspace_list[vspace_row_number]\
             vspace_name = vspace_row[3]\
             vspace_row_column_count = #vspace_row[7]\
             if vspace_row_column_count ~= nil and vspace_row_column_count > 0 then\
               for vspace_row_column_number = 1, vspace_row_column_count do\
                 output_tuple = box.tuple.new('C', vspace_name, vspace_row[7][vspace_row_column_number].name)\
                 table.insert(output_table_of_tuples, output_tuple)\
                end\
             end\
           end\
           for vspace_row_number = 1,#vspace_list do\
             vspace_row = vspace_list[vspace_row_number]\
             vspace_name = vspace_row[3]\
             output_tuple = box.tuple.new('T', vspace_name, 'T')\
             table.insert(output_table_of_tuples, output_tuple)\
           end\
           x, y = pcall(function () trigger_list = box.space._trigger:select() end)\
           if x then\
             for trigger_row_number = 1,#trigger_list do\
               trigger_row = trigger_list[trigger_row_number]\
               trigger_name = trigger_row[1]\
               output_tuple = box.tuple.new('t', trigger_name, '')\
               table.insert(output_table_of_tuples, output_tuple)\
             end\
           end\
           x, y = pcall(function () vindex_list = box.space._vindex:select() end)\
           if x then\
             for vindex_row_number = 1,#vindex_list do\
               vindex_row = vindex_list[vindex_row_number]\
               vindex_name = vindex_row[3]\
               vspace_name = box.space._vspace:select(vindex_row[1])[1][3]\
               output_tuple = box.tuple.new('I', vspace_name, vindex_name)\
               table.insert(output_table_of_tuples, output_tuple)\
             end\
           end\
         end\
         local output_table_final = \
         {\
           ['metadata']=\
           {\
             {['name']='COLUMN_1',['type']='string'},\
             {['name']='COLUMN_2',['type']='string'},\
             {['name']='COLUMN_3',['type']='string'}\
           }\
           ,\
           ['rows']=\
           output_table_of_tuples\
         }\
         return output_table_final\
       end\
     ";

    /* Todo: Solve this mystery: why does result == 0 even if tarantool_execute_sql fails? */

    result= tarantool_execute_lua(lua_request, strlen(lua_request), 0);

    if (result != 0)
    {
      er= ER_SELECT_FAILED;
      goto error_return;
    }
    rg= new ResultGrid(lmysql, this, false, 0);
    MYSQL_RES *mysql_res_for_new_result_set= NULL;
    rg->fillup(mysql_res_for_new_result_set,
              //&tarantool_tnt_reply,
              connections_dbms[MYSQL_MAIN_CONNECTION],
              //this,
              lmysql, ocelot_client_side_functions,
              MYSQL_MAIN_CONNECTION,
              false);

    tarantool_tnt_reply_data_p= tarantool_tnt_reply.data;
    rehash_result_column_count= tarantool_num_fields();
    rehash_result_row_count= tarantool_num_rows(MYSQL_MAIN_CONNECTION);
    if ((rehash_result_column_count == 0) || (rehash_result_row_count == 0))
    {
      er= ER_0_ROWS_RETURNED;
      goto error_return;
    }
#endif // OLD_STYLE
  }

  char database_name[512];
  strcpy(database_name, "main");
  er= ER_OK_REHASH;
  sprintf(error_or_ok_message, er_strings[er_off + er],
          database_name, count_of_tables, count_of_columns, count_of_functions, count_of_procedures, count_of_triggers, count_of_events, count_of_indexes);
  rehash_result_row_count= count_of_tables + count_of_columns + count_of_triggers + count_of_indexes;
  return er;
error_return:
  rehash_result_column_count= 0;
  rehash_result_row_count= 0;
  strcpy(error_or_ok_message, er_strings[er_off + er]);
  return er;
}

/*
  For picking out fields we want from Tarantool system spaces _vspace or _vindex or _trigger
  Re possible changes in format:
    Todo: This will fail if the name fields are not in the expected positions. We should check "format" clauses in _space.
    If new fields are added at the end, or if the order ofiems in the column list changes, we should be safe.
  Re index column:
    In _vindex column 5 there is a "parts" array. For system tables members are usually arrays.
    For SQL tables members are usually maps. Although multi-column indexes are possible, we only note the first.
    If members are arrays then the column that the index part refers to is the first array item.
    If members are maps then the column that the index part refers to is the one named "field".
    We put this number in index_column_numbers but the job is not done yet -- we convert it later
    to a column name for oei[].part_type.
*/
void MainWindow::rehash_scan_one_space(int space_number)
{
  int field_number_of_id;
  int field_number_of_name;
  int field_number_of_columns;
#if (OCELOT_EXPLORER == 1)
  int field_number_of_engine= -1;
  int field_number_of_sql= -1;
#endif
  if (space_number == 281) /* 281 is "_vspace" */
  {
    field_number_of_id= 0;
    field_number_of_name= 2;
    field_number_of_columns= 6;
#if (OCELOT_EXPLORER == 1)
    field_number_of_engine= 3;
    field_number_of_sql= 5;
    field_number_of_columns= 6;
#endif
  }
  if (space_number == 289) /* 289 is "_vindex" */
  {
    field_number_of_id= 0;
    field_number_of_name= 2;
    field_number_of_columns= 5;
  }
  if (space_number == 328) /* 328 is "_trigger" */
  {
    field_number_of_id= 1;
    field_number_of_name= 0;
    field_number_of_columns= -1;
  }
  if (space_number == 356) /* 356 is "_fk_constraint", late addition for foreign keys */
  {
    field_number_of_id= -1; /* we'll get child_id and parent_id in a more hardcoded way */
    field_number_of_name= 0;
    field_number_of_columns= -1;
  }
  int returned_result_set_type;
  tarantool_execute_lua_select(0, space_number); /* 0 is assumed connection number, e.g. space_number is 280 "_space" */
  if (tarantool_errno[0] != 0)
  {
    result_row_count= 0;
    return;
  }
  result_row_count= tarantool_num_rows(0); /* hmm. maybe I should prefer result_set_init()? */
  if (result_row_count == 0) return;
  const char *tarantool_tnt_reply_data_copy;
  tarantool_tnt_reply_data_copy= tarantool_seek_0(&returned_result_set_type); /* "seek to row 0" */
  for (unsigned int row_number= 0; row_number < result_row_count; ++row_number)
  {
    QString table_id;
    QString table_name;
    int number_of_fields= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy);
    for (int field_number= 0; field_number < number_of_fields; ++field_number)
    {
      if ((field_number == field_number_of_id)
       && (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_UINT))
      {
        uint32_t id= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy);
        table_id= QString::number(id);
      }

      else if ((field_number == 1) && (space_number == 356) /* Version 1.9 addition for foreign keys */
        & (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_UINT))
      {
        uint32_t id= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy);
        tarantool_fk_constraint_child_ids << QString::number(id);
      }
      else if ((field_number == 2) && (space_number == 356) /* Version 1.9 addition for foreign keys */
        & (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_UINT))
      {
        uint32_t id= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy);
        tarantool_fk_constraint_parent_ids << QString::number(id);
      }

      else if ((field_number == field_number_of_name)
            && (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_STR))
      {
        const char *value;
        uint32_t value_length;
        value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
        QString returned_string= QString::fromUtf8(value, value_length);
        if (space_number == 281)
        {
          table_name= returned_string;
          tarantool_table_ids << table_id;
          tarantool_table_names << table_name;
        }
        if (space_number == 289)
        {
          int index_of_table_name= tarantool_table_ids.indexOf(table_id);
          if (index_of_table_name >= 0)
          {
            tarantool_index_table_names << tarantool_table_names.at(index_of_table_name);
            tarantool_index_names << returned_string;
          }
        }
        if (space_number == 328)
        {
          tarantool_trigger_names << returned_string;
        }
        if (space_number == 356)
        {
          tarantool_fk_constraint_names << returned_string;
        }
      }
#if (OCELOT_EXPLORER == 1)
      else if ((field_number == field_number_of_engine)
            && (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_STR))
      {
        /* blackhole | memtx | vinyl | sysview | service. We might replace with what's in 'sql'. */
        const char *value;
        uint32_t value_length;
        value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
        QString returned_string= QString::fromUtf8(value, value_length);
        tarantool_table_engines << returned_string;
      }
      else if ((field_number == field_number_of_sql)
            && (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_MAP))
      {
        /* Possibly: 'sql'+create-view-statement, 'view'+true. let's take the 'sql'. */
        /* Todo: much here is a duplicate of what we do for field_number_of_columns */
        uint32_t number_of_map_members= lmysql->ldbms_mp_decode_map(&tarantool_tnt_reply_data_copy);
        for (unsigned int i= 0; i < number_of_map_members; ++i)
        {
          const char *value;
          uint32_t value_length;
          QString returned_string;
          int typex= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy);
          if (typex != MP_STR)
          {
            value_length= 0;
            lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);
          }
          else
          {
            value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
            returned_string= QString::fromUtf8(value, value_length);
            if ((value_length == 3) && (returned_string == "sql"))
            {
              value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
              returned_string= QString::fromUtf8(value, value_length);
              int i_of_last_engine= tarantool_table_engines.size() - 1;
              tarantool_table_engines[i_of_last_engine]= returned_string;
            }
            else
              lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy); /* skip */
          }
        }
      }
      else if ((field_number == field_number_of_columns)
            && (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_ARRAY)
            && (space_number == 289)) /* see comment preceding this function = "Re index column" */
      {
        const char *tarantool_tnt_reply_data_copy_pushed= tarantool_tnt_reply_data_copy; /* push */
        int column_5_field_number= -1;
        uint32_t number_of_column_5_parts= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy);
        for (unsigned int part_number= 0; part_number < number_of_column_5_parts; ++part_number)
        {
          int type_of= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy);
          if (type_of == MP_ARRAY)
          {
            uint32_t i_array_count= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy);
            for (unsigned int i_array_number= 0; i_array_number < i_array_count; ++i_array_number)
            {
              int array_element_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy);
              if (array_element_type == MP_UINT)
              {
                column_5_field_number= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy);
                break;
              }
              else lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);
            }
          }
          else if (type_of == MP_MAP)
          {
            uint32_t i_map_count= lmysql->ldbms_mp_decode_map(&tarantool_tnt_reply_data_copy);
            const char *value= NULL;
            uint32_t value_length;
            for (unsigned int i_map_number= 0; i_map_number < i_map_count * 2; ++i_map_number)
            {
              int map_element_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy);
              if (map_element_type == MP_STR)
              {
                value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
              }
              else if (map_element_type == MP_UINT)
              {
                uint32_t x= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy);
                if ((value_length == 5) && memcmp(value, "field",5) == 0)
                {
                  column_5_field_number= x;
                  break;
                }
              }
              else lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);
            }
          }
          else lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);      /* skip */
          if (column_5_field_number != -1) break;
        }
        tarantool_index_column_numbers << QString::number(column_5_field_number);
        tarantool_tnt_reply_data_copy= tarantool_tnt_reply_data_copy_pushed; /* pop */
        lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);      /* skip */
      }
#endif
      else if ((field_number == field_number_of_columns)
            && (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_ARRAY))
      {
        uint32_t number_of_columns= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy);
        for (unsigned int column_number= 0; column_number < number_of_columns; ++column_number)
        {
          uint32_t number_of_map_members= lmysql->ldbms_mp_decode_map(&tarantool_tnt_reply_data_copy);
          for (unsigned int i= 0; i < number_of_map_members; ++i)
          {
            const char *value;
            uint32_t value_length;
            QString returned_string;
            if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) != MP_STR)
            {
              value_length= 0;
              lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);
            }
            else
            {
              value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
              returned_string= QString::fromUtf8(value, value_length);
            }
            if ((value_length == 4) && (returned_string == "name"))
            {
              if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) != MP_STR)
              {
                lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);
              }
              else
              {
                value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
                returned_string= QString::fromUtf8(value, value_length);
                tarantool_column_table_names << table_name;
                tarantool_column_names << returned_string;
              }
            }
            else
            {
#if (OCELOT_EXPLORER == 1)
              if ((value_length == 4) && (returned_string == "type"))
              {
                value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
                returned_string= QString::fromUtf8(value, value_length);
                tarantool_type_names << returned_string;
              }
              else
#endif
              lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy); /* skip type */
            }
          }
        }
      }
      else
      {
        lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);      /* skip */
      }
    }
  }
}
#endif

/*
  Called from hparse_f_multi_block() for adding to the "Expecting:" list
  Pass: search string. Return: column name matching searching string.
  Re ""s: An identifier if starts-with-digit or has-lower-case or has-non-alpha-or-digit isn't regular.
          So making it a delimited identifier seems reasonable in this context.
          But in MySQL/MariaDB it's complicated due to ansi-quotes, backtick use, and whether lower-case matters.
          So for now we only check for Tarantool.
  Todo: We only look at column[1] column_name. We should look at column[0] table_name.
  Todo: Matching reftype is fine but we could also match column's table or index's table if we know it.
        !! NOW WE KNOW IT! Well, for column anyway.
  Todo: Should not the search be case insensitive?
  Todo: Consider stopping display after TARANTOOL_MAX_FIELD_NAME_LENGTH or MYSQL_MAX_IDENTIFIER_LENGTH characters.
  Todo: "count_of_hits > 100" is arbitrary, and also you should add "..."
  Todo: Perhaps the QByteArray() trick here could be used elsewhere where we're currently using strncpy().
  Todo: We avoid duplicates e.g. "primary".
        But that disturbs the order, and something that occurs more often should be first.
        And if you ever get more info e.g. column-type or table-of-index then it will be ambiguous.
  Todo: We could call QStringList::sort()
  Todo: Comparisons are case insensitive but don't have to be if "" encloses
  Todo: Change pass of TOKEN_TYPE_IDENTIFIER if in fact it's within backticks or ""s
  Todo: If it's a function, call completer_widget->append_wrapper with final argument i.e. flags|= TOKEN_FLAG_IS_FUNCTION
*/
QString MainWindow::rehash_search(QString table_name, char *search_string, int reftype,
                    QString hparse_token,
                    bool is_exact_required,
                    QString specified_schema,
                    QStringList specified_list)
{
  QStringList special_handling_names;
  if (search_string[0] == '"') ++search_string;
  else if (search_string[0] == '`') ++search_string;

  long unsigned int r;
  char *row_pointer;
  unsigned int column_length;
  unsigned int i;
  QString column_value;
  QStringList column_value_list;
  unsigned int search_string_length;
//  QString tmp_word= "";
  int count_of_hits= 0;
  char desired_types[TOKEN_REFTYPE_MAX]= "";
  unsigned int column_to_match= 0;
  search_string_length= strlen(search_string);
  column_value_list.clear();
  if ((reftype == TOKEN_REFTYPE_COLUMN)
   || (reftype == TOKEN_REFTYPE_TABLE_OR_COLUMN)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN_OR_FUNCTION)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN_OR_FUNCTION_OR_VARIABLE)
   || (reftype == TOKEN_REFTYPE_COLUMN_OR_USER_VARIABLE)
   || (reftype == TOKEN_REFTYPE_COLUMN_OR_VARIABLE)
   || (reftype == TOKEN_REFTYPE_TABLE_OR_COLUMN_OR_FUNCTION))
  {
    strcpy(desired_types, "C");
    column_to_match= 2;
  }
  else if ((reftype == TOKEN_REFTYPE_FUNCTION)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_FUNCTION))
  {
    strcpy(desired_types, "F");
    column_to_match= 1;
  }
  else if ((reftype == TOKEN_REFTYPE_PROCEDURE)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_PROCEDURE))
  {
    strcpy(desired_types, "P");
    column_to_match= 1;
  }
  else if ((reftype == TOKEN_REFTYPE_FUNCTION_OR_PROCEDURE)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_FUNCTION_OR_PROCEDURE))
  {
    strcpy(desired_types, "FP");
    column_to_match= 1;
  }
  else if ((reftype == TOKEN_REFTYPE_TABLE)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_TABLE))
  {
    strcpy(desired_types, "T");
    column_to_match= 1;
  }
  else if ((reftype == TOKEN_REFTYPE_TRIGGER)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_TRIGGER))
  {
    strcpy(desired_types, "t");
    column_to_match= 1;
  }
  else if ((reftype == TOKEN_REFTYPE_EVENT)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_EVENT))
  {
    strcpy(desired_types, "E");
    column_to_match= 1;
  }
  else if (reftype == TOKEN_REFTYPE_INDEX)
  {
    strcpy(desired_types, "I");
    column_to_match= 2;
  }
  else if ((reftype == TOKEN_REFTYPE_DATABASE) && (ocelot_explorer_visible == "yes"))
  {
    strcpy(desired_types, "D");
    column_to_match= 1;
  }
  else
  {
    return "not rehashed";
  }
  bool is_special_handling= false;
  if (desired_types[0] == 'D') /* For database|schema rehash isn't useful but explorer is. */
  {
#ifdef DBMS_TARANTOOL
    if (connections_dbms[0] == DBMS_TARANTOOL)
    {
      column_value_list.append("main");
      count_of_hits= 1;
      goto ok_return;
    }
#endif
    special_handling_names.clear();
    for (unsigned int i_of_oei= 0; i_of_oei < oei_count; ++i_of_oei)
    {
      if (oei[i_of_oei].object_type == "S")
      {
        special_handling_names << oei[i_of_oei].object_name;
      }
    }
    is_special_handling= true;
  }

  if ((desired_types[0] == 'T') && (specified_schema > "")) /* for erdiagram (table list) */
  {
    is_special_handling= true;
  }

  if ((connections_dbms[0] == DBMS_TARANTOOL) || (is_special_handling == true))
  {
    QStringList *q= NULL;
    QStringList *q2= NULL;
    if (desired_types[0] == 'D') q= &special_handling_names;
    else if ((desired_types[0] == 'T') && (specified_schema > "")) q= &specified_list;
#ifdef DBMS_TARANTOOL
    else if (desired_types[0] == 'T') q= &tarantool_table_names;
    else if (desired_types[0] == 't') q= &tarantool_trigger_names;
    else if (desired_types[0] == 'I') { q= &tarantool_index_names; q2= &tarantool_index_table_names; }
    else if (desired_types[0] == 'C') { q= &tarantool_column_names; q2= &tarantool_column_table_names; }
#endif
    if (q != NULL)
    {
      for (int i= 0; i < (*q).count(); ++i)
      {
        QString s= (*q).at(i);
        if ((q2 != NULL) && (table_name > ""))
        {
          if (QString::compare((*q2).at(i), table_name, Qt::CaseInsensitive) != 0) continue;
        }
        if (is_exact_required == true)
        {
          if (QString::compare(s, search_string, Qt::CaseInsensitive) == 0) return s;
        }
        else
        {
          if (search_string_length < (unsigned) s.length())
          {
            if (QString::compare(s.left(search_string_length), search_string, Qt::CaseInsensitive) == 0)
            {
              if (count_of_hits > 100) break;
              ++count_of_hits;
              column_value_list.append(s);
            }
          }
        }
      }
    }
    goto ok_return;
  }
  /* not Tarantool, not (database + explorer) */
  for (r= 0; r < rehash_result_row_count; ++r)
  {
    row_pointer= rehash_result_set_copy_rows[r];
    bool is_table_matched= true;
    for (i= 0; i < rehash_result_column_count; ++i)
    {
      memcpy(&column_length, row_pointer, sizeof(unsigned int));
      row_pointer+= sizeof(unsigned int) + sizeof(char);
      /* Now row_pointer points to contents, length has # of bytes */
      if (i == 0)
      {
        assert(column_length == 1);
        if (strchr(desired_types, *row_pointer) == NULL) break;
      }
      if ((i == 1) && (column_to_match == 2) && (table_name > ""))
      {
        QByteArray table_value_as_qbytearray= QByteArray(row_pointer, column_length);
        if (QString::compare(table_value_as_qbytearray, table_name, Qt::CaseInsensitive) != 0) is_table_matched= false;
      }
      if ((i == column_to_match) && (is_table_matched == true))
      {
        if (is_exact_required == true)
        {
          QByteArray column_value_as_qbytearray= QByteArray(row_pointer, column_length);
          if (QString::compare(column_value_as_qbytearray, search_string, Qt::CaseInsensitive) == 0)
          {
            QString s= column_value_as_qbytearray;
            return s;
          }
          else
          {
            ;
          }
        }
        else
        {
          QByteArray column_value_as_qbytearray= QByteArray(row_pointer, column_length);
          if (search_string_length < column_length)
          {
            {
              column_value= column_value_as_qbytearray;
              if (column_value_list.contains(column_value) == false)
              {
                column_value_list.append(column_value);
                ++count_of_hits;
                if (count_of_hits > 10) break;
              }
            }
          }
        }
      }
      row_pointer+= column_length;
    }
    if (count_of_hits > 100) break;
  }
ok_return:
  if (count_of_hits == 0) return "";
  for (int i= 0; i < column_value_list.size(); ++i)
  {
    QString token= column_value_list.at(i);
    /* TEST!!!! */
    QString hparse_s= hparse_token;
    if (hparse_s.left(1) == "\"") hparse_s= hparse_s.right(hparse_s.size() - 1);
    if (hparse_s.left(1) == "`") hparse_s= hparse_s.right(hparse_s.size() - 1);
    completer_widget->append_wrapper(token, hparse_s, TOKEN_TYPE_IDENTIFIER, 0, desired_types);
    //tmp_word.append(column_value_list.at(i));
    //tmp_word.append(" ");
  }
  return "OK";
}

void MainWindow::rehash_get_database_name(char *database_name)
{
  *database_name= '\0';
  if (rehash_result_set_copy == 0) return;
  char *row_pointer;
  unsigned int column_length;
  row_pointer= rehash_result_set_copy_rows[0];
  memcpy(&column_length, row_pointer, sizeof(unsigned int));
  row_pointer+= sizeof(unsigned int) + sizeof(char);
  row_pointer+= column_length;
  memcpy(&column_length, row_pointer, sizeof(unsigned int));
  row_pointer+= sizeof(unsigned int);
  if ((*row_pointer & FIELD_VALUE_FLAG_IS_NULL) != 0) return;
  row_pointer+= sizeof(char);
  strncpy(database_name, row_pointer, column_length);
  *(database_name + column_length)= '\0';
}

/*
  Call widget_sizer() from action_execute() to resize the three
  main_layout widgets if necessary.
  Todo: so far widget_sizer() is just ideas, mostly unimplemented.
  The widgets are in a layout (although grid and history and debug leave the layout if detached).
  But the maximum sizing can be helped by me. Some rules are:
  * If history_edit_widget is higher than needed without scrolling, shrink it.
  * If user has manually expanded a window, leave it.
    ** But a grid should snap back to a minimum size
  * A select() should be visible, up to some maximum line count, even if a result set has many rows.
  * We need a scroll bar for the whole main window. But maybe not for all the main_layout widgets?
  * The widget might be detached -- in that case the sizes of other widgets won't matter.
  * The statement window can shrink quite a bit because after action_execute() there's nothing in it.
  Probably TitleBarHeight won't matter because we set the bar to vertical (update: no, I gave up on vertical)
  Probably PM_DefaultFrameWidth won't matter but I'm not sure what it is.
  So far all I've thought about is a special case for detaching.
    It's a bit silly to allow for height of a horizontal scroll bar, if there is no scroll bar.
  Maybe we should use the WA_DontShowOnScreen trick for this and for size_calc.
*/
void MainWindow::widget_sizer()
{
  int history_edit_widget_height;
  /*
    This would work, but only if show() is called before widget_sizer().
    But if history_edit_widget becomes something other than plain text,
    we'd have to do something like this ...
    history_edit_widget_height= history_edit_widget->document()->size().height();
    history_edit_widget->setMaximumHeight(history_edit_widget_height);
  */
  QFontMetrics history_font(history_edit_widget->font());
  history_edit_widget_height= (history_edit_widget->document()->lineCount() + 1) * history_font.lineSpacing();
  history_edit_widget_height+= QApplication::style()->pixelMetric(QStyle::PM_ScrollBarExtent);
  history_edit_widget->setMaximumHeight(history_edit_widget_height);
}


/*
  If the response to a MySQL query is an error, put error information
  in statement_edit_widget->result and return error number. Else return 0.
  This should only be called for mysql calls, not for client commands.
  For a Tarantool query, we put together all error messages during tarantool_get_messages().
*/
/*
  Todo: the elapsed-time calculation in the diagnostics is calculated at the wrong time,
  it includes the time to set up the widgets. Move it to just after statement-execution.
*/
void MainWindow::put_diagnostics_in_result(unsigned int connection_number)
{
#if (OCELOT_MYSQL_INCLUDE == 1)
  unsigned int mysql_warning_count;
  char mysql_error_and_state[50]; /* actually we should need less than 50 */
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  char elapsed_time_string[50];   /* actually we should need less than 50 */
  QString s1, s2;
  /* Display may include: how long the statement took, to nearest tenth of a second. Todo: fix calculation. */
  {
    qint64 statement_end_time= QDateTime::currentMSecsSinceEpoch();
    qint64 elapsed_time= statement_end_time - statement_edit_widget->start_time;
    long int elapsed_time_as_long_int= (long int) elapsed_time;
    float elapsed_time_as_float= (float) elapsed_time_as_long_int / 1000; /* todo: round */
    sprintf(elapsed_time_string, " (%.1f seconds)", elapsed_time_as_float);
  }
#ifdef DBMS_TARANTOOL
  if (connections_dbms[connection_number] == DBMS_TARANTOOL)
  {
    s1= tarantool_get_messages(connection_number);
    s1.append(elapsed_time_string);
    statement_edit_widget->result= s1;
    return;
  }
#endif
  if ((connections_dbms[connection_number] != DBMS_MYSQL)
   && (connections_dbms[connection_number] != DBMS_MARIADB))
  {
    statement_edit_widget->result= "Bad connection."; /* shouldn't happen! */
    return;
  }
#if (OCELOT_MYSQL_INCLUDE == 1)
  mysql_errno_result= lmysql->ldbms_mysql_errno(&mysql[connection_number]);
  mysql_warning_count= lmysql->ldbms_mysql_warning_count(&mysql[connection_number]);
  if (mysql_errno_result == 0)
  {
    s1= er_strings[er_off + ER_OK];
    s1.append(" ");

    /* This should output, e.g. "Records: 3 Duplicates: 0 Warnings: 0" -- but actually nothing happens. */
    if (lmysql->ldbms_mysql_info(&mysql[connection_number])!= NULL)
    {
      /* This only works for certain insert, load, alter or update statements */
      s1.append(tr(lmysql->ldbms_mysql_info(&mysql[connection_number])));
    }
    else
    {
      sprintf(mysql_error_and_state, er_strings[er_off + ER_ROWS_AFFECTED], lmysql->ldbms_mysql_affected_rows(&mysql[connection_number]));
      s1.append(mysql_error_and_state);
      if (mysql_warning_count > 0)
      {
        sprintf(mysql_error_and_state, er_strings[er_off + ER_WARNING], mysql_warning_count);
        s1.append(mysql_error_and_state);
        if (mysql_warning_count > 1) s1.append("s");
      }
    }
    s1.append(elapsed_time_string);
    if (mysql_warning_count > 0)
    {
      if (ocelot_history_includes_warnings > 0)
      {
        lmysql->ldbms_mysql_query(&mysql[connection_number], "show warnings");
        MYSQL_RES *mysql_res_for_warnings;
        MYSQL_ROW warnings_row;
        QString s;
        // unsigned long connect_lengths[0];
        mysql_res_for_warnings= lmysql->ldbms_mysql_store_result(&mysql[connection_number]);
        assert(mysql_res_for_warnings != NULL);
        //for (unsigned int wi= 0; wi <= lmysql->ldbms_mysql_warning_count(&mysql[connection_number]); ++wi)
        int count_of_fields= lmysql->ldbms_mysql_num_fields(mysql_res_for_warnings);
#if defined(NDEBUG)
        if (count_of_fields != 3) {printf("assert(count_of_fields == 3);"); exit(1); }
#else
        assert(count_of_fields == 3);
#endif
        for (;;)
        {
          warnings_row= lmysql->ldbms_mysql_fetch_row(mysql_res_for_warnings);
          if (warnings_row == NULL) break;
          unsigned long *lengths= lmysql->ldbms_mysql_fetch_lengths(mysql_res_for_warnings);
          unsigned long required_size= lengths[0] + lengths[1] + lengths[2] + 16;
          char *long_warning= new char[required_size];
          sprintf(long_warning, "\n%s (%s) %s.", warnings_row[0], warnings_row[1], warnings_row[2]);
          s1.append(long_warning);
          delete []long_warning;
        }
        lmysql->ldbms_mysql_free_result(mysql_res_for_warnings);
      }
    }
  }
  if (mysql_errno_result > 0)
  {
    s1= er_strings[er_off + ER_ERROR];
    sprintf(mysql_error_and_state, "%d (%s) ", mysql_errno_result, lmysql->ldbms_mysql_sqlstate(&mysql[connection_number]));
    s1.append(mysql_error_and_state);
    s2= lmysql->ldbms_mysql_error(&mysql[connection_number]);
    s1.append(s2);
  }
  statement_edit_widget->result= s1;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
}


/*
  Called from execute_client_statement() and from debugger.
  Effect is like put_diagnostics_in_result() when the server returns an error,
  but without elapsed time or sqlstate or error number.
  Todo: consider putting in elapsed time.
*/
void MainWindow::put_message_in_result(QString s1)
{
  statement_edit_widget->result= s1;
}

/*
  Todo: truncate if length would be greater than ER_MAX_LENGTH
*/
void MainWindow::make_and_put_message_in_result(
        unsigned int er_number,
        int er_numeric_parameter,
        char *er_string_parameter)
{
  char buffer[ER_MAX_LENGTH];
  if (strstr(er_strings[er_off + er_number], "%s") != NULL)
    sprintf(buffer, er_strings[er_off + er_number], er_string_parameter);
  else
    sprintf(buffer, er_strings[er_off + er_number], er_numeric_parameter);
  put_message_in_result(buffer);
}

void MainWindow::make_and_put_open_message_in_result(
        unsigned int er_number, /* either ER_FILE_OPEN or ER_OK_PLUS */
        int er_numeric_parameter,
        QString file_name)
{
  char er_string_parameter[1024]; /* todo: should depend on file_name.size() */
  char buffer[ER_MAX_LENGTH];
  strcpy(er_string_parameter, file_name.toUtf8());
  if (strstr(er_strings[er_off + er_number], "%s") != NULL)
    sprintf(buffer, er_strings[er_off + er_number], er_string_parameter);
  else
    sprintf(buffer, er_strings[er_off + er_number], er_numeric_parameter);
  put_message_in_result(buffer);
}

void MainWindow::make_and_append_message_in_result(
        unsigned int er_number,
        int er_numeric_parameter,
        char *er_string_parameter)
{
  char buffer[ER_MAX_LENGTH];
  if (strstr(er_strings[er_off + er_number], "%s") != NULL)
    sprintf(buffer, er_strings[er_off + er_number], er_string_parameter);
  else
    sprintf(buffer, er_strings[er_off + er_number], er_numeric_parameter);
  statement_edit_widget->result.append(buffer);
}


/*
   tokenize(): Produce a list of tokens given an SQL statement using MySQL rules.

   Example: SELECT `a` FROM t; will give:
     token_offsets[0] -> SELECT, token_lengths=0] = 6
     token_offsets[1] -> `a`, token_lengths[1] = 3
     token_offsets[2] -> FROM, token_lengths[2] = 4
     token_offsets[3] -> t, token_lengths[3] = 1
     token_offsets[4] -> ;, token_lengths[4] = 1
     token_offsets[5] -> `'0', token_lengths[5] = 0
   Most character sets are OK because all breaks are ASCII.

  What to pass:
    Token_lengths[] gets the length of the token
    Token_offsets[] gets where the token starts within text
    Max_tokens is the size of token_lengths[] and token_offsets
      This is what I actually depend on but C++ insists I state the size.
    Version is what to compare when you say / * ! nnnnn
      It must be a 5-character string.
      It will be compared with the 5 digits following '!', if any
      If comparison fails, / * ! is treated as / * style comment
    Comment behaviour influences what will happen with comments
      1: save whole comment as one token.
         useful for syntax highlighting.
      2: ignore whole comment.
         useful for debug.
      3: save whole comment as multiple tokens, include markers
         useful for html markup.
      4: save whole comment as multiple tokens, ignore markers
    Special_token is a string, possibly blank, which will be treated as a single n-byte token
    even if it contains special characters. In this program we use it for delimiters.
    Minus behaviour influences what will happen with '-' i.e. 0x2d i.e. hyphen-minus
      1: '-' is an operator, this is the norm when tokenizing SQL
      2: '-' is a token part, this is the norm when tokenizing options

  If ocelot_dbms='tarantool':
    #... is not a comment
    [[...]] is a string
    .. is an operator
    == is an operator
    todo: =[[...]]= and nested strings
    no backslash escapes e.g. \' \" \\ are not escaped single characters inside strings

  Adjusting the tokenizer for Qt:
    With tokenize(QString text, char* comment_handling) we find the tokens of a string in statement.
    The results go to token_offsets[] and token_lengths[].
    According to Qt documentation:
      QString contains QChars. It's really UTF-16 except that a surrogate pair counts as two QChars.
      I won't use Qchar's helpers (isHighSurrogate, isLowSurrogate, isDigit, isLetter, isSpace, isNull)
      because I can't be sure that MySQL/MariaDB parser will always act the same way.
      I'm assuming nobody has played with the exec's codec, whatever that means.
      I'm assuming that the compiler will treat each QChar as unsigned.
      So I know that if something is "QString str" then I can compare characters within it to
      "QChar('u')" or "QChar(0x00e7)" etc. and I can get substrings with str.mid(position,length).
  The original program is tokenize.c which is a standalone that uses unsigned char* not QString.
  Todo: Flaw: In Tarantool/Lua [[...]] is TOKEN_TYPE_LITERAL_WITH_BRACKET but in Tarantool/SQL [ and ]
        will be TOKEN_TYPE_OPERATOR. So if we see [[ we try to determine whether the string is SQL or Lua.
        But we don't skip back to statement start so would be confused by lua-statement; sql-statement.
        And we assume if a word starts / and * it's SQL, but don't check for other kinds of comments.
        Tarantool/Lua still might confused by [[ or ]] in strings or comments but that's not our problem.
*/

void MainWindow::tokenize(QChar *text, int text_length, int *token_lengths,
                           int *token_offsets, int max_tokens, QChar *version,
                           int passed_comment_behaviour, QString special_token,
                           int minus_behaviour)
{
  log("tokenize start", 50);
  int token_number;
  QChar expected_char;
  int char_offset;
  QChar expected_char_at_comment_end;
  int comment_behaviour;
  QChar version_inside_comment[6];
  int n;

  expected_char_at_comment_end=' ';
  comment_behaviour=passed_comment_behaviour;
  token_number= 0;
  char_offset= 0;
next_token:
  token_lengths[token_number]= 0;
  token_offsets[token_number]= char_offset;
next_char:
  if (token_number >= (max_tokens - 1)) goto string_end;
  /* Following IFs happen to be in order by ASCII code */
  if (char_offset >= text_length) goto string_end; /* this is the usual check for end of string */
  if (text[char_offset] == '\x00') goto string_end;  /* \0 end of string (probably will never happen) */
  /* Check whether special_token occurs at this point. */
  {
    int special_token_length, special_token_offset;
    special_token_length= special_token.length();
    if ((special_token_length > 0)
    &&  (char_offset + special_token_length <= text_length))
    {
      for (special_token_offset= 0; special_token_offset < special_token_length; ++special_token_offset)
      {
        QChar special_token_char= special_token.at(special_token_offset);
        if (special_token_char != text[char_offset+special_token_offset]) break;
      }
      if (special_token_offset == special_token_length)
      {
        n= special_token_length;
        goto n_byte_token;
      }
    }
  }
  if (text[char_offset] <= ' ') goto white_space; /* space tab ff etc. = white space */
  if (text[char_offset] == '!')                 /* ! might be start of != otherwise one-byte token */
  {
    expected_char= '=';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
#ifdef DBMS_TARANTOOL
    if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0)
    {
      expected_char= '<';
      if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
      expected_char= '>';
      if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    }
#endif
    goto one_byte_token;
  }
  if (text[char_offset] == '"')    /* " starts a token until next " but watch for ""s and end-of-string and escape */
  {
    expected_char= '"';
    goto skip_till_expected_char;
  }
  if (text[char_offset] == '#')          /* # starts a comment */
  {
    if ((dbms_version_mask&FLAG_VERSION_TARANTOOL) != 0) goto one_byte_token;
    expected_char= '\n';
    goto comment_start;
  }
  if (text[char_offset] == '%') goto one_byte_token; /* % one-byte token */
  if (text[char_offset] == '&')     /* & might be start of &&. otherwise one-byte token */
  {
    expected_char= '&';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    goto one_byte_token;
  }
  if (text[char_offset] == '\x27')     /* ' starts a token until next ' but watch for end-of-string and escape */
  {
    expected_char= '\x27';
    goto skip_till_expected_char;
  }
  if (text[char_offset] == '(') goto one_byte_token; /* ( one-byte token */
  if (text[char_offset] == ')') goto one_byte_token; /* ) one-byte token */
  if (text[char_offset] == '*') /* * one-byte token unless * / and we're inside a comment */
  {
    if ((expected_char_at_comment_end == '/') && (char_offset + 1 < text_length) && (text[char_offset + 1] == '/'))
    {
      expected_char_at_comment_end= ' ';
      if (comment_behaviour == 3)
      {
        expected_char= '/';
        goto skip_till_expected_char;
      }
      if (comment_behaviour == 4)
      {
        n= 2;
        goto n_byte_token_skip;
      }
    }
    else goto one_byte_token;
  }
  if (text[char_offset] == '+') goto one_byte_token; /* + one-byte token */
  if (text[char_offset] == ',') goto one_byte_token; /* , one-byte token */
  if (text[char_offset] == '-') /* MySQL 5.7.9 JSON-colum->path operator */
  {
    expected_char= '>';
    if ((char_offset + 1  < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
  }
  if (minus_behaviour != 2) {
    if ((dbms_version_mask&FLAG_VERSION_TARANTOOL) == 0)
    {
      if (text[char_offset] == '-')     /* - one-byte token, unless -- comment */
      {
        if ((char_offset + 1 < text_length) && (text[char_offset + 1]  == '-'))
        {
          if ((char_offset + 2 < text_length) && (text[char_offset + 2] <= ' '))
          {
            expected_char= '\n';
            goto comment_start;
          }
        }
        goto one_byte_token;
      }
    }
    else
    {
      if (text[char_offset] == '-')     /* - one-byte token, unless -- comment */
      {
        if ((char_offset + 1 < text_length) && (text[char_offset + 1]  == '-'))
        {
          if (((char_offset + 2 < text_length) && (text[char_offset + 2] == '['))
           && ((char_offset + 3 < text_length) && (text[char_offset + 3] == '[')))
          {
            goto string_starting_with_bracket_start;
          }
          else
          {
            expected_char= '\n';
            goto comment_start;
          }
        }
        goto one_byte_token;
      }
    }
  }
  if (text[char_offset] == '.')     /* . part of token if previous or following is digit. otherwise one-byte token */
  {
    if (char_offset + 1 < text_length)
    {
      if ((text[char_offset + 1] >= '0') && (text[char_offset + 1] <= '9')) goto part_of_token;
      /* .. is an operator in MariaDB 10.3 for ... end for */
      if ((text[char_offset + 1] == '.')
       && ((hparse_dbms_mask & FLAG_VERSION_MARIADB_10_3) != 0))
      {
        n= 2;
        goto n_byte_token;
      }
    }
    if (token_lengths[token_number] > 0)
    {
      if ((text[char_offset - 1] >= '0') && (text[char_offset - 1] <= '9'))
      {
        int j;
        for (j= token_offsets[token_number]; j < char_offset; ++j)
        {
          if (text[j] > '9') goto one_byte_token;
        }
        goto part_of_token;
      }
    }
    goto one_byte_token;
  }
  if (text[char_offset] == '/') /* / one-byte token unless it's '/' followed by '*' */
  {
    expected_char= '/';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == '*')) goto comment_starting_with_slash_start;
    goto one_byte_token;
  }
  if ((text[char_offset] >= '0') && (text[char_offset] <= '9')) goto part_of_token; /* digit part of token */
  if (text[char_offset] == ':')    /* : might be start of := otherwise one-byte token */
  {
    if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0) expected_char= ':';
    else expected_char= '=';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    goto one_byte_token;
  }
  if (text[char_offset] == ';') goto one_byte_token; /* ; one-byte token */
  if (text[char_offset] == '<')       /* < might be start of <=  or << or <=> or <>. otherwise one-byte token */
  {
    expected_char= '=';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char))
    {
      if ((char_offset + 2 < text_length) && (text[char_offset + 2] == '>'))
      {
        expected_char= '>';
        goto skip_till_expected_char;
      }
      goto skip_till_expected_char;
    }
    expected_char= '>';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    expected_char= '<';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    goto one_byte_token;
  }
  if (text[char_offset] == '=')
  {
#ifdef DBMS_TARANTOOL
    if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0)
    {
      expected_char= '=';
      if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    }
#endif
    goto one_byte_token;          /* = one-byte token */
  }
  if (text[char_offset] == '>')   /* > might be start of >= or >>. otherwise one-byte token */
  {
    expected_char= '=';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    expected_char= '>';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    goto one_byte_token;
  }
  if (text[char_offset] == '?') goto one_byte_token; /* ? one-byte token? */
  if (text[char_offset] == '@') /* @ start of @token or start of @@token otherwise one-byte token */
  {
    if (token_lengths[token_number] == 0) goto part_of_token;
    if (token_lengths[token_number] == 1)
    {
      if (text[char_offset - 1] == '@') goto part_of_token;
    }
    goto one_byte_token;
  }
  if (text[char_offset] == '[')
  {
    if ((dbms_version_mask&FLAG_VERSION_TARANTOOL) != 0)
    {
      expected_char= '[';
      if ((char_offset + 1 < text_length) && (text[char_offset + 1] == '['))
      {
        QString tmp_s= QString(text, char_offset); /* I wonder: could I say text-> and skip this assignment? */
        QString word0, word1, word2;
        if (token_number > 0) word0= tmp_s.mid(token_offsets[0],token_lengths[0]); else word0= "";
        if (token_number > 1) word1= tmp_s.mid(token_offsets[1],token_lengths[1]); else word1= "";
        if (token_number > 2) word2= tmp_s.mid(token_offsets[2],token_lengths[2]); else word2= "";
        int tmp_statement_type;
        if ((word0.mid(0,2) == "/*") || (word1.mid(0,2) == "/*") || (word2.mid(0,2) == "/*"))
          tmp_statement_type= TOKEN_KEYWORD_SQL;
        else tmp_statement_type= get_statement_type_low(word0, word1, word2);
        if (tmp_statement_type == TOKEN_KEYWORD_DO_LUA) goto string_starting_with_bracket_start;
      }
    }
    goto one_byte_token; /* [ one-byte token which is never used except maybe in Tarantool arrays */
  }
  if (text[char_offset] == '\x5c')  goto one_byte_token; /* \ one-byte token which is never used */
  if (text[char_offset] == ']') goto one_byte_token; /* ] one-byte token which is never used */
  if (text[char_offset] == '^') goto one_byte_token; /* ^ one-byte token */
  if (text[char_offset] == '`')        /* ` starts a token until next ` but watch for end-of-string and escape */
  {
    expected_char= '`';
    goto skip_till_expected_char;
  }
  /* Changed handling of {...} on February 1 2016 */
  if (text[char_offset] == '{') goto one_byte_token;
  if (text[char_offset] == '}') goto one_byte_token;
  //if (text[char_offset] == '{')      /* { starts a token until next } but watch for end-of-string */
  //{
  //  expected_char= '}';
  //  goto skip_till_expected_char;
  //}
  if (text[char_offset] == '|')      /* | might be start of ||. otherwise one-byte token */
  {
    expected_char= '|';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    goto one_byte_token;
  }
  if (text[char_offset] == '}') goto one_byte_token; /* } one-byte token which is never used */
  if (text[char_offset] == '~') /* ~ one-byte token unless Tarantool+Lua */
  {
#ifdef DBMS_TARANTOOL
    if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0)
    {
      expected_char= '=';
      if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    }
#endif
   goto one_byte_token;
  }
  /* Remaining possibilities are:
     $, 0 to 9, A to Z, a to z
     >127 (top-bit-on is probably a continuation byte of a utf-8 character)
     _ DEL */
part_of_token:
  ++char_offset;
  ++token_lengths[token_number];
  goto next_char;
string_end:
  if (token_lengths[token_number] > 0) token_lengths[token_number + 1]= 0;
  log("tokenize end", 50);
  return;
white_space:
  if (token_lengths[token_number] > 0) ++token_number;
  ++char_offset;
  goto next_token;
string_starting_with_bracket_start:
  if (token_lengths[token_number] > 0)
  {
    ++token_number;
    token_lengths[token_number]= 0;
    token_offsets[token_number]= char_offset;
  }
  for (;;)
  {
    if (char_offset >= text_length) goto string_end;
    if (text[char_offset] == '\x00') goto string_end;
    if ((char_offset + 1 < text_length)
     && (text[char_offset] == ']')
     && (text[char_offset + 1] == ']'))
     {
       char_offset+= 2;
       token_lengths[token_number]+= 2;
       break;
     }
    ++char_offset;
    ++token_lengths[token_number];
  }
  ++token_number;
  goto next_token;
comment_starting_with_slash_start:
comment_start:
  comment_behaviour= passed_comment_behaviour;

  if (text[char_offset] == '/')
  {
    if ((char_offset + 2 < text_length) && (text[char_offset + 2] == '!'))
    {
      if ((char_offset + 8 < text_length) && (text[char_offset + 3] >= '0') && (text[char_offset + 3] <= '9'))
      {
        version_inside_comment[0]= text[char_offset + 3];
        version_inside_comment[1]= text[char_offset + 4];
        version_inside_comment[2]= text[char_offset + 5];
        version_inside_comment[3]= text[char_offset + 6];
        version_inside_comment[4]= text[char_offset + 7];
        version_inside_comment[5]= '\x00';
      }
      else
      {
        version_inside_comment[0]= '\x00';
      }
      if (strcmp((char*)version, (char*)version_inside_comment) >= 0)
      {
        if (comment_behaviour == 1) comment_behaviour= 3;
        if (comment_behaviour == 2) comment_behaviour= 4;
        expected_char= ' ';
        expected_char_at_comment_end= '/';
        if (comment_behaviour == 4)
        {
          char_offset+= 3 + strlen((char*)version_inside_comment);
          goto next_token;
        }
        goto skip_till_expected_char;
      }
    }
  }

  if (comment_behaviour == 3)
  {
    expected_char_at_comment_end= expected_char; /* / or \n */
    if (text[char_offset] == '#') goto one_byte_token;
    if (text[char_offset] == '-') expected_char='-';
    if (text[char_offset] == '/') expected_char='*';
  }
  if (comment_behaviour == 4)
  {
    /* comment_behaviour=4 means ignore / * and * / but not comment contents */
    expected_char_at_comment_end= expected_char; /* / or \n */
    if (text[char_offset] == '#') n= 1;
    else n= 2;
    goto n_byte_token_skip;
  }
skip_till_expected_char:
  /* No break if we're facing N'...' or X'...' or B'...' or @`...` or @a"..." */
  /* Todo: check: I might have forgotten N"..." etc. */
  if (token_lengths[token_number] == 1)
  {
    if (expected_char == '\x27')
    {
      if ((text[char_offset - 1] == 'N') || (text[char_offset - 1] == 'X') || (text[char_offset - 1] == 'B')
              ||(text[char_offset - 1] == 'n') || (text[char_offset - 1] == 'x') || (text[char_offset- 1] == 'b'))
      {
        goto skip_till_expected_char_2;
      }
    }
    if ((expected_char == '`') || (expected_char == '"'))
    {
      if (text[char_offset - 1] == '@')
      {
        goto skip_till_expected_char_2;
      }
    }
  }
  if (token_lengths[token_number] > 0)
  {
    ++token_number;
    token_lengths[token_number]= 0;
    token_offsets[token_number]= char_offset;
  }
skip_till_expected_char_2:
  ++char_offset;
  ++token_lengths[token_number];
  if (char_offset >= text_length) goto string_end;
  if (text[char_offset] == '\x00') goto string_end;
  if (text[char_offset] != expected_char) goto skip_till_expected_char_2;
  /* No match if / not preceded by *, \' or '' inside ''s, \" or "" inside ""s or `` inside ``s */
  if ((expected_char == '/') && (text[char_offset - 1] != '*')) goto skip_till_expected_char_2;

  /* Adjustment on 2021-08-19 because SELECT '\\'; wasn't being tokenized correctly, apparently. */
  //if ((expected_char == '\x27') && (text[char_offset - 1] == '\x5c')) goto skip_till_expected_char_2;
  //if ((expected_char == '"') && (text[char_offset - 1] == '\x5c')) goto skip_till_expected_char_2;
#if (OCELOT_MYSQL_INCLUDE == 1)
  if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) == 0)
  {
    if ((expected_char == '\x27') || (expected_char == '"'))
    {
      if (text[char_offset - 1] == '\x5c')
      {
        if ((char_offset <= 2) || (text[char_offset - 2] != '\x5c')) goto skip_till_expected_char_2;
      }
    }
  }
#endif
  if ((expected_char == '\x27') || (expected_char == '"') || (expected_char == '`'))
  {
    if ((char_offset + 1 < text_length) && (expected_char == text[char_offset + 1]))
    {
      ++char_offset;
      ++token_lengths[token_number];
      goto skip_till_expected_char_2;
    }
  }
  ++char_offset;
  ++token_lengths[token_number];
  if ((expected_char == '/') || (expected_char == '\n'))
  {
    if (comment_behaviour == 2)
    {
      /*
        comment_behaviour=2 means "ignore comments (treat them as whitespace)",
        so ignore, i.e. go for next token without incrementing token_number.
      */
      goto next_token;
    }
    if (comment_behaviour == 4)
    {
      if (expected_char == expected_char_at_comment_end)
      {
        /*
          comment_behaviour=4 means "don't ignore comments but treat begin/end
          marks as whitespace" so declare there's no more end-marks, then ignore.
        */
        expected_char_at_comment_end= ' ';
        goto next_token;
      }
    }
  }
  ++token_number;
  goto next_token;
one_byte_token: /* we know that coming token length is 1 */
  if (token_lengths[token_number] > 0) ++token_number;
  token_offsets[token_number]= char_offset;
  token_lengths[token_number]= 1;
  ++char_offset;
  ++token_number;
  goto next_token;
n_byte_token:   /* we know that coming token length is n */
  if (token_lengths[token_number] > 0) ++token_number;
  token_offsets[token_number]= char_offset;
  token_lengths[token_number]= n;
  char_offset+= n;
  ++token_number;
  goto next_token;
n_byte_token_skip:
  if (token_lengths[token_number] > 0) ++token_number;
  char_offset+= n;
  goto next_token;
}


/*
  token_type() should be useful for syntax highlighting and for hovering.
  However, it's rudimentary. If parsing routines are called, they'll override.
  Pass: token, token length. we assume it's at least 1.
  Return: type
  I could have figured this out during tokenize(), but didn't.
  See also tokens_to_keywords().
*/
int MainWindow::token_type(QChar *token, int token_length, bool ansi_quotes)
{
  if (token_length == 0) return TOKEN_TYPE_OTHER;
  /* Check whether token == delimiter_str. similar to a comparison with special_token in tokenize(). */
  {
    int special_token_length, special_token_offset;
    special_token_length= ocelot_delimiter_str.length();
    if ((special_token_length > 0)
    &&  (special_token_length == token_length))
    {
      for (special_token_offset= 0; special_token_offset < special_token_length; ++special_token_offset)
      {
        QChar special_token_char= ocelot_delimiter_str.at(special_token_offset);
        if (special_token_char != *(token+special_token_offset)) break;
      }
      if (special_token_offset == special_token_length)
      {
        return TOKEN_TYPE_OPERATOR;
      }
    }
  }

  if (*token == '\x27') return TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE;

  if (token_length > 1)
  {
    if ((*token == 'N') || (*token == 'X') || (*token == 'B')
     || (*token == 'n') || (*token == 'x') || (*token == 'b'))
    {
     if (*(token + 1) == '\x27') return TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE;
    }
    if ((*token == '[') && (*(token + 1) == '['))
    {
      return TOKEN_TYPE_LITERAL_WITH_BRACKET;
    }
  }
  if (*token == '"')
  {
    if (ansi_quotes) return TOKEN_TYPE_IDENTIFIER_WITH_DOUBLE_QUOTE;
    return TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE;
  }
  if ((*token >= '0') && (*token <= '9')) return TOKEN_TYPE_LITERAL_WITH_DIGIT;
  if ((token_length > 1) && (*token == '.'))
  {
    if ((*(token + 1)>= '0') && (*(token + 1) <= '9')) return TOKEN_TYPE_LITERAL_WITH_DIGIT;
  }
  //if (*token == '{') return TOKEN_TYPE_LITERAL_WITH_BRACE;
  if ((*token == '{') || (*token == '}')) return TOKEN_TYPE_OPERATOR;
  if ((*token == '[') || (*token == ']'))
  {
    if (dbms_version_mask&FLAG_VERSION_TARANTOOL) return TOKEN_TYPE_OPERATOR;
  }
  if (*token == '`') return TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK;
  if (*token == '@') return TOKEN_TYPE_IDENTIFIER_WITH_AT;
  if (token_length > 1)
  {
    if ((*token == '/') && (*(token + 1) == '*')) return TOKEN_TYPE_COMMENT_WITH_SLASH;
    if ((*token == '*') && (*(token + 1) == '/')) return TOKEN_TYPE_COMMENT_WITH_SLASH;
  }
  if (*token == '#')
  {
    if (dbms_version_mask&FLAG_VERSION_TARANTOOL) return TOKEN_TYPE_OPERATOR;
    return TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE;
  }
  if (token_length > 1)
  {
    if ((*token == '-') && (*(token + 1) == '-')) return TOKEN_TYPE_COMMENT_WITH_MINUS;
  }
  if ((*token > ' ') && (*token < 'A') && (*token != '$')) return TOKEN_TYPE_OPERATOR;
  return TOKEN_TYPE_OTHER;
}

/*
  We depend on some defined | constant values being correct, the right size, in order, etc.
  So at the start we call these checks. So far most of them are related to strvalues.
  Things will only go wrong if the code or the platform changes.
  The time-consuming check is commented out, re-enable it if you changed something significant.
  Todo: rather than asserts, do runtime tests iff debug mode.
*/
void MainWindow::initial_asserts()
{
  /* Maximum QString length = sizeof(int)/4. Maximum LONGBLOB length = 2**32. So 32 bit int is ok. */
  assert(sizeof(int) >= 4);

  #ifdef OCELOT_OS_LINUX
  #if defined(NDEBUG)
    if (MENU_FONT != 95) {printf("assert(MENU_FONT == 93);"); exit(1); }
  #else
    assert(MENU_FONT == 95); /* See kludge alert in ocelotgui.h Settings() */
  #endif
  #else
    assert(MENU_FONT != 0);  /* i.e. "if Windows, we don't care." */
  #endif

  assert(TOKEN_REFTYPE_MAX == 91); /* See comment after ocelotgui.h TOKEN_REFTYPE_MAX */

  //printf("TOKEN_KEYWORD__UTf8MB4 == %d\n", TOKEN_KEYWORD__UTF8MB4);

  //printf("TOKEN_KEYWORD_OCELOT_XML - TOKEN_KEYWORD_OCELOT_BATCH=%d\n", TOKEN_KEYWORD_OCELOT_XML - TOKEN_KEYWORD_OCELOT_BATCH);

  /* If the following assert happens, you inserted/removed something in strvalues[] */
  /* without changing KEYWORD_LIST_SIZE in tokens_to_keywords(). */
  /* That is okay but you must change all occurrences of KEYWORD_LIST_SIZE to the new size */
  /* and you should also temporarily uncomment the "test strvalues" test below. */
  assert(TOKEN_KEYWORD__UTF8MB4 == KEYWORD_LIST_SIZE - 1);

  /* If the following assert happens, you inserted/removed an OCELOT_... item in strvalues. */
  /* That is okay but you must change this occurrence of "147" to the new size */
  /* and you should also look whether SET statements cause an overflow */
  /* See hparse.h comment "If you add to this, hparse_errmsg might not be big enough." */
  /* Temporarily uncomment the check later whether ocelot_keyword_lengths > MAX_HPARSE_ERRMSG_LENGTH */
  assert(TOKEN_KEYWORD_OCELOT_XML - TOKEN_KEYWORD_OCELOT_BATCH == 147);

  /* If the following assert happens, you put something before "?" in strvalues[]. */
  /* That is okay but you must ensure that the first non-placeholder is strvalues[TOKEN_KEYWORDS_START]. */
  assert(TOKEN_KEYWORD_QUESTIONMARK == TOKEN_KEYWORDS_START);

#ifdef ADDITIONAL_ASSERTS
  //* Test strvalues is ordered by bsearching for every item. */
  // This is commented out i.e. we don't define ADDITIONAL_ASSERTS unless there has been a change to the list */
  char *p_item;
  unsigned long index;
  char l[MAX_KEYWORD_LENGTH+1]= "";
  for (int ii= TOKEN_KEYWORD_QUESTIONMARK; ii < KEYWORD_LIST_SIZE; ++ii)
   {
     char *k= (char*) &strvalues[ii].chars;
     if (strcmp(k, l) <= 0) {printf("k <= l!\n"); exit(0); }
     printf("ii=%d\n", ii);
     printf("k=%s.\n", k);
     p_item= (char*) bsearch(k, strvalues, KEYWORD_LIST_SIZE, sizeof(struct keywords), (int(*)(const void*, const void*)) strcmp);
     assert(p_item != NULL);
     index= ((((unsigned long)p_item - (unsigned long)strvalues)) / sizeof(struct keywords));
     printf("ii=%d, index=%ld, k=%s. l=%s.\n", ii, index, k, l);
     if (index != strvalues[ii].token_keyword) exit(0);
     assert(index == strvalues[ii].token_keyword);
     strcpy(l, k);
   }
  assert(strcmp(strvalues[TOKEN_KEYWORD_QUESTIONMARK].chars, "?") == 0);
  assert(strcmp(strvalues[TOKEN_KEYWORD__UTF8MB4].chars, "_UTF8MB4") == 0);
  {
    int ocelot_keyword_lengths= 200; /* approximately what hparse_f_errormsg() adds */
    for (int ii= TOKEN_KEYWORD_OCELOT_BATCH; ii <= TOKEN_KEYWORD_OCELOT_XML; ++ii)
    {
      char *k= (char*) &strvalues[ii].chars;
      printf("k=%s.\n", k);
      ocelot_keyword_lengths+= strlen(k) + 3;
    }
    if (ocelot_keyword_lengths > MAX_HPARSE_ERRMSG_LENGTH)
    {
      printf("ocelot_keyword_lengths=%d\n", ocelot_keyword_lengths);
      printf("MAX_HPARSE_ERRMSG_LENGTH=%d\n", MAX_HPARSE_ERRMSG_LENGTH);
      exit(0);
    }
  }
#endif //ADDITIONAL_ASSERTS
}

void MainWindow::tokens_to_keywords(QString text, int start, bool ansi_quotes)
{
  log("tokens_to_keywords start", 80);

  //QString text;
  QString s= "";
  int t;
  int index;
  char key2[MAX_KEYWORD_LENGTH + 1];
  int i2;

  //text= statement_edit_widget->toPlainText();
  for (i2= start; main_token_lengths[i2] != 0; ++i2)
  {
    /* Get the next word. */
    s= text.mid(main_token_offsets[i2], main_token_lengths[i2]);
    t= token_type(s.data(), main_token_lengths[i2], ansi_quotes);
    main_token_types[i2]= t;
    main_token_flags[i2]= 0;
    main_token_pointers[i2]= 0;
    main_token_reftypes[i2]= 0;
    if ((t == TOKEN_TYPE_OTHER) && (main_token_lengths[i2] < MAX_KEYWORD_LENGTH))
    {
      /* It's not a literal or operator. Maybe it's a keyword. Convert it to char[]. */
      QByteArray key_as_byte_array= s.toLocal8Bit();
      const char *key= key_as_byte_array.data();
      index= get_keyword_index(key, key2);

      if (index != -1)
      {
        /* It's in the list, so instead of TOKEN_TYPE_OTHER, make it TOKEN_KEYWORD_something. */
        if ((strvalues[index].reserved_flags & dbms_version_mask) != 0)
          main_token_flags[i2]= (main_token_flags[i2] | TOKEN_FLAG_IS_RESERVED);
        if ((strvalues[index].built_in_function_flags & dbms_version_mask) != 0)
        {
          main_token_flags[i2]= (main_token_flags[i2] | TOKEN_FLAG_IS_FUNCTION);
        }
        if ((strvalues[index].reserved_flags & FLAG_VERSION_LUA) != 0)
          main_token_flags[i2]= (main_token_flags[i2] | TOKEN_FLAG_IS_MAYBE_LUA);
        //index+= TOKEN_KEYWORDS_START; commented out on 2019-02-27
        main_token_types[i2]= index;
      }
#if (OCELOT_MYSQL_DEBUGGER == 1)
      else
      {
        /* It's not in the list, but if it's unambiguously $DEB[UG] etc. then consider it a debug keyword. */
        if ((key2[0] == '$') && (key2[1] != '\0'))
        {
          if (strncmp(key2, "$BREAKPOINT", strlen(key2)) == 0) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_BREAKPOINT;
          if ((strlen(key2) > 2) && (strncmp(key2, "$CLEAR", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_CLEAR;
          if ((strlen(key2) > 2) && (strncmp(key2, "$CONTINUE", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_CONTINUE;
          if ((strlen(key2) > 3) && (strncmp(key2, "$DEBUG", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_DEBUG;
          if ((strlen(key2) > 3) && (strncmp(key2, "$DELETE", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_DELETE;
          if ((strlen(key2) > 3) && (strncmp(key2, "$EXECUTE", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_EXECUTE;
          if ((strlen(key2) > 3) && (strncmp(key2, "$EXIT", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_EXIT;
          if ((strlen(key2) > 3) && (strncmp(key2, "$INFORMATION", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_INFORMATION;
          if ((strlen(key2) > 3) && (strncmp(key2, "$INSTALL", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_INSTALL;
          if (strncmp(key2, "$LEAVE", strlen(key2)) == 0) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_LEAVE;
          if (strncmp(key2, "$NEXT", strlen(key2)) == 0) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_NEXT;
          if (strncmp(key2, "$REFRESH", strlen(key2)) == 0) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_REFRESH;
          if (strcmp(key2, "$SET") == 0) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_SET;
          if ((strlen(key2) > 4) && (strncmp(key2, "$SETUP", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_SETUP;
          if ((strlen(key2) > 2) && (strncmp(key2, "$SKIP", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_SKIP;
          if ((strlen(key2) > 2) && (strncmp(key2, "$SOURCE", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_SOURCE;
          if ((strlen(key2) > 2) && (strncmp(key2, "$STEP", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_STEP;
          if (strncmp(key2, "$TBREAKPOINT", strlen(key2)) == 0) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_TBREAKPOINT;
        }
      }
#endif
    }
  }

  /* Global. Sometimes we'll want to know how many tokens there are. */
  main_token_count_in_all= i2;

  main_token_types[i2]= 0; /* since main_token_lengths[i2] == 0, types and flags etc. are too. */
  main_token_flags[i2]= 0;
  main_token_pointers[i2]= 0;
  main_token_reftypes[i2]= 0;

  /* The special cases of BEGIN, DO, END, FUNCTION, ROW. */
  int i_of_function= -1;
  int i_of_do= -1;
  int start_of_body= find_start_of_body(text, start, &i_of_function, &i_of_do);

  tokens_to_keywords_revert(start_of_body, i_of_function, i_of_do, text, start);

  /*
    The special case of "?". Although tokenize() says ? is an operator,
    we might have to treat it as a keyword meaning "help".
  */
  if (main_token_lengths[start] == 1)
  {
    s= text.mid(main_token_offsets[start], 1);
    if (s == QString("?")) main_token_types[start]= TOKEN_KEYWORD_QUESTIONMARK;
  }

  /*
    The special cases of "\q" etc.:
    If token[0] is "\" and token[q] == "q" (lower case only), that's equivalent to "quit".
    They're still separate tokens -- changing tokenize() to say "\=" is not a keyword is not
    appropriate because "\" really should be an operator. But treat both tokens as the
    same keyword, TOKEN_KEYWORD_QUIT.
    This is for mysql compatibility.
    I couldn't find a consistent rule, but it seems that the statement pair could be at the
    start, could be at the end, or could be at the end before a delimiter.
    The list is in order by TOKEN_KEYWORD_... value.
  */
  /* Todo: There is interference with the statement "prompt \u" and maybe other special prompts */
  /* Todo: This is completely wrecked if start!=0 because of delimiter */
  int xx= -1;
  if (i2 >= 2)
  {
    /* Todo: what about the delimiter? */
    if ((main_token_offsets[1] == 1)
     && (main_token_lengths[1] == 1)
     && (text.mid(main_token_offsets[0], main_token_lengths[0]) == "\\"))
    {
      xx= 0;
    }
    else if ((main_token_lengths[main_token_count_in_all - 2] == 1)
     && (main_token_lengths[main_token_count_in_all - 1] == 1)
     && (text.mid(main_token_offsets[main_token_count_in_all - 2], main_token_lengths[main_token_count_in_all - 2]) == "\\"))
    {
      xx= main_token_count_in_all - 2;
    }
  }
  if (i2 >= 3)
  {
    s= text.mid(main_token_offsets[i2 - 1], main_token_lengths[i2 - 1]);
    /* Todo: compare with delimiter, which isn't always semicolon. */
    if (s == (QString)ocelot_delimiter_str)
    {
      if ((main_token_lengths[main_token_count_in_all - 3] == 1)
       && (main_token_lengths[main_token_count_in_all - 2] == 1)
       && (text.mid(main_token_offsets[main_token_count_in_all - 3], main_token_lengths[main_token_count_in_all - 3]) == "\\"))

      {
        xx= main_token_count_in_all - 3;
      }
    }
  }
  if (xx >= 0)
  {
    s= text.mid(main_token_offsets[xx], 2);
    if (s == QString("\\?")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_QUESTIONMARK;
    if (s == QString("\\C")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_CHARSET;
    if (s == QString("\\c")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_CLEAR;
    if (s == QString("\\r")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_CONNECT;
    if (s == QString("\\d")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_DELIMITER;
    if (s == QString("\\e")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_EDIT;
    if (s == QString("\\G")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_EGO;
    if (s == QString("\\g")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_GO;
    if (s == QString("\\h")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_HELP_IN_CLIENT;
    if (s == QString("\\n")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_NOPAGER;
    if (s == QString("\\t")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_NOTEE;
    if (s == QString("\\w")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_NOWARNING;
    if (s == QString("\\P")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_PAGER;
    if (s == QString("\\p")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_PRINT;
    if (s == QString("\\R")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_PROMPT;
    if (s == QString("\\q")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_QUIT;
    if (s == QString("\\#")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_REHASH;
    if (s == QString("\\.")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_SOURCE;
    if (s == QString("\\s")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_STATUS;
    if (s == QString("\\!")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_SYSTEM;
    if (s == QString("\\T")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_TEE;
    if (s == QString("\\u")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_USE;
    if (s == QString("\\W")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_WARNINGS;
  }
  log("tokens_to_keywords end", 80);
}

/*
  Pass a word. Return a pointer to the keywords list, or 0 if word is not in keywords list.
  And change key2, which must be big enough to store the biggest word, to upper(key).
  Todo: the calculation in the return might not be portable, maybe use strvalues[x].token_keyword
*/
int MainWindow::get_keyword_index(const char *key, char *key2)
{
  int i;
  char *p_item;
  /* Uppercase it. I don't necessarily have strupr() or strcmpi(). */
  for (i= 0; (*(key + i) != '\0') && (i < MAX_KEYWORD_LENGTH); ++i) key2[i]= toupper(*(key + i));
  key2[i]= '\0';
  /* Search it with library binary-search. Assume KEYWORD_LIST_SIZE items and everything MAX_KEYWORD_LENGTH bytes long. */
  p_item=  (char*) bsearch(key2, strvalues, KEYWORD_LIST_SIZE, sizeof(struct keywords), (int(*)(const void*, const void*)) strcmp);
  if (p_item == NULL) return -1;
  return (int)((((unsigned long)p_item - (unsigned long)strvalues)) / sizeof(struct keywords));
}

/*
  Todo: There are a few places where we do something like this,
        change them to calls to get_keyword_index_from_qstring().
*/
int MainWindow::get_keyword_index_from_qstring(QString key)
{
  char key1[MAX_KEYWORD_LENGTH + 1];
  char key2[MAX_KEYWORD_LENGTH + 1];
  strcpy(key1, key.toUtf8());
  return get_keyword_index(key1, key2);
}

/*
  Return true if the passed token number is for the first word of a client statement.
*/
bool MainWindow::is_client_statement(int token, int i,QString text)
{
  if ((token == TOKEN_KEYWORD_QUESTIONMARK)
  ||  (token == TOKEN_KEYWORD_CHARSET)
  ||  (token == TOKEN_KEYWORD_CLEAR)
  ||  (token == TOKEN_KEYWORD_CONNECT)
  ||  (token == TOKEN_KEYWORD_DELIMITER)
  ||  (token == TOKEN_KEYWORD_EDIT)
  ||  (token == TOKEN_KEYWORD_EGO)
  ||  (token == TOKEN_KEYWORD_EXIT)
  ||  (token == TOKEN_KEYWORD_GO)
  ||  (token == TOKEN_KEYWORD_HELP_IN_CLIENT)
  ||  (token == TOKEN_KEYWORD_NOPAGER)
  ||  (token == TOKEN_KEYWORD_NOTEE)
  ||  (token == TOKEN_KEYWORD_NOWARNING)
  ||  (token == TOKEN_KEYWORD_PAGER)
  ||  (token == TOKEN_KEYWORD_PRINT)
  ||  (token == TOKEN_KEYWORD_PROMPT)
  ||  (token == TOKEN_KEYWORD_QUIT)
#if (OCELOT_EXPLORER == 1)
  ||  (token == TOKEN_KEYWORD_REFRESH)
#endif
  ||  (token == TOKEN_KEYWORD_REHASH)
  ||  (token == TOKEN_KEYWORD_SOURCE)
  ||  (token == TOKEN_KEYWORD_STATUS)
  ||  (token == TOKEN_KEYWORD_SYSTEM)
  ||  (token == TOKEN_KEYWORD_TEE)
  ||  (token == TOKEN_KEYWORD_USE)
  ||  (token == TOKEN_KEYWORD_WARNINGS))
    return true;
  if (token == TOKEN_KEYWORD_SET)
  {
    if (main_token_lengths[i + 1] > 7)
    {
      QString s= text.mid(main_token_offsets[i + 1], 7);
      if (QString::compare(s, "OCELOT_", Qt::CaseInsensitive) == 0)
      {
        return true;
      }
    }
  }
#if (OCELOT_MYSQL_DEBUGGER == 1)
  if ((token >= TOKEN_KEYWORD_DEBUG_BREAKPOINT)
   && (token <= TOKEN_KEYWORD_DEBUG_TBREAKPOINT))
    return true;
#endif
  return false;
}

/*
  Find start of body in CREATE ... FUNCTION|PROCEDURE|TRIGGER statement
  This is tricky and might need revisiting if syntax changes in later MySQL versions.
  First find out whether the statement is CREATE ... FUNCTION|PROCEDURE|TRIGGER|EVENT.
  A definer clause might have to be skipped.
  If it's CREATE TRIGGER: skip till past FOR EACH ROW.
                          but watch for new PRECEDES|FOLLOWS clauses
  If it's CREATE EVENT: skip till past ON and past DO.
  If it's CREATE PROCEDURE|FUNCTION:
    skip past ()s
   (Function) Skip returns clause i.e. skip until anything is seen which is not one of the following:
      anything within ()s
      ASCII BIGINT BINARY BIT BLOB BOOL BOOLEAN CHAR CHARACTER CHARSET COLLATE DATE DATETIME DEC
      DECIMAL DOUBLE ENUM FLOAT
      GEOMETRY GEOMETRYCOLLECTION INT INTEGER LINESTRING LONGBLOB LONGTEXT MEDIUMBLOB MEDIUMINT MEDIUMTEXT
      MULTILINESTRING MULTIPOINT MULTIPOLYGON NUMERIC POINT POLYGON PRECISION RETURNS
      SERIAL SET(...) SMALLINT TIME TIMESTAMP TINYBLOB TINYINT TINYTEXT UNICODE UNSIGNED VARCHAR VARYING YEAR ZEROFILL
      name if previous is CHARSET | CHARACTER SET | COLLATE
   (Function or Procedure) Skip words that are in characteristics i.e.
     COMMENT 'string', LANGUAGE SQL, DETERMINISTIC, NOT DETERMINISTIC,
     CONTAINS SQL, NO SQL, READS SQL DATA, MODIFIES SQL DATA,
     SQL SECURITY DEFINER, SQL SECURITY INVOKER
   (Function or Procedure) Watch for Oracle-style {IS|AS} body
   Skipping comments too
   Return: offset for first word of body, or -1 if not-create-routine | body-not-found
   todo: there might be a problem with "create procedure|function function ...".
   No worries: even if this doesn't get everything right, parsing will come later.
*/
int MainWindow::find_start_of_body(QString text, int start, int *i_of_function, int *i_of_do)
{
  int i;
  int create_seen= 0;
  int procedure_seen= 0;
  int function_seen= 0;
  int trigger_seen= 0;
  int trigger_for_seen= 0;
  int trigger_row_seen= 0;
  int trigger_precedes_seen= 0;
  int trigger_name_seen= 0;
  int parameter_list_seen= 0;
  int parentheses_count= 0;
  int characteristic_seen= 0;
  int data_type_seen= 0;
  int character_set_seen= 0;
  int collate_seen= 0;
  int event_seen= 0;
  int event_do_seen= 0;
  int event_on_seen= 0;

  for (i= start; main_token_lengths[i] != 0; ++i)
  {
    if ((main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
     || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_SLASH)
     || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_MINUS))
    {
      continue;
    }
    if (trigger_precedes_seen == 1)
    {
      if (main_token_types[i] == TOKEN_TYPE_OPERATOR)
      {
        trigger_name_seen= 0;
        continue;
      }
      if (trigger_name_seen == 1)
      {
        return i;
      }
      trigger_name_seen= 1;
      continue;
    }
    if (trigger_row_seen == 1)
    {
      if ((main_token_types[i] == TOKEN_KEYWORD_PRECEDES)
       || (main_token_types[i] == TOKEN_KEYWORD_FOLLOWS))
      {
        trigger_precedes_seen= 1;
        continue;
      }
      return i;
    }
    if (event_do_seen == 1)
    {
      return i;
    }
    if (main_token_types[i] == TOKEN_KEYWORD_CREATE)
    {
      create_seen= 1;
      continue;
    }
    if (create_seen != 1)
    {
      return -1;
    }
    if (main_token_types[i] == TOKEN_KEYWORD_PROCEDURE)
    {
      procedure_seen= 1;
      continue;
    }
    if (main_token_types[i] == TOKEN_KEYWORD_FUNCTION)
    {
      function_seen= 1;
      *i_of_function= i;
      continue;
    }
    if (main_token_types[i] == TOKEN_KEYWORD_TRIGGER)
    {
      trigger_seen= 1;
      continue;
    }
    if (main_token_types[i] == TOKEN_KEYWORD_EVENT)
    {
      event_seen= 1;
      continue;
    }
    if (trigger_seen == 1)
    {
      if (main_token_types[i] == TOKEN_KEYWORD_FOR) trigger_for_seen= 1;
      if (trigger_for_seen == 1)
      {
        if (main_token_types[i] == TOKEN_KEYWORD_ROW) trigger_row_seen= 1;
      }
    }
    if (event_seen == 1)
    {
      if (main_token_types[i] == TOKEN_KEYWORD_ON)
      {
        event_on_seen= 1;
      }
      if (event_on_seen == 1)
      {
        if (main_token_types[i] == TOKEN_KEYWORD_DO)
        {
          *i_of_do= i;
          event_do_seen= 1;
        }
      }
    }
    if ((function_seen == 1) || (procedure_seen == 1))
    {
      if ((parameter_list_seen == 0) && (main_token_types[i] == TOKEN_TYPE_OPERATOR) && (main_token_lengths[i] == 1))
      {
        if (text.mid(main_token_offsets[i], main_token_lengths[i]) == "(")
        {
          ++parentheses_count;
          continue;
        }
        if (text.mid(main_token_offsets[i], main_token_lengths[i]) == ")")
        {
          --parentheses_count;
          if (parentheses_count == 0)
          {
            parameter_list_seen= 1;
            continue;
          }
        }
      }
    }

    if ((function_seen == 1) && (parameter_list_seen == 1) && (characteristic_seen == 0))
    {
      if (text.mid(main_token_offsets[i], main_token_lengths[i]) == "(")
      {
        ++parentheses_count;
        continue;
      }
      if (text.mid(main_token_offsets[i], main_token_lengths[i]) == ")")
      {
        --parentheses_count;
        continue;
      }
      if (parentheses_count != 0)
      {
        continue;
      }
      if (main_token_types[i] == TOKEN_KEYWORD_RETURNS)
      {
        continue;
      }
      if (data_type_seen == 0)
      {
        if ((main_token_types[i] == TOKEN_KEYWORD_ASCII)
         || (main_token_types[i] == TOKEN_KEYWORD_BIGINT)
         || (main_token_types[i] == TOKEN_KEYWORD_BFILE)
         || (main_token_types[i] == TOKEN_KEYWORD_BIGINT)
         || (main_token_types[i] == TOKEN_KEYWORD_BINARY)
         || (main_token_types[i] == TOKEN_KEYWORD_BINARY_DOUBLE)
         || (main_token_types[i] == TOKEN_KEYWORD_BINARY_FLOAT)
         || (main_token_types[i] == TOKEN_KEYWORD_BIT)
         || (main_token_types[i] == TOKEN_KEYWORD_BLOB)
         || (main_token_types[i] == TOKEN_KEYWORD_BOOL)
         || (main_token_types[i] == TOKEN_KEYWORD_BOOLEAN)
         || (main_token_types[i] == TOKEN_KEYWORD_CHAR)
         || (main_token_types[i] == TOKEN_KEYWORD_CHARACTER)
         || (main_token_types[i] == TOKEN_KEYWORD_DATE)
         || (main_token_types[i] == TOKEN_KEYWORD_DATETIME)
         || (main_token_types[i] == TOKEN_KEYWORD_DEC)
         || (main_token_types[i] == TOKEN_KEYWORD_DECIMAL)
         || (main_token_types[i] == TOKEN_KEYWORD_DOUBLE)
         || (main_token_types[i] == TOKEN_KEYWORD_ENUM)
         || (main_token_types[i] == TOKEN_KEYWORD_FLOAT)
         || (main_token_types[i] == TOKEN_KEYWORD_GEOMETRY)
         || (main_token_types[i] == TOKEN_KEYWORD_GEOMETRYCOLLECTION)
         || (main_token_types[i] == TOKEN_KEYWORD_INT)
         || (main_token_types[i] == TOKEN_KEYWORD_INTEGER)
         || (main_token_types[i] == TOKEN_KEYWORD_JSON)
         || (main_token_types[i] == TOKEN_KEYWORD_LINESTRING)
         || (main_token_types[i] == TOKEN_KEYWORD_LONGBLOB)
         || (main_token_types[i] == TOKEN_KEYWORD_LONGTEXT)
         || (main_token_types[i] == TOKEN_KEYWORD_MEDIUMBLOB)
         || (main_token_types[i] == TOKEN_KEYWORD_MEDIUMINT)
         || (main_token_types[i] == TOKEN_KEYWORD_MEDIUMTEXT)
         || (main_token_types[i] == TOKEN_KEYWORD_MULTILINESTRING)
         || (main_token_types[i] == TOKEN_KEYWORD_MULTIPOINT)
         || (main_token_types[i] == TOKEN_KEYWORD_MULTIPOLYGON)
         || (main_token_types[i] == TOKEN_KEYWORD_NUMBER)
         || (main_token_types[i] == TOKEN_KEYWORD_NUMERIC)
         || (main_token_types[i] == TOKEN_KEYWORD_NVARCHAR2)
         || (main_token_types[i] == TOKEN_KEYWORD_POINT)
         || (main_token_types[i] == TOKEN_KEYWORD_POLYGON)
         || (main_token_types[i] == TOKEN_KEYWORD_RAW)
         || (main_token_types[i] == TOKEN_KEYWORD_SERIAL)
         || (main_token_types[i] == TOKEN_KEYWORD_SET)
         || (main_token_types[i] == TOKEN_KEYWORD_SMALLINT)
         || (main_token_types[i] == TOKEN_KEYWORD_TIME)
         || (main_token_types[i] == TOKEN_KEYWORD_TIMESTAMP)
         || (main_token_types[i] == TOKEN_KEYWORD_TINYBLOB)
         || (main_token_types[i] == TOKEN_KEYWORD_TINYINT)
         || (main_token_types[i] == TOKEN_KEYWORD_TINYTEXT)
         || (main_token_types[i] == TOKEN_KEYWORD_UNICODE)
         || (main_token_types[i] == TOKEN_KEYWORD_VARCHAR)
         || (main_token_types[i] == TOKEN_KEYWORD_VARCHAR2)
         || (main_token_types[i] == TOKEN_KEYWORD_VARCHARACTER)
         || (main_token_types[i] == TOKEN_KEYWORD_YEAR))
        {
          data_type_seen= 1;
          continue;
        }
      }
      if (data_type_seen == 1)
      {
        if ((main_token_types[i] == TOKEN_KEYWORD_PRECISION)
         || (main_token_types[i] == TOKEN_KEYWORD_VARYING)
         || (main_token_types[i] == TOKEN_KEYWORD_UNSIGNED)
         || (main_token_types[i] == TOKEN_KEYWORD_ZEROFILL))
        {
          continue;
        }
        if ((main_token_types[i] == TOKEN_KEYWORD_CHARSET) || (main_token_types[i] == TOKEN_KEYWORD_CHARACTER))
        {
          character_set_seen= 1;
          continue;
        }
        if (main_token_types[i] == TOKEN_KEYWORD_COLLATE)
        {
          collate_seen= 1;
          continue;
        }
        if (character_set_seen == 1)
        {
          if (main_token_types[i] == TOKEN_KEYWORD_SET)
          {
            continue;
          }
          character_set_seen= 0;
          continue;
        }
        if (collate_seen == 1)
        {
          collate_seen= 0;
          continue;
        }
      }
    }

    if (((function_seen == 1) || (procedure_seen == 1)) && (parameter_list_seen == 1))
    {
      if ((text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "COMMENT")
       || (text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "LANGUAGE")
       || (main_token_types[i] == TOKEN_KEYWORD_SQL)
       || (main_token_types[i] == TOKEN_KEYWORD_DETERMINISTIC)
       || (main_token_types[i] == TOKEN_KEYWORD_NOT)
       || (text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "CONTAINS")
       || (text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "NO")
       || (main_token_types[i] == TOKEN_KEYWORD_READS)
       || (text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "DATA")
       || (main_token_types[i] == TOKEN_KEYWORD_MODIFIES)
       || (text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "SECURITY")
       || (text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "DEFINER")
       || (text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "INVOKER")
       || (main_token_types[i] == TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE)
       || (main_token_types[i] == TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE)
       || (main_token_types[i] == TOKEN_TYPE_LITERAL))
      {
        characteristic_seen= 1;
        continue;
      }
    }
    /* Todo: consider checking for ROLE too, but it is not a reserved word. */
    if ((main_token_types[i] == TOKEN_KEYWORD_DATABASE)
     || (main_token_types[i] == TOKEN_KEYWORD_INDEX)
     || (main_token_types[i] == TOKEN_KEYWORD_LOGFILE)
     || (main_token_types[i] == TOKEN_KEYWORD_SERVER)
     || (main_token_types[i] == TOKEN_KEYWORD_TABLE)
     || (main_token_types[i] == TOKEN_KEYWORD_TABLESPACE)
     || (main_token_types[i] == TOKEN_KEYWORD_VIEW))
    {
      if (function_seen + procedure_seen + trigger_seen + event_seen == 0)
      {
        return -1;
      }
    }
    if ((function_seen == 1) || (procedure_seen == 1))
    {
      if (parameter_list_seen == 0) continue;
      if ((main_token_types[i] == TOKEN_KEYWORD_IS)
       || (main_token_types[i] == TOKEN_KEYWORD_AS))
      {
        continue;
      }
      return i;
    }
  }
  return -1;
}


/*
  The special cases of FUNCTION, ROW, DO, END, BEGIN. We don't want to mark them as special unless
  we know they're really serving a non-identifier role in the statement, but they might be,
  because they're not reserved. This has to be right because later we might count BEGINs
  minus ENDs in order to figure out whether a compound statement has ended.
  FUNCTION is a keyword if: previous == DROP or CREATE [definer=...] or DROP (this is known in advance)
  ROW is a keyword if: previous == EACH
  DO is a keyword if: last statement-beginner keyword was WHILE
                      and next is a statement-beginner keyword or a label
                      (but actually this just checks whether we're within WHILE -- Todo: must fix that someday)
  END is a keyword if: previous == ; or BEGIN
  BEGIN is a keyword if: previous ==  ; or : or BEGIN or DO or ELSE or LOOP or ROW or THEN
                         or previous = ) and word before matching ( is PROCEDURE or FUNCTION or TRIGGER
                         and next is not :
                         or it's first word in main body or handler body, which is what causes most of the difficulties.
*/
void MainWindow::tokens_to_keywords_revert(int i_of_body, int i_of_function, int i_of_do, QString text, int start)
{
  if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0) return;
  int i;                                                /* index of current token */
  int i_prev= -1;                                       /* index of last non-comment token */
  int i_of_while= -1;                                   /* index of last keyword = while */

  for (i= start; main_token_lengths[i] != 0; ++i)
  {
    /* If this is a comment then don't note its position i.e. i_prev is only for non-comment tokens */
    if ((main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
     || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_SLASH)
     || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_MINUS))
    {
      continue;
    }
    if (i_prev != -1)
    {
      /* If this is ":" then the last item can't have been a keyword */
      if (QString::compare(text.mid(main_token_offsets[i], main_token_lengths[i]), ":") == 0)
      {
        if ((main_token_types[i_prev] >= TOKEN_KEYWORDS_START))
        {
          main_token_types[i_prev]= TOKEN_TYPE_OTHER;
        }
      }
      /* If this is FUNCTION then it's not a keyword unless previous was DROP or CREATE [definer=...] */
      if (main_token_types[i] == TOKEN_KEYWORD_FUNCTION)
      {
        if ((i == i_of_function) || (main_token_types[i_prev] == TOKEN_KEYWORD_DROP)) ;
        else main_token_types[i]= TOKEN_TYPE_OTHER;
      }
      /* If this is ROW then it's not a keyword unless previous was EACH as in FOR EACH ROW */
      if (main_token_types[i] == TOKEN_KEYWORD_ROW)
      {
        if (main_token_types[i_prev] == TOKEN_KEYWORD_EACH) ;
        else main_token_types[i]= TOKEN_TYPE_OTHER;
      }
      /* If this is DO then it's not a keyword unless it's after WHILE (condition) */
      if (main_token_types[i] == TOKEN_KEYWORD_DO)
      {
        if (i_of_while != -1) i_of_while= -1;
        else
        {
          if (i != i_of_do)
          {
            main_token_types[i]= TOKEN_TYPE_OTHER;
          }
        }
      }
      /* If this is END then it's not a keyword unless previous was ; or BEGIN */
      if (main_token_types[i] == TOKEN_KEYWORD_END)
      {
        if ((QString::compare(text.mid(main_token_offsets[i_prev], main_token_lengths[i_prev]), ";") == 0)
        || (main_token_types[i_prev] == TOKEN_KEYWORD_BEGIN)) ;
        else main_token_types[i]= TOKEN_TYPE_OTHER;
      }
      /* If this is BEGIN then it's not a keyword unless it's body start or prev = BEGIN|DO|ELSE|LOOP|ROW|THEN */
      if (main_token_types[i] == TOKEN_KEYWORD_BEGIN)
      {
        if ((i == i_of_body)
        || (QString::compare(text.mid(main_token_offsets[i_prev], main_token_lengths[i_prev]), ":") == 0)
        || (QString::compare(text.mid(main_token_offsets[i_prev], main_token_lengths[i_prev]), ";") == 0)
        || (main_token_types[i_prev] == TOKEN_KEYWORD_BEGIN)
        || (main_token_types[i_prev] == TOKEN_KEYWORD_DO)
        || (main_token_types[i_prev] == TOKEN_KEYWORD_ELSE)
        || (main_token_types[i_prev] == TOKEN_KEYWORD_LOOP)
        || (main_token_types[i_prev] == TOKEN_KEYWORD_ROW)
        || (main_token_types[i_prev] == TOKEN_KEYWORD_THEN)) ;
        else main_token_types[i]= TOKEN_TYPE_OTHER;
      }
    }
    if (main_token_types[i] == TOKEN_KEYWORD_WHILE) i_of_while= i;
    if ((QString::compare(text.mid(main_token_offsets[i], main_token_lengths[i]), "HANDLER", Qt::CaseInsensitive) == 0)
     && (main_token_types[next_token(i)] == TOKEN_KEYWORD_FOR))
    {
      /* DECLARE ... HANDLER FOR might be followed by BEGIN so we have to find where statement starts */
      int i_plus_1, i_plus_2, i_plus_3, i_plus_4, i_next;
      i= next_token(i);
      for (;;)
      {
        i_plus_1= next_token(i);
        i_plus_2= next_token(i_plus_1);
        i_plus_3= next_token(i_plus_2);
        i_plus_4= next_token(i_plus_3);
        if ((main_token_types[i_plus_1] == TOKEN_KEYWORD_SQLSTATE)
         && (QString::compare(text.mid(main_token_offsets[i_plus_2], main_token_lengths[i_plus_2]), "VALUE", Qt::CaseInsensitive) == 0))
        {
          if (main_token_types[i_plus_3] >= TOKEN_KEYWORDS_START) main_token_types[i_plus_3]= TOKEN_TYPE_OTHER;
          i_next= i_plus_4;
        }
        else if (main_token_types[i_plus_1] == TOKEN_KEYWORD_SQLSTATE)
        {
          if (main_token_types[i_plus_2] >= TOKEN_KEYWORDS_START) main_token_types[i_plus_2]= TOKEN_TYPE_OTHER;
          i_next= i_plus_3;
        }
        else if ((main_token_types[i_plus_1] == TOKEN_KEYWORD_NOT)
         && (QString::compare(text.mid(main_token_offsets[i_plus_2], main_token_lengths[i_plus_2]), "FOUND", Qt::CaseInsensitive) == 0))
        {
          i_next= i_plus_3;
        }
        else
        {
          if (main_token_types[i_plus_1] >= TOKEN_KEYWORDS_START) main_token_types[i_plus_1]= TOKEN_TYPE_OTHER;
          i_next= i_plus_2;
        }
        if (QString::compare(text.mid(main_token_offsets[i_next], main_token_lengths[i_next]), ",") == 0)
        {
          i= i_next;
          continue;
        }
        break;
      }
      /* now i_next == first_word_in_statement in DECLARE HANDLER, unless syntax is bad, I hope */
      i= i_next;
    }
    i_prev= i;
  }
}

/* returns next token after i, skipping comments, but do not go past end */
/* todo: maybe it could be merged with next_i() */
int MainWindow::next_token(int i)
{
  int i2;

  for (i2= i;;)
  {
    if (main_token_lengths[i2] == 0) break;
    ++i2;
    if ((main_token_types[i2] == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
    || (main_token_types[i2] == TOKEN_TYPE_COMMENT_WITH_SLASH)
    || (main_token_types[i2] == TOKEN_TYPE_COMMENT_WITH_MINUS))
    {
      continue;
    }
    break;
  }
  return i2;
}

/*
  Called by mouseMoveEvent for hovering in the statement widget.
  Called from deep within hparse_f_multiblock().
  Pass: offset in main_token lists
  Return: information string
*/
QString MainWindow::token_reftype(int i, bool is_hover, int token_type, char reftype_parameter)
{
#define MAX_REFTYPEWORD_LENGTH 64
struct reftypewords {
   char  chars[MAX_REFTYPEWORD_LENGTH];
   unsigned short int reserved_flags;
   unsigned short int built_in_function_flags;
   unsigned short int token_keyword;
};

    /* reftype_values strings must correspond to the order of TOKEN_REFTYPE_ #defines */
    /* Todo: strings shouldn't be blank */
  const reftypewords reftype_values[]=
    {
    {"", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ANY},
    {"alias-of-column ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ALIAS_OF_COLUMN},
    {"alias-of-table ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ALIAS_OF_TABLE},
    {"attribute ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ATTRIBUTE},
    {"auto_increment ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_AUTO_INCREMENT},
    {"channel ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CHANNEL},
    {"character-set ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CHARACTER_SET},
    {"collation ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_COLLATION},
    {"column ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_COLUMN},
    {"column-or-user-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_COLUMN_OR_USER_VARIABLE},
    {"column-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_COLUMN_OR_VARIABLE},
    {"comment ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_COMMENT},
    {"condition-define ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CONDITION_DEFINE},
    {"condition-refer ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CONDITION_REFER},
    {"condition-or-cursor ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CONDITION_OR_CURSOR},
    {"constraint ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CONSTRAINT},
    {"cursor-define ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CURSOR_DEFINE},
    {"cursor-refer ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CURSOR_REFER},
    {"database ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE}, /* or schema */
    {"database-or-constraint ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_CONSTRAINT},
    {"database-or-event ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_EVENT},
    {"database-or-function ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_FUNCTION},
    {"database-or-function-or-procedure ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_FUNCTION_OR_PROCEDURE},
    {"database-or-function-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_FUNCTION_OR_VARIABLE},
    {"database-or-package ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_PACKAGE},
    {"database-or-procedure ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_PROCEDURE},
    {"database-or-sequence ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_SEQUENCE},
    {"database-or-table ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE},
    {"database-or-table-or-row ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW},
    {"database-or-table-or-column ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN},
    {"database-or-table-or-column-or-function ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN_OR_FUNCTION},
    {"database-or-table-or-variable-or-function ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_VARIABLE_OR_FUNCTION},
    {"database-or-table-or-row-or-function-or-column ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW_OR_FUNCTION_OR_COLUMN},
    {"database-or-table-or-row-or-function-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW_OR_FUNCTION_OR_VARIABLE},
    {"database-or-table-or-column-or-function-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN_OR_FUNCTION_OR_VARIABLE},
    {"database-or-table-or-row-or-column-or-function-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW_OR_COLUMN_OR_FUNCTION_OR_VARIABLE},
    {"database-or-trigger ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TRIGGER},
    {"database-or-view ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_VIEW},
    {"directory ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DIRECTORY},
    {"engine ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ENGINE},
    {"event ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_EVENT},
    {"file ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_FILE},
    {"function ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_FUNCTION},
    {"function-or-procedure ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_FUNCTION_OR_PROCEDURE},
    {"function-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_FUNCTION_OR_VARIABLE},
    {"handler-alias ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_HANDLER_ALIAS},
    {"host ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_HOST},
    {"index ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_INDEX},
    {"introducer ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_INTRODUCER},
    {"key_cache ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_KEY_CACHE},
    {"label-define ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_LABEL_DEFINE},
    {"label-refer ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_LABEL_REFER},
    {"length ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_LENGTH},
    {"package ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PACKAGE},
    {"parameter-define ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PARAMETER_DEFINE},
    {"parameter-refer ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PARAMETER_REFER},
    {"parser ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PARSER},
    {"plugin ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PLUGIN},
    {"procedure ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PROCEDURE},
    /* plus {"", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_RESERVED_FUNCTION */
    {"partition ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PARTITION},
    {"partition-number ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PARTITION_NUMBER},
    {"password ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PASSWORD},
    {"role ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ROLE},
    {"row ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ROW},
    {"row-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ROW_OR_VARIABLE},
    {"savepoint ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_SAVEPOINT},
    {"scale ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_SCALE},
    {"sequence ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_SEQUENCE},
    {"server ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_SERVER},
    {"sqlstate ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_SQLSTATE},
    {"statement ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_STATEMENT},
    {"subpartition ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_SUBPARTITION},
    {"switch ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_SWITCH_NAME},
    {"table ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TABLE},
    {"table-or-column ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TABLE_OR_COLUMN},
    {"table-or-column-or-function ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TABLE_OR_COLUMN_OR_FUNCTION},
    {"table-or-column-or-function-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TABLE_OR_COLUMN_OR_FUNCTION_OR_VARIABLE},
    {"table-or-row ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TABLE_OR_ROW},
    {"tablespace ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TABLESPACE},
    {"transaction ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TRANSACTION},
    {"trigger ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TRIGGER},
    {"user ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_USER},
    {"user-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_USER_VARIABLE},
    {"variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_VARIABLE},         /* i.e. either USER_VARIABLE or DECLARED VARIABLE */
    {"variable-define ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_VARIABLE_DEFINE},
    {"variable-refer ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_VARIABLE_REFER},
    {"view ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_VIEW},
    {"with-table ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_WITH_TABLE},
    {"wrapper ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_WRAPPER},
    {"", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_MAX}
  };

  QString s= "";
  int token_flag= main_token_flags[i];

  if (is_hover)
  {
    if ((token_flag & TOKEN_FLAG_IS_ERROR) != 0) s= "(error) ";
    if ((token_flag & TOKEN_FLAG_IS_FUNCTION) != 0) s= "(function) ";
  }
  if ((token_type >= TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE)
   && (token_type <= TOKEN_TYPE_LITERAL))
  {
    int array_subscript= reftype_parameter;
    s.append((char*)reftype_values[array_subscript].chars);
    s.append("literal");
  }
  else if ((token_type >= TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK)
   && (token_type <= TOKEN_TYPE_IDENTIFIER))
  {
    s.append("[");
    int array_subscript= reftype_parameter;
    s.append((char*)reftype_values[array_subscript].chars);
    s.append("identifier]");
  }
  else if ((token_type >= TOKEN_TYPE_COMMENT_WITH_SLASH)
   && (token_type <= TOKEN_TYPE_COMMENT_WITH_MINUS))
  {
    s.append("comment");
  }
  else if (token_type == TOKEN_TYPE_OPERATOR)
  {
    s.append("operator");
  }
  else if (token_type == TOKEN_TYPE_OTHER)
  {
    s.append("[identifier or keyword]");
  }
  else
  {
    if ((token_flag & TOKEN_FLAG_IS_RESERVED) != 0)
    {
      s.append("reserved ");
    }
    s.append("keyword");
  }
  return s;
}

#if (OCELOT_MYSQL_INCLUDE == 1)
/*
  Todo: disconnect old if already connected.
  TODO: LOTS OF ERROR CHECKS NEEDED IN THIS!
   QRegExp is unavailable in Qt 6. Todo: We have never tested the replacemnt QRegularExpression code.
*/
int MainWindow::connect_mysql(unsigned int connection_number)
{
  QString ldbms_return_string;
  ldbms_return_string= "";

  /* Find libmysqlclient. Prefer ld_run_path, within that prefer libmysqlclient.so.18.
    Generally libmysqlclient.so will have a symlink to libmariadb.so
    or to libmariadbclient.so. But not always. Not on Windows.
    And not on some MariaDB releases -- there were some renames and
    some bugs with missing symlinks.
    Also, if ocelot_dbms=mysql, the libmysqlclient searches come first,
    but if ocelot_dbms=mariadb, the libmariadb searches come first.
    So try multiple combinations. e.g. if libmysqlclient.so.18 didn't
    get loaded, try libmysqlclient without a version number.
  */
  for (int i= 1; i < 12; ++i)
  {
    QString li_path;
    int li_lib;
    if (i == 1) {if (connections_dbms[0] == DBMS_MARIADB) continue; li_path= ocelot_ld_run_path; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT18; }
    if (i == 2) {if (connections_dbms[0] == DBMS_MARIADB) continue; li_path= ocelot_ld_run_path; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT; }
    if (i == 3) {                                                   li_path= ocelot_ld_run_path; li_lib= WHICH_LIBRARY_LIBMARIADBCLIENT; }
    if (i == 4) {                                                   li_path= ocelot_ld_run_path; li_lib= WHICH_LIBRARY_LIBMARIADB; }
    if (i == 5) {if (connections_dbms[0] != DBMS_MARIADB) continue; li_path= ocelot_ld_run_path; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT18; }
    if (i == 6) {if (connections_dbms[0] != DBMS_MARIADB) continue; li_path= ocelot_ld_run_path; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT; }
    if (i == 7) {if (connections_dbms[0] == DBMS_MARIADB) continue; li_path= ""                ; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT18; }
    if (i == 8) {if (connections_dbms[0] == DBMS_MARIADB) continue; li_path= ""                ; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT; }
    if (i == 9) {                                                   li_path= ""                ; li_lib= WHICH_LIBRARY_LIBMARIADBCLIENT; }
    if (i == 10){                                                   li_path= ""                ; li_lib= WHICH_LIBRARY_LIBMARIADB; }
    if (i == 11){if (connections_dbms[0] != DBMS_MARIADB) continue; li_path= ""                ; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT18; }
    if (i == 12){if (connections_dbms[0] != DBMS_MARIADB) continue; li_path= ""                ; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT; }
    lmysql->ldbms_get_library(li_path, &is_libmysqlclient_loaded, &libmysqlclient_handle, &ldbms_return_string, li_lib);
    if (is_libmysqlclient_loaded == 1)
    {
      break;
    }
  }


  /* Todo: The following errors would be better if we put them in diagnostics the usual way. */

  if (is_libmysqlclient_loaded == -2)
  {
    /* Todo: QMessageBox should have a parent, use "= new" */
    QMessageBox msgbox;
    char error_message[2048];
    char t_ldbms_return_string[2048];
    strcpy(t_ldbms_return_string, ldbms_return_string.toUtf8());
    sprintf(error_message, er_strings[er_off + ER_LIBMYSQLCLIENT_DOES_NOT_HAVE], t_ldbms_return_string);
    msgbox.setText(error_message);
    msgbox.exec();
    //delete lmysql;
    return 1;
  }

  if (is_libmysqlclient_loaded == 0)
  {
    /* Todo: QMessageBox should have a parent, use "= new" */
    QMessageBox msgbox;
    char error_message[2048];
    char t_ldbms_return_string[2048];
    strcpy(t_ldbms_return_string, ldbms_return_string.toUtf8());
    sprintf(error_message, er_strings[er_off + ER_LIBMYSQLCLIENT_WAS_NOT_FOUND], t_ldbms_return_string);
    msgbox.setText(error_message);
    msgbox.exec();
    //delete lmysql;
    return 1;
  }

  if (is_mysql_library_init_done == false)
  {
    if (lmysql->ldbms_mysql_library_init(0, NULL, NULL))
    {
      /* Todo: QMessageBox should have a parent, use "= new" */
      QMessageBox msgbox;
      msgbox.setText(er_strings[er_off + ER_MYSQL_LIBRARY_INIT_FAILED]);
      msgbox.exec();
      return 1;
    }
    is_mysql_library_init_done= true;
  }
  /* Mysterious crash may happen with one particular MariaDB version. */
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
  {
    QString s;
    s= lmysql->ldbms_mysql_get_client_info();
    if (s.contains("10.1.7", Qt::CaseInsensitive) == true)
    {
      QMessageBox msgbox;
      msgbox.setText("Warning: Detected MariaDB 10.1.7 client library. This version has been known to cause problems.");
      msgbox.exec();
    }
  }
#endif
  /* I decided this line is unnecessary, mysql_init is done in options_and_connect() */
  //lmysql->ldbms_mysql_init(&mysql[connection_number]);
  if (the_connect(connection_number))
  {
    put_diagnostics_in_result(connection_number);
    make_and_append_message_in_result(ER_FAILED_TO_CONNECT, 0, (char*)"");
    return 1;
  }
  make_and_put_message_in_result(ER_OK, 0, (char*)"");

  /*
    Initially ocelot_prompt == "mysql>" and ocelot_prompt_is_default == true.
    It might have changed if getenv("MYSQL_PS1") returned something.
    It might have changed if --prompt = prompt-format was specified.
    We can override it with "mariadb>" if the client library comes from MariaDB.
    That is, we depend on mysql_get_client_info() not mysql_get_host_info().
    That is, we say "mariadb>" although mariadb's client would probably say "\N [\d]>".
    For example mysql_get_client_info() might return "10.0.4-MariaDB".
    We'll set ocelot_prompt_is_default= false to ensure this only happens once.
    We are hoping that following statements don't override earlier PROMPT statements by user.
    TODO: This had to be abandoned because it didn't work properly with Qt4.
          Since I didn't know what the true problem was, or exactly which versions
          will work, I cancelled it. The todo is: revive it.
  */
  //{
  //  if (ocelot_prompt_is_default == true)
  //  {
  //    QString s;
  //    s= lmysql->ldbms_mysql_get_client_info();
  //    if (s.contains("MariaDB", Qt::CaseInsensitive) == true)
  //    {
  //      ocelot_prompt= "mariadb>";
  //    }
  //    ocelot_prompt_is_default= false;
  //  }
  //}

  statement_edit_widget->prompt_default= ocelot_prompt;
  statement_edit_widget->prompt_as_input_by_user= statement_edit_widget->prompt_default;

  /*
    Collect some variables in case they're needed for "prompt".
    Todo: handle errors better after mysql_ calls here.
    A possible error is: Error 1226 (42000) User ... has exceeded the 'max_queries_per_hour' resource
    A possible error is: Error 1820 (HY000) You must reset your password using ALTER USER statement before executing this statement.
    Not using the mysql_res global, since this is not for user to see.
  */
  int query_result= lmysql->ldbms_mysql_query(&mysql[connection_number], "select version(), database(), @@port, current_user(), connection_id()");
  if (query_result != 0 )
  {
    connect_mysql_error_box(er_strings[er_off + ER_MYSQL_QUERY_FAILED], connection_number);
    connect_init(connection_number);
    return 0;
  }
  MYSQL_RES *mysql_res_for_connect;
  MYSQL_ROW connect_row;
  QString s;
  int i;

  // unsigned long connect_lengths[1];
  mysql_res_for_connect= lmysql->ldbms_mysql_store_result(&mysql[connection_number]);
  if (mysql_res_for_connect == NULL)
  {
    connect_mysql_error_box(er_strings[er_off + ER_MYSQL_STORE_RESULT_FAILED], connection_number);
    connect_init(connection_number);
    return 0;
  }
  connect_row= lmysql->ldbms_mysql_fetch_row(mysql_res_for_connect);
  if (connect_row == NULL)
  {
    connect_mysql_error_box(er_strings[er_off + ER_MYSQL_FETCH_ROW_FAILED], connection_number);
    connect_init(connection_number);
    return 0;
  }
  /* lengths= lmysql->ldbms_mysql_fetch_lengths(mysql_res_for_connect); */
  statement_edit_widget->dbms_version= connect_row[0];
  statement_edit_widget->dbms_database= connect_row[1];
  statement_edit_widget->dbms_port= connect_row[2];
  s= connect_row[3];
  statement_edit_widget->dbms_current_user= s;
#if (QT_VERSION >= 0x60000)
  i= s.indexOf(QRegularExpression("@"), 0);
#else
  i= s.indexOf(QRegExp("@"), 0);
#endif
  if (i > 0) s= s.left(i);
  else s= "";
  statement_edit_widget->dbms_current_user_without_host= s;
  statement_edit_widget->dbms_connection_id= atoi(connect_row[4]);
  /* Todo: find out why this returns capitalized e.g. "Localhost" rather than "localhost" */
  s= lmysql->ldbms_mysql_get_host_info(&mysql[connection_number]);
#if (QT_VERSION >= 0x60000)
  i= s.indexOf(QRegularExpression(" "), 0);
#else
  i= s.indexOf(QRegExp(" "), 0);
#endif
  if (i > 0) s= s.left(i);
  statement_edit_widget->dbms_host= s;
  lmysql->ldbms_mysql_free_result(mysql_res_for_connect);
  get_sql_mode(TOKEN_KEYWORD_CONNECT, "", false, main_token_number);
  connect_init(connection_number);
  set_dbms_version_mask(statement_edit_widget->dbms_version, connection_number);
#if (OCELOT_EXPLORER == 1)
  if (connection_number == 0) initialize_widget_explorer_after_connect();
#endif
  return 0;
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

#if (OCELOT_MYSQL_INCLUDE == 1)
void MainWindow::connect_mysql_error_box(QString s1, unsigned int connection_number)
{
  QString s2;
  char i_mysql_error_and_state[1024];
  int i_mysql_errno_result= lmysql->ldbms_mysql_errno(&mysql[connection_number]);
  s1.append(tr(" Warning: Connection succeeded, but server refused to provide some non-essential information due to Error "));
  sprintf(i_mysql_error_and_state, "%d (%s) ", i_mysql_errno_result, lmysql->ldbms_mysql_sqlstate(&mysql[connection_number]));
  s1.append(i_mysql_error_and_state);
  s2= lmysql->ldbms_mysql_error(&mysql[connection_number]);
  s1.append(s2);
  /* Todo: QMessageBox should have a parent, use "= new" */
  QMessageBox msgbox;
  msgbox.setText(s1);
  msgbox.exec();
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

/*
 We call set_dbms_version_mask(ocelot_dbms) from MainWindow() after
 calling mysql_options_2(),in which case the pass should be the original
 default ("mysql") or something the user specified with --ocelot_dbms
 (probably "mysql" or "mariadb" but could contain version
 before or after and we don't check validity).
 We call set_dbms_version_mask(statement_edit_widget->dbms_version)
 from connect_mysql() after connection succeeds, in which case the
 pass would be what "select version()" returns, such as 10.2.0-MariaDB,
 or 8.0.11 (MySQL might not say 'mysql'). Assume Percona is like MySQL.
 Or we call from connect_tarantool() after connection succeeds.
 If there's a disconnect later, we don't reset to original flag values.
 If you must know the vendor, then maybe select @@version_comment
 is good, but I don't know if @@version_comment was in old versions.
 Warn: get_sql_mode() might change dbms_version_mask.
 If we don't see a known version number, we tend to assume it's a later version.
 Todo: a message like "Don't recognize MySQL/MariaDB version" would be nice.
 Todo: if command line had a version number, don't let version() override it.
 Warning: this may override setting of dbms_connections[0] done in connect_set_variable()
*/
void MainWindow::set_dbms_version_mask(QString version, int connection_number)
{
  if (version.contains("mariadb", Qt::CaseInsensitive) == true)
  {
    if (version.contains("10.0.") == true)
    {
      dbms_version_mask= (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_0);
    }
    else if (version.contains("10.1.") == true)
    {
      dbms_version_mask= (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_0 | FLAG_VERSION_MARIADB_10_1);
    }
    else if (version.contains("10.2.") == true)
    {
      QString s= version.mid(version.indexOf("10.2.") + 5, 1);
      if (s >= "3")
        dbms_version_mask= (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_0 | FLAG_VERSION_MARIADB_10_1 | FLAG_VERSION_MARIADB_10_2_2 | FLAG_VERSION_MARIADB_10_2_3);
      else
        dbms_version_mask= (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_0 | FLAG_VERSION_MARIADB_10_1 | FLAG_VERSION_MARIADB_10_2_2);
    }
    else if (version.contains("10.3.") == true)
      dbms_version_mask= (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_0 | FLAG_VERSION_MARIADB_10_1 | FLAG_VERSION_MARIADB_10_2_2 | FLAG_VERSION_MARIADB_10_2_3 | FLAG_VERSION_MARIADB_10_3);
    else
    {
      /* 10.4 + 10.5 + 10.6 + 10.7 + 10.8 + 10.9 + 10.10 + 10.11 all get ... | FLAG_VERSION_MARIADB_10_10 */
      dbms_version_mask= FLAG_VERSION_MARIADB_ALL;
    }
  }
#ifdef DBMS_TARANTOOL
  else if (version.contains("tarantool", Qt::CaseInsensitive) == true)
  {
    {
      if (version.contains("2.2.") == true)
      {
        dbms_version_mask= (FLAG_VERSION_TARANTOOL | FLAG_VERSION_TARANTOOL_2_2);
      }
      else if (version.contains("2.3.") == true)
      {
        dbms_version_mask= (FLAG_VERSION_TARANTOOL | FLAG_VERSION_TARANTOOL_2_2 | FLAG_VERSION_TARANTOOL_2_3);
      }
      else if (version.contains("2.4.") == true)
      {
        dbms_version_mask= (FLAG_VERSION_TARANTOOL | FLAG_VERSION_TARANTOOL_2_2 | FLAG_VERSION_TARANTOOL_2_3 | FLAG_VERSION_TARANTOOL_2_4);
      }
      else if (version.contains("2.7.") == true)
      {
        dbms_version_mask= (FLAG_VERSION_TARANTOOL | FLAG_VERSION_TARANTOOL_2_2 | FLAG_VERSION_TARANTOOL_2_3 | FLAG_VERSION_TARANTOOL_2_4 | FLAG_VERSION_TARANTOOL_2_7);
      }
      else
      {
        dbms_version_mask= FLAG_VERSION_TARANTOOL_ALL;
      }
    }
  }
#endif
  /* MySQL's version string might not contain 'mysql */
  else /* if (version.contains("mysql", Qt::CaseInsensitive) == true) */
  {
    if (version.contains("5.6") == true) /* including 5.5.6 since we don't differentiate 5.5 and 5.6 now */
    {
      dbms_version_mask= (FLAG_VERSION_MYSQL_5_5 | FLAG_VERSION_MYSQL_5_6);
    }
    else if ((version.contains("5.7") == true)
          && (version.contains("5.5.7") == false))
    {
      dbms_version_mask= (FLAG_VERSION_MYSQL_5_5 | FLAG_VERSION_MYSQL_5_6 | FLAG_VERSION_MYSQL_5_7);
    }
    else if (version.contains("8.0") == true)
    {
      dbms_version_mask= (FLAG_VERSION_MYSQL_5_5 | FLAG_VERSION_MYSQL_5_6 | FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MYSQL_8_0);
      if (version.contains("8.0.31") == true) dbms_version_mask= (dbms_version_mask | FLAG_VERSION_MYSQL_8_0_31);
    }
    else if (version.contains("mysql", Qt::CaseInsensitive) == true)
    {
      dbms_version_mask= FLAG_VERSION_MYSQL_ALL;
    }
    else dbms_version_mask= FLAG_VERSION_DEFAULT;
  }
  if (((dbms_version_mask&FLAG_VERSION_MYSQL_ALL) != 0)
   && ((dbms_version_mask&FLAG_VERSION_MARIADB_ALL) == 0))
  {
    connections_dbms[connection_number]= DBMS_MYSQL;
  }
  if (((dbms_version_mask&FLAG_VERSION_MARIADB_ALL) != 0)
   && ((dbms_version_mask&FLAG_VERSION_MYSQL_ALL) == 0))
  {
    connections_dbms[connection_number]= DBMS_MARIADB;
  }
}

/*
  Pass: i_start = where we are now, i_increment = +1 or -1
  Go forward | backward skipping comments
  Stop if end or start of all input (we pay no attention to statement
  start|end).
  Todo: this could be useful in other places where we currently
        are making temporary copies that don't contain comments.
  Warning: do not put next_i in a loop without checking that it is at end.
*/
int MainWindow::next_i(int i_start, int i_increment)
{
  int i= i_start;
  for (;;)
  {
    if ((i == 0) && (i_increment <= 0)) break;
    if ((main_token_lengths[i] == 0) && (i_increment >= 0)) break;
    i= i + i_increment;
    if ((main_token_types[i] != TOKEN_TYPE_COMMENT_WITH_SLASH)
      && (main_token_types[i] != TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
      && (main_token_types[i] != TOKEN_TYPE_COMMENT_WITH_MINUS))
     break;
  }
  return i;
}

/* Variant of next_i() where we pass token_lengths + types rather than assume main_token_lengths + types */
int MainWindow::next_i_v(int i_start, int i_increment, int token_types[], int token_lengths[])
{
  int i= i_start;
  for (;;)
  {
    if ((i == 0) && (i_increment <= 0)) break;
    if ((token_lengths[i] == 0) && (i_increment >= 0)) break;
    i= i + i_increment;
    if ((token_types[i] != TOKEN_TYPE_COMMENT_WITH_SLASH)
      && (token_types[i] != TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
      && (token_types[i] != TOKEN_TYPE_COMMENT_WITH_MINUS))
     break;
  }
  return i;
}


#if (OCELOT_MYSQL_INCLUDE == 1)
/*
  We use sql_mode to decide whether "..." is an identifier or a literal.
  So we try to get its value at connect time or if user says
  SET SESSION SQL_MODE ... or SET @@session.sql_mode
  This might fail if (ocelot_statement_syntax_checker.toInt() < 1
  but I'm not expecting people will set that and then expect recognizing.
  Todo: Handle the undocumented syntax SET @@sql_mode=ANSI.
        If MariaDB, we'd have to ensure that we're not in a block
        that has DECLARE ANSI. But it's clearly used by some people.
  Todo: track global value too so we can handle sql_mode=default.
  Todo: try to do this while parsing, before you can ask the server.
  Todo: check: did the server return a warning for this statement?
  Warning: We might call this from within hparse_f_multi_block().
  Warning: if we aren't connected yet, then dbms_version_mask is default e.g. MySQL-8.0 flag is on.
*/
bool MainWindow::get_sql_mode(int who_is_calling,
                              QString text,
                              bool is_in_hparse,
                              int start_token_number)
{
  QString sql_mode_string;
  bool sql_mode_string_seen= false;
  bool must_ask_server= false;
  QString token;
  bool default_is_session= true;
  bool immediate_is_session= true;
  QString var_name;
  bool old_hparse_sql_mode_ansi_quotes= hparse_sql_mode_ansi_quotes;
  if (who_is_calling == TOKEN_KEYWORD_SET)
  {
    int i;
    int t;
    for (i= start_token_number; main_token_lengths[i] != 0; ++i)
    {
      {
        QString token3= text.mid(main_token_offsets[i], main_token_lengths[i]);
        if ((token3 == ";")
         || (token3 == ocelot_delimiter_str)) break;
      }
      t= main_token_types[i];
      if ((t == TOKEN_KEYWORD_SESSION)
      || (t == TOKEN_KEYWORD_LOCAL))
      {
        default_is_session= true;
        continue;
      }
      if ((t == TOKEN_KEYWORD_GLOBAL)
        || (t == TOKEN_KEYWORD_PERSIST)
        || (t == TOKEN_KEYWORD_PERSIST_ONLY))
      {
        default_is_session= false;
        continue;
      }
      var_name= text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper();
      if ((connect_stripper(var_name, false) == "SQL_MODE")
       || (var_name == "@@SQL_MODE"))
      {
        int i_minus_1= next_i(i, -1);
        int i_minus_2= next_i(i_minus_1, -1);
        int i_plus_1= next_i(i, +1);
        int i_plus_2= next_i(i_plus_1, +1);
        int i_plus_3= next_i(i_plus_2, +1);
        if (var_name == "@@SQL_MODE") immediate_is_session= true;
        else
        {
          immediate_is_session= default_is_session;
          token= text.mid(main_token_offsets[i_minus_1], main_token_lengths[i_minus_1]);
          if (token == ".")
          {
            token= text.mid(main_token_offsets[i_minus_2], main_token_lengths[i_minus_2]).toUpper();
            if ((token == "@@SESSION")
             || (token == "@@LOCAL"))
            {
              immediate_is_session= true;
            }
            if ((token == "@@GLOBAL")
             || (token == "@@PERSIST")
             || (token == "@@PERSIST_ONLY"))
            {
              immediate_is_session= false;
            }
          }
          if (immediate_is_session == false) continue;
        }
        token= text.mid(main_token_offsets[i_plus_1], main_token_lengths[i_plus_1]);
        if ((token == "=") || (token == ":="))
        {
          bool is_simple_literal= false;
          /* is_simple_literal=true if e.g. set sql_mode='ansi' */
          t= main_token_types[i_plus_2];
          if ((t == TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE)
           || (t == TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE)
           || (t == TOKEN_TYPE_LITERAL))
          {
            is_simple_literal= true;
          }
          /* is_simple_literal=true if e.g. set sql_mode=ansi */
          if (is_simple_literal == false)
          {
            if ((t == TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK)
             || (t == TOKEN_TYPE_IDENTIFIER_WITH_DOUBLE_QUOTE)
             || (t == TOKEN_TYPE_IDENTIFIER)
             || (t >= TOKEN_TYPE_OTHER))
            {
               QString token4= text.mid(main_token_offsets[i_plus_2], main_token_lengths[i_plus_2]);
               if ((token4.left(1) != "@")
                && (main_token_reftypes[i_plus_2] != TOKEN_REFTYPE_VARIABLE_REFER))
                 is_simple_literal= true;
            }
          }
          /* is_simple_literal=false if not simple e.g. 'ansi,ansi' */
          if (is_simple_literal == true)
          {
            QString token3= text.mid(main_token_offsets[i_plus_3], main_token_lengths[i_plus_3]);
            if ((token3 != ",")
             && (token3 != ";")
             && (token3 != ocelot_delimiter_str))
            {
              is_simple_literal= false;
            }
          }
          if (is_simple_literal == false)
          {
            /* User has said SET SESSION sql_mode = not-literal which server can interpret */
            sql_mode_string_seen= false;
            must_ask_server= true;
          }
          else
          {
            /* User has said SET SESSION sql_mode = literal which we can interpret as client */
            sql_mode_string= text.mid(main_token_offsets[i_plus_2], main_token_lengths[i_plus_2]);
            sql_mode_string_seen= true;
            must_ask_server= false;
          }
        }
      }
    }
  }
  if ((who_is_calling == TOKEN_KEYWORD_CONNECT)
   || (must_ask_server == true))
  {
    if (is_in_hparse) return false;
    QString s= select_1_row("select @@session.sql_mode");
    if (s == "")
    {
      sql_mode_string= select_1_row_result_1;
      sql_mode_string_seen= true;
    }
  }
  if (sql_mode_string_seen == true)
  {
    bool is_ok_combo= false;
    if (sql_mode_string.contains("ANSI", Qt::CaseInsensitive) == true)
      is_ok_combo= true;
    if ((dbms_version_mask & FLAG_VERSION_MYSQL_8_0) == 0)
    {
      if ((sql_mode_string.contains("DB2", Qt::CaseInsensitive) == true)
       || (sql_mode_string.contains("MAXDB", Qt::CaseInsensitive) == true)
       || (sql_mode_string.contains("MSSQL", Qt::CaseInsensitive) == true)
       || (sql_mode_string.contains("ORACLE", Qt::CaseInsensitive) == true)
       || (sql_mode_string.contains("POSTGRESQL", Qt::CaseInsensitive) == true))
        is_ok_combo= true;
    }
    if (is_ok_combo)
    {
      if (is_in_hparse == false) sql_mode_ansi_quotes= true;
      hparse_sql_mode_ansi_quotes= true;
    }
    else
    {
      if (is_in_hparse)
      {
        /*
           We'll decide it's false if it contains some valid setting.
           We'll decide it's unknown (and return unchanged) otherwise.
           Obviously this is unreliable, but what else can I do?
        */
        sql_mode_string= sql_mode_string.toUpper();
        bool is_ok= false;
        if ((connect_stripper(sql_mode_string, false) == "")
           || (sql_mode_string.contains("ALLOW_INVALID_DATES"))
           || (sql_mode_string.contains("ERROR_FOR_DIVISION_BY_ZERO"))
           || (sql_mode_string.contains("HIGH_NOT_PRECEDENCE"))
           || (sql_mode_string.contains("IGNORE_SPACE"))
           || (sql_mode_string.contains("NO_AUTO_VALUE_ON_ZERO"))
           || (sql_mode_string.contains("NO_BACKSLASH_ESCAPES"))
           || (sql_mode_string.contains("NO_DIR_IN_CREATE"))
           || (sql_mode_string.contains("NO_ENGINE_SUBSTITUTION"))
           || (sql_mode_string.contains("NO_UNSIGNED_SUBTRACTION"))
           || (sql_mode_string.contains("NO_ZERO_DATE"))
           || (sql_mode_string.contains("NO_ZERO_IN_DATE"))
           || (sql_mode_string.contains("ONLY_FULL_GROUP_BY"))
           || (sql_mode_string.contains("PAD_CHAR_TO_FULL_LENGTH"))
           || (sql_mode_string.contains("PIPES_AS_CONCAT"))
           || (sql_mode_string.contains("REAL_AS_FLOAT"))
           || (sql_mode_string.contains("STRICT_ALL_TABLES"))
           || (sql_mode_string.contains("STRICT_TRANS_TABLES"))
           || (sql_mode_string.contains("TRADITIONAL")))
          is_ok= true;
        if ((dbms_version_mask & FLAG_VERSION_MYSQL_8_0) == 0)
        {
          if ((sql_mode_string.contains("MYSQL323"))
           || (sql_mode_string.contains("MYSQL40"))
           || (sql_mode_string.contains("NO_AUTO_CREATE_USER"))
           || (sql_mode_string.contains("NO_FIELD_OPTIONS"))
           || (sql_mode_string.contains("NO_KEY_OPTIONS"))
           || (sql_mode_string.contains("NO_TABLE_OPTIONS")))
            is_ok= true;
        }
        if ((dbms_version_mask & FLAG_VERSION_MARIADB_10_3) != 0)
        {
          if ((sql_mode_string.contains("EMPTY_STRING_IS_NULL"))
           || (sql_mode_string.contains("IGNORE_BAD_TABLE_OPTIONS"))
           || (sql_mode_string.contains("SIMULTANEOUS_ASSIGNMENT")))
            is_ok= true;
        }
        if ((dbms_version_mask & FLAG_VERSION_MYSQL_8_0) != 0)
        {
          if (sql_mode_string.contains("TIME_TRUNCATE_FRACTIONAL"))
            is_ok= true;
        }
        if (is_ok == false) return false; /* SET will fail so this has no effect */
      }
      if (is_in_hparse == false)  sql_mode_ansi_quotes= false;
      hparse_sql_mode_ansi_quotes= false;
    }
    if ((sql_mode_string.contains("ORACLE", Qt::CaseInsensitive) == true)
     && ((hparse_dbms_mask & FLAG_VERSION_MARIADB_10_3) != 0))
    {
      if (is_in_hparse == false) dbms_version_mask |= FLAG_VERSION_PLSQL;
      hparse_dbms_mask |= FLAG_VERSION_PLSQL;
    }
    else
    {
      if (is_in_hparse == false) dbms_version_mask &= (~FLAG_VERSION_PLSQL);
      hparse_dbms_mask &= (~FLAG_VERSION_PLSQL);
    }
  }
  if (hparse_sql_mode_ansi_quotes == old_hparse_sql_mode_ansi_quotes) return false;
  else return true;
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

/* 20160915: moved hparse_* and tparse_* routines to a new file. */
#include "hparse.h"

#ifdef DBMS_TARANTOOL

/*
  Connect to tarantool server due to --ocelot_dbms='tarantool'
  or "create server id options (port=x);".
  Todo: disconnect old if already connected.
  TODO: LOTS OF ERROR CHECKS NEEDED IN THIS!
  Usually libtarantool.so and libtarantoolnet.so are in /usr/local/lib or LD_LIBRARY_PATH.
  todo: We no longer use libtarantoolnet.so, remove reference to it.
  After connecting:
    -- get session.id and version
    -- todo: if version is old we shouldn't try to use SQL
  ansi_quotes:
    With Tarantool/SQL "x" is a delimited identifier not a string
    literal. So we set hparse_sql_mode_ansi_quotes= true.
    If we mix Tarantool/SQL and MySQL/MariaDB, this is still required.
    So we guess that users are sane. I hope this becomes policy someday.
    With Tarantool/NoSQL "x" is always a string literal.
*/
int MainWindow::connect_tarantool(unsigned int connection_number,
                                  QString port_maybe,
                                  QString host_maybe,
                                  QString password_maybe,
                                  QString user_maybe)
{
  //(void) connection_number; /* suppress "unused parameter" warning */
  QString ldbms_return_string;
  ldbms_return_string= "";

  /* Mainly we want to be sure tarantool_tnt_reply.data == 0 if failure */
  /* tnt_reply_init() also does memset but it might not be available yet */
  memset(&tarantool_tnt_reply, 0, sizeof(struct tnt_reply));

  /* Find libtarantool. Prefer ld_run_path. */
  if (is_libtarantool_loaded != 1)
  {
    lmysql->ldbms_get_library(ocelot_ld_run_path, &is_libtarantool_loaded, &libtarantool_handle, &ldbms_return_string, WHICH_LIBRARY_LIBTARANTOOL);
  }
  if (is_libtarantool_loaded != 1)
  {
    lmysql->ldbms_get_library("", &is_libtarantool_loaded, &libtarantool_handle, &ldbms_return_string, WHICH_LIBRARY_LIBTARANTOOL);
  }
  /* Find libtarantoolnet. Prefer ld_run_path. */
  /* Now libtarantool.so has everything so this is removed. */
  //if (is_libtarantoolnet_loaded != 1)
  //{
  //  lmysql->ldbms_get_library(ocelot_ld_run_path, &is_libtarantoolnet_loaded, &libtarantoolnet_handle, &ldbms_return_string, WHICH_LIBRARY_LIBTARANTOOLNET);
  //}
  //if (is_libtarantoolnet_loaded != 1)
  //{
  //  lmysql->ldbms_get_library("", &is_libtarantoolnet_loaded, &libtarantoolnet_handle, &ldbms_return_string, WHICH_LIBRARY_LIBTARANTOOLNET);
  //}

  /* Todo: The following errors would be better if we put them in diagnostics the usual way. */

  if (is_libtarantool_loaded == -2)
  {
    /* Todo: QMessageBox should have a parent, use "= new" */
    QMessageBox msgbox;
    QString error_message;
    error_message= "Severe error: libtarantool does not have these names: ";
    error_message.append(ldbms_return_string);
    error_message.append(". Close ocelotgui, restart with a better libtarantool.so.");
    msgbox.setText(error_message);
    msgbox.exec();
    delete lmysql;
    return 1;
  }
  if (is_libtarantool_loaded == 0)
  {
    /* Todo: QMessageBox should have a parent, use "= new" */
    QMessageBox msgbox;
    QString error_message;
    error_message= "Error, libtarantool was not found or a loading error occurred. Message was: ";
    error_message.append(ldbms_return_string);
    msgbox.setText(error_message);
    msgbox.exec();
    delete lmysql;
    return 1;
  }
  /* Todo: this should have been done already; we must be calling from the wrong place. */
  copy_connect_strings_to_utf8();

  /* CONNECT. URI = port, host:port, or username:password@host:port */

  /* tnt[] is static global */
  tnt[connection_number]= lmysql->ldbms_tnt_net(NULL);
  if (ocelot_opt_connect_timeout > 0)
  {
    struct timeval tvp;
    tvp.tv_sec= ocelot_opt_connect_timeout;
    tvp.tv_usec= 0;
    lmysql->ldbms_tnt_set(tnt[connection_number], (int)TNT_OPT_TMOUT_CONNECT, (char*)&tvp);
  }
  {
    /* Todo:
       I was setting TNT_OPT_SEND_BUF and TNT_OPT_RECV_BUF to (char*)ocelot_net_buffer_length in
       ocelotgui.h. I said third arg is char*, so casting was goofy. The greater problem was that
       the default on startup is 16384 which is MySQL's default, not Tarantool's. The true solution
       is to change the default if --ocelot_dbms=tarantool, perhaps. But 0 turns buffering off, and
       I think that is convenient for sending or receiving images.
       Warning: ocelot_net_buffer_length is long.
    */
    lmysql->ldbms_tnt_set(tnt[connection_number], TNT_OPT_SEND_BUF, 0);
    lmysql->ldbms_tnt_set(tnt[connection_number], TNT_OPT_RECV_BUF, 0);
  }
  sql_mode_ansi_quotes= true;        /* see comment = ansi_quotes */
  hparse_sql_mode_ansi_quotes= true; /* probably not necessary */
  {
    char connection_string[1024];
    char connection_port[128];
    char connection_host[128];
    char connection_password[128];
    char connection_user[128];
    if (port_maybe != "DEFAULT") strcpy(connection_port, port_maybe.toUtf8());
    else sprintf(connection_port, "%d", ocelot_port);
    if (host_maybe != "DEFAULT") strcpy(connection_host, host_maybe.toUtf8());
    else strcpy(connection_host,ocelot_host_as_utf8);
    if (password_maybe != "DEFAULT") strcpy(connection_password, password_maybe.toUtf8());
    else strcpy(connection_password,ocelot_password_as_utf8);
    if (user_maybe != "DEFAULT") strcpy(connection_user, user_maybe.toUtf8());
    else strcpy(connection_user, ocelot_user_as_utf8);
    strcpy(connection_string, "");
    /* guest has no password
       after connect() succeeds user = guest,
       after authenticate() succeeds user = arg
    */
    if (strcmp(connection_user, "guest") != 0)
    {
      strcat(connection_string, connection_user);
      if (strcmp(connection_password, "") != 0)
      {
        strcat(connection_string, ":");
        strcat(connection_string, connection_password);
      }
      strcat(connection_string, "@");
    }
    strcat(connection_string, connection_host);
    strcat(connection_string, ":");
    strcat(connection_string, connection_port);
    lmysql->ldbms_tnt_set(tnt[connection_number], (int)TNT_OPT_URI, connection_string);
    if (lmysql->ldbms_tnt_connect(tnt[connection_number]) < 0) {
      tarantool_errno[connection_number]= 9999;
      strcpy(tarantool_errmsg, "Connection refused for ");
      strcat(tarantool_errmsg, connection_string);
      enum tnt_error j= lmysql->ldbms_tnt_error(tnt[connection_number]);
      if ((j >= 0) && (j < TNT_LAST))
      {
        strcat(tarantool_errmsg, " ");
        strcat(tarantool_errmsg, lmysql->ldbms_tnt_strerror(tnt[connection_number]));
      }
    }
    else
    {
      tarantool_errno[connection_number]= 0;
      strcpy(tarantool_errmsg, er_strings[er_off + ER_OK]);
    }
  }
  if (tarantool_errno[connection_number] != 0)
  {
    /* Kludge so put_diagnostics_in_result won't crash */
    connections_dbms[connection_number]= DBMS_TARANTOOL;
    put_diagnostics_in_result(connection_number);
    if (connection_number == MYSQL_MAIN_CONNECTION)
    {
      make_and_append_message_in_result(ER_FAILED_TO_CONNECT_TO_TARANTOOL, 0, (char*)"");
    }
    else
    {
      make_and_append_message_in_result(ER_FAILED_TO_CONNECT_TO_TARANTOOL_FOR_SERVER, 0, (char*)"");
    }
    return 1;
  }
  make_and_put_message_in_result(ER_OK, 0, (char*)"");
  connect_init(connection_number);
  /* Todo: Consider saying select version(); instead of an internal query for box.info.version. */
  /* Todo: I gave up on memtx_use_mvcc_engine. Revive when I see how to make remote transactions work. */
  QString session_id, version;
  {
    char query_string[1024];
    sprintf(query_string, "return box.session.id()");
    session_id= tarantool_internal_query(query_string, connection_number);
    sprintf(query_string, "return box.info.version");
    version= tarantool_internal_query(query_string, connection_number);
    int index_of_hyphen= version.indexOf("-");
    if (index_of_hyphen > 0) version= version.left(index_of_hyphen);
    //tarantool_memtx_use_mvcc_engine= 0;
    //if (version >= "2.6")
    //{
    //  sprintf(query_string, "return box.cfg.memtx_use_mvcc_engine and 1 or 0");
    //  tarantool_memtx_use_mvcc_engine= tarantool_internal_query(query_string, connection_number).toInt();
    //}
  }
  /* Old Tarantool (before 2.1.2?) need box.sql.execute not box.execute */
  /* If box.execute() fails and box.sql.execute() fails, SQL is impossible. */
  if (connection_number == 0)
  {
    tarantool_execute_sql("select 5;", strlen("select 5;"), connection_number);
    if (tarantool_errno[0] != 0)
    {
      strcpy(tarantool_box_execute, "No SQL");
      /* Todo: how to clear the error? */
    }
  }

  if (connection_number == MYSQL_REMOTE_CONNECTION)
  {
    /* The caller should save the connection for the server id. */
    return 0;
  }

  /*
    Todo: This overrides any earlier PROMPT statements by user.
    Probably what we want is a flag: "if user did PROMPT, don't override it."
    Or we want PROMPT statement to change ocelot_prompt.
  */
  statement_edit_widget->prompt_default= ocelot_prompt;
  statement_edit_widget->prompt_as_input_by_user= statement_edit_widget->prompt_default;
  statement_edit_widget->dbms_version= version;
  statement_edit_widget->dbms_database= ocelot_database;
  statement_edit_widget->dbms_port= QString::number(ocelot_port);
  statement_edit_widget->dbms_current_user= ocelot_user;
  statement_edit_widget->dbms_current_user_without_host= ocelot_user;
  statement_edit_widget->dbms_connection_id= session_id.toInt();
  statement_edit_widget->dbms_host= ocelot_host;
  //connect_init(connection_number);
  tarantool_initialize(connection_number);
  if (connection_number == 0)
  {
    set_dbms_version_mask("tarantool-" + version, connection_number);
#if (OCELOT_EXPLORER == 1)
    initialize_widget_explorer_after_connect();
#endif
  }
  return 0;
}
#endif

#ifdef DBMS_TARANTOOL
/*
  For some internal (not user-generated) requests
  returns tarantool_errno[connection_number]
  returns tarantool_errmsg[connection_number]
  if first word is "return" and no error, return a scalar
  the scalar must be MP_STR or MP_UINT or MP_INT, otherwise return = ""
  The preferred way is with tnt_eval but it will fail if user lacks privilege.
  The second-choice way is with tnt_execute but it might fail in a future Tarantool version.

*/
QString MainWindow::tarantool_internal_query(char *query,
                                            int connection_number)
{
  QString returned_string;
  struct tnt_stream *empty;
  empty= lmysql->ldbms_tnt_object(NULL);
  lmysql->ldbms_tnt_object_add_array(empty, 0);
  lmysql->ldbms_tnt_eval(tnt[connection_number], query, strlen(query), empty);
  tarantool_flush_and_save_reply(connection_number);
  if (tarantool_errno[connection_number] != 0)
  {
    empty= lmysql->ldbms_tnt_object(NULL);
    QString co= query;
    if (co.contains("''")) co= co.replace("'", "''");
    co= "select lua('" + co;
    if (strncmp(query, "return ", 7) != 0) co= co + " return 0";
    co= co + "');";
    QByteArray ba= co.toUtf8();
    char *tmp= ba.data();
    lmysql->ldbms_tnt_object_add_array(empty, 0);
    lmysql->ldbms_tnt_execute(tnt[connection_number], tmp, strlen(tmp), empty);
    tarantool_flush_and_save_reply(connection_number);
  }

  if ((tarantool_errno[connection_number] == 0)
   && (strncmp(query, "return ", 7) == 0))
  {
    uint32_t value_length;
    const char *value;
    char value_as_string[320]; /* must be big enough for any sprintf() result */
    char field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_p);
    /* if field_type != MP_ARRAY that's an error but we just return "" */
    if (field_type == MP_ARRAY)
    {
      /* The first item will be dd 00 00 01 i.e. "array of length = 1". Or, nowadays: 91,91. */
      long unsigned int result;
      result= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_p);
      if (result == 1)
        field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_p);
      if (field_type == MP_ARRAY)
      {
        result= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_p);
        if (result == 1)
          field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_p);
      }
    }
    if (field_type == MP_STR)
    {
      value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_p, &value_length);
      returned_string= QString::fromUtf8(value, value_length);
    }
    else if (field_type == MP_UINT)
    {
      uint64_t uint_value= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_p);
      long long unsigned int llu= uint_value;
      value_length= sprintf(value_as_string, "%llu", llu);
      returned_string= QString::fromUtf8(value_as_string);
    }
    else if (field_type == MP_INT)
    {
      int64_t int_value= lmysql->ldbms_mp_decode_int(&tarantool_tnt_reply_data_p);
      long long int lli= int_value;
      value_length= sprintf(value_as_string, "%lld", lli);
      returned_string= QString::fromUtf8(value_as_string);
    }
  }
  else returned_string= "";
  lmysql->ldbms_tnt_reply_free(&tarantool_tnt_reply);
  return returned_string;
}
#endif

#ifdef DBMS_TARANTOOL
/*
  Call tarantool_initialize() from connect_tarantool() if successful.
  The main task is to create a function that executes SQL statements or Lua requests.
  There might be multiple things to execute between START TRANSACTION and COMMIT|ROLLBACK
  because we defer in-transaction statements, then run them all within a single function.
  If there's only one statement, we don't call ocelot_sqle, we directly call box.execute or eval
  Luckily there won't be multiple results for any single SQL statement or Lua chunk.
  Input = a string containing [type][size];[sql-statement-or-Lua-chunk] repeated.
          type is 'S' = SQL or 'L' = Lua
          size is a string of an integer that ends with ;
          sql-statement is something you can pass to box.execute
          lua-chunk is something you can pass to dostring
  Output = a table or multiple tables
           results returned from box.execute or dostring, one for each statement
           If there was an error, then the result will be "Error: [number] [message]"
             (Error messages will be added to a big messages which we'll return once)
           If there was no return, then the result will be "nil"
           If there are multiple result sets, we will produce a tabbed widget later.
  Todo: version check. we pick it up during connect with "return box.info.version"
  Todo: query_return is unused.
        We should check it because if you can't create the functions, you can't do transactions.

  Example: 'S37;CREATE TABLE MJ (s1 INT PRIMARY KEY);S37;CREATE TABLE MJ (s1 INT PRIMARY KEY);'
  You could invoke ocelot_sqle with conn:eval([[return0 = ocelot_sqle(stuff)]])
  but I think conn:call() i.e. I am happier with tnt_request_call.
  Todo: I fear that query_return might have nothing even if there is an error.
  Todo: Global! So This assumes that all clients use box.execute() or all use box.sql.execute().
*/
void MainWindow::tarantool_initialize(int connection_number)
{
  if (strcmp(tarantool_box_execute, "No SQL") == 0) return;
  QString query_return;
  const char *error_string=
        "function ocelot_sqle_error (x)"
        "  local e = ''"
        "  if type(x) == 'string' then"
        "    e = 'Error: 0 ' .. x"
        "  else"
        "    if type(x) == 'cdata' then"
        "      e = 'Error: ' .. x:unpack().code .. ' ' .. x:unpack().message"
        "    else"
        "      e = 'Error: 0 unknown'"
        "    end"
        "  end"
        "  return e"
        "  end";
  query_return= tarantool_internal_query((char*)error_string, connection_number);

  const char *ex_string_1=
        "function ocelot_sqle (input_statements)"
        "  local i = 1"
        "  local statement_number = 1"
        "  local j, original_i, size_string, size_int, statement, status, r_type"
        "  local returns = {}"
        "  local e = ''"
        "  while true do"
        "    r_type = string.sub(input_statements, i, i)"
        "    if r_type == nil then break end"
        "    i = i + 1"
        "    original_i = i"
        "    i, j = string.find(input_statements, ';', i)"
        "    if i == nil then break end"
        "    size_string = string.sub(input_statements, original_i, i - 1)"
        "    size_int = string.format('%d', size_string)"
        "    statement = string.sub(input_statements, j + 1, j + size_int)"
        "    if r_type == 'S' then status, returns[statement_number] = pcall(";
  const char *ex_string_2=
        ", statement) end"
        "    if r_type == 'L' then status, returns[statement_number] = pcall(dostring, statement) end"
        "    if status == false then"
        "      status, e = pcall(ocelot_sqle_error, returns[statement_number])"
        "      if status == false then e = 'Error: 0 unknown' end"
        "      returns[statement_number] = e"
        "    end"
        "    if returns[statement_number] == nil then returns[statement_number] = 'nil' end"
        "    i = j + 1 + size_int"
        "    statement_number = statement_number + 1"
        "  end"
        "  return unpack(returns)"
        "  end";

  char ex_string_4[2048]; /* actual current size = 1150 but allow for slight increase */
  strcpy(ex_string_4, ex_string_1);
  strcat(ex_string_4, tarantool_box_execute);
  strcat(ex_string_4, ex_string_2);
  query_return= tarantool_internal_query((char*)ex_string_4, connection_number);
}
#endif

#ifdef DBMS_TARANTOOL
/*
  tnt_flush() sends a request to the server.
  after every tnt_flush, save reply.
  TODO: KLUDGE: (I wonder many times have I used that word.)
        When I entered [[return box.schema.space.create('T8');]] I got
        error = unsupported Lua type 'function' but the space was
        created. There are github.com/tarantool issues that mention
        this message. I don't understand them. So I'll cancel the error.
*/

void MainWindow::tarantool_flush_and_save_reply(unsigned int connection_number)
{
  lmysql->ldbms_tnt_flush(tnt[connection_number]);

  lmysql->ldbms_tnt_reply_init(&tarantool_tnt_reply);
  int read_result= tnt[connection_number]->read_reply(tnt[connection_number], &tarantool_tnt_reply);

  /*
    Because of a Tarantool bug "Result code is sometimes 0 when there is an error"
    I cannot trust reply.code, so decide it is an error if error message is set.
    Also I notice that reply.data == NULL, which probably is the cause of later trouble.
    Todo: But this is not a fix. Follow issue#4177 and change this when it is fixed. (Hmm. It is now fixed.)
    Todo: ocelotgui will crash if this kludge is not present. Make it more robust, eh?
  */
  if (tarantool_tnt_reply.code == 0)
  {
    if (tarantool_tnt_reply.error != NULL) tarantool_tnt_reply.code= 3;
  }

  tarantool_tnt_reply_data_p= tarantool_tnt_reply.data;

  /* Todo: check: should this be != 0 or should it be == -1? */
  if (read_result != 0)
  {
    tarantool_errno[connection_number]= 1;
    sprintf(tarantool_errmsg, "read_result=%d", read_result);
    return;
  }
  tarantool_errno[connection_number]= tarantool_tnt_reply.code;

  if (tarantool_tnt_reply.code != 0)
  {
    char *x1= (char*)tarantool_tnt_reply.error;
    char *x2= (char*)tarantool_errmsg;
    while (x1 < tarantool_tnt_reply.error_end) *(x2++)=*(x1++);
    *x2= '\0';
  }
  else strcpy(tarantool_errmsg, er_strings[er_off + ER_OK]);
  if (strcmp(tarantool_errmsg, "unsupported Lua type 'function'") == 0)
  {
    tarantool_errno[connection_number]= 0;
    strcpy(tarantool_errmsg, er_strings[er_off + ER_OK]);
  }
}

/*
  Return statement type = first keyword = TOKEN_KEYWORD_SELECT etc.
  Probably hparse has already found the facts in a better way but
  perhaps you haven't called hparse.
  Currently this is only being used to guess whether it's Lua.
*/
/*
  DESPERATION -- for tarantool_real_query() ...
  We are passing dbms_query + dbms_query_len, which might not be the
  same as a subset of main_token globals. We just need to know what
  are the first two tokens, we're looking for BEGIN, COMMIT, ROLLBACK
  but not ROLLBACK TO, LUA '...'. We have to skip comments, and we
  assume that there aren't more than 98 comments at statement start.
  If first word is not an SQL statement-start word, or LUA.
  turn on the Lua flag.
  ALSO: make_statement_ready_to_send() happened recently, and we could
        have used it to know the first words, would have been faster
  ALSO: hparse_f_multi_block() turned on TOKEN_FLAG_IS_LUA, and we
        could have used it to know if it's Lua, would have been faster
  TODO: return error if too many initial comments, or retry with more
  TODO: if we get WITH, we'd like to know if it's SELECT|INSERT|UPDATE
        (which requires going ahead many more words)
  Warn: only works for Tarantool at the moment, e.g.
        wouldn't recognize MySQL/MariaDB comments starting with #
  TODO: Now tarantool_real_query has alltext, you should use that!
*/
QString MainWindow::get_statement_type(QString q_dbms_query, int *statement_type)
{
  log("get_statement_type", 15);
  int token_offsets[100]; /* Surely a single assignable target can't have more */
  int token_lengths[100];
  tokenize(q_dbms_query.data(),
           q_dbms_query.size(),
           &token_lengths[0], &token_offsets[0], 100 - 1,
          (QChar*)"33333", 2, "", 1);
  int word_number= 0;
  QString word0= "", word1= "", word2= "";
  for (int i= 0; i < 100; ++i)
  {
    if (token_lengths[i] == 0) break;
    if ((q_dbms_query.mid(token_offsets[i], 2) == "/*")
     || (q_dbms_query.mid(token_offsets[i], 2) == "--"))
      continue;
    if (word_number == 0)
    {
      word0= q_dbms_query.mid(token_offsets[i], token_lengths[i]);
    }
    if (word_number == 1)
    {
      word1= q_dbms_query.mid(token_offsets[i], token_lengths[i]);
    }
    if (word_number == 2)
    {
      word2= q_dbms_query.mid(token_offsets[i], token_lengths[i]);
      break;
    }
    ++word_number;
  }
  *statement_type= get_statement_type_low(word0, word1, word2);
  return word1;
}

/* TODO: Get fussier about what you'll accept is (Tarantool) SQL. */
int MainWindow::get_statement_type_low(QString word0, QString word1, QString word2)
{
  word0= word0.toUpper();

  int statement_type= TOKEN_KEYWORD_DO_LUA;
  if (word0 == "ALTER")
  {
    if (QString::compare(word1, "TABLE", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_ALTER;
  }
  else if (word0 == "ANALYZE")
  {
    if ((word1 == ";") || (word1 == "")) statement_type= TOKEN_KEYWORD_ANALYZE;
    if (word1 > "")
    {
      QChar w1c1= word1.at(0);
      if ((w1c1.isLetter() == true)
       || (w1c1 == '\"'))
        statement_type= TOKEN_KEYWORD_ANALYZE;
    }
  }
  else if (word0 == "COMMIT")
  {
    if ((word1 == ";") || (word1 == "")) statement_type= TOKEN_KEYWORD_COMMIT;
  }
  else if (word0 == "CREATE")
  {
    if ((QString::compare(word1, "UNIQUE", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "INDEX", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "TABLE", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "TRIGGER", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "VIEW", Qt::CaseInsensitive) == 0))
      statement_type= TOKEN_KEYWORD_CREATE;
  }
  else if (word0 == "DELETE")
  {
    if (QString::compare(word1, "FROM", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_DELETE;
  }
  else if (word0 == "DROP")
  {
    if ((QString::compare(word1, "INDEX", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "TABLE", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "TRIGGER", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "VIEW", Qt::CaseInsensitive) == 0))
      statement_type= TOKEN_KEYWORD_DROP;
  }
  else if (word0 == "EXPLAIN") { statement_type= TOKEN_KEYWORD_EXPLAIN; }
  else if (word0 == "INSERT")
  {
    if ((QString::compare(word1, "INTO", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "OR", Qt::CaseInsensitive) == 0))
      statement_type= TOKEN_KEYWORD_INSERT;
  }
  else if (word0 == "LUA") { statement_type= TOKEN_KEYWORD_LUA; }
  else if (word0 == "PRAGMA") { statement_type= TOKEN_KEYWORD_PRAGMA; }
  else if (word0 == "RELEASE")
  {
    if (QString::compare(word1, "SAVEPOINT", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_RELEASE;
  }
  else if (word0 == "REPLACE")
  {
    if (QString::compare(word1, "INTO", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_REPLACE;
  }
  else if (word0 == "ROLLBACK")
  {
    if (QString::compare(word1, "TO", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_ROLLBACK_IN_ROLLBACK_TO;
    else
    {
      if ((word1 == ";") || (word1 == "")) statement_type= TOKEN_KEYWORD_ROLLBACK;
    }
  }
  else if (word0 == "SAVEPOINT")
  {
    if (word1 > "")
    {
      QChar w1c1= word1.at(0);
      if ((w1c1.isLetter() == true)
       || (w1c1 == '\"'))
        statement_type= TOKEN_KEYWORD_SAVEPOINT;
    }
  }
  else if (word0 == "SELECT") { statement_type= TOKEN_KEYWORD_SELECT; }
  else if (word0 == "SET")
  {
    if (QString::compare(word1, "SESSION", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_SET;
  }
  else if (word0 == "START")
  {
    if (strcmp(tarantool_box_execute, "No SQL") != 0)
    {
      if (QString::compare(word1, "TRANSACTION", Qt::CaseInsensitive) == 0)
        statement_type= TOKEN_KEYWORD_START;
    }
  }
  else if (word0 == "TRUNCATE")
  {
    if (QString::compare(word1, "TABLE", Qt::CaseInsensitive) == 0)
      statement_type= TOKEN_KEYWORD_TRUNCATE;
  }
  else if (word0 == "UPDATE")
  {
    if (word1 > "")
    {
      QChar w1c1= word1.at(0);
      if ((w1c1.isLetter() == true)
       || (w1c1 == '\"'))
        statement_type= TOKEN_KEYWORD_UPDATE;
    }
  }
  else if (word0 == "VALUES")
  {
    if (word1 == "(") statement_type= TOKEN_KEYWORD_VALUES;
  }
  else if (word0 == "WITH")
  {
    if (QString::compare(word1, "RECURSIVE", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_WITH;
    if (QString::compare(word2, "AS", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_WITH;
  }
  else { statement_type= TOKEN_KEYWORD_DO_LUA; }
  return statement_type;
}

/* An equivalent to mysql_real_query(). NB: this might be called from a non-main thread */
/*
   Todo: we shouldn't be calling tparse_f_program() yet again!
         AND WE DON'T NEED TO. NOW WE PASS ALLTEXT.
   Todo: I succeeded in making this work
           lua 'return box.space.t:select()';
         but:
           should use [[...]] or escapes
           should not depend later on looking at TOKEN_KEYWORD_LUA
   Because Tarantool-style transactions require us to send all requests
   as a single send, we have to combine them -- which is sad because we
   spent time earlier in splitting them apart. We use a QStringList.
   Todo: We depend on commit|rollback to end a transaction but they might
         be inside a Lua function.
*/
/*
  Re dbms_query and alltext
  We pass dbms_query = the string to execute, which might have been massaged by
  get_ready_to_send(). It might not be the first query in alltext.
  We pass alltext = the complete text, not massaged, which might contain multiple
  statements (and if dbms_query is not the first statement then passed_main_token_number > 0).
  Mainly we use it because it has already gone through the recognizer.
  Todo: don't parse again if you don't need to!
  Todo: use alltext rather than dbms_query sometimes!
  Todo: we could be using const a lot more often!
  Todo: You aren't actually using table_name or column_name QStrings!
        You need them in tarantool_scan_field_names!
*/
/*
      In here we should be setting the table name and the
      field names, if it is SELECT -- Tarantool doesn't tell us.
      Currently generated UPDATEs lack the right information,
      tarantool_scan_field_names generates the wrong table name and
      the wrong literal (seems to assume it's varchar) and doesn't have
      an equivalent for org_name + org_table. We could figure this out by looking
      again at the statement -- make sure it's SELECT etc.
      See inside this function where we calculate offset_of_space_name.
      Make sure main_token list is still valid, make sure it's SELECT (not missing WITH),
      calculate for both SQL table and NoSQL space, make sure it's not
      in a transaction so it will really produce a grid result.
      Put it in global or (somehow) add to the result set information.
      Tarantool has revised box.execute() but I still mostly follow the old way.
      ! You won't see TOKEN_REFTYPE_COLUMN if it is *
      ! dbms_query might be only the current query of a multi-query
        this is a shame because when you call action_execute_one_statement you have text
        see the comments REALL DUBIOUS twice in this function
      ! Do this for Lua too
*/
int MainWindow::tarantool_real_query(const char *dbms_query,
                                     unsigned long dbms_query_len,
                                     unsigned int connection_number,
                                     unsigned int passed_main_token_number,
                                     unsigned int passed_main_token_count_in_statement,
                                     const QString *alltext)
{
  log("tarantool_real_query start", 80);
  tarantool_errno[connection_number]= 10001;
  strcpy(tarantool_errmsg, "Unknown Tarantool Error");

  QString x_dbms_query;
  if (passed_main_token_number > 0)
  {
    x_dbms_query= *alltext;
  }
  else x_dbms_query= QString::fromUtf8(dbms_query, dbms_query_len);

  {
    unsigned int i;
    QString text= x_dbms_query;

    tarantool_table_name= ""; /* global within MainWindow */
    tarantool_column_name= ""; /* global within MainWindow */
    int parentheses_count= 0;
    int type;
    bool is_select_seen= false;
    bool is_comma= false;
    bool is_from_seen= false;
    for (i= passed_main_token_number; i < passed_main_token_count_in_statement; ++i)
    {
      if (main_token_lengths[i] == 0) break; /* This is impossible, is an assert better? */
      is_comma= false;
      type= main_token_types[i];
      if (main_token_types[i] == TOKEN_TYPE_OPERATOR)
      {
        QString o= text.mid(main_token_offsets[i], main_token_lengths[i]);
        if (o == "(") ++parentheses_count;
        if (o == ")") --parentheses_count;
        if (o == ",")
        {
          is_comma= true;
        }
      }
      if (parentheses_count != 0) continue;
      if (is_select_seen == false)
      {
        if (type == TOKEN_KEYWORD_WITH) continue;
        if ((type > TOKEN_KEYWORDS_START) && (type != TOKEN_KEYWORD_SELECT)) break;
        is_select_seen= true;
        continue;
      }
      if ((type == TOKEN_KEYWORD_FROM) || (is_comma == true))
      {
        /* Back up from "," or "from". Whatever precedes is either column or expression. */
        for (unsigned int j= i - 1; j > passed_main_token_number; --j)
        {
          int jtype= main_token_types[j];
          if ((type >= TOKEN_TYPE_COMMENT_WITH_SLASH) && (type <= TOKEN_TYPE_COMMENT_WITH_MINUS))
            continue;
          int jreftype= main_token_reftypes[j];
          if (jreftype == TOKEN_REFTYPE_ALIAS_OF_COLUMN)
          {
            --j;
            jtype= main_token_types[j];
            if (jtype == TOKEN_KEYWORD_AS)
            {
              --j;
            }
          }
          if (jreftype == TOKEN_REFTYPE_COLLATION)
          {
            --j;
            --j;
          }
          if (main_token_reftypes[j] == TOKEN_REFTYPE_COLUMN)
            tarantool_column_name= tarantool_column_name + ".!.!" + text.mid(main_token_offsets[j], main_token_lengths[j]);
          else
            tarantool_column_name= tarantool_column_name + ".!.!" + "";
          break;
        }
        if (type == TOKEN_KEYWORD_FROM) is_from_seen= true;
        continue;
      }
      if ((is_from_seen == true) && (main_token_reftypes[i] == TOKEN_REFTYPE_TABLE))
      {
        tarantool_table_name= text.mid(main_token_offsets[i], main_token_lengths[i]);
        break;
      }
    }
  }

  QString q_dbms_query= QString::fromUtf8(dbms_query, dbms_query_len);
  int statement_type;
  /* Todo: use x_dbms_query???? */
  QString word1= get_statement_type(q_dbms_query, &statement_type);
  int token_type= -1;
  //int result_row_count= 0; /* for everything except SELECT we ignore rows that are returned */

  {
    /* If it is LUA 'X'; we only want to pass X. */
    if (statement_type == TOKEN_KEYWORD_LUA) q_dbms_query= connect_stripper(word1, false);
    int statement_number= tarantool_statements_in_begin.size();

    if (statement_number > 0) q_dbms_query= q_dbms_query.append(" ");

    /* TEST!!!! If we survive removing these two lines, we can rethink SQL transactions. */
    /*          ... but we don't survive. */
    if ((tarantool_start_transaction_seen == false)
     && (statement_type != TOKEN_KEYWORD_START))
    {
      if ((statement_type != TOKEN_KEYWORD_LUA) && (statement_type != TOKEN_KEYWORD_DO_LUA))
      {
        /* SQL statement, not within transaction or start of transaction, direct box.execute call */
        tarantool_execute_sql(q_dbms_query.toUtf8(), q_dbms_query.toUtf8().length(), connection_number);
      }
      else
      {
        /* Lua chunk, not within transaction or start of transaction, direct eval */
        tarantool_execute_lua(q_dbms_query.toUtf8(), q_dbms_query.toUtf8().length(), connection_number);
      }
      return tarantool_errno[connection_number];
    }
  }
  if ((statement_type != TOKEN_KEYWORD_LUA) && (statement_type != TOKEN_KEYWORD_DO_LUA))
    tarantool_statements_in_begin.append(
                "S" +
                QString::number(q_dbms_query.toUtf8().length()) +
                ";" +
                q_dbms_query);
   else
    tarantool_statements_in_begin.append(
                "L" +
                QString::number(q_dbms_query.toUtf8().length()) +
                ";" +
                q_dbms_query);

  if (statement_type == TOKEN_KEYWORD_START)
  {
    tarantool_start_transaction_seen= true;
  }
  if ((statement_type == TOKEN_KEYWORD_COMMIT)
   || (statement_type == TOKEN_KEYWORD_ROLLBACK))
  {
    tarantool_start_transaction_seen= false;
  }
  if (tarantool_start_transaction_seen == true)
  {
    strcpy(tarantool_errmsg, er_strings[er_off + ER_8372]);
    tarantool_errno[connection_number]= ER_8372_INT;
    return tarantool_errno[connection_number];
  }
  if (hparse_f_is_nosql(q_dbms_query) == false)
  {
    QString s= "";
    QString s2;
    s2= "";
    while (tarantool_statements_in_begin.isEmpty() == false)
    {
      s= tarantool_statements_in_begin.at(0);
      s2.append(s);
      tarantool_statements_in_begin.removeAt(0);
    }
    /* Todo: reduce copying because some statements might be very long. */
    /* size of s2.toUtf8 not size of s2 is right but s2.size()*4 would work too */
    int dbms_query_len= s2.toUtf8().length();
    char *request_string= new char[dbms_query_len + 1];
    memcpy(request_string, s2.toUtf8(), dbms_query_len);
    struct tnt_stream *tuple= lmysql->ldbms_tnt_object(NULL);
    lmysql->ldbms_tnt_object_add_array(tuple, 1);
    lmysql->ldbms_tnt_object_add_str(tuple, request_string, dbms_query_len);
    lmysql->ldbms_tnt_call(tnt[connection_number], "ocelot_sqle", 11, tuple);
    tarantool_flush_and_save_reply(0);
    log("tarantool_real_query end", 80);
    return 0; /* Todo: in fact I suppose commit|rollback could fail, we should be passing it on */
  }
  /* If something is NoSQL, transactions don't work. */
  /* This section is rarely tested, I'm thinking of abandoning it. */
   /* It might be saved if I could push + pop main_tokens. */

  strcpy(tarantool_errmsg, "/* NOSQL */ is temporarily disabled");
  tarantool_errno[connection_number]= 8373;
  return tarantool_errno[connection_number];
  tarantool_select_nosql= true;
  //int hparse_statement_type=-1, clause_type=-1;
  //QString current_token, what_we_expect, what_we_got;

  //tparse_f_program(text); /* syntax check; get offset_of_identifier,statement_type, number_of_literals */
  if (hparse_errno > 0)
  {
    strcpy(tarantool_errmsg, hparse_errmsg);
    tarantool_errno[connection_number]= hparse_errno;
    return tarantool_errno[connection_number];
  }

  /* The number of literals in a statement must be what we'd insert etc. */
  int number_of_literals= 0;
  for (unsigned int i= passed_main_token_number; i < passed_main_token_number + passed_main_token_count_in_statement; ++i)
  {
    if (main_token_types[i] == TOKEN_TYPE_LITERAL)
    {
      ++number_of_literals;
    }
  }

  /* The first identifier in any of the statements must be the space name. */
  /* TODO: UNLESS hparse_statement_type == TOKEN_KEYWORD_SET! */
  /* TODO: This is another reason for having a table of reftypes, eh? */
  int offset_of_space_name= -1;
  for (unsigned int i= passed_main_token_number; i < passed_main_token_number + passed_main_token_count_in_statement; ++i)
  {
    if ((main_token_types[i] == TOKEN_TYPE_IDENTIFIER)
     && (main_token_reftypes[i] == TOKEN_REFTYPE_TABLE))
    {
      offset_of_space_name= (int) i;
      break;
    }
  }

  /* todo: use x_dbms_query???? */
  QString text= q_dbms_query; /* REALLY DUBIOUS */

  int spaceno= -1;
  {
    int i= offset_of_space_name;
    QString space_name= text.mid(main_token_offsets[i], main_token_lengths[i]);
    spaceno= lmysql->ldbms_tnt_get_spaceno(tnt[connection_number], space_name.toUtf8(), main_token_lengths[i]);
    if (spaceno < 0)
    {
      /* Todo: figure out when this really needs to be called */
      lmysql->ldbms_tnt_reload_schema(tnt[connection_number]);
      spaceno= lmysql->ldbms_tnt_get_spaceno(tnt[connection_number], space_name.toUtf8(), main_token_lengths[i]);
      if (spaceno < 0)
      {
        QString s;
        s= "Could not find a space named ";
        s.append(space_name);
        tarantool_errno[connection_number]= 10003;
        strcpy(tarantool_errmsg, s.toUtf8());
        return tarantool_errno[connection_number];
      }
    }
  }

  /*
    The iterator type, if there is one, is the first comp-op
    in the statement. If there are more comp-ops, we've already
    checked that they're valid, during tparse_f_indexed_condition().
  */
  int iterator_type= TARANTOOL_BOX_INDEX_EQ;;
  for (unsigned int i= passed_main_token_number; i < passed_main_token_number + passed_main_token_count_in_statement; ++i)
  {
    if (main_token_types[i] == TOKEN_TYPE_OPERATOR)
    {
      QString token= text.mid(main_token_offsets[i], main_token_lengths[i]);
      if (token == "=") { iterator_type= TARANTOOL_BOX_INDEX_EQ; break; }
      if (token == "<") { iterator_type= TARANTOOL_BOX_INDEX_LT; break; }
      if (token == "<=") {iterator_type= TARANTOOL_BOX_INDEX_LE; break; }
      if (token == ">") { iterator_type= TARANTOOL_BOX_INDEX_GT; break; }
      if (token == ">=") { iterator_type= TARANTOOL_BOX_INDEX_GE; break; }
    }
  }

  /* DELETE + INSERT + REPLACE + (maybe?) SELECT require a tuple of values to insert or search */
  struct tnt_stream *tuple= NULL;
  //if (number_of_literals > 0)
  {
    tuple= lmysql->ldbms_tnt_object(NULL);
    lmysql->ldbms_tnt_object_add_array(tuple, number_of_literals);
    int number_of_adds= 0;
    for (unsigned int i= passed_main_token_number; i < passed_main_token_number + passed_main_token_count_in_statement; ++i)
    {
      token_type= main_token_types[i];
      if (token_type == TOKEN_TYPE_LITERAL)
      {
        /* Todo: figure out literal's exact type, and be sure. */
        assert(main_token_lengths[i] > 0);
        QString first_char= text.mid(main_token_offsets[i], 1);
        if (first_char == "'") token_type= TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE;
        else if (first_char < "#") token_type= TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE;
        else token_type= TOKEN_TYPE_LITERAL_WITH_DIGIT;
      }
      if ((token_type == TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE)
       || (token_type == TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE))
      {
        QString s;
        s= text.mid(main_token_offsets[i], main_token_lengths[i]);
        s= s.left(s.length() - 1);
        s= s.right(s.length() - 1);
        lmysql->ldbms_tnt_object_add_str(tuple, s.toUtf8(), s.length());
        ++number_of_adds;
      }
      if (token_type == TOKEN_TYPE_LITERAL_WITH_DIGIT)
      {
        /* todo: binary, float, double */
        QString s;
        s= text.mid(main_token_offsets[i], main_token_lengths[i]);
        lmysql->ldbms_tnt_object_add_int(tuple, s.toInt());
        ++number_of_adds;
      }
      if (token_type == TOKEN_KEYWORD_NULL)
      {
        lmysql->ldbms_tnt_object_add_nil(tuple);
        ++number_of_adds;
      }
    }
    assert(number_of_literals == number_of_adds);
    /* Todo: check whether we really need to say object_container_close. */
    lmysql->ldbms_tnt_object_container_close(tuple);
  }

  result_row_count= 0; /* for everything except SELECT we ignore rows that are returned */

  if (statement_type == TOKEN_KEYWORD_DELETE)
  {
    lmysql->ldbms_tnt_delete(tnt[connection_number], spaceno, 0, tuple);
    tarantool_flush_and_save_reply(connection_number);
    lmysql->ldbms_tnt_reply_free(&tarantool_tnt_reply);
    return tarantool_errno[connection_number];
  }

  if (statement_type == TOKEN_KEYWORD_INSERT)
  {
    if (lmysql->ldbms_tnt_insert(tnt[connection_number], spaceno, tuple) < 0)
    {
      tarantool_errno[connection_number]= 10007;
      strcpy(tarantool_errmsg, "Bug. tnt_insert() returned an error");
      return tarantool_errno[connection_number];
    }
    tarantool_flush_and_save_reply(connection_number);
    lmysql->ldbms_tnt_reply_free(&tarantool_tnt_reply);
    return tarantool_errno[connection_number];
  }

  if (statement_type == TOKEN_KEYWORD_REPLACE)
  {
    if (lmysql->ldbms_tnt_replace(tnt[connection_number], spaceno, tuple) < 0)
    {
      tarantool_errno[connection_number]= 10007;
      strcpy(tarantool_errmsg, "Bug. tnt_replace() returned an error");
      return tarantool_errno[connection_number];
    }
    tarantool_flush_and_save_reply(connection_number);
    lmysql->ldbms_tnt_reply_free(&tarantool_tnt_reply);
    return tarantool_errno[connection_number];
  }

  if (statement_type == TOKEN_KEYWORD_SELECT)
  {
    lmysql->ldbms_tnt_select(tnt[connection_number], spaceno, 0, (2^32) - 1, 0, iterator_type, tuple);
    tarantool_flush_and_save_reply(connection_number);
    if (tarantool_errno[connection_number] != 0) return tarantool_errno[connection_number];
    /* The return should be an array of arrays of scalars. */
    /* If there are no rows, then there are no fields, so we cannot put up a grid. */
    /* Todo: don't forget to free if there are zero rows. */
    {
      const char *tarantool_tnt_reply_data_copy= tarantool_tnt_reply_data_p; /* push */
//      unsigned long r= tarantool_num_rows(connection_number);
      tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy; /* pop */
//      if (r == 0)
//      {
//        strcpy(tarantool_errmsg, "Zero rows.");
//        tarantool_errno[connection_number]= 10027;
//      }
    }

    return tarantool_errno[connection_number];
  }

  return tarantool_errno[connection_number];
}

/*
  tarantool_tnt_reply_data_p has results from all statements in the transaction.
  It starts with a count of the number of statements, then something for each result.
  Signatures for SQL statements:
    signature_0 = 0x81, 0xa9, "row_count", n i.e. 1-item map as happens for most ddl + dml
    signature_1 = 0x82, 0xa8, "metadata" i.e. 2-item map as happens for select
    0xd9, "... error message ..." i.e. string as happens for errors (we check for any string signal)
  But tarantool_tnt_reply.error always has 0 because that is the result of "return ...".
  So, for each statement:
    If it is "row_count" then add diagnostic "ok, nn rows"
    If it is "metadata" then make a result-set addition, and add diagnostic "ok, nn rows"
    If it is error message then add diagnostic "error, " + error message
  If there is more than one result set, add tab.
  The final result is what determines whether you display tarantool_error or not.
  I don't think we can guarantee 1-to-1 correspondence between statements and results.
  Todo: you still need to check what NoSQL requests deliver.
  Todo: single statements might go directly, and that would be a different signature. ?? but it works.
  Todo: some simple memcmps would accomplish nearly the same effect. but signature check should be strict
  Todo: there might be more result sets and error messages, maybe restart from tarantool_result_set.data
  Todo: too much code repetition of "is it uint or int" followed by decode of uint or uint, for messages
  Todo: 0xd9 only should be interpreted as an error if it's preceded by start transaction
  If and only if you see a result set that is not at start, change tarantool_tnt_reply_data_p.
*/
/*
  For tnt_execute(query) of SQL, over the wire we have metadata and then data. The tarantool-c folks
  decided to split them so that struct tnt_reply has a data component and a metadata component,
  but not if tnt_call(box.execute(query)) or (I guess) tnt_eval('box.execute(query)').
  We try to handle both.
*/

int MainWindow::tarantool_get_result_set(int connection_number, int desired_result_set_number)
{
  long int number_of_results;
  const char *tarantool_tnt_reply_data_copy= tarantool_tnt_reply.data;
  if (tarantool_tnt_reply_data_copy == NULL) return 0; /* Actually this shouldn't happen, must be an error */

  if (tarantool_is_result_count(tarantool_tnt_reply_data_copy))
    number_of_results= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy);
  else
    number_of_results= 1;
  int this_result_set_number= 0;
  {
    for (int i= 0; i < number_of_results; ++i)
    {
      int tmp_result_type;
      tarantool_get_result_type(connection_number, tarantool_tnt_reply_data_copy, &tmp_result_type);
      if ((tmp_result_type == RESULT_TYPE_2)
       || (tmp_result_type == RESULT_TYPE_4)
       || (tmp_result_type == RESULT_TYPE_5))
      {
        if (this_result_set_number == desired_result_set_number)
        {
          tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy;
          return 1;
        }
        ++this_result_set_number;
      }
      lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);
    }
  }
  return 0;
}

QString MainWindow::tarantool_get_messages(int connection_number)
{
  QString messages= "";
  char field_type;
  long int number_of_results;
  /* todo: this might not be good enough, it assumes failed statements make 0, not guaranteed */
  /* !! IF IT ASSUMES WRONG, YOU COULD CRASH! */
  if (tarantool_tnt_reply.data == 0)
  {
    if (strcmp(tarantool_errmsg, "OK") != 0)
    {
      messages= er_strings[er_off + ER_ERROR];
      messages.append(". ");
    }
    messages.append(tarantool_errmsg);
    return messages;
  }
  const char *tarantool_tnt_reply_data_copy= tarantool_tnt_reply.data;

  if (tarantool_errno[connection_number] == 0)
  {
    messages= er_strings[er_off + ER_OK];
    messages.append(" ");
  }
  else
  {
    messages= er_strings[er_off + ER_ERROR];
    messages.append(". ");
    messages.append(tarantool_errmsg);
  }

  /* Don't look for messages if deferred because the search itself might cause an error. */
  /* Todo:  This line used to contain "connections_dbms[0]= DBMS_TARANTOOL", make sure that was an error. */
  if ((connections_dbms[0] == DBMS_TARANTOOL)
   && (tarantool_errno[connection_number] == ER_8372_INT))
    return messages;

  if (tarantool_is_result_count(tarantool_tnt_reply_data_copy))
    number_of_results= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy);
  else
    number_of_results= 1;

  {
    for (int i= 0; i < number_of_results; ++i)
    {
      int sig;
      tarantool_get_result_type(connection_number, tarantool_tnt_reply_data_copy, &sig);
      if (sig == RESULT_TYPE_6)
      {
        char value_as_string[16];
        const char *tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data_copy + 11;
        field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
        if (field_type == MP_UINT) /* anything other than MP_UINT would be a surprise */
        {
          uint64_t uint_value= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy_copy);
          long long unsigned int llu= uint_value;
          sprintf(value_as_string, "%llu", llu);
        }
        else if (field_type == MP_INT)
        {
          int64_t int_value= lmysql->ldbms_mp_decode_int(&tarantool_tnt_reply_data_copy_copy);
          long long int lli= int_value;
          sprintf(value_as_string, "%lld", lli);
        }
        messages= messages + " " + value_as_string + " rows affected";
      }
      if (sig == RESULT_TYPE_5)
      {
        messages.append(" ");
        messages.append(QString::number(tarantool_row_count[connection_number]));
        messages= messages + " rows selected";
      }
      if (sig == RESULT_TYPE_7)
      {
        const char *tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data_copy;
        const char *value;
        uint32_t value_length;
        value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy_copy, &value_length);
        char *error_string= new char[value_length + 1];
        memcpy(error_string, value, value_length);
        *(error_string + value_length)= '\0';
        messages= messages + " " + error_string;
        delete [] error_string;
      }
      lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);
    }
  }
  return messages;
}

/*
  Signature of result count = (array) followed by (array), as first bytes in what is returned
  Or: (array)(map) in which case the map is almost certainly "row_count"
  This happens for a transaction, in which case the number of results will always be > 1.
  This happens for a certain type of Lua request, in which case the number of results will always be 1.
  Do not be fooled by array+array from tnt_execute, which can be distinguished by checking if .metadata != 0
  If return == false, then assume the number of results is 1.
*/
bool MainWindow::tarantool_is_result_count(const char *tarantool_tnt_reply_data_copy)
{
  if (tarantool_tnt_reply_data_copy == NULL) return false; /* actually this should never happen, there is an error somewhere */
  if (tarantool_tnt_reply.metadata != 0) return false;
  const char *tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data_copy;
  char field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
  if (field_type != MP_ARRAY) return false;
  lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy_copy);
  field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
  if ((field_type == MP_ARRAY) || (field_type == MP_MAP)) return true;
  return false;
}


/* See comments preceding tarantool_get_result_set() */
/*
  Signatures for SQL statements:

    (map-2)(str-8)"metadata"(array)     RESULT_TYPE_5 i.e. 2-item map as happens for select

  Signatures for Lua requests:
    (array)(array) i.e. row+field count TOKEN_KEYWORD e.g. from "return box.space.T:select()"
    array signal, value e.g. from "return box.space.T:insert{1}"
    scalar value, e.g. from "return 5"   but this could conflict with RESULT_TYPE_7, rarely
    TODO: what happened to connection_number?
*/
const char * MainWindow::tarantool_get_result_type(
        int connection_number,
        const char *tarantool_tnt_reply_data_copy,
        int *result_type)
{
  const char *tarantool_tnt_reply_data_p_saved= tarantool_tnt_reply_data_p; /* push */
  long unsigned int result_row_count;
  tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy;
  tarantool_result_set_init(connection_number, &result_row_count, result_type);
  tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_p_saved; /* pop */
  return tarantool_tnt_reply_data_p_saved;

  /* EVERYTHING AFTER THIS IS CANCELLED */

  if ((tarantool_tnt_reply_data_p == NULL)
   || (tarantool_tnt_reply.data_end == NULL)
   || (tarantool_tnt_reply_data_copy == NULL))
  {
    *result_type= 0;
    return tarantool_tnt_reply_data_copy;
  }

  const char *tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data_copy;
  int array_size;
  char field_type;
  const char *value;
  uint32_t value_length;


  tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data_copy;
  field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
  if (field_type == MP_MAP)
  {
    array_size= lmysql->ldbms_mp_decode_map(&tarantool_tnt_reply_data_copy_copy);
    if (array_size == 2)
    {
      field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
      if (field_type == MP_STR)
      {
        value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy_copy, &value_length);
        if (value_length == 8)
        {
          if (memcmp(value, "metadata", 8) == 0)
          {
            field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
            if (field_type == MP_ARRAY)
            {
              *result_type= RESULT_TYPE_5;
              const char *x= tarantool_tnt_reply_data_copy;
              lmysql->ldbms_mp_decode_map(&x);
              lmysql->ldbms_mp_next(&x); /* skip "metadata" */
              lmysql->ldbms_mp_next(&x);
              lmysql->ldbms_mp_next(&x); /* skip "rows" so we're pointing to row count */
              return x;
            }
          }
        }
      }
    }
  }


  /* Still to come: (array)(value) */
  /* Still to come: value */
  *result_type= 0;
  return tarantool_tnt_reply_data_copy;
}

/*
  ? This might be superseded by above functions. ... Well, no it wasn't.
  We call this to get basic information about a Tarantool return;
  if it is a result set we get type + row count + return pointer to
  the first row.
  TODO: There might be multiple result sets, for example if there were
        multiple selects inside begin ... commit|rollback. We only look
        at the first. What we should be doing is: pass "selection number"
        and skip till we get to it. (Update: we seem to be doing that now)
  Todo: The calculation of data_length might be buggy.
  Todo: It might be nice to know what statement caused the result, although
        the signature of "select ..." won't look different from box.execute("select ...").
  Todo: return box.info().version returns 81 1 1 (fixmap, 1) which we do not recognize
  What is in tarantool_tnt_reply_data_p?
  LUA '"a"'         ... dd 0 0 0 1 a1 61
  LUA '15'          ... dd 0 0 0 1 f
  LUA 'm = 1'       ... dd 0 0 0 0
  LUA '...select()' ... dd 0 0 0 1 93 92  (93 is row count, 92 is field count)
  LUA '1,2,3'       ... dd 0 0 0 3 1  2  3
  SELECT is like LUA '...select()'
  SELECT / * NOSQL * /  dd 0 0 0 4 92 1 a5 68 65 (0 0 0 4 is row count)
  (dd is fixarray-32, 93 is fixarray)
  (the NOSQL option uses tarantool_tnt_select rather than eval)
  So return:
  0 == there is no result set because we don't understand ... error?
  1 == there is no result set because we start with fixarray-32 == 0
       or we get dd 0 0 0 1 c0 (nil)
  2 == array-32 == field count, then fields. so assume row_count == 1
  3 == array-32 == 1, array-x = row count, array-x == field count
  4 == array-32 == row count, then array-x == field count
  5 == same as 3, but first row is 0xa1 0x08 then column names. Or .metadata != 0
  6 == (map-1)(str-9)"row_count"(uint) i.e. 1-item map as happens for most ddl + dml
  7 == (str)"Error: ..." i.e. string as happens for errors in transactions
  7 == (str)"nil" etc. but we return 7 anyway just to get over this hump. It will be in the error line.
  Beware, though, because (array) at the start can be taken as #-of-results
*/

const char *MainWindow::tarantool_result_set_init(
        int connection_number,
        long unsigned int *result_row_count,
        int *result_set_type)
{
  log("tarantool_result_set_init start", 80);
  const char *tarantool_tnt_reply_data= tarantool_tnt_reply_data_p; /* not a push */
  char field_type;
  long unsigned int r= 0;
  //unsigned int data_length;

  if ((tarantool_tnt_reply.metadata != 0) && (tarantool_tnt_reply_data_p != 0))
  {
    if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_p) == MP_ARRAY)
    {
      /* We are looking at an array but it is column count not row count */
      r= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
      *result_set_type= RESULT_TYPE_5;
      goto return_point;
    }
  }

  if ((tarantool_tnt_reply_data_p == NULL)
   || (tarantool_tnt_reply.data_end == NULL))
    goto erret;
  {
    const char *tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data;
    int array_size;
    const char *value;
    uint32_t value_length;
    field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
    if (field_type == MP_MAP)
    {
      array_size= lmysql->ldbms_mp_decode_map(&tarantool_tnt_reply_data_copy_copy);
      if (array_size == 2)
      {
        value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy_copy, &value_length);
        if (value_length == 17)
        {
          if (memcmp(value, "autoincrement_ids", 17) == 0)
          {
            field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
            if (field_type != MP_ARRAY) goto erret;
            int autoincrement_id_count= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy_copy);
            for (int k= 0; k < autoincrement_id_count; ++k)
            {
                field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
                if (field_type == MP_UINT) lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy_copy);
                else if (field_type == MP_INT) lmysql->ldbms_mp_decode_int(&tarantool_tnt_reply_data_copy_copy);
                else goto erret;
            }
            array_size= 1; /* we have skipped autoincrement_ids so now we can proceed with field_count */
          }
        }
      }
      if (array_size == 1)
      {
        field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
        if (field_type == MP_STR)
        {
          value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy_copy, &value_length);
          if (value_length == 9)
          {
            if (memcmp(value, "row_count", 9) == 0)
            {
              field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
              if (field_type == MP_UINT)
              {
                *result_set_type= RESULT_TYPE_6;
                r= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy_copy); /* unused? */
                goto return_point;
              }
            }
          }
        }
      }
    }
  }

  {
    const char *tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data;
    const char *value;
    uint32_t value_length;
    field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
    if (field_type == MP_STR)
    {
      *result_set_type= RESULT_TYPE_7; /* trying to get over the hump, so 7 even if it's not "Error:" */
      r= 0;
      goto return_point;
      value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy_copy, &value_length);
      if (value_length > 7)
      {
        if (memcmp(value, "Error: ", 7) == 0)
        {
          if (isdigit(*(value+7)))
          {
            *result_set_type= RESULT_TYPE_7;
            r= 0;
            goto return_point;
          }
        }
      }
    }
  }

  {
    const char *n;

    n= tarantool_result_set_init_select(&r, -1, -1);
    if (n != NULL)
    {
      tarantool_tnt_reply_data= n;
      *result_set_type= RESULT_TYPE_5; goto return_point;
    }
  }

  field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data);
  if (field_type != MP_ARRAY) goto erret;

  {
    const char *tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data;
    field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
    int array_size;
    if (field_type == MP_ARRAY)
    {
      array_size= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy_copy);
      r= array_size;
      field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
      if (field_type == MP_ARRAY)
      {
        *result_set_type= RESULT_TYPE_4;
        tarantool_tnt_reply_data= tarantool_tnt_reply_data_copy_copy;
        goto return_point;
      }
    }
  }

  r= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);

  if (r > 0) /* Check if it's nil or a series of nothing but nils */
  {
    long unsigned int q;
    for (q= 0; q < r; ++q)
    {
      if ((unsigned char)*(tarantool_tnt_reply_data + q) != 0xc0) break;
    }
    if (q == r)
    {
      *result_set_type= RESULT_TYPE_1;
      goto return_point;
    }
  }


  /* TEST: ANOTHER EL GRANDE KLUDGE */
  if ((r > 1) && (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data) == MP_NIL))
  {
    const char *tarantool_tnt_reply_data2= tarantool_tnt_reply_data;
    long r2;
    for (r2= r; r2 != 0; --r2)
    {
      if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data2) == MP_NIL)
      {
        ++tarantool_tnt_reply_data2;
        continue;
      }
      break;
    }
    if (r2 == 0)
    {
    }
    else if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data2) == MP_ARRAY)
    {
      r= 1;
      tarantool_tnt_reply_data= tarantool_tnt_reply_data2;
    }
  }
  if (r == 0)
  {
    *result_set_type= RESULT_TYPE_1; goto return_point;
  }
  if (r != 1)
  {
    tarantool_tnt_reply_data= tarantool_tnt_reply_data_p;
    *result_set_type= RESULT_TYPE_2; goto return_point;
  }

  field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data);
  if (field_type != MP_ARRAY)
  {
    tarantool_tnt_reply_data= tarantool_tnt_reply_data_p;
    *result_set_type= RESULT_TYPE_2; goto return_point;
  }
  r= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
  field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data);
  if (field_type != MP_ARRAY)
  {
    tarantool_tnt_reply_data= tarantool_tnt_reply_data_p;
    *result_set_type= RESULT_TYPE_2; goto return_point;
  }
  *result_set_type= RESULT_TYPE_3; goto return_point;

return_point:
  if (*result_set_type == RESULT_TYPE_0) *result_row_count= 0;
  else if (*result_set_type == RESULT_TYPE_2) *result_row_count= 1;
//  if (*result_set_type != 4)
//  {
//    lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
//  }
//  long unsigned int r;
  else
  {
//  r= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
    *result_row_count= r;
  }
  log("tarantool_result_set_init end 1", 80);
  return tarantool_tnt_reply_data;
erret:
  tarantool_errno[connection_number]= 10008;
  strcpy(tarantool_errmsg, "Error: did not understand received data. ");
  if (tarantool_tnt_reply_data_p == NULL)
    strcat(tarantool_errmsg, "tarantool_tnt_reply_data_p == NULL");
  else if (tarantool_tnt_reply.data_end == NULL)
    strcat(tarantool_errmsg, "tarantool_tnt_reply.data_end == NULL");
  else
  {
    int j= tarantool_tnt_reply.data_end - tarantool_tnt_reply_data_p;
    strcat(tarantool_errmsg, "First few bytes are: ");
    char tmp_hex[16];
    for (int i= 0; i < 10 && i < j; ++i)
    {
      sprintf(tmp_hex, "%x ", *(tarantool_tnt_reply_data_p + i) & 0xff);
      strcat(tarantool_errmsg, tmp_hex);
    }
    strcat(tarantool_errmsg, ".");
  }
  *result_row_count= 0;
  log("tarantool_result_set_init end 0", 80);
  return 0;
}

/* SELECT will have, for a result with 1 column named '5' with type 'integer' and 1 row:
   dd,00,00,01                          1-element array
   82                                   2-element map (for metadata + rows)
     a8,"metadata"                      string
     91                                 1-element array (for column count)
     82                                 2-element map (for name + type)
       a4,'name'                        string
       a1,'5'                           string
       a4,'type'                        string
       a7,'integer'                     string
     a4,"rows"                          string
     91                                 1-element array (for row count)
     91                                 1-element array (for field count)
     5                                  contents
  OR, if it was done via tnt_execute rather than tnt_call or tnt_eval
    [metadata]
    91                                  1-element array = number of fields
      82                                2-element map (there might be more elements if details are requested)
        0                               IPROTO_FIELD_NAME
        a1,'5'                          string
        1                               IPROTO_FIELD_TYPE
        a7,'integer'                    string
    [data]
    91                                  1-element array = number of rows
      91                                1-element array = number of fields
        a1,'5'                          contents

  Return: pointer to first row
  Re column_number: If it is >= 0, we return pointer to column name not pointer to first data row.
                    Then the caller can say
                    value= lmysql->ldbms_mp_decode_str(tarantool_tnt_reply_data, &value_length);
  TODO: Probably we shouldn't assume 'name' and 'type' are in order and alone
  TODO: We could skip some strings instead of decoding them.
        In fact I could skip the whole map with ldbms_mp_next().
*/
const char * MainWindow::tarantool_result_set_init_select(
        long unsigned int *result_row_count,
        int column_number,
        int what_to_return)         /* -1 if column_number=-1, 0 if we want name, 1 if we want type */
{

  char field_type; /* for return from lmysql->ldbms_mp_typeof */
  uint32_t array_size; /* for return from lmyswl->dbms_mp_decode_array */
  uint32_t value_length; /* for return from lmysql->ldbms_mp_decode_str */
  const char *value; /* for return from lmysql->ldbms_mp_decode_str */
  uint64_t row_count;
  uint32_t field_count;

  const char *tarantool_tnt_reply_data_copy= tarantool_tnt_reply_data_p; /* push */
  const char* new_tarantool_tnt_reply_data;

  const char **tarantool_tnt_reply_data= &tarantool_tnt_reply_data_p;

  if ((tarantool_tnt_reply.metadata != 0) && (tarantool_tnt_reply_data_p != 0))
  {
    const char *tarantool_tnt_reply_metadata_copy= tarantool_tnt_reply.metadata;

    field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_metadata_copy);
    if (field_type != MP_ARRAY) { goto x; }
    field_count= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_metadata_copy);
    for (unsigned int field_no= 0; field_no < field_count; ++field_no)
    {
      field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_metadata_copy);
      if (field_type != MP_MAP) { goto x; }
      unsigned int member_count= lmysql->ldbms_mp_decode_map(&tarantool_tnt_reply_metadata_copy);
      const char *name_value; /* actually it's name value or type value */
      uint32_t name_value_length;
      for (unsigned int j= 0; j < member_count; ++j)
      {
        if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_metadata_copy) != MP_UINT) { goto x; }
        int member_type= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_metadata_copy);
        if (member_type == what_to_return) /* = IPROTO_FIELD_NAME or IPROTO_FIELD_TYPE */
        {
          if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_metadata_copy) != MP_STR) { goto x; }
          name_value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_metadata_copy, &name_value_length);
        }
        else /* 2 == IPROTO_FIELD_COLL 3 = IPROTO_FIELD_IS_NULLABLE 4 = IPROTO_FIELD_IS_AUTOINCREMENT etc. */
        {
          /* todo: check: what is this line for? surely it's no problem if it's not a string */
          if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_metadata_copy) != MP_STR) { goto x; }
          value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_metadata_copy, &value_length);
        }
      }
      if (field_no == (unsigned) column_number)
      {
        *result_row_count= name_value_length;
        tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy; /* pop */
        return name_value;
      }
    }
    const char *tnt_reply_data_p= tarantool_tnt_reply_data_p; /* push */
    if (lmysql->ldbms_mp_typeof(*tnt_reply_data_p) != MP_ARRAY) goto x;
    long int row_count= lmysql->ldbms_mp_decode_array(&tnt_reply_data_p);
    *result_row_count= row_count;
    if (column_number != -1)
    {
      tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy; /* pop */
      return NULL;
    }
    /* and now we are pointing to the first row */
    new_tarantool_tnt_reply_data= tnt_reply_data_p;
    tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy; /* pop */
    return new_tarantool_tnt_reply_data;
  }

  /* Todo: be suspicious of this, I fear it could be true in many cases */
  if (tarantool_tnt_reply_data_p > tarantool_tnt_reply.data)
  {
    /* dd, 0, 0, 1 will be missing if this is part of a transaction return */
    ;
  }
  else
  {
    field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
    if (field_type != MP_ARRAY) {  goto x; }
    array_size= lmysql->ldbms_mp_decode_array(tarantool_tnt_reply_data);
    if (array_size != 1) { goto x; }
  }

  field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
  if (field_type != MP_MAP) { goto x; }
  array_size= lmysql->ldbms_mp_decode_map(tarantool_tnt_reply_data) * 2;
  if (array_size != 4) { goto x; }
  field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
  if (field_type != MP_STR) { goto x; }
  value= lmysql->ldbms_mp_decode_str(tarantool_tnt_reply_data, &value_length);
  if (value_length != 8) { goto x; }
  field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
  if (field_type != MP_ARRAY) { goto x; }
  field_count= lmysql->ldbms_mp_decode_array(tarantool_tnt_reply_data);
  for (unsigned int field_no= 0; field_no < field_count; ++field_no)
  {
    field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
    if (field_type != MP_MAP) {  goto x; }
    array_size= lmysql->ldbms_mp_decode_map(tarantool_tnt_reply_data);
    if (array_size != 2) { goto x; }
    field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
    if (field_type != MP_STR) { goto x; }
    value= lmysql->ldbms_mp_decode_str(tarantool_tnt_reply_data, &value_length);
    if (value_length != 4) { goto x; }
    field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
    if (field_type != MP_STR) { goto x; }
    value= lmysql->ldbms_mp_decode_str(tarantool_tnt_reply_data, &value_length);
    if ((int)field_no == column_number)
    {
      *result_row_count= value_length;
      tarantool_tnt_reply_data_p=tarantool_tnt_reply_data_copy; /* pop */
      return value;
    }
    /* value = column name */
    value= lmysql->ldbms_mp_decode_str(tarantool_tnt_reply_data, &value_length);
    if (value_length != 4) { goto x; }
    field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
    if (field_type != MP_STR) { goto x; }
    value= lmysql->ldbms_mp_decode_str(tarantool_tnt_reply_data, &value_length);
    /* value = type e.g. 'integer' */
  }
  field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
  if (field_type != MP_STR) { goto x; }
  value= lmysql->ldbms_mp_decode_str(tarantool_tnt_reply_data, &value_length);
  if (value_length != 4) { goto x; }
  field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);

  if (field_type != MP_ARRAY) { goto x; }
  row_count= lmysql->ldbms_mp_decode_array(tarantool_tnt_reply_data);
  /* and now we are pointing to the first row */
  *result_row_count= row_count;
  if (column_number != -1) return NULL;

    new_tarantool_tnt_reply_data= *tarantool_tnt_reply_data;
  tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy; /* pop */

  return new_tarantool_tnt_reply_data;
x:  *result_row_count= 0;
  tarantool_tnt_reply_data_p=tarantool_tnt_reply_data_copy; /* pop */
  return 0;
}

/*
  Given tarantool_tnt_reply, return number of rows from a SELECT.
  Used by result grid.
*/
long unsigned int MainWindow::tarantool_num_rows(unsigned int connection_number)
{
  long unsigned int r;
  int result_set_type;
  tarantool_result_set_init(connection_number, &r, &result_set_type);
  return r;
}

/*
  Warning: do not say "delete [] request_string;" early, there
  might be a hidden pointer to it.

  TODO: Remove the giant kludge here. Instead of skipping nulls till
        we can return the first thing that's not null, we should
        "return ocelot_return0,ocelot_return1,..." and if there are
        2 or more result sets, then handle them with tabs the same way
        we do for MySQL/MariaDB.
*/

/*
  Execute a single SQL statement by calling Tarantool tnt_execute().
  Until 2020-09-23 we used to call Tarantool tnt_call("box.execute", ...).
  That worked but it required one more privilege, and Tarantool supports tnt_execute since version 2.1 (April 2019).
  For multiple SQL statements we call ocelot_sqle instead.
  This should be faster on the server because it does not make a local copy of the result.
  Also we get tarantool_errno, which ocelot_sqle does not deliver (hmm, it does, as part of message).
  Called by: rehash_scan().
  Called by: tarantool_real_query() if we see that it is SQL and not start of | part of a transaction.
  Todo:
    tarantool_execute_sql() previously did:
        tarantool_select_nosql= false;
        result_row_count= r;
    I am not sure whether something is still expecting that.
  Todo: This does not expect ? placeholders because Tarantool-C doesn't have tnt_prepare at this moment.
        When it does, we want to add something like (for one string parameter):
          lmysql->ldbms_tnt_object_add_array(tuple, 1);
          lmysql->ldbms_tnt_object_add_str(tuple, str, str_len);
*/
int MainWindow::tarantool_execute_sql(
        const char *dbms_query,
        unsigned int dbms_query_len,
        int connection_number)
{
  struct tnt_stream *tuple= lmysql->ldbms_tnt_object(NULL);
  lmysql->ldbms_tnt_object_reset(tuple); /* Todo: check if this is necessary. Doc is a bit unclear. */
  //tarantool_tnt_reply.data= NULL;
  //tarantool_tnt_reply.metadata= NULL;
  //tarantool_tnt_reply.error= NULL;
  /* TEST!!!! Let's not check, for the moment. */
  if (strcmp(tarantool_box_execute, "No SQL") == 0)
  {
    tarantool_errno[connection_number]= 9998;
    strcpy(tarantool_errmsg, "(Warning) Tarantool server won't accept SQL, only Lua");
    return tarantool_errno[connection_number];
  }
  /* TEST!!!! I want tarantool_tnt_connect, but am I better off without? */
  lmysql->ldbms_tnt_object_add_array(tuple, 0);
  lmysql->ldbms_tnt_execute(tnt[connection_number], dbms_query, dbms_query_len, tuple);
  //lmysql->ldbms_tnt_object_add_array(tuple, 1);
  //lmysql->ldbms_tnt_object_add_str(tuple, dbms_query, dbms_query_len);
  //lmysql->ldbms_tnt_call(tnt[connection_number], tarantool_box_execute, strlen(tarantool_box_execute), tuple);
  tarantool_flush_and_save_reply(connection_number);
  if (tarantool_errno[connection_number] != 0) return tarantool_errno[connection_number];
  return 0;
}

int MainWindow::tarantool_execute_lua(
        const char *dbms_query,
        unsigned int dbms_query_len,
        int connection_number)
{
  struct tnt_stream *tuple= lmysql->ldbms_tnt_object(NULL);
  lmysql->ldbms_tnt_object_reset(tuple); /* Todo: check if this is necessary. Doc is a bit unclear. */
  lmysql->ldbms_tnt_object_add_array(tuple, 0);
  lmysql->ldbms_tnt_eval(tnt[connection_number], dbms_query, dbms_query_len, tuple);
  tarantool_flush_and_save_reply(connection_number);
  if (tarantool_errno[connection_number] != 0)  return tarantool_errno[connection_number];
  return 0;
}

/*
  Select everything in a space.
  See description of tnt_select in third_party.h.
*/
int MainWindow::tarantool_execute_lua_select(int connection_number, int space_number)
{
  struct tnt_stream *tuple= lmysql->ldbms_tnt_object(NULL);
  lmysql->ldbms_tnt_object_reset(tuple); /* Todo: check if this is necessary. Doc is a bit unclear. */
  //tarantool_tnt_reply.data= NULL;
  //tarantool_tnt_reply.metadata= NULL;
  //tarantool_tnt_reply.error= NULL;
  lmysql->ldbms_tnt_object_add_array(tuple, 0);
  lmysql->ldbms_tnt_select(
                 tnt[connection_number], /* struct tnt_stream * s */
                 space_number,           /* uint32_t space no */
                 0,                      /* uint32_t index no */
                 UINT32_MAX,             /* uint32_t limit */
                 0,                      /* uint32_t offset */
                 TNT_ITER_ALL,          /* uint8_t iterator */
                 tuple);                 /* struct tnt_stream * key */
  tarantool_flush_and_save_reply(connection_number);
  if (tarantool_errno[connection_number] != 0)  return tarantool_errno[connection_number];
  return 0;
}

/*
  For LUA 'x x x', how on earth do I know if it returns a result set?
  As far as I can tell, I must know this in advance because for eval()
  I have to say 'return ' somewhere. Somehow the regular tarantool client
  figures this out, but I don't know the official method if there is one.
  My guess is based on the Lua keyword list ...
  If first word = and break do else elseif end for function if in local or repeat return then until while
  (But not: true nil false not)
  then do not add "return "
  else If the second token is: "="
  then do not add "return "
  else add "return "
  ... Eventually we should parse Lua and then we can get rid of this.
      Todo: now we do parse Lua, so consider how to get rid of this.
  TODO: Nothing calls this, we can get rid of it.
*/
QString MainWindow::tarantool_add_return(QString s)
{
  log("tarantool_add_return start", 80);
  int token_offsets[100]; /* Surely a single assignable target can't have more */
  int token_lengths[100];
  tokenize(s.data(),
           s.size(),
           &token_lengths[0], &token_offsets[0], 100 - 1,
          (QChar*)"33333", 2, "", 1);
  QString word_1= s.mid(token_offsets[0], token_lengths[0]);
  if ((word_1 == "and") || (word_1 == "break") || (word_1 == "do")
   || (word_1 == "else") || (word_1 == "elseif") || (word_1 == "end")
   || (word_1 == "for") || (word_1 == "function") || (word_1 == "if")
   || (word_1 == "in") || (word_1 == "local") || (word_1 == "or")
   || (word_1 == "repeat") || (word_1 == "return") || (word_1 == "then")
   || (word_1 == "until") || (word_1 == "while"))
    return s;
  QString word_2;
  for (int i= 1; i < 100 - 1; ++i)
  {
    word_2= s.mid(token_offsets[i], token_lengths[i]);
    if ((word_2 == "") || (word_2 == "(")) break;
    if (word_2 == "=") return s;
  }
  log("tarantool_add_return end", 80);
  return "return " + s;
}

/*
  Given tarantool_tnt_reply, return number of fields from a SELECT. Used by result grid.
  Actually there are two counts: the count of main fields, and the count of sub-fields.
  Todo: what if there are arrays within arrays?
  Todo: shouldn't map fields be arranged so new map value = new field?
  Due to flattening, field_count is count of scalars not count of arrays and maps.
  For example, array[2] X Y array[3] A B C has 5 scalars.
  Todo: Check is it ok to pass connection_number==0 to tarantool_result_set_init
*/
unsigned int MainWindow::tarantool_num_fields()
{
  const char *tarantool_tnt_reply_data_copy= tarantool_tnt_reply_data_p; /* push */
  const char **tarantool_tnt_reply_data= &tarantool_tnt_reply_data_p;
  char field_name[TARANTOOL_MAX_FIELD_NAME_LENGTH];
  unsigned int max_field_count;

  field_name_list_all_rows.clear();
  field_name_list_all_rows_count.clear();
  field_name_list_all_rows_address.clear();
  field_type_list_all_rows.clear();

  /* See tarantool_num_rows for pretty well the same code as this */
  /* Todo: this is wrong, connection_number might not be 0 */
  int result_set_type;
  *tarantool_tnt_reply_data= tarantool_result_set_init(0, &result_row_count, &result_set_type);
  if ((result_set_type == RESULT_TYPE_0) || (result_set_type == RESULT_TYPE_1))
  {
//    result_row_count= 0;
    return 0;
  }
//  if (result_set_type == RESULT_TYPE_2) result_row_count= 1;
//  else
//  {
//    if (result_set_type != RESULT_TYPE_4)
//    {
//      lmysql->ldbms_mp_decode_array(tarantool_tnt_reply_data);
//    }
//    result_row_count= lmysql->ldbms_mp_decode_array(tarantool_tnt_reply_data);
//  }
  if (result_set_type == RESULT_TYPE_5)
  {
    /* We no longer need to do anything because we don't need to skip a header row */
    //int bytes;
    //int row_size_1;
    //QString fetch_row_result= tarantool_fetch_row(*tarantool_tnt_reply_data, &bytes, &row_size_1);
    //if (fetch_row_result != "OK") return fetch_row_result;
    //*(tarantool_tnt_reply_data)+= bytes;
//    --result_row_count;
  }

  strcpy(field_name, TARANTOOL_FIELD_NAME_BASE);
  strcat(field_name, "_");

  for (long unsigned int r= 0; r < result_row_count; ++r)
  {
    int return_value= tarantool_num_fields_recursive(tarantool_tnt_reply_data,
                                                     field_name, 0,
                                                     &field_name_list_all_rows,
                                                     &field_name_list_all_rows_count,
                                                     &field_name_list_all_rows_address,
                                                     0);
    if (return_value < 0) assert(0 != 0);
  }

  /* Todo: If it's possible to have a column with field_name_list_count == 0, eliminate it here. */

  /* Field names must be in order. Temporarily change $s so most common map names have precedence. */
  field_name_list_all_rows.sort();

  max_field_count= field_name_list_all_rows.count();

  tarantool_field_names_count= max_field_count; /* tarantool_field_names_count is global */

  tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy; /* pop */

  return max_field_count;
}

/*
  tarantool_num_fields_recursive
  Called from: tarantool_scan_rows(), tarantool_num_fields(), tarantool_num_fields_recursive()
  Within a for-each-row loop, we call this with:
    Initial value of char **tarantool_tnt_reply_data is to start of row.
    Initial value of char *field_name is TARANTOOL_FIELD_NAME_BASE + "_" e.g. "f_"
    Initial value of field_number_within_array is 0 (maybe we should rename "i" in the loop)
    Initial value of QStringList field_name_list is clear (possibly clear() isn't necessary)
    Initial value of QList<int> field_name_list_count is clear
    Initial value of int field_name_upper is 0, it can be MP_MAP or (MP_ARRAY << 4) | MAP
  Inside this routine, we say:
    p_field_name_end points to after the last "_" in field_name.
    if (tarantool_tnt_reply_data is to a map or array)
      add (field number within array + 1) and "_" to field_name
      for each element in map or array
        recursive call!
    else i.e. if (tarantool_tnt_reply_data is to a scalar) skip
    add (array number + 1) to field_name
    if field name is not in field_name_list) add field_name to field_name_list
    Eventually we replace base name with defined field name, if there is one
  So this is a good place to check for maps (or arrays of maps):
    If (map) and (key type == string) and (key length not too great) and (value type is scalar)
    and (number of fields < too many) then the key will be a header.
    Todo: key type could be number, key length max could be less, number of fields could be more.
          the numbers plugged in here are arbitrary
    Todo: what if it is not the right result type?
    Todo: what if user prefers the old way (as if TARANTOOL_MAX_MAP_FIELDS == 0)?
    because the ambition is to have map keys as column headers where possible
    but we try to preserve the order of maps within an array
    So later we have to associate a key with a heading.
  Todo: we go through the rows and call this more than once, so speed up or call less often
        QHash or QMap or a tree or something that searches in a narrow range withthe same prefix
        or a binary search if it's the second loop after there's been a sort
  Todo: There might be a point to distinguishing MP_MAP size n from MP_ARRAY size n containing maps.
        In the former case you know it's all maps and maybe needn't worry about the order.
*/
/* If there are 64 or more fields, block creation of new headers from maps. Arbitrary. Must be divisible by 2. */
#define TARANTOOL_MAX_MAP_FIELDS 64
int MainWindow::tarantool_num_fields_recursive(const char **tarantool_tnt_reply_data,
                                               char *field_name,
                                               int field_number_within_array,
                                               QStringList *p_field_name_list,
                                               QList<int> *p_field_name_list_count,
                                               QList<char*> *p_field_name_list_address,
                                               int field_type_upper)
{
  bool is_scalar;
  int field_name_index;
  char field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
  if ((field_type == MP_NIL)
   || (field_type == MP_UINT)
   || (field_type == MP_INT)
   || (field_type == MP_STR)
   || (field_type == MP_BIN)
   || (field_type == MP_BOOL)
   || (field_type == MP_FLOAT)
   || (field_type == MP_DOUBLE)
   || (field_type == MP_EXT))
    is_scalar= true;
  else if ((field_type == MP_ARRAY) || (field_type == MP_MAP))
    is_scalar= false;
  else return -1;

  /* p_field_name_end, within field_name, = after last '_' or after TARANTOOL_FIELD_NAME_BASE */
  char *p_field_name_end;
  for (p_field_name_end= field_name + strlen(field_name);; --p_field_name_end)
  {
    if (*p_field_name_end == '_') break;
  }
  ++p_field_name_end;
  if (is_scalar == false)
  {
    uint32_t array_size;
    uint32_t field_type_to_pass;
    const char *tarantool_tnt_reply_data_before_decode= *tarantool_tnt_reply_data;
    if (field_type == MP_ARRAY)
    {
      field_type_to_pass= MP_ARRAY;
      array_size= lmysql->ldbms_mp_decode_array(tarantool_tnt_reply_data);
    }
    else
    {
      if (field_type_upper == MP_ARRAY) field_type_to_pass= (MP_ARRAY << 4) | MP_MAP;
      else field_type_to_pass= MP_MAP;
      array_size= lmysql->ldbms_mp_decode_map(tarantool_tnt_reply_data) * 2;
    }
    if (array_size == 0) *tarantool_tnt_reply_data= tarantool_tnt_reply_data_before_decode;
    if (array_size != 0)
    {
      sprintf(p_field_name_end, "%05d_", field_number_within_array + 1);
      for (uint32_t i= 0; i < array_size; ++i)
      {
        int return_value= tarantool_num_fields_recursive(tarantool_tnt_reply_data,
                                                         field_name,
                                                         i, p_field_name_list,
                                                         p_field_name_list_count,
                                                         p_field_name_list_address,
                                                         field_type_to_pass);
        if (return_value < 0) return return_value;
        i+= return_value; /* usually return_value == 0 but return_value == 1 iff we made a map field and skipped value */
      }
      p_field_name_end= field_name + strlen(field_name) - 1;
      while (*p_field_name_end != '_') --p_field_name_end;
      *(p_field_name_end - 1)= '\0';
      return 0;
    }
  }
  /* is_scalar == true or array size == 0 which we treat as null */
  if ((is_scalar == true)
   && ((field_type_upper == MP_MAP) || (field_type_upper == ((MP_ARRAY << 4) | MP_MAP)))
   && ((field_number_within_array % 2) == 0)
   && (lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data) == MP_STR))
  {
    const char *tarantool_tnt_reply_data_copy= *tarantool_tnt_reply_data;
    uint32_t key_length;
    const char *key;
    unsigned int field_name_length= strlen(field_name);
    key= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &key_length);
    if ((key_length + field_name_length + 2) < TARANTOOL_MAX_FIELD_NAME_LENGTH)
    {
      int value_field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy);
      if ((value_field_type != MP_ARRAY) && (value_field_type != MP_MAP))
      {
        char map_field_name[TARANTOOL_MAX_FIELD_NAME_LENGTH];
        /* Won't include map item number but will include array item number if we're in a map within an array */
        /* field_name_length -= 6; */
        memcpy(map_field_name, field_name, field_name_length);
        *(map_field_name + field_name_length - 1)= '_';
        memcpy(map_field_name + field_name_length, key, key_length);
        *(map_field_name + field_name_length + key_length)= '\0';
        int map_field_name_index= (*p_field_name_list).indexOf(map_field_name);
        if ((map_field_name_index != -1 || (*p_field_name_list).size() < TARANTOOL_MAX_MAP_FIELDS))
        {
          if (map_field_name_index == -1)
          {
            (*p_field_name_list).append(map_field_name);
            (*p_field_name_list_count).append(1);
            (*p_field_name_list_address).append((char*)tarantool_tnt_reply_data_copy);
          }
          else
          {
            (*p_field_name_list_count)[map_field_name_index]= (*p_field_name_list_count)[map_field_name_index] + 1;
            (*p_field_name_list_address)[map_field_name_index]= (char*)tarantool_tnt_reply_data_copy;
          }
          lmysql->ldbms_mp_next(tarantool_tnt_reply_data);
          lmysql->ldbms_mp_next(tarantool_tnt_reply_data);
          return 1;
        }
      }
    }
  }
  sprintf(p_field_name_end, "%05d", field_number_within_array + 1);
  field_name_index= (*p_field_name_list).indexOf(field_name);
  if (field_name_index == -1)
  {
    (*p_field_name_list).append(field_name);
    (*p_field_name_list_count).append(1);
    (*p_field_name_list_address).append((char*)*tarantool_tnt_reply_data);
  }
  else
  {
    (*p_field_name_list_count)[field_name_index]= (*p_field_name_list_count)[field_name_index] + 1;
    (*p_field_name_list_address)[field_name_index]= (char*)*tarantool_tnt_reply_data;
  }
  lmysql->ldbms_mp_next(tarantool_tnt_reply_data);
  return 0;
}

/* To "seek to row zero", start with the initial pointer and skip over the row count. */
/* Also skip field names if result_set_type == RESULT_TYPE_5. */
/* Todo: Check is it ok to pass connection_number==0 to tarantool_result_set_init */
/* TODO: Don't call this, it is useless. */
const char * MainWindow::tarantool_seek_0(int *returned_result_set_type)
{
  uint32_t row_count;
  const char *tarantool_tnt_reply_data;
  //tarantool_tnt_reply_data= tarantool_tnt_reply_data_p;

  long unsigned int tmp_row_count;
  int result_set_type;
  tarantool_tnt_reply_data= tarantool_result_set_init(0, &tmp_row_count, &result_set_type);
  row_count= tmp_row_count;
  if ((result_set_type == RESULT_TYPE_0) || (result_set_type == RESULT_TYPE_1))
  {
    assert(result_set_type > RESULT_TYPE_1);
  }
//  if (result_set_type == RESULT_TYPE_2) row_count= 1;
//  else
//  {
//    if (result_set_type != RESULT_TYPE_4)
//    {
//      lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
//    }
//    row_count= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
//  }
  if (result_set_type == RESULT_TYPE_5)
  {
    //int bytes;
    //int row_size_1;
    //QString fetch_row_result= tarantool_fetch_row(tarantool_tnt_reply_data, &bytes, &row_size_1);
    ////if (fetch_row_result != "OK") return fetch_row_result;
    //tarantool_tnt_reply_data+= bytes;
//    --row_count;
  }
#if defined(NDEBUG)
  if (row_count != result_row_count) {printf("assert(row_count == result_row_count);"); exit(1); }
#else
  assert(row_count == result_row_count);
#endif
  *returned_result_set_type= result_set_type;
  return tarantool_tnt_reply_data;
}

/*
  Originally this resembled mysql_fetch_row, till we realized we only want the total length.
  The traversal of fields must use the same system as in tarantool_scan_rows.
  The value of tarantool_tnt_reply_data increases, so at the end it points past row end.
  The calculation involves the actual amount that any non-missing field will take
  when sprintf'd to the row copy, but not the per-field overhead for all fields.
  todo: value_length is usually an unnecessary variable, just add to total_length
*/
QString MainWindow::tarantool_fetch_row(const char *tarantool_tnt_reply_data,
                                             int *bytes, int *tsize)
{
  const char *original_tarantool_tnt_reply_data= tarantool_tnt_reply_data;
  unsigned int total_length= 0;
  char field_type;
  field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data);
  if (field_type != MP_ARRAY) return "tarantool_fetch_row: field_type != MP_ARRAY";
  uint32_t field_count= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
  if (field_count == 0) return "tarantool_fetch_row: field_count == 0";

  for (uint32_t field_number= 0; field_number < field_count; ++field_number)
  {
    field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data);
    assert(field_type <= MP_EXT);
    uint32_t value_length;
    const char *value;
    (void) value; /* suppress 'variable set but not used' warning */
    char value_as_string[320]; /* must be big enough for any sprintf() result */
    if (field_type == MP_NIL)
    {
      lmysql->ldbms_mp_decode_nil(&tarantool_tnt_reply_data);
      value_length= 0;
    }
    if (field_type == MP_UINT)
    {
      uint64_t uint_value= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data);
      long long unsigned int llu= uint_value;
      value_length= sprintf(value_as_string, "%llu", llu);
    }
    if (field_type == MP_INT)
    {
      int64_t int_value= lmysql->ldbms_mp_decode_int(&tarantool_tnt_reply_data);
      long long int lli= int_value;
      value_length= sprintf(value_as_string, "%lld", lli);
    }
    if (field_type == MP_STR)
    {
      /* todo: allow for the library routine that only gets length */
      value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data, &value_length);
    }
    if (field_type == MP_BIN)
    {
      /* todo: allow for the library routine that only gets length */
      value= lmysql->ldbms_mp_decode_bin(&tarantool_tnt_reply_data, &value_length);
    }
    if (field_type == MP_ARRAY)
    {
      uint32_t array_size;
      array_size= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
      field_count+= array_size;
      value_length= 0;
    }
    if (field_type == MP_MAP)
    {
      uint32_t array_size;
      array_size= lmysql->ldbms_mp_decode_map(&tarantool_tnt_reply_data) * 2;
      field_count+= array_size;
      value_length= 0;
    }
    if (field_type == MP_BOOL)
    {
      bool bool_value= lmysql->ldbms_mp_decode_bool(&tarantool_tnt_reply_data);
      if (bool_value == 0) {value_length= 5; strcpy(value_as_string, "FALSE"); }
      else                 {value_length= 4; strcpy(value_as_string, "TRUE"); }
    }
    if (field_type == MP_FLOAT)
    {
      float float_value= lmysql->ldbms_mp_decode_float(&tarantool_tnt_reply_data);
      value_length= sprintf(value_as_string, "%f", float_value);
    }
    if (field_type == MP_DOUBLE)
    {
      double double_value= lmysql->ldbms_mp_decode_double(&tarantool_tnt_reply_data);
      value_length= sprintf(value_as_string, "%E", double_value);
    }
    if (field_type == MP_EXT)
    {
      value_length= tarantool_fetch_row_ext(tarantool_tnt_reply_data, value_as_string);
      lmysql->ldbms_mp_next(&tarantool_tnt_reply_data);
    }

    total_length+= value_length;
  }
  *bytes=   tarantool_tnt_reply_data - original_tarantool_tnt_reply_data;
  if (*bytes <= 0) return "tarantool_fetch_row: *bytes <= 0";
  *tsize= total_length;
  return "OK";
}

/*
  called from tarantool_fetch_row() and from tarantool_scan_rows()
  MP_EXT requires a lot of special handling because it might be MP_DECIMAL or MP_UUID or MP_ERROR.
  We brought in the older msgpuck.h which doesn't have mp_decode_ext.
  Re possible errors:
      For all types, we return "EXT" and length = 3. It will be skipped because caller lmysql->ldbms_mp_next(&tarantool_tnt_reply_data);
      Error if: ext 16 and ext 32, which would not be possible for decimal, but might be allowed someday
      Error if: not equal to MP_DECIMAL = 1: MP_UNKNOWN_EXTENSION = 0, MP_UUID = 2, MP_ERROR = 3.
      We do not check for premature end of input (we rarely do), so really bad input could cause segmentation fault
  Re decimal:
      Beware negative scale which means add 0s at end.
  Re uuid:
      I assume that length = 16 and I do not check that the MP_EXT byte was d8.
      I produce a string that does not contain any "-"s.
  todo: we could distinguish non-decimal sub-types rather than return "EXT" for everything
  todo: for perfect lining up, we could keep track of maximum scale not just maximum length
*/
#define MP_DECIMAL 1
#define MP_UUID 2
#define MP_ERROR 3
#define MP_ERROR_STACK 0x00
#define MP_ERROR_TYPE 0
#define MP_ERROR_FILE 1
#define MP_ERROR_LINE 2
#define MP_ERROR_MESSAGE 3
#define MP_ERROR_ERRNO 4
#define MP_ERROR_CODE 5
#define MP_ERROR_FIELDS 6

int MainWindow::tarantool_fetch_row_ext(const char *tarantool_tnt_reply_data,
                                            char *value_as_string)
{
  const char *next_tarantool_tnt_reply_data;
  unsigned char ext_field_type;
  next_tarantool_tnt_reply_data= tarantool_tnt_reply_data;
  lmysql->ldbms_mp_next(&next_tarantool_tnt_reply_data);
  unsigned char mp_ext_byte= *tarantool_tnt_reply_data;
  /* int l= 0; */
  if (mp_ext_byte == 0xd4) { /* l= 1; */ tarantool_tnt_reply_data+= 1; }
  else if (mp_ext_byte == 0xd5) { /* l= 2; */ tarantool_tnt_reply_data+= 1; }
  else if (mp_ext_byte == 0xd6) { /* l= 4; */ tarantool_tnt_reply_data+= 1; }
  else if (mp_ext_byte == 0xd7) { /* l= 8; */ tarantool_tnt_reply_data+= 1; }
  else if (mp_ext_byte == 0xd8) { /* l= 16; */ tarantool_tnt_reply_data+= 1; }
  else if (mp_ext_byte == 0xc7) { /* l= *(tarantool_tnt_reply_data + 1); */ tarantool_tnt_reply_data+= 2; }
  else {strcpy(value_as_string, "EXT"); return 3; }
  ext_field_type= *tarantool_tnt_reply_data;
  ++tarantool_tnt_reply_data;
  if (ext_field_type == MP_DECIMAL)
  {
    signed char scale= *tarantool_tnt_reply_data;
    ++tarantool_tnt_reply_data;
    if (scale == -48) /* i.e. 0xd0 = MessagePack for "int 8", only happens for big numbers e.g. 1e35 */
    {
      scale= *tarantool_tnt_reply_data;
      ++tarantool_tnt_reply_data;
    }
    unsigned char high_nibble, low_nibble;
    unsigned char decimal_output[64];
    unsigned char *decimal_output_pointer= &decimal_output[0];
    unsigned char sign= '+';
    while (tarantool_tnt_reply_data < next_tarantool_tnt_reply_data)
    {
      unsigned char ch= (unsigned char) *tarantool_tnt_reply_data;
      high_nibble= (ch >> 4);
      if ((high_nibble != 0) || (decimal_output_pointer != &decimal_output[0]))
      {
        *decimal_output_pointer= high_nibble + 0x30;
        ++decimal_output_pointer;
      }
      low_nibble= (ch & 0xf);
      if ((low_nibble == 10) || (low_nibble == 12) || (low_nibble == 14) || (low_nibble == 15)) sign= '+';
      else if ((low_nibble == 11) || (low_nibble == 13)) sign= '-';
      else
      {
        *decimal_output_pointer= low_nibble + 0x30;
        ++decimal_output_pointer;
      }
      ++tarantool_tnt_reply_data;
    }
    int decimal_output_length= decimal_output_pointer - &decimal_output[0];
    char *o= value_as_string;
    if (sign == '-') { *o= sign; ++o; }
    if ((scale == 0) && (decimal_output_length == 0))
    {
      *o= '0';
      ++o;
    }
    else if (scale == 0)
    {
      memcpy(o, decimal_output, decimal_output_length);
      o+= decimal_output_length;
    }
    else if (scale >= decimal_output_length)
    {
      *o= '0'; ++o; /* Actually I prefer '.1' not '0.1' but '0.1' is what Tarantool client produces */
      *o= '.'; ++o;
      memset(o, '0', scale - decimal_output_length);
      o+= scale - decimal_output_length;
      memcpy(o, decimal_output, decimal_output_length);
      o+= decimal_output_length;
    }
    else
    {
      if (scale < 0)
      {
        int additional_zeros= 0 - scale;
        memcpy(o, decimal_output, decimal_output_length);
        o+= decimal_output_length;
        memset(o, '0', additional_zeros);
        o+= additional_zeros;
      }
      else
      {
        memcpy(o, decimal_output, decimal_output_length - scale);
        o+= decimal_output_length - scale;
        *o= '.'; ++o;
        memcpy(o, decimal_output + (decimal_output_length - scale), scale);
        o+= scale;
      }
    }
    return o - value_as_string;
  }
  else if (ext_field_type == MP_UUID)
  {
    char *o= value_as_string;
    unsigned char ch, high_nibble, low_nibble;
    for (int i= 0; i < 16; ++i)
    {
      ch= (unsigned char) *tarantool_tnt_reply_data;
      if ((i == 4) || (i == 6) || (i == 8) || (i == 10)) *(o++)= '-';
      high_nibble= (ch >> 4);
      if (high_nibble < 10) high_nibble+= 0x30; else high_nibble+= 0x61 - 10;
      *(o++)= high_nibble;
      low_nibble= (ch &0xf);
      if (low_nibble < 10) low_nibble+= 0x30; else low_nibble+= 0x61 - 10;
      *(o++)= low_nibble;
      ++tarantool_tnt_reply_data;
    }
    return o - value_as_string;
  }
  else if (ext_field_type == MP_ERROR)
  {
    unsigned char mp_ext_error_byte= *(tarantool_tnt_reply_data++);
    if (mp_ext_error_byte == MP_ERROR_STACK) printf("*** MP_ERROR_STACK\n");

    unsigned char mp_ext_error_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data);
    if (mp_ext_error_type == MP_ARRAY)
    {
      int mp_ext_array_size= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
      printf("  array size = %d\n", mp_ext_array_size);
      for (int i= 0; i < mp_ext_array_size; ++i)
      {
        unsigned char mp_ext_map_type= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
        if (mp_ext_map_type == MP_ERROR_TYPE)
        {
          printf("MP_ERROR_TYPE\n");
        }
        if (mp_ext_map_type == MP_ERROR_FILE)
        {
          printf("MP_ERROR_FILE\n");
        }
        if (mp_ext_map_type == MP_ERROR_LINE)
        {
          printf("MP_ERROR_LINE\n");
        }
        if (mp_ext_map_type == MP_ERROR_MESSAGE)
        {
          printf("MP_ERROR_MESSAGE\n");
        }
        if (mp_ext_map_type == MP_ERROR_ERRNO)
        {
          printf("MP_ERROR_ERRNO\n");
        }
        if (mp_ext_map_type == MP_ERROR_CODE)
        {
          printf("MP_ERROR_CODE\n");
        }
        if (mp_ext_map_type == MP_ERROR_FIELDS)
        {
          printf("MP_ERROR_FIELDS\n");
        }
        lmysql->ldbms_mp_next(&tarantool_tnt_reply_data);
      }
    }
    exit(0);
  }
  else
  {
    ; /* Not decimal or uuid or error. Some sort of error. */
  }
  strcpy(value_as_string, "EXT");
  return 3;
}

/*
  This is for result_set_type == RESULT_TYPE_5, where row#1 should actually
  be the header i.e. the field names. Ultimately it might be from the format.
  Skip the dd 00 00 00 01 and the row count.
  Skip the first field which is the a1 08 signature.
  For each header field
   replacing "f_n" section, i.e. as far as the second "_", if any.
   replacing "f_1..." with name#1..., "f_2..." with name#2..., etc.
  Todo: finding "f_n" is inefficient, memcmp etc. should be avoided.
  Todo: Check is it ok to pass connection_number==0 to tarantool_result_set_init
  THIS IS ALL GONE NOW.
*/
QString MainWindow::tarantool_fetch_header_row()
{
  uint32_t value_length;
  const char *value;

  int base_length= strlen(TARANTOOL_FIELD_NAME_BASE);
  char *flags= new char[tarantool_field_names_count];
  memset(flags, 0, tarantool_field_names_count);

  for (uint32_t field_number= 0; ;++field_number)
  {
    long unsigned int r;
    value= tarantool_result_set_init_select(&r, field_number, 0);
    if (value == NULL) break; /* no more columns? */
    if (r >= TARANTOOL_MAX_FIELD_NAME_LENGTH) goto error_return;
    value_length= r;
    char what_to_set_to[TARANTOOL_MAX_FIELD_NAME_LENGTH * 2];
    memcpy(what_to_set_to, value, value_length); /* This is what we set to */
    *(what_to_set_to + value_length)= '\0';
    char what_to_search_for[TARANTOOL_MAX_FIELD_NAME_LENGTH];
    memcpy(what_to_search_for, TARANTOOL_FIELD_NAME_BASE, base_length);
    //char field_number_as_char[16];
    sprintf(what_to_search_for, "%s_%d", TARANTOOL_FIELD_NAME_BASE, field_number + 1);
    int what_to_search_for_length= strlen(what_to_search_for);
    for (unsigned int j= 0; j < tarantool_field_names_count; ++j)
    {
      if (*(flags + j) > 0)
      {
        continue;
      }
      char tmp[TARANTOOL_MAX_FIELD_NAME_LENGTH * 2];
      QString s= field_name_list_all_rows.at(j);
      strcpy(tmp, s.toUtf8().data());
      char *what= &tmp[0];
      int memcmp_result= memcmp(what_to_search_for, what, what_to_search_for_length);
      if (memcmp_result < 0) break; /* what_to_search_for < what */
      if (memcmp_result > 0) continue; /* what to search for > what */

      char char_after_what= *(what + what_to_search_for_length);
      if ((char_after_what == 0) || (char_after_what == '_'))
      {
        *(flags + j)= 1;
        char new_name[TARANTOOL_MAX_FIELD_NAME_LENGTH * 2];
        memset(new_name, 0, TARANTOOL_MAX_FIELD_NAME_LENGTH);
        memcpy(new_name, value, value_length);
        memcpy(new_name + value_length, what + what_to_search_for_length, TARANTOOL_MAX_FIELD_NAME_LENGTH - what_to_search_for_length);
        *(new_name + TARANTOOL_MAX_FIELD_NAME_LENGTH)='\0';
        memcpy(what, new_name, TARANTOOL_MAX_FIELD_NAME_LENGTH);
      }
      field_name_list_all_rows[j]= what;
      value= tarantool_result_set_init_select(&r, field_number, 1);
      value_length= r;
      if (value == NULL) {;} /* I don't know whether we should care about null */
      /* Todo: Some field types here are wrong, and we don't have all possible types here. */
      if ((value_length == 7) && (memcmp(value, "integer", 7) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_INTEGER;
      if ((value_length == 6) && (memcmp(value, "string", 6) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_VAR_STRING;
      if ((value_length == 3) && (memcmp(value, "map", 3) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_MAP;
      if ((value_length == 5) && (memcmp(value, "array", 5) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_ARRAY;
      if ((value_length == 8) && (memcmp(value, "unsigned", 8) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_UNSIGNED;
      if ((value_length == 9) && (memcmp(value, "varbinary", 9) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_VARBINARY;
      if ((value_length == 7) && (memcmp(value, "boolean", 7) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_BOOLEAN;
      if ((value_length == 6) && (memcmp(value, "number", 6) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_DOUBLE;
      if ((value_length == 6) && (memcmp(value, "scalar", 6) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_SCALAR;
      if ((value_length == 6) && (memcmp(value, "double", 6) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_DOUBLE;
    }
  }
  delete []flags;
  return "OK";
error_return:
  delete []flags;
  return "Field name too long";
}


/*
  Given tarantool_tnt_reply, fill in field names + types + max widths.
  Return amount that we would need for allocating.
  Called from: scan_rows in result grid.
  Compare: what we do for first loop in scan_rows().
  Todo: Wonder: any advantage to having more precise field_value_flags since we know MP_UINT etc.?
  Todo: possible speed improvements
        field_name_list lookup via QHash, or via QMap, or binary search, or search only where prefix matches
        do not bother with tarantool_fetch_row, you could figure out allocation size in tarantool_num_fields (?)
        header-row heroism can end, you will just keep the main field name list until tarantool_scan_rows ends
*/
QString MainWindow::tarantool_scan_rows(unsigned int p_result_column_count,
               unsigned int p_result_row_count,
               MYSQL_RES *p_mysql_res,
               char **p_result_set_copy,
               char ***p_result_set_copy_rows,
               unsigned int **p_result_max_column_widths)
{
  (void) p_mysql_res; /* suppress "unused parameter" warning */
  unsigned long int v_r;
  //unsigned int i;
  int returned_result_set_type;
  const char *tarantool_tnt_reply_data_copy;

  /* Todo: all_rows_address could be done with new or malloc but we have early 'return' statements. */
  QList<char*> field_name_list_all_rows_address;
  for (int i= 0; i < field_name_list_all_rows.count(); ++i) field_name_list_all_rows_address.append(NULL);

  assert(p_result_column_count == tarantool_field_names_count); /* does this make sense? */

  ResultGrid *rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));

  /* TODO: The first loop is not necessary because we have data from tarantool_num_fields_recursive()? */
  /* TODO: Are you sure it's enough to use tarantool_field_names_count not p_result_column_count? */

  for (unsigned int i= 0; i < p_result_column_count; ++i) (*p_result_max_column_widths)[i]= 0;
  /*
    First loop: find how much to allocate. Allocate. Second loop: fill in with pointers within allocated area.
  */
  unsigned int total_size= 0;
  char *result_set_copy_pointer;
  tarantool_tnt_reply_data_copy= tarantool_seek_0(&returned_result_set_type); /* "seek to row 0" */
  for (v_r= 0; v_r < p_result_row_count; ++v_r)                                /* first loop */
  {
    int bytes;
    int row_size_1;
    QString fetch_row_result= tarantool_fetch_row(tarantool_tnt_reply_data_copy, &bytes, &row_size_1);
    if (fetch_row_result != "OK") return fetch_row_result;
    tarantool_tnt_reply_data_copy+= bytes;
    total_size+= row_size_1;
    /* per-field overhead includes overhead for missing fields; they are null */
    int row_size_2= tarantool_field_names_count * (sizeof(unsigned int) + sizeof(char) + TARANTOOL_MAX_FIELD_NAME_LENGTH);
    total_size+= row_size_2;
  }

  if (total_size > 2000000000) return ": total_size too big";
  *p_result_set_copy= new char[total_size];                                         /* allocate */
  *p_result_set_copy_rows= new char*[p_result_row_count];
  result_set_copy_pointer= *p_result_set_copy;
  tarantool_tnt_reply_data_copy= tarantool_seek_0(&returned_result_set_type); /* "seek to row 0" */
  const char **tarantool_tnt_reply_data= &tarantool_tnt_reply_data_copy;

  /*
    If we found a name when we went through all the rows during tarantool_num_fields,
    then surely we will find it when we look a a single row.
    Therefore this pass will not add to the field name list, but will set addresses.
    That is: For each field in list of current row, we will mark as non-null in list of all rows.
  */
  for (v_r= 0; v_r < p_result_row_count; ++v_r)                                 /* second loop */
  {
    (*p_result_set_copy_rows)[v_r]= result_set_copy_pointer;
    //char *tmp_copy_pointer= result_set_copy_pointer;
    /* Form a field name list the same way you did in tarantool_num_fields */
    /* Initialize all addresses */
    for (int i= 0; i < field_name_list_all_rows.count(); ++i) field_name_list_all_rows_address[i]= NULL;
    {
      char field_name[TARANTOOL_MAX_FIELD_NAME_LENGTH];
      strcpy(field_name, TARANTOOL_FIELD_NAME_BASE);
      strcat(field_name, "_");

      int return_value= tarantool_num_fields_recursive(tarantool_tnt_reply_data,
                                                       field_name, 0,
                                                       &field_name_list_all_rows,
                                                       &field_name_list_all_rows_count,
                                                       &field_name_list_all_rows_address,
                                                       0);

      if (return_value < 0) return "tarantool_scan_rows: return_value < 0";
      //tarantool_tnt_reply_data_copy_end= tarantool_tnt_reply_data_copy;
    }

    /*
      At this point, field_name_list_all_rows* stuff has:
      field_name = name still as base name + numbers e.g. e.g. f_00001_00001,
      address = NULL or something we can mp_decode.
    */

    for (int i= 0; i < field_name_list_all_rows.count(); ++i) /* second field loop */
    {
      unsigned char field_type;
      const char *all_rows_address= field_name_list_all_rows_address[i];

      if (all_rows_address == 0) field_type= MP_NIL;
      else field_type= lmysql->ldbms_mp_typeof(*all_rows_address);

      if (field_type > MP_EXT) return "tarantool_scan_rows: field_type > MP_EXT";

      if ((field_type == MP_NIL) || (field_type == MP_ARRAY) || (field_type == MP_MAP))
      {
        /* Assumption: if MP_ARRAY or MP_MAP, size = 0. */
        if (sizeof(NULL_STRING) - 1 > (*p_result_max_column_widths)[i]) (*p_result_max_column_widths)[i]= sizeof(NULL_STRING) - 1;
        if (all_rows_address != 0) lmysql->ldbms_mp_next(&all_rows_address);
        memset(result_set_copy_pointer, 0, sizeof(unsigned int));
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_NULL;
        result_set_copy_pointer+= sizeof(unsigned int) + sizeof(char);
        continue;
      }
      const char *value;
      uint32_t value_length;
      char value_as_string[TARANTOOL_MAX_FIELD_NAME_LENGTH * 2]; /* must be big enough for any sprintf() result */
      if (field_type == MP_UINT)
      {
        uint64_t uint_value= lmysql->ldbms_mp_decode_uint(&all_rows_address);
        long long unsigned int llu= uint_value;
        value_length= sprintf(value_as_string, "%llu", llu);
        value= value_as_string;
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_NUMBER;
      }
      else if (field_type == MP_INT)
      {
        int64_t int_value= lmysql->ldbms_mp_decode_int(&all_rows_address);
        long long int lli= int_value;
        value_length= sprintf(value_as_string, "%lld", lli);
        value= value_as_string;
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_NUMBER;
      }
      else if (field_type == MP_STR)
      {
        value= lmysql->ldbms_mp_decode_str(&all_rows_address, &value_length);
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_STRING;
      }
      else if (field_type == MP_BIN)
      {
        value= lmysql->ldbms_mp_decode_bin(&all_rows_address, &value_length);
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_STRING;
      }
      else if (field_type == MP_BOOL)
      {
        bool bool_value= lmysql->ldbms_mp_decode_bool(&all_rows_address);
        if (bool_value == 0) {value_length= 5; strcpy(value_as_string, "FALSE"); }
        else                 {value_length= 4; strcpy(value_as_string, "TRUE"); }
        value= value_as_string;
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_OTHER;
      }
      else if (field_type == MP_FLOAT)
      {
        float float_value= lmysql->ldbms_mp_decode_float(&all_rows_address);
        value_length= sprintf(value_as_string, "%f", float_value);
        value= value_as_string;
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_NUMBER;
      }
      else if (field_type == MP_DOUBLE)
      {
        double double_value= lmysql->ldbms_mp_decode_double(&all_rows_address);
        value_length= sprintf(value_as_string, "%E", double_value);
        value= value_as_string;
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_NUMBER;
      }
      else if (field_type == MP_EXT)
      {
        value_length= tarantool_fetch_row_ext(all_rows_address, value_as_string);
        value= value_as_string;
        lmysql->ldbms_mp_next(&all_rows_address);
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_NUMBER;
      }
      else
      {
        /* it probably would be proper to assert() here */
        value_length= 0;
        value= "";
      }
      //if (value_length > (*p_result_max_column_widths)[i]) (*p_result_max_column_widths)[i]= value_length;
      rg->set_max_column_width(value_length, value, (&(*p_result_max_column_widths)[i]));
      memcpy(result_set_copy_pointer, &value_length, sizeof(unsigned int));
      result_set_copy_pointer+= sizeof(unsigned int) + sizeof(char);
      memcpy(result_set_copy_pointer, value, value_length);
      result_set_copy_pointer+= value_length;
    }
    /* I think tarantool_tnt_reply_data_copy should be pointing to next row after tarantool_num_fields_recursive */
  }
  /* Now that names are sorted, we can shorten them e.g. f_0001_0007_0001_0001 becomes f_7_1_1. */
  for (int i= 0; i < field_name_list_all_rows.count(); ++i)
  {
    char tmp[TARANTOOL_MAX_FIELD_NAME_LENGTH];
    QString s= field_name_list_all_rows.at(i);
    strcpy(tmp, s.toUtf8().data());
    char *c= &tmp[0];
    for (unsigned int j= strlen(TARANTOOL_FIELD_NAME_BASE); *(c + j) != '\0'; ++j)
    {
      if ((*(c + j) == '0') && (*(c + j - 1) == '_'))
      {
        unsigned int k;
        for (k= j + 1; *(c + k) != '\0'; ++k) *(c + k - 1)= *(c + k);
        *(c + k - 1)= '\0';
        --j;
      }
    }
    unsigned int j= strlen(TARANTOOL_FIELD_NAME_BASE);
    if ((*(c + j) == '_') && (*(c + j + 1) == '1'))
    {
      unsigned int k;
      for (k= j + 2; *(c + k) != '\0'; ++k) *(c + k - 2)= *(c + k);
      *(c + k - 2)= '\0';
    }
    field_name_list_all_rows[i]= tmp;
  }
  for (int i= 0; i < field_name_list_all_rows.count(); ++i) field_type_list_all_rows.insert(i, OCELOT_DATA_TYPE_VAR_STRING);

  /* Replace result-set arbitrary names with names from format strings */
  /* Replace result-set guessed types with types from format strings */
  if (returned_result_set_type == RESULT_TYPE_5)
  {
    QString fetch_header_row_result= tarantool_fetch_header_row();
    if (fetch_header_row_result != "OK") return fetch_header_row_result;
  }

  return "OK";
}


/*
  Re is_for_display:
  MySQL tells us "org_name" and "org_table" with the result set, but Tarantool doesn't.
  If you're coming from action_execute_one_statement() which called
  execute_real_query()+tarantool_real_query() before calling fillup() which called here, then
  you know that tarantool_real_query() happened and left you a table name and column names,
  which it figured out from the query.

  Todo: check: in tarantool_scan_field_names(), should I use
        sizeof(TARANTOOL_FIELD_NAME_BASE) or strlen(TARANTOOL_FIELD_NAME_BASE)?
*/

QString MainWindow::tarantool_scan_field_names(
               const char *which_field,

        unsigned int p_result_column_count,
               char **p_result_field_names,
        bool is_for_display)
{
  char tmp_table_name[128*3]; /* I hope this is safe, I discourage long-table-name nonsense. */

  if (is_for_display == true) strcpy(tmp_table_name, tarantool_table_name.toUtf8());
  else strcpy(tmp_table_name, "");

  unsigned int i;
  unsigned int v_lengths;
  /*
    First loop: find how much to allocate. Allocate. Second loop: fill in with pointers within allocated area.
  */
  unsigned int total_size= 0;
  char *result_field_names_pointer;

  for (i= 0; i < p_result_column_count; ++i)                                /* first loop */
  {
    total_size+= sizeof(unsigned int);
    if (strcmp(which_field, "name") == 0) total_size+= field_name_list_all_rows.at(i).length();
    else if (strcmp(which_field, "org_name") == 0) total_size+= field_name_list_all_rows.at(i).length();
    else if (strcmp(which_field, "org_table") == 0) total_size+= strlen(tmp_table_name);
    else /* if (strcmp(which_field, "db") == 0) */ total_size+= sizeof(TARANTOOL_FIELD_NAME_BASE);
  }
  *p_result_field_names= new char[total_size];                               /* allocate */

  result_field_names_pointer= *p_result_field_names;
  for (i= 0; i < p_result_column_count; ++i)                                 /* second loop */
  {
    if (strcmp(which_field, "name") == 0) v_lengths= field_name_list_all_rows.at(i).length();
    else if (strcmp(which_field, "org_name") == 0) v_lengths= field_name_list_all_rows.at(i).length();
    else if (strcmp(which_field, "org_table") == 0) v_lengths= strlen(tmp_table_name);
    else /* if (strcmp(which_field, "db") == 0) */ v_lengths= sizeof(TARANTOOL_FIELD_NAME_BASE);
    memcpy(result_field_names_pointer, &v_lengths, sizeof(unsigned int));
    if (v_lengths >= TARANTOOL_MAX_FIELD_NAME_LENGTH) return "Field Name Too Long";
    result_field_names_pointer+= sizeof(unsigned int);
    char tmp_field_name[TARANTOOL_MAX_FIELD_NAME_LENGTH * 2];
    QString s= field_name_list_all_rows.at(i);
    strcpy(tmp_field_name, s.toUtf8().data());
    if (strcmp(which_field, "name") == 0) memcpy(result_field_names_pointer, tmp_field_name, v_lengths);
    else if (strcmp(which_field, "org_name") == 0) memcpy(result_field_names_pointer, tmp_field_name, v_lengths);
    else if (strcmp(which_field, "org_table") == 0) memcpy(result_field_names_pointer, tmp_table_name, v_lengths);
    else /* if (strcmp(which_field, "db") == 0) */ memcpy(result_field_names_pointer, TARANTOOL_FIELD_NAME_BASE, v_lengths);
    result_field_names_pointer+= v_lengths;
  }
  return "OK";
}

//void MainWindow::tarantool_close()
//{
//lmysql->ldbms_tnt_close(tnt);
//lmysql->ldbms_tnt_stream_free(tuple);
//lmysql->ldbms_tnt_stream_free(tnt);
//}

#endif

#ifdef DBMS_TARANTOOL
/*
  Handle CREATE [TEMPORARY] TABLE table-name SERVER server-name
   {LUA 'expression'} | {RETURN lua-expression};
  We want to exeute the lua-expression on the remote server created
  with CREATE SERVER. This is going to be complicated.
  The 'expression' must cause return a result set.
  Do a fillup.
  From the result set, we can figure out field names and types.
  So that tells us how to CREATE TABLE table-name (...) on main.
  Then we can INSERT INTO table-name VALUES (result-set values);
  Todo: There are other things we could do, e.g. SELECT from remote.
  Todo: It would be better to check for LUA|RETURN when parsing.
*/
int MainWindow::create_table_server(QString text,
                                         bool *is_create_table_server,
                                         unsigned int passed_main_token_number,
                                         unsigned int passed_main_token_count_in_statement)
{
  *is_create_table_server= false;
  /* Quick search -- if there is no SERVER id clause, get out now. */

  bool is_create= false;
  unsigned int i_of_table= 0;
  unsigned int i_of_server= 0;
  unsigned int i_of_server_id= 0;
  unsigned int i_of_literal= 0;
  unsigned int i_of_lua= 0;
  unsigned int i_of_return= 0;
  for (unsigned int i= passed_main_token_number; i < passed_main_token_number + passed_main_token_count_in_statement; ++i)
  {
    if ((main_token_types[i] >= TOKEN_TYPE_COMMENT_WITH_SLASH)
     && (main_token_types[i] <= TOKEN_TYPE_COMMENT_WITH_MINUS))
      continue;
    if (main_token_types[i] == TOKEN_KEYWORD_CREATE)
    {
      is_create= true;
    }
    if (is_create == false) break;
    if (main_token_types[i] == TOKEN_KEYWORD_TABLE)
    {
      i_of_table= i;
    }
    if ((main_token_types[i] == TOKEN_KEYWORD_SERVER)
     && (i_of_table > 0))
    {
      i_of_server= i;
    }
    if (i_of_server > 0)
    {
      if (main_token_reftypes[i] == TOKEN_REFTYPE_SERVER)
      {
        i_of_server_id= i;
      }
      if (main_token_types[i] == TOKEN_KEYWORD_LUA)
      {
        i_of_lua= i;
      }
      if (main_token_types[i] == TOKEN_KEYWORD_RETURN)
      {
        i_of_return= i;
      }
      if ((main_token_types[i] <= TOKEN_TYPE_LITERAL)
       && (main_token_types[i] >= TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE))
      {
        i_of_literal= i;
      }
    }
  }

  if (i_of_server == 0) return 0;

  *is_create_table_server= true;

  if (tarantool_server_name == "")
  {
    /* "CREATE TABLE ... SERVER fails, CREATE SERVER not done?" */
    make_and_put_message_in_result(ER_CREATE_SERVER, 0, (char*)"");
    return 1;
  }
  {
    QString s;
    if (i_of_server_id == 0) s= "";
    else s= text.mid(main_token_offsets[i_of_server_id], main_token_lengths[i_of_server_id]);
    if (QString::compare(s, tarantool_server_name, Qt::CaseSensitive) != 0)
    {
      /* "CREATE TABLE ... SERVER fails, server id <> CREATE SERVER id\n" */
    make_and_put_message_in_result(ER_CREATE_SERVER, 0, (char*)"");
    return 1;
    }
  }

  if ((i_of_literal == 0) && (i_of_lua != 0))
  {
    /* "CREATE TABLE ... SERVER fails, blank literal\n" */
    make_and_put_message_in_result(ER_EMPTY_LITERAL, 0, (char*)"");
    return 1;
  }

  /* Todo: There should be a separate error message for this ... */
  if (i_of_server_id == 0)
  {
    /* "CREATE TABLE ... SERVER fails, blank literal\n" */
    make_and_put_message_in_result(ER_EMPTY_LITERAL, 0, (char*)"");
    return 1;
  }

  /* Todo: There should be a separate error message for this ... */
  if ((i_of_lua == 0) && (i_of_return == 0))
  {
    /* "CREATE TABLE ... SERVER fails, blank literal\n" */
    make_and_put_message_in_result(ER_EMPTY_LITERAL, 0, (char*)"");
    return 1;
  }

  QString q;
  unsigned int new_passed_main_token_number;
  unsigned int new_passed_main_token_count_in_statement;
  if (i_of_lua == 0)
  {
    unsigned int m= passed_main_token_number + passed_main_token_count_in_statement;
    q= text.mid(main_token_offsets[i_of_return],
                main_token_offsets[m - 1] + main_token_lengths[m - 1] - main_token_offsets[i_of_return]);
    new_passed_main_token_number= i_of_server_id + 1;
    new_passed_main_token_count_in_statement= passed_main_token_count_in_statement - (i_of_return);
  }
  else
  {
    q= text.mid(main_token_offsets[i_of_lua],
                main_token_offsets[i_of_literal] + main_token_lengths[i_of_literal] - main_token_offsets[i_of_lua]);
    new_passed_main_token_number= i_of_lua;
    /* Todo: Check: why i_of_literal? */
    new_passed_main_token_count_in_statement= i_of_literal;
  }
  QString read_format_result= tarantool_read_format(q);
  int result;
  ResultGrid *rg= new ResultGrid(lmysql, this, false, 0);
  for (;;)
  {
    result=
    tarantool_real_query(q.toUtf8(),
                         q.toUtf8().size(),
                         MYSQL_REMOTE_CONNECTION,
                         new_passed_main_token_number,
                         new_passed_main_token_count_in_statement,
                         &q);
    if (result != 0)
    {
      put_diagnostics_in_result(MYSQL_REMOTE_CONNECTION);
      break;
    }
    /* CREATE TABLE y4 SERVER id LUA 'box.space._space:select()'; crashed */
    {
      long unsigned int r;
      int result_set_type;
      tarantool_result_set_init(MYSQL_REMOTE_CONNECTION, &r, &result_set_type);
      if ((result_set_type) == RESULT_TYPE_0 || (result_set_type == RESULT_TYPE_1))
      {
        tarantool_errno[MYSQL_MAIN_CONNECTION]= 9999;
        result= 9999;
        strcpy(tarantool_errmsg, "No result set");
        put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
        break;
      }
      if (r == 0)
      {
        tarantool_errno[MYSQL_MAIN_CONNECTION]= 9999;
        result= 9999;
        strcpy(tarantool_errmsg, "Empty result set");
        put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
        break;
      }
    }

    /* TODO: I'd be much happier if we didn't fool with existing result copy (NOW THAT IS A BUG!!!) */
    /* TODO: Check for an error return from fillup(). */
    //rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));
    rg->fillup(mysql_res,
              //&tarantool_tnt_reply,
              connections_dbms[MYSQL_REMOTE_CONNECTION],
              //this,
              lmysql, ocelot_client_side_functions,
              MYSQL_REMOTE_CONNECTION,
              false);
    /* TODO: Get field names and data types from fillup!! */
    QString create_table_statement=
    text.mid(main_token_offsets[passed_main_token_number],
             main_token_offsets[i_of_server] - main_token_offsets[passed_main_token_number]);
    /* Pass "CREATE TABLE table-name", fill in (field-names) + execute */
    result= rg->creates(create_table_statement, connections_dbms[MYSQL_MAIN_CONNECTION], read_format_result);
    if (result != 0)
    {
      put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
      break;
    }
    QString temporary_table_name=
            text.mid(main_token_offsets[i_of_table] + main_token_lengths[i_of_table],
                     main_token_offsets[i_of_server] - (main_token_offsets[i_of_table] + main_token_lengths[i_of_table]));
    /* INSERT INTO [temporary_table_name] VALUES (...); */
    result= rg->inserts(temporary_table_name);
    if (result != 0)
    {
      put_diagnostics_in_result(MYSQL_MAIN_CONNECTION);
      break;
    }
    break;
  }
  /* Todo: Now destroy the temporary tables? (What temporary tables?) */
  delete rg;
  return result;
}
#endif

#ifdef DBMS_TARANTOOL
/*
  Pass: lua_request which might contain space_name.
  Read the _space tuple for space_name. Example:
  - [514,                                                                   -- id
     1,                                                                     -- owner
     'y1',                                                                  -- name
     'memtx',                                                               -- engine
     2,                                                                     -- field_count
     {'sql': 'CREATE TABLE y1 (f_1 VARCHAR(5) PRIMARY KEY,f_2 BIGINT )'},   -- flags
     [{'name': 'f_1', 'type': 'scalar'},                                    -- format
      {'name': 'f_2', 'type': 'scalar'}]]
  We care about the format field. It might be blank i.e. [].
  If it is not blank, we want to use the list of names.
  This is for create_table_server i.e. CREATE TABLE ... SERVER ... LUA '...';
  It only works if the Lua request looks like box.space.space-name:select().
  The list might not be complete.
  Compare tarantool_internal_query()
  Returns e.g. [1]id[2]owner[3]name[4]engine[5]field_count[6]flags[7]format
  Todo: the loop calls the server once per field! Fix this real soon, eh?
  Todo: someday use the types too.
  Todo: use for any SELECT from a single table, or box.space.space_name:select()
*/
QString MainWindow::tarantool_read_format(QString lua_request)
{
  QString read_format_result= "";
  QString word= "";
  /* e.g. from LUA 'box.space.t:select()' find 't' */
  /* Todo: this doesn't allow for whitespace */
  int word_start= lua_request.indexOf("box.space.", 0);
  if (word_start == -1) return "";
  word_start+= strlen("box.space.");
  int word_end= lua_request.indexOf(":", word_start);
  if (word_end == -1) return "";
  word= lua_request.mid(word_start, (word_end - word_start));
  for (int i= 1; i < 10; ++i)
  {
    char i_str[10];
    sprintf(i_str, "%d", i);
    QString request= "return box.space._space.index.name:select('"
                     + word
                     + "')[1][7]["
                     + i_str
                     + "].name";
    char tmp[1024];
    strcpy(tmp, request.toUtf8());
    QString result= tarantool_internal_query(tmp, MYSQL_REMOTE_CONNECTION);
    if (result == "") break;
    read_format_result= read_format_result + "[" + i_str + "]" + result;
  }
  return read_format_result;
}
#endif

/*
  log() may be useful for debugging if the program is acting strangely.
  * We do not use printf() ordinarily, but if level > ocelot_log_level,  we printf(message).
    Thus level is a priority, ocelot_log_level is a threshold, to increase the chance that a
    particular message will appear we increase level, to increase the chance that any message
    will appear we decrease ocelot_log_level.
  * We also fflush(stdout) which is usually unnecessary (messages
    are printed with "\n") unless stdout has been redirected to a file.
  * ocelot_log_level default value = 100, can be changed with --ocelot_log_level==N.
  * Re QElapsedTimer:
    We also printf(seconds-since-last-printf) based on a so-called nanoseconds count.
    Of course it's not really nanoseconds and sometimes it's based on ticks or milliseconds.
    So printf doesn't really say anything with %.9f especially since printf itself takes so much time.
    If this is never used, then #include #include <QElapsedTimer> can be removed from ocelotgui.h.
  Undocumented: if level == 1000, show part of statement_edit_widget html.
                see https://github.com/tarantool/doc/issues/1835
                Initially I tried toHtml() but it requires too much massaging
                Works better if connected because e.g. otherwise ansi_quotes might be wrong.
  Todo: consider using stderr or a named file.
  Todo: attach a timer or counter so printf occurs if dangers exist.
  Todo: consider using a bit mask instead of a greater-than comparison.
        or, a system with definitions, e.g. 10=trivial, 20=unusual,
        30=surprising, 200=pseudo-assertion
  Todo: consider making this a macro so invocation is easier.
*/
void MainWindow::log(const char *message, int level)
{
  if (ocelot_log_level == 1000)
  {
    if (level == 1000)
    {
      QString indenter= QString(" ").repeated(ocelot_statement_format_statement_indent.toInt());
      QString s_in= statement_edit_widget->toPlainText();
      QString s_out= indenter + "<p style='font-family:monospace; white-space:pre;'>\n" + indenter;
      QTextCursor text_cursor= statement_edit_widget->textCursor();
      text_cursor.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor);
      QString last_color= "";
      int ii= 0;
      bool is_in_span= false;
      while(text_cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::MoveAnchor))
      {
        QTextCharFormat text_cursor_format = text_cursor.charFormat();
        QString this_color= text_cursor_format.foreground().color().name();
        this_color= rgb_to_color(this_color).toLower();
        QString m= s_in.mid(ii, 1);
        QChar c= m.at(0);
        if ((c.isPrint() == true) && (c.isSpace() == false))
        {
          if (this_color != last_color)
          {
            if (is_in_span == true) s_out.append("</span>");
            s_out.append("<span style=\"color:"); s_out.append(this_color); s_out.append("\">");
            last_color= this_color;
            is_in_span= true;
          }
        }
        s_out.append(m);
        if (c == QChar(10)) s_out.append(indenter);
        ++ii;
      }
      if (is_in_span == true) s_out.append("</span>");
      s_out.append("</p>");
      char *tmp= new char[s_out.size() * 3 + 1];
      strcpy(tmp, s_out.toUtf8());
      printf("\n.. raw:: html\n\n");
      printf("%s\n\n", tmp);
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
      fflush(stdout);
#endif
      delete []tmp;
      return;
    }
  }
  if (level == 1000) return;
  static QElapsedTimer* timer;
  static long int elapsed_nanoseconds= 0;
  if (level > ocelot_log_level)
  {
    long int new_elapsed_nanoseconds;
    double seconds;
    if (elapsed_nanoseconds == 0)
    {
      timer= new QElapsedTimer(); /* Todo: this leaks. destroy it eventually. */
      timer->start();
    }
    new_elapsed_nanoseconds= timer->nsecsElapsed();
    seconds= new_elapsed_nanoseconds - elapsed_nanoseconds;
    seconds= seconds / 1000000000;
    printf("%s %.9f\n", message, seconds);
    elapsed_nanoseconds= new_elapsed_nanoseconds;
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
    fflush(stdout);
#endif
  }
}

/*
  Context Menu
  Usually caused by right-click on a widget but we do not try to
  assume that by intercepting a Qt::RightButton event, it might be Menu key.
  https://doc.qt.io/archives/qt-4.8/qcontextmenuevent.html
  * When we start we say
    statement_edit_widget->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(this, SIGNAL(customContextMenuRequested(const QPoint &)),
        statement_edit_widget, SLOT(menu_context(const QPoint &)));
    etc.
    For ResultGrid we do this in ocelotgui.h during client initiation, before making the cell pool,
    so that TextEditFrame will inherit the policy (and it does).
  * We don't want the default context menu. I tried to turn it off by calling
    setContextMenuPolicy(Qt::PreventContextMenu); in TextEditFrame::TextEditFrame(),
    and in MainWindow, but failed. However, I succeeded with the method I'm using now.
  * In ocelotgui.h we have public slots: menu_context().
  * TIP? itemAt(pos) might tell you where right click happened, else you might need special measures.
  * Todo: pass QContextMenuEvent::Reason too?
  * Todo: I wish we could just connect for MainWindow and inherit, but I couldn't get that to work.
          Now we're only setting policy and connecting for
          result grid, + history_edit_widget, + statement_edit_widget, + TextEditWidget
          and not debug or line or texteditframe|textedwidget.
  * Todo: mapToGlobal(pos) is nearly okay but the menu is slightly to the left of the cursor.
          And, since we get here for all widgets not just statement_edit_widget, it can be way off.
  * Todo: This is not really a custom or in-context menu, we just show the menu that we'd see if we
    clicked Menu|Edit. We re-use menu_edit rather than making a new QMenu. This seems to work
    but I've not seen a definite statement that it is supposed to work.
  * Todo: Meanwhile html_text_edit has a public slot menu_context_t which calls menu_context_t_2
    which calls here. Probably more jumps than needed, eh? Anyway, at the time we call, we
    know exactly which cell the cursor is on, and we know it's result grid not statement_edit_widget,
    so considerable improvement is possible for that.
*/
void MainWindow::menu_context(const QPoint &pos)
{
  menu_edit->exec(statement_edit_widget->mapToGlobal(pos));
}

/******************** typer start ***********************************************/
/*
  We want a list of data types as numbers, corresponding to a list of data types as strings.
  But, alas, OCELOT_DATA_TYPE_LONG won't tell us TOKEN_KEYWORD_INTEGER.
*/
struct typer {
   unsigned int ocelot_data_type;
   unsigned int keyword_data_type;
};
static const typer typer_list[]=
{
    {OCELOT_DATA_TYPE_DECIMAL, TOKEN_KEYWORD_DECIMAL},
    {OCELOT_DATA_TYPE_TINY, TOKEN_KEYWORD_TINYINT},
    {OCELOT_DATA_TYPE_SHORT, TOKEN_KEYWORD_INTEGER},
    {OCELOT_DATA_TYPE_LONG, TOKEN_KEYWORD_LONG},
    {OCELOT_DATA_TYPE_FLOAT, TOKEN_KEYWORD_FLOAT},
    {OCELOT_DATA_TYPE_DOUBLE, TOKEN_KEYWORD_DOUBLE},
    {OCELOT_DATA_TYPE_NULL, TOKEN_KEYWORD_NULL},
    {OCELOT_DATA_TYPE_TIMESTAMP, TOKEN_KEYWORD_TIMESTAMP},
    {OCELOT_DATA_TYPE_LONGLONG, TOKEN_KEYWORD_INTEGER},
    {OCELOT_DATA_TYPE_INT24, TOKEN_KEYWORD_INTEGER},
    {OCELOT_DATA_TYPE_DATE, TOKEN_KEYWORD_DATE},
    {OCELOT_DATA_TYPE_TIME, TOKEN_KEYWORD_TIME},
    {OCELOT_DATA_TYPE_DATETIME, TOKEN_KEYWORD_DATETIME},
    {OCELOT_DATA_TYPE_YEAR, TOKEN_KEYWORD_YEAR},
    {OCELOT_DATA_TYPE_BIT, TOKEN_KEYWORD_BIT},
    {OCELOT_DATA_TYPE_JSON, TOKEN_KEYWORD_JSON},
    {OCELOT_DATA_TYPE_NEWDECIMAL, TOKEN_KEYWORD_DECIMAL},
    {OCELOT_DATA_TYPE_ENUM, TOKEN_KEYWORD_ENUM},
    {OCELOT_DATA_TYPE_SET, TOKEN_KEYWORD_SET},
    {OCELOT_DATA_TYPE_TINY_BLOB, TOKEN_KEYWORD_BLOB},
    {OCELOT_DATA_TYPE_MEDIUM_BLOB, TOKEN_KEYWORD_BLOB},
    {OCELOT_DATA_TYPE_LONG_BLOB, TOKEN_KEYWORD_BLOB},
    {OCELOT_DATA_TYPE_BLOB, TOKEN_KEYWORD_BLOB},
    {OCELOT_DATA_TYPE_VAR_STRING, TOKEN_KEYWORD_STRING},
    {OCELOT_DATA_TYPE_STRING, TOKEN_KEYWORD_STRING},
    {OCELOT_DATA_TYPE_GEOMETRY, TOKEN_KEYWORD_GEOMETRY},
    {OCELOT_DATA_TYPE_BINARY, TOKEN_KEYWORD_BINARY},
    {OCELOT_DATA_TYPE_VARBINARY, TOKEN_KEYWORD_VARBINARY},
    {OCELOT_DATA_TYPE_TEXT, TOKEN_KEYWORD_TEXT},
    {OCELOT_DATA_TYPE_SCALAR, TOKEN_KEYWORD_SCALAR},
    {OCELOT_DATA_TYPE_BOOLEAN, TOKEN_KEYWORD_BOOLEAN},
    {OCELOT_DATA_TYPE_MAP, TOKEN_KEYWORD_MAP},
    {OCELOT_DATA_TYPE_ARRAY, TOKEN_KEYWORD_ARRAY},
    {OCELOT_DATA_TYPE_INTEGER, TOKEN_KEYWORD_INTEGER},
    {OCELOT_DATA_TYPE_UNSIGNED, TOKEN_KEYWORD_UNSIGNED},
    {OCELOT_DATA_TYPE_NUMBER, TOKEN_KEYWORD_NUMBER},
    {0, 0}
};

/*
  Pass: string with a data type. Return: OCELOT_DATA_TYPE_xxx
  This works, but for now we use the slightly cheaper-looking
  if ((value_length == 7) && (memcmp(value, "integer", 7) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_LONG;
  etc. So for now it's commented out, it's "in reserve".
*/
//int MainWindow::typer_to_ocelot_data_type(char *s)
//{
//  char key2[MAX_KEYWORD_LENGTH + 1];
//  int keyword_index;
//  keyword_index= get_keyword_index(s, key2);
//  for (int i= 0; ; ++i)
//  {
//    if (typer_list[i].keyword_data_type == 0) break;
//    if (typer_list[i].keyword_data_type == (unsigned int)keyword_index)
//    {
//      printf("**** match! %d\n", typer_list[i].ocelot_data_type);
//      return typer_list[i].ocelot_data_type;
//    }
//  }
//  return OCELOT_DATA_TYPE_NULL;
//}

char * MainWindow::typer_to_keyword(unsigned int ocelot_type)
{
  for (int i= 0; ;++i)
  {
    if (typer_list[i].keyword_data_type == 0) break;
    if (typer_list[i].ocelot_data_type == ocelot_type)
    {
      int k= typer_list[i].keyword_data_type;
      return (char*)strvalues[k].chars;
    }
  }
  return (char*)strvalues[TOKEN_KEYWORD_NULL].chars;
}

/* Return true iff keyword identified one of the integer data types. Currently only used during parse. */
bool MainWindow::typer_is_int(int key)
{
  if ((key == TOKEN_KEYWORD_BIGINT)
   || (key == TOKEN_KEYWORD_BIT)
   || (key == TOKEN_KEYWORD_BOOL)
   || (key == TOKEN_KEYWORD_BOOLEAN)
   || (key == TOKEN_KEYWORD_INT)
   || (key == TOKEN_KEYWORD_INT1)
   || (key == TOKEN_KEYWORD_INT2)
   || (key == TOKEN_KEYWORD_INT3)
   || (key == TOKEN_KEYWORD_INT4)
   || (key == TOKEN_KEYWORD_INT8)
   || (key == TOKEN_KEYWORD_INTEGER)
   || (key == TOKEN_KEYWORD_MEDIUMINT)
   || (key == TOKEN_KEYWORD_SMALLINT)
   || (key == TOKEN_KEYWORD_TINYINT))
    return true;
  return false;
}

/******************** typer end ***********************************************/

#include "codeeditor.h"

/******************** completer_widget start ************************************/

/*
  The hint list box that appears (hopefully underneath the statement widget) if syntax error,
  which probably means that the user is typing and hasn't finished a word.
  This is somewhat like a popup but using "Qt::Popup" caused trouble. We don't want modal.
  Warning: We can call this without going via hparse_f_multi_block() and before calling dbms_version_mask()
  Re class = subclass of QTextEdit:
    Originally it was a subclass of QListWidget and that worked well enough with Ubuntu 18 + Qt 5.9,
    but worked very poorly with Fedora 32 + Qt 5.13, the size was too small and the reported size was false.
  Re timer:
    We hide the widget after ocelot_completer_timeout, default = 10 (seconds). Todo: check what normal amount is.
    We should reset the timer (by stopping and starting it) if there is activity either in statement_edit_widget or completer_widget
    Todo: if user says SET ocelot_completer_timeout=0; interpret that as: disable the widget.
  Todo: some sort of in-context help if --i-am-a-dummy or menu = Help
        users are supposed to know that Tab will complete, down-arrow will navigate, timeout is 10 seconds,
  * Possible experiments with flags:
    Tried Qt::Dialog and Qt::Window, they cause trouble
    Try Qt::CustomizeWindowHint |  Qt::Tool | Qt::WindowDoesNotAcceptFocus | Qt::FramelessWindowHint
    setWindowFlags must follow setParent, otherwise hide() will not be totally reversed by show()
  * todo: maybe it should be initially hidden
  Unusually main_window will not be the parent, we call setParent(p->statement_edit_widget);.
  todo: references to main_window->statement_edit_widget are a bit convoluted since it is the parent.
  todo: there's no point in Completer_widget if we aren't recognizing, in that case make sure it's suppressed
  Re eventfilter_function:
    Checks for key_up or key_down events and calls key_up_or_down().
    Could check for MousePressEvent and hide completer_widget -- the idea is that for a tooltip | popup if one clicks
    outside the tooltip then the tooltip disappears. But there's no point checking within eventfilter function because
    if you click outside statement_edit_widget then it loses focus and then completer_widget gets hidden anyway,
    and if you click inside statement_edit_widget then eventfilter_function won't notice. The real solution would be to
    put a MousePressEvent function in codeeditor.
  Todo: Some inputs we don't handle well: right-click, select-all + copy, ctrl-+ ctrl--
*/

/* call from constructor */
/* Todo: you could just put the constructor here, same as what you do with TextEditFrame::TextEditFrame */
/*
  Warning: QStringList QList etc. are "implicitly shared" classes https://doc.qt.io/qt-5/implicit-sharing.html
           I have only slight experience with this concept and might be initializing wrong.
           Supposedly the private area never shrinks; maybe I should try occasional delete + recreate of whole Completer_widget.
*/
void Completer_widget::construct(MainWindow *m)
{
  main_window= m;
  setParent(main_window->statement_edit_widget); /* This can change during initialize() */
  setWindowFlags(Qt::WindowStaysOnTopHint);
  timer= new QTimer(this);
  timer->setSingleShot(true);
  set_timer_interval();
  current_row= 0;
  string_list= QStringList();        /* Qt default constructors create empty lists but I worry anyway. */
  string_list_tooltips= QStringList();
  token_type_list= QList<int> ();
  setReadOnly(true);
  QObject::connect(timer, SIGNAL(timeout()), this, SLOT(timer_expired(void)));
}

/* todo: replace this with QStringList::join()? or do appends to QTextEdit so you're sure there are blocks? */
void Completer_widget::copy_string_list()
{
  QString s= "";
  for (int i= 0; i < string_list.size(); ++i)
  {
    s= s + string_list.at(i) + "\n";
  }
  setText(s);
}

void Completer_widget::set_timer_interval()
{
  timer->setInterval(ocelot_completer_timeout * 1000);
}

/*
  Saying completer_widget->hide() ... completer_widget->show() used to be tricky ... the widget would disapper.
  Now that seems to be solved but let us leave these in as wrappers and not call hide() or show() directly.
*/
/* call when list widget size == 0 (due to clear, probably) (but also if you append and there are no candidates) */
/* call when statement edit widget loses focus, except when the focus is going to be completer_widget */
/* call after an interval, maybe there must be a timer */
void Completer_widget::hide_wrapper()
{
  timer->stop();
  hide();
  main_window->menu_edit_action_autocomplete->setEnabled(false);
}

/*
  call when adding something
  Todo: We decide here that we won't show if statement_edit_widget is empty.
        But we could show if it seemed worthwhile.
        And maybe there's a quicker way to know if it is empty.
  Todo: Merge with updater() if that is the only thing that calls show_wrapper().
*/
void Completer_widget::show_wrapper()
{
  if (main_window->statement_edit_widget->document()->isEmpty()) return;
  line_colors(associated_widget_type);
  show();
  timer_reset(); /* although timer->stop((); is maybe unnecessary */
  main_window->menu_edit_action_autocomplete->setEnabled(true);
}

/* Similar to something in codeeditor.h
   Todo: With explorer_widget and result_of_evaluate == true, changes to text_color and background_color go okay,
         but setFont() fails with the QFont that I get from get_font_from_style_sheet().
         So insert html? Or the answer might be hinted at in
         https://stackoverflow.com/questions/39531626/qtextedit-update-single-qtextcharformat
*/
void Completer_widget::line_colors(int associated_widget_type)
{
  QList<QTextEdit::ExtraSelection> extraSelections;
  QTextCursor tc= textCursor();
  tc.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor, 1);
  QColor line_color;
  for (int i= 0; i < count_wrapper(); ++i)
  {
    if (i != 0) tc.movePosition(QTextCursor::NextBlock, QTextCursor::MoveAnchor, 1);
    setTextCursor(tc);
    QTextEdit::ExtraSelection selection;
    int flags= 0;
    bool result_of_evaluate= false;
    QString cs_new_style_sheet;
    QTextCharFormat format_of_current_token;
    QString cs_new_tooltip;
    QString cs_new_cell_height;
    QString cs_new_cell_width;
    int returned_cs_number;
    QString style_string= main_window->ocelot_explorer_style_string;
    QString string= string_list.at(i);
    if (associated_widget_type == EXPLORER_WIDGET)
    {
      /* Todo: Stripping lead+trail spaces does not remove a shortcut. Should we remove shortcuts? */
      string= string.trimmed();
      QByteArray string_utf8= string.toUtf8();
      result_of_evaluate= main_window->explorer_widget->conditional_setting_evaluate_till_true(
                                          1,           /* i.e. result set column number */
                                          1,       /* e.g. text_frame->ancestor_grid_result_row_number */
                                          string_utf8.data(),       /* e.g. text_frame->content_pointer */
                                          0,          /* e.g. FIELD_VALUE_FLAG_IS_NULL */
                                          string_utf8.size(), /* e.g. text_frame->content_length */
                                          TEXTEDITFRAME_CELL_TYPE_DETAIL,  /* e.g. text_frame->cell_type */
                                          &cs_new_tooltip,        /* return */
                                          &cs_new_style_sheet,    /* return */
                                          &cs_new_cell_height,    /* return */
                                          &cs_new_cell_width,     /* return */
                                          &returned_cs_number);        /* return */
      if (result_of_evaluate == true)
      {
        style_string= cs_new_style_sheet;
      }
    }
    if (associated_widget_type == STATEMENT_WIDGET)
    {
      int token_type= token_type_list.at(i);
      format_of_current_token= main_window->get_format_of_current_token(token_type, flags, "");
    }
    else /* EXPLORER_WIDGET -- but unfortunate, since statement choices allow customizing depending on type */
    {
      if (result_of_evaluate == true)
      {
        QString color= main_window->get_color_from_style_sheet(style_string);
        format_of_current_token.setForeground(QColor(color));
      }
      else
      {
        format_of_current_token.setForeground(QColor(main_window->qt_color(main_window->ocelot_explorer_text_color)));
      }
    }
    line_color= format_of_current_token.foreground().color();
    selection.format.setForeground(line_color);
    selection.format.setProperty(QTextFormat::FullWidthSelection, true);
    selection.cursor= textCursor();
    selection.cursor.clearSelection();
    extraSelections.append(selection);
    setExtraSelections(extraSelections);

    bool is_enabled= true;
    if (associated_widget_type == EXPLORER_WIDGET)
    {
      int i_of_cmi= i_of_cmi_of_text(string);
      if (i_of_cmi != -1)
      {
        QString e= main_window->explorer_widget->html_text_edit->explorer_context_menu->cmi[i_of_cmi].enabled;
        if (e == "no") is_enabled= false;
      }
    }
    if (is_enabled == false) line_color= Qt::lightGray;
    else
    {
      if (i != current_row)
      {
        if (associated_widget_type == STATEMENT_WIDGET)
          line_color= QColor(main_window->ocelot_statement_background_color);
        else /* EXPLORER_WIDGET */
        {
          if (result_of_evaluate == true)
          {
            line_color= main_window->get_background_color_from_style_sheet(style_string);
          }
          else
            line_color= QColor(main_window->ocelot_explorer_background_color);
        }
      }
      else
      {
        line_color= QColor(main_window->ocelot_statement_highlight_current_line_color).lighter(160);
      }
    }
    selection.format.setBackground(line_color);
    selection.format.setProperty(QTextFormat::FullWidthSelection, true);
    selection.cursor= textCursor();
    selection.cursor.clearSelection();
    extraSelections.append(selection);
    setExtraSelections(extraSelections);
  }
  tc.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor, 1);
  setTextCursor(tc);
}

/*
  Called from: line_colors() but probably interesting elsewhere
  We want to know whether an item the explorer context menu is matched with a cmi that has enabled = 'no'.
  Warning: the menu text can include the shortcut, which you don't want to compare.
*/
int Completer_widget::i_of_cmi_of_text(QString string)
{
  QString trimmed_string= string.trimmed();
  int cmi_count= main_window->explorer_widget->html_text_edit->explorer_context_menu->cmi_count;
  for (int i= 0; i < cmi_count; ++i)
  {
    QString t= main_window->explorer_widget->html_text_edit->explorer_context_menu->cmi[i].text;
    QString s= main_window->explorer_widget->html_text_edit->explorer_context_menu->cmi[i].shortcut;
    if ((s != "") && (trimmed_string.contains(s)))
    {
      int shortcut_length= s.length();
      trimmed_string= trimmed_string.left(trimmed_string.length() - shortcut_length);
      trimmed_string= trimmed_string.trimmed();
    }
    if (t == trimmed_string) return i;
  }
  return -1;
}

/*
  call when statement_edit_widget stylesheet change
  we could use something different from the statement_edit_widget style string, but I haven't seen a reason
  todo: check: I think explorer style sheet is also being set up outside the initialize
*/
void Completer_widget::initialize(int w)
{
  associated_widget_type= w; /* either STATEMENT_WIDGET or EXPLORER_WIDGET */
  if (associated_widget_type == STATEMENT_WIDGET)
  {
    setParent(main_window->statement_edit_widget);
    setWindowFlags(Qt::WindowStaysOnTopHint);
    setStyleSheet(main_window->ocelot_statement_style_string);
  }
  else /* EXPLORER_WIDGET */
  {
    if (main_window->ocelot_explorer_detached == "no") setParent(main_window);
    else setParent(main_window->explorer_widget);
    setWindowFlags(Qt::WindowStaysOnTopHint);
    setStyleSheet(main_window->ocelot_explorer_style_string);
  }
  /* TODO: WHAT SHOULD WE REALLY USE FOR EXPLORER? */
  size_and_position_change();
}

void Completer_widget::clear_wrapper()
{
  string_list.clear();
  string_list_tooltips.clear();
  token_type_list.clear();
  current_row= 0;
  hide_wrapper();
}

int Completer_widget::count_wrapper()
{
  return string_list.count();
}

/* todo: I suppose you'll need some error check although it's impossible that there are no selected items */
QString Completer_widget::get_selected_item(QString *tool_tip)
{
  *tool_tip= string_list_tooltips.at(current_row);
  return string_list.at(current_row);
}

/*
  Allow just enough size for Completer_widget, in the best possible location within statement_edit_widget.
  This is so that the list won't have a bunch of blank lines, and might have a vertical scroll bar.
  Re scroll bars:
    There might be a vertical scroll bar if number_of_choices i.e. lines > what we calculate will fit.
    There might be a horizontal scroll bar if number_of_choices i.e. characters-in-a-line > what we calculate will fit.
    If we expect a horizontal scroll bar, then we will add horizontal-scroll-bar-height to height.
  Re space at the bottom if there is a vertical scroll bar:
     See https://stackoverflow.com/questions/41827513/getting-rid-of-blank-area-at-the-bottom-of-a-qlistwidget
     The recommendation re setFixedSize type will fail.
     The recommendation re scrollPerPixel was tried and failed, e.g.
      ->setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);
     and anyway maybe that has an effect that's worse than the extra space.
*/

/*
  Get desired width and height of completer_widget based on width of its largest item and number of items.
  Possibly reduce so it won't be dominant.
  Get desired position based on where it will fit, and reduce more if there is trouble fitting within statement_edit_widget.

Usually this should mean there is no above/below switching and left moving, but frequent size change.

Separate resize should be unnecessary

This should be done in reaction to statement_edit_widget->resize too, but
-- beware, completer_widget might not exist yet
-- it would be good if we didn't recalculate for each pixel moved
-- so maybe don't respond, it will get figured out next time user types something
-- we could depend on our timer
-- if boundingRect() seems too slow, we could reduce by only sampling a few, but there might be horizontal overflow
-- todo: if list_widget hasn't changed since last time you called this, skip initial recalculation of width and height
*/

/*
   This should put completer_widget below the text cursor in statement_edit_widget, which is the parent.
   If it is too close to the right, shift to the left (even covering the prompt).
   If it is too close to the bottom, try the top.
   Todo: the minimum width/height calculations here are silliness for emergencies, we ordinarily calculate actual width + height.
*/

void Completer_widget::size_and_position_change()
{
  QFont f;
  if (associated_widget_type == STATEMENT_WIDGET)
    f= main_window->get_font_from_style_sheet(main_window->ocelot_statement_style_string);
  else /* EXPLORER_WIDGET */
    f= main_window->get_font_from_style_sheet(main_window->ocelot_explorer_style_string);
  QFontMetrics fm(f);
  QString s= "";
  copy_string_list();
  s= toPlainText();
  s= s.left(s.size() - 1); /* otherwise there's a blank at the end? */
  QRect r= fm.boundingRect(
            0, /* int x = x coordinate within original rect */
            0, /* int y = y coordinate within original rect */
            4000, /* int width = width, which is arbitrary big maximum */
            4000, /* int height = height, which is arbitrary big maximum */
            Qt::TextDontClip,
            s); /* QString & text= cell contents */
  int desired_width= r.width();
  int desired_height= r.height();
  int desired_height_of_one_line;
  if (count_wrapper() == 0) desired_height_of_one_line= desired_height;
  else desired_height_of_one_line= desired_height / count_wrapper();

  desired_width+= verticalScrollBar()->width();
  desired_width+= 2 * frameWidth() + 16; /* why + 16? I don't know. But it helps. */

  int maximum_width, maximum_height;
  if (associated_widget_type == STATEMENT_WIDGET)
  {
    maximum_width= main_window->statement_edit_widget->width();
    maximum_height= main_window->statement_edit_widget->height();
  }
  else
  {
    /* TODO: SHOULD BE CURRENT POSITION TILL END. AND THIS ASSUMES NO DETACHING! */
      maximum_width= main_window->width() - main_window->explorer_widget->width();
    maximum_height= main_window->height();
  }
  if (desired_width > maximum_width)
  {
    desired_height+= horizontalScrollBar()->height(); /* do this only if there will be a horizontal scroll bar */
  }

  desired_height+= 2 * frameWidth();
  desired_height+= count_wrapper() * 2; /* why * 2? I don't know. But it helps. */

  QRect r3;
  if (associated_widget_type == STATEMENT_WIDGET)
    r3= main_window->statement_edit_widget->cursorRect();
  else /* EXPLORER_WIDGET */
    r3= main_window->explorer_widget->html_text_edit->cursorRect();
  int desired_x;
  if (associated_widget_type == STATEMENT_WIDGET)
    desired_x= r3.x() + main_window->statement_edit_widget->prompt_width_calculate();
  else /* EXPLORER_WIDGET todo: can shift more than this if it wouldn't interfere with maximum width */
    desired_x= r3.x() + 24;
  int desired_y= r3.y() + r3.height();
  /* If there isn't enough width, try to shift completer_widget left. If still not enough, shift to x=0 and reduce width. */
  int space_after_x= maximum_width - (desired_x + desired_width);
  if (space_after_x < 0)
  {
    if (desired_width > maximum_width) desired_width= maximum_width;
    desired_x= maximum_width - desired_width;
  }
  /* If there isn't enough height, see if it would fit much better above. If not, reduce height. */
  int space_after_y= maximum_height - (desired_y + desired_height);
  if (space_after_y < 0)
  {
    if (r3.y() > (maximum_height - desired_y) + 100)
    {
      desired_y= r3.y() - desired_height;
      if (desired_y < 0)
      {
        desired_y= 0;
        desired_height= r3.y();
      }
    }
    else
    {
     while (desired_height > (maximum_height - desired_y))
     {
       /* Something initially comes up with size = 10, covering the prompt, if show_wrapper() activates while statement is empty */
       if (desired_height < 10) break;
       desired_height -= desired_height_of_one_line;
     }
     //desired_height= maximum_height - desired_y;
    }
    setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
  }
  else
  {
    /* If we know that it will fit, let's try reducing to eliminate that extra blank lne? Nope, doesn't work */
    setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
  }
  //setFixedSize(desired_width, desired_height);
  resize(desired_width, desired_height);
  if (associated_widget_type == STATEMENT_WIDGET)
    move(desired_x, desired_y);
  else /* EXPLORER_WIDGET */
    move(desired_x, desired_y);
}

/*
  Re final_letter:
    Symbols: 'D' database 'C' column 'T' table 'F' function 'P' procedure 't' trigger 'E' event 'I' index (from database)
             'K' keyword (not from database) or operator
    We use this for setToolTip() so the user can see the object type (reftype?) when hovering, but more importantly we use this
    to decide whether it's an identifier because in that case we might want to put ""s around it
    (depending on foreground color would be wrong because users can set the same color for multiple things).
    todo: maybe we should be setting with setStatusTip() or setWhatsThis instead of setToolTip()
  todo: Some junk remains because you aren't calling when looking at Lua. I guess when you just type 'i' there's no call?
  todo: You must be suspicious about removeWidget
  todo: at the time we call this, we also know reftype. and we could look ahead to see if "(" follows
  todo: I'm a bit uncertain why hparse_token can be "", maybe it's something during start
  todo: it's inefficient to add in and then take out what was just added in
  todo: we must pass type() but we don't need icon (or, we need icon)
  todo: don't sort string_list, but you could insert to string_list and string_list_tooltips in order
*/
void Completer_widget::append_wrapper(QString token, QString hparse_token, int token_type, int flags, QString final_letter)
{
  (void) flags; /* suppress "unused parameter" warning */
  QString s_hparse_token= hparse_token;
  if (s_hparse_token.left(1) == "\"") s_hparse_token= s_hparse_token.right(hparse_token.size() - 1);
  if (s_hparse_token.left(1) == "`") s_hparse_token= s_hparse_token.right(hparse_token.size() - 1);
  /* Do not add token if there is already a match in the list. todo: should be checking type + reftype too, somehow */
  if (string_list.contains(token, Qt::CaseInsensitive) == false)
  {
    string_list.append(token);
    string_list_tooltips.append(final_letter);
    token_type_list.append(token_type);
  }
  if (s_hparse_token > "")
  {
    int hps= s_hparse_token.size();
    for (int i= count_wrapper() - 1; i >= 0; --i)
    {
      QString s= string_list.at(i).left(hps);
      if (QString::compare(s_hparse_token, s, Qt::CaseInsensitive) != 0)
      {
        string_list.removeAt(i);
        string_list_tooltips.removeAt(i);
        token_type_list.removeAt(i);
      }
    }
  }
  set_current_row(current_row);
}

void Completer_widget::updater()
{
  if (count_wrapper() > 0)
  {
    size_and_position_change();
    show_wrapper();
  }
  else
  {
    hide_wrapper();
  }
}

/* todo: change ostrings.h so tooltip text can be in French */
/* todo: don't change the tooltip unless there's something different to say, but this checking might be inefficient */
/* todo: we seem to call set_current_row with new_current_row==0 a huge number of times, find out why. */
void Completer_widget::set_current_row(int new_current_row)
{
#if (OCELOT_EXPLORER == 1)
  if (associated_widget_type == EXPLORER_WIDGET)
  {
    setToolTip("Context menu. Click to execute explorer action");
    current_row= new_current_row;
    return;
  }
#endif
  if ((new_current_row != current_row) || (string_list_tooltips.count() < 3))
  {
   if (string_list_tooltips.count() > new_current_row)
    {
      QString s;
      if (string_list_tooltips.count() == 1) s= "Autocompletion hint.\n";
      else
      {
        s= "Autocompletion hints.\n";
        s= s + "Change selection with down-arrow key or mouse.\n";
        QString s3= ocelot_shortcut_autocomplete;
        if (s3 == "default") s3= "tab key";
        s= s + "Choose selection with " + s3 + ".\n";
      }
      s= s + "Current selection is ";
      QString s2= string_list_tooltips.at(new_current_row);
      if      (s2 == "C") s= s + "a Column name.";
      else if (s2 == "D") s= s + "a Database name.";
      else if (s2 == "E") s= s + "an Event name.";
      else if (s2 == "F") s= s + "a Function name.";
      else if (s2 == "FP") s= s + "a Function or Procedure name";
      else if (s2 == "I") s= s + "an Index name.";
      else if (s2 == "i") s= s + "an identifier.";
      else if (s2 == "K") s= s + "a Keyword.";
      else if (s2 == "O") s= s + "an Operator.";
      else if (s2 == "P") s= s + "a Procedure name.";
      else if (s2 == "T") s= s + "A Table name.";
      else if (s2 == "t") s= s + "a Trigger name.";
      else if (s2 == "V") s= s + "a Variable. name.";
      else s= s + "a (" + s2 + ") token.";
      setToolTip(s);
    }
  }
  current_row= new_current_row;
}

/*
  Down arrow will go down in completer_widget without changing focus.
  Up arrow will go up in completer_widget without changing focus but if we're at top then it will go up in statement widget.
  Todo: this should be something we can change with "set ocelot_shortcut_..."
  Todo: how can we be sure this won't go to statement edit widgets' slot?
  In eventfilter_function check:
    if (key->key() == Qt::Key_Down) && (completer_widget->key_up_or_down(+1)) return true;
    if completer_widget is not hidden (and we are at end of input?)
      change what is selected -- go forward 1
      return true
*/
bool Completer_widget::key_up_or_down(int plus_or_minus_one)
{
  if (isHidden() == true) return false;
  timer_reset();
  if ((plus_or_minus_one == +1) && (current_row >= count_wrapper() - 1)) return true;
  if ((plus_or_minus_one == -1) && (current_row <= 0)) return false;
  set_current_row(current_row + plus_or_minus_one);
  line_colors(associated_widget_type);

  /* Todo: This works but is a ridiculous way to ensure cursor stays visible. */
  QTextCursor cursor= textCursor();
  int p= 0;
  for (int i= 0; i < current_row; ++i)
  {
    p+= string_list.at(i).size() + 1;
  }
  QString s= string_list.at(current_row);
  ensureCursorVisible();
  cursor.setPosition(p, QTextCursor::MoveAnchor);
  setTextCursor(cursor);
  return true;
}

/* If user clicks an item, it should become current_row. Compare key_up_or_down(). */
void Completer_widget::mousePressEvent(QMouseEvent *event)
{
  timer_reset();
  QTextCursor tc= cursorForPosition(event->pos());
  int tc_original_block_number= tc.blockNumber();
  set_current_row(tc_original_block_number);
  line_colors(associated_widget_type);
  tc.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor, 1);
  tc.movePosition(QTextCursor::NextBlock, QTextCursor::MoveAnchor, tc_original_block_number);
  setTextCursor(tc);
  if (associated_widget_type == STATEMENT_WIDGET)
    main_window->statement_edit_widget->setFocus();
  else /* EXPLORER_WIDGET */
    call_for_action();
}

/*
  If user double-clicks an item, that's equivalent to single-click followed by autocomplete key.
  When you double click, you get mousePressEvent first, so current_row is known by this time.
  Todo: It seems that, at least for explorer menu, mousePressEvent happens and we never reach here.
        But that might be a problem, it would mean that the second click is going up the line to explorer widget?
*/
void Completer_widget::mouseDoubleClickEvent(QMouseEvent *event)
{
  (void) event;
  main_window->statement_edit_widget->setFocus();
  main_window->menu_edit_autocomplete();
}

/* Probably focusInEvent will happen only when Context_menu calls Completer_widget. Else this is bad. */
void C_widget::focusInEvent(QFocusEvent *event)
{
  QTextEdit::focusInEvent(event);
  line_colors(EXPLORER_WIDGET); /* so that the first item in the list gets "emphasis" */
  main_window->menu_edit_action_autocomplete->setEnabled(true); /* So shortcut e.g. Key_Tab will work */
}

/* When Context_menu calls Completer_widget, hide it as soon as e.g. mouse click outside. */
void C_widget::focusOutEvent(QFocusEvent *event)
{
  QTextEdit::focusOutEvent(event);
#if (OCELOT_EXPLORER == 1)
  if (associated_widget_type == EXPLORER_WIDGET)
  {
    hide();
    main_window->menu_edit_action_autocomplete->setEnabled(false);
    initialize(STATEMENT_WIDGET);
  }
#endif
}

/*
  Ordinarily I expect keyPressEvent will be caught in eventfilter_function, and that seems to be the case
  when parent is statement_edit_widget, but not when parent is explorer_widget. So some duplication here.
  What about shortcut?
  Re Key_Escape: I think it's normal for QDialog and QMenu that Esc causes focus loss, so hide().
  Re Key_Tab: we should treat this like we treat Key_Enter, via shortcut_override, it won't get to here.
*/
void Completer_widget::keyPressEvent(QKeyEvent *event)
{
  QKeyEvent *key= event;
  if (main_window->keypress_shortcut_handler(key, false) == true)
  {
    call_for_action();
  } /* todo: this isn't seen */
  if (key->key() == Qt::Key_Down) key_up_or_down(+1);
  if (key->key() == Qt::Key_Up) key_up_or_down(-1);
  if ((key->key() == Qt::Key_Enter) || (key->key() == Qt::Key_Return)) call_for_action();
  if (key->key() == Qt::Key_Escape) hide();
  event->accept(); /* unless there's some reason we should let the key propagate upwards to an ultimate owner? */
}

/* called from mousePressEvent, keyPressEvent if Key_Enter */
void Completer_widget::call_for_action()
{
  main_window->explorer_widget->html_text_edit->explorer_context_menu->action(current_row, -1);
  hide();
}

void Completer_widget::timer_reset()
{
  timer->stop();
  timer->start();
}

/*
  ocelot_completer_timeout has expired so we hide completer_widget, unless it has focus (because user clicked on its vertical scroll bar).
*/
void Completer_widget::timer_expired()
{
  if (hasFocus())
  {
    timer->start();
    return;
  }
  hide_wrapper();
}

/*
  Todo: generally (always?) autocomplete menu item is disabled when we're looking at explorer.
  Note: "if (qk == Qt::Key_Tab)" was here before but on some Qt versions caused an error =
        ambiguous overload of operand == (operand types are QKey::KeySequence and Qt::Key)
*/
bool Completer_widget::shortcut_override(QKeySequence qk)
{
  if ((hasFocus() == true) && (associated_widget_type == EXPLORER_WIDGET))
  {
    if (qk.toString() == "Tab")
    {
      call_for_action();
      return true;
    }
  }
  return false;
}

/******************** completer_widget end   ************************************/

/******************** Messagebox_flash start *************************************/
void Messagebox_flash::showEvent( QShowEvent * event)
{
  timer= new QTimer(this);
  timer->setSingleShot(true);
  timer->setInterval(1000);
  timer->start();
  QObject::connect(timer, SIGNAL(timeout()), this, SLOT(timer_expired(void)));
  QMessageBox::showEvent(event);
}

void Messagebox_flash::timer_expired()
{
  this->done(0); /* meaning = QDialog::done(int r) */
}

/******************** Messagebox_flash end *************************************/

/******************** find_widget start   ************************************/
#if (OCELOT_FIND_WIDGET == 1)
/*
  Re close_button:
    If user clicks this, we hide (but we don't delete, and maybe we should. or delete components)
    This is like what an editor does.
  Re find_label:
    This and other text should be in ostrings.h so it can be French
  Re combo_box:
    QComboBox, editable.
    After each Ctrl+F, users see a blank that they can edit, or they can scroll down and pick a previous.
    This is like what an editor does but an editor's history is stored, ours is since-startup and limited to 5.
  Re up_button and down_button:
    These are for going to "next" or "previous"
    This is like what an editor does.
    We could have said down_button->setArrowType(Qt::DownArrow);
  Re case_button:
    Text is 'i' for Qt::CaseInsensitive or 's' for Qt::CaseSensitive. Default is 'i'.
    Click to toggle between 'i' and 's'. Search won't be repeated automatically but setting is in effect.
    I'm not sure this is a good way to do it.
    I've seen an icon used here, I think text might be clearer.
  Re searching:
    By default CaseInsensitive, but clicking case_button toggles to sensitive.
    We wrap, i.e. if at end when forward we go to start, if at start when backward we go from end
    This is like what an editor does but an editor goes from statement current pos, we go from start|end.
    Todo: options e.g. "matching )"
  Re highlighting what's found:
    Todo: I'd like to set color and maybe underline as in debug_highlight_line() instead of selecting.
          e.g. muted yellow, and straight underline
    highlight all? or highlight first from cursor? should the cursor move?
    Todo: put a box around the clause
  Re keyPressEvent:
    Maybe looking for Esc is a mistake, it should be a shortcut with default == QKeySequence::Cancel.
    See also keypress_shortcut_handler().
  Re relevant widget:
    We try to use last_focus_widget, i.e. what we saved in menu_activate() when one of the main widgets
    lost focus, regarding that as "current". Make sure cast is legitimate by checking the class name.
    codeEditor is subclass of QPlainTextEit, TextEditHistory and TextEditWidget and TextEditWidge2 are
    subclasses of QTextEdit, if it's anything else then assume statement_edit_widget not last_focus_widget.
    Todo: Show immediately after relevant widget, or in main menu
    If the relevant widget is grid, then we search only in a cell.
    I hoped we'd see more if --ocelot_html=1 but html_text_edit doesn't get seen by filter (?).
  Todo: signal(pressed) and signal(clicked) both seem to work, which should I prefer?
  Todo: in ababaabaab I see 3 occurrences of aba but an editor sees 2
  Todo: Save current focus, see https://forum.qt.io/topic/80019/find-which-widget-had-focus-when-menu-item-is-clicked/8
  Todo: Maybe say "explicit" before Find_widget(...) in ocelotgui.h
  Todo: Do I need to change so next|prev widget won't come to find_widget when it's activated?
  Todo: Maybe say action_close_button_clicked() instead of hide()
  Todo: Change keyboard_shortcut_handler(), you need to handle ^Q but not most other things
  Todo: bug: search for "bl" and see bl is highlighted in statement
             then backspace so the search is only for "b" and see bl is still highlighted in statement
  Todo: There is too much space between the statement widget and the find widget
  Todo: Maybe save space by only loading components when activate, and deleting them when close
  Todo: bug: if a word goes over one line in HTML display, find fails (if I recall right, we added a line feed)
*/

/* called from new Find_widget() which is called just before main_window->setLayout(main_layout) */
void Find_widget::construct()
{
  QStyle *style = qApp->style();
  layout= new QHBoxLayout(this);
  close_button= new QToolButton(this);
  close_button->setIcon(style->standardIcon(QStyle::SP_DialogCancelButton));
  close_button->setToolTip("Close");
  find_label= new QLabel(this);
  QFont f= this->font();
  QFontMetrics fm(f);
  QString s= "Find:";
  s= s.left(s.size() - 1); /* otherwise there's a blank at the end? */
  QRect r= fm.boundingRect(0, 0, 4000, 4000, Qt::TextDontClip, s);
  find_label->setFixedWidth(r.width());
  find_label->setText(s);
  combo_box= new QComboBox(this);
  combo_box->setEditable(true);
  combo_box->setMaxCount(5);
  combo_box->setToolTip("Text to find");
  down_button= new QToolButton(this);
  down_button->setIcon(style->standardIcon(QStyle::SP_ArrowDown));
  down_button->setToolTip("Find next match");
  up_button= new QToolButton(this);
  up_button->setIcon(style->standardIcon(QStyle::SP_ArrowUp));
  up_button->setToolTip("Find previous match");
  case_button= new QToolButton(this);
  case_button->setText("i");
  case_button->setToolTip("Case sensitive search");
  layout->addWidget(close_button);
  layout->addWidget(find_label);
  layout->addWidget(combo_box);
  layout->addWidget(down_button);
  layout->addWidget(up_button);
  layout->addWidget(case_button);
  setLayout(layout);
  connect(combo_box, SIGNAL(currentTextChanged(QString)), this, SLOT(action_combo_box_text_changed(QString)));
  connect(down_button, SIGNAL(clicked()), this, SLOT(action_down_button_clicked()));
  connect(up_button, SIGNAL(pressed()), this, SLOT(action_up_button_clicked()));
  connect(close_button, SIGNAL(pressed()), this, SLOT(action_close_button_clicked()));
  connect(case_button, SIGNAL(pressed()), this, SLOT(action_case_button_clicked()));
  hide();
}

void Find_widget::find_widget_activate()
{
  if (combo_box->currentIndex() > 0) combo_box->setCurrentIndex(0);
  QString s= combo_box->currentText();
  if (s != "")
  {
    combo_box->insertItem(0, s);
    combo_box->setCurrentIndex(0);
    combo_box->setItemText(0, ""); /* setCurrentText(""); didn't work on old Qt */
  }
  enable_or_disable();
  combo_box->setFocus();
  show();
}

void Find_widget::action_close_button_clicked()
{
  hide();
}

/* slot for signal connected with find_widget_activate */
void Find_widget::action_combo_box_text_changed(QString find_text)
{
  (void)find_text;
  enable_or_disable();
  action_find_widget_move(true, true);
}

void Find_widget::action_down_button_clicked()
{
  action_find_widget_move(false, true);
}

void Find_widget::action_up_button_clicked()
{
  action_find_widget_move(false, false);
}

void Find_widget::action_case_button_clicked()
{
  if (case_button->text() == "i") case_button->setText("s");
  else case_button->setText("i");
}

/* called from action_combo_box_text_change|down_arrow_clicked|up_arrow_clicked */
void Find_widget::action_find_widget_move(bool is_from_start, bool is_forward)
{
  QTextCursor c;
  QString s;
  QPlainTextEdit *p_plaintextedit= NULL;
  QTextEdit *p_textedit= NULL;
  const char *class_name= main_window->last_focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
  {
    p_plaintextedit= (QPlainTextEdit *) main_window->last_focus_widget;
    c= p_plaintextedit->textCursor();
    s= p_plaintextedit->toPlainText();
  }
  else if ((strcmp(class_name, "TextEditHistory") == 0)
   || (strcmp(class_name, "TextEditWidget") == 0) /* Todo: This class no longer exists. */
   || (strcmp(class_name, "TextEditWidget2") == 0))
  {
    p_textedit= (QTextEdit *) main_window->last_focus_widget;
    c= p_textedit->textCursor();
    s= p_textedit->toPlainText();
  }
  else if (strcmp(class_name, "Result_qtextedit") == 0)
  {
    p_textedit= (Result_qtextedit *) main_window->last_focus_widget;
    c= p_textedit->textCursor();
    s= p_textedit->toPlainText();
  }
  else
  {
    c= main_window->statement_edit_widget->textCursor();
    s= main_window->statement_edit_widget->toPlainText();
  }
  Qt::CaseSensitivity case_sensitive;
  if (case_button->text() == "i") case_sensitive= Qt::CaseInsensitive;
  else case_sensitive= Qt::CaseSensitive;
  int position_from, position_to;
  if (is_from_start == true) position_from= 0;
  else position_from= c.position();
  QString find_text= combo_box->currentText();
  if (is_forward == true)
  {
    position_to= s.indexOf(find_text, position_from  - (find_text.size() - 1), case_sensitive);
    if (position_to == -1) position_to= s.indexOf(find_text, 0, case_sensitive);
  }
  else
  {
    position_to= s.lastIndexOf(find_text, position_from - (find_text.size() + 1), case_sensitive);
    if (position_to == -1) position_to= s.lastIndexOf(find_text, s.size() - 1, case_sensitive);
  }
  if (position_to != -1)
  {
    c.setPosition(position_to, QTextCursor::MoveAnchor);
    c.setPosition(position_to + find_text.size(), QTextCursor::KeepAnchor);
    if (p_plaintextedit != NULL) p_plaintextedit->setTextCursor(c);
    else if (p_textedit != NULL) p_textedit->setTextCursor(c);
    else main_window->statement_edit_widget->setTextCursor(c);
  }
}

void Find_widget::enable_or_disable()
{
  if (combo_box->currentText() != "")
  {
    up_button->setEnabled(true);
    down_button->setEnabled(true);
  }
  else
  {
    up_button->setEnabled(false);
    down_button->setEnabled(false);
  }
}

void Find_widget::keyPressEvent(QKeyEvent *event)
{
  if (event->key() == Qt::Key_Escape)
  {
    hide();
    return;
  }
  if (main_window->keypress_shortcut_handler(event, false) == true)
  {
    return;
  }
}

#endif
/******************** find_widget end   ************************************/


/******************** result_qtextedit start   ************************************/

/*
  Re setMouseTracking: we want mouseMoveEvent to work.
  Re setDocumentMargin: We want the table to start at left boundary, but it starts at 1 anyway.
  Re possible memory leaks:
    We allow ^Z i.e. we don't setUndoRedoEnabled(false) and that causes a leak danger.
    We might create resources, especially for images, and that too can cause a leak danger
    (See https://stackoverflow.com/questions/34735595/qtextdocument-how-to-remove-a-resource-from-cache).
    and although we could delete (or at least clear) QTextDocument, something might still be forgotten.
    So in display_garbage_collect() we delete result_qtextedit and create it again.
  Todo: why NoWrap? I'm going to some trouble to do my own wrapping!
*/
void Result_qtextedit::construct()
{
  qtextedit_result_changes= NULL; /* to avoid bad "delete" in ~Result_qtextedit */
  explorer_context_menu= NULL;
  setMouseTracking(true);
  document()->setDocumentMargin(0);
  /* test!! Hey it works. But should be an option. */
  setAlignment(Qt::AlignTop | Qt::AlignLeft);
  setWordWrapMode(QTextOption::NoWrap);
  setFrameStyle(QFrame::NoFrame);
  /* Once this was in TextEditWidget */
  this->setContextMenuPolicy(Qt::CustomContextMenu);
#if (OCELOT_EXPLORER == 1)
  if (result_grid->result_grid_type == EXPLORER_WIDGET)
  {
    qtextedit_is_min_max_clicked= false;
    connect(this, SIGNAL(customContextMenuRequested(const QPoint &)),
        this, SLOT(menu_context_t_explorer(const QPoint &)));
  }
  else
#endif
  connect(this, SIGNAL(customContextMenuRequested(const QPoint &)),
      this, SLOT(menu_context_t(const QPoint &)));
  qtextedit_result_changes= new Result_changes(this); /* ~Result_qtextedit() should delete this */
//  show();
#if (OCELOT_EXPLORER == 1)
  if (result_grid->result_grid_type == EXPLORER_WIDGET)
    explorer_context_menu= new Context_menu(result_grid, this);
#endif
}

#ifdef OLD_STUFF
void TextEditFrame::style_sheet_setter(TextEditFrame *text_frame, TextEditWidget *text_edit)
{
  ResultGrid *rg= text_frame ->ancestor_result_grid_widget;
  MainWindow *mw= rg->copy_of_parent;
  QString new_tooltip= "";
  QString new_style_sheet= mw->ocelot_grid_style_string;
  QString new_cell_height= "";
  QString new_cell_width= "";
  int returned_cs_number= 0;
  bool result= rg->conditional_setting_evaluate_till_true(text_frame->ancestor_grid_column_number, text_frame->ancestor_grid_result_row_number, text_frame->content_pointer, text_frame->content_length, text_frame->cell_type, &new_tooltip, &new_style_sheet, &new_cell_height, &new_cell_width, &returned_cs_number);
  if (result == true)
  {
    if (new_tooltip != "") text_edit->setToolTip(new_tooltip);
    QString old_style_sheet= text_edit->styleSheet();
    if (new_style_sheet != old_style_sheet)
    {
      text_edit->setStyleSheet(new_style_sheet);
    }
    if (text_frame->is_style_sheet_set_flag == false)
    {
      text_frame->setStyleSheet(rg->frame_color_setting); /* for drag line color */
      text_frame->is_style_sheet_set_flag= true;
    }
    return; /* !! Too early! We only have evaluated one condition! */
  }
  if (text_frame->is_style_sheet_set_flag == false)
  {
    text_frame->setStyleSheet(rg->frame_color_setting); /* for drag line color */
    if (text_frame->cell_type == TEXTEDITFRAME_CELL_TYPE_HEADER) text_edit->setStyleSheet(mw->ocelot_grid_header_style_string);
    else if (text_frame->cell_type == TEXTEDITFRAME_CELL_TYPE_DETAIL) text_edit->setStyleSheet(mw->ocelot_grid_style_string);
    else text_edit->setStyleSheet(mw->ocelot_extra_rule_1_style_string);
    text_frame->is_style_sheet_set_flag= true;
  }
}
#endif

/*
  Copy a column's contents to an HTML cell i.e. within <TD></TD> and return # of bytes copied.
  We call this for chars not images.
  Todo: Change < to &lt; > to &gt; & to &amp; but it seems unnecessary to change " to &quot;
  Todo: pass width, wrap if width exceeded by adding <BR>
  Todo: pass height, this is our maximum number of lines (else we cut off? else we add a scroll bar?)
        or: no, height is fixed number of pixels, in case user insisted on fixed height with SET
        but height can be 'any'
  Todo: pass font. Life is easier if it's fixed-font.
  Todo: call this for headers too (or are they different?) (must we pass #-of-lines?)
  Todo: pass flags:
        1 replace < and > and & with character entities
        2 wrap if width exceeded by adding <BR>
        4 this is a header, although I don't see what that would change
  Todo: Allow #-of-bytes * 5 when allocating for tmp because it might be all &&&&&s and <BR>s are needed
        (this might have to be regarded as a temporary solution) (we're allocating * 5 in display_html)
  Todo: replace \n with <br>, and allow <> if <br>
  We're replacing
    memcpy(tmp_pointer, pointer, v_length);
    tmp_pointer+= v_length;
  with
    tmp_pointer+= html_text_edit->copy_html_cell(tmp_pointer, pointer, v_length);
  Todo: Using max_width_of_a_char is not exact enough, we should call boundingRect()
  Todo: we're always passing the same font, we should be looking for a conditionally changed font
  Todo: BUG: in order to get wrapping right, I have to first do a select with ocelot_html = 0.
  Todo: I think it's always TEXTEDITFRAME_CELL_TYPE_DETAIL now so you don't need to pass it and check it.
  Todo: BUG: width isn't being set for numeric columns, which is why column drag fails for numeric columns.
  Todo: For an image, we assume height < max_height_of_a_char*2 is default and ignore it. We should check.
  Todo: re ocelot_grid_html_settings:
        Specialize e.g. it could be 'italics' or '<i>' to recognize only italics.
        bug: If we put a <br> in order to increase height, it wrecks something between <i> and </i>.
        We should calculate width without the html markup, otherwise column can be too wide.
        When documenting, give example = select '<p style="color:red">' || 'x' || '</p>'; which is HTML 4.
        Or select '<p style="color:red">' || 'x' || '</p>' AS "<i>BIG HEADER IN ITALICS</i>";
*/
int Result_qtextedit::copy_html_cell(char *ocelot_grid_detail_numeric_column_start,
                                     char *ocelot_grid_detail_char_column_start,
                                     char *tmp_pointer,
                                     char *result_pointer, /* result_field_names_pointer or result_set_pointer */
                                     char result_set_value_flags, /* e.g. FIELD_VALUE_FLAG_IS_NULL */
                                     int v_length,
                                     int cell_type,
                                     int width_n,
                                     int height_n,
                                     QFont font,
                                     int max_width_of_a_char,
                                     int grid_column_no,
                                     long unsigned int tmp_result_row_number,
                                     char *ocelot_grid_detail_char_column_end,
                                     int *new_cell_height_as_int,
                                     unsigned int result_column_no)
{
  (void)ocelot_grid_detail_numeric_column_start;
  (void)font;
  *new_cell_height_as_int= -1; /* default */
  char *original_tmp_pointer= tmp_pointer;
  bool is_image= false;
  /* Todo: Actually, maybe is_image(result_column_no) would be correct regardless of vertical value. */
  if (result_grid->copy_of_ocelot_vertical == 0)
  {
    if (result_grid->is_image(grid_column_no) == true)
    {
      is_image= true;
    }
  }
  else
  {
    if (result_grid->is_image(result_column_no) == true)
    {
      is_image= true;
    }
  }
  QByteArray f= qtextedit_result_changes->find(tmp_result_row_number, result_column_no);
  if (f.size() > 1)
  {
    is_image= true; /* image paste experiment */
    result_pointer= (char*) f.constData();  /* image paste experiment */
    v_length= f.size();  /* image paste experiment */
  }
  /* How can this be right if v_length and result_pointer get adjusted afterward? Well, VALUE='...' doesn't work. */
  /* Todo: This is supposed to be applicable to header too, no? */
  /* TEST!!! start: See whether we can change color, at least. HTML only! */
  QString new_tooltip= "";
  QString new_style_sheet;
#if (OCELOT_EXPLORER == 1)
  if (result_grid->result_grid_type == EXPLORER_WIDGET)
    new_style_sheet= result_grid->copy_of_parent->ocelot_explorer_style_string;
  else
#endif
    new_style_sheet= result_grid->copy_of_parent->ocelot_grid_style_string;
  QString new_cell_height= "";
  QString new_cell_width= "";
  int returned_cs_number= 0;
  bool result= result_grid->conditional_setting_evaluate_till_true(
       result_column_no, /* i.e. result set column number */
       tmp_result_row_number, /* text_edit_frames[text_edit_frames_index]->ancestor_grid_result_row_number, */
       result_pointer, /* result_field_names_pointer or result_set_pointer or image paste experiment */
       result_set_value_flags,
       v_length, /* text_edit_frames[text_edit_frames_index]->content_length, */
       TEXTEDITFRAME_CELL_TYPE_DETAIL, /* text_edit_frames[text_edit_frames_index]->cell_type, */
       &new_tooltip, &new_style_sheet, &new_cell_height, &new_cell_width, &returned_cs_number);
//  char tmp_new_style_sheet[640];
//  strcpy(tmp_new_style_sheet, new_style_sheet.toUtf8());
  if ((result == true) && (new_cell_height != ""))
  {
    int nchi= result_grid->get_cell_width_or_height_as_int(new_cell_height, result_grid->max_height_of_a_char);
#if (OCELOT_EXPLORER == 1)
    if ((nchi == 0) && (result_grid->result_grid_type == EXPLORER_WIDGET))
    {
      *new_cell_height_as_int= 0;
    }
#endif
    if ((nchi > 0)
     && (QString::compare("default", new_cell_height, Qt::CaseInsensitive) != 0))
      *new_cell_height_as_int= nchi;
  }
  /*
    Although we pass ocelot_grid_detail_numeric_column_start and ocelot_grid_detail_char_column_start,
    we ignore them because we must add <width=...> in either case so what we really will want is
    <TD width=...> or <TD width=...; align="right">
  */
  /* TODO: SET THE RIGHT WIDTH IN THE FIRST PLACE! */
  unsigned int width_i= width_n; /* instead of result_grid->grid_column_widths[grid_column_no]; */
  /* If conditional setting is true and has a width setting clause, use that instead of normal value. */
  if ((result == true) && (new_cell_width != ""))
  {
    int new_cell_width_as_int= result_grid->get_cell_width_or_height_as_int(new_cell_width, result_grid->character_count_to_pixel_count(MIN_WIDTH_IN_CHARS));
    if (new_cell_width_as_int > 0) width_i= new_cell_width_as_int;
  }
  {
    width_i-= result_grid->setting_ocelot_grid_cell_border_size_as_int * 2;
//    width_i-= result_grid->setting_ocelot_grid_cell_drag_line_size_as_int;
    char bgcolor[64];
    if (((int) tmp_result_row_number == result_grid->focus_result_row_number) && ((int) grid_column_no == result_grid->focus_column_number - 1))
    {
      char color_name[32];
      strcpy(color_name, result_grid->copy_of_parent->ocelot_grid_focus_cell_background_color.toUtf8());
      sprintf(bgcolor, "bgcolor='%s'; ", color_name);
    }
    else bgcolor[0]= '\0';
    char tmp_td[128];

    if (memcmp(ocelot_grid_detail_char_column_start, "<TH", 3) == 0)
      sprintf(tmp_td, "<TH align='left'; width=%d>", width_i);
    else
    {
      if ((result_grid->result_field_flags[result_column_no] & NUM_FLAG) != 0)
        sprintf(tmp_td, "<TD %salign='right'; width=%d>", bgcolor, width_i);
      else
        sprintf(tmp_td, "<TD %swidth=%d>", bgcolor, width_i);
    }

    strcpy(tmp_pointer, tmp_td);
    tmp_pointer+= strlen(tmp_td);
  }
  if (result == true)
  {
    char tmp_div[32];
    sprintf(tmp_div, "<div class=\"E%d\">", returned_cs_number);
    memcpy(tmp_pointer, tmp_div, strlen(tmp_div));
    tmp_pointer+= strlen(tmp_div);
  }
  /* TEST!!! end */
  if ((cell_type == TEXTEDITFRAME_CELL_TYPE_DETAIL) && (is_image == true))
  {
    char img_type[4];
    result_grid->set_img_type(result_pointer, v_length, img_type); /* so img_type = "" or "png" or "jpg" or "gif" */
    if (strcmp(img_type,"") != 0)
    {
      char *base64_tmp;
      base64_tmp= new char[(v_length * 4) / 3 + 64];
      QByteArray data= QByteArray::fromRawData(result_pointer, v_length);
      strcpy(base64_tmp, data.toBase64());
      char img_start[64];
      unsigned int height_candidate= height_n;
      if (*new_cell_height_as_int != -1) height_candidate= *new_cell_height_as_int;
      if (height_candidate > result_grid->max_height_of_a_char * 2)
        sprintf(img_start, "<img width=%d height=%d src=\"data:image/", width_i, height_candidate);
      else
        sprintf(img_start, "<img width=%d src=\"data:image/", width_i);
      /* IMAGE TEST!!!! What happens if I don't say what the width is? */
      if (grid_column_no > 0)
      {
          sprintf(img_start, "<img src=\"data:image/");
      }
      /* TEST!!!! end */

      strcpy(tmp_pointer, img_start);
      tmp_pointer+= strlen(img_start);
      memcpy(tmp_pointer, img_type, 3);
      tmp_pointer+= 3;
      memcpy(tmp_pointer, ";base64,", 8);
      tmp_pointer+= 8;
      memcpy(tmp_pointer, base64_tmp, strlen(base64_tmp));
      tmp_pointer+= strlen(base64_tmp);
      memcpy(tmp_pointer, "\"/>", 3);
      tmp_pointer+= 3;
      {
        /* TEST!! */
        *tmp_pointer= '\0';
      }
      delete base64_tmp;
    }
    return tmp_pointer - original_tmp_pointer;
  }
  char c;
  QString s;
  int column_width_in_chars= (width_n / max_width_of_a_char); /* TEST!!!! */
  if (column_width_in_chars < 1) column_width_in_chars= 1;
  for (int i= 0, j= 0; i < v_length; ++i)
  {
    c= *result_pointer;
    ++result_pointer;
    /* todo: check here if flag & 2 */
    if ((c & 0xc0) != 0x80) /* 10xxxxxx is a continuation byte so don't count as another character */
    {
      if ((j != 0) && ((j % column_width_in_chars) == 0))
      {
        memcpy(tmp_pointer, "<br>", 4);
        tmp_pointer+= 4;
      }
      ++j;
    }
    {
      bool is_special_char= false;
      if (c == '\0') {memcpy(tmp_pointer, "&#0;", 4); tmp_pointer+= 4; is_special_char= true;}
      if (result_grid->copy_of_parent->ocelot_grid_html_effects != "yes")
      {
        if (c == '<') {memcpy(tmp_pointer, "&lt;", 4); tmp_pointer+= 4; is_special_char= true;}
        else if (c == '>') {memcpy(tmp_pointer, "&gt;", 4); tmp_pointer+= 4; is_special_char= true;}
        else if (c == '&') {memcpy(tmp_pointer, "&amp;", 5); tmp_pointer+= 5; is_special_char= true;}
      }
      if (is_special_char == false) {*tmp_pointer= c; ++tmp_pointer;}
    }
  }
  /* TODO: This looks like dead code since we have copied already and we won't increment tmp_pointer here */
  memcpy(tmp_pointer, result_pointer, v_length);

  if (result == true)
  {
    strcpy(tmp_pointer, "</div>");
    tmp_pointer+= strlen("</div>");
  }
  strcpy(tmp_pointer, ocelot_grid_detail_char_column_end);
  tmp_pointer+= strlen(ocelot_grid_detail_char_column_end);
  return tmp_pointer - original_tmp_pointer;
}

/*
  Copy in result grid cell. We get here via menu_edit_copy(), not overriding QtextEdit::copy().
     If the cell has text then we did setText() and QTextEdit::copy() should work okay.
    The reason that we reimplement copy(), and call it from QKeySequence, is:
    for images we do not do setText(). So we (?) have to loadfromData again and
    put in the clipboard as a pixmap.
    This can be called via QKeySequence (default ^C), menu, or via right-click RightButton see menu_context.
    This gets the entire unclipped image because we're reloading from the source.
    Todo: check for nulls.
    Todo: decide whether we care about select() before copy().
          If it's an image, Copy is enabled even if there's no selection.
    Todo: With Qt4, when program ends, if there was a copy, we might see
          "QClipboard: Unable to receive an event from the clipboard manager in a reasonable time"
          which might be like https://bugreports.qt.io/browse/QTBUG-32853.
 */

/*
It's solved -- see TEST! stuff in cell_analyze(). You just need to transfer some of the code to here.
However, loadFromData as used by TextEditWidget::copy() might have some use too.
Also I'm not really sure it's good enough to copy the cell without selecting it.
*/

void Result_qtextedit::copy()
{
  //if (qtextedit_cell_content == U+FFFC) /* fffc = Unicode object replacement character */
  //{
  //  printf("FFFC\n");
  //  exit(0);
  //}

  QTextEdit::copy();
#ifdef OLD_STUFF
  void TextEditWidget::copy()
  {
    if ((text_edit_frame_of_cell->is_image_flag == true)
    &&  (text_edit_frame_of_cell->content_pointer != 0))
    {
      QPixmap p= QPixmap();
      if (p.loadFromData((const uchar*) text_edit_frame_of_cell->content_pointer,
                         text_edit_frame_of_cell->content_length,
                         0,
                         Qt::AutoColor) == false)
      {
        /* Not readable as an image. Maybe text. Maybe null. */
        QClipboard *p_clipboard= QApplication::clipboard();
        p_clipboard->setText(QString::fromUtf8(text_edit_frame_of_cell->content_pointer,
                             text_edit_frame_of_cell->content_length));
      }
      else
      {
        QClipboard *p_clipboard= QApplication::clipboard();
        p_clipboard->setPixmap(p);
      }
    }
    else QTextEdit::copy();
#endif
}

void Result_qtextedit::changeEvent(QEvent *event)
{
  event->ignore();
}


void Result_qtextedit::closeEvent(QCloseEvent *event)
{
  QTextEdit::closeEvent(event);
}

void Result_qtextedit::focusInEvent(QFocusEvent *event)
{
  if (result_grid->is_fancy() == false){ QTextEdit::focusInEvent(event); return; }
  result_grid->copy_of_parent->menu_activations(this, QEvent::FocusIn);
  QTextEdit::focusInEvent(event);
#ifdef OLD_STUFF
  /* from texteditwidget::focusInEvent() */
  TextEditFrame *t= text_edit_frame_of_cell;
  ResultGrid *r=  t->ancestor_result_grid_widget;
  MainWindow *m= r->copy_of_parent;
  m->menu_activations(this, QEvent::FocusIn);
  /* We probably don't need to say this. */
  QTextEdit::focusInEvent(event);
#endif
}

/* Add ' at start and end of a string. Change ' to '' within string. Compare connect_stripper(). */
/* mysql_hex_string() might be useful for some column types here */
QString Result_qtextedit::unstripper(QString value_to_unstrip)
{
  QString s;
  QString c;

  s= "'";
  for (int i= 0; i < value_to_unstrip.count(); ++i)
  {
    c= value_to_unstrip.mid(i, 1);
    s.append(c);
    if (c == "'") s.append(c);
  }
  s.append("'");
  return s;
}

/*
  Pass: row_number from display, probably qtextedit_grid_row_number
  Return: row_number from result set, usually a simple calculation
*/
int Result_qtextedit::result_row_number_from_grid_row_number(int grid_row_number)
{
#if (OCELOT_EXPLORER == 1)
  /* There might have been skipping and scrolling. Todo: what if for some reason nothing is found? */
  if (result_grid->result_grid_type == EXPLORER_WIDGET)
  {
    unsigned int local_grid_row_number= 0;
    unsigned int r;
    for (r= result_grid->explorer_first_result_row; r < result_grid->copy_of_parent->oei_count; ++r)
    {
      if (result_grid->copy_of_parent->oei[r].display_row_number != -1)
      {
        if ((unsigned int) grid_row_number == local_grid_row_number) break;
        ++local_grid_row_number;
      }
    }
    return r;
  }
#endif
  int result_row_number= grid_row_number + result_grid->grid_vertical_scroll_bar->value();
  if (result_grid->copy_of_ocelot_vertical == 1)
  {
    result_row_number= result_row_number / result_grid->result_column_count;
  }
  else
  {
    if (result_grid->ocelot_result_grid_column_names_copy == 1) --result_row_number;
  }

  return result_row_number;
}

/*
  Pass: row_number from result set
  Return: row_number on grid, or -1 if it's not on grid
          If it's before the first grid row, it's negative, that's okay.
          If it's after the last grid row i.e. max_display_rows in display_html(), that's okay.
*/
int Result_qtextedit::grid_row_number_from_result_row_number(int result_row_number)
{
  int grid_row_number;
  if (result_grid->copy_of_ocelot_vertical == 1)
  {
    grid_row_number= (result_row_number * result_grid->result_column_count) - result_grid->grid_vertical_scroll_bar->value();
  }
  else
  {
    grid_row_number= result_row_number - result_grid->result_column_count;
    if (grid_row_number >= 0)
    {
      if (result_grid->ocelot_result_grid_column_names_copy == 1) ++grid_row_number;
    }
  }
  return grid_row_number;
}

///*
//  Pass: column_number from display, probably qtextedit_grid_column_number
//  Return: column_number from result set, usually a simple calculation
//  Todo: I forget why grid_row_number starts at 1, find out. Apparently minimum column number is 0.
//  In the end we decided not to use this.
//*/
//int Result_qtextedit::result_column_number_from_grid_column_number(int grid_row_number, int grid_column_number)
//{
//  int result_column_number;
//  if (result_grid->copy_of_ocelot_vertical == 1)
//  {
//    --grid_row_number;
//    result_column_number= grid_row_number % result_grid->result_column_count;
//  }
//  else
//  {
//    result_column_number= grid_column_number;
//  }
//  return result_column_number;
//}


/* Taken from TextEditWidget::generate_update() */
/*
  If the user changes the contents of a cell, that indicates a desire to update the row.
  Make a statement: UPDATE table SET changed-columns WHERE short-columns.
  Re WHERE clause:
    Ideally there is a set of columns in the result set which
    appear in a unique not-null index, such as a primary-key index.
    But we don't check for that! We merely check for values which
    are shorter than 128 bytes (thus avoiding most BLOB searches).
    If we get 50 thousand hits, so be it, the user asked for it.
    Alternative: we could put a LIMIT on.
    Alternative: we could SELECT first, and then UPDATE.
    Alternative: we could UPDATE, then ROLLBACK to savepoint if too many.
    Alternative: we could select from information_schema.statistics.
  TODO: figure out what to do with the string -- is it a hint? does it go direct to statement?
        Perhaps: when the user clicks on a different row, or tries to leave: suggest it.
  TODO: If it's binary or blob, we should do the editing as 0x... rather than '...'.
  TODO: Trail spaces should not matter for char, should matter for binary.
  TODO: I am not distinguishing between NULL and 'NULL'
  TODO: If the SELECT originally had a search-condition X = literal, you could incorporate that
  TODO: If different columns come from different tables, update is impossible, do nothing
  TODO: I don't know why I see result_column_count rather than gridx_column_count here
  Re ^Z: It didn't work anyway and I set undoRedoEnabled=false.
*/
#define MAX_WHERE_CLAUSE_LITERAL_SIZE 128   /* arbitrary. maybe should be user-settable. */
void Result_qtextedit::generate_update()
{
  QString content_in_result_set;
  QString content_in_text_edit_widget;
  QString name_in_result_set;
  QString update_statement, where_clause;

  // already done. ResultGrid *result_grid= text_edit_frame_of_cell->ancestor_result_grid_widget;
  MainWindow *m= result_grid->copy_of_parent;
  /* Todo: look for text_edit_frame_of_cell->is_image_flag == true -- if so, byte array */

  /* Todo: This is row# within display. So it is offset. Translate to row# within result set. */
  int xrow;
  xrow= qtextedit_grid_row_number;
  ++xrow; /* possible bug: should this be done if there's no header row? */
  /* Go up the line to find first text_edit_frame for the row */
  /* Content has changed since the last keyPressEvent. */
  /* column number = text_edit_frame_of_cell->ancestor_grid_column_number */
  /* length = text_edit_frame_of_cell->content_length */
  /* field_value_flags = null, numeric, etc. */
  /* *content = text_edit_frame_of_cell->content_pointer, which should be 0 for null */
  update_statement= "";
  where_clause= "";
  char *name_pointer, *table_pointer, *db_pointer;
  unsigned int name_length, table_length, db_length;
  char *field_names_pointer, *org_tables_pointer, *dbs_pointer;
  field_names_pointer= result_grid->result_original_field_names;
  org_tables_pointer= result_grid->result_original_table_names;
  dbs_pointer= result_grid->result_original_database_names;
  unsigned int column_number;
  unsigned int tefi= 0; /* was: text_edit_frame_index_of_first_cell; */

  /* Row# in result set = Row# in display but offset by vertical scroll bar */
  int result_set_row_number= result_row_number_from_grid_row_number(qtextedit_grid_row_number);

  /* Given Row# point to result set row. We'll go through its columns in the loop. */
  char *result_set_copy_pointer;
  result_set_copy_pointer= result_grid->result_set_copy_rows[result_set_row_number];
  for (column_number= 0; column_number < result_grid->result_column_count; )
  {
    /* NB: Don't continue i.e. skip until you move result_set_copy_pointer forward. */
    //char *p= result_set_copy_pointer; /* so p is looking at v_length, flags, contents */
    unsigned int column_v_length;
    char field_value_flags;
    char *column_value;
    memcpy(&column_v_length, result_set_copy_pointer, sizeof(unsigned int));
    field_value_flags= *(result_set_copy_pointer + sizeof(unsigned int));
    column_value= result_set_copy_pointer + sizeof(unsigned int) + 1;
    result_set_copy_pointer+= sizeof(unsigned int) + 1 + column_v_length;
    /* Todo: You must skip if it's a header */
    //text_edit_frame= result_grid->text_edit_frames[tefi];
    //if (text_edit_frame->cell_type == TEXTEDITFRAME_CELL_TYPE_HEADER)
    //{
    //  ++tefi;
    //  continue;
    //}
    memcpy(&name_length, field_names_pointer, sizeof(unsigned int)); /* Checked */
    field_names_pointer+= sizeof(unsigned int);
    name_pointer= field_names_pointer;
    field_names_pointer+= name_length;
    memcpy(&table_length, org_tables_pointer, sizeof(unsigned int)); /* Checked */
    org_tables_pointer+= sizeof(unsigned int);
    table_pointer= org_tables_pointer;
    org_tables_pointer+= table_length;
    memcpy(&db_length, dbs_pointer, sizeof(unsigned int));            /* Not checked. Meaningless if Tarantool */
    dbs_pointer+= sizeof(unsigned int);
    db_pointer= dbs_pointer;
    dbs_pointer+= db_length;
    /* if in UNION or column-expression, or literal, skip it */
    if ((name_length == 0) || (table_length == 0) || (db_length == 0))
    {
      ++column_number;
      ++tefi;
      continue;
    }
    bool is_null= false;
    int l= 0;
    if ((field_value_flags & FIELD_VALUE_FLAG_IS_NULL) != 0) is_null= true; /* distinguish blank from null */
    else
    {
      l= column_v_length;
      content_in_result_set= QString::fromUtf8(column_value, l);
    }
    name_in_result_set= QString::fromUtf8(name_pointer, name_length);
    if (l <= MAX_WHERE_CLAUSE_LITERAL_SIZE)
    {
      if (where_clause == "") where_clause= " WHERE ";
      else where_clause.append(" AND ");
      where_clause.append(name_in_result_set);
      if (is_null == true) where_clause.append(" IS NULL"); /* or check content_field_value_flags */
      else
      {
        where_clause.append("=");
        QString s;
        //if (result_grid->result_field_types[column_number] <= OCELOT_DATA_TYPE_DOUBLE)
        if (field_value_flags == FIELD_VALUE_FLAG_IS_NUMBER)
          s= content_in_result_set;
        else s= unstripper(content_in_result_set);
        where_clause.append(s);
      }
    }
    if (true) /* was: if (text_edit_frame->is_retrieved_flag == true) */
    {
      bool contents_changed_flag= true;
      if ((field_value_flags & FIELD_VALUE_FLAG_IS_IMAGE) != 0)
      {
        /* Todo: I'm assuming we changed the pointers and came in via paste(). I could be wrong. */
        /* Todo: use p, I think it is the same as content_pointer */
        int content_length= column_v_length;
        char *content_pointer= column_value;
        content_in_text_edit_widget="X'";
        char tmp[3];
        for (int i= 0; i < content_length; ++i)
        {
          sprintf(tmp, "%02X", (unsigned char) *(content_pointer+i));
          content_in_text_edit_widget.append(tmp);
        }
        content_in_text_edit_widget.append("'");
        /* TODO: THIS IS JUST A GUESS! */
        contents_changed_flag= true;
      }
      else
      {
        /* Todo: I think this works because we don't change the pointers, but that will change. */
          QTextDocument *qt;
          qt= document();
          QTextBlock qtb;
          /* Todo: Mystery! Why "+ 2"? I calculate it should be "+ 1". */
          int qtb_number= (qtextedit_grid_row_number * (result_grid->result_column_count + 1)) + 2 + column_number;
          qtb= qt->findBlockByNumber(qtb_number);
        content_in_text_edit_widget= qtb.text();

        if ((is_null == true) && (content_in_text_edit_widget == NULL_STRING)) contents_changed_flag= false;
        else if (content_in_text_edit_widget == content_in_result_set) contents_changed_flag= false;
      }
      if (contents_changed_flag == true)
      {
        if (update_statement == "")
        {
          update_statement= "/* generated */ UPDATE ";
          if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) == 0)
          {
            update_statement.append(QString::fromUtf8(db_pointer, db_length));
            update_statement.append(".");
          }
          update_statement.append(QString::fromUtf8(table_pointer, table_length));
          update_statement.append(" SET ");
        }
        else update_statement.append(",");
        update_statement.append(name_in_result_set);
        update_statement.append('=');
        //if ((result_grid->result_field_types[column_number] <= OCELOT_DATA_TYPE_DOUBLE)
        if ((field_value_flags == FIELD_VALUE_FLAG_IS_NUMBER)
        || (content_in_text_edit_widget == NULL_STRING)
        || ((field_value_flags & FIELD_VALUE_FLAG_IS_IMAGE) != 0))
          update_statement.append(content_in_text_edit_widget);
        else update_statement.append(unstripper(content_in_text_edit_widget));
      }
    }
    ++column_number;
    ++tefi;
  }
  /* We've got a string. If it's not blank, put it in the statement widget, overwriting. */
  /* It might be blank because user returned to the original values, if so wipe out. */
  CodeEditor *c= m->statement_edit_widget;
  if (update_statement != "")
  {
    update_statement.append(where_clause);
    update_statement.append(";");
    c->setPlainText(update_statement);
  }
  else
  {
    if (c->toPlainText().mid(0, 23) == "/* generated */ UPDATE ") c->setPlainText("");
  }
}

/*
  Todo: see what we do with main widgets when they lose focus
  Todo: I'm not even sure that we get here, maybe event filter catches focusOutEvent
        (Update: we do get here when showing explorer and right-clicking to get context menu)
  Todo: If we did a mousepress then the cursor is blinking. Figure out how to turn it off
*/
#ifdef OLDSTUFF
TextEditFrame *t= text_edit_frame_of_cell;
ResultGrid *r=  t->ancestor_result_grid_widget;
MainWindow *m= r->copy_of_parent;
m->menu_activations(this, QEvent::FocusOut);
/* We probably don't need to say this. */
QTextEdit::focusOutEvent(event);
#endif
void Result_qtextedit::focusOutEvent(QFocusEvent *event)
{
  if (result_grid->is_fancy() == false) { QTextEdit::focusOutEvent(event); return; }
  result_grid->copy_of_parent->menu_activations(this, QEvent::FocusOut);
}

/*
  User pressed a key on result grid. It might be for shortcut, it might be editing.
  It doesn't supply event-x() or event-y() so we depend on what we saved during mouseMoveEvent.
  Perhaps we could have used QCursor position instead and translated global to local.
  Mostly copied from void TextEditWidget::keyPressEvent(QKeyEvent *event)
  todo: call event->ignore() if cursor at end | between cells, or if event->key() == Qt::Key_Enter, etc.
        (or maybe I mean event->accept()? but that's default anyway)
  Todo: maybe there is a smarter way to detect if cell is for header? texteditframe_cell_type_header?
*/

void Result_qtextedit::keyPressEvent(QKeyEvent *event)
{
  if (result_grid->is_fancy() == false) { QTextEdit::keyPressEvent(event); return; }
  if (result_grid->result_grid_type == EXPLORER_WIDGET)
  {
    QKeyEvent *key= event;
//    if (key->key() == Qt::Key_Down) ...
    if ((key->key() == Qt::Key_Up) || (key->key() == Qt::Key_Down))
    {
      int frrn= result_grid->focus_result_row_number;            /* = result row of current focus */
      /* skip if frrn = 0 already? */
      int prev_visible= -1;
      int next_visible= -1;
      int fdrn= result_grid->copy_of_parent->oei[frrn].display_row_number;       /* = focus's display row number */
      for (unsigned int i= 0; i < result_grid->copy_of_parent->oei_count; ++i)     /* go through oei skipping invisibles */
      {
        int n= result_grid->copy_of_parent->oei[i].display_row_number;
        if (n != -1)
        {
          if (n == fdrn - 1) { prev_visible= i; }
          if (n == fdrn + 1) { next_visible= i; }
          if (n == fdrn) { ; }
        }
      }
      int gvsbv= result_grid->grid_vertical_scroll_bar_value;
      if (key->key() == Qt::Key_Up)
      {
        if (prev_visible == -1) return;
        fdrn= prev_visible;
        int fdrid= result_grid->explorer_first_result_row;
        if (fdrn < fdrid)
        {
          result_grid->focus_result_row_number= fdrn;
          result_grid->grid_vertical_scroll_bar->triggerAction(QAbstractSlider::SliderSingleStepSub);
          return; /* explorer_display_html should be done by vertical_scroll_bar_event() */
        }
      }
      else
      {
        if (next_visible == -1) return;
        fdrn= next_visible;
        int fdrid= result_grid->explorer_first_result_row;
        int fddid= result_grid->copy_of_parent->oei[fdrid].display_row_number;
        unsigned int last_row_in_display=  fddid + result_grid->html_max_grid_rows;
        unsigned int this_row_in_display=  result_grid->copy_of_parent->oei[fdrn].display_row_number;
        if (this_row_in_display == last_row_in_display)
        {
          int fdrn_new_value= result_grid->copy_of_parent->oei[fdrn].display_row_number;
          result_grid->focus_result_row_number= fdrn;
          result_grid->grid_vertical_scroll_bar->setValue(fdrn_new_value);
          return; /* explorer_display_html should be done by vertical_scroll_bar_event() */
        }
      }
      result_grid->focus_result_row_number= fdrn; /* we get here if we don't need to scroll */
      result_grid->explorer_display_html(gvsbv);
    }
//    /* assume accept() */
    return;
  }
  MainWindow *m= result_grid->copy_of_parent;

  /* TEXT!!!! TODO: I DO NOT KNOW WHAT THIS WAS FOR. MAYBE IT SHOULD BE RESTORED. */
  // if (m->keypress_shortcut_handler(event, true) == true)
  //{
  //  printf("**** keypress_shortcut_handler(true) returned true\n");
  //  copy();
  //  return;
  //}

  if (m->keypress_shortcut_handler(event, false) == true)
  {
    /* Todo: shortcut but not ignore. Am I supposed to accept? */
    return;
  }
  QString content_in_cell_before_keypress= qtextedit_cell_content;
  bool is_printable= true;
  if (qtextedit_at_end == true) {is_printable= false; }
  if (qtextedit_is_before_column == true) {is_printable= false; }
  if (qtextedit_is_before_row == true) {is_printable= false; }
  if (qtextedit_column_number == 0) {is_printable= false; }
  if (qtextedit_y < (int) (result_grid->setting_ocelot_grid_cell_border_size_as_int)) {is_printable= false; }
  if (result_grid->is_image(qtextedit_column_number) == true) {is_printable= false; }
  if (result_grid->copy_of_ocelot_result_grid_column_names == 1)
  {
    if (result_grid->copy_of_ocelot_vertical == 1)
    {
      if (((qtextedit_column_number - 1) % 2) == 0)
      {
        is_printable= false;
      }
    }
    else
    {
      if (qtextedit_grid_row_number == 0)
      {
        is_printable= false;
      }
    }
  }

  if (result_grid->copy_of_ocelot_result_grid_column_names == 1)
  {
    if (result_grid->copy_of_ocelot_vertical == 1)
    {
      if (((qtextedit_column_number - 1) % 2) == 0)
      {
        is_printable= false;
      }
    }
    else
    {
      if (qtextedit_grid_row_number == 0)
      {
        is_printable= false;
      }
    }
  }

  Qt::KeyboardModifiers modifiers= event->modifiers();
  if ((modifiers & Qt::ControlModifier) != 0) {is_printable= false; }
  if ((modifiers & Qt::ShiftModifier) != 0)  {; }
  if ((modifiers & Qt::AltModifier) != 0)  {is_printable= false; }
  if ((modifiers & Qt::MetaModifier) != 0)  {is_printable= false; }

  if (is_printable == false) return;

  QTextEdit::keyPressEvent(event);

  cell_analyze(qtextedit_x, qtextedit_y); /* keypress might cause cursor movement but still within column (?) */
  QString content_in_cell_after_keypress= qtextedit_cell_content;
  if (content_in_cell_before_keypress != content_in_cell_after_keypress)
  {
    generate_update();
  }
}

//void Result_qtextedit::key_up_or_down(QKeyEvent *event)
//{
//  ;
//}

/*
  Cell content = qtextedit_cell_content, unless it's an image.
  But we will need to somehow track and get rid of <br>s which will show p as \n.
*/
QString Result_qtextedit::to_plain_text()
{
  return "";
}

void Result_qtextedit::mouseDoubleClickEvent(QMouseEvent *event)
{
#if (OCELOT_EXPLORER == 1)
  if (result_grid->result_grid_type == EXPLORER_WIDGET)
  {
    cell_analyze(event->pos().x(), event->pos().y());
    /* Append to statement_edit_text! Compare completer_widget::mouseDoubleClickEvent */
    QString text= result_grid->copy_of_parent->statement_edit_widget->toPlainText();
    text= text + qtextedit_cell_content;
    result_grid->copy_of_parent->statement_edit_widget->setPlainText(text);
  }
#endif
  QTextEdit::mouseDoubleClickEvent(event);
}

void Result_qtextedit::mouseMoveEvent(QMouseEvent *event)
{
  if (result_grid->is_fancy() == false) { QTextEdit::mouseMoveEvent(event); return; }
  cell_analyze(event->pos().x(), event->pos().y());
  QString tip= "";
  //tip= tip + "block_count=" + QString::number(qtextedit_block_count);
  //tip= tip + " columns_per_row=" + QString::number(qtextedit_columns_per_row);
  tip= tip + " x=" + QString::number(qtextedit_x);
  tip= tip + " y=" + QString::number(qtextedit_y);
  //tip= tip + " Block=" + QString::number(qtextedit_block_number);
  tip= tip + " Grid_Row=" + QString::number(qtextedit_grid_row_number);
  tip= tip + " Result_row=" + QString::number(qtextedit_result_row_number);
  tip= tip + " Column  " + QString::number(qtextedit_column_number);
  if (qtextedit_is_before_column) tip= tip + " (is_before_column)";
  if (qtextedit_is_before_row) tip= tip + " (is_before_row)";
  tip= tip + " x_start= " + QString::number(qtextedit_x_start);
  tip= tip + " x_end= " + QString::number(qtextedit_x_end);
  tip= tip + " y_start= " + QString::number(qtextedit_y_start);
  tip= tip + " y_end= " + QString::number(qtextedit_y_end);
  //tip= tip + " content=" + qtextedit_cell_content; removed because big contents cause slowdown

#if (OCELOT_EXPLORER == 1)
  if ((result_grid->result_grid_type == EXPLORER_WIDGET)
   && (qtextedit_at_end == false))
  {
    /* Todo: probably this lookup method is duplicated somewhere, and is more complete somewhere. */
    QString row_type= result_grid->copy_of_parent->oei[qtextedit_result_row_number].object_type;
    if (row_type == "S") tip= "Schema";
    if (row_type == "T") tip= "Table";
    if (row_type == "V") tip= "View";
    if (row_type == "C") tip= "Column";
    if (row_type == "I") tip= "Index";
    if (row_type == "F") tip= "Function";
    if (row_type == "P") tip= "Procedure";
    if (row_type == "R") tip= "Trigger";
    tip= tip + ". Right-click to see context menu. ";
  }
#endif
  if (qtextedit_at_end == true) tip= tip + " (At End)"; /* If this is so, nothing else matters */

  setToolTip(tip);
  if (qtextedit_is_before_column) viewport()->setCursor(Qt::SizeHorCursor);
  else if (qtextedit_is_before_row) viewport()->setCursor(Qt::SizeVerCursor);
  else viewport()->unsetCursor();
  QTextEdit::mouseMoveEvent(event);
  return;
}

/*
  cell_analyze() -- get statistics about the cell that's at position x, y.
   Todo: Find out why there is 1 additional white pixel in the border.
         There should be no pixels before the left border because we called document()->setDocumentMargin(0);
         I've set spacing to 0 and padding to 0, but it doesn't seem to have an effect.
   Todo: Research whether detaching the grid widget might change something that you set here.
   grid_column_size_calc() adds + setting_ocelot_grid_cell_border_size_as_int * 2
   grid_column_size_calc() adds + setting_ocelot_grid_cell_drag_line_size_as_int
   Usually the desired column width is calculable based on what grid_column_size_calc() delivered.
   But this routine is for getting the actual width etc., which might be quite different.
*/
void Result_qtextedit::cell_analyze(int x, int y)
{
  qtextedit_block_count= document()->blockCount();

  qtextedit_block_number= qtextedit_grid_row_number= qtextedit_column_number= 0;
  qtextedit_is_before_column= qtextedit_is_before_row= false;

  qtextedit_columns_per_row= result_grid->gridx_column_count + 1; /* +1 because of thin image on the left */
  qtextedit_x= x;
  qtextedit_y= y;

  //if (qtextedit_block_count <= 1)
  //{
  //  /* There should be at least two blocks, counting the thin image */
  //  /* Todo: If it's not HTML or we returned that the result set is empty, this can happen. */
  //  printf("**** too small\n");
  //  exit(0);
  //}
  QTextCursor text_cursor_0= cursorForPosition(QPoint(x, y));
  if (text_cursor_0.atEnd() == true)
  {
    /* TODO: THIS CAN HAPPEN -- SO ELSEWHERE DO NOT DEPEND ON QTEXTEDIT_GRID_ROW_NUMBER ETC.  */
    qtextedit_at_end= true;
    return;
  }
  //if (text_cursor_0.blockNumber() == 0)
  //{
  //  printf("**** blockNumber == 0\n");
  //  exit(0);
  //}
  //if (text_cursor_0.blockNumber() > qtextedit_block_count)
  //{
  //  printf("text_cursor_0.blockNumber() > qtextedit_block_count\n");
  //  exit(0);
  //}
  qtextedit_at_end= false;

  QTextCursor text_cursor= cursorForPosition(QPoint(x, y));
  qtextedit_block_number= text_cursor.blockNumber() - 1;
  qtextedit_grid_row_number= qtextedit_block_number / qtextedit_columns_per_row;
  qtextedit_result_row_number= result_row_number_from_grid_row_number(qtextedit_grid_row_number);  qtextedit_column_number= qtextedit_block_number % qtextedit_columns_per_row;
  int border_size= result_grid->copy_of_parent->ocelot_grid_cell_border_size.toInt();
  qtextedit_is_before_column= false;
  qtextedit_is_before_row= false;
  QTextCursor text_cursor_2= cursorForPosition(QPoint(x + border_size * 2, y));
  int block_number_2= text_cursor_2.blockNumber() - 1;
  if (qtextedit_block_number != block_number_2) qtextedit_is_before_column= true;
  QTextCursor text_cursor_3= cursorForPosition(QPoint(x, y + border_size * 2));
  int block_number_3= text_cursor_3.blockNumber() - 1;
  if (qtextedit_block_number != block_number_3) qtextedit_is_before_row= true;
  for (qtextedit_x_start= x - 1; qtextedit_x_start > border_size * 2; --qtextedit_x_start)
  {
    QTextCursor text_cursor_4= cursorForPosition(QPoint(qtextedit_x_start, y));
    int block_number_4= text_cursor_4.blockNumber() - 1;
    if (qtextedit_block_number != block_number_4) break;
  }
  ++qtextedit_x_start;
  for (qtextedit_x_end= qtextedit_x_start; qtextedit_x_end > border_size * 2; ++qtextedit_x_end)
  {
    QTextCursor text_cursor_5= cursorForPosition(QPoint(qtextedit_x_end, y));
    int block_number_5= text_cursor_5.blockNumber() - 1;
    if (qtextedit_block_number != block_number_5) break;
  }
  --qtextedit_x_end;
  for (qtextedit_y_start= y - 1; qtextedit_y_start > border_size * 2; --qtextedit_y_start)
  {
    QTextCursor text_cursor_6= cursorForPosition(QPoint(x, qtextedit_y_start));
    int block_number_6= text_cursor_6.blockNumber() - 1;
    if (qtextedit_block_number != block_number_6) break;
  }
  ++qtextedit_y_start;
  for (qtextedit_y_end= qtextedit_y_start; qtextedit_y_end > border_size * 2; ++qtextedit_y_end)
  {
    QTextCursor text_cursor_7= cursorForPosition(QPoint(x, qtextedit_y_end));
    int block_number_7= text_cursor_7.blockNumber() - 1;
    if (qtextedit_block_number != block_number_7) break;
  }
  --qtextedit_y_end;
  QTextDocument *qt;
  qt= document();
  QTextBlock qtb;
  qtb= qt->findBlockByNumber(qtextedit_block_number + 1);
  qtextedit_cell_content= qtb.text();

#if (QT_VERSION >= 0x50000)
  /* See also https://stackoverflow.com/questions/18700945/qtextbrowser-how-to-identify-image-from-mouse-click-position */
  {
    QTextCursor qtc= cursorForPosition(QPoint(x, y));
    QTextCharFormat fmt = qtc.charFormat();
    if (fmt.isImageFormat() == true)
    {
      QTextImageFormat image_format = fmt.toImageFormat();
      QString image_format_name= image_format.name();
      //char tmp_image_format_name[65536];
      //strcpy(tmp_image_format_name, image_format_name.toUtf8());
      //printf("**** image_format_name=%s.\n", tmp_image_format_name);
      QVariant qv= qt->resource(QTextDocument::ImageResource, image_format_name);
      QImage qi= qv.value<QImage>();
      QClipboard *p_clipboard= QApplication::clipboard();
      p_clipboard->setImage(qi);
    }
  }
#endif
}

#ifdef OLD_STUFF
void TextEditFrame::mousePressEvent(QMouseEvent *event)
{
  if (event->button() == Qt::LeftButton)
  {
    left_mouse_button_was_pressed= 1;
  }
  /* We don't look for Qt::RightButton because we have menu_context in MainWIndow. */
}
#endif
/*
 Todo: We've calculated c.position(), we should be able to say what column we're in (or bar between columns).
       (requires blocknumber() and assume we do not wrap, or else see https://stackoverflow.com/questions/15814776/how-do-i-get-the-actual-visible-cursors-line-number
 Todo: button() has flags, it's possible that more than one button is being pressed.
 would eventClicked() be better?
 See also https://www.qtcentre.org/threads/45645-QTextEdit-cursorForPosition()-and-character-at-mouse-pointer
 Todo: I think dragging is only for left button. so add   if (!(event->buttons() & Qt::LeftButton))
 Re focus_result_row_number and focus_column_number:
   We recognize mousePressEvent as a focus change. To show it, we change the background color with bgcolor.
   This gets overridden if there is a conditional setting too. We do not change it if the result set loses
   focus. We don't change color if mousePressEvent is on the header or outside the table. Default color is
   "Wheat" as can be seen in the Settings menu.
   It's a mystery to me that color_change() caused cursor disappearance because QTextCursor confuses me.
   I see that color_change() calls display_html() so maybe this won't the be only cursor-loser situation.
   There's a workaround at the end of this routine
 Re cell_analyze: Usually we can depend on mouseMoveEvent doing this, but it won't get activated if there is
                  a context menu and we move out of it to Result_qtextedit. Same problem with mouseDoubleClick.
                  I don't know why the problem occurs, perhaps it involves an edit filter or a focus event.
 Todo: After I've said mousePressEvent, there's an endless calling of paintEvent although nothing happened.
       It doesn't hog CPU and disappears after the next statement, but presumably something went wrong.
       Todo: Here's a theory to check: it's merely because the cursor is blinking.
  Todo: See also menu_context_t_2_explorer() which I hope won't conflict with right-click causing mousePressEvent.
*/
void Result_qtextedit::mousePressEvent(QMouseEvent *event)
{
  if (result_grid->is_fancy() == false) { QTextEdit::mousePressEvent(event); return; }
  if (result_grid->result_grid_type == EXPLORER_WIDGET) cell_analyze(event->pos().x(), event->pos().y());
  result_grid->focus_result_row_number= result_row_number_from_grid_row_number(qtextedit_grid_row_number); /* so that background = Grid Focus Cell Background Color */
  result_grid->focus_column_number= qtextedit_column_number;

  qtextedit_is_in_drag_for_column= qtextedit_is_in_drag_for_row= false;
  if ((qtextedit_column_number > 0) && (qtextedit_is_before_column))
  {
    qtextedit_is_in_drag_for_column= true;
    qtextedit_drag_start_x= event->pos().x();
    qtextedit_column_number_at_drag_start_time= qtextedit_column_number;
  }
  if (qtextedit_is_before_row == true)
  {
    qtextedit_is_in_drag_for_row= true;
    qtextedit_drag_start_y= event->pos().y();
    qtextedit_grid_row_number_at_drag_start_time= qtextedit_grid_row_number;
    qtextedit_result_row_number_at_drag_start_time= qtextedit_result_row_number;
  }
  if ((qtextedit_is_in_drag_for_column == true) || (qtextedit_is_in_drag_for_row == true))
  {
    qtextedit_drag_start_time= QDateTime::currentMSecsSinceEpoch();
  }
#if (OCELOT_EXPLORER == 1)
  if ((result_grid->result_grid_type == EXPLORER_WIDGET)
   && (qtextedit_is_in_drag_for_column == false) && (qtextedit_is_in_drag_for_row == false)
   && (event->button() == Qt::LeftButton)
   && (qtextedit_column_number == 1)
   && (qtextedit_cell_content > ""))
  {
    qtextedit_is_min_max_clicked= true;
    /* TODO: find out why I have to say "return;" here! */
    return;
  }
#endif
  QTextEdit::mousePressEvent(event);
  result_grid->color_change();
  QTextCursor text_cursor_0= cursorForPosition(QPoint(qtextedit_x, qtextedit_y));
  text_cursor_0.movePosition(QTextCursor::NoMove);
  setTextCursor(text_cursor_0);

  return;
  //if (event->button() == Qt::LeftButton) printf("****    Qt::LeftButton\n");
  //if (event->button() == Qt::RightButton) printf("****    Qt::RightButton\n");
  QTextCursor c= cursorForPosition(event->pos());
  //int position= c.position();
  //QRect r= cursorRect(c);

  QString s= this->toPlainText();
  //char tmp_s[512];
  //strcpy(tmp_s, s.mid(position,3).toUtf8());
  //printf("****     characters = %s.\n", tmp_s);

  for (unsigned int i= 0; i < result_grid->gridx_column_count; ++i)
  {
    ; /* Here we try to find out what column number matches the cursor position */
//    printf("****     i=%d. field_number=%d\n", i, result_widget->result_columns[i].field_number);
//    printf("****     width_in_pixels=%d\n", result_widget->result_columns[i].width_in_pixels);
  }

  for (unsigned int i= 0; i < 110; ++i)
  {
    QPoint p= QPoint(i, event->pos().y());
    c= cursorForPosition(p);
    QString s= toPlainText();
    QString s2= s.mid(c.position(), 1);
    //char s2_tmp[64];
    //strcpy(s2_tmp, s2.toUtf8());
    //printf("****    i=%d, c.position()=%d, s2=%s.\n", i, c.position(), s2_tmp);
  }

  QTextEdit::mousePressEvent(event);
}

/*
  Dragging Theory.
  Todo: Put this comment in an obvious place.
  Dragging is:
    mousePressEvent (left button only?), on a boundary
    interval, mouseMoveEvent distance,
    mouseRelease.
  We can't allow dragging to the left that reduces column size to less than a minimum.
  We should change the tooltip and the cursor (https://doc.qt.io/qt-5/qcursor.html) to show dragging is happening.
  Todo: what if we lose focus, should drag flag go off?
  Todo: I removed the check of QApplication::startDragTime() because I thought it was too short. Revive?
  Todo: This isn't working for the header row, although I think the blame for that lies elsewhere.
  Todo: This is only working for row_number within display, it should be for row_number within result set.
        Probably the way to do this is by adding a different type of entry in Result_changes.
  Todo: it might look nicer to do this during movemouseMoveEvent() so change is continuous until release.
  Todo: Check for minimum width and minimum height.
  Todo: Bug: After you drag a column, the new width is still there for the next result set selected.
*/
void Result_qtextedit::mouseReleaseEvent(QMouseEvent *event)
{
  if (result_grid->is_fancy() == false) { QTextEdit::mouseReleaseEvent(event); return; }
#if (OCELOT_EXPLORER == 1)
  if (result_grid->result_grid_type == EXPLORER_WIDGET)
  {
    if (qtextedit_is_min_max_clicked == true)
    {
      qtextedit_is_min_max_clicked= false;
      result_grid->explorer_toggle(result_grid->focus_result_row_number);
    }
  }
#endif
  if ((qtextedit_is_in_drag_for_column == true) || (qtextedit_is_in_drag_for_row == true))
  {
    bool is_dragged= false;
//    if ((QDateTime::currentMSecsSinceEpoch() - qtextedit_drag_start_time) >= QApplication::startDragTime())
    {
      if ((qtextedit_is_in_drag_for_column == true)
       && (qtextedit_column_number_at_drag_start_time >= 1))
      {
        int moved_x= event->pos().x() - qtextedit_drag_start_x;
        if (abs(moved_x) >= QApplication::startDragDistance())
        { /* Drag relevant column right or left */
          if (result_grid->copy_of_ocelot_vertical == 0)
          {
            result_grid->grid_column_widths[qtextedit_column_number_at_drag_start_time - 1]+= moved_x;
          }
          else
          {
            if ((result_grid->copy_of_ocelot_result_grid_column_names == 1)
             && (qtextedit_column_number_at_drag_start_time == 1))
              result_grid->result_grid_vertical_width_of_header+= moved_x;
            else
              result_grid->result_grid_vertical_width_of_value+= moved_x;
          }
          is_dragged= true;
        }
      }
      if (qtextedit_is_in_drag_for_row == true)
      {
        int moved_y= event->pos().y() - qtextedit_drag_start_y;
        if (abs(moved_y) >= QApplication::startDragDistance())
        { /* Drag relevant row up or down */
          /* Todo: maybe it should be qtextedit_result_row_number_at_drag_start_time? No, dangerous. */
          result_grid->grid_row_heights[qtextedit_grid_row_number_at_drag_start_time]+= moved_y;
          is_dragged= true;
        }
      }
    }
    qtextedit_is_in_drag_for_column= qtextedit_is_in_drag_for_row= false;
    if (is_dragged == true) result_grid->display_html(result_grid->grid_vertical_scroll_bar->value(), 0); /* refresh */
  }
  QTextEdit::mouseReleaseEvent(event);
}
#ifdef OLD_STUFF
/*
  This is an event that happens if a result-set grid cell comes into view due to scrolling.
  It can happen multiple times, and it can happen before we're ready to do anything (mysteriously).
  But it's great for handling result sets that have many cells, because some actions are slow.
  For example, setStyleSheet takes 2+ seconds when there are hundreds of child widgets.
  Todo: only apply setStyleSheet if new cell or if style change
  Todo: check if anything that we're calling from paintEvent is causing another paintEvent
*/
void TextEditFrame::paintEvent(QPaintEvent *event)
{
  if (event == 0) return; /* this is just to avoid an "unused parameter" warning */
  if (ancestor_result_grid_widget->is_paintable == 1)
  {
    /*
      Sometimes spurious text_edit_frames show up as if ready to paint.
      Todo: find out if there's a known Qt bug that might explain this.
      It's possible that it no longer happens now that I'm saying "hide()" more often.
    */
    if (text_edit_frames_index >= ancestor_result_grid_widget->max_text_edit_frames_count)
    {
      printf("Trying to paint a texteditframe that isn't in the layout\n");
      printf("  text_edit_frames_index=%d\n", text_edit_frames_index);
      printf("  max_text_edit_frames_count=%d\n", ancestor_result_grid_widget->max_text_edit_frames_count);
    }
    else
    {
      TextEditWidget *text_edit= findChild<TextEditWidget *>();
      if (text_edit != 0)
      {
        style_sheet_setter(this, text_edit);
        if (is_retrieved_flag == false)
        {
          if (is_image_flag == false)
          {
            if (content_pointer == 0) /* or check content_field_value_flags */
            {
              text_edit->setText(QString::fromUtf8(NULL_STRING, sizeof(NULL_STRING) - 1));
            }
            else text_edit->setText(QString::fromUtf8(content_pointer, content_length));
          }
          is_retrieved_flag= true;
        }
      }
    }
  }
}

/*
 Finally we're ready to paint a cell inside a frame inside a grid row inside result widget.
 The final decision is: paint as text (default) or paint as image (if blob and if flag).
 If it's a non-blob or if the relevant blob flag is off: default paint.
 If it's a blob and ocelot_extra_rule_1_display_as == "image" is on:
   make a pixmap from the contents
   draw the pixmap
   todo: we're allowing resizing (miraculously) but there's no option for scrolling
   todo: consider: is there some better way to decide whether or not to display as image?
*/

void TextEditWidget::paintEvent(QPaintEvent *event)
if (text_edit_frame_of_cell->is_image_flag == false)
{
  QTextEdit::paintEvent(event);
  return;
}

if (text_edit_frame_of_cell->content_pointer == 0) /* or check content_field_value_flags */
{
  setText(QString::fromUtf8(NULL_STRING, sizeof(NULL_STRING) - 1));
  QTextEdit::paintEvent(event);
  return;
}

//QPixmap p= QPixmap(QSize(event->rect().width(), event->rect().height()));
QPixmap p= QPixmap();
if (p.loadFromData((const uchar*) text_edit_frame_of_cell->content_pointer,
                   text_edit_frame_of_cell->content_length,
                   0,
                   Qt::AutoColor) == false)
{
  /* Todo: check above. Haven't we alread esitablished that content_pointer != 0? */
  if (text_edit_frame_of_cell->content_pointer != 0)  /* or check content_field_value_flags */
  {
    setText(QString::fromUtf8(text_edit_frame_of_cell->content_pointer,
                              text_edit_frame_of_cell->content_length));
  }
  QTextEdit::paintEvent(event);
  return;
}
QPainter painter(this->viewport());

/*
  There were choices for QPixmap display. We could have said Qt::IgnoreAspectRatio (the default)
  or Qt::KeepAspectRatioByExpanding. We could have used this->viewport()->size().
  We could have shown a fragment with a scrollbar.
  We could have shown a portion without a scrollbar (one can see the rest by dragging)
  by leaving out the line with the "p.scaled()" function. Maybe users would want such choices?
  Anyway, the line here was wrong:
  p= p.scaled(event->rect().size(), Qt::KeepAspectRatio);
  because event->rect().size() is constantly changing.
  I'm not sure whether this->width(), this->height() might be a few
  pixels too large, but am not seeing noticeable harm.
*/
p= p.scaled(this->width(), this->height(), Qt::KeepAspectRatio);
painter.drawPixmap(0, 0, p);
//painter.drawPixmap(event->rect(), p);
return;
#endif
/* Todo: Find out why this is called repeatedly when visible, even if nothing's going on. */
void Result_qtextedit::paintEvent(QPaintEvent *event)
{
  QTextEdit::paintEvent(event);
}

/*
  Cut in result grid cell. We get here via menu_edit_cut(), not overriding QtextEdit::cut().
  It was never in TextEditWidget.
*/
void Result_qtextedit::cut()
{
  QTextEdit::cut();
}

/*
  Select all in result grid cell. We get here via menu_edit_select_all(), not overriding QtextEdit::selectAll().
  It was never in TextEditWidget.
*/
void Result_qtextedit::selectAll()
{
  QTextEdit::selectAll();
}

/*
  Currently zoomIn and zoomOut are handled via MainWindow::menu_edit_zoominorout(int increment).
  See the comments there. So Result_qtextedit::zoomIn() Result_qtextedit::zoomOut() shouldn't happen.
*/
void Result_qtextedit::zoomIn()
{
  QTextEdit::zoomIn();
}
void Result_qtextedit::zoomOut()
{
  QTextEdit::zoomOut();
}

/*
  Undo in result grid cell. We get here via menu_edit_undo(), not overriding QtextEdit::undo().
  But undoredoenabled is false so we probably will never get to here. It was never in TextEditWidget.
*/
void Result_qtextedit::undo()
{
  QTextEdit::undo();
}

/*
  Redo in result grid cell. We get here via menu_edit_redo(), not overriding QtextEdit::redo().
  But undoredoenabled is false so we probably will never get to here. It was never in TextEditWidget.
*/
void Result_qtextedit::redo()
{
  QTextEdit::redo();
}

/*
  Paste to result grid cell. We get here via menu_edit_paste(), not overriding QtextEdit::paste().
  Todo: call generate_update() i.e. generate an UPDATE statement.
  Re images:
    This is a Work in progress. So far, we detect that the clipboard has
    a pixmap, and if so we convert the pixmap to a byte array following
    https://doc.qt.io/qt-5/qpixmap.html#save-1, and we copy that to a
    permanent char[], and we save the bytes so that (I think)
    copy_html_cell() is seeing it and overwriting the old pixmap.
    An advantage is that scrolling and then coming back, we'll see the new image.
    But the job is only half done.
    Todo: allow undo, which would require saving the old pointers.
    Todo: generate an UPDATE statement.
    Todo: have an array of char[] not just one, and delete it when result set is closed.
          (right now there is only one and it leaks, look at the "new" instruction inside the function)
    Todo: check if is_retrieved_flag is necessary, and is all you need.
    Todo: maybe there should be another flag to indicate "a paste happened here".
    Todo: the same technique could be applied to non-images though may be unnecessary.
    Todo: make this a no-op if user is pasting an image to a non-image cell.
          (but if the old value is NULL we might change it to an image, I suppose)
    Todo: try removing "PNG" argument.
    Todo: need more error checks, including for "new".
    Todo: we're not falling through to QTextEdit::paste(). Is there any benefit in that?
          I think it was causing "QXcbClipboard: SelectionRequest too old", but should test.
    Todo: research: is there a way to get clipboard contents to char[] with fewer steps?
    Todo: image_as_char is a memory leaker.
    Some image code was copied from QTextEdit::paste().
    Todo: This works in image paste experiment, which is where I copy an image from Pinta,
          ^V in a result set, scroll, and see that row#2 column#2 is an image. Whoopee.
          Now get rid of the leak, allow for more than one paste, determine correct row # column,
          and display the change immediately without waiting for scroll. Still lots to do!
*/
void Result_qtextedit::paste()
{
  if (result_grid->is_fancy() == false) { QTextEdit::paste(); return; }
  QPixmap p;
  QClipboard *p_clipboard= QApplication::clipboard();
  p= p_clipboard->pixmap(QClipboard::Clipboard);
  if (p.isNull() == false)
  {
    /* It is a pixmap. See the comments preceding this function. */
    QByteArray image_as_byte_array;
    QBuffer buffer(&image_as_byte_array);
    buffer.open(QIODevice::WriteOnly);
    if (p.save(&buffer, "PNG"))
    {
      /* image paste experiment */
      qtextedit_result_changes->append(qtextedit_grid_row_number, qtextedit_column_number, &image_as_byte_array);
      return;
    }
  }
  QTextEdit::paste();
}

/* I don't know what cause Result_qtextedit::hideEvent(). Maybe ResultGrid::hideEvent()? */
/* Although I do have html_text_edit->hide() in display_batch() */
void Result_qtextedit::hideEvent(QHideEvent *event)
{
  QTextEdit::hideEvent(event);
}

void Result_qtextedit::resizeEvent(QResizeEvent *event)
{
  QTextEdit::resizeEvent(event);
}

/*
  Do not show html_text_edit if batch_text_edit is visible and is all that's supposed to be visible.
  Todo: Someday find out what causes this event while html_text_edit is hidden. Maybe parent tab show?
*/
void Result_qtextedit::showEvent(QShowEvent *event)
{
  QTextEdit::showEvent(event);
}

/*
   Todo: We know what is at pos but do nothing about it.
   Will this conflict with right-button keypress?
*/
void Result_qtextedit::menu_context_t_2(const QPoint & pos)
{
  result_grid->copy_of_parent->menu_context(pos);
}

#if (OCELOT_EXPLORER == 1)
/* Comments about Context_menu should be in ocelotgui.h before the words "class Context_menu: public QWidget" */
void Result_qtextedit::menu_context_t_2_explorer(const QPoint & pos)
{
  explorer_context_menu->menu_context_t_2_explorer(pos);
  return;
}

#endif

/******************** Result_qtextedit end   ************************************/

/******************** Context_menu start   ************************************/

/* Comments about Context_menu should be in ocelotgui.h before the words "class Context_menu: public QWidget" */
void Context_menu::construct()
{
  add_action("CLIPBOARD=${object_name}", "*", "S,T,P,F,E,R", "", "", "Copy to clipboard");
  add_action("CLIPBOARD=${part_name}", "*", "C,I", "", "", "Copy to clipboard");
  add_action("ACTION=${object_name}", "*", "S,T,P,F,E,R", "", "", "Send to SQL editor");
  add_action("ACTION=${part_name}", "*", "C,I", "", "", "Send to SQL editor");
  add_action("USE ${schema_name};", "M", "S", "", "", "Set as default schema");
  add_action("FILTER=$schema_name", "M", "S", "", "", "Filter to this schema");
  add_action("select schema_name,"
           " (select count(*) from information_schema.tables where table_schema='${schema_name}') as table_count,"
           " (select count(*) from information_schema.routines where routine_schema='${schema_name}') as routine_count,"
           " (select count(*) from information_schema.triggers where trigger_schema='${schema_name}') as trigger_count,"
           " schema_comment"
           " from information_schema.schemata"
           " where schema_name='${schema_name}';", "*", "S", "", "", "Schema inspector");
  add_action("Show create schema ${schema_name};", "M", "S", "", "", "Create schema");
  add_action("Alter schema ${schema_name}"
           " character set=${part_name}"
           " collate=${part_type};", "M", "S", "", "", "Alter schema");
  add_action("Drop schema ${schema_name};", "M", "S", "", "", "Drop schema");
  add_action("SET ocelot_query = SHOW ERDIAGRAM OF ${schema_name};", "M", "S", "", "", "ER Diagram");
  add_action("Select * from ${object_name} limit 100;", "*", "T,V", "", "", "Select rows");
  add_action("SET ocelot_query = SHOW FOREIGN KEYS OF ${object_name};", "*", "T", "", "", "Foreign Keys");
#ifdef OCELOT_IMPORT_EXPORT
  add_action("EXPORT_TEXT;", "*", "T,V", "", "", "Export dialog - Text");
  add_action("EXPORT_TABLE;", "*", "T,V", "", "", "Export dialog - Table");
  add_action("EXPORT_HTML;", "*", "T,V", "", "", "Export dialog - Html");
  add_action("IMPORT ${object_name} ${dialog_file};", "*", "T,V", "", "", "Import  - Text");
#endif
  add_action("Show create table ${object_name};", "M", "T", "", "", "Create table");
  add_action("Create table ${dialog_table} like ${object_name};", "M", "T", "", "", "Create table like");
  add_action("Drop table ${object_name};", "*", "T", "", "", "Drop table");
  add_action("Truncate table ${object_name};", "*", "T", "", "", "Truncate table");
  add_action("show create view ${object_name};", "M", "V", "", "", "Show create view");
  add_action("${unqualified_part_name};", "T", "V", "", "", "Show create view");
  add_action("Drop view ${object_name};",  "*", "V", "", "", "Drop view");
  add_action("select '${part_name}' as column_name,"
          "'${part_type}' as column_type,"
          "'${occurs_text}' as occurs_in_indexes;", "*", "C", "", "", "Show column");
  add_action("Alter table ${object_name} drop column ${part_name};", "M", "C", "", "", "Drop column");
  add_action("Show index from ${object_name};", "M", "I", "", "", "Show index");
  add_action("Select * from \"_vindex\" where \"name\" = '${part_name}';", "T", "I", "", "", "Show index");
  add_action("Select * from information_schema.statistics where index_name = '${part_name}';", "M", "I", "", "", "Select index");
  add_action("select * from \"_vindex\" where \"id\" = (select \"id\" from \"_vspace\" where \"name\" = '${object_name}');", "T", "I", "", "", "Select index");
  add_action("Drop index ${unqualified_part_name} on ${object_name};", "*", "I", "", "", "Drop index");
  add_action("Show create procedure ${object_name};", "*", "P", "", "", "Create procedure");
  add_action("Drop procedure ${object_name};", "*", "P", "", "", "Drop procedure");
  add_action("Drop function ${object_name};", "*", "F", "", "", "Drop function");
  add_action("Select * from information_schema.triggers where trigger_name = ${object_name}", "M", "R", "", "", "Show trigger");
  add_action("Select * from \"_trigger\" where \"name\" = '${object_name}';", "T", "R", "", "", "Show trigger");
  add_action("Drop trigger ${object_name};", "*", "R", "", "", "Drop trigger");
  add_action("RESET;", "*", "*", "", "", "Reset");
  add_action("Refresh;", "*", "*", "", "", "Refresh");
}

/* Note: avoiding "warning: extended initializer lists only available with -std=c++11 or -std=gnu++11 ..." */
int Context_menu::add_action(QString action, QString applicable_dbmss, QString applicable_types,
                              QString enabled, QString shortcut, QString text)
{
  if (cmi_count >= MAX_CMI_COUNT) return -1; /* Fail. Increase MAX_CMI_COUNT if this happens. */
  cmi[cmi_count].action= action;
  cmi[cmi_count].applicable_dbmss= applicable_dbmss;
  cmi[cmi_count].applicable_types= applicable_types;
  cmi[cmi_count].enabled= enabled;
  cmi[cmi_count].shortcut= shortcut;
  cmi[cmi_count].text= text;
  cmi[cmi_count].is_visible= false;
  ++cmi_count;
  return 0;
}

/* This existed because cells for long names had \r or \n but apparently that doesn't happen any more. */
//QString Context_menu::strip_crlf(QByteArray result_row_value)
//{
//  QString s= QString::fromUtf8(result_row_value);
//  char tmp10[256];
//  strcpy(tmp10, s.toUtf8());
//  s.replace("\n", "");
//  s.replace("\r", "");
//  char tmp11[256];
//  strcpy(tmp11, s.toUtf8());
//  if (strcmp(tmp10, tmp11) != 0) printf("**** difference for %s.\n", tmp10);
//  return s;
//}

QString Context_menu::replacer(QString s)
{
  cm_object_type= QString::fromUtf8(result_grid->copy_of_parent->oei[q->qtextedit_result_row_number].object_type);
  QString schema_name= QString::fromUtf8(result_grid->copy_of_parent->oei[q->qtextedit_result_row_number].schema_name);
  QString object_name= QString::fromUtf8(result_grid->copy_of_parent->oei[q->qtextedit_result_row_number].object_name);
  QString part_name= QString::fromUtf8(result_grid->copy_of_parent->oei[q->qtextedit_result_row_number].part_name);
  QString part_type= QString::fromUtf8(result_grid->copy_of_parent->oei[q->qtextedit_result_row_number].part_type);

  //char flags= result_grid->copy_of_parent->oei[q->qtextedit_result_row_number].flags;
  /* Todo: Let delimiter be blank if it's not necessary. */
  QString delimiter= "\"";
  if (connections_dbms[0] == DBMS_TARANTOOL) ;
  else if (sql_mode_ansi_quotes == false) delimiter= "`";
  QString delimited_schema_name= delimiter + schema_name + delimiter;
  /* Todo: don't add schema qualifier if it's not necessary */
  QString schema_qualifier= "";
  if (connections_dbms[0] == DBMS_TARANTOOL) ;
  else schema_qualifier= delimited_schema_name + ".";
  if (cm_object_type == "S") cm_delimited_object_name= delimited_schema_name;
  else cm_delimited_object_name= schema_qualifier+ delimiter + object_name + delimiter;
  cm_cell= q->qtextedit_cell_content;
  QString table_qualifier= delimiter + object_name + delimiter + ".";
  QString delimited_part_name= table_qualifier+ delimiter + part_name + delimiter;
  QString unqualified_part_name= delimiter + part_name + delimiter;
  if (s.contains("${dialog_table}", Qt::CaseInsensitive) == true)
  {
    Small_dialog *sm= new Small_dialog("Enter new table name and type Enter", "New name", "");
    sm->exec();
    QString text= "Create table " + sm->line_edit.text().toUtf8() + " like " + cm_delimited_object_name + ";";
    QString dialog_result= sm->line_edit.text().toUtf8();
    delete sm;
    s.replace("${dialog_table}", dialog_result, Qt::CaseInsensitive);
  }
  if (s.contains("${dialog_file}", Qt::CaseInsensitive) == true)
  {
    Small_dialog *sm= new Small_dialog("Enter file name and type Enter", "New name", "");
    sm->exec();
    QString text= "Create table " + sm->line_edit.text().toUtf8() + " like " + cm_delimited_object_name + ";";
    QString dialog_result= sm->line_edit.text().toUtf8();
    delete sm;
    s.replace("${dialog_file}", dialog_result, Qt::CaseInsensitive);
  }
  if (s.contains("${occurs_text}", Qt::CaseInsensitive) == true)
  {
    int index_count= 0;
    for (unsigned int i= 0; i < result_grid->copy_of_parent->oei_count; ++i)
    {
      if (result_grid->copy_of_parent->oei[i].object_type == "I")
      {
        if ((result_grid->copy_of_parent->oei[i].object_name == object_name)
         && (result_grid->copy_of_parent->oei[i].part_type == part_name))
        {
          ++index_count;
        }
      }
    }
    QString occurs_text= QString::number(index_count) + " times";
    if (index_count == 1) occurs_text= "1 time";
    s.replace("${occurs_text}", occurs_text, Qt::CaseInsensitive);
  }
  s.replace("'${schema_name}'", "'" + schema_name + "'", Qt::CaseInsensitive);
  s.replace("${schema_name}", delimited_schema_name, Qt::CaseInsensitive);
  s.replace("'${object_name}'", "'" + object_name + "'", Qt::CaseInsensitive);
  s.replace("${object_name}", cm_delimited_object_name, Qt::CaseInsensitive);
  s.replace("'${part_name}'", "'" + part_name + "'", Qt::CaseInsensitive);
  s.replace("${unqualified_part_name}", unqualified_part_name, Qt::CaseInsensitive);
  s.replace("${part_name}", delimited_part_name, Qt::CaseInsensitive);
  s.replace("${part_type}", part_type, Qt::CaseInsensitive);
  s.replace("${cell}", cm_cell, Qt::CaseInsensitive);
  s.replace("${clipboard}", QApplication::clipboard()->text());
  s.replace("${action}", result_grid->copy_of_parent->statement_edit_widget->toPlainText());
  return s;
}

void Context_menu::menu_context_t_2_explorer(const QPoint & pos)
{
  (void)pos;
  if (q->qtextedit_at_end == true) return;
  result_grid->copy_of_parent->log("menu_context_t_2_explorer start", 90);
  if ((q->qtextedit_is_before_column == true) || (q->qtextedit_is_before_row == true)) return;

  q->result_grid->copy_of_parent->c_widget->initialize(EXPLORER_WIDGET);
  q->result_grid->copy_of_parent->c_widget->clear_wrapper();

  QString dbms= "M"; /* MariaDB/MySQL assumed */
  if (connections_dbms[0] == DBMS_TARANTOOL) dbms= "T";
  int cmi_count_visible= 0;
  int max_visible_text_length= 0;
  for (int i_of_cmi= 0; i_of_cmi < cmi_count; ++i_of_cmi)
  {
    replacer(""); /* so we get cm_object_type and cm_delimited_object_name */
    bool is_object_type_match= false;
    if ((cmi[i_of_cmi].applicable_types.contains(cm_object_type) == true)
     || (cmi[i_of_cmi].applicable_types.contains("*") == true))
      is_object_type_match= true;
    bool is_dbms_match= false;
    if ((cmi[i_of_cmi].applicable_dbmss.contains("*") == true)
     || (cmi[i_of_cmi].applicable_dbmss.contains(dbms) == true))
      is_dbms_match= true;
    if ((is_object_type_match == true) && (is_dbms_match == true))
    {
      cmi[i_of_cmi].is_visible= true;
      QString visible_text= replacer(cmi[i_of_cmi].text);
      if (visible_text.length() > max_visible_text_length) max_visible_text_length= visible_text.length();
      ++cmi_count_visible;
    }
    else cmi[i_of_cmi].is_visible= false;
  }

  /* Loop again so we can right-align shortcut, assuming fixed font */
  for (int i_of_cmi= 0; i_of_cmi < cmi_count; ++i_of_cmi)
  {
    QString spacer= " ";
    if (cmi[i_of_cmi].is_visible == true)
    {
      QString visible_text= replacer(cmi[i_of_cmi].text);
      visible_text= visible_text + spacer.repeated(max_visible_text_length - visible_text.length());
      visible_text= visible_text + " " + cmi[i_of_cmi].shortcut;
      q->result_grid->copy_of_parent->c_widget->append_wrapper(visible_text, "", TOKEN_TYPE_IDENTIFIER, TOKEN_FLAG_IS_NEW, "K");
    }
  }

  q->result_grid->copy_of_parent->c_widget->size_and_position_change();
  q->result_grid->copy_of_parent->c_widget->show();
  q->result_grid->copy_of_parent->c_widget->setFocus();
  result_grid->copy_of_parent->log("menu_context_t_2_explorer end", 90);
}

/* if due to mousepressevent: current_row >= 0, i_of_cmi == -1 */
/* if due to shortcutter: current_row == -1, i_of_cmi >= 0 */
void Context_menu::action(int current_row, int i_of_cmi)
{
  int i_of_cmi_visible= 0;
  if (current_row >= 0)
  {
    bool is_match= false;
    for (i_of_cmi= 0; i_of_cmi < cmi_count; ++i_of_cmi)
    {
      if (cmi[i_of_cmi].is_visible == false) continue;
      if (i_of_cmi_visible == current_row)
      {
        is_match= true;
        break;
      }
      if (i_of_cmi_visible != current_row)
      ++i_of_cmi_visible;
    }
    if (is_match == false)
    {
      /* ?? Unknown action. This must be an error, eh? */
      printf("Unknown action\n");
      return;
    }
  }
  if (cmi[i_of_cmi].enabled == "no")
  {
    return;
  }
  {
    QString s= cmi[i_of_cmi].action.trimmed();
    if (s.startsWith("CLIPBOARD=", Qt::CaseInsensitive) == true) /* probably "CLIPBOARD=${cell}" */
    {
      s= replacer(s);
      s= s.right(s.size()-10);
      QApplication::clipboard()->setText(s);
    }
    else if (s.startsWith("ACTION=", Qt::CaseInsensitive) == true) /* probably "ACTION=${cell}" */
    {
      s= replacer(s);
      s= s.right(s.size()-7);
      result_grid->copy_of_parent->statement_edit_widget->setPlainText(s);
    }
#ifdef OCELOT_IMPORT_EXPORT
    else if ((s == "EXPORT_TEXT;")
     || (s == "EXPORT_TABLE;")
     || (s == "EXPORT_HTML;"))
    {
      int keyword;
      if (s == "EXPORT_TEXT;") keyword= TOKEN_KEYWORD_TEXT;
      if (s == "EXPORT_TABLE;") keyword= TOKEN_KEYWORD_TABLE;
      if (s == "EXPORT_HTML;") keyword= TOKEN_KEYWORD_HTML;
      struct export_settings copy_of_main_exports;
      copy_of_main_exports= main_exports;
      int function_result= result_grid->copy_of_parent->action_export_function(TOKEN_KEYWORD_EXPORT, keyword);
      if (function_result == 1) /* Todo: check that function_result != 1 if dialog-cancel or SET failure */
      {
        QString file_name= main_exports.file_name;
        QString text= "SELECT /* FOR EXPORT TO " + file_name + "*/ * FROM " + cm_delimited_object_name + ";";
        result_grid->copy_of_parent->statement_edit_widget->setPlainText(text);
        result_grid->copy_of_parent->action_execute(1);
        result_grid->copy_of_parent->history_file_stop("TEE");
      }
      main_exports= copy_of_main_exports;
    }
    else if (s.startsWith("IMPORT") == true)
    {
      s= replacer(s);
      int index_of_first_space= s.indexOf(" ");
      int index_of_second_space= s.lastIndexOf(" ");
      QString table_name= s.mid(index_of_first_space + 1, index_of_second_space - (index_of_first_space + 1));
      QString file_name= s.mid(index_of_second_space + 1, (s.size() - 1) - (index_of_second_space + 1));
      result_grid->copy_of_parent->read_file(TOKEN_KEYWORD_IMPORT, file_name, table_name);
    }
#endif
    else if (s == "RESET;")
    {
      result_grid->explorer_reset();
    }
    else if (s.startsWith("FILTER=", Qt::CaseInsensitive) == true) /* probably "FILTER=${schema_name}" */
      result_grid->explorer_filter(q->qtextedit_result_row_number);
    else
    {
      result_grid->copy_of_parent->statement_edit_widget->setPlainText(replacer(s));
      assert(result_grid->copy_of_parent->main_token_max_count >= (unsigned int) s.size());
      result_grid->copy_of_parent->action_execute(1);
    }
  }
}

/* With menus I'd be able to handle the switching with connect() and lambdas, thus:
   (in class Context_Menu private slots) void cmi_switcher(int cmi_index);
   (in Context_menu::add_qaction) int i= cmi_count; connect(cmi[cmi_count].action_pointer, &QAction::triggered,[this, i] { cmi_switcher(i); });
   (here) uncomment
   Currently I'm happy with looking at the exec() result but this method might be better for main menu bar
*/
//void Context_menu::cmi_switcher(int cmi_index)
//{
//  printf("**** cmi_switcher %d\n", cmi_index);
//}

void Context_menu::keyPressEvent(QKeyEvent *event)
{
  (void)event;
}

bool Context_menu::shortcutter(QKeySequence qk)
{
  for (int i_of_cmi= 0; i_of_cmi < cmi_count; ++i_of_cmi)
  {
    QString i_of_cmi_shortcut= cmi[i_of_cmi].shortcut;
    if (i_of_cmi_shortcut != "")
    {
      QKeySequence qk_of_shortcut= QKeySequence(i_of_cmi_shortcut);
      if (qk_of_shortcut == qk)
      {
        action(-1, i_of_cmi);
        return true;
      }
    }
  }
  return false;
}

/******************** Context_menu end   ************************************/


#ifdef OLD_STUFF
/*
  TextEditFrame
  This is one of the components of result_grid
*/
TextEditFrame::TextEditFrame(QWidget *parent, ResultGrid *result_grid_widget, unsigned int index) :
    QFrame(parent)
{
  setMouseTracking(true);
  left_mouse_button_was_pressed= 0;
  ancestor_result_grid_widget= result_grid_widget;
  text_edit_frames_index= index;
  is_style_sheet_set_flag= false;
  hide();
}

#endif



/*
  CONNECT
*/

/*
   MySQL options
   Any mysql/mariadb client should have a consistent way to see what
   options the user has put in a configuration file such as my.cnf, or added
   on the command line with phrases such as --port=x.
   MySQL's own clients can do it with an include of getopt.h and calls to my_long_options etc.
   but that would introduce some unwanted dependencies, so we do all the option retrievals directly.
   Todo: meld that with whatever a user might say in a CONNECT command line
         or maybe even a dialog box.
   Assume lmysql->ldbms_mysql_init() has not already happened.
   Qt gets to see argc+argv first, and Qt will process options that it recognizes
   such as -style, -session, -graphicssystem. See
   http://qt-project.org/doc/qt-4.8/qapplication.html#details.
   But when Qt is done, it should remove what it parsed.
   Todo: actually you should operate on a copy of argc + argv, rather than change the originals. QT docs say so.
         but that would contradict another todo, which is to blank the password if it's in an argv
   Most options are ignored but the ones which might be essential for connecting are not ignored.
   Example: if ~/.my.cnf has "port=3306" in [clients] group, and start happens with --host=127.0.0.1,
            then port=3306 and current_host=127.0.0.1 and that will get passed to the connect routine.
   Read: http://dev.mysql.com/doc/refman/5.6/en/connecting.html
         See also http://dev.mysql.com/doc/refman/5.6/en/mysql-command-options.html
 */

/*
  Connect -- get options

  Environment variables, then option files, then command-line arguments

  Except that you have to read the command-line arguments to know whether
  you should read the option files, see http://dev.mysql.com/doc/refman/5.7/en/option-file-options.html

  For environment variables:
  Follow http://dev.mysql.com/doc/refman/5.7/en/environment-variables.html
  * Watch: LD_RUN_PATH MYSQL_GROUP_SUFFIX MYSQL_HOST MYSQL_PS1 MYSQL_PWD MYSQL_TCP_PORT TZ USER
           MYSQL_UNIX_PORT

  For option files:
  Follow MySQL manual http://dev.mysql.com/doc/refman/5.7/en/option-files.html
  Don't follow MariaDB documentation https://mariadb.com/kb/en/mariadb/mariadb-documentation/getting-started/getting-installing-and-upgrading-mariadb/configuring-mariadb-with-mycnf/
  Todo: Find out whether MariaDB documentation is merely wrong, or represents a real incompatibility with MySQL.
  * Read these files:
  /etc/my.cnf
  /etc/mysql/my.cnf
  SYSCONFDIR/my.cnf       ?? i.e. [installation-directory]/etc/my.cnf but this should be changeable
  $MYSQL_HOME/my.cnf
  file specified with --defaults-extra-file
  $HOME/.my.cnf             MySQL manual says ~/.my.cnf which isn't necessarily the same thing, but I don't believe that
  $HOME/.mylogin.cnf        MySQL manual says ~/.mylogin.cnf which isn't necessarily the same thing, but I don't believe that
  ... There is no use of DATADIR, which is deprecated, and (I think) would only relate to server anyway.
  On Unix, "ignore configuration files that are world-writable" -- we use stat.h for this.
  * How to read ...
  for (;;)
    read line
    tokenize for the line
    If blank, or starts with '#', or starts with ';', ignore
    ignore everything following '#' (not necessarily at start of line)
    start only when you see [client] or [mysql] or [ocelot]
    stop when you see [something-else]
    expand escape sequences
    if you see opt_name = value:
      compare to important-opt-name but allow "unambiguous prefix" see http://dev.mysql.com/doc/refman/5.7/en/program-options.html
      if opt_name is important
        get value, strip '' or "", strip lead/trail
        assign: variable-name-corresponding-to-opt-name = value
    if you see !include /home/mydir/myopt.cnf or the like:
        open the file; subsequent read lines will be from there, but you have to return
        [ if you're already in an include, that's probably an error ]
    if you see !includedir /home/mydir or the like:
        each file in the directory might be an options file, ending in ".cnf"
  * Last specification takes precedence, so we're starting with
  (say) a variable named OPT which is blank, setting it to
  something when we see OPT = xxx, and setting it again when
  we see OPT = xxx again. Only PASSWORD is tricky, because it
  can be followed by blank to indicate password is necessary.

  For command-line:
  Follow http://dev.mysql.com/doc/refman/5.7/en/command-line-options.html
  * This is somewhat different from the tokenizing that's done for the
    command line, but it's still a matter of tokenizing
  * The trick is: you have to tokenize twice, before and after command-line stuff
  * Get rid of any arguments that you actually handle, Qt might want the rest
  * todo: recognize --print-defaults and --login-pathconf

  In the end, you have a bunch of variables with values.
  Todo: For each variable with a value, append to "CONNECT" client-statement,
  which eventually will be what you actually use (though password won't be repeated?).
  See connect_make_statement().

  Todo: mysql client handles bad format in my.cnf file thus:
        "error: Found option without preceding group in config file: /home/pgulutzan/.my.cnf at line: 1
         Fatal error in defaults handling. Program aborted"
        Maybe we should do the same?

  The above comments apply to Unix, Windows is a bit different.

  Todo: whenever you have a token0/token1/token2:
        find token1 in case it's one of the options we track
        set the value for that option
  Todo: if argv[i] is a password, you should wipe it out. Compare what mysql client does:
        "while (*argument) *argument++= 'x';"

  Todo: The environment variable LD_LIBRARY_PATH is also important, because it determines
        where libmysqlclient.so and the Qt libraries will be loaded from. Document that,
        and show it somewhere.
        The only complication I can think of is that, if I
        decide someday to support another DBMS, the MySQL
        stuff would still come in or have to be disabled.
*/

//#include <dirent.h>

void connect_set_variable(QString token0, QString token1, QString token2);
void connect_read_command_line(int argc, char *argv[]);
#if (OCELOT_MYSQL_INCLUDE == 1)
void connect_read_my_cnf(const char *file_name, int is_mylogin_cnf);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

//#include <pwd.h>
//#include <unistd.h>

/*
  Called from MainWindow, once, very early. So options get default values then may get user-set values.
  The name suggests that the mysql client uses some options this way, but in fact we call for non-mysql-client.
  Options are initialized in this order, with each step possibly overriding what was in the last step:
  (1) any static variables defined with "= constant" outside MainWindow
  (2) assignments in MainWindow() before calling this routine
  (3) assignments at the start of this routine
  (4) handling of anything set due to cmake . -DDEFAULT_OPTION=<string>, see CMakeLists.txt
  (5) later, in connect_mysql_options_2(), --command-line options and configuration-file options
  (6) getenv() comes up somewhere, and see the "Todo:" comment below.
*/
void MainWindow::connect_mysql_options_2(int argc, char *argv[])
{
  char *mysql_pwd;
  const char *home;
  char *ld_run_path;
  /*
    Todo: check: are there any default values to be set before looking at environment variables?
          I don't see documentation to that effect, so I'm just setting them to "" or 0.
          Except that port initially = MYSQL_PORT (probably 3306), and ocelot_delimiter_str initially = ";"
          and http://dev.mysql.com/doc/refman/5.6/en/connecting.html mentions a few others:
          host = 'localhost' (which means protocol=SOCKET if mysql client, but we ignore that)
          user = Unix login name on Linux, although on Windows it would be 'ODBC'
          and there seem to be some getenv() calls in other clients that I didn't take into account.
  */
  ocelot_no_defaults= 0;
  ocelot_defaults_file= "";
  ocelot_defaults_extra_file= "";

  ocelot_host= "localhost";
  ocelot_database= "";
  ocelot_user= "";
  ocelot_password_was_specified= 0;
  /* ocelot_port= MYSQL_PORT; */ /* already initialized */
  ocelot_unix_socket= "";
  ocelot_default_auth= "";
  ocelot_defaults_group_suffix= "";
  /* ocelot_enable_cleartext_plugin= 0; */ /* already initialized */
  ocelot_history_hist_file_name= "/.mysql_history";
  ocelot_histignore= "";
  ocelot_init_command= "";
  ocelot_opt_bind= "";
  /* ocelot_opt_can_handle_expired_passwords= 0; */ /* already initialized */
  /* ocelot_opt_compress= 0; */ /* already initialized */
  ocelot_opt_connect_attr_delete= "";
  /* ocelot_opt_connect_attr_reset= 0; */ /* already initialized */
  /* ocelot_opt_connect_timeout= 0; */ /* ocelot_opt_connect_timeout is initialized to 0 */
  /* ocelot_opt_local_infile= 0; */ /* ocelot_opt_local_infile is initialized to 0 */
  /* ocelot_opt_named_pipe= 0; */ /* already initialized */
  /* ocelot_opt_read_timeout= 0; */ /* already initialized */
  /* ocelot_opt_reconnect= 0; */ /* ocelot_opt_reconnect is initialized to 0 */
  ocelot_opt_ssl= "";
  ocelot_opt_ssl_ca= "";
  ocelot_opt_ssl_capath= "";
  ocelot_opt_ssl_cert= "";
  ocelot_opt_ssl_cipher= "";
  ocelot_opt_ssl_crl= "";
  ocelot_opt_ssl_crlpath= "";
  ocelot_opt_ssl_key= "";
  ocelot_opt_ssl_mode= "";
  /* ocelot_opt_ssl_verify_server_cert= 0; */ /* already initialized */
  /* ocelot_opt_use_result= 0; */ /* already initialized */
  /* ocelot_opt_write_timeout= 0; */ /* already initialized */
  ocelot_plugin_dir= "";
  ocelot_read_default_file= "";
  ocelot_read_default_group= "";
  /* ocelot_report_data_truncation= 0; */ /* already initialized */
  /* ocelot_secure_auth= 1; secure_auth is 1 by default anyway */ /* =1 if mysql 5.6.7 */
  ocelot_server_public_key= "";
  ocelot_set_charset_dir= "";
  ocelot_set_charset_name= "utf8"; /* ocelot_default_character_set= "";  */
  ocelot_shared_memory_base_name= "";

  ocelot_protocol= ""; ocelot_protocol_as_int= get_ocelot_protocol_as_int(ocelot_protocol);

  ocelot_delimiter_str= ";";
  /* ocelot_history_includes_warnings= 0; is default anyway */
  /* ocelot_sigint_ignore= 0; is default anyway */
  /* ocelot_safe_updates= 0; */ /* ocelot_safe_updates is initialized to 0 */
  /* ocelot_select_limit= 0; */ /* ocelot_select_limit is initialized to 0 */
  /* ocelot_max_join_size= 0; */ /* ocelot_max_join_size is initialized to 0 */
  /* ocelot_silent= 0; */ /* ocelot_silent is initialized to 0 */
  /* ocelot_no_beep= 0; */ /* ocelot_no_beep is initialized to 0 */
  /* ocelot_wait= 0; *//* ocelot_wait is initialized to 0 */

  ocelot_bind_address= "";
  ocelot_debug= "";
  ocelot_execute= "";
  ocelot_ld_run_path= "";
  ocelot_login_path= "";
  ocelot_dbms= "";
  ocelot_pager= "";
  //ocelot_prompt= "mysql>";                  /* Todo: change to "\N [\d]>"? */

  options_files_read= "";
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
  {
    struct passwd *pw;
    uid_t u;
    u= geteuid();
    pw= getpwuid(u);
    if (pw != NULL) ocelot_user= pw->pw_name;
  }
#endif
#ifdef DEFAULT_OPTION
  char *pseudo_argv[2];
  pseudo_argv[1]= (char*) DEFAULT_OPTION;
  connect_read_command_line(2, pseudo_argv);
#endif  // DEFAULT_OPTION
  connect_read_command_line(argc, argv);               /* We're doing this twice, the first time won't count. */
  /*
    ocelotgui.pro variables
    Looking at https://dev.mysql.com/doc/refman/5.6/en/source-configuration-options.html
    I gather that some items can be defined at cmake time. The possibly interesting ones
    that we could do in ocelotgui.pro are, for example:
    DEFINES += MYSQL_TCP_PORT=3306
    DEFINES += MYSQL_UNIX_ADDR="/tmp/mysql.sock"
    DEFINES += SYSCONFDIR="..."
    which in cmake terms is -DMYSQL_TCP_PORT=3306 -DMYSQL_UNIX_ADDR="/tmp/mysql.sock" etc.
    MySQL_UNIX_ADDR must go through stringification.
    Following shows how we'd do stringification, but then we don't do anything with it.
    Warning: The stringification might be adding extra "s.
    Warning: MYSQL_UNIX_ADDR has a definition in a mysql.h-related include file.
    Todo: pay attention to these settings.
  */
//#define xstr(a) str(a)
//#define str(a) #a
//#ifdef MYSQL_UNIX_ADDR
//  printf("Ignoring MYSQL_UNIX_ADDR=%s.\n", xstr(MYSQL_UNIX_ADDR));
//#endif

  /* Environment variables */

  if (getenv("HOME") != 0)
  {
    home= getenv("HOME");
  }
  else home= "";

  if (getenv("LD_RUN_PATH") != 0)
  {
    ld_run_path= getenv("LD_RUN_PATH");                  /* maybe used to find libmysqlclient */
    ocelot_ld_run_path= ld_run_path;
  }
  if (getenv("MYSQL_GROUP_SUFFIX") != 0)
  {
    char *tmp_ocelot_defaults_group_suffix;
    tmp_ocelot_defaults_group_suffix= getenv("MYSQL_GROUP_SUFFIX");
    ocelot_defaults_group_suffix= tmp_ocelot_defaults_group_suffix;
  }

  //getenv("MYSQL_HOME");                                /* skip, this is only for server */

  if (getenv("MYSQL_HISTFILE") != 0)
  {
    char *tmp_ocelot_histfile;
    tmp_ocelot_histfile= getenv("MYSQL_HISTFILE");
    ocelot_history_hist_file_name= tmp_ocelot_histfile;
  }
  else ocelot_history_hist_file_name= home + ocelot_history_hist_file_name;

  if (getenv("MYSQL_HISTIGNORE") != 0)
  {
    char *tmp_ocelot_histignore;
    tmp_ocelot_histignore= getenv("MYSQL_HISTIGNORE");
    ocelot_histignore= tmp_ocelot_histignore;
  }

  if (getenv("MYSQL_HOST") != 0)
  {
    char *tmp_ocelot_host;
    tmp_ocelot_host= getenv("MYSQL_HOST");
    ocelot_host= tmp_ocelot_host;
  }

  if (getenv("MYSQL_PS1") != 0)
  {
    char *tmp_ocelot_prompt;
    tmp_ocelot_prompt= getenv("MYSQL_PS1");
    ocelot_prompt= tmp_ocelot_prompt;
    ocelot_prompt_is_default= false;
  }

  if (getenv("MYSQL_PWD") != 0)
  {
    mysql_pwd= getenv("MYSQL_PWD");
    ocelot_password= mysql_pwd;
    ocelot_password_was_specified= 1;
  }
  if (getenv("MYSQL_TCP_PORT") != 0) ocelot_port= atoi(getenv("MYSQL_TCP_PORT"));         /* "" */
  //user= getenv("USER"); no, this is for Windows
  //tz= getenv("TZ");

  if (getenv("MYSQL_UNIX_PORT") != 0)
  {
    char *tmp_ocelot_unix_socket;
    tmp_ocelot_unix_socket= getenv("MYSQL_UNIX_PORT");
    ocelot_unix_socket= tmp_ocelot_unix_socket;
  }
  /*
    Options files i.e. Configuration files i.e. my_cnf files
    Don't read option files if ocelot_no_defaults==1 (which is true if --no-defaults was specified on command line).
    For Tarantool, we look in the same places as for MariaDB.
    MariaDB's mysql client wouldn't read .mylogin.cnf, but we do.
    Todo: check: does MariaDB read mylogin.cnf even if ocelot_no_defaults==1?
    Todo: put mycnf_file list somewhere where ocelotgui --help can see
  */
  if (QString::compare(ocelot_defaults_file, " ") > 0)
  {
    char tmp_my_cnf[1024];                         /* file name = $HOME/.my.cnf or $HOME/.mylogin.cnf or defaults_extra_file */
    strcpy(tmp_my_cnf, ocelot_defaults_file.toUtf8());
    connect_read_my_cnf(tmp_my_cnf, 0);
  }
  else
  {
    if (ocelot_no_defaults == 0)
    {
      char my_cnf_file[10][1024];
      int i= 0;
      /* Internet mentions other my.cnf locations but I'm guessing they're for examples. */
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
      strcpy(my_cnf_file[i++], "/etc/my.cnf");
      strcpy(my_cnf_file[i++], "/etc/mysql/my.cnf");
      /* todo: think: is argv[0] what you want for SYSCONFDIR? not exact, but it's where the program is now. no, it might be a copy. */
      // connect_read_my_cnf("SYSCONFDIR/etc/my.cnf", 0) /* ?? i.e. [installation-directory]/etc/my.cnf but this should be changeable */
      /* skip $MYSQL_HOME/my.cnf, only server stuff should be in it */
      // connect_read_my_cnf("file specified with --defaults-extra-file", 0);
      if (QString::compare(ocelot_defaults_extra_file, " ") > 0)
      {
        strcpy(my_cnf_file[i++], ocelot_defaults_extra_file.toUtf8());
      }
      strcpy(my_cnf_file[i], home);
      strcat(my_cnf_file[i++], "/.my.cnf");
      if (getenv("MYSQL_TEST_LOGIN_FILE") != NULL)
      {
        strcpy(my_cnf_file[i++], getenv("MYSQL_TEST_LOGIN_FILE"));
      }
      else
      {
        strcpy(my_cnf_file[i], home);          /* $HOME/.mylogin.cnf */
        strcat(my_cnf_file[i++], "/.mylogin.cnf");
      }
#else
      /* Todo: %PROGRAMDATA%... (MySQL) */
      if ((hparse_dbms_mask & (FLAG_VERSION_MARIADB_ALL|FLAG_VERSION_TARANTOOL)) != 0)
      {
        if (getenv("SYSTEM") != 0)
        {
          strcpy(my_cnf_file[i], getenv("SYSTEM"));
          strcat(my_cnf_file[i++], "\\my.ini");
          strcpy(my_cnf_file[i], getenv("SYSTEM"));
          strcat(my_cnf_file[i++], "\\my.cnf");
        }
      }
      if (getenv("WINDIR") != 0)
      {
        strcpy(my_cnf_file[i], getenv("WINDIR")); /* e.g. c:\windows */
        strcat(my_cnf_file[i++], "\\my.ini");
        strcpy(my_cnf_file[i], getenv("WINDIR"));
        strcat(my_cnf_file[i++], "\\my.cnf");
      }
      strcpy(my_cnf_file[i++], "c:\\my.ini");
      strcpy(my_cnf_file[i++], "c:\\my.cnf");
      if ((hparse_dbms_mask & FLAG_VERSION_MYSQL_ALL) != 0)
      {
        /* Todo: This should be BASEDIR | INSTALLDIR. Close enough? */
        strcpy(my_cnf_file[i], QCoreApplication::applicationDirPath().toUtf8());
        strcat(my_cnf_file[i++], "\\my.ini");
        strcpy(my_cnf_file[i], QCoreApplication::applicationDirPath().toUtf8());
        strcat(my_cnf_file[i++], "\\my.cnf");
      }
      if ((hparse_dbms_mask & (FLAG_VERSION_MARIADB_ALL|FLAG_VERSION_TARANTOOL)) != 0)
      {
        if (getenv("MYSQL_HOME") != 0)
        {
          strcpy(my_cnf_file[i], getenv("MYSQL_HOME"));
          strcat(my_cnf_file[i++], "\\my.ini");
          strcpy(my_cnf_file[i], getenv("MYSQL_HOME"));
          strcat(my_cnf_file[i++], "\\my.cnf");
        }
      }
      if (QString::compare(ocelot_defaults_extra_file, " ") > 0)
      {
        strcpy(my_cnf_file[i++], ocelot_defaults_extra_file.toUtf8());
      }
      if (getenv("APPDATA") != 0)
      {
        strcpy(my_cnf_file[i], getenv("APPDATA"));
        strcat(my_cnf_file[i], "\\MYSQL");
        strcat(my_cnf_file[i++], "\\.mylogin.cnf");
      }
#endif
      for (int j= 0; j < i; ++j)
      {
        if (strstr(my_cnf_file[j], ".mylogin.cnf") != 0)
          connect_read_my_cnf(my_cnf_file[j], 1);
        else connect_read_my_cnf(my_cnf_file[j], 0);
      }
    }
  }
  connect_read_command_line(argc, argv);
  if (ocelot_prompt_is_default == true)
  {
    ocelot_prompt= ocelot_dbms;
    ocelot_prompt.append(">");
  }

  //connect_make_statement();
}


/*
  Command line arguments i.e. argc + argv (or pseudo_argv if cmake .-DDEFAULT_OPTION=string)
  Some tokenizing has already been done.
  For example progname --a=b --c=d gives us argv[1]="--a=b" and argv[2]="--c=d".
  For example progname -a b -c d gives us argv[1]="-a" argv[2]="b" argv[3]="-c" argv[4]="d".
  If something is enclosed in single or double quotes, then it has already been stripped of quotes and lead/trail spaces.
  We do command line arguments TWICE! first time is just to find out what my.cnf files should be read, etc.
  second time is to override whatever happened during getenv and option-file processing
  todo: parse so -p x and --port=x etc. are known
  todo: check: is it okay still to abbreviate e.g. us rather than user?
  todo: strip the arguments so Qt doesn't see them, or maybe don't
  todo: you seem to be forgetting that Qt can also expect command-line options
  todo: all the .ToLower() stuff is probably unnecessary, it can probably be upper
*/
/*
  BUG: If user enters "--ocelot_xml = wombat" rather than "--ocelot_xml=wombat", we will interpret
       this as three entries, and the third entry is not preceded by - so we will interpret wombat as
       a database name. Of course the spaces shouldn't be there, but we should parse better.
*/
void MainWindow::connect_read_command_line(int argc, char *argv[])
{
  QString token0, token1, token2;
  QString s_argv;
  int i;

  for (i= 1; i < argc; ++i)
  {
    s_argv= argv[i];
    /* If there's no '-' then (I guess) this is the database name */
    if (s_argv.mid(0, 1) != "-")
    {
      token0= "database"; token1= "="; token2= s_argv;
    }
    /* If there is one '-' then token0=argv[i], maybe token1='=', maybe token2=argv[i+1 */
    /* Some items don't need spaces before argument, e.g. -D db_name is same as -Ddb_name */
    else if ((strlen(argv[i]) > 1) && (s_argv.mid(1, 1) != "-"))
    {
      bool is_token2_needed= false;
      token0= argv[i]; token1= ""; token2= "";
      if (token0.size() > 2)
      {
        token1= "=";
        token2= token0.right(token0.size() - 2);
        token0= token0.left(2);
      }
      if (token0 == "-?") token0= QString(strvalues[TOKEN_KEYWORD_HELP].chars).toLower();
      if (token0 == "-#") token0= QString(strvalues[TOKEN_KEYWORD_DEBUG].chars).toLower();
      if (token0 == "-A") token0= QString(strvalues[TOKEN_KEYWORD_NO_AUTO_REHASH].chars).toLower();
      if (token0 == "-B") token0= QString(strvalues[TOKEN_KEYWORD_BATCH].chars).toLower();
      if (token0 == "-b") token0= QString(strvalues[TOKEN_KEYWORD_NO_BEEP].chars).toLower();
      if (token0 == "-C") token0= QString(strvalues[TOKEN_KEYWORD_COMPRESS].chars).toLower();
      if (token0 == "-c") token0= QString(strvalues[TOKEN_KEYWORD_COMMENTS].chars).toLower();
      if (token0 == "-D") { token0= QString(strvalues[TOKEN_KEYWORD_DATABASE].chars).toLower(); is_token2_needed= true; }
      if (token0 == "-E") token0= QString(strvalues[TOKEN_KEYWORD_VERTICAL].chars).toLower();
      if (token0 == "-e") { token0= QString(strvalues[TOKEN_KEYWORD_EXECUTE].chars).toLower(); is_token2_needed= true; }
      if (token0 == "-f") token0= QString(strvalues[TOKEN_KEYWORD_FORCE].chars).toLower();
      if (token0 == "-G") token0= QString(strvalues[TOKEN_KEYWORD_NAMED_COMMANDS].chars).toLower();
      if (token0 == "-H") token0= QString(strvalues[TOKEN_KEYWORD_HTML].chars).toLower();
      if (token0 == "-h") { token0= QString(strvalues[TOKEN_KEYWORD_HOST].chars).toLower(); is_token2_needed= true; }
      if (token0 == "-i") token0= QString(strvalues[TOKEN_KEYWORD_IGNORE_SPACES].chars).toLower();
      if (token0 == "-j") token0= QString(strvalues[TOKEN_KEYWORD_SYSLOG].chars).toLower();
      if (token0 == "-L") token0= "skip_line_numbers";
      /* Somewhere I think I saw "l login-path" but it doesn't work with mysql client. */
      if (token0 == "-N") token0= "skip_column_names";
      if (token0 == "-n") token0= QString(strvalues[TOKEN_KEYWORD_UNBUFFERED].chars).toLower();
      if (token0 == "-o") token0= QString(strvalues[TOKEN_KEYWORD_ONE_DATABASE].chars).toLower();
      if (token0 == "-P") { token0= QString(strvalues[TOKEN_KEYWORD_PORT].chars).toLower(); is_token2_needed= true; }
      if (token0 == "-p") token0= QString(strvalues[TOKEN_KEYWORD_PASSWORD].chars).toLower();
      if (token0 == "-q") token0= QString(strvalues[TOKEN_KEYWORD_QUICK].chars).toLower();
      if (token0 == "-r") token0= QString(strvalues[TOKEN_KEYWORD_RAW].chars).toLower();
      if (token0 == "-S") { token0= QString(strvalues[TOKEN_KEYWORD_SOCKET].chars).toLower(); is_token2_needed= true; }
      if (token0 == "-s") token0= QString(strvalues[TOKEN_KEYWORD_SILENT].chars).toLower();
      if (token0 == "-T") token0= QString(strvalues[TOKEN_KEYWORD_DEBUG_INFO].chars).toLower();
      if (token0 == "-t") token0= QString(strvalues[TOKEN_KEYWORD_TABLE].chars).toLower();
      if (token0 == "-U") token0= QString(strvalues[TOKEN_KEYWORD_SAFE_UPDATES].chars).toLower();
      if (token0 == "-u") { token0= QString(strvalues[TOKEN_KEYWORD_USER].chars).toLower(); is_token2_needed= true; }
      if (token0 == "-V") token0= QString(strvalues[TOKEN_KEYWORD_VERSION].chars).toLower();
      if (token0 == "-v") token0= QString(strvalues[TOKEN_KEYWORD_VERBOSE].chars).toLower();
      if (token0 == "-W") token0= QString(strvalues[TOKEN_KEYWORD_PIPE].chars).toLower();
      if (token0 == "-w") token0= QString(strvalues[TOKEN_KEYWORD_WAIT].chars).toLower();
      if (token0 == "-X") token0= QString(strvalues[TOKEN_KEYWORD_XML].chars).toLower();
      if ((i < argc - 1) && (is_token2_needed == true) && (token2 == ""))
      {
        token1= "="; token2= argv[i + 1];
        ++i;
      }
    }
    /* If there are two '-'s then token0=argv[i] left, token1='=', token2=argv[i] right */
    else
    {
      QString equaller= "=";
      int equaller_index= s_argv.indexOf(equaller);
      int argv_length= strlen(argv[i]);
      if (equaller_index == -1)
      {
        token0= s_argv.mid(2, argv_length - 2);
        token1= "";
        token2= "";
        if (i < (argc - 1))
        {
          QString token_next= argv[i + 1];
          if (token_next.mid(0, 1) == "=")
          {
            ++i;
            if (token_next.size() == 1)
            {
              if (i < (argc - 1))
              {
                token2= argv[i + 1];
                ++i;
              }
            }
            else
            {
              token2= token_next.mid(1, token_next.size() - 1);
            }
          }
        }
      }
      else if ((equaller_index == (argv_length - 1)) && (argv_length > 3))
      {
        token0= s_argv.mid(2, argv_length - 3);
        token1= "=";
        token2= "";
        /* 2021-03-10 it turns out that password= --user=root should work (password is blank) */
        if ((i < (argc - 1)) && (argv[i + 1][0] != '-'))
        {
          token2= argv[i + 1];
          ++i;
        }
      }
      else
      {
        token0= s_argv.mid(2, equaller_index - 2);
        token1= "=";
        token2= s_argv.mid(equaller_index + 1, (argv_length - equaller_index) - 1);
      }
    }
    connect_set_variable(token0, token1, token2);
  }
}

/* todo: check if we've already looked at the file (this is possible if !include or !includedir happens)
         if so, skip */
/* todo: this might be okay for a Linux file that ends lines with \n, but what about Windows? */
/*
  Re groups:
    The MySQL mysql client looks for [client] and [mysql].
    The MariaDB mysql client looks for [client] and [mysql] and [client-server] and [mariadb-client].
    Re MariaDB-specific groups [client-server] and [client-mariadb]:
    The problem is that we don't know for sure we're connecting to a MariaB server until after we connect.
    For [client-server] I'm going to assume that anything in the group is probably valid for a MySQL server too.
    For [client-mariadb] we could depend on hints e.g. we actually opened mariadb.cnf file when asking for my.cnf,
    or we saw [client-server], or we saw the comment line "# The MariaDB configuration file", or the link is to
    a mariadb library,  but none of those things are certain proofs. Decision was: [client-mariadb] only matters
    when earlier we saw a setting ocelot_dbms=%mariadb% via cmake . -DDEFAULT_OPTION | command-line or on
    command line i.e. --ocelot_dbms=mariadb or earlier in .cnf file.
    Therefore ...
    We look for [client] and [mysql] and [client-server] always i.e. even if ocelot_dbms=tarantool.
    (There is no specific [tarantool] or [tarantool-client] group.)
    We also look for [client-mariadb] iff ocelot_dbms=mariadb has been specified.
    We allow cnf files to contain ocelot_dbms= and defaults_group_suffix= so anything after will depend on
    those settings, therefore the order of file reading matters, and therefore the print should say
    "(final settings)" which can be understood as "dbms or group suffix may have changed during my.cnf reading".
    The initial assumption is mysql but see CMakeLists.txt comment re
    cmake . -DDEFAULT_OPTION="--ocelot_dbms=mariadb".
    Groups can also have a suffix due to MYSQL_GROUP_SUFFIX or --defaults-group-suffix or .cnf.
    So if "ocelotgui" should be a group just say suffix is gui.
    We get a list of readable groups via my_cnf_groups_list() based on these comments.
    Todo: It would be faster to call my_cnf_groups_list() only at start or when we change dbms or suffix.
    Todo: mysql client sees [] as an ignorable group, we don't see it at all, though I guess it's undocumented.
*/
void MainWindow::connect_read_my_cnf(const char *file_name, int is_mylogin_cnf)
{
  log("connect_read_my_cnf", 15);
  //FILE *file;
  char line[2048];
  int token_offsets[100]; /* actually 10 is enough, currently */
  int token_lengths[100];
  int i;
  QString token0, token1, token2, token_for_value;
  QString group;                                         /* what was in the last [...] e.g. mysqld, client, mysql, ocelot */
  int token0_length, token1_length, token2_length;
  unsigned char output_buffer[65536];                    /* todo: should be dynamic size */

  group= "";                                             /* group identifier doesn't carry over from last .cnf file that we read */
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
  struct stat st;
  if (stat(file_name, &st) == 0)
  {
    if ((st.st_mode & S_IWOTH) == S_IWOTH)
    {
      printf("Ignoring world-writable configuration file %s.\n", file_name);
      return;
    }
  }
#endif
  QFile file(file_name);
  /* 2016-04-20 removed QIODevice::Text */
  bool open_result= file.open(QIODevice::ReadOnly);
  if (open_result == false)
  {
    return;                                              /* (if file doesn't exist, ok, no error */
  }
  //file= fopen(file_name, "r");                           /* Open specified file, read only */
  //if (file == NULL) return;                              /* (if file doesn't exist, ok, no error */
  /* Todo: Even if OCELOT_MYSQL_INCLUDE == 0) we should be able to read mylogin.cnf, find another way to get AES_decrypt */
#if (OCELOT_MYSQL_INCLUDE == 1)
  if (is_mylogin_cnf == 1)
  {
      /*
        todo: close file when return, including return for error
      */
      /*
        connect_readmylogin() is a variation of readmylogin.c
        AES_KEY and AES_BLOCK_SIZE are defined in ocelotgui.h
        If openSSL is not available, ignore it (mysql would always read because YaSSL is bundled).
        If .mylogin.cnf is not an encrypted file, ignore it (same as what mysql would do).
      */
      //int MainWindow::connect_readmylogin(QFile &file, unsigned char *output_buffer)
      {
        QString ldbms_return_string;

        ldbms_return_string= "";

        /* First find libcrypto.so */
        if (is_libcrypto_loaded != 1)
        {
          lmysql->ldbms_get_library(ocelot_ld_run_path, &is_libcrypto_loaded, &libcrypto_handle, &ldbms_return_string, WHICH_LIBRARY_LIBCRYPTO);
        }
        if (is_libcrypto_loaded != 1)
        {
          lmysql->ldbms_get_library("", &is_libcrypto_loaded, &libcrypto_handle, &ldbms_return_string, WHICH_LIBRARY_LIBCRYPTO);
        }
        if (is_libcrypto_loaded != 1)
        {
          file.close(); return; /* if decryption fails, ignore */
        }
        unsigned char cipher_chunk[4096];
        unsigned int cipher_chunk_length, output_length= 0, i;
        unsigned char key_in_file[20];
        unsigned char key_after_xor[AES_BLOCK_SIZE] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
        AES_KEY key_for_aes;

        if (file.seek(4) == false)
        //if (fseek(file, 4, SEEK_SET) != 0)
        {
          file.close(); return; /* if decryption fails, ignore */
        }
        if (file.read((char*)key_in_file, 20) != 20)
        //if (fread(key_in_file, 1, 20, file) != 20)
        {
          file.close(); return; /* if decryption fails, ignore */
        }

        for (i= 0; i < 20; ++i) *(key_after_xor + (i%16))^= *(key_in_file + i);
        lmysql->ldbms_AES_set_decrypt_key(key_after_xor, 128, &key_for_aes);

        while (file.read((char*)&cipher_chunk_length, 4) == 4)
        //while (fread(&cipher_chunk_length, 1, 4, file) == 4)
        {
          if (cipher_chunk_length > sizeof(cipher_chunk))
          {
            file.close(); return; /* if decryption fails, ignore */
          }
          if (file.read((char*)cipher_chunk, cipher_chunk_length) != cipher_chunk_length)
          //if (fread(cipher_chunk, 1, cipher_chunk_length, file) != cipher_chunk_length)
          {
            file.close(); return; /* if decryption fails, ignore */
          }
          for (i= 0; i < cipher_chunk_length; i+= AES_BLOCK_SIZE)
          {
            lmysql->ldbms_AES_decrypt(cipher_chunk+i, output_buffer+output_length, &key_for_aes);
            output_length+= AES_BLOCK_SIZE;
            while ((output_length > 0) && (*(output_buffer+(output_length-1)) < ' ') && (*(output_buffer+(output_length-1)) != '\n')) --output_length;
          }
        }
        *(output_buffer + output_length)= '\0';
        //return 0;
      }
  }
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  options_files_read.append(file_name); options_files_read.append(" ");
  char *fgets_result;
  int file_offset= 0;
  int line_offset= 0;
  for (;;)
  {
    if (is_mylogin_cnf == 0)
    {
      if (file.atEnd() == true) {fgets_result= NULL; }
      else
      {
        QByteArray qbline;
        qbline= file.readLine((sizeof line) - 1);
        int ii;
        for (ii= 0; ii < qbline.size(); ++ii) line[ii]= qbline[ii];
        line[ii]= '\0';
        //line= file.readLine(sizeof line);
        fgets_result=&line[0];
      }
      //fgets_result= fgets(line, sizeof line, file);
    }
    else
    {
      for (line_offset= 0; *(output_buffer + file_offset) != '\0'; ++line_offset, ++file_offset)
      {
        *(line + line_offset)= *(output_buffer + file_offset);
        if (*(line + line_offset) == '\n') { ++line_offset; ++file_offset; break; }
      }
      *(line + line_offset)= '\0';
      if (line_offset > 0) fgets_result= (char*) output_buffer;
      else fgets_result= NULL;
    }
    if (fgets_result == NULL) break;
    QString s= line;
    /* tokenize, ignore # comments or / * comments * /, treat '-' as part of token not operator */
    tokenize(s.data(),
             s.size(),
             &token_lengths[0], &token_offsets[0], 100 - 1,
            (QChar*)"33333", 2, "", 2);
    /* Ignore blank lines and lines that start with ';' */
    if (token_lengths[0] == 0) continue;
    if (QString::compare(s.mid(token_offsets[0], token_lengths[0]), ";", Qt::CaseInsensitive) == 0) continue;
    /* Possible meaningful lines are: [ group ], ! include x, ! includedir x, variable = value */
    token0_length= token_lengths[0];
    token0= s.mid(token_offsets[0], token0_length);
    token1_length= token_lengths[1];
    if (token1_length != 0) token1= s.mid(token_offsets[1], token1_length);
    else token1= "";
    if (token1_length == 0) token_lengths[2]= 0;
    token2_length= token_lengths[2];
    if (token2_length != 0)
    {
      int last_token;
      for (last_token= 3; token_lengths[last_token] != 0; ++last_token) ;
      token2_length= token_offsets[last_token - 1] + token_lengths[last_token - 1] - token_offsets[2];
      token2= s.mid(token_offsets[2], token2_length);
    }
    else token2= "";

    /* See if it's !include + file-name */
    /* todo: check for a sym link, or a directory. I don't know what we should do with such junk. */
    if ((QString::compare(token0, "!") == 0) && (QString::compare(token1, "include", Qt::CaseInsensitive) == 0))
    {
      char new_file_name[2048];
      strcpy(new_file_name,token2.toUtf8());
      *(new_file_name + token2_length)= 0;
      connect_read_my_cnf(new_file_name, 0);
    }
    ///* See if it's !includedir */
    //if ((QString::compare(token0, "!") == 0) && (QString::compare(token1, "includedir", Qt::CaseInsensitive) == 0))
    //{
    //  DIR *d;
    //  struct dirent *dir;
    //  char new_directory_name[2048];
    //  strcpy(new_directory_name,token2.toUtf8());
    //  *(new_directory_name + token2_length)= 0;
    //  d= opendir(new_directory_name);
    //  if (d)
    //  {
    //    while ((dir = readdir(d)) != NULL)
    //    {
    //      if ((strlen(dir->d_name)>4) && (strcmp(dir->d_name + strlen(dir->d_name) - 4, ".cnf") == 0))
    //      {
    //        char new_file_name[2048];
    //        strcpy(new_file_name, new_directory_name);
    //        strcat(new_file_name, "/");
    //        strcat(new_file_name, dir->d_name);
    //        connect_read_my_cnf(new_file_name, 0);
    //      }
    //    }
    //    closedir(d);
    //  }
    //}
    /* See if it's !includedir */
    /* Todo: there are no checks for looping; not sure what to do with hidden or symlink */
    if ((QString::compare(token0, "!") == 0) && (QString::compare(token1, "includedir", Qt::CaseInsensitive) == 0))
    {
      QDir dir(token2);
      dir.setFilter(QDir::Files | QDir::Hidden);
      QFileInfoList list= dir.entryInfoList();
      for (int i= 0; i < list.size(); ++i)
      {
        QFileInfo fileInfo= list.at(i);
#if defined(Q_OS_LINUX) || defined(Q_OS_FREEBSD)
        QString file_name= fileInfo.fileName();
        if (file_name.right(4) == ".cnf")
#endif
#ifdef Q_OS_WIN32
        QString file_name= fileInfo.fileName().toUpper();
        if ((file_name.right(4) == ".CNF") || (file_name.right(4) == ".INI"))
#endif
        {
          QString s= token2;
          s.append("/");
          s.append(fileInfo.fileName());
          char new_file_name[2048];
          strcpy(new_file_name, s.toUtf8());
          *(new_file_name + s.length())= '\0';
          connect_read_my_cnf(new_file_name, 0);
        }
      }
    }
    /* See if it's [ group ] */
    if ((QString::compare(token0, "[") == 0) && (QString::compare(token2,"]") == 0))
    {
      group= token1;
      continue;
    }
    if ((is_mylogin_cnf == 1) && (QString::compare(group, ocelot_login_path, Qt::CaseInsensitive) == 0))
    {
      /* it's in .mylogin.cnf and the group matches the specified login path */
    }
    else
    {
      /* Skip if it's not one of the groups that we care about, see comments preceding this function. */
      /* QStringList::contains() or QStringList::indexOf() would work but require newish Qt versions. */
      QStringList qs= my_cnf_groups_list();
      bool is_match= false;
      for (int i_in_group= 0; i_in_group < qs.size(); ++i_in_group)
      {
        if (QString::compare(group, qs.at(i_in_group), Qt::CaseInsensitive) == 0) is_match= true;
      }
      if (is_match == false) continue;
    }
    /* Remove ''s or ""s around the value, then strip lead or trail spaces. */
    token2= connect_stripper(token2, true);
    token2_length= token2.size();
    /* Convert escape sequences in the value \b backspace, \t tab, \n newline, \r carriage return, \\ \, \s space */
    token_for_value= "";
    for (i= 0; i < token2_length; ++i)
    {
      QString c, c2;
      c= token2.mid(i, 1);
      if ((c == "\\") && (i < token2_length))
      {
        c2= token2.mid(i + 1, 1);
        if (c2 == "b") { c2= "\x08"; token_for_value = token_for_value + c2; ++i; continue; }
        if (c2 == "t"){ c2= "\x09"; token_for_value = token_for_value + c2; ++i; continue; }
        if (c2 == "n"){ c2= "\x0a"; token_for_value = token_for_value + c2; ++i; continue; }
        if (c2 == "r") { c2= "\x0d"; token_for_value = token_for_value + c2; ++i; continue; }
        if (c2 == "\\") { c2= "\\"; token_for_value = token_for_value + c2; ++i; continue; }
        if (c2 == "s") { c2= "\x20"; token_for_value = token_for_value + c2; ++i; continue; }
      }
      token_for_value= token_for_value + c;
    }
    token2= token_for_value;
    connect_set_variable(token0, token1, token2);
  }
  file.close();
  //fclose(file);
}

/* Called by connect_read_my_cnf() + print_help(). See comments preceding connect_read_my_cnf(). */
QStringList MainWindow::my_cnf_groups_list()
{
  QStringList qs;
  qs.clear();
  qs.append("client");
  qs.append("mysql");
  qs.append("client-server");
  if (ocelot_dbms.contains("mariadb", Qt::CaseInsensitive) == true) qs.append("client-mariadb");
  qs.append("ocelot");
  if (ocelot_defaults_group_suffix > "")
  {
    int qs_size=qs.size();
    for (int i= 0; i < qs_size; ++i)
    {
      QString s= qs.at(i);
      qs.append(s + ocelot_defaults_group_suffix);
    }
  }
  return qs;
}

/*
  Remove ''s or ""s or ``s around a QString, then remove lead or trail spaces.
  Called for connect, and also for things like USE `test`.
  I didn't say remove lead or trail whitespace, so QString "trimmed()" is no good.
  Todo: This will also change 'xxx''yyy' to 'xxx'yyy', I'm not sure that's always good.
  todo: I'm not sure that `` (tildes) should be removed for my.cnf values, check that
        (we are depending on stripping of ``s when we call connect_stripper() with debuggee information status values)
  todo: I am fairly sure that I need to call this from other places too.
  Todo: strip_doublets_flag, i.e. change 'xxx''yyy' to xxx'yyy' etc., is currently only true
        for condition_1 and for command-line options. Maybe it should be more, maybe less.
*/
QString MainWindow::connect_stripper(QString value_to_strip, bool strip_doublets_flag)
{
  QString s;
  int s_length;
  char c_singlequote[2];
  char c_doublequote[2];
  char c_grave_accent[2]; /* Grave Accent is the Unicode term for `. MySQL calls it backtick. */

  s= value_to_strip;
  s_length= s.size();
  if (s_length > 1)
  {
    c_singlequote[0]= 0x27; c_singlequote[1]= 0;
    c_doublequote[0]= 0x22; c_doublequote[1]= 0;
    c_grave_accent[0]= 0x60; c_grave_accent[1]= 0;
    if (((s.mid(0, 1) == QString(c_singlequote)) && (s.mid(s_length - 1, 1) == QString(c_singlequote)))
    ||  ((s.mid(0, 1) == QString(c_doublequote)) && (s.mid(s_length - 1, 1) == QString(c_doublequote)))
    ||  ((s.mid(0, 1) == QString(c_grave_accent)) && (s.mid(s_length - 1, 1) == QString(c_grave_accent))))
    {
      QString strippable_char= s.mid(0, 1);                    /* strippable_char = " or ' or ` */
      s= s.mid(1, s_length - 2);
      while ((s.size() > 0) && (s.mid(0, 1) == " "))
      {
        s_length= s.size();
        s= s.mid(1, s_length - 1);
      }
      while ((s.size() > 0) && (s.mid(s.size() - 1, 1) == " "))
      {
        s_length= s.size();
        s= s.mid(0, s_length - 1);
      }
      if (strip_doublets_flag == true)
      {
        QString s2= "";
        for (int i= 0; i < s.size(); ++i)
        {
          QString c= s.mid(i, 1);
          s2.append(c);
          if ((c == strippable_char) && (i < (s.size() - 1)) && (c == s.mid(i + 1, 1))) ++i;
        }
        return s2;
      }
    }
  }
  return s;
}

/* Add ' at start and end of a string.
   Change ' to '' within string. Compare connect_stripper().
   with string literals inside single quotes. Need doublets.
   Todo: This is the same code as TextEditWidget::unstripper(),
         see whether you can reduce the duplication.
   Todo: Consider:
         if (co.contains("''")) co= co.replace("''", "'");
         Would surely be faster?
   Todo: We also have something in debug_debug_go for changing ' to '',
         maybe there's code duplication
   Todo: Maybe something in setup_generate_routine_entry_parameter
         has something similar too, maybe there's code duplication.
   Todo: debugger routines should call this when we generate statements
         but so far it's not happening
*/
QString MainWindow::connect_unstripper(QString value_to_unstrip)
{
  QString s;
  QString c;

  s= "'";
  for (int i= 0; i < value_to_unstrip.size(); ++i)
  {
    c= value_to_unstrip.mid(i, 1);
    s.append(c);
    if (c == "'") s.append(c);
  }
  s.append("'");
  return s;
}



/*
  Given token0=option-name [token1=equal-sign token2=value],
  see if option-name corresponds to one of your program-variables,
  and if so set program-variable = true or program-variable = value.
  For example, if token0="user", token1="=", token2="peter",
  then set ocelot_user = "peter".
  But that would be too simple, eh? So here are some complications:
  * unambiguous prefixes of option names are allowed until MySQL 5.7
    (this is true for options but not true for values)
    http://dev.mysql.com/doc/refman/5.6/en/program-options.html
  * '-' and '_' are interchangeable
    http://dev.mysql.com/doc/refman/5.6/en/command-line-options.html
  * if the target is numeric and ends with K etc., multiply by 1024 etc.
  option our variable name mysql variable name
  ------ ----------------- -------------------
  ho[st] ocelot_host       current_host
  us[er] ocelot_user       current_user
  database ocelot_database current_db
  so[cket] ocelot_unix_socket                opt_mysql_unix_port
  po[rt]   ocelot_port     mysql opt_mysql_port
  comm[ents] ocelot_comments preserve_comments
  ocelot_init_command opt_init_command
  ocelot_default_auth opt_default_auth
  no-defaults ocelot_no_defaults
  defaults-extra-file ocelot_defaults_extra_file
  defaults-file ocelot_defaults_file
  delimiter ocelot_delimiter_str
  show-warnings ocelot_history_includes_warnings
  connect_timeout ocelot_opt_connect_timeout
  compress ocelot_opt_compress
  secure_auth ocelot_secure_auth
  local_infile ocelot_opt_local_infile
  safe_updates or i_am_a_dummy ocelot_safe_updates
  plugin_dir ocelot_plugin_dir
  select_limit ocelot_select_limit
  max_join_size ocelot_max_join_size
  silent ocelot_silent
  no_beep ocelot_no_beep
  wait ocelot_wait
  default-character-set ocelot_default_character_set
*/
/*
  Re undocumented behaviour with option modifiers
  The rules in http://dev.mysql.com/doc/refman/5.7/en/option-modifiers.html
  "Program Option Modifiers" are weird already. To make it weirder, here's
  a partial description of undocumented behaviour of mysql client.
  For booleans:
  ! If first letter of value = '0' it's 0, if first letter of value = '1' it's 1
  ! --enable-disable-show-warnings is OK, the last prefix decides
  ! If enable|disable|skip was stated, and [= value] is stated, then
    If value = 0, then it reverses whatever enable|disable is in place so far
      Else [= value] clause is ignored
    Otherwise
      If value is blank or invalid, ignore the whole specification and warn
  For non-booleans:
  ! If we say --skip-port=5, then port = 0 i.e. override previous setting
  ! If we say --skip-delimiter=x then delimiter = ; i.e. return to default
  ! If we say --skip-socket=x then socket='0' i.e. override previous setting
  I try to follow some of this but not all.
*/
/*
  Re case sensitivity:
    * Effectively case sensitive for "skip_" etc. because we use strcmp()
    * Effectively case insensitive for keywords because get_keyword_index makes upper
    * For variables beginning "ocelot_" we may use strcasecmp rather than strcmp.
    * This is different from mysql which is usually case sensitive all the way
*/
void MainWindow::connect_set_variable(QString token0, QString token1, QString token2)
{
  unsigned int token0_length;
  char token0_as_utf8[80 + 1];
  unsigned short int is_enable;
  token0_length= token0.size();
  if (token0_length >= 64) return; /* no option name is ever longer than 80 bytes */
  strcpy(token0_as_utf8,token0.toUtf8());
  *(token0_as_utf8 + token0_length)= 0;
  for (int i= 0; token0_as_utf8[i] != '\0'; ++i)
  {
    if (token0_as_utf8[i] == '-') token0_as_utf8[i]= '_';
  }

  /* option modifiers: ignore loose, set enable=true if enable or false if disable|skip */
  is_enable= 1;
  bool is_enable_disable_skip_specified= false;
  for (;;)
  {
    if (strncmp(token0_as_utf8, "loose_", sizeof("loose_") - 1) == 0)
    {
      strcpy(token0_as_utf8, token0_as_utf8 + sizeof("loose_") - 1);
      continue;
    }
    if (strncmp(token0_as_utf8, "enable_", sizeof("enable_") - 1) == 0)
    {
      is_enable_disable_skip_specified= true;
      is_enable= 1;
      strcpy(token0_as_utf8, token0_as_utf8 + sizeof("enable_") - 1);
      continue;
    }
    if (strncmp(token0_as_utf8, "disable_", sizeof("disable_") - 1) == 0)
    {
      is_enable_disable_skip_specified= true;
      is_enable= 0;
      strcpy(token0_as_utf8, token0_as_utf8 + sizeof("disable_") - 1);
      continue;
    }
    if (strncmp(token0_as_utf8, "skip_", sizeof("skip_") - 1) == 0)
    {
      is_enable_disable_skip_specified= true;
      is_enable= 0;
      strcpy(token0_as_utf8, token0_as_utf8 + sizeof("skip_") - 1);
      continue;
    }
    break;
  }
  if ((is_enable_disable_skip_specified == false) && (token2 > ""))
  {
    QString token2_upper= token2.toUpper();
    if ((token2 == "ON") || (token2 == "TRUE") || (token2.left(1) == "1")) ;
    else if ((token2 == "OFF") || (token2 == "FALSE") || (token2.left(1) == "0")) is_enable= 0;
    else /* error */ is_enable= 0;
  }

  char key2[MAX_KEYWORD_LENGTH + 1];
  int keyword_index;
  keyword_index= get_keyword_index(token0_as_utf8, key2);
  /*
    Shortenings.
    These are obsolete, one should say --password= not -pas=, but we continue to accept them.
    Todo: put this inside "if keyword_index < 0" if you're sure there can be no ambiguity.
    Todo: let this be case insensitive like most other options, and compared with strvalues[] items.
    Todo: let i_am_a_dummy be part of the keyword list? */
  {
    if ((token0_length >= sizeof("pas") - 1) && (strncmp(token0_as_utf8, "password", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_PASSWORD;
    if ((token0_length >= sizeof("comm") - 1) && (strncmp(token0_as_utf8, "comments", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_COMMENTS;
    if ((token0_length >= sizeof("comp") - 1) && (strncmp(token0_as_utf8, "compress", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_COMPRESS;
    if ((token0_length >= sizeof("con") - 1) && (strncmp(token0_as_utf8, "connect_timeout", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_CONNECT_TIMEOUT;
    if ((token0_length >= sizeof("default_a") - 1) && (strncmp(token0_as_utf8, "default_auth", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_DEFAULT_AUTH;
    if ((token0_length >= sizeof("del") - 1) && (strncmp(token0_as_utf8, "delimiter", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_DELIMITER;
    if ((token0_length >= sizeof("ho") - 1) && (strncmp(token0_as_utf8, "host", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_HOST;
    if ((token0_length >= sizeof("i_") - 1) && (strncmp(token0_as_utf8, "i_am_a_dummy", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SAFE_UPDATES;
    if ((token0_length >= sizeof("loc") - 1) && (strncmp(token0_as_utf8, "local_infile", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_LOCAL_INFILE;
    if ((token0_length >= sizeof("max_j") - 1) && (strncmp(token0_as_utf8, "max_join_size", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_MAX_JOIN_SIZE;
    if ((token0_length >= sizeof("no_b") - 1) && (strncmp(token0_as_utf8, "no_beep", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_NO_BEEP;
    if ((token0_length >= sizeof("pas") - 1) && (strncmp(token0_as_utf8, "password", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_PASSWORD;
    if ((token0_length >= sizeof("pl") - 1) && (strncmp(token0_as_utf8, "plugin_dir", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_PLUGIN_DIR;
    if ((token0_length >= sizeof("po") - 1) && (strncmp(token0_as_utf8, "port", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_PORT;
    if ((token0_length >= sizeof("prot") - 1) && (strncmp(token0_as_utf8, "protocol", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_PROTOCOL;
    if ((token0_length >= sizeof("sa") - 1) && (strncmp(token0_as_utf8, "safe_updates", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SAFE_UPDATES;
    if ((token0_length >= sizeof("sec") -1 ) && (strncmp(token0_as_utf8, "secure_auth", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SECURE_AUTH;
    if ((token0_length >= sizeof("sel") - 1) && (strncmp(token0_as_utf8, "select_limit", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SELECT_LIMIT;
    if ((token0_length >= sizeof("sh") - 1) && (strncmp(token0_as_utf8, "show_warnings", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SHOW_WARNINGS;
    if ((token0_length >= sizeof("sil") - 1) && (strncmp(token0_as_utf8, "silent", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SILENT;
    if ((token0_length >= sizeof("so") - 1) && (strncmp(token0_as_utf8, "socket", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SOCKET;
    if ((token0_length >= sizeof("ssl_verify") - 1) && (strncmp(token0_as_utf8, "ssl_verify_server_cert", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SSL_VERIFY_SERVER_CERT;
    if ((token0_length >= sizeof("us") - 1) && (strncmp(token0_as_utf8, "user", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_USER;
    if ((token0_length >= sizeof("wa") - 1) && (strncmp(token0_as_utf8, "wait", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_WAIT;
  }

  if (keyword_index == TOKEN_KEYWORD_ABORT_SOURCE_ON_ERROR) { ocelot_abort_source_on_error= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_AUTO_REHASH) { ocelot_auto_rehash= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_AUTO_VERTICAL_OUTPUT) { ocelot_auto_vertical_output= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_BATCH)
  {
    ocelot_batch= is_enable;
    ocelot_silent= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_BINARY_MODE) { ocelot_binary_mode= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_BIND) /* not available in mysql client */
  {
    ocelot_opt_bind= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_BIND_ADDRESS) { ocelot_bind_address= is_enable; return; }

  if (keyword_index == TOKEN_KEYWORD_CONNECT_EXPIRED_PASSWORD) /* not available in mysql client before version 5.7 */
  {
    ocelot_opt_can_handle_expired_passwords= is_enable;
    return;
  }

  if (keyword_index == TOKEN_KEYWORD_CHARACTER_SETS_DIR)
  {
    ocelot_set_charset_dir= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_COLUMN_NAMES) {
    ocelot_result_grid_column_names= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_COLUMN_TYPE_INFO) { ocelot_column_type_info= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_COMMENTS)
  {
    ocelot_comments= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_COMPRESS)
  {
    ocelot_opt_compress= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_CONNECT_ATTR_DELETE) /* not available in mysql client */
  {
    ocelot_opt_connect_attr_delete= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_CONNECT_ATTR_RESET) /* not available in mysql client */
  {
    ocelot_opt_connect_attr_reset= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_CONNECT_TIMEOUT)
  {
    ocelot_opt_connect_timeout= to_long(token2);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_DATABASE)
  {
    ocelot_database= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_DEBUG) { ocelot_debug= token2; return; }
  if (keyword_index == TOKEN_KEYWORD_DEBUG_INFO) { ocelot_debug_info= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_DEFAULT_AUTH)
  {
    ocelot_default_auth= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_DEFAULT_CHARACTER_SET)
  {
    ocelot_set_charset_name= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_DEFAULTS_EXTRA_FILE)
  {
    ocelot_defaults_extra_file= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_DEFAULTS_FILE)
  {
    ocelot_defaults_file= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_DEFAULTS_GROUP_SUFFIX)
  {
    ocelot_defaults_group_suffix= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_DELIMITER)
  {
    ocelot_delimiter_str= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_ENABLE_CLEARTEXT_PLUGIN)
  {
    ocelot_enable_cleartext_plugin= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_EXECUTE) { ocelot_execute= token2; return; }
  if (keyword_index == TOKEN_KEYWORD_FORCE) { ocelot_force= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_HELP) { ocelot_help= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_HISTFILE) { ocelot_history_hist_file_name= token2; return; }
  if (keyword_index == TOKEN_KEYWORD_HISTIGNORE) { ocelot_histignore= token2; return; }
  if (keyword_index == TOKEN_KEYWORD_HOST)
  {
    ocelot_host= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_HTML) { ocelot_html= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_SAFE_UPDATES) /* Actually this could be "i-am-a-dummy" */
  {
    ocelot_safe_updates= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_IGNORE_SPACES) { ocelot_ignore_spaces= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_LD_RUN_PATH) { ocelot_ld_run_path= token2; return; }
  if (keyword_index == TOKEN_KEYWORD_INIT_COMMAND)
  {
    ocelot_init_command= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_LINE_NUMBERS) { ocelot_line_numbers= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_LOCAL_INFILE)
  {
    if (token2 > "") ocelot_opt_local_infile= to_long(token2);
    else ocelot_opt_local_infile= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_LOGIN_PATH) { ocelot_login_path= token2; return; }
  if (keyword_index == TOKEN_KEYWORD_MAX_ALLOWED_PACKET) { ocelot_max_allowed_packet= to_long(token2); return; }
  if (keyword_index == TOKEN_KEYWORD_MAX_JOIN_SIZE)
  {
    ocelot_max_join_size= to_long(token2);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_NAMED_COMMANDS) { ocelot_named_commands= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_NET_BUFFER_LENGTH) { ocelot_net_buffer_length= to_long(token2); return; }
  if (keyword_index == TOKEN_KEYWORD_NO_AUTO_REHASH) { ocelot_auto_rehash= 0; return; }
  if (keyword_index == TOKEN_KEYWORD_NO_BEEP)
  {
    ocelot_no_beep= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_NO_DEFAULTS) { ocelot_no_defaults= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_NO_NAMED_COMMANDS) { ocelot_named_commands= 0; return; }
  if (keyword_index == TOKEN_KEYWORD_NO_TEE) { history_file_stop("TEE"); return; }/* see comment=tee+hist */

  QString ccn;
  /* Changes to ocelot_* settings. But we don't check that they're in the [ocelot] group. */
  /* Todo: validity checks */

  if (keyword_index == TOKEN_KEYWORD_OCELOT_DBMS)
  {
    /* Warning: what we do here may be overridden after connection, by set_dbms_version_mask() */
    ocelot_dbms= token2;
    if (ocelot_dbms.contains("mysql", Qt::CaseInsensitive) == true)
    {
      connections_dbms[0]= DBMS_MYSQL;
    }
    else if (ocelot_dbms.contains("mariadb", Qt::CaseInsensitive) == true)
    {
      connections_dbms[0]= DBMS_MARIADB;
    }
#ifdef DBMS_TARANTOOL
    else if (ocelot_dbms.contains("tarantool", Qt::CaseInsensitive) == true)
    {
      connections_dbms[0]= DBMS_TARANTOOL;
    }
#endif
    else connections_dbms[0]= DBMS_MYSQL; /* default */
#if (OCELOT_MYSQL_INCLUDE == 0)
    connections_dbms[0]= DBMS_TARANTOOL; /* default if no MySQL */
#endif //#if (OCELOT_MYSQL_INCLUDE == 0)
    return;
  }
#ifdef OCELOT_IMPORT_EXPORT
  if (keyword_index == TOKEN_KEYWORD_OCELOT_EXPORT)
  {
    import_export_rule_set(token2);
    return;
  }
#endif
  if (keyword_index == TOKEN_KEYWORD_OCELOT_CLIENT_SIDE_FUNCTIONS) { ocelot_client_side_functions= is_enable; return; }
  else
  {
    /* Anything that starts with "ocelot_" except "ocelot_dbms" "ocelot_client_side_functions" "ocelot_export" */
    if (xsettings_widget->ocelot_variable_set(keyword_index, token2) != ER_OVERFLOW)
    {
      /* It might not be ER_OK but we ignore errors here */
      return;
    }
  }
  if (keyword_index == TOKEN_KEYWORD_ONE_DATABASE) { ocelot_one_database= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_PAGER) { ocelot_pager= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_PASSWORD)
  {
    ocelot_password= token2;
    ocelot_password_was_specified= is_enable;
    if ((is_enable == 1) && (token1 != "=")) ocelot_password_was_specified= 2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_PIPE) /* Not sure about this. Windows. Same as protocol? */
  {
    ocelot_opt_named_pipe= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_PLUGIN_DIR)
  {
    ocelot_plugin_dir= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_PORT)
  {
    ocelot_port= to_long(token2);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_PRINT_DEFAULTS) { ocelot_print_defaults= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_PROMPT) { ocelot_prompt= token2; ocelot_prompt_is_default= false; return; }
  if (keyword_index == TOKEN_KEYWORD_PROTOCOL)
  {
    ocelot_protocol= token2; /* Todo: perhaps make sure it's tcp/socket/pipe/memory */
    ocelot_protocol_as_int= get_ocelot_protocol_as_int(ocelot_protocol);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_QUICK) { ocelot_quick= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_RAW) { ocelot_raw= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_READ_DEFAULT_FILE) /* not available in mysql client */
  {
    ocelot_read_default_file= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_READ_DEFAULT_GROUP) /* not available in mysql client */
  {
    ocelot_read_default_group= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_READ_TIMEOUT) /* not available in mysql client */
  {
    ocelot_opt_read_timeout= to_long(token2);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_RECONNECT)
  {
    ocelot_opt_reconnect= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_REPORT_DATA_TRUNCATION)/* not available in mysql client */
  {
    ocelot_report_data_truncation= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SAFE_UPDATES)
  {
    ocelot_safe_updates= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SECURE_AUTH)
  {
    ocelot_secure_auth= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SERVER_PUBLIC_KEY) /* not available in mysql client */
  {
    ocelot_server_public_key= token2;
    return;
  }
   if (keyword_index == TOKEN_KEYWORD_SELECT_LIMIT)
  {
    ocelot_select_limit= to_long(token2);
    return;
  }

  if (keyword_index == TOKEN_KEYWORD_SHARED_MEMORY_BASE_NAME)
  {
    ocelot_shared_memory_base_name= token2;
    return;
    }
  if (keyword_index == TOKEN_KEYWORD_SHOW_WARNINGS)
  {
    ocelot_history_includes_warnings= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SIGINT_IGNORE) { ocelot_sigint_ignore= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_SILENT)
  {
    ocelot_silent= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SOCKET)
  {
    ocelot_unix_socket= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL)
  {
    ocelot_opt_ssl= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_CA)
  {
    ocelot_opt_ssl_ca= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_CAPATH)
  {
    ocelot_opt_ssl_capath= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_CERT)
  {
    ocelot_opt_ssl_cert= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_CIPHER)
  {
    ocelot_opt_ssl_cipher= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_CRL)
  {
    ocelot_opt_ssl_crl= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_CRLPATH)
  {
    ocelot_opt_ssl_crlpath= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_KEY)
  {
    ocelot_opt_ssl_key= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_MODE)
  {
    ocelot_opt_ssl_mode= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_VERIFY_SERVER_CERT)
  {
    ocelot_opt_ssl_verify_server_cert= to_long(token2);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SYSLOG) { ocelot_syslog= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_TABLE) { ocelot_table= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_TEE)
  {
    QString rr;
    history_file_start("TEE", token2, &rr); /* todo: check whether history_file_start returned 0 which is an error */ /* see comment=tee+hist */
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_UNBUFFERED) { ocelot_unbuffered= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_USE_RESULT)/* not available in mysql client */
  {
    ocelot_opt_use_result= to_long(token2);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_USER)
  {
    ocelot_user= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_VERBOSE) { ocelot_verbose= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_VERSION) { ocelot_version= is_enable; return; }
  /* todo: check that this finds both --vertical and -E */ /* for vertical */
  if (keyword_index == TOKEN_KEYWORD_VERTICAL) { ocelot_vertical= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_WAIT)
  {
    ocelot_wait= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_WRITE_TIMEOUT)
  {
    ocelot_opt_write_timeout= to_long(token2);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_XML)
  {
    ocelot_xml= is_enable;
    return;
  }
}


/*
  Given the options that have actually been set to non-default values,
  form a CONNECT statement.
  todo: something should call this for the sake of history, at least.
  todo: instead o x > "", use if (QString::compare(x, " ") > 0)
*/
void MainWindow::connect_make_statement()
{
  /* Todo: QMessageBox should have a parent, use "= new" */
  QMessageBox msgBox;
  QString statement_text;
  statement_text= "CONNECT";
  if (ocelot_defaults_file > "") statement_text= statement_text + " defaults_file=" + ocelot_defaults_file;
  if (ocelot_no_defaults > 0) statement_text= statement_text + " no_defaults";
  if (ocelot_defaults_extra_file > "") statement_text= statement_text + " defaults_extra_file=" + ocelot_defaults_extra_file;
  if (ocelot_host > "") statement_text= statement_text + " host=" + ocelot_host;
  if (ocelot_user > "") statement_text= statement_text + " user=" + ocelot_user;
  if (ocelot_database > "") statement_text= statement_text + " database=" + ocelot_database;
  if (ocelot_port > 0) statement_text= statement_text + " port=" + QString::number(ocelot_port);
  if (ocelot_comments > 0) statement_text= statement_text + " comments";
  if (ocelot_init_command > "") statement_text= statement_text + " init_command=" + ocelot_init_command;
  if (ocelot_default_auth > "") statement_text= statement_text + " default_auth=" + ocelot_default_auth;
  if (ocelot_protocol > "") statement_text= statement_text + " protocol=" + ocelot_protocol;
  if (ocelot_password_was_specified > 0) statement_text= statement_text + " password=" + ocelot_password;
  if (ocelot_unix_socket > "") statement_text= statement_text + " socket=" + ocelot_unix_socket;
  if (ocelot_delimiter_str > "") statement_text= statement_text + " delimiter=" + ocelot_delimiter_str;
  if (ocelot_history_includes_warnings > 0) statement_text= statement_text + " show_warnings";
  if (ocelot_opt_connect_timeout > 0) statement_text= statement_text + " connect_timeout=" + QString::number(ocelot_opt_connect_timeout);
  if (ocelot_opt_compress > 0) statement_text= statement_text + " compress";
  if (ocelot_secure_auth > 0) statement_text= statement_text + " secure_auth";
  if (ocelot_opt_local_infile > 0) statement_text= statement_text + " local_infile";
  if (ocelot_safe_updates > 0) statement_text= statement_text + " safe_updates";
  if (ocelot_plugin_dir > "") statement_text= statement_text + " plugin_dir=" + ocelot_plugin_dir;
  if (ocelot_select_limit > 0) statement_text= statement_text + " select_limit=" + QString::number(ocelot_select_limit);
  if (ocelot_max_join_size > 0) statement_text= statement_text + " max_join_size=" + QString::number(ocelot_max_join_size);
  if (ocelot_silent > 0) statement_text= statement_text + " silent";
  if (ocelot_no_beep > 0) statement_text= statement_text + "no_beep";
  if (ocelot_wait > 0) statement_text= statement_text + "wait";
  if (ocelot_set_charset_name > "") statement_text= statement_text + "default_character_set=" + ocelot_set_charset_name;
  if (ocelot_opt_ssl > "") statement_text= statement_text + "ssl=" + ocelot_opt_ssl;
  if (ocelot_opt_ssl_ca > "") statement_text= statement_text + "ssl_ca=" + ocelot_opt_ssl_ca;
  if (ocelot_opt_ssl_capath > "") statement_text= statement_text + "ssl_capath=" + ocelot_opt_ssl_capath;
  if (ocelot_opt_ssl_cert > "") statement_text= statement_text + "ssl_cert=" + ocelot_opt_ssl_cert;
  if (ocelot_opt_ssl_cipher > "") statement_text= statement_text + "ssl_cipher=" + ocelot_opt_ssl_cipher;
  if (ocelot_opt_ssl_crl > "") statement_text= statement_text + "ssl_crl=" + ocelot_opt_ssl_crl;
  if (ocelot_opt_ssl_crlpath > "") statement_text= statement_text + "ssl_crlpath=" + ocelot_opt_ssl_crlpath;
  if (ocelot_opt_ssl_key > "") statement_text= statement_text + "ssl_key=" + ocelot_opt_ssl_key;
  if (ocelot_opt_ssl_mode > "") statement_text= statement_text + "ssl_mode=" + ocelot_opt_ssl_mode;
  if (ocelot_opt_ssl_verify_server_cert > 0) statement_text= statement_text + "ssl_verify_server_cert=" + ocelot_opt_ssl_verify_server_cert;
  msgBox.setText(statement_text);
  msgBox.exec();
}

#define PROTOCOL_TCP 1
#define PROTOCOL_SOCKET 2
#define PROTOCOL_PIPE 3
#define PROTOCOL_MEMORY 4
unsigned int MainWindow::get_ocelot_protocol_as_int(QString ocelot_protocol)
{
  if (QString::compare(ocelot_protocol, "TCP", Qt::CaseInsensitive) == 0) return PROTOCOL_TCP;
  if (QString::compare(ocelot_protocol, "SOCKET", Qt::CaseInsensitive) == 0) return PROTOCOL_SOCKET;
  if (QString::compare(ocelot_protocol, "PIPE", Qt::CaseInsensitive) == 0) return PROTOCOL_PIPE;
  if (QString::compare(ocelot_protocol, "MEMORY", Qt::CaseInsensitive) == 0) return PROTOCOL_MEMORY;
  return 0;
}

#if (OCELOT_MYSQL_INCLUDE == 1)
/*
  Todo: this routine calls mysql_options() iff option value != 0,
  forgetting that 0 might be non-default, or a change from non-0.
  Also it doesn't check whether mysql_options() failed, but okay.
  Note: we don't pass ocelot_opt_can_handle_expired_passwords because
  it does nothing (maybe due to an old libmysqlclient?), instead we
  pass client_can_handle_expired_passwords to mysql_real_connect().

  Re MySQL 5.7.11 and ssl_mode: mysql allows truncation e.g.
  --ssl_mode='PREF' but we don't it must be in full.
  We don't know in advance whether we'll be connecting with MySQL 5.7.11
  so we'll call only if we (not MariaDB|Tarantool) and (not default).
  Our default is '' but we'll also do nothing if 'preferred'.
  Check if mysql_options() returns != 0 indicating libmysqlclient
  doesn't recognize MYSQL_OPT_SSL_MODE, if so assume it didn't work.
  If it's VERIFY_IDENTITY, we don't try to use --ssl-verify-server-cert.
  It should mean we don't try to use --ssl, but we don't anyway.
*/
int options_and_connect(
    unsigned int connection_number,
    char *database_as_utf8)
{
  if (connected[connection_number] != 0)
  {
    connected[connection_number]= 0;
    lmysql->ldbms_mysql_close(&mysql[connection_number]);
  }
#ifdef _WIN32
  /* Actually this has no effect in my tests. Maybe just superstition. */
  /* But it's harmless. See https://bugs.mysql.com/bug.php?id=8059 */
  int padding= 42;
  mysql_init(&mysql[connection_number]);
#else
  lmysql->ldbms_mysql_init(&mysql[connection_number]);
#endif
  int opt= 0;
  if (ocelot_default_auth_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_23, ocelot_default_auth_as_utf8);
  if (ocelot_enable_cleartext_plugin == true) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_36, (char *) &ocelot_enable_cleartext_plugin);
  if (ocelot_init_command_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_3, ocelot_init_command_as_utf8);
  if (ocelot_opt_bind_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_24, ocelot_opt_bind_as_utf8);
  if (ocelot_opt_compress > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_1, NULL);
  if (ocelot_opt_connect_attr_delete_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_34, ocelot_opt_connect_attr_delete_as_utf8);
  if (ocelot_opt_connect_attr_reset != 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_32, (char*) &ocelot_opt_connect_attr_reset);
  if (ocelot_opt_connect_timeout != 0)
  {
    unsigned int timeout= ocelot_opt_connect_timeout;
    lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_0, (char*) &timeout);
  }
  if (ocelot_opt_local_infile > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_8, (char*) &ocelot_opt_local_infile);
  if (ocelot_opt_named_pipe > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_2, (char*) &ocelot_opt_named_pipe);
  if (ocelot_protocol_as_int > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_9, (char*)&ocelot_protocol_as_int);
  if (ocelot_opt_read_timeout > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_11, (char*)&ocelot_opt_read_timeout);
  if (ocelot_opt_reconnect > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_20, (char*)&ocelot_opt_reconnect);

  if (ocelot_opt_ssl_mode_as_utf8[0] != '\0')
  {
    for(int i= 0; ocelot_opt_ssl_mode_as_utf8[i] != 0; ++i)
    {
      ocelot_opt_ssl_mode_as_utf8[i] = toupper(ocelot_opt_ssl_mode_as_utf8[i]);
    }
    if (strcmp(ocelot_opt_ssl_mode_as_utf8, "DISABLED") == 0) opt= 1;
    if (strcmp(ocelot_opt_ssl_mode_as_utf8, "PREFERRED") == 0) opt= 2;
    if (strcmp(ocelot_opt_ssl_mode_as_utf8, "REQUIRED") == 0) opt= 3;
    if (strcmp(ocelot_opt_ssl_mode_as_utf8, "VERIFY_CA") == 0) opt= 4;
    if (strcmp(ocelot_opt_ssl_mode_as_utf8, "VERIFY_IDENTITY") == 0) opt= 5;
    if (opt != 0)
    {
      if (lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_42, (char*) &opt) != 0)
      {
        opt= 0;
      }
    }
  }

  /*
    If dlopen() failed for "myql_ssl_set" then ldbms_mysql_ssl_set is a no-op, which is not an error.
    For some options use mysql_ssl_set because it's in MySQL 5.5, for others use mysql_options.
    We treat "" as the same as NULL, and prefer to pass NULL.
    Instead of looking at ocelot_opt_ssl, we check whether anything is non-NULL.
  */
  {
    char *a= 0, *b= 0, *c= 0, *d= 0, *e= 0;
    if (ocelot_opt_ssl_key_as_utf8[0] != '\0') a= ocelot_opt_ssl_key_as_utf8;
    if (ocelot_opt_ssl_cert_as_utf8[0] != '\0') b= ocelot_opt_ssl_cert_as_utf8;
    if (ocelot_opt_ssl_ca_as_utf8[0] != '\0') c= ocelot_opt_ssl_ca_as_utf8;
    if (ocelot_opt_ssl_capath_as_utf8[0] != '\0') d= ocelot_opt_ssl_capath_as_utf8;
    if (ocelot_opt_ssl_cipher_as_utf8[0] != '\0') e= ocelot_opt_ssl_cipher_as_utf8;
    if ((a != 0) || (b != 0) || (c != 0) || (d != 0) || (e != 0))
    {
      lmysql->ldbms_mysql_ssl_set(&mysql[connection_number], a, b, c, d, e);
    }
  }
  if (ocelot_opt_ssl_crl_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_30, ocelot_opt_ssl_crl_as_utf8);
  if (ocelot_opt_ssl_crlpath_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_31, ocelot_opt_ssl_crlpath_as_utf8);
  if (opt != 5)
  {
    if (ocelot_opt_ssl_verify_server_cert > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_21, (char*) &ocelot_opt_ssl_verify_server_cert);
  }
  if (ocelot_opt_write_timeout > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_12, (char*) &ocelot_opt_write_timeout);
  if (ocelot_plugin_dir_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_22, ocelot_plugin_dir_as_utf8);
  if (ocelot_read_default_file_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_4, ocelot_read_default_file_as_utf8);
  if (ocelot_read_default_group_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_5, ocelot_read_default_group_as_utf8);
  if (ocelot_report_data_truncation > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_19, (char*) &ocelot_report_data_truncation);
  /* secure_auth causes trouble in MySQL 8 and hasn't been useful for years so do not pass it */
  //if (ocelot_secure_auth > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_18, (char *) &ocelot_secure_auth);
  if (ocelot_server_public_key_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_35, ocelot_server_public_key_as_utf8);
  if (ocelot_set_charset_dir_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_6, ocelot_set_charset_dir_as_utf8);
  if (ocelot_set_charset_name_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_7, ocelot_set_charset_name_as_utf8);
  if (ocelot_shared_memory_base_name_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_10, ocelot_shared_memory_base_name_as_utf8);
  if (ocelot_safe_updates > 0)
  {
    char init_command[100]; /* todo: the size could be more dynamic here */
    sprintf(init_command,
        "SET sql_select_limit = %lu, sql_safe_updates = 1, max_join_size = %lu",
        ocelot_select_limit, ocelot_max_join_size);
    lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_3, init_command);
  }
  /* CLIENT_MULTI_RESULTS but not CLIENT_MULTI_STATEMENTS */
  unsigned long real_connect_flags= CLIENT_MULTI_RESULTS;

  if (ocelot_opt_can_handle_expired_passwords != 0)
    real_connect_flags|= (1UL << 22); /* CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS */

  MYSQL *connect_result;
  char *socket_parameter= ocelot_unix_socket_as_utf8;

  for (int connect_attempt= 0; connect_attempt < 6; ++connect_attempt)
  {
    connect_result= lmysql->ldbms_mysql_real_connect(&mysql[connection_number],
                                                     ocelot_host_as_utf8,
                                                     ocelot_user_as_utf8,
                                                     ocelot_password_as_utf8,
                                                     database_as_utf8,
                                                     ocelot_port,
                                                     socket_parameter,
                                                     real_connect_flags);
     if (connect_result != NULL) break;
     /* See ocelot.ca blog post = Connecting to MySQL or MariaDB with sockets on Linux */
     /* Todo: you should provide info somewhere how the connection was actually done. */
     if ((ocelot_protocol_as_int != 0) && (ocelot_protocol_as_int != PROTOCOL_SOCKET)) break;
#ifdef _WIN32
     break;
#endif
     if ((ocelot_unix_socket_as_utf8 != 0) && (strcmp(ocelot_unix_socket_as_utf8, "") != 0)) break;
     if ((ocelot_host_as_utf8 != 0) && (strcmp(ocelot_host_as_utf8,"") != 0) && (strcmp(ocelot_host_as_utf8, "localhost") != 0)) break;
     if (lmysql->ldbms_mysql_errno(&mysql[connection_number]) != 2002) break; /* 2002 == CR_CONNECTION_ERROR */
     if (connect_attempt == 0) socket_parameter= (char *) "/tmp/mysql.sock";
     if (connect_attempt == 1) socket_parameter= (char *) "/var/lib/mysql/mysql.sock";
     if (connect_attempt == 2) socket_parameter= (char *) "/var/run/mysqld/mysqld.sock";
     if (connect_attempt == 3) socket_parameter= (char *) "/var/run/mysql/mysql.sock";
     if (connect_attempt == 4) socket_parameter= (char *) "/tmp/mysqld.sock";
   }

  if (connect_result == NULL)
  {
    /* connect failed. todo: better diagnostics? anyway, user can retry, a dialog box will come up. */
    return -1;					// Retryable
  }

  /*
    Tell the server: characters from the client are UTF8, characters going to the client are UTF8.
    This partially overrides --default_character_set, except there's no change to character_set_connection.
    Todo: Eventually UTF8MB4 will be preferable but check server version before trying that.
    Todo: We could have an option to receive in UTF16 which is what Qt would prefer.
    Todo: We should warn or disallow if user tries to change these.
    Todo: Think what we're going to do with file I/O, e.g. the user might expect it to be ujis.
    Todo: This makes the server do conversions. Eventually the client could do the conversions but that's lots of work.
    Todo: Worry that there might be some way to start Qt with different character-set assumptions.
    Todo: Worry that we haven't got a plan for _latin2 'string' etc. although we could get the server to translate for us
  */
  if (lmysql->ldbms_mysql_query(&mysql[connection_number], "set character_set_client = utf8")) printf("SET character_set_client failed\n");
  if (lmysql->ldbms_mysql_query(&mysql[connection_number], "set character_set_results = utf8")) printf("SET character_set_results failed\n");

  connected[connection_number]= 1;
  return 0;
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

/*
  Convert string to long.
  For numeric connect-related tokens, K means 1024, M means 1024**2, G means 1024**3.
  Actually the token might be unsigned int or unsigned long, but this will do.
*/
long MainWindow::to_long(QString token)
{
  QString kmg;
  QString token_without_kmg;
  long return_value;

  kmg= token.right(1).toUpper();
  if ((kmg == "K") || (kmg == "M") || (kmg == "G"))
  {
    token_without_kmg= token.left(token.size() - 1);
    return_value= token_without_kmg.toLong();
    if (kmg == "K") return_value *= 1024;
    if (kmg == "M") return_value *= 1024 * 1024;
    if (kmg == "G") return_value *= 1024 * 1024 * 1024;
  }
  else return_value= token.toLong();
  return return_value;

}

/*
  called from: copy_connect_strings_to_utf8(), to initialize before making new copies
  called from: action_exit(), to avoid valgrind complaints
*/
void MainWindow::delete_utf8_copies()
{
  if (ocelot_host_as_utf8 != 0) { delete [] ocelot_host_as_utf8; ocelot_host_as_utf8= 0; }
  if (ocelot_database_as_utf8 != 0) { delete [] ocelot_database_as_utf8; ocelot_database_as_utf8= 0; }
  if (ocelot_user_as_utf8 != 0) { delete [] ocelot_user_as_utf8; ocelot_user_as_utf8= 0; }
  if (ocelot_password_as_utf8 != 0) { delete [] ocelot_password_as_utf8; ocelot_password_as_utf8= 0; }
  if (ocelot_default_auth_as_utf8 != 0) { delete [] ocelot_default_auth_as_utf8; ocelot_default_auth_as_utf8= 0; }
  if (ocelot_default_auth_as_utf8 != 0) { delete [] ocelot_default_auth_as_utf8; ocelot_default_auth_as_utf8= 0; }
  if (ocelot_default_auth_as_utf8 != 0) { delete [] ocelot_default_auth_as_utf8; ocelot_default_auth_as_utf8= 0; }
  if (ocelot_opt_bind_as_utf8 != 0) { delete [] ocelot_opt_bind_as_utf8; ocelot_opt_bind_as_utf8= 0; }
  if (ocelot_opt_connect_attr_delete_as_utf8 != 0) { delete [] ocelot_opt_connect_attr_delete_as_utf8; ocelot_opt_connect_attr_delete_as_utf8= 0; }
  if (ocelot_opt_ssl_as_utf8 != 0) { delete [] ocelot_opt_ssl_as_utf8; ocelot_opt_ssl_as_utf8= 0; }
  if (ocelot_opt_ssl_ca_as_utf8 != 0) { delete [] ocelot_opt_ssl_ca_as_utf8; ocelot_opt_ssl_ca_as_utf8= 0; }
  if (ocelot_opt_ssl_capath_as_utf8 != 0) { delete [] ocelot_opt_ssl_capath_as_utf8; ocelot_opt_ssl_capath_as_utf8= 0; }
  if (ocelot_opt_ssl_cert_as_utf8 != 0) { delete [] ocelot_opt_ssl_cert_as_utf8; ocelot_opt_ssl_cert_as_utf8= 0; }
  if (ocelot_opt_ssl_cipher_as_utf8 != 0) { delete [] ocelot_opt_ssl_cipher_as_utf8; ocelot_opt_ssl_cipher_as_utf8= 0; }
  if (ocelot_opt_ssl_crl_as_utf8 != 0) { delete [] ocelot_opt_ssl_crl_as_utf8; ocelot_opt_ssl_crl_as_utf8= 0; }
  if (ocelot_opt_ssl_crlpath_as_utf8 != 0) { delete [] ocelot_opt_ssl_crlpath_as_utf8; ocelot_opt_ssl_crlpath_as_utf8= 0; }
  if (ocelot_opt_ssl_key_as_utf8 != 0) { delete [] ocelot_opt_ssl_key_as_utf8; ocelot_opt_ssl_key_as_utf8= 0; }
  if (ocelot_opt_ssl_mode_as_utf8 != 0) { delete [] ocelot_opt_ssl_mode_as_utf8; ocelot_opt_ssl_mode_as_utf8= 0; }
  if (ocelot_plugin_dir_as_utf8 != 0) { delete [] ocelot_plugin_dir_as_utf8; ocelot_plugin_dir_as_utf8= 0; }
  if (ocelot_read_default_group_as_utf8 != 0) { delete [] ocelot_read_default_group_as_utf8; ocelot_read_default_group_as_utf8= 0; }
  if (ocelot_read_default_file_as_utf8 != 0) { delete [] ocelot_read_default_file_as_utf8; ocelot_read_default_file_as_utf8= 0; }
  if (ocelot_server_public_key_as_utf8 != 0) { delete [] ocelot_server_public_key_as_utf8; ocelot_server_public_key_as_utf8= 0; }
  if (ocelot_unix_socket_as_utf8 != 0) { delete [] ocelot_unix_socket_as_utf8; ocelot_unix_socket_as_utf8= 0; }
  if (ocelot_set_charset_dir_as_utf8 != 0) { delete [] ocelot_set_charset_dir_as_utf8; ocelot_set_charset_dir_as_utf8= 0; }
  if (ocelot_set_charset_name_as_utf8 != 0) { delete [] ocelot_set_charset_name_as_utf8; ocelot_set_charset_name_as_utf8= 0; }
  if (ocelot_shared_memory_base_name_as_utf8 != 0) { delete [] ocelot_shared_memory_base_name_as_utf8; ocelot_shared_memory_base_name_as_utf8= 0; }
}

/* Todo: check every one of the "new ..." results for failure. */
void MainWindow::copy_connect_strings_to_utf8()
{
  delete_utf8_copies();
  /* See comment "UTF8 Conversion" */

  int tmp_host_len= ocelot_host.toUtf8().size();
  ocelot_host_as_utf8= new char[tmp_host_len + 1];
  memcpy(ocelot_host_as_utf8, ocelot_host.toUtf8().constData(), tmp_host_len + 1);

  int tmp_database_len= ocelot_database.toUtf8().size();
  ocelot_database_as_utf8= new char[tmp_database_len + 1];
  memcpy(ocelot_database_as_utf8, ocelot_database.toUtf8().constData(), tmp_database_len + 1);

  int tmp_user_len= ocelot_user.toUtf8().size();
  ocelot_user_as_utf8= new char[tmp_user_len + 1];
  memcpy(ocelot_user_as_utf8, ocelot_user.toUtf8().constData(), tmp_user_len + 1);

  int tmp_password_len= ocelot_password.toUtf8().size();
  ocelot_password_as_utf8= new char[tmp_password_len + 1];
  memcpy(ocelot_password_as_utf8, ocelot_password.toUtf8().constData(), tmp_password_len + 1);

  int tmp_default_auth_len= ocelot_default_auth.toUtf8().size();
  ocelot_default_auth_as_utf8= new char[tmp_default_auth_len + 1];
  memcpy(ocelot_default_auth_as_utf8, ocelot_default_auth.toUtf8().constData(), tmp_default_auth_len + 1);

  int tmp_init_command_len= ocelot_init_command.toUtf8().size();
  ocelot_init_command_as_utf8= new char[tmp_init_command_len + 1];
  memcpy(ocelot_init_command_as_utf8, ocelot_init_command.toUtf8().constData(), tmp_init_command_len + 1);

  int tmp_opt_bind_len= ocelot_opt_bind.toUtf8().size();
  ocelot_opt_bind_as_utf8= new char[tmp_opt_bind_len + 1];
  memcpy(ocelot_opt_bind_as_utf8, ocelot_opt_bind.toUtf8().constData(), tmp_opt_bind_len + 1);

  int tmp_opt_connect_attr_delete_len= ocelot_opt_connect_attr_delete.toUtf8().size();
  ocelot_opt_connect_attr_delete_as_utf8= new char[tmp_opt_connect_attr_delete_len + 1];
  memcpy(ocelot_opt_connect_attr_delete_as_utf8, ocelot_opt_connect_attr_delete.toUtf8().constData(), tmp_opt_connect_attr_delete_len + 1);

  int tmp_opt_ssl_len= ocelot_opt_ssl.toUtf8().size();
  ocelot_opt_ssl_as_utf8= new char[tmp_opt_ssl_len + 1];
  memcpy(ocelot_opt_ssl_as_utf8, ocelot_opt_ssl.toUtf8().constData(), tmp_opt_ssl_len + 1);

  int tmp_opt_ssl_ca_len= ocelot_opt_ssl_ca.toUtf8().size();
  ocelot_opt_ssl_ca_as_utf8= new char[tmp_opt_ssl_ca_len + 1];
  memcpy(ocelot_opt_ssl_ca_as_utf8, ocelot_opt_ssl_ca.toUtf8().constData(), tmp_opt_ssl_ca_len + 1);

  int tmp_opt_ssl_capath_len= ocelot_opt_ssl_capath.toUtf8().size();
  ocelot_opt_ssl_capath_as_utf8= new char[tmp_opt_ssl_capath_len + 1];
  memcpy(ocelot_opt_ssl_capath_as_utf8, ocelot_opt_ssl_capath.toUtf8().constData(), tmp_opt_ssl_capath_len + 1);

  int tmp_opt_ssl_cert_len= ocelot_opt_ssl_cert.toUtf8().size();
  ocelot_opt_ssl_cert_as_utf8= new char[tmp_opt_ssl_cert_len + 1];
  memcpy(ocelot_opt_ssl_cert_as_utf8, ocelot_opt_ssl_cert.toUtf8().constData(), tmp_opt_ssl_cert_len + 1);

  int tmp_opt_ssl_cipher_len= ocelot_opt_ssl_cipher.toUtf8().size();
  ocelot_opt_ssl_cipher_as_utf8= new char[tmp_opt_ssl_cipher_len + 1];
  memcpy(ocelot_opt_ssl_cipher_as_utf8, ocelot_opt_ssl_cipher.toUtf8().constData(), tmp_opt_ssl_cipher_len + 1);

  int tmp_opt_ssl_crl_len= ocelot_opt_ssl_crl.toUtf8().size();
  ocelot_opt_ssl_crl_as_utf8= new char[tmp_opt_ssl_crl_len + 1];
  memcpy(ocelot_opt_ssl_crl_as_utf8, ocelot_opt_ssl_crl.toUtf8().constData(), tmp_opt_ssl_crl_len + 1);

  int tmp_opt_ssl_crlpath_len= ocelot_opt_ssl_crlpath.toUtf8().size();
  ocelot_opt_ssl_crlpath_as_utf8= new char[tmp_opt_ssl_crlpath_len + 1];
  memcpy(ocelot_opt_ssl_crlpath_as_utf8, ocelot_opt_ssl_crlpath.toUtf8().constData(), tmp_opt_ssl_crlpath_len + 1);

  int tmp_opt_ssl_key_len= ocelot_opt_ssl_key.toUtf8().size();
  ocelot_opt_ssl_key_as_utf8= new char[tmp_opt_ssl_key_len + 1];
  memcpy(ocelot_opt_ssl_key_as_utf8, ocelot_opt_ssl_key.toUtf8().constData(), tmp_opt_ssl_key_len + 1);

  int tmp_opt_ssl_mode_len= ocelot_opt_ssl_mode.toUtf8().size();
  ocelot_opt_ssl_mode_as_utf8= new char[tmp_opt_ssl_mode_len + 1];
  memcpy(ocelot_opt_ssl_mode_as_utf8, ocelot_opt_ssl_mode.toUtf8().constData(), tmp_opt_ssl_mode_len + 1);

  int tmp_plugin_dir_len= ocelot_plugin_dir.toUtf8().size();
  ocelot_plugin_dir_as_utf8= new char[tmp_plugin_dir_len + 1];
  memcpy(ocelot_plugin_dir_as_utf8, ocelot_plugin_dir.toUtf8().constData(), tmp_plugin_dir_len + 1);

  int tmp_read_default_file_len= ocelot_read_default_file.toUtf8().size();
  ocelot_read_default_file_as_utf8= new char[tmp_read_default_file_len + 1];
  memcpy(ocelot_read_default_file_as_utf8, ocelot_read_default_file.toUtf8().constData(), tmp_read_default_file_len + 1);

  int tmp_read_default_group_len= ocelot_read_default_group.toUtf8().size();
  ocelot_read_default_group_as_utf8= new char[tmp_read_default_group_len + 1];
  memcpy(ocelot_read_default_group_as_utf8, ocelot_read_default_group.toUtf8().constData(), tmp_read_default_group_len + 1);

  int tmp_server_public_key_len= ocelot_server_public_key.toUtf8().size();
  ocelot_server_public_key_as_utf8= new char[tmp_server_public_key_len + 1];
  memcpy(ocelot_server_public_key_as_utf8, ocelot_server_public_key.toUtf8().constData(), tmp_server_public_key_len + 1);

  int tmp_unix_socket_len= ocelot_unix_socket.toUtf8().size();
  ocelot_unix_socket_as_utf8= new char[tmp_unix_socket_len + 1];
  memcpy(ocelot_unix_socket_as_utf8, ocelot_unix_socket.toUtf8().constData(), tmp_unix_socket_len + 1);

  int tmp_set_charset_dir_len= ocelot_set_charset_dir.toUtf8().size();
  ocelot_set_charset_dir_as_utf8= new char[tmp_set_charset_dir_len + 1];
  memcpy(ocelot_set_charset_dir_as_utf8, ocelot_set_charset_dir.toUtf8().constData(), tmp_set_charset_dir_len + 1);

  int tmp_set_charset_name_len= ocelot_set_charset_name.toUtf8().size();
  ocelot_set_charset_name_as_utf8= new char[tmp_set_charset_name_len + 1];
  memcpy(ocelot_set_charset_name_as_utf8, ocelot_set_charset_name.toUtf8().constData(), tmp_set_charset_name_len + 1);

  int tmp_shared_memory_base_name_len= ocelot_shared_memory_base_name.toUtf8().size();
  ocelot_shared_memory_base_name_as_utf8= new char[tmp_shared_memory_base_name_len + 1];
  memcpy(ocelot_shared_memory_base_name_as_utf8, ocelot_shared_memory_base_name.toUtf8().constData(), tmp_shared_memory_base_name_len + 1);
}

#if (OCELOT_MYSQL_INCLUDE == 1)
int MainWindow::the_connect(unsigned int connection_number)
{
  int x;

  /* options_and_connect() cannot use QStrings because it is not in MainWindow */
  copy_connect_strings_to_utf8();
  x= options_and_connect(connection_number, ocelot_database_as_utf8);
  return x;
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

/*
  We should do this after any successful connection
  Todo: Check that we're not calling this twice. There are too many connect routines.
  Todo: I'm guessing that somewhere in the connection we specified a database option, or it isn't necessary.
        If I'm wrong then I guess rehash_scan() will fail which is no big deal.
  Todo: Everything that we enable when connection_number == 0 should be disabled when we disconnect.
*/
void MainWindow::connect_init(int connection_number)
{
  connections_is_connected[connection_number]= 1;
  if (connection_number == 0)
  {
    menu_file_export->setEnabled(true);
    if (ocelot_auto_rehash != 0)
    {
      char error_or_ok_message[ER_MAX_LENGTH];
      rehash_scan(error_or_ok_message, ""); /* Todo: should we display the error/ok message that rehash_scan() produces? */
    }
  }
}

/*
  For telling the user version info of ocelotgui itself,
  and of whatever it's connected to.
  Called by action_about(), print_version().
  qVersion() is Qt runtime, maybe != QT_VERSION_STR
  For action_about() we go further and try to say what we're connected
  to, but for --version, we aren't connecting so such info wouldn't be
  available.
*/
QString MainWindow::get_version()
{
  QString s;
  s = "\n\nocelotgui version ";
  s.append(ocelotgui_version);
#ifdef OCELOT_OS_LINUX
  s.append(", for Linux");
#endif
#ifdef OCELOT_OS_NONLINUX
#ifdef OCELOT_OS_FREEBSD
  s.append(", for FreeBSD");
#else
  s.append(", for Windows");
#endif
#endif
#if __x86_64__
  s.append(" (x86_64)");
#endif
  s.append(" using Qt version ");
  s.append(qVersion());
  s.append("\n");
  return s;
}

/* --version, or version in an option file, causes version display and exit */
void MainWindow::print_version()
{
  QString QStr= get_version();
  int tmp_len= QStr.toUtf8().size();
  char *tmp= new char[tmp_len + 1];
  memcpy(tmp, QStr.toUtf8().constData(), tmp_len + 1);
  printf("%s", tmp);
  delete []tmp;
  return;
}

/* --help, or help in an option file, causes help display and exit */
void MainWindow::print_help()
{
  char output_string[5120];

  print_version();
  printf("Copyright (c) 2022 by Peter Gulutzan and others\n");
  printf("\n");
  printf("Usage: ocelotgui [OPTIONS] [database]\n");
  printf("Options files that were actually read:\n");
  strcpy(output_string, options_files_read.toUtf8());
  printf("%s\n", output_string);
  {
    printf("Options files groups that ocelotgui looks for (changeable depending on user choices):");
    QStringList qs= my_cnf_groups_list();
    char tmp_group[256];
    for (int i= 0; i < qs.size(); ++i) {strcpy(tmp_group, qs.at(i).toUtf8()); printf(" %s", tmp_group); }
    printf("\n");
  }
  printf("Possible option values: same as possible option values for mysql client\n");
  printf("Option values after reading options files and command-line arguments:\n");
  printf("Option                            Value\n");
  printf("--------------------------------- ----------------------------------------\n");
  action_connect_once("Print");
}

#if (OCELOT_MYSQL_DEBUGGER == 1)

QStringList debug_routine_list_schemas;
QStringList debug_routine_list_names;
QStringList debug_routine_list_types;
QStringList debug_routine_list_sql_modes;
QStringList debug_routine_list_surrogates;
QStringList debug_routine_list_texts;
int debug_v_statement_number; /* the number for all routines */
QString debug_xxxmdbug_icc_core_surrogate_name;
#endif
QStringList c_variable_names;  /* (declared) in reverse order */
QStringList c_variable_tokens; /* (declared) in reverse order */
#if (OCELOT_MYSQL_DEBUGGER == 1)
QStringList debug_tmp_user_variables;
QString debug_v_g;
QString debug_xxxmdbug_debugger_name;
QString debug_xxxmdbug_debugger_version;
int debug_xxxmdbug_signal_errno;
QString debug_xxxmdbug_timestamp;
QString debug_xxxmdbug_setup_group_name;
#endif
int i_of_start_of_parameters, i_of_end_of_parameters;
#if (OCELOT_MYSQL_DEBUGGER == 1)
QStringList debug_label_list;
QString debug_xxxmdbug_default_schema;
int debug_track_statements;
int debug_track_user_variables;
int debug_track_declared_variables;
#endif
bool debug_ansi_quotes;
#if (OCELOT_MYSQL_DEBUGGER == 1)
QString debug_lf;
QString debug_plugins;
QString debug_session_sql_mode_original;
QString debug_session_sql_mode_after_last_change;
int debug_routine_list_size;
bool is_plsql;

/*
  When NEW_SETUP == 1, which is default since May 2018,
  we handle $setup from new code in ocelotgui.cpp due to the
  changes in MySQL 8.0. Except for debug_setup_go, all the new
  routines begin with "setup_".
  All setup_* functions, on error, should call debug_error() and return <> 0.
*/

#if (NEW_SETUP == 1)
/*
  We expect hparse to catch syntax errors so checks here are minimal.
*/
/* The 'track' switches exist so that one can reduce the amount of instrumenting,
   for space or speed reasons.
   @xxxmdbug_track_statements:            0=none, 1=base set, 2=+iterate/leave/set. default: 2.
   @xxxmdbug_track_user_variables:        0=none, 1=in same routine, 2=all (todo: allow 2). default=1.
   @xxxmdbug_track_declared_variables     0=none, 1=since last declare, 2=all. default: 2.
   Future switch: overwrite
   We are parsing these switches, but they are undocumented.
*/
/*
  Todo: New syntax: $SETUP ... [procedure|function|trigger|event] name.
                    and LIKE | = 'name'
  Todo: Are you sure $setup is starting at 0??
  Todo: Are you okay if there's a delimiter?
  Todo: I do case-insensitive comparisons. That's always okay for
        routine | declared variable | event, but not if
        @@lower_case_table_names == 0 and database | trigger | table.
*/
/*
  Todo: get_lock('xxxmdbug_lock') -- but in the past this has failed.
        Anyway conflict is unlikely unless two users get the same
        group name.
  Todo: I don't think locking is necessary. But check at the end, or
        even at $debug time, whether all routines are current.
        That is: did anyone change or drop a routine that's in the log?
                 or change our access rights to the surrogate routines?
        If so, $setup is probably invalid, return "failed".
  Todo: debug_privilege_check() should include whether we can read the
        information_schema.routines table for MySQL 8.0, but if we can't
        then that will be clear because setting up routine lists fails.
*/
void MainWindow::debug_setup_go(QString text)
{
  if (ocelot_statement_syntax_checker.toInt() < 1)
  {
    debug_error((char*)"Before running $setup you must say 'set ocelot_statement_syntax_checker=1;' or 'set ocelot_statement_syntax_checker=3;'");
    return;
  }
  if (hparse_errno != 0)
  {
    char copy_of_hparse_errmsg[1024];
    strcpy(copy_of_hparse_errmsg, "$setup cannot proceed due to syntax error: ");
    strcat(copy_of_hparse_errmsg, hparse_errmsg);
    debug_error((char*)copy_of_hparse_errmsg);
    return;
  }
  if (setup_initialize_variables()) return;
  /* parse the switches */
  debug_track_statements= 2;                        /* default */
  debug_track_user_variables= 1;                    /* default */
  debug_track_declared_variables= 2;                /* default */
  QString switch_name= "";
  bool is_switch= false;

  int last_token= main_token_number + main_token_count_in_statement;
  for (int i= main_token_number;
       ((main_token_lengths[i] != 0) && (i < last_token));
       ++i)
  {
    QString s= text.mid(main_token_offsets[i], main_token_lengths[i]);
    if (s == "-")
    {
      is_switch= true;
      continue;
    }
    if ((main_token_types[i] == TOKEN_TYPE_IDENTIFIER) && (is_switch))
    {
      switch_name= s;
      continue;
    }
    if (is_switch)
    {
      if ((main_token_types[i] == TOKEN_TYPE_LITERAL_WITH_DIGIT)
       || (main_token_types[i] == TOKEN_TYPE_LITERAL))
      {
        QString p= switch_name.toUpper();
        int j= s.toInt();
        if (p == "TRACK_STATEMENTS") debug_track_statements= j;
        else if (p == "TRACK_USER_VARIABLES") debug_track_user_variables= j;
        else if (p == "TRACK_DECLARED_VARIABLES") debug_track_declared_variables= j;
        is_switch= false;
      }
    }
  }

  QString qstring_error_message;
  //QString command_string;
  /* Todo: use debug_error instead, provided debug_error gets rid of any problematic ''s */
  qstring_error_message= debug_privilege_check(TOKEN_KEYWORD_DEBUG_SETUP);
  if (qstring_error_message != "")
  {
    char command_string[512];
    strcpy(command_string, qstring_error_message.toUtf8());
    if (debug_error(command_string) != 0) return; /* setup wouldn't be able to operate so fail */
  }
  int r= setup_internal(text);
  if (r == 1)
  {
    setup_cleanup();
    /* I assume debug_error() has set up a good error message. */
    return;
  }
  /* Todo: Return how many routines you found. */

  /* Repetition of some code in put_diagnostics_in_result */
  char elapsed_time_string[50];
  {
    qint64 statement_end_time= QDateTime::currentMSecsSinceEpoch();
    qint64 elapsed_time= statement_end_time - statement_edit_widget->start_time;
    long int elapsed_time_as_long_int= (long int) elapsed_time;
    float elapsed_time_as_float= (float) elapsed_time_as_long_int / 1000;
    sprintf(elapsed_time_string, " (%.1f seconds)", elapsed_time_as_float);
  }
  QString s1= QString("OK ");
  s1.append(QString::number(debug_routine_list_size));
  s1.append(" surrogate routines. ");
  s1.append(elapsed_time_string);
  statement_edit_widget->result= s1;
  setup_cleanup();
  return;
}
#endif // if (NEW_SETUP == 1)


/*
  $setup should call this wrapper when it needs mysql_real_query(),
  so that if there is a failure it can find it, prefix it with the
  error_prefix string, put it in the result, and erturn 1.
  We also put it in the log what the query was, with a low number.
  Todo: Error strings should be in ostrings.h.
*/
int MainWindow::setup_mysql_real_query(char *statement,
                                             char *error_prefix)
{
  int statement_len= strlen(statement);
  if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], statement, statement_len))
  {
    QString e= error_prefix;
    char debuggee_state_error[STRING_LENGTH_512];
    strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_MAIN_CONNECTION]), STRING_LENGTH_512 - 1);
    e= e + debuggee_state_error;
    put_message_in_result(e);
    log(error_prefix, 60);
    log(statement, 60);
    return 1;
  }
  return 0;
}

/*
  Make the routine_list_* QStringlists from the $SETUP arguments.
  Todo: This won't work for names that contain 's.
  Exclude if:
  * Language <> 'SQL'
    That's mysql.proc.language, an approximation is external_language.
    This might be important if external languages become okay.
    But it won't help with MariaDB, PL/SQL doesn't seem to be flagged.
    In MySQL expect 'SQL', in MariaDB expect NULL.
  * % wildcard for schema, and system database
    That is, mysql, information_schema, performance_schema, xxxmdbug.
  * % wildcard for name, and name like 'xxxmdbug___%'
    Quis custodiet ipsos debuggeros?
*/
/*
  We use COLLATE utf8_general_ci clauses in some comparisons, to avoid
  incompatible-mix-of-collations errors due to a MySQL 8.0 change.
  In MySQL 8.0: routine_catalog and routine_schema are utf8_tolower_ci,
  routine_name is utf8_general_ci. In earlier versions and in
  MariaDB 10.3: they are all utf8_general_ci.
*/
/* Todo:
   Ignore routines whose surrogate names would be too long.
   Todo: put a notice in setup_log.
   IF LENGTH(mysql_proc_name)+LENGTH('xxxmdbugxxxP')>64 THEN ITERATE x1; END IF;
*/
/*
  Todo: DEBUG_TAB_WIDGET_MAX is a maximum caused by our desire not to
  have too many tabs when $debug happens. But you could try to fix that
  some other way, e.g. allow users to change the maximum, or dynamically
  shift tabs in and out from the front on a last-seen basis.
*/

int MainWindow::setup_routine_list(QString text)
{
  debug_routine_list_schemas.clear();
  debug_routine_list_names.clear();
  debug_routine_list_types.clear();
  debug_routine_list_sql_modes.clear();
  debug_routine_list_surrogates.clear();
  debug_routine_list_texts.clear();
  debug_tmp_user_variables.clear();
  debug_routine_list_size= 0;
  QString s;
  QString token;
  QString schema_name= debug_xxxmdbug_default_schema;
  QString routine_name= "";
  char select_statement[2048];
  int i;
  for (i= 0; main_token_lengths[i] != 0; ++i)
  {
    if (main_token_types[i] == TOKEN_TYPE_IDENTIFIER)
    {
      token= text.mid(main_token_offsets[i], main_token_lengths[i]);
      if (main_token_reftypes[i] == TOKEN_REFTYPE_DATABASE)
      {
        schema_name= token.replace("_", "\\_");
      }
      else if (main_token_reftypes[i] == TOKEN_REFTYPE_SWITCH_NAME) {;}
      else
      {
        routine_name= token.replace("_", "\\_"); /* _ is a wildcard so escape it */
        s= "SELECT routine_schema,routine_name,routine_type,sql_mode " ;
        s= s + "FROM information_schema.routines WHERE ";
        s= s + "routine_schema COLLATE utf8_general_ci LIKE '" + connect_stripper(schema_name, false) + "' ";
        s= s + "AND routine_name LIKE '" + connect_stripper(routine_name, false) + "'";
        s= s + " AND (external_language IS NULL OR external_language='SQL')";
        if (schema_name.contains("%"))
        {
          s= s + " AND routine_schema COLLATE utf8_general_ci <> 'information_schema'"
               + " AND routine_schema COLLATE utf8_general_ci <> 'performance_schema'"
               + " AND routine_schema COLLATE utf8_general_ci <> 'mysql'"
               + " AND routine_schema COLLATE utf8_general_ci <> 'xxxmdbug'";
        }
        if (routine_name.contains("%"))
        {
          s= s + " AND routine_name NOT LIKE 'xxxmdbug___%'";
        }
        s= s + ";";
        strcpy(select_statement, s.toUtf8());
        MYSQL_RES *res= NULL;
        MYSQL_ROW row= NULL;
        if (setup_mysql_real_query(select_statement,
                                   (char*)"FAILED. Cannot make a list of routines. ") == 1)
          return 1;
        res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
        if (res == NULL)
        {
          debug_error((char*)"mysql_store_result -- FAILED. Cannot make a list of routines.");
          return 1;
        }
        int counter= 0;
        {
          for (;;)
          {
            row= lmysql->ldbms_mysql_fetch_row(res);
            if (row == NULL) break;
            /* TODO: connect_stripper()? */
            QString t_schema= QString::fromUtf8(row[0]);
            QString t_name= QString::fromUtf8(row[1]);
            QString t_type= QString::fromUtf8(row[2]);
            QString t_sql_mode= QString::fromUtf8(row[3]);
            int name_offset= setup_find(t_schema, t_name);
            if (name_offset >= 0)
            {
              if (debug_routine_list_types.at(name_offset) != t_type)
              {
                debug_error((char*)"Two routines have the same name but different types");
                if (res != NULL) lmysql->ldbms_mysql_free_result(res);
                return 1;
              }
              continue; /* ignore duplicates of the same type */
            }
            /* Todo: Check you don't make the name too long */
            debug_routine_list_schemas << t_schema;
            debug_routine_list_names << t_name;
            debug_routine_list_types << t_type;
            debug_routine_list_sql_modes << t_sql_mode;
            QString v_routine_identifier_of_surrogate;
            v_routine_identifier_of_surrogate= "xxxmdbug"
                    + debug_xxxmdbug_setup_group_name
                    + t_type.mid(0,1)
                    + connect_stripper(t_name, false);
            debug_routine_list_surrogates << v_routine_identifier_of_surrogate;
            ++counter;
          }
        }
        if (res != NULL) lmysql->ldbms_mysql_free_result(res);
        if (counter == 0)
        {
          char c_schema_name[256];
          strcpy(c_schema_name, schema_name.toUtf8());
          char c_routine_name[256];
          strcpy(c_routine_name, routine_name.toUtf8());
          char q[512];
          strcpy(q, "FAILED. Could not find routine ");
          strcat(q, c_schema_name);
          strcat(q, ".");
          strcat(q, c_routine_name);
          debug_error(q);
          return 1;
        }
        schema_name= debug_xxxmdbug_default_schema;
      }
    }
  }
  debug_routine_list_size= debug_routine_list_names.count();
  if (debug_routine_list_size > DEBUG_TAB_WIDGET_MAX)
  {
    char q[256];
    sprintf(q, "Error: Number of routines = %d. The maximum number of routines in a single $setup is %d", debug_routine_list_size, DEBUG_TAB_WIDGET_MAX);
    debug_error((char*)q);
    return 1;
  }
  return 0;
}

/*
  Pass: schema+name.
  Return: offset of schema+name (both must match) in QStringLists.
          or -1 if not found.
  This is an odd case where "return 1" does not mean "error".
  Todo: test with delimited names.
*/
int MainWindow::setup_find(QString t_schema, QString t_name)
{
  int i= 0;
  for (; i < debug_routine_list_schemas.count(); ++i)
  {
    if (QString::compare(debug_routine_list_names.at(i), t_name, Qt::CaseInsensitive) == 0)
    {
      if (QString::compare(debug_routine_list_schemas.at(i), t_schema, Qt::CaseInsensitive) == 0)
        return i;
    }
  }
  return -1;
}

/*
  Generate the surrogate for one routine, specified by routine_number.
  Todo: Make sure that any global checks/setups come before this.
*/
/*
   Todo: see if this is happening ...
   Reset tokens+variables+statements tables for each routine.
   One effect is that @user_variables are only tracked in routines where
   they are mentioned, and we might want to change that if a non-default
   setup switch value is used i.e. track_user_variables=2.
*/

int MainWindow::setup_generate(int routine_number)
{
  log("setup_generate", 15);
  debug_label_list.clear();
  if (debug_track_user_variables == 1) debug_tmp_user_variables.clear();
  QString s;
  bool pushed_sql_mode_ansi_quotes;
  bool pushed_hparse_sql_mode_ansi_quotes;
  QString routine_schema= debug_routine_list_schemas.at(routine_number);
  QString routine_name= debug_routine_list_names.at(routine_number);
  QString routine_type= debug_routine_list_types.at(routine_number);
  QString routine_sql_mode= debug_routine_list_sql_modes.at(routine_number);
  QString routine_surrogate= debug_routine_list_surrogates.at(routine_number);

  /* Todo: Put the names inside ``s. */
  /* Todo: check: what if there are nulls, will select_1_row() fail? */
  {
    char select_1_row_arg[1024];
    strcpy(select_1_row_arg, "SHOW CREATE ");
    strcat(select_1_row_arg, routine_type.toUtf8());
    strcat(select_1_row_arg, " `");
    strcat(select_1_row_arg, routine_schema.toUtf8());
    strcat(select_1_row_arg,"`.`");
    strcat(select_1_row_arg, routine_name.toUtf8());
    strcat(select_1_row_arg,"`;");
    s= select_1_row(select_1_row_arg);
    if (s != "")
    {
      strcat(select_1_row_arg, "-- FAILED so cannot generate surrogates");
      debug_error((char*)select_1_row_arg);
      return 1;
    }
  }
  /* Now select_1_row_result_3 has the procedure text. */
  /* Todo: this duplicates stuff in action_statement_edit_widget_text_changed */
  debug_v_g= "";
  QString text;
  int i;
  QString mysql_proc_db= routine_schema;
  QString p_routine_identifier= routine_name;
  bool is_schema_seen= false;

  /* NB: after this push do not "return 1" without popping */
  main_token_push();
  pushed_sql_mode_ansi_quotes= sql_mode_ansi_quotes;
  pushed_hparse_sql_mode_ansi_quotes= hparse_sql_mode_ansi_quotes;

  if (routine_sql_mode.contains("ANSI_QUOTES",Qt::CaseInsensitive))
  {
    debug_ansi_quotes= true;
  }
  else
  {
    debug_ansi_quotes= false;
  }
  hparse_sql_mode_ansi_quotes= debug_ansi_quotes;

  /* Todo: There's no need to copy, we could use select_1_row_result_3 */
  text= select_1_row_result_3;
  /* SHOW CREATE doesn't show ; but maybe I can't depend on that. */
  if (text.right(1) != ";") text= text + ";";

  main_token_new(text.size());
  tokenize(text.data(),
           text.size(),
           main_token_lengths, main_token_offsets, main_token_max_count,
           (QChar*)"33333", 1, ocelot_delimiter_str, 1);
  tokens_to_keywords(text, 0, sql_mode_ansi_quotes);

  if (routine_sql_mode.contains("ORACLE",Qt::CaseInsensitive)) is_plsql= true;
  else is_plsql= false;

  /*
    Workaround for a bug in MariaDB 10.3 / PLSQL.
    If, before IS|AS|RETURN, you see (): remove () and try again.
  */
  if (is_plsql)
  {
    bool bug= false;
    int offset1;
    int offset2;
    int i;
    for (i= 0; main_token_lengths[i] != 0; ++i)
    {
      int token_type= main_token_types[i];
      if ((token_type == TOKEN_KEYWORD_IS)
       || (token_type == TOKEN_KEYWORD_AS)
       || (token_type == TOKEN_KEYWORD_BEGIN)
       || (token_type == TOKEN_KEYWORD_RETURN))
        break;
    }
    for (int j= 0; j < i; ++j)
    {
      offset1= main_token_offsets[j];
      offset2= main_token_offsets[j + 1];
      QString token1= text.mid(offset1, main_token_lengths[j]);
      QString token2= text.mid(offset2, main_token_lengths[j + 1]);
      if ((token1 == "(") && (token2 == ")")) bug= true;
    }
    if (bug)
    {
      QString text_before_parentheses= text.mid(0, offset1 - 1);
      QString text_after_parentheses= text.mid(offset2 - 1);
      text= text_before_parentheses + "  " + text_after_parentheses;
      tokenize(text.data(),
               text.size(),
               main_token_lengths, main_token_offsets, main_token_max_count,
               (QChar*)"33333", 1, ocelot_delimiter_str, 1);
      tokens_to_keywords(text, 0, sql_mode_ansi_quotes);
    }
  }

  hparse_f_multi_block(text); /* recognizer */
  /* Todo: We only check hparse_errno. hparse_errno_count maybe > 0. */
  if (hparse_errno != 0)
  {
    debug_error((char*)"ocelotgui failed to parse the routine body");
    goto pop_and_return_error;
  }
  /* Successful parse. Now we can start the fiddling. */
  i= 0;

  /* Copy CREATE DEFINER ... PROCEDURE|FUNCTION name, maybe add schema */
  for (; main_token_lengths[i] != 0; ++i)
  {
    QString d= text.mid(main_token_offsets[i], main_token_lengths[i]);
    if (main_token_reftypes[i] == TOKEN_REFTYPE_DATABASE) is_schema_seen= true;
    if ((main_token_reftypes[i] == TOKEN_REFTYPE_PROCEDURE)
     || (main_token_reftypes[i] == TOKEN_REFTYPE_FUNCTION))
    {
      if (is_schema_seen == false) debug_v_g= debug_v_g + routine_schema + ".";
      if (setup_append(routine_surrogate, text, i)) goto pop_and_return_error;
      break;
    }
    else if (setup_append(d, text, i)) goto pop_and_return_error;
  }
  ++i;
  /* Todo: error if main_token_lengths[i] == 0 */
  /* Todo: call find_start_of_body() to find where routine really starts? */
  /* TODO: Assumption is wrong,
     CREATE TRIGGER or CREATE EVENT do not have parameter lists. */
  /* Assume always there is (parameter list). Where does it end? */
  {
    int parentheses_count= 0;
    bool is_parenthesis_seen= false;
    QString token;
    int j;
    for (j= i; main_token_lengths[j] != 0; ++j)
    { 
      if (is_plsql)
      {
        if ((main_token_types[j] == TOKEN_KEYWORD_AS)
         || (main_token_types[j] == TOKEN_KEYWORD_IS))
          break;
      }
      if (main_token_types[j] == TOKEN_TYPE_OPERATOR)
      {
        token= text.mid(main_token_offsets[j], main_token_lengths[j]);
        if (token == "(")
        {
          if (is_parenthesis_seen == false) i_of_start_of_parameters= j + 1;
          ++parentheses_count;
          is_parenthesis_seen= true;
        }
        if (token == ")")
        {
          --parentheses_count;
          if (parentheses_count == 0) break;
        }
      }
    }
    i_of_end_of_parameters= j;
  }
  if (setup_insert_into_variables_user_variables(text, i_of_end_of_parameters) == 1) return 1;
  /* Skip past the parameter list. */
  /* In fact skip all the way till the first real statement appears. */
  {
    int i_of_statement;
    for (i_of_statement= i_of_end_of_parameters;
         (main_token_flags[i_of_statement] & TOKEN_FLAG_IS_START_STATEMENT) == 0;
         ++i_of_statement)
    {
      if (main_token_lengths[i_of_statement] == 0)
      {
        debug_error((char*)"found no statements"); /* pseudo-assertion */
        goto pop_and_return_error;
      }
    }

    int j= main_token_offsets[i];
    QString d= text.mid(j, main_token_offsets[i_of_statement] - j);
    if (setup_append(d, text, i)) goto pop_and_return_error;
    i= i_of_statement;
  }

  if (setup_generate_starter(mysql_proc_db,
                         p_routine_identifier,
                         routine_type,
                         text)) goto pop_and_return_error;
  if (setup_generate_statements(i,
                            text,
                            routine_number)) goto pop_and_return_error;
  setup_generate_ender();
  /* Now you have a new CREATE statement in debug_v_g for a surrogate. */
  debug_routine_list_texts << debug_v_g;
  main_token_pop();
  sql_mode_ansi_quotes= pushed_sql_mode_ansi_quotes;
  hparse_sql_mode_ansi_quotes= pushed_hparse_sql_mode_ansi_quotes;
  return 0;
pop_and_return_error:
  main_token_pop();
  sql_mode_ansi_quotes= pushed_sql_mode_ansi_quotes;
  hparse_sql_mode_ansi_quotes= pushed_hparse_sql_mode_ansi_quotes;
  return 1;
}

int MainWindow::setup_append(QString d, QString text, int i)
{
  debug_v_g.append(d);
  int j= main_token_offsets[i] + main_token_lengths[i];
  assert(main_token_offsets[i + 1] >= j);
  debug_v_g.append(text.mid(j, main_token_offsets[i + 1] - j));
  return 0;
}

/* called from generate_starter().
   Job: make a string from the variables table.
   For example: '2,a. int;13,b. int;'
   Todo: don't need to start at 0, could start after routine name.
   Todo: This should be useful when creating the variables table.
   Todo: Actually the variables table can include @variables!
         Data type will not be known.
   Todo: You have to get the WHOLE data type, but replace 's in ENUM
         or SET with ''s.
   Todo: No idea how to handle MariaDB 10's ROW TYPE OF.
*/
int MainWindow::setup_generate_routine_entry_parameter(QString text)
{
  int v_token_number_of_declare= 0;
  QString v_variable_identifier;
  QString v_data_type;
  int i;
  for (i= 0; main_token_lengths[i] != 0; ++i)
  {
    if (main_token_types[i] == TOKEN_KEYWORD_DECLARE)
    {
      v_token_number_of_declare= i - i_of_start_of_parameters;
    }
    if ((main_token_reftypes[i] == TOKEN_REFTYPE_VARIABLE_DEFINE)
     || (main_token_reftypes[i] == TOKEN_REFTYPE_PARAMETER_DEFINE))
    {
      if (setup_row_type(i) == TOKEN_KEYWORD_ROW) continue;
      v_variable_identifier= text.mid(main_token_offsets[i], main_token_lengths[i]);
      v_data_type= "";
      for (int j= i + 1; main_token_lengths[j] != 0; ++j)
      {
        /* Todo: Add error check: no data type, or unknown data type */
        if ((main_token_flags[j] & TOKEN_FLAG_IS_DATA_TYPE) != 0)
        {
          v_data_type= "";
          int parentheses_count= 0;
          for (int k= j; main_token_lengths[k] != 0; ++k)
          {
            QString s= text.mid(main_token_offsets[k], main_token_lengths[k]);
            if (s == "(") ++parentheses_count;
            if (s == ")")
            {
              --parentheses_count;
              if (parentheses_count < 0) break;
            }
            if (parentheses_count == 0)
            {
              if ((s == ";")
               || (s == ",")
               || (QString::compare(s, "DEFAULT", Qt::CaseInsensitive) == 0))
                break;
            }
            if (v_data_type != "") v_data_type= v_data_type + " ";
            if (s.mid(0,1) == "'") s= "'" + s + "'";
            v_data_type= v_data_type + s;
          }
          break;
        }
      }
      debug_v_g= debug_v_g
              + QString::number(v_token_number_of_declare)
              + "*"
              + setup_add_delimiters(v_variable_identifier)
              + "*"
              + v_data_type
              + ";";
    }
  }
  return 0;
}

int MainWindow::setup_generate_starter(QString mysql_proc_db,
                                        QString p_routine_identifier,
                                        QString mysql_proc_type,
                                        QString text)
{
  QString debug_v_generated_time= debug_xxxmdbug_timestamp;
  /* We will use the contents of xxxmdbug_comment to find surrogates, or to check version number. So do not change here! */
  if (is_plsql)
  {
    debug_v_g= debug_v_g + "xxxmdbug_5678 EXCEPTION;" + debug_lf;
  }
  else
  {
    debug_v_g= debug_v_g + debug_lf + "BEGIN ";
    debug_v_g= debug_v_g + debug_lf + "DECLARE ";
  }
  debug_v_g= debug_v_g + "xxxmdbug_comment VARCHAR(1000) DEFAULT";
  debug_v_g= debug_v_g + debug_lf + "'Surrogate routine for `" + mysql_proc_db + "`.`" + p_routine_identifier + "`";
  debug_v_g= debug_v_g + debug_lf + "Generated by " + debug_xxxmdbug_debugger_name + " Version " + debug_xxxmdbug_debugger_version;
  debug_v_g= debug_v_g + debug_lf + "Generated on " + debug_v_generated_time + "';";
  if (is_plsql)
  {
    debug_v_g= debug_v_g + debug_lf + "BEGIN " + debug_lf;
  }
  else
  /* Handling the signal number. If plsql this will be done at the end. */
  {
    debug_v_g= debug_v_g + debug_lf + "DECLARE EXIT HANDLER FOR " + QString::number(debug_xxxmdbug_signal_errno) + " BEGIN CALL xxxmdbug.routine_exit(); RESIGNAL; END;";
    debug_v_g= debug_v_g + debug_lf + "DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN CALL xxxmdbug.routine_exit(); RESIGNAL; END;";
  }
  /* "call routine_entry(variable-list,command-list)". includes "Insert Into Call stack". */
  debug_v_g= debug_v_g + debug_lf + "CALL xxxmdbug.routine_entry("
                  + "'`" + mysql_proc_db + "`',"
                  + "'`" + p_routine_identifier + "`',"
                  + "'" + mysql_proc_type + "',"
                  + "'" + debug_xxxmdbug_debugger_version + "',"
                  + "'" + debug_v_generated_time + "','";
  if (setup_generate_routine_entry_parameter(text)) return 1;
  debug_v_g= debug_v_g + "');" + debug_lf;
  /* TODO: routine_entry() should have another parameter for pre-set commands. */

  /* A breakpoint on line 0 is possible. There are no settable variables,
     but the user can see what the routine is, and can set breakpoints."
     breakpoint_check() always stops for line 0 right after 'debug' command. */
  debug_v_g= debug_v_g + debug_lf + "IF xxxmdbug.is_debuggee_and_is_attached()=1 THEN CALL xxxmdbug."
                  + debug_xxxmdbug_icc_core_surrogate_name
                  + "(0);"
                  + "END IF;" + debug_lf;
  return 0;
}

/*
   "Generate: ender": Called from generate(). Was: generate_ender().
   We call this for the last line of a routine.
   We also change call stack (without calling this) for special handling of RETURN.
   routine_exit() should cause "Delete From Call Stack" */
/* in plsql LEAVE x won't work if x is a label before a BEGIN,
   so we put a label at the end for which we can say GOTO */
void MainWindow::setup_generate_ender()
{
  if (is_plsql)
    debug_v_g= debug_v_g + "<<xxxmdbug_routine_exit>>";
  debug_v_g= debug_v_g
           + "\nCALL xxxmdbug.routine_exit();" + debug_lf;
  /* Handling the signal number. If sql/psm this was done at the start. */
  /* Todo: Don't generate "EXCEPTION " if EXCEPTION statement exists. */
  if (is_plsql)
  {
    debug_v_g= debug_v_g
           + "EXCEPTION "
           + "WHEN xxxmdbug_5678 THEN BEGIN RAISE xxxmdbug_5678; END;"
           + debug_lf;
  }
  debug_v_g= debug_v_g
          + "END;" + debug_lf;
}

/*
  Find statements and generate for them.
  Beware, sometimes flow-control statements start with labels.
  Actually I think start_statement flag is on if it's label_define.
  If i_end_of_parameters is at ")" then it won't be shown, but if it
  is at "AS" (as happens with plsql) then it will be shown so ++count.
  Todo: some of the parameters can be calculated from routine_number.
*/
int MainWindow::setup_generate_statements(int i,
                                           QString text,
                                           int routine_number)
{
  int v_statement_number_within_routine= 0;
  int v_line_number_of_start_of_first_token;
  int v_token_number_of_last_token;
  for (; main_token_lengths[i] != 0; ++i)
  {
    QString d= text.mid(main_token_offsets[i], main_token_lengths[i]);
    if ((main_token_flags[i] & TOKEN_FLAG_IS_START_STATEMENT)
     || (main_token_reftypes[i] == TOKEN_REFTYPE_LABEL_DEFINE))
    {
      ++debug_v_statement_number;
      ++v_statement_number_within_routine;
      if (main_token_reftypes[i] == TOKEN_REFTYPE_LABEL_DEFINE)
      {
        int j= main_token_offsets[i];
        ++i;
        for (; ; ++i)
        {
          if (main_token_flags[i] & TOKEN_FLAG_IS_START_STATEMENT) break;
        }
        QString s= text.mid(j, main_token_offsets[i] - j);
        debug_v_g.append(s);
      }
      {
        int j= main_token_offsets[i_of_end_of_parameters];
        int k= main_token_offsets[i];
        QString s= QString::number(i) + "*" + text.mid(j, k - j);
        v_line_number_of_start_of_first_token= s.count(debug_lf);
        int t= main_token_types[i_of_end_of_parameters];
        if ((t == TOKEN_KEYWORD_AS) || (t == TOKEN_KEYWORD_IS))
          ++v_line_number_of_start_of_first_token;
      }
      //v_character_number_of_start_of_first_token= main_token_offsets[i];
      for (int j= i + 1; ; ++j)
      {
        if ((main_token_flags[j] & TOKEN_FLAG_IS_START_STATEMENT)
         || (main_token_reftypes[i] == TOKEN_REFTYPE_LABEL_DEFINE)
         || (main_token_lengths[j] == 0))
        {
          v_token_number_of_last_token= j - 1;
          break;
        }
      }
      if (setup_generate_label(i, text, v_statement_number_within_routine)) return 1;

      if (main_token_flags[i] & TOKEN_FLAG_IS_DEBUGGABLE)
      {
        /* Todo: generate per-statement stuff, this is executable */
        /* We'll set is_leave_possible later. */
        if (setup_generate_statements_debuggable(i,
                                             v_line_number_of_start_of_first_token,
                                             v_statement_number_within_routine,
                                             text,
                                             v_token_number_of_last_token,
                                             routine_number)) return 1;
      }
      else
      {
        if (setup_generate_statement_text(i,
                                      text,
                                      v_token_number_of_last_token,
                                      routine_number)) return 1;
      }
      i= v_token_number_of_last_token;
    }
  }
  return 0;
}

/*
   Initialize some variables. Called from setup(), command(), and become_debuggee_connection().
   Start with some error checks.
   Any names that start with @xxxmdbug are reserved.
   Some of the variables set in this procedure are "constants".
   In debug_parse_statement() there is also some initialization,
   but $setup no longer calls that.
*/
/* For debugger purposes, the pipe prefix forms are:
   'xxxmdbug_' + @xxxmdbug_prefix_endxxx e.g. 'B '
   The 'R ' messages are status sendings which the debugger may or may not choose to receive (the debuggee may overwrite them).
   The @xxxmdbug_prefix_end_for_rxxx messages are responses to specific questions which the debugger is expecting.
*/
/* Todo: why not find out current sql_mode too? */
int MainWindow::setup_initialize_variables()
{
  debug_lf = "\n"; /* constant: Line Feed. add carriage return if desired */
  debug_xxxmdbug_debugger_name= "OCELOTGUI";
  debug_xxxmdbug_debugger_version= ocelotgui_version;
  debug_xxxmdbug_signal_errno= 5678;

  /* Todo: make this call along with other things you need server for. */
  /* Todo: watch out re group_concat_max_len */
  char query[]="SELECT current_timestamp(),database(),group_concat(plugin_name ORDER BY plugin_name), @@session.sql_mode FROM information_schema.plugins;";
  QString s= select_1_row(query);
  if (s != "")
  {
    char error_message[1024];
    strcpy(error_message, "Failed to execute: ");
    strcat(error_message, query);
    debug_error(error_message);
    return 1;
  }

  debug_xxxmdbug_timestamp= select_1_row_result_1;
  debug_xxxmdbug_default_schema= select_1_row_result_2;
  debug_plugins= select_1_row_result_3;
  debug_session_sql_mode_original= select_1_row_result_4;
  debug_session_sql_mode_after_last_change= debug_session_sql_mode_original;
  return 0;
}

/*
   routine_identifier_of_surrogate = xxxmdbug xxx type routine_identifier
   where xxx = set name = a 3-character value with character set { 0-9 A-Z },
   up to 36 * 36 * 36 = 46656 possibilities, and it goes up every time we call setup().
   where type = first letter of mysql.proc.type so 'P' for procedure and 'F' for function.
   This format is expected by debuggee_wait_loop().
   In get_set_setup_group_name() all we do is get the 3-character string, @xxxmdbug_setup_group_name
   Todo: explain what to do if set name reaches 'ZZZ'.
   Todo: Get group name again when you're ready to write.
         If it's not the same, debug_error("Concurrency error").
*/
int MainWindow::setup_get_setup_group_name()
{
  int vxxx_as_number;
  int v_digit1,v_digit2,v_digit3;
  QString v_max_name= "";
  QString v_max_name_in_setup_log= "";
  QString s;
  s= select_1_row("SELECT MAX(routine_name) FROM information_schema.routines WHERE routine_name LIKE 'xxxmdbug____%';");
  if (s != "")
  {
    debug_error((char*)"Failed to read information_schema.routines");
    return 1;
  }
  v_max_name= select_1_row_result_1.toUpper();
  s= select_1_row("SELECT MAX(surrogate_routine_identifier) FROM xxxmdbug.setup_log WHERE surrogate_routine_identifier LIKE 'xxxmdbug____%';");
  if (s != "")
  {
    debug_error((char*)"Failed to read xxxmdbug.setup_log");
    return 1;
  }
  v_max_name_in_setup_log= select_1_row_result_1.toUpper();
  if ((v_max_name_in_setup_log > v_max_name)
   || (v_max_name == ""))
    v_max_name= v_max_name_in_setup_log;
  if (v_max_name == "") debug_xxxmdbug_setup_group_name= "000";
  else
  {
    debug_xxxmdbug_setup_group_name= v_max_name.mid(strlen("xxxmdbug"), 3);
    if (debug_xxxmdbug_setup_group_name == "ZZZ")
    {
      debug_error((char*)"Too many sets of surrogates, cleanup necessary");
      return 1;
    }
    char digits[4];
    strcpy(digits, debug_xxxmdbug_setup_group_name.mid(0, 1).toUtf8());
    v_digit1= (int)digits[0];
    if (v_digit1 <= 57) v_digit1-= 48; else v_digit1 -= (65 - 10);
    strcpy(digits, debug_xxxmdbug_setup_group_name.mid(1, 1).toUtf8());
    v_digit2= (int)digits[0];
    if (v_digit2 <= 57) v_digit2-= 48; else v_digit2 -= (65 - 10);
    strcpy(digits, debug_xxxmdbug_setup_group_name.mid(2, 1).toUtf8());
    v_digit3= (int)digits[0];
    if (v_digit3 <= 57) v_digit3-= 48; else v_digit3 -= (65 - 10);
    vxxx_as_number= ((v_digit1 * 36 * 36) + (v_digit2 * 36) + v_digit3) + 1;
    v_digit3= vxxx_as_number % 36;
    v_digit2= ((vxxx_as_number - v_digit3)/36) %36;
    v_digit1= ((vxxx_as_number-(v_digit3+v_digit2*36))/(36*36)) %36;
    if (v_digit1 <= 9) v_digit1= v_digit1 + 48; else v_digit1= v_digit1 + (65-10);
    if (v_digit2 <= 9) v_digit2= v_digit2 + 48; else v_digit2= v_digit2 + (65-10);
    if (v_digit3 <= 9) v_digit3= v_digit3 + 48; else v_digit3= v_digit3 + (65-10);
    digits[0]= v_digit1;
    digits[1]= v_digit2;
    digits[2]= v_digit3;
    digits[3]= '\0';
    debug_xxxmdbug_setup_group_name= digits;
  }
  return 0;
}
#endif

/*
  Identifiers in routines might be "delimited" or `delimited` or bare.
  We usually want `delimited` for consistent comparisons.
  Todo: Convert to upper because, even if variable-name is delimited,
        it is not case sensitive? Well, let's cancel that for a while.
        If we don't send it as lower case, IT DOESN'T WORK.
  Todo: This doesn't handle names that have ` or " inside them.
  Todo: Test with @`var` etc.
*/
QString MainWindow::setup_add_delimiters(QString name)
{
  QString n= name;
  if (n.mid(0,1) == "@") return n;
  if ((debug_ansi_quotes) && (n.mid(0,1) == "\""))
  {
    n= connect_stripper(n, true);
    return "`" + n + "`";
  }
  if (n.mid(0,1) != "`")
  {
    n= "`" + n + "`";
  }
  return n;
}

#if (OCELOT_MYSQL_DEBUGGER == 1)
/* We finished with declared variables.
   Now user variables, that is, any token that starts with '@'.
   Here we dump names that start with '@' into a variables list.
   Later we select from the list and use the result as input for
   generate_icc_core().
   In the end the user sees these variables with command 'refresh user_variables'.
   If the user said call setup('-track_user_variables=0 ...') then we do nothing.
   todo: this is not handling already-delimited user variables correctly.
   todo: check: do we need to check for TOKEN_REFTYPE_COLUMN_OR_USER_VARIABLE?
   todo: I would much prefer to look for TOKEN_REFTYPE_USER_VARIABLE, but
         for some reason hparse isn't generating it. Have a look there.
   todo: BUG: (probably): setup_add_delimiters depends on debug_ansi_quotes which maybe we didn't set
*/
int MainWindow::setup_insert_into_variables_user_variables(QString text, int i_of_end_of_parameters)
{
  if (debug_track_user_variables > 0)
  {
    for (int i= i_of_end_of_parameters; main_token_lengths[i] != 0; ++i)
    {
      if (main_token_types[i] == TOKEN_TYPE_IDENTIFIER_WITH_AT)
      {
        QString v_value= text.mid(main_token_offsets[i], main_token_lengths[i]);
        if ((v_value.mid(0,1) == "@") && (v_value.mid(1,1) != "@"))
        {
          v_value= setup_add_delimiters(v_value);
          /* don't insert duplicates. */
          if (debug_tmp_user_variables.contains(v_value)) continue;
          debug_tmp_user_variables << v_value;
        }
      }
    }
  }
  debug_tmp_user_variables.sort(); /* I'm not sure this is necessary */
  return 0;
}


int MainWindow::setup_create_setup_log_table()
{
  char statement[]=
  "CREATE TABLE IF NOT EXISTS xxxmdbug.setup_log (\
   group_name VARCHAR(3) CHARACTER SET utf8,\
   user VARCHAR(80) CHARACTER SET utf8,\
   version_number_of_debugger CHAR(5) CHARACTER SET utf8,\
   timestamp_when_setup_procedure_was_run DATETIME,\
   arguments_passed_to_setup VARCHAR(8192) CHARACTER SET utf8,\
   routine_type VARCHAR(10) CHARACTER SET utf8, /* procedure|function. not event|trigger yet. */\
   schema_identifier VARCHAR(66) CHARACTER SET utf8,\
   original_routine_identifier VARCHAR(66) CHARACTER SET utf8,\
   surrogate_routine_identifier VARCHAR(66) CHARACTER SET utf8,\
   outcome VARCHAR(66) CHARACTER SET utf8, /* Made surrogate, Overwrote, or Failed */\
   invocations_of_routines_in_same_group INT,\
   invocations_of_routines_in_any_group INT,\
   comment_based_on_generate VARCHAR(66) CHARACTER SET utf8,\
   comment_based_on_readme VARCHAR(66) CHARACTER SET utf8) engine=myisam;\
  ";

  if (setup_mysql_real_query(statement,
                             (char*)"FAILED. Cannot create setup_log table.") == 1)
    return 1;
  return 0;
}

/* We need to use information_schema.routines and SHOW CREATE.
   todo: decide whether to use body or body_utf8 from mysql.proc.
         it's impossible in MySQL but still possible in MariaDB.
   todo: we could have an additional parameter for extra diagnostics from debug
   Todo: Although I don't trust get_lock any more, I suppose that we
         could lock an xxxmdbug table during this routine. */
int MainWindow::setup_internal(QString command_string)
{
  QString object_name_list= command_string;
  /* Make sure object_name_list is schema_identifier.routine_identifier
    or schema_identifier.% or %.%. Default is %.%.
    (Well, no it is not, the comments here are a bit obsolete.)
    TODO: re-examine whether default schema identifier should be current database or %.
    TODO: re-examine whether wildcarding should be (% and _) or with *."
    Output is a temporary list of schemas and objects. */
  {
    /* CALL xxxmdbug.privilege_checks(); */
    if (setup_create_setup_log_table() == 1) return 1;
    if (setup_get_setup_group_name()) return 1; /* returns @xxxmdbug_setup_group_name = 3-character string for new set name. */
    if (debug_track_user_variables > 0)
      debug_xxxmdbug_icc_core_surrogate_name=
          "xxxmdbug"
          + debug_xxxmdbug_setup_group_name
          + "P"
          + "icc_core";
    else
      debug_xxxmdbug_icc_core_surrogate_name= "icc_core";
  }

  if (setup_routine_list(command_string)) return 1;
  debug_v_statement_number= 0;
  for (int i= 0; i < debug_routine_list_names.count(); ++i)
  {
    if (setup_generate(i)) return 1;
    QString s_insert=
      QString("INSERT INTO xxxmdbug.setup_log VALUES (")
      +  "'" + debug_xxxmdbug_setup_group_name + "'," /* group_name */
      +  "'" + ocelot_user + "'," /* user. ?? maybe statement_edit_widget->dbms_current_user is better? */
      +  "'" + debug_xxxmdbug_debugger_version + "'," /* version_number_of_debugger */
      +  "'" + debug_xxxmdbug_timestamp + "'," /* timestamp_when_setup_procedure_was_run */
      +  "'" + object_name_list + "'," /* arguments_passed_to_setup */
      +  "'" + debug_routine_list_types.at(i) + "'," /* routine_type */
      +  "'" + debug_routine_list_schemas.at(i) + "'," /* schema_identifier */
      +  "'" + debug_routine_list_names.at(i) + "'," /* original_routine_identifier */
      +  "'" + debug_routine_list_surrogates.at(i) + "'," /* surrogate_routine_identifier */
      +  "'done'," /* outcome */ /* todo: something informative, eh? */
      +  "0," /* @xxxmdbug_invocations_of_routines_in_same_group,"*/ /* invocations_of_routines_in_same_group */
      +  "0," /* @xxxmdbug_invocations_of_routines_in_any_group,"*/ /* invocations_of_routines_in_any_group */
      + "NULL," /* comment_based_on_generate */
      + "'thanks. copyright. gpl');"; /* comment_based_on_readme */
    char s_utf8[2048]; /* Todo: this should be dynamically allocated */
    strcpy(s_utf8, s_insert.toUtf8());
    if (setup_mysql_real_query(s_utf8,
                               (char*)"FAILED. Cannot insert into xxxmdbug.setup_log. ") == 1)
      return 1;
  }

  if (debug_track_user_variables > 0)
  {
    if (setup_generate_icc_core() == 1) return 1;
  }

  if (setup_generate_icc_process_user_command_r_server_variables() == 1) return 1;

  /* This is blank: CALL xxxmdbug.view_and_trigger_and_event_check(); */
  /* This is blank: CALL xxxmdbug.checks_and_warnings(mysql_proc_db); */

  /*
    Now routine_lists_* has a bunch of CREATE PROCEDURE|FUNCTION,
    ready to be executed.
    TODO: If there were no @variables you can change calls to the
          generated icc_core back to the regular icc_core, it's a
          simple search-and-replace now.
  */

  if (setup_drop_routines() == 1) return 1;
  /* Create all the routines that are to be created. */
  /* If one of the creates fails, undo all previous creates. */
  /* Todo: change sql_mode before you call. Definer too? */
  for (int i= 0; i < debug_routine_list_surrogates.count(); ++i)
  {
    QString s;
    s= debug_routine_list_texts.at(i);
    {
      setup_set_session_sql_mode(debug_routine_list_sql_modes.at(i));
      int query_len= s.toUtf8().size();                  /* See comment "UTF8 Conversion" */
      char *query= new char[query_len + 1];
      memcpy(query, s.toUtf8().constData(), query_len + 1);
      if (setup_mysql_real_query(query,
                                 (char*)"FAILED. Cannot create a routine. ") == 1)
      {
        setup_drop_routines();
        delete []query;
        return 1;
      }
      delete []query;
    }
  }
  return 0;
}

/*
  Drop all routines in debug_routine_list_surrogates.
  We call this before we try to create those routines.
  Or we call this if any create fails.
  Todo: Think: why return if drop fails, instead of going to next?
*/
int MainWindow::setup_drop_routines()
{
  for (int i= 0; i < debug_routine_list_surrogates.count(); ++i)
  {
    QString s;
    s= "DROP "
            + debug_routine_list_types.at(i)
            + " IF EXISTS "
            + debug_routine_list_schemas.at(i)
            + "."
            + debug_routine_list_surrogates.at(i)
            + ";" + debug_lf;
    {
      int query_len= s.toUtf8().size();                  /* See comment "UTF8 Conversion" */
      char *query= new char[query_len + 1];
      memcpy(query, s.toUtf8().constData(), query_len + 1);

      if (setup_mysql_real_query(query,
                                 (char*)"FAILED. Cannot drop.") == 1)
      {
        delete []query;
        return 1;
      }
    }
  }
  return 0;
}

/*
  At the end of the $setup process, whether or not it succeeded:
  Possibly temporary tables were created, now drop them (no, gone now).
  Possibly some QStringLists were filled, now clear them.
  This is not a complete list, just the most likely to be big.
  Do not call before setup_initialize() where got debug_session_sql_mode.
*/
void MainWindow::setup_cleanup()
{
  debug_routine_list_schemas.clear();
  debug_routine_list_names.clear();
  debug_routine_list_types.clear();
  debug_routine_list_sql_modes.clear();
  debug_routine_list_surrogates.clear();
  debug_routine_list_texts.clear();
  debug_tmp_user_variables.clear();
  setup_set_session_sql_mode(debug_session_sql_mode_original);
}

/*
  Called from setup_internal() when we're about to create a routine.
  Called from setup_cleanup() when we want to restore the original.
  We execute SET SESSION_SQL_MODE=... so that, if sql_mode when the
  original routine was created is different from sql_mode now, we
  won't get in trouble because ""s were used for names, or due to
  pipes_as_concat, or in future something to do with sql_mode='oracle'.
  Actually we've probably changed ""s to ``s but that's not enough.
  Todo: Not much we can do about failure. But return an error if fail.
*/
int MainWindow::setup_set_session_sql_mode(QString s)
{
  if (s != debug_session_sql_mode_after_last_change)
  {
    char query[1024];
    strcpy(query, "SET SESSION SQL_MODE='");
    strcat(query, s.toUtf8());
    strcat(query, "';");
    if (setup_mysql_real_query(query,
                               (char*)"FAILED. Cannot change sql_mode.") == 1)
      return 1;
    debug_session_sql_mode_after_last_change= s;
  }
  return 0;
}

/* This generates the debuggee procedure that will handle the 'refresh server_variables'
   command. It is better to generate rather than have a fixed set of
   statements, because the server variables depend on the version and
   on what engines or plugins are installed. An example first line:
   SET v_ret=CONCAT(v_ret,'"@@ARIA_BLOCK_SIZE",','"',@@ARIA_BLOCK_SIZE,'";');
   todo: watch for v_ret overflow
   Perhaps performance_schema.session_variables won't exist,
   so we don't abort on failure.
   Todo: Nowadays MariaDB information_schema.server_variables has
         data-type and read-only columns, so most of this effort is not
         necessary! But we still need it because MySQL won't have them:
         https://dev.mysql.com/doc/refman/8.0/en/performance-schema-system-variable-tables.html
*/
/* Code from setup_generate_icc_process_user_command_set_server_variables
   has been added, it will use QString v_g_2 instead of QString v_g.
   This generates the debuggee procedure that will handle the 'set @@server_variable=...'
   command. An example first line:
   IF @token_value_2 = '@@ARIA_BLOCK_SIZE' THEN SET @@ARIA_BLOCK_SIZE=@xxxmdbug_token_value_4a; END IF;
   Wrong type or wrong value will cause a severe error, we handle it, but the warning list is cleared.*/
int MainWindow::setup_generate_icc_process_user_command_r_server_variables()
{
  QString mysql_proc_name;
  QString mysql_proc_db;
  QString mysql_proc_type;
  QString v_variable_name;
  QString v_g, v_g_2;
  QStringList c_variable_names; /* not the global with the same name */
  QStringList c_variable_types;
  {
    /* Skip if we did it before and server version + plugins unchanged */
    /* (Maybe 'settable' differs due to privileges, I don't care.) */
    QString s=
      QString("SELECT COUNT(*) ")
      + "FROM information_schema.routines "
      + "WHERE routine_name = 'icc_process_user_command_r_server_variables' "
      + "AND routine_schema COLLATE utf8_general_ci = 'xxxmdbug' "
      + "AND routine_definition LIKE '%" + statement_edit_widget->dbms_version + "%' "
      + "AND routine_definition LIKE '%" + debug_plugins + "%';";
    int query_len= s.toUtf8().size(); /* See comment "UTF8 Conversion" */
    char *query= new char[query_len + 1];
    memcpy(query, s.toUtf8().constData(), query_len + 1);
    QString s2= select_1_row(query);
    delete []query;
    if ((s2 == "") && (select_1_row_result_1.toInt() == 1)) return 0;
  }

  {
    /* Todo: Make sure big enough. Restore to original value. */
    int max_len= 100000;
    char query[256];
    sprintf(query, "SET SESSION GROUP_CONCAT_MAX_LEN=%d;", max_len);
    if (setup_mysql_real_query(query,
                               (char*)"FAILED. Cannot change group_concat_maxlen.") == 1)
      return 1;
  }
  c_variable_names.clear();
  c_variable_types.clear();
  {
    QString s;
    /* todo: maybe for MariaDB I should look first at information_schema */
    s= select_1_row("select group_concat('/*@@',variable_name) from performance_schema.session_variables;");
    if (s != "")
    {
      s= select_1_row("select group_concat('/*@@',variable_name) from information_schema.session_variables;");
      if (s != "")
      {
        debug_error((char*)"select from session_variables failed");
        return 1;
      }
    }
    int j, k;
    j= 0;
    for (int i= 0; ; ++i)
    {
      if (j == select_1_row_result_1.length()) break;
      k= select_1_row_result_1.indexOf("/*@@", j + 1);
      if (k == -1)
      {
        k= select_1_row_result_1.length();
        s= select_1_row_result_1.mid(j + 2, k - (j + 2));
      }
      else s= select_1_row_result_1.mid(j + 2, k - (j + 2 + 1));
      c_variable_names << s;
      j= k;
    }
  }

  if (c_variable_names.count()== 0) /* pseudo-assertion */
  {
    debug_error((char*)"c_variable_names.count() == 0");
    return 1;
  }
  c_variable_names.sort();

  /* Determine the types. Since we're calling from C, we
     have a way that doesn't involve trips to xxxmdbug.uvar.
     More exact too, but we throw away the exactness. */
  {
    MYSQL_RES *res= NULL;
    QString s= "SELECT ";
    for (int i= 0; i < c_variable_names.count(); ++i)
    {
      if (i != 0) s= s + QString(",");
      s= s + c_variable_names.at(i);
    }
    s= s + QString(";");
    int query_len= s.toUtf8().size(); /* See comment "UTF8 Conversion" */
    char *query= new char[query_len + 1];
    memcpy(query, s.toUtf8().constData(), query_len + 1);

    if (setup_mysql_real_query(query,
                               (char*)"FAILED. While selecting variable names.") == 1)
    {
      delete []query;
      return 1;
    }
    delete []query;
    res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
    if (res != NULL)
    {
      int num_fields= lmysql->ldbms_mysql_num_fields(res);
      assert(num_fields == c_variable_names.count());
      MYSQL_FIELD *fields;
      fields= lmysql->ldbms_mysql_fetch_fields(res);
      int t;
      QString v_data_type;
      for (int i= 0; i < num_fields; ++i)
      {
        t= fields[i].type;
        if ((t == OCELOT_DATA_TYPE_LONGLONG)
         || (t == MYSQL_TYPE_TINY)
         || (t == OCELOT_DATA_TYPE_SHORT)
         || (t == MYSQL_TYPE_LONG)
         || (t == OCELOT_DATA_TYPE_INT24))
         v_data_type= "BIGINT";
        else if ((t == MYSQL_TYPE_LONG_BLOB)
              || (t == MYSQL_TYPE_VAR_STRING)
              || (t == MYSQL_TYPE_TIMESTAMP)
              || (t == MYSQL_TYPE_SET)
              || (t == MYSQL_TYPE_ENUM)
              || (t == OCELOT_DATA_TYPE_STRING))
        {
          if (fields[i].charsetnr == 63) v_data_type= "LONGBLOB";
          else v_data_type= "LONGTEXT";
        }
        else if (t == OCELOT_DATA_TYPE_DECIMAL) v_data_type= "DECIMAL";
        else if ((t == MYSQL_TYPE_FLOAT)
              || (t == OCELOT_DATA_TYPE_DOUBLE))
                v_data_type= "DOUBLE";
        else v_data_type= "UNKNOWN";
        c_variable_types << v_data_type;
      }
    }
    if (res != NULL) lmysql->ldbms_mysql_free_result(res);
  }

  mysql_proc_name= "icc_process_user_command_r_user_variables"; /* todo: this is a lie. the original is for server_variables. */
  QString v_g_surrogate_routine_identifier= "icc_process_user_command_r_server_variables";
  QString v_g_2_surrogate_routine_identifier= "icc_process_user_command_set_server_variables";

  QString xxxmdbug_comment;
  {
    QString xxxmdbug_comment_string=
            debug_lf + "Routine for debugger tracking server variables"
            + debug_lf + "Generated by " + debug_xxxmdbug_debugger_name + " Version " + debug_xxxmdbug_debugger_version
            + debug_lf + "Generated on " + debug_xxxmdbug_timestamp
            + debug_lf + "Generated from " + statement_edit_widget->dbms_version
            + debug_lf + "Plugins: " + debug_plugins;
    xxxmdbug_comment=
          debug_lf
          + "DECLARE xxxmdbug_comment VARCHAR("
          + QString::number(xxxmdbug_comment_string.length() + 1)
          + ") DEFAULT '"
          + xxxmdbug_comment_string
          + "';" + debug_lf;
  }
  mysql_proc_db= "xxxmdbug";
  mysql_proc_type= "PROCEDURE";

  /* For ..._r_... Opening matches what is in generate(). */

  v_g = "CREATE "
          + mysql_proc_type
          + " "
          + mysql_proc_db
          + "."
          + v_g_surrogate_routine_identifier
          + "()" + debug_lf;
  //v_g_offset_of_begin= v_g.length() + debug_lf.length();
  v_g= v_g
          + "BEGIN"
          + xxxmdbug_comment
          + "DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';" + debug_lf
          /* todo: try TEXT */
          + "DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" + debug_lf;

  /* For ..._set_... Opening matches what is in generate(). */
  v_g_2= v_g_2
          + "CREATE "
          + mysql_proc_type
          + " "
          + mysql_proc_db
          + "."
          + v_g_2_surrogate_routine_identifier
          + "()" + debug_lf;
  //v_g_2_offset_of_begin= v_g_2.length() + debug_lf.length();
  v_g_2= v_g_2
        + "BEGIN"
        + xxxmdbug_comment
        + "DECLARE EXIT HANDLER FOR SQLEXCEPTION CALL xxxmdbug.icc_change_statement_status('Fail');" + debug_lf
        + "SET @xxxmdbug_tmp_for_set = 'Fail';" + debug_lf;

  for (int i= 0; i < c_variable_names.count(); ++i)
  {
    /* Test whether one can assign to the variable. If an exception happens,
       it is almost certainly because the variable is read-only.
       ERROR 1238 (HY000): Variable 'warning_count' is a read only variable.
       In that case 'refresh server_variables' will show that is_settable = 0.
       Do not check @@timestamp because SET TIMESTAMP freezes the clock.
       Todo: actually a new column 'read only' would be smarter, here and for parameters. */
    //QString xxxmdbug_test_setting;
    v_variable_name= c_variable_names.at(i);
    int v_is_settable= 1;
    if (v_variable_name  != "@@TIMESTAMP")
    {
      char xxxmdbug_test_setting[256];
      strcpy(xxxmdbug_test_setting, "SET ");
      strcat(xxxmdbug_test_setting, v_variable_name.toUtf8());
      strcat(xxxmdbug_test_setting, "=");
      strcat(xxxmdbug_test_setting, v_variable_name.toUtf8());
      strcat(xxxmdbug_test_setting, ";");
      /* Not a call to setup_mysql_query because failure is okay. */
      if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], xxxmdbug_test_setting, strlen(xxxmdbug_test_setting)))
      {
        v_is_settable= 0;
      }
    }

    v_g= v_g +
            + "SET v_ret=CONCAT(v_ret,'\""
            + v_variable_name
            + "\",','\"',HEX(IFNULL(LEFT("
            + v_variable_name
            + ",66),'NULL')),'\","
            + QString::number(v_is_settable)
            + ",\""
            + c_variable_types.at(i)
            + "\";');" + debug_lf;

    if (v_is_settable != 0)
    {
      v_g_2= v_g_2
             + "IF @xxxmdbug_token_value_2 = '"
             + v_variable_name
             + "' THEN SET "
             + v_variable_name
             + "= @xxxmdbug_token_value_4a; SET @xxxmdbug_tmp_for_set = 'OK'; END IF;" + debug_lf;
    }
  }

  v_g= v_g
       + "SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_server_variables);\n"
       + "CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);" + debug_lf
       + "CALL xxxmdbug.icc_change_statement_status('OK');" + debug_lf
       + "END;" + debug_lf;

  v_g_2= v_g_2
           + "CALL xxxmdbug.icc_change_statement_status(@xxxmdbug_tmp_for_set);" + debug_lf
           + "END;" + debug_lf;

  /*
    When setup_internals() sees what you add here,
    it will actually execute the creates. That is:
    drop + create icc_process_user_command_r_server_variables
    drop + create icc_process_user_command_set_server_variables
    update xxxmdbug.routines
  */
  debug_routine_list_schemas << "xxxmdbug";
  debug_routine_list_names << "";
  debug_routine_list_types << "PROCEDURE";
  debug_routine_list_sql_modes << "";
  debug_routine_list_surrogates << v_g_surrogate_routine_identifier;
  debug_routine_list_texts << v_g;

  debug_routine_list_schemas << "xxxmdbug";
  debug_routine_list_names << "";
  debug_routine_list_types << "PROCEDURE";
  debug_routine_list_sql_modes << "";
  debug_routine_list_surrogates << v_g_2_surrogate_routine_identifier;
  debug_routine_list_texts << v_g_2;
  return 0;
}

/* This generates a variant icc_core that can handle 'refresh user_variables'..
   Any changes to icc_core() should be made here too.
   Comments are stripped so see the original icc_core() above.
   The tmp_user_variables list was populated with @user-variable-names while we were generating.
     Although it is easy to assign to a user variable or server variable by
     preparing and executing a SET statement, it is unreliable because we
     might be in a function rather than in a procedure. So, for 'set', we
     generate fixed SET statements for the user variables that we know of.
   Use the base icc_core if track_user_variables=0.
   Todo: probably this would be faster if it was smaller. */
int MainWindow::setup_generate_icc_core()
{
  QString v_g;
  /* we already know icc_core_surrogate_name */
  v_g= "CREATE PROCEDURE xxxmdbug."
          + debug_xxxmdbug_icc_core_surrogate_name
          + "(line_number INT) "
          + debug_lf;

/* part 1 -- as far as the first 'call xxxmdbug.process_user_command'."
   v_ret and v_prefix are part of the variant. */
/* todo: as far as I can tell, the initial label 'z:' is not needed */
  v_g= v_g
          + "z:BEGIN" + debug_lf
          + "DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8;" + debug_lf
          + "DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" + debug_lf
          + "DECLARE sleep_result INT;" + debug_lf
          + "DECLARE v_n INT;" + debug_lf
          + "DECLARE v_flags INT;"
          + "DECLARE v_table_is_temporary_and_to_be_cleared INT;" + debug_lf
          + "SET @xxxmdbug_token_value_1 = '';"
          + "SET @xxxmdbug_icc_count=@xxxmdbug_icc_count+1;" + debug_lf
          + "x1: LOOP" + debug_lf
          + "  CALL xxxmdbug.icc_get_user_command(0);" + debug_lf
          + "  IF @xxxmdbug_message <= 0x20 THEN LEAVE x1; END IF;" + debug_lf
          + "  IF @xxxmdbug_token_value_1 IN ('continue','exit','leave','next','execute','skip','step') THEN LEAVE x1; END IF;"
          + "  IF @xxxmdbug_token_value_2 = 'user_variables' THEN" + debug_lf
          + "    SET v_ret='';" + debug_lf;
/* part 1 end */
  for (int i= 0; i < debug_tmp_user_variables.count(); ++i)
  {
    QString v_variable_name= debug_tmp_user_variables.at(i);
    v_g= v_g
          + "SET @xxxmdbug_uvar="
          + v_variable_name
          + ";"
          + "SET @xxxmdbug_old_uvar="
          + "@xxxmdbug_old_"
          + v_variable_name.mid(1, v_variable_name.length() - 1)
          + ";";
    v_g= v_g
          + "CALL xxxmdbug.uvar(v_ret,'"
          + v_variable_name
          + "');" + debug_lf;
  }

  v_g= v_g + "SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_user_variables);" + debug_lf
                       + "CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);" + debug_lf
                       + "CALL xxxmdbug.icc_change_statement_status('OK');" + debug_lf
                       + "ELSE" + debug_lf
                       + "CALL xxxmdbug.icc_process_user_command();" + debug_lf
                       + "END IF;" + debug_lf;

  v_g= v_g + "IF @xxxmdbug_token_value_1 = 'set' AND LEFT(@xxxmdbug_token_value_2,1) = '@' AND LEFT(@xxxmdbug_token_value_2,2) <> '@@' THEN" + debug_lf
                       + "  SET @xxxmdbug_status_last_command = 'set';" + debug_lf
                       + "  SET @xxxmdbug_tmp_for_set='Fail';" + debug_lf;
  for (int i= 0; i < debug_tmp_user_variables.count(); ++i)
  {
    QString v_variable_name= debug_tmp_user_variables.at(i);
    v_g= v_g
                       + "  IF @xxxmdbug_token_value_2 = '"
                       +    v_variable_name
                       +    "' THEN CALL xxxmdbug.retype(); SET "
                       +    v_variable_name
                       +    "= @xxxmdbug_token_value_4a; SET @xxxmdbug_tmp_for_set='OK'; END IF;" + debug_lf;
  }
  v_g= v_g + "CALL xxxmdbug.icc_change_statement_status(@xxxmdbug_tmp_for_set);" + debug_lf;
  v_g= v_g + "END IF;" + debug_lf;
  /* part 2 */
  v_g= v_g
                       + "END LOOP;" + debug_lf
                       + "SET @xxxmdbug_status_line_number = line_number;" + debug_lf
                       + "CALL xxxmdbug.icc_breakpoint_check(line_number,@xxxmdbug_breakpoint_check_result);" + debug_lf
                       + "SET @xxxmdbug_status_breakpoint_check_result = @xxxmdbug_breakpoint_check_result;" + debug_lf
                       + "CALL xxxmdbug.icc_send_statement_status('icc_core');" + debug_lf
                       + "IF @xxxmdbug_breakpoint_check_result > 0 THEN" + debug_lf
                       + "x2: LOOP" + debug_lf
                       + "IF @xxxmdbug_token_value_1 IN ('continue','exit','leave','next','execute','skip','step') THEN" + debug_lf
                       + "LEAVE x2;" + debug_lf
                       + "END IF;" + debug_lf
                       + "CALL xxxmdbug.icc_get_user_command(1);" + debug_lf
                       + "IF @xxxmdbug_token_value_1 IN ('next','step') THEN CALL xxxmdbug.icc_process_user_command_step_or_next(); END IF;" + debug_lf
                       + "IF @xxxmdbug_token_value_1 IN ('continue','exit','leave','next','execute','skip','step') THEN" + debug_lf
                       + "LEAVE x2;" + debug_lf
                       + "END IF;" + debug_lf
                       + "IF @xxxmdbug_token_value_2 = 'user_variables' THEN" + debug_lf
                       + "SET v_ret='';" + debug_lf;
/* part2 end */
  for (int i= 0; i < debug_tmp_user_variables.count(); ++i)
  {
    QString v_variable_name= debug_tmp_user_variables.at(i);
    v_g= v_g
                        + "SET @xxxmdbug_uvar="
                        + v_variable_name
                        + ";"
                        + "SET @xxxmdbug_old_uvar=@xxxmdbug_old_"
                        + v_variable_name.mid(1,v_variable_name.length() - 1)
                        + ";"
                        + "CALL xxxmdbug.uvar(v_ret,'"
                        + v_variable_name
                        + "');" + debug_lf;
  }
  v_g= v_g
                        + "SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_user_variables);" + debug_lf
                        + "CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);" + debug_lf
                        + "CALL xxxmdbug.icc_change_statement_status('OK');" + debug_lf
                        + "ELSE "
                        + "CALL xxxmdbug.icc_process_user_command();" + debug_lf
                        + "END IF;" + debug_lf;
  v_g= v_g
                        + "IF @xxxmdbug_token_value_1 = 'set' AND LEFT(@xxxmdbug_token_value_2,1) = '@'  AND LEFT(@xxxmdbug_token_value_2,2) <> '@@' THEN" + debug_lf
                        + "SET @xxxmdbug_status_last_command = 'set';" + debug_lf
                        + "SET @xxxmdbug_tmp_for_set = 'Fail';" + debug_lf;
  for (int i= 0; i < debug_tmp_user_variables.count(); ++i)
  {
    QString v_variable_name= debug_tmp_user_variables.at(i);
    v_g= v_g
                        + "IF @xxxmdbug_token_value_2 = '"
                        + v_variable_name
                        + "' THEN CALL xxxmdbug.retype(); SET "
                        + v_variable_name
                        + "= @xxxmdbug_token_value_4a; SET @xxxmdbug_tmp_for_set = 'OK'; END IF;" + debug_lf;
  }
  v_g= v_g + "CALL xxxmdbug.icc_change_statement_status(@xxxmdbug_tmp_for_set);" + debug_lf;
  v_g= v_g + "END IF;" + debug_lf;
/* part 3 start */
  v_g= v_g + "CALL xxxmdbug.icc_send_statement_status('icc_core');\n"
                       + "END LOOP;" + debug_lf
                       + "CALL xxxmdbug.icc_send_statement_status('icc_core');\n"
                       + "END IF;" + debug_lf;
/* part 3 end */
/* part 4 */
/* Copy all user variables to old user variables. For example, if there is
   a user variable @a, this will generate \"SET @xxxmdbug_old_a=@a;\".
   Results should show up in user_variables.old_value column.
   Todo: check for too-long variable names.
   Todo: there has to be some way to clean up all the @xxxmdbug_old_ variables. */
  for (int i= 0; i < debug_tmp_user_variables.count(); ++i)
  {
    QString v_variable_name= debug_tmp_user_variables.at(i);
    v_g= v_g
            + "SET @xxxmdbug_old_"
            + v_variable_name.mid(1, v_variable_name.length() - 1)
            + "="
            + v_variable_name
            + ";" + debug_lf;
  }
  v_g= v_g + "END;" + debug_lf;

  debug_routine_list_schemas << "xxxmdbug";
  debug_routine_list_names << debug_xxxmdbug_icc_core_surrogate_name;
  debug_routine_list_types << "PROCEDURE";
  debug_routine_list_sql_modes << "";
  debug_routine_list_surrogates << debug_xxxmdbug_icc_core_surrogate_name;
  debug_routine_list_texts << v_g;

  return 0;
}

/* Todo: "    IF v_statement_type = 'debuggable' THEN" ... */
int MainWindow::setup_generate_statements_debuggable(int i_of_statement_start,
                                                      int v_line_number_of_start_of_first_token,
                                                      int v_statement_number_within_routine,
                                                      QString text,
                                                      int v_token_number_of_last_token,
                                                      int routine_number)
{
  /* starts "if statement is being debugged" */
  debug_v_g= debug_v_g + "IF xxxmdbug.is_debuggee_and_is_attached()=1 THEN " + debug_lf;
  /* inner_loop: generate 'xxxmdbug_inner_loop_x: LOOP' */
  QString inner_loop_label= "xxxmdbug_inner_loop_label_" + QString::number(v_statement_number_within_routine);
  if (is_plsql)
    debug_v_g= debug_v_g
            + "<<" + inner_loop_label + ">> "
            + "LOOP" + debug_lf;
  else
    debug_v_g= debug_v_g
            + inner_loop_label
            + ": LOOP" + debug_lf;
//  /* Save @@warning_count. */
//  int v_verb= i; /* == token_number_of_first_token?? */
//  /* TODO: Find out previous_statement_type */
  /* Find out if previous_statement_type was nothing | DECLARE HANDLER */
  QString v_previous_statement_type= "not declare_handler";
  bool handler_seen= false;
  for (int i= i_of_statement_start; i >= 0; --i)
  {
    if (main_token_flags[i] & TOKEN_FLAG_IS_START_STATEMENT)
    {
      if ((main_token_types[i] == TOKEN_KEYWORD_DECLARE)
       && (handler_seen == true))
        v_previous_statement_type= "declare_handler";
      break;
    }
    if (main_token_types[i] == TOKEN_KEYWORD_HANDLER) handler_seen= true;
  }
  int is_first_statement_in_a_declare_handler;
  if (v_previous_statement_type == "declare_handler")
    is_first_statement_in_a_declare_handler= 1;
  else
    is_first_statement_in_a_declare_handler= 0;
  debug_v_g= debug_v_g + debug_lf + "CALL xxxmdbug.icc_start("
           + QString::number(v_line_number_of_start_of_first_token)
           + ","
           + QString::number(is_first_statement_in_a_declare_handler)
           + ");"  + debug_lf;
  if (setup_determine_what_variables_are_in_scope(i_of_statement_start, text, false)) return 1; /* result=c_variables */

  for (int i= c_variable_names.count() - 1; i >= 0; --i)
  {
    QString v_variable_identifier= c_variable_names.at(i);
    QString v_token_number_of_declare= c_variable_tokens.at(i);
    //"          CALL xxxmdbug.overflow_check(debug_v_g);
    debug_v_g= debug_v_g + debug_lf
         + "CALL xxxmdbug.icc_copy_variable_to_table_row('"
         + v_variable_identifier
         + "',"
         + v_token_number_of_declare
         + ","
         + v_variable_identifier
         + ");" + debug_lf;
  }
  /* generate 'call icc_core' */
  debug_v_g= debug_v_g + "CALL xxxmdbug."
           + debug_xxxmdbug_icc_core_surrogate_name
           + "("
           + QString::number(v_line_number_of_start_of_first_token)
           + ");" + debug_lf;

  /* Generate: "if (exit) signal" */
  /* todo: consider doing the signal in icc_core or icc_process_user_command but maybe then it won't be handled. */
  debug_v_g= debug_v_g + "IF @xxxmdbug_token_value_1 = 'exit' THEN SIGNAL sqlstate '56780' SET mysql_errno = @xxxmdbug_signal_errno; END IF;";
  for (int i= c_variable_names.count() - 1; i >= 0; --i)
  {
    QString v_variable_identifier= c_variable_names.at(i);
    QString v_token_number_of_declare= c_variable_tokens.at(i);
    //"          CALL xxxmdbug.overflow_check(debug_v_g);
    debug_v_g= debug_v_g + debug_lf
         + "CALL xxxmdbug.icc_copy_table_row_to_variable('"
         + v_variable_identifier
         + "',"
         + v_token_number_of_declare
         + ","
         + v_variable_identifier
         + ");" + debug_lf;
  }
  /* inner_loop: 'SET' and 'EXECUTE' might change variables that we're watching.
     So if they happened, go back and copy the variables again.
     Todo: think: should this happen after non-debuggable statements too? */
  QString iterate;
  if (is_plsql) iterate= "CONTINUE ";
  else iterate= "ITERATE ";
  debug_v_g= debug_v_g + "IF @xxxmdbug_breakpoint_check_result>0 AND (@xxxmdbug_token_value_1 = 'set' OR @xxxmdbug_token_value_1 = 'execute') THEN "
             + iterate
             + inner_loop_label
             + "; END IF;" + debug_lf;
  /* Check @@warning_count. */
  debug_v_g= debug_v_g + debug_lf + "CALL xxxmdbug.icc_end();" + debug_lf;
  /* Generate: "if (leave) leave" i.e. leave outer loop */
  /* Sometimes LEAVE is illegal, see insert_into_statements comments.
     If so act as if 'leave' is 'skip'. */
  bool is_leave_possible;
  for (int j= i_of_statement_start - 1;; --j)
  {
    if (j <= i_of_end_of_parameters)
    {
      is_leave_possible= false;
      break;
    }
    if (main_token_types[j] == TOKEN_KEYWORD_END)
    {
      int k= main_token_pointers[j];
      if ((k >= j) || (k < 1))
      {
        is_leave_possible= false;  /* should be an assert */
        break;
      }
      j= main_token_pointers[j];
      continue;
    }
    if (main_token_flags[j] & TOKEN_FLAG_IS_START_STATEMENT)
    {
      bool is_begin_ok= true;
      if ((is_plsql) && (debug_label_list.count() != 1)) is_begin_ok= false;
      if (((main_token_types[j] == TOKEN_KEYWORD_BEGIN) && (is_begin_ok))
       || (main_token_types[j] == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT)
       || (main_token_types[j] == TOKEN_KEYWORD_LOOP)
       || (main_token_types[j] == TOKEN_KEYWORD_REPEAT)
       || (main_token_types[j] == TOKEN_KEYWORD_WHILE))
      {
        is_leave_possible= true;
        break;
      }
    }
    else
      if (main_token_types[j] == TOKEN_KEYWORD_HANDLER)
    {
      is_leave_possible= false;
      break;
    }
  }
  QString leave;
  if (is_plsql) leave= "EXIT ";
  else leave= "LEAVE ";
  if (is_leave_possible == true)
  {
    if (debug_label_list.count() == 0) /* pseudo-assert */
    {
      debug_error((char*)"debug_label_list.count() == 0");
      return 1;
    }
    debug_v_g= debug_v_g + debug_lf + "IF @xxxmdbug_token_value_1 = 'leave' THEN ";
    if ((is_plsql) && (debug_label_list.count() == 1))
    {
      debug_v_g= debug_v_g +"GOTO xxxmdbug_routine_exit";
    }
    else
    {
      debug_v_g= debug_v_g
             + "LEAVE "
             + debug_label_list.at(debug_label_list.count() - 1);
    }
    debug_v_g= debug_v_g
             + "; END IF;" + debug_lf;
  }
  else
  {
    debug_v_g= debug_v_g + debug_lf + "IF @xxxmdbug_token_value_1 = 'leave' THEN "
             + leave
             + inner_loop_label
             + "; END IF;" + debug_lf;
  }
  /* inner_loop: by leaving inner_loop before doing the instruction, we "skip over" it */
  debug_v_g= debug_v_g + "IF @xxxmdbug_token_value_1 = 'skip' THEN "
           + leave
           + inner_loop_label
           + "; END IF;" + debug_lf;
  /* If the original routine contained only one statement which was not compound and which
     did not end with ';', add ';'.
     Todo: Check: isn't this impossible? Didn't we add ";" earlier?
           I've assumed it's impossible, but statement ends with ";".
  */
  QString v_statement_end_character= ";";
  /* generate: handlers */
  /* removed. see notes before generate_handlers(). CALL xxxmdbug.generate_handlers(debug_v_g,v_line_number_of_start_of_first_token); */
//"  CALL xxxmdbug.overflow_check(debug_v_g);"
  /* todo: we got sql_mode earlier but we don't seem to be using it! */
  if (setup_generate_statement_text(i_of_statement_start, text, v_token_number_of_last_token, routine_number)) return 1;
  /* END the BEGIN that generate_handlers() generated */
  /* removed. see notes before generate_handlers(). SET debug_v_g = CONCAT(debug_v_g,@xxxmdbug_lf,'END;'); */

  /* generate something to insert if statement is 'prepare' or delete if statement is 'deallocate' */
  /* todo: think about the execution path if there is a user-written warning */
  int statement_type= main_token_types[i_of_statement_start];
  if ((statement_type == TOKEN_KEYWORD_PREPARE)
   || (statement_type == TOKEN_KEYWORD_DROP)
   || (statement_type == TOKEN_KEYWORD_DEALLOCATE))
  {
    QString v_value_of_second_token= "";
    QString v_value_of_third_token= "";
    QString v_value_of_fourth_token= "";
    for (int i= i_of_statement_start + 1; main_token_lengths[i] != 0; ++i)
    {
      if ((main_token_types[i] >= TOKEN_TYPE_COMMENT_WITH_SLASH)
       && (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_MINUS))
        continue;
      QString n= text.mid(main_token_offsets[i], main_token_lengths[i]);
      if (v_value_of_second_token == "") v_value_of_second_token= n;
      else if (v_value_of_third_token == "") v_value_of_third_token= n;
      else
      {
        v_value_of_fourth_token= n;
        break;
      }
    }
    if (statement_type == TOKEN_KEYWORD_PREPARE)
    {
      /* I think v_value_of_fourth_token has ''s already, correctly */
      debug_v_g= debug_v_g + debug_lf + "CALL xxxmdbug.insert_into_prepared_statements('"
               + v_value_of_second_token
               + "',"
               + v_value_of_fourth_token
               + ");";
    }
    if (statement_type ==  TOKEN_KEYWORD_DROP)
    {
      /* A little-known alternative syntax for DEALLOCATE PREPARE is DROP PREPARE. */
      if (QString::compare(v_value_of_second_token, "PREPARE", Qt::CaseInsensitive) == 0)
      {
        statement_type= TOKEN_KEYWORD_DEALLOCATE;
      }
    }
    if (statement_type ==  TOKEN_KEYWORD_DEALLOCATE)
    {
      debug_v_g= debug_v_g + debug_lf + "CALL xxxmdbug.delete_from_prepared_statements('"
               + v_value_of_third_token
               + "');";
    }
  }
  /* generate 'update statements_executed' */
  debug_v_g= debug_v_g + debug_lf + "CALL xxxmdbug.update_statements_executed(0);";
  /* inner_loop: leave the loop after doing the original statement once */
  debug_v_g= debug_v_g + debug_lf
          + leave
          + inner_loop_label
          + ";" + debug_lf;
  /* inner loop: ends */
  debug_v_g= debug_v_g + "END LOOP;" + debug_lf;
  debug_v_g= debug_v_g + debug_lf + "ELSE"; /* terminates "if statement is being debugged" */
  /* "generate the statement text" for when we're not debugging */
//"      CALL xxxmdbug.overflow_check(debug_v_g);"
  if (setup_generate_statement_text_as_is(i_of_statement_start, text, v_token_number_of_last_token)) return 1;
  //"      SET debug_v_g = CONCAT(debug_v_g,v_statement_end_character);"
  debug_v_g= debug_v_g + debug_lf + "END IF;";
  return 0;
}

/* "Generate: label": Called from generate()
   Whenever you see WHILE or LOOP or BEGIN or REPEAT, make|copy a label and add to label list
   Whenever you see END (but not END IF or END CASE), remove last item in label list
   LEAVE will use the latest item in label list.
*/
int MainWindow::setup_generate_label(int i_of_start_of_statement, QString text, int v_statement_number)
{
  QString v_label;
  QString v_token_value_of_previous_token;
  int token_type;
  token_type= main_token_types[i_of_start_of_statement];
  if ((token_type == TOKEN_KEYWORD_BEGIN)
   || (token_type == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT)
   || (token_type == TOKEN_KEYWORD_LOOP)
   || (token_type == TOKEN_KEYWORD_REPEAT)
   || (token_type == TOKEN_KEYWORD_WHILE))
  {
    int j;
    for (j= i_of_start_of_statement - 1; j > i_of_end_of_parameters; --j)
    {
      token_type= main_token_types[j];
      if ((main_token_types[j] >= TOKEN_TYPE_COMMENT_WITH_SLASH)
       && (main_token_types[j] <= TOKEN_TYPE_COMMENT_WITH_MINUS))
        continue;
      v_token_value_of_previous_token= text.mid(main_token_offsets[j], main_token_lengths[j]);
      break;
    }
    if (v_token_value_of_previous_token == ":")
    {
      v_label= text.mid(main_token_offsets[j-1], main_token_lengths[j-1]);
    }
    else
    {
      v_label= " xxxmdbug_label_" + QString::number(v_statement_number);
      /* the ' ' is necessary if the while/loop/begin/repeat is not at start of line */
      if (is_plsql)
        debug_v_g= debug_v_g + " <<" + v_label + ">>";
      else
        debug_v_g= debug_v_g + " " + v_label + ":";
      debug_v_g= debug_v_g + debug_lf;
    }
    debug_label_list << v_label;
  }
  if (token_type == TOKEN_KEYWORD_END)
  {
    int j;
    for (j= i_of_start_of_statement + 1; main_token_lengths[j] != 0; ++j)
    {
      if ((main_token_types[j] >= TOKEN_TYPE_COMMENT_WITH_SLASH)
       && (main_token_types[j] <= TOKEN_TYPE_COMMENT_WITH_MINUS))
        continue;
      break;
    }
    if ((main_token_types[j] != TOKEN_KEYWORD_IF)
     && (main_token_types[j] != TOKEN_KEYWORD_CASE))
    {
      if (debug_label_list.count() == 0) /* pseudo-assert */
      {
        debug_error((char*)"label_list.count() == 0");
        return 1;
      }
      debug_label_list.removeAt(debug_label_list.count() - 1);
    }
  }
  return 0;
}
#endif //if (OCELOT_MYSQL_DEBUGGER == 1)

/* Todo: I'm excluding MariaDB variables defined as row type or
   within FOR var-name IN, since $debug can't handle them.
   It's probably fixable -- we don't absolutely have to have the
   data type (we get along without it for $user-variables); we
   should be able to recognize `row`.`scalar` names even if we
   have to lie to install_sql.cpp.
*/
int MainWindow::setup_row_type(int i_of_variable)
{
  for (int i= i_of_variable; main_token_lengths[i] != 0; ++i)
  {
    if ((main_token_flags[i] & TOKEN_FLAG_IS_DATA_TYPE) != 0)
    {
      if ((main_token_types[i] == TOKEN_KEYWORD_ROW)
       || (main_token_types[i] == TOKEN_KEYWORD_TYPE))
        return TOKEN_KEYWORD_ROW;
      return main_token_types[i];
    }
    if (main_token_types[i] == TOKEN_KEYWORD_IN) return TOKEN_KEYWORD_ROW;
    if ((main_token_flags[i] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
      break; /* reached next statement without seeing data type? impossible */
  }
  return 0;
}

/* Make c_variables = a list of in-scope variables. */
/* Use the same trick that was used for hparse_f_label */
/* token_number_of_declare starts at 1 after end of (parameter list)
   (or maybe it's 2 after start of parameter list?) */
/* Todo: Something can be in scope but shadowed. Look for duplicates! */
/* Todo: You're not handling identifiers that need delimiting */
/* Warning: Since search is from end to start, list is backwards.
   Therefore, when searching or copying, go in reverse order. */
/* Somewhere in some install_sql.cpp routine is an expectation that
   variables are inside ``s. So we add ``s if they're absent. */
/* Todo: Preserve the case of the original, not the reference (?).
   Todo: See what happens if it's in ""s or in ''s. */
/* Todo: We plan to change hparse_f_variables() so variable_refer
         points to variable_define. If that's done, this may be easier. */
/* Note: going backwards means for DEFINE x INT; we will see data_type INT before we see the name, good. */
int MainWindow::setup_determine_what_variables_are_in_scope(
            int i_of_statement_start,
            QString text,
            bool must_be_int)
{
  int data_type= -1;
  c_variable_names.clear();
  c_variable_tokens.clear();
  int v_token_number_of_declare= 0;
  bool is_identifier;
  for (int i= i_of_statement_start - 1; i >= 0; --i)
  {
    if (main_token_types[i] == TOKEN_KEYWORD_END)
    {
      int j= main_token_pointers[i];
      if ((j >= i) || (j < 1)) break; /* should be an assert */
      i= main_token_pointers[i];
      continue;
    }
    QString v_variable_identifier= "";
    if ((main_token_flags[i] & TOKEN_FLAG_IS_DATA_TYPE) != 0) data_type= main_token_types[i];
    is_identifier= false;
    if ((main_token_types[i] == TOKEN_TYPE_IDENTIFIER)
     || (main_token_types[i] == TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK)
     || (main_token_types[i] == TOKEN_TYPE_IDENTIFIER_WITH_DOUBLE_QUOTE))
    {
      if ((must_be_int == false) || (typer_is_int(data_type) == true))
        is_identifier= true;
    }
    if ((is_identifier)
     && (main_token_reftypes[i] == TOKEN_REFTYPE_VARIABLE_DEFINE))
    {
      v_variable_identifier= text.mid(main_token_offsets[i], main_token_lengths[i]);
      /* s = the var! */
      int k;
      for (k= i - 1; k >= 0; --k)
      {
        if ((main_token_flags[k] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
          break;
      }
      v_token_number_of_declare= k - i_of_start_of_parameters;
    }
    if ((is_identifier)
     && (i < i_of_end_of_parameters)
     && (main_token_reftypes[i] == TOKEN_REFTYPE_PARAMETER_DEFINE))
    {
      v_variable_identifier= text.mid(main_token_offsets[i], main_token_lengths[i]);
      v_token_number_of_declare= 0;
    }
    if (v_variable_identifier != "")
    {
      v_variable_identifier= setup_add_delimiters(v_variable_identifier);
      bool is_shadow= false;
      /* todo: variable_names.contains() would do this faster, I think. But it's in Qt 5.12+. */
      for (int m= 0; m < c_variable_names.count(); ++m)
      {
        if (QString::compare(c_variable_names.at(m), v_variable_identifier, Qt::CaseInsensitive) == 0)
        {
          is_shadow= true;
          break;
        }
      }
      if (is_shadow == false)
      {
        c_variable_names << v_variable_identifier;
        if (setup_row_type(i) == TOKEN_KEYWORD_ROW)
          c_variable_tokens << QString::number(-1);
        else
          c_variable_tokens << QString::number(v_token_number_of_declare);
      }
    }
  }
  for (int k= c_variable_tokens.count() - 1; k >= 0; --k)
  {
    int k2= c_variable_tokens.at(k).toInt();
    if (k2 == -1)
    {
      c_variable_names.removeAt(k);
      c_variable_tokens.removeAt(k);
    }
  }
  return 0;
}

#if (OCELOT_MYSQL_DEBUGGER == 1)
/*
  Generate the statement text, but replace routine names
  with surrogate routine names if they are in the $setup list,
  and being invoked.
  Beware: spaces after function names matter
  Todo: DO NOT necessarily replace with surrogate routine name. We might have put it in directly."
  Todo: check that argument count = parameter count."
  Todo: handle possible qualifier."
  Todo: handle possible delimiter."
  Todo: check that function name <> built-in name,
        in that case it's ignored (detectable at CREATE time).
  Todo: skip if CREATE? I forget why we substitute for CREATE.
  Todo: call this for flow-control statements, but they must end
        after the expression, e.g. WHILE (expr) DO ends with DO.
        (This also applies for DECLARE HANDLER.)
  Todo: call this for DECLARE because DEFAULT clauses can have (expr).
  Todo: I don't know how to handle PREPARE or EXECUTE IMMEDIATE yet,
        but if they have literal arguments there is hope.
  Todo: watch out for routine characteristic = ansi_quotes.
        (we've used debug_ansi_quotes elsewhere)
  Todo: Flow-control is not debuggable but might contain function calls.
  Warning: We're preserving comments because if they start with / * !
           they are not stripped, but we don't see inside them.
*/
int MainWindow::setup_generate_statement_text(int i_of_statement_start,
                                               QString text,
                                               int v_token_number_of_last_token,
                                               int routine_number
                                              )
{
  //bool statement_might_contain_routine_invocation= false;
  int statement_type= main_token_types[i_of_statement_start];

  /*
     special handling of RETURN -- remove the function name from the call stack before returning.
     we also do delete from call stack at the end of the routine, due to generate_ender.
     todo: more special handling of RETURN: we pointlessly generate
           CALL xxxmdbug.update_statements_executed(0);
           LEAVE xxxmdbug_inner_loop_label_2;
  */
  if (statement_type == TOKEN_KEYWORD_RETURN)
    debug_v_g= debug_v_g + "CALL xxxmdbug.routine_exit();" + debug_lf;
  /*
    TOKEN_KEYWORD_CREATE used to be in this list, but I removed it.
    Todo: Perhaps CREATE TABLE AS SELECT could be okay though.
    Currently it doesn't matter because we check everything.
  */
  //if ((statement_type == TOKEN_KEYWORD_CALL)
  // || (statement_type == TOKEN_KEYWORD_CASE)
  // || (statement_type == TOKEN_KEYWORD_DECLARE)
  // || (statement_type == TOKEN_KEYWORD_DELETE)
  // || (statement_type == TOKEN_KEYWORD_DO)
  // || (statement_type == TOKEN_KEYWORD_ELSEIF)
  // || (statement_type == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT)
  // || (statement_type == TOKEN_KEYWORD_IF)
  // || (statement_type == TOKEN_KEYWORD_INSERT)
  // || (statement_type == TOKEN_KEYWORD_REPLACE)
  // || (statement_type == TOKEN_KEYWORD_RETURN)
  // || (statement_type == TOKEN_KEYWORD_SELECT)
  // || (statement_type == TOKEN_KEYWORD_SET)
  // || (statement_type == TOKEN_KEYWORD_UNTIL)
  // || (statement_type == TOKEN_KEYWORD_WHILE))
  //  statement_might_contain_routine_invocation= true;
  for (int i= i_of_statement_start; main_token_lengths[i] != 0; ++i)
  {
    QString d= text.mid(main_token_offsets[i], main_token_lengths[i]);

    /*
      special handling of BEGIN NOT ATOMIC -- only output BEGIN
      looks like MariaDB has a bug with "label: BEGIN NOT ATOMIC"
    */
    if (statement_type == TOKEN_KEYWORD_BEGIN)
    {
      int m;
      for (m= i_of_statement_start; m <= v_token_number_of_last_token; ++m)
      {
        if (main_token_lengths[m] == 0) break; /* should be an assert? */
        if (main_token_types[m] == TOKEN_KEYWORD_ATOMIC)
        {

          if (setup_append(d, text, i)) return 1;
          return 0;
        }
      }
    }

    int reftype= main_token_reftypes[i];
    if ((reftype == TOKEN_REFTYPE_FUNCTION)
     || (reftype == TOKEN_REFTYPE_PROCEDURE)
     || (reftype == TOKEN_REFTYPE_FUNCTION_OR_PROCEDURE))
    {
      QString tmp_schema_name= "";
      if (i > 2)
      {
        QString d= text.mid(main_token_offsets[i-1], main_token_lengths[i-1]);
        if (d == ".")
        {
          if (main_token_reftypes[i-2] == TOKEN_REFTYPE_DATABASE)
          {
            tmp_schema_name= text.mid(main_token_offsets[i-2], main_token_lengths[i-2]);
          }
        }
      }
      if (tmp_schema_name == "")
      {
        if (routine_number >= debug_routine_list_schemas.count()) /* pseudo-assert */
        {
          debug_error((char*)"bad routine_number");
          return 1;
        }
        tmp_schema_name= debug_routine_list_schemas.at(routine_number);
      }

      QString c_routine_name= setup_add_delimiters(d);
      QString c_schema_name= setup_add_delimiters(tmp_schema_name);

      /* Todo: What about TOKEN_REFTYPE_FUNCTION_OR_VARIABLE? */
      /* Todo: Are you sure hparse is catching this? */
      /* Todo: you're failing to check whether it's 'P' or 'F' */
      for (int i= 0; i < debug_routine_list_names.count(); ++i)
      {
        QString d_routine_name= debug_routine_list_names.at(i);
        QString d_schema_name= debug_routine_list_schemas.at(i);
        d_routine_name= setup_add_delimiters(d_routine_name);
        d_schema_name= setup_add_delimiters(d_schema_name);
        if ((QString::compare(c_routine_name, d_routine_name, Qt::CaseInsensitive) == 0)
         && (QString::compare(c_schema_name, d_schema_name, Qt::CaseInsensitive) == 0))
        {
          d= debug_routine_list_surrogates.at(i);
        }
      }
    }
    /* Todo: Why are you dumping d but not schema? */
    if (setup_append(d, text, i)) return 1;
    if (i == v_token_number_of_last_token) break;
  }
  return 0;
}

/* Generate: "statement text" but without any changes or special handling.
   This is for "if (statement is being debugged) is false" */
/* Todo: an assert that v_token_number_of_last_token is reasonable. */
/* Todo: copy line feeds and indentation of the original */
int MainWindow::setup_generate_statement_text_as_is(int i_of_statement_start,
                                                     QString text,
                                                     int v_token_number_of_last_token)
{
  int i;
  QString d;
  debug_v_g= debug_v_g + debug_lf;
  i= v_token_number_of_last_token;
  d= text.mid(main_token_offsets[i_of_statement_start],
              (main_token_offsets[i] - main_token_offsets[i_of_statement_start]) + main_token_lengths[i]);
  if (setup_append(d, text, i)) return 1;
  return 0;
}
#endif //if (OCELOT_MYSQL_DEBUGGER == 1)

/*
  clf stands for create lua function. All its sub-functions begin with clf_.
  If input is CREATE LUA PROCEDURE or CREATE LUA FUNCTION,
  we generate a Lua function that would do the same thing.
  Called from execute_client_statement().
  It works only if syntax checking is on and sql mode is not Oracle.
  Re labels: see clf_label
  Re comments:
    We preserve them inside box.execute([[...]]). Outside, block comment is --[[]], -- comment is unchanged
    Beware: we do lots of iterating through the tokens, usually it should not be with ++ unless comments are skipped.
  Re semicolons: They're often unnecessary in Lua but we preserve them when we can.
  Re object names: If they're within ""s we strip the ""s and output after making pretty, else we output upper().
  Re variables:
    For "DECLARE x INT" the Lua name is X.
    When using in an SQL expression, we don't replace with "CAST(? AS data_type)", we do put Lua name in parameter list
    When using as target of SET, replace with lua_name = box.execute([[SELECT (expression);]])
  Re other kinds of DECLARE besides DECLARE variables:
    No support, we're working on it
  Re BEGIN:
        You can LEAVE from a BEGIN, or have an error that forces leave from begin.
        Option 1: a loop that you break from: while true do ... break; end
                  However, "break" won't work right if we're trying to exit from begin...while...end-while...end,
                  you'd only break out of the while, so you have to hve goto past-end anyway.
        Option 2: do...end (what we chose). it doesn't confuse (possibly a loop would be confusing)
                  but all Lua statements for getting out of the loop have to be goto past-end,
                  unless it's the last statement.
  Re conditions:
       For IF and UNTIL and WHILE, the condition checking is according to SQL logic,
       and might contain declared variables, so we pass the condition to a SELECT and see if it returns true.
        After WHILE etc. we will have a condition, which we will pass to SQL, but it isn't the statement end.
        There is a check here whether executing the SELECT causes an error, but that is okay because
        sql_execute() is supposed to return nil when there is an error, so the condition will not be true,
        so we will end up after the END, and conditions do get checked after END (I hope).
  Todo: add recursion for all flow-control statements so you can handle IF within IF
  Todo: For LEAVE or ITERATE, check that label exists and goto will work.
        Lua goto might fail if it is over a local declare.
        There is no check in hparse whether a target exists, I think.
        Unlike DB2, we won't allow ITERATE or LEAVE to jump out of a handler because each handler has its own function.
*/

int clfi; /* In clf() and its offspring, this is the index for main_token_xxx lists */
QString clf_parameter_list;
int clf_last_token; /* maybe a better name would be i_of_last_token */
QString clf_output_final;

int handler_count;
int *handler_starts;
int *handler_code_ends;
int *handler_scope_ends;
int *handler_begin_of_declares; /* to BEGIN or to label preceding BEGIN */
QString sql_execute_starter;
QString sql_execute_ender;

void MainWindow::clf(QString text)
{
  log("clf start", 90);
  clf_output_final= "";
  QString clf_output_main_function= "";
  clf_last_token= main_token_number + main_token_count_in_statement;
  //QString indent_string;

  /* Preliminary error checks. */
  if (((ocelot_statement_syntax_checker.toInt()) & (FLAG_FOR_HIGHLIGHTS | FLAG_FOR_ERRORS)) != (FLAG_FOR_HIGHLIGHTS | FLAG_FOR_ERRORS))
  {
    clf_output_final= "Sorry, we cannot handle this statement unless ocelot_statement_syntax_checker flags are on.";
    goto ret;
  }
  if ((hparse_errno != 0) || (hparse_errno_count != 0))
  {
    clf_output_final= "Sorry, we cannot handle this statement if the syntax checker thinks there is a problem.";
    goto ret;
  }
  if ((connections_dbms[0] == DBMS_MARIADB) && ((hparse_dbms_mask & FLAG_VERSION_PLSQL) != 0))
  {
    clf_output_final= "Sorry, we cannot handle procedures when sql_mode is for PL/SQL (e.g. oracle + mariadb) at this time.";
    goto ret;
  }
  if (ocelot_delimiter_str != ";")
  {
    clf_output_final= "Sorry, we cannot handle procedures when the delimiter is something other than ; (semicolon) at this time.";
    goto ret;
  }
  if ((connections_dbms[0] != DBMS_TARANTOOL) && (sql_mode_ansi_quotes == false))
  {
    clf_output_final= "Sorry, we do not handle procedures unless sql_mode = ansi_quotes is set, at this time.";
    goto ret;
  }
  /* Usually starter="sql_execute([[", sql_execute_ender="]]". But we might change to [=[ ... ]=] etc. */
  if (clf_make_sql_execute_starter_and_ender(text, &clf_output_final) == false) goto ret;

  /* CREATE PROCEDURE|FUNCTION name () --> function name () */
  for (clfi= main_token_number;
       /* Todo: check: how reliable is clf_last_token? */
       ((main_token_lengths[clfi] != 0) && (clfi < clf_last_token));
       ++clfi)
  {
    if ((main_token_reftypes[clfi] == TOKEN_REFTYPE_PROCEDURE)
       || (main_token_reftypes[clfi] == TOKEN_REFTYPE_FUNCTION))
    {
      clf_output_main_function= "function ";
      QString routine_name= clf_v(text, clfi, TOKEN_REFTYPE_PROCEDURE);
      clf_output_main_function= clf_output_main_function + routine_name;
      clf_output_main_function= clf_output_main_function + "(";
      break;
    }
  }
  {
    int parentheses_count= 0;
    int parameter_count= 0;
    while ((main_token_lengths[clfi] != 0) && (clfi < clf_last_token))
    {
      QString d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);
      if (d == "(") ++parentheses_count;
      if (d == ")")
      {
        --parentheses_count;
        if (parentheses_count == 0) break;
      }

      if ((main_token_types[clfi] == TOKEN_KEYWORD_INOUT) || (main_token_types[clfi] == TOKEN_KEYWORD_OUT))
      {
        clf_output_final= "Sorry, we do not support OUT or INOUT parameters at this time";
        goto ret;
      }

      if (main_token_reftypes[clfi] == TOKEN_REFTYPE_PARAMETER_DEFINE)
      {
        if (parameter_count > 0) clf_output_main_function= clf_output_main_function + ",";
        clf_output_main_function= clf_output_main_function + clf_v(text, clfi, TOKEN_REFTYPE_PARAMETER_DEFINE);
        ++parameter_count;
      }
      ++clfi;
    }
  }
  clf_output_main_function= clf_output_main_function + ")";
  clf_dump_whitespace(text, &clf_output_main_function);
  ++clfi;

  clf_make_sql_execute_function(&clf_output_main_function);

  /* clf_handler_list() creates handler_begin_of_declares[] etc. so after it you should not say goto ret. */
  if (clf_handler_list(text, main_token_number, clf_last_token, &clf_output_final) == false) goto ret;

  if (clf_block(text, 999999, &clf_output_main_function) == 1) clf_output_final= clf_output_main_function;
  else clf_output_final= clf_output_final + clf_output_main_function;

  if (handler_count > 0)
  {
    delete []handler_begin_of_declares;
    delete []handler_scope_ends;
    delete []handler_code_ends;
    delete []handler_starts;
  }
ret:
  /* Similar to how we display Help meessages. */
  Message_box *message_box;
  /* Don't use width=960 if screen width is smaller, e.g. on a VGA screen. */
#if (QT_VERSION >= 0x50000)
  QScreen *screen= QGuiApplication::primaryScreen();
  int desktop_width= screen->availableGeometry().width();
#else
  QDesktopWidget desktop;
  int desktop_width= desktop.availableGeometry().width();
#endif
  if (desktop_width > (960 + 50)) message_box= new Message_box("Result", clf_output_final, 960, "", er_strings[er_off + ER_OK], "", this);
  else message_box= new Message_box("Result", clf_output_final, desktop_width - 50, "", er_strings[er_off + ER_OK], "", this);
  message_box->exec();
  delete message_box;
  log("clf end", 90);
}

/* Beware recursion -- we aren't doing it yet, but when we do, if (clf_block()==1) then return 1; */
int MainWindow::clf_block(QString text, int i_of_end_of_handler, QString *clf_output)
{
  int token_type; /* warning: there is also a function named token_type() */
  int begin_count= 0;

  for (clfi= clfi;
       ((main_token_lengths[clfi] != 0) && (clfi < clf_last_token));
       ++clfi)
  {
    if (clfi >= i_of_end_of_handler)
    {
      return 0;
    }

    token_type= main_token_types[clfi];
    QString d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);

    /* Dump whatever is between this token and last token, which presumably is whitespace */
    /* Similar calculation is in clfdw() but that is for inside the statement, this is outside */
    /* Todo: maybe call clf_dump_whitespace() instead. */
    if (clfi > 0)
    {
      QString d2= text.mid(main_token_offsets[clfi - 1] + main_token_lengths[clfi - 1],
                    main_token_offsets[clfi] - (main_token_offsets[clfi - 1] + main_token_lengths[clfi - 1]));
      *clf_output= *clf_output + d2;
    }

    /* Todo: don't you want to output the label, at least in a comment? */
    if (main_token_reftypes[clfi] == TOKEN_REFTYPE_LABEL_DEFINE)
    {
      /* Todo: If there are two labels in a row, return error (we could handle them but don't). */
      /*       But this isn't necessary at the moment because our syntax checker won't accept them anyway. */
      clfi= next_token(clfi); /* skip to the ":" */
      continue;
    }

    if (main_token_types[clfi] == TOKEN_TYPE_COMMENT_WITH_SLASH)
    {
      *clf_output= *clf_output + "--[[" + d + "]]";
      continue;
    }

    if (main_token_types[clfi] == TOKEN_TYPE_COMMENT_WITH_MINUS)
    {
      *clf_output= *clf_output + d;
      continue;
    }

    if (main_token_types[clfi] == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
    {
      *clf_output= *clf_output + "--" + d;
      continue;
    }

    /*
      Since it's not a label or comment, we'll presume it's a statement start
      i.e. ((main_token_flags[clfi] & TOKEN_FLAG_IS_START_STATEMENT) == 0)
      or it might be an operator such as ";"
    */

    QString indent_string= clf_indent(clf_output);

    if (token_type == TOKEN_KEYWORD_BEGIN)
    {
      //Beware: BEGIN might be inside DECLARE ... HANDLER
      if (main_token_types[clfi] == TOKEN_KEYWORD_NOT) clfi= next_i(clfi, 2); /* Skip [NOT ATOMIC] */
      ++begin_count;
      *clf_output= *clf_output + "do "; /* alternative = while true do ... break end */
      continue;
    }

    if (token_type == TOKEN_KEYWORD_CASE)
    {
      *clf_output= "Sorry, we do not handle CASE statements at this time.";
      return 1;
    }

    if (token_type == TOKEN_KEYWORD_CLOSE)
    {
      /* Todo: We do not check if it is not open, maybe that is an error */
      clfi= next_i(clfi, 1); /* skip to cursor name */
      if (clf_check_reference(text, clfi, TOKEN_REFTYPE_CURSOR_DEFINE, clf_output) == false) return 1;
      int i_of_cursor_name= main_token_pointers[clfi];
      /* Following lines are similar to initialization done for TOKEN_KEYWORD_DECLARE. */
      QString cursor_name;
      cursor_name= clf_v(text, i_of_cursor_name, TOKEN_REFTYPE_CURSOR_DEFINE);
      *clf_output= *clf_output + "\n" + indent_string + cursor_name + "= {};";
      *clf_output= *clf_output + "\n" + indent_string + cursor_name + "_OFFSET = 0;";
      *clf_output= *clf_output + "\n" + indent_string + cursor_name + "_STATUS = 'not open';";
      /* As long as CLOSE doesn't cause a condition to change, we won't need to call clf_find_handler */
      clf_handler_end(clfi, clf_output);
      continue;
    }

    if (token_type == TOKEN_KEYWORD_DECLARE)
    {
      int i_of_declare= clfi;
      int i2= next_token(clfi); i2= next_token(i2);
      if (main_token_types[i2] == TOKEN_KEYWORD_HANDLER)
      {
        *clf_output= *clf_output + "local function " + clf_handler_name(i_of_declare) + "()";
        clfi= i2;
        /* If next is BEGIN/LOOP/etc. then handler end is past the next END, otherwise it is past next statement */
        /* Skip to statement start (past "FOR conditions") */
        int i3;
        for (i3= clfi;; ++i3) /* todo: error check! */
        {
          if ((main_token_flags[i3] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
          {
            clfi= i3 - 1;
            break;
          }
        }
        /* So for example, we're looking at FOUND. By continuing, we should be getting handler statement #1. */
        continue;
      }

      if (main_token_types[i2] == TOKEN_KEYWORD_CURSOR)
      {
        int i_of_cursor_name= next_i(i2, -1);
        QString cursor_name= clf_v(text, i_of_cursor_name, TOKEN_REFTYPE_CURSOR_DEFINE);
        *clf_output= *clf_output +               + "local " + cursor_name + " = {};\n";
        *clf_output= *clf_output + indent_string + "local " + cursor_name + "_OFFSET = 0;\n";
        *clf_output= *clf_output + indent_string + "local " + cursor_name + "_STATUS = 'not open';\n";
        continue;
      }
      if (main_token_types[next_i(i2, 1)] == TOKEN_KEYWORD_CONDITION)
      {
        *clf_output= "Sorry, DECLARE ... CONDITION is not supported at this time.\n";
        return 1;
      }
      /* It's not DECLARE ... CONDITION|CURSOR|HANDLER. So it must be DECLARE ... variable. */
      while ((main_token_lengths[clfi] != 0) && (clfi < clf_last_token))
      {
        QString d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);
        if (main_token_reftypes[clfi] == TOKEN_REFTYPE_VARIABLE_DEFINE)
        {
          QString variable_name= clf_v(text, clfi, TOKEN_REFTYPE_VARIABLE_DEFINE);
          *clf_output= *clf_output + "local ";
          *clf_output= *clf_output + variable_name;
          /* Look for DEFAULT clause. It might apply for multiple locals, e.g. DECLARE x,y,z INT DEFAULT 5; */
          int saved_clfi= clfi;
          while ((main_token_lengths[clfi] != 0) && (clfi < clf_last_token))
          {
            QString d2= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);
            if (d2 == ";") break;
            if (main_token_types[clfi] == TOKEN_KEYWORD_DEFAULT)
            {
              /* This looks much like SET. Whats between DEFAULT and ; is the expression to assign to variable. */
              clfi= next_i(clfi, 1);
              *clf_output= *clf_output + "; " + sql_execute_starter + "SELECT ";
              if (clfds(text, TOKEN_KEYWORD_DEFAULT, indent_string, "", clf_output) == false) return false;
              *clf_output= *clf_output + "; " + variable_name + " = sqlresult[1][1]";
              break;
            }
            ++clfi;
          }
          clfi= saved_clfi;

          *clf_output= *clf_output + ";";
        }
        if (d == ";") { break; }
        ++clfi;
      }
      clf_handler_end(clfi, clf_output); /* DECLARE statement ends handler? Foolish but possible. */
      continue;
    }

    if (token_type == TOKEN_KEYWORD_ELSE)
    {
      *clf_output= *clf_output + "else ";
      continue;
    }

    if (token_type == TOKEN_KEYWORD_ELSEIF)
    {
      *clf_output= "Sorry, we do not handle ELSEIF clauses at this time.";
      return 1;
    }

    if (token_type == TOKEN_KEYWORD_END)
    {
      QString label_1= clf_label(text, "_1");
      QString label_2= clf_label(text, "_2");
      *clf_output= *clf_output + label_1;
      /* Todo: END CASE? Not necessary as long as we don't support CASE */
      int i_of_start_of_statement= clfi;
      int i_of_begin= main_token_pointers[clfi]; /* to BEGIN or to label preceding BEGIN */
      clfi= next_token(clfi);
      int n= main_token_types[clfi];

      if (n == TOKEN_KEYWORD_IF)
      {
        *clf_output= *clf_output + "end;";
      }
      else if (n == TOKEN_KEYWORD_LOOP)
      {
        *clf_output= *clf_output + "end;";
      }
      else if (n == TOKEN_KEYWORD_REPEAT)
      {
        *clf_output= *clf_output + "end;";
      }
      else if (n == TOKEN_KEYWORD_WHILE)
      {
        *clf_output= *clf_output + "end;";
      }
      else /* Nothing after? Must be END of BEGIN ... END */
      {
        *clf_output= *clf_output + "end;";
        /* We add a label = "::end_n:"" so if there is an EXIT handler it knows where to goto */
        /* Even if there's no EXIT handler we might jump out of a BEGIN/END. Also you can LEAVE a BEGIN but it has a different label. */
        *clf_output= *clf_output + " ::end_" + QString::number(i_of_begin) + ":: ";
        --begin_count;
      }
//      clf_dump_whitespace(text, clf_output); /* This dumps as far as ";" but could get mixed up if delimiter wasn't ";". */
//      clfi= next_i(clfi, 1);
      *clf_output= *clf_output + label_2;

//      if (begin_count != 0)

      {
        if (clf_find_handler(text, clf_output, indent_string, i_of_start_of_statement + 1, token_type) == false) return false;
        clf_handler_end(clfi, clf_output);
      }
      continue;
    }

    if (token_type == TOKEN_KEYWORD_FETCH)
    {
      /* Todo: check if too many or too few columns */
      /* Todo: There is probably some resemblance to what we do with SET, see if you can merge code. */
      int i_of_start_of_statement= clfi;
      clfi= next_i(clfi, 1); /* skip to cursor name */
      if (clf_check_reference(text, clfi, TOKEN_REFTYPE_CURSOR_DEFINE, clf_output) == false) return 1;
      int i_of_cursor_name= main_token_pointers[clfi];
      QString cursor_name;
      cursor_name= clf_v(text, i_of_cursor_name, TOKEN_REFTYPE_CURSOR_DEFINE);
      /* If the cursor is not open, that's an error */
      *clf_output= *clf_output + "if " + cursor_name + "_STATUS ~= 'open' then sqlstate = '07000';";
      *clf_output= *clf_output + "\n" + indent_string + "else if " + cursor_name + "_OFFSET >= #" + cursor_name + " then sqlstate = '02000';";
      *clf_output= *clf_output + "\n" + indent_string + "else do";
      *clf_output= *clf_output + "\n" + indent_string + "   " + cursor_name + "_OFFSET = " + cursor_name + "_OFFSET + 1;";
      /* Some of the following lines are similar to initialization done for TOKEN_KEYWORD_DECLARE. */
      int column_number= 1;
      for (clfi= clfi + 1;; ++clfi)
      {
        if (main_token_types[clfi] == TOKEN_TYPE_OPERATOR) break; /* ";" ends FETCH, perhaps there is no INTO */
        if (main_token_types[clfi] == TOKEN_TYPE_IDENTIFIER)
        {
          if (clf_check_reference(text, clfi, TOKEN_REFTYPE_VARIABLE_DEFINE, clf_output) == false) return 1;
          QString variable_name= clf_v(text, main_token_pointers[clfi], TOKEN_REFTYPE_VARIABLE_DEFINE);
          *clf_output= *clf_output + "\n" + indent_string + "    " + variable_name + " = " + cursor_name;
          *clf_output= *clf_output + "[";
          *clf_output= *clf_output + cursor_name + "_OFFSET][";
          *clf_output= *clf_output + QString::number(column_number);
          *clf_output= *clf_output + "];";
          ++column_number;
        }
      }
      *clf_output= *clf_output + "\n" + indent_string + "end; end; end;";
      if (clf_find_handler(text, clf_output, indent_string, i_of_start_of_statement, TOKEN_KEYWORD_FETCH) == false) return false;
      clf_handler_end(clfi, clf_output);
      continue;
    }

    if (token_type == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT)
    {
      *clf_output= "Sorry, we do not handle FOR statements at this time.";
      return 1;
    }

    if (token_type == TOKEN_KEYWORD_GET)
    {
      //I doubt that we can support GET DIAGNOSTICS
      /* Todo: If GET DIAGNOSTICS into an error message of a certain type, we might support it in Tarantool */
      /* Todo: error check: assignment to declared variable (though we should try to support it someday) */
      *clf_output= "Sorry, we do not handle GET statements at this time.";
      return 1;
    }

    if (token_type == TOKEN_KEYWORD_IF)
    {
    }

    if (token_type == TOKEN_KEYWORD_ITERATE)
    {
      *clf_output= *clf_output + "goto ";
      clfi= next_token(clfi);
      /* Todo: Check if label was defined. main_token_pointers[clfi] isn't pointing to it. */
      QString d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]).toUpper();
      *clf_output= *clf_output + d + "_1;";
      /* no need to call clf_find_handler() */
      clf_handler_end(clfi, clf_output);
      continue;
    }

    if (token_type == TOKEN_KEYWORD_LEAVE) /* See comment = Re labels */
    {
      *clf_output= *clf_output + "goto ";
      clfi= next_token(clfi);
      /* Todo: Check if label was defined. main_token_pointers[clfi] isn't pointing to it. */
      QString d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]).toUpper();
      *clf_output= *clf_output + d + "_2;";
      /* no need to call clf_find_handler() */
      clf_handler_end(clfi, clf_output);
      continue;
    }

    if (token_type == TOKEN_KEYWORD_LOOP)
    {
      *clf_output= *clf_output + "while true do ";
      continue;
    }

    if (token_type == TOKEN_KEYWORD_OPEN)
    {
     /* Todo: check if it is already open, maybe that is an error */
      clfi= next_i(clfi, 1); /* skip to cursor name */
      if (clf_check_reference(text, clfi, TOKEN_REFTYPE_CURSOR_DEFINE, clf_output) == false) return 1;
      int i_of_cursor_name= main_token_pointers[clfi];

      assert(main_token_reftypes[i_of_cursor_name] == TOKEN_REFTYPE_CURSOR_DEFINE);

      QString cursor_name = clf_v(text, i_of_cursor_name, TOKEN_REFTYPE_CURSOR_DEFINE);

      int saved_clfi= clfi;

      for (clfi= i_of_cursor_name;; ++clfi) /* skip past "CURSOR FOR", skipping comments */
      {
        clf_dump_whitespace(text, clf_output);
        if (main_token_types[clfi] == TOKEN_KEYWORD_FOR) break;
      }
      clfi= next_i(clfi, 1);

      *clf_output= *clf_output + cursor_name + " = ";

      QString indent_string_for_open= clf_indent(clf_output);
      *clf_output= *clf_output + sql_execute_starter;
      *clf_output= *clf_output + "\n" + indent_string_for_open;
      if (clfds(text, TOKEN_KEYWORD_OPEN, indent_string_for_open, "", clf_output) == false) return false;
      clfi= saved_clfi;

      *clf_output= *clf_output + "\n" + indent_string_for_open + "if string.sub(sqlstate,1,2) == '00' or string.sub(sqlstate,1,2) == '02' then";
      *clf_output= *clf_output + "\n" + indent_string + cursor_name + "_OFFSET = 0;";
      *clf_output= *clf_output + "\n" + indent_string + cursor_name + "_STATUS = 'open';";
      *clf_output= *clf_output + "\n" + indent_string + "end;\n";
      /* todo: clf_dump_whitespace? */
      clfi= next_i(clfi, 1); /* skip to ";" */
      /* clfds should have called clf_find_handler already */
      clf_handler_end(clfi, clf_output);
      continue;
    }

    if (token_type == TOKEN_KEYWORD_REPEAT)
    {
      *clf_output= *clf_output + "repeat ";
      continue;
    }

    if (token_type == TOKEN_KEYWORD_RESIGNAL)
    {
      *clf_output= "Sorry, we do not support RESIGNAL statements at this time.";
      return 1;
    }

    if (token_type == TOKEN_KEYWORD_RETURN)
    {
      clf_parameter_list= ""; /* todo: see whether this is necessary */
      if (clf_internal_select(TOKEN_KEYWORD_RETURN, text, clf_output) == false) return false;
      *clf_output= *clf_output + " return sqlresult[1][1];";
      continue;
    }

    if (token_type == TOKEN_KEYWORD_SELECT)
    {
      /* Todo: Maybe SELECT should display, currently it just finds the result set and then ignores it */
      /* SELECT INTO declared-variable won't work. Todo: We should support it the same way we do FETCH. */
      bool into_seen= false;
      for (int i= clfi; i < clf_last_token; ++i)
      {
        QString d= text.mid(main_token_offsets[i], main_token_lengths[i]);
        if (d == ";") break;
        if (main_token_types[i] == TOKEN_KEYWORD_INTO) { into_seen= true; continue; }
        if (into_seen == true)
        {
          /* If it's the end of the INTO clause, we've found no problems. */
          if (((main_token_flags[clfi] & TOKEN_FLAG_IS_START_CLAUSE) != 0)
           || (main_token_types[i] == TOKEN_KEYWORD_FROM))
            break;
          /* If it's a declared variable, i.e. not @variable (which should be TOKEN_REFTYPE_USER_VARIABLE), problem. */
          if ((main_token_reftypes[i] == TOKEN_REFTYPE_VARIABLE_REFER)
           || (main_token_reftypes[i] == TOKEN_REFTYPE_PARAMETER_REFER))
          {
            *clf_output= "Sorry, SELECT INTO declared-variable is not supported at this time.";
            return 1;
          }
        }
      }
    }

    if (token_type == TOKEN_KEYWORD_SET)
    {
      if (clf_set(text, indent_string, clf_output) == false) return 1;
      /* TODO: I wonder how many other statements hae 'continue' without calling clf_handler_end. */
      /* clfds should have called clf_find_handler already */
      clf_handler_end(clfi, clf_output);
      continue;
    }

    if (token_type == TOKEN_KEYWORD_SIGNAL)
    {
      int i_of_start_of_statement= clfi;
      clfi= next_i(clfi, 2);
      QString d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);
      clfi= next_i(clfi, 1);
      QString d2= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);
      if (d2 != ";")
      {
        *clf_output= "Sorry, the only SIGNAL statement that we support at this time is SIGNAL SQLSTATE sqlstate_value.";
        return 1;
      }
      *clf_output= *clf_output + "sqlstate = " + d + ";";
      if (clf_find_handler(text, clf_output, indent_string, i_of_start_of_statement, token_type) == false) return false;
      clf_handler_end(clfi, clf_output);
      continue;
    }

    if (token_type == TOKEN_KEYWORD_UNTIL)
    {
    }

    if (token_type == TOKEN_KEYWORD_UPDATE)
    {
      /* We don't allow assigning to declared variables in UPDATE. Todo: get inspired by how we do SET. */
      for (int i= clfi; i < clf_last_token; ++i)
      {
        if ((main_token_types[i] == TOKEN_KEYWORD_WHERE)
         || (main_token_types[i] == TOKEN_KEYWORD_ORDER)
         || (main_token_types[i] == TOKEN_KEYWORD_LIMIT))
          break;
        QString d= text.mid(main_token_offsets[i], main_token_lengths[i]);
        if (d == ";") break;
        int i2= next_i(i, -1);
        d= text.mid(main_token_offsets[i2], main_token_lengths[i2]);
        if ((main_token_types[i2] == TOKEN_KEYWORD_SET)
         || (d == ","))
        {
          if ((main_token_reftypes[i] == TOKEN_REFTYPE_PARAMETER_REFER)
           || (main_token_reftypes[i] == TOKEN_REFTYPE_VARIABLE_REFER))
          {
            int i3= next_i(i, +1);
            d= text.mid(main_token_offsets[i3], main_token_lengths[i3]);
            if (d == "=")
            {
              *clf_output= "Sorry, we do not handle assignments to variables in UPDATE statements at this time.";
              return 1;
              }
          }
        }
      }
    }

    if (token_type == TOKEN_KEYWORD_WHILE)
    {
    }

    /* todo: probably this "if" is unnecessary now, we want to check earlier */
    if ((main_token_flags[clfi] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
    {
      /*
        Usually our result is box.execute([=[statement]=]); but special things can happen, e.g.
        if it's RETURN we want sql_execute(); return sqlresult[1][1];
      */
      clf_parameter_list= ""; /* Todo: probably this is the wrong place to initialize */
      if (token_type == TOKEN_KEYWORD_IF) *clf_output= *clf_output + "if ";
      if (token_type == TOKEN_KEYWORD_UNTIL) *clf_output= *clf_output + "until ";
      if (token_type == TOKEN_KEYWORD_WHILE) *clf_output= *clf_output + "while ";
      if ((token_type == TOKEN_KEYWORD_IF)
       || (token_type == TOKEN_KEYWORD_UNTIL)
       || (token_type == TOKEN_KEYWORD_WHILE))
      {
        if (clf_internal_select(token_type, text, clf_output) == false) return false;
      }
      else
      {
        *clf_output= *clf_output + sql_execute_starter;
        *clf_output= *clf_output + "\n" + indent_string;
        if (clfds(text, token_type, indent_string, "", clf_output) == false) return false;
      }
      clf_handler_end(clfi, clf_output); /*Sometimes this useless because we're not at end of a statement. */
    }
  }

  /* Todo: make sure this is indented the same as the CREATE statement. */
  *clf_output= *clf_output + "\nend;";
  return 0;
}

/*
  An internal select is a query that we construct in order to get sql_execute to return one row with one value.
  We want it for conditions, e.g. WHILE 0 = 0 should cause sql_execute([[SELECT 0 = 0;]],{});
  Also we want it for statements that assign to declared variables. At first, that means SET statements.
  Usually our indenting is where the SQL statement begins, but in this case it's where the condition begins.
  Todo: use VALUES rather than SELECT?
  Todo: don't pass ; unless you're really sure there is no ; i.e. it is a WHILE/IF conditional, not SET or RETURN or UNTIL 
*/
bool MainWindow::clf_internal_select(int token_type, QString text, QString *clf_output)
{
  QString indent_string= clf_indent(clf_output);
  *clf_output= *clf_output + sql_execute_starter;
  *clf_output= *clf_output + "\n" + indent_string;
  *clf_output= *clf_output + "SELECT "; clfi= next_token(clfi);
  if (clfds(text, token_type, indent_string, ";", clf_output) == false) return false;
  return true;
}

/*
  Pass: i = token number of a reference to a variable, parameter, or cursor.
  Return: 0 = ok, 1 = bad and *clf_output has an error description
  Usually this probably means that the user typed in a nonexistent name.
  If we had parsed perfectly earlier, this check would not be necessary.
  Todo: No error if name begins with @ (MySQL/MariaDB)
  Todo: Check if offset too great. If so, status = 'not found' and clf_find_handler() (I forget what this means)
*/
bool MainWindow::clf_check_reference(QString text, int i, int reftype, QString *clf_output)
{
  bool is_ok= true;
  int j= main_token_pointers[i];
  if ((j == 0) || (j > clf_last_token)) is_ok= false; /* actually j > clf_last_token could be an assert */
  else if (reftype == TOKEN_REFTYPE_VARIABLE_DEFINE)
  {
    if ((main_token_reftypes[j] != reftype) && (main_token_reftypes[j] != TOKEN_REFTYPE_PARAMETER_DEFINE))
      is_ok= false;
  }
  else if (main_token_reftypes[j] != reftype) is_ok= false;
  if (is_ok == false)
  {
    QString d= text.mid(main_token_offsets[i], main_token_lengths[i]);
    QString type_name;
    if (reftype == TOKEN_REFTYPE_VARIABLE_DEFINE) type_name= " variable-or-parameter ";
    else if (reftype == TOKEN_REFTYPE_CURSOR_DEFINE) type_name= " cursor ";
    else type_name= "";
    *clf_output= "Sorry, cannot find the declaration of" + type_name + d;
  }
  return is_ok;
}

/* Todo: parameter #1 doesn't seem to be of statement, it should be of ;, so consider changing the name. */
void MainWindow::clf_handler_end(int i_of_statement, QString *clf_output)
{
  for (int i= 0; i < handler_count; ++i)
  {
    if (i_of_statement == handler_code_ends[i]) *clf_output= *clf_output + " end;";
  }
}

/*
  Dump statements
  Sometimes there are tokens that we must stop at:
    ";" always (todo: actually it should be delimiter)
    "DO" if it is WHILE ... DO (Todo: check: can DO ever appear in an expression?)
    "END" if it is UNTIL ... END (Todo: check: can END ever appear in an expression, other than CASE where it is ok?)
    "THEN" if it is IF ... THEN (THEN can appear in a CASE expression, that's why we have cases_count)
    "," if it is SET variable=expression , variable_expression
  The start of the statement has already been dumped.
*/
bool MainWindow::clfds(QString text, int token_type, QString indent_string, QString terminator, QString *clf_output)
{
  int parentheses_count= 0;
  int cases_count= 0;
  int i_of_start_of_statement= clfi;
  QString d;
  clf_parameter_list= "";
  /* Todo: you need to stop at last_token */
  while ((main_token_lengths[clfi] != 0) && (clfi < clf_last_token))
  {
    d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]).toUpper();
    if (d == "(") ++parentheses_count;
    if (d == ")") --parentheses_count;
    if (main_token_types[clfi] == TOKEN_KEYWORD_CASE_IN_CASE_EXPRESSION) ++cases_count;
    if (main_token_types[clfi] == TOKEN_KEYWORD_END_IN_CASE_EXPRESSION) --cases_count;
    int current_token_type= main_token_types[clfi];
    if ((parentheses_count == 0) && (cases_count == 0))
    {
      if ((token_type == TOKEN_KEYWORD_SET) && (d == ",")) break;
      if ((token_type == TOKEN_KEYWORD_WHILE) && (current_token_type == TOKEN_KEYWORD_DO)) break;
      if ((token_type == TOKEN_KEYWORD_IF) && (current_token_type == TOKEN_KEYWORD_THEN)) break;
      if (current_token_type == TOKEN_KEYWORD_END) { --clfi; break; }
    }
    if (d == ";") { *clf_output= *clf_output + d; break; }
    if (clfdw(text, clf_output) == false) return false;
    //if (text.mid(main_token_offsets[clfi], main_token_lengths[clfi]) == ";") break;
    ++clfi;
  }

  /* Todo: I still worry that we might get two ;;s at the end of the statement, write a test that ignores spaces. */
  if (terminator == ";")
  {
    if ((clf_output)->right(1) != ";")
      *clf_output= *clf_output + terminator; /* statement terminator is either "" or ";" */
  }

  *clf_output= *clf_output + "\n" + indent_string + sql_execute_ender;
  *clf_output= *clf_output + ",{" + clf_parameter_list + "}";
  clf_parameter_list= "";

  if (token_type == TOKEN_KEYWORD_RETURN) { *clf_output= *clf_output + ");"; return true; }
  if (token_type == TOKEN_KEYWORD_DEFAULT) { *clf_output= *clf_output + ")"; return true; }
  if (token_type == TOKEN_KEYWORD_IF) { *clf_output= *clf_output + ") == true and sqlresult[1][1] == true then "; return true; }
  if (token_type == TOKEN_KEYWORD_WHILE) { *clf_output= *clf_output + ") == true and sqlresult[1][1] == true do "; return true; }
  if (token_type == TOKEN_KEYWORD_SET) *clf_output= *clf_output + ")";
  else if (token_type == TOKEN_KEYWORD_UNTIL) *clf_output= *clf_output + ") == true and sqlresult[1][1] == true ";
  else *clf_output= *clf_output + ");";
  if (clf_find_handler(text, clf_output, indent_string, i_of_start_of_statement, token_type) == false) return false;
  return true;
}

/*
  Dump words
  What I'm really after is:
    For each until endword (we pass endwod = ";" or "DO" or "" ("" means we only do it once)
      Check: is this a variable name? If so, figure out the Lua equivalent.
      Dump
      Dump whatever is between this token and the next token
  Re variable-name:
    We depend on earlier success of hparse_f_variables().
    Lua variable name should be prefix + sql_variable_name (upper?) + token number
  Todo: call this from more places
*/
bool MainWindow::clfdw(QString text, QString *clf_output)
{
  QString d;

  d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);
  if ((main_token_reftypes[clfi] == TOKEN_REFTYPE_PARAMETER_REFER)
   || (main_token_reftypes[clfi] == TOKEN_REFTYPE_VARIABLE_REFER))
  {
    if (clf_check_reference(text, clfi, TOKEN_REFTYPE_VARIABLE_DEFINE, clf_output) == false) return false;
    int j= main_token_pointers[clfi];
    if ((main_token_reftypes[j] == TOKEN_REFTYPE_PARAMETER_DEFINE)
     || (main_token_reftypes[j] == TOKEN_REFTYPE_VARIABLE_DEFINE))
    {
      ;
    }

    /* Add ? to what we pass in box_execute(string...), add variable name to box.execute parameters */
    *clf_output= *clf_output + "?";
    if (clf_parameter_list != "") clf_parameter_list= clf_parameter_list + ", ";
    clf_parameter_list= clf_parameter_list + clf_v(text, main_token_pointers[clfi], TOKEN_REFTYPE_VARIABLE_DEFINE);

  }
  else *clf_output= *clf_output + d;

  clf_dump_whitespace(text, clf_output);
  return true;
}

/*
  Dump whatever is between this word and the next word, unless there is no next word.
  This is whitespace, it isn't important, but we try to preserve it if there are multiple spaces or line feeds.
*/
void MainWindow::clf_dump_whitespace(QString text, QString *clf_output)
{
  if (main_token_lengths[clfi + 1] == 0) return;
  if ((clfi + 1) >= clf_last_token) return;
  QString d= text.mid(main_token_offsets[clfi] + main_token_lengths[clfi],
              main_token_offsets[clfi + 1] - (main_token_offsets[clfi] + main_token_lengths[clfi]));
  *clf_output= *clf_output + d;
}

/*
  Labels
    If the BEGIN|LOOP|REPEAT|WHILE was preceded by "label:", return a Lua label "::LABEL_1::" or "::LABEL_2::".
    We call this when we see END, twice.
    The first time, suffix == "_1", this is for the label that comes before "end".
    The second time, suffix == "_2", this is for the label that comes after "end".
    For ITERATE label; we generate goto LABEL_1", to do the loop again.
    For LEAVE label; we generate "goto LABEL_2", to get out of a loop.
    We depend on main_token_pointers[] which should have been set up during parsing.
    Todo: There might be more than one e.g. user said label1: label2: BEGIN END -- so loop
    Another label type is "end_" + token-number + "::", which is formed for handlers and does not call here.
    The goto statements cause a reference to a label too.
*/
QString MainWindow::clf_label(QString text, QString suffix)
{
  int i= main_token_pointers[clfi];
  if (i == 0) return ""; /* actually this must be soms sort of error */
  if (main_token_reftypes[i] != TOKEN_REFTYPE_LABEL_DEFINE) return ""; /* there are no labels */
  return "::"
          + text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper()
          + suffix
          + "::";
}

/*
  SET
  SET i = sql-expression [, j= sql_expression ...];
  must become
  S_i... = sql_execute([=[sql-expression]].row[1][1];
  S_j... = sql_execute([=[sql-expression]].row[1][1];
  It's complex because expression can contain specials e.g. SET i=(j=5), j= substr(k,1,1);
  Notice we do assignments sequentially.
  This is the only place where we can assign to a variable -- SELECT INTO is unknown.
  Todo: small bug: If it is SET i=1, j = 1; we fail to put out ";" at the end of the first SELECT
  Todo: Sometimes the expression is a literal that Lua can read, e.g. SET i = 1;
        In that case maybe we could say "I=1;" instead of "i=sql_execute([=[SELECT 1;]]" etc.
  Todo: This is not allowing for the chance that sql_execute might fail.
        It would be better to say: if sql_execute() then assign end
*/
bool MainWindow::clf_set(QString text, QString indent_string, QString *clf_output)
{
  QString d;
  QString variable_name;
  for (;;)
  {
    clfi= next_token(clfi); /* skip "SET" or "," */
    /* Surely this is a variable that we are assigning to. */
    if (clf_check_reference(text, clfi, TOKEN_REFTYPE_VARIABLE_DEFINE, clf_output) == false) return false;
    variable_name = clf_v(text, main_token_pointers[clfi], TOKEN_REFTYPE_VARIABLE_DEFINE);
    clfi= next_token(clfi); /* skip variable name */
    if (clf_internal_select(TOKEN_KEYWORD_SET, text, clf_output) == false) return false;
    *clf_output= *clf_output + variable_name + " = sqlresult[1][1];";
    /* repeat if it was ',' */
    d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);
    if (d != ",") break;
    *clf_output= *clf_output + "\n" + indent_string;
  }
  return true;
}

/*
  Find out where we are in a line, so we know how many spaces to indent.
  The general aim is: keep the original indent.
  For example we should call this before sql_execute([=[\n, and use it so that the lines are
    sql_execute([=[
    sql-statement
    ]=])
  So another way to put it is: try to indent to wherever sql_execut([=[\n is.
  We should use the indent for all decoration/wrapping, such as "if sqlstate ... handler()".
  Figure out indent at start.
  Whenever you are adding your own decoration/wrapping, \n wrapping \n
  Whenever you are removing (as you do for OPEN/FETCH/CLOSE), keep original text, but in comments. + DECLARE?
  Usually we want the same indenting as in the original i.e. text, but see clf_internal_select().
*/
QString MainWindow::clf_indent(QString *clf_output)
{
  int j= (*clf_output).length();
  int i= j;
  const QChar *ti = (*clf_output).constData();
  for (; i > 0; --i)
  {
    if (*(ti + i) == '\n') break;
  }
  int indent_amount= (j - i) - 1;
  QString indent_string= " ";
  return indent_string.repeated(indent_amount);
}

/*
  After every SQL statement, we check: is there a handler?
  If BEGIN ... BEGIN ... DECLARE ... END statement, the DECLARE is not relevant, skip it.
  There might be multiple handlers that are relevant: exception, not found, specific SQLSTATE, specific number.
  By going backwards, we find the last handler first, which is fine, it's more immediate than handlers above it.
  There are two passes: sqlexception first, then not found. Todo: eventually there will be multiple passes.
  Todo: this can work after a full SQL statement, but not after a snippet as used in WHILE, SET, etc.
  Todo: we're not checking for NOT FOUND if it's TOKEN_KEYWORD_OPEN. Good, but what about other exclusions?
  Put this note somewhere:
    If we have
      BEGIN
        DECLARE HANDLER#1 ...
        non-handler stuff
        BEGIN
          DECLARE HANDLER#2 ...
          non-handler stuff
        END  -- END#1
      END    -- END#2
    The scope of HANDLER#1 is all the way to END#2. But I guess HANDLER#2 won't invoke HANDLER#1.
    Todo: If we have SQLEXCEPTION, SQLWARNING in a higher begin, SQLWARNING in a lower begin won't appear. Okay?
    Todo: allow handler within handler
    Todo: some of the checks here are maybe redundant since we check when making the list (clf_handler_list)
    Todo: Maybe you ought to store the conditions in a list when you make with clf_handler_list()
    Pass 1: specifics, pass 2: sqlexception, pass 3: not found, pass 4: sqlwarning. Avoiding repetition.
    After we dump the handlers, and even if there are no handlers, we still have "if sqlexception goto exit;"
    Yet another exceptional situation:
         If we're within a handler and it's a non-compound statement, we don't want the final
         "if sqlstate... goto" because that would try to jump out of the main begin/end.
         But if it's a compound statement, we do want to jump out because that will goto the end of
         the BEGIN that is inside the handler. That is: DECLARE HANDLER FOR non-compound = no goto,
         DECLARE HANDLER for BEGIN ... END -- goto.
*/
bool MainWindow::clf_find_handler(QString text, QString *clf_output, QString indent_string, int i_of_start_of_statement, int token_type)
{
  QString if_statements= ""; /* A string containing if_statements that we will add to clf_output at the end */
  QString goto_string= "";

  int i_of_begin= clf_find_begin(i_of_start_of_statement); /* = the BEGIN of the current block, if any */

  /* Check that it's not in any handler. We don't call handlers from handlers. Todo: allow, it should be legal. */
  for (int i= 0; i < handler_count; ++i)
  {
    if ((i_of_start_of_statement > handler_starts[i]) && (i_of_start_of_statement <= handler_code_ends[i]))
    {
      if ((i_of_begin != -1) && (i_of_begin >= handler_starts[i])) goto after_handler_calls;
      return true;
    }
  }

  /*
    We'll want to produce "if condition then goto after-end-of-block end" if
    we've just called an EXIT handler, or after we've called all handlers
    (in which case the condition is sqlexception).
    Since BEGIN...END causes a Lua do...end, the goto is unnecessary for the last statement in the block.
    Notice: we goto to get out of the block of the handled statement, not the handler statement
    (sometimes we invoke a handler that is in a higher level, rather than in our own block).
    Todo: reconsider: we wouldn't have to do this if BEGIN...END produced "while true...end", then we'd just dump "break".
  */
  if (i_of_begin != -1)
  {
    int i= i_of_start_of_statement + 1;
    for (;;++i)
    {
      if (i >= clf_last_token) break;
      if ((main_token_types[i] == TOKEN_KEYWORD_END) && (main_token_types[next_i(i, 1)] == TOKEN_TYPE_OPERATOR)) break;
      if ((main_token_flags[i] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
      {
        goto_string= " goto end_" + QString::number(i_of_begin) + ";";
        break;
      }
    }
  }

  for (int pass= 1; pass <= 4; ++pass)
  {
    for (int i= handler_count - 1; i >= 0; --i)
    {
      if (i_of_start_of_statement >= handler_code_ends[i] && (i_of_start_of_statement < handler_scope_ends[i]))
      {
        QString action_after_call= "";
        int j;
        /* In DECLARE ... HANDLER FOR we only care if we see EXIT. Skip to the FOR. */
        for (j= handler_starts[i];; ++j)
        {
          if (main_token_types[j] == TOKEN_KEYWORD_EXIT) action_after_call= goto_string;
          if (main_token_types[j] == TOKEN_KEYWORD_FOR) break;
        }
        bool is_right_pass= false;
        QString status_to_check= "";
        for (j= j + 1;; ++j)
        {
          if (main_token_types[j] == TOKEN_KEYWORD_SQLSTATE)
          {
            j= next_i(j, 1);
            if (main_token_types[j] == TOKEN_KEYWORD_VALUE) j= next_i(j, 1);
            assert(main_token_reftypes[j]== TOKEN_REFTYPE_SQLSTATE);
            QString d= text.mid(main_token_offsets[j], main_token_lengths[j]);
            if (if_statements.contains(d) == false)                                   /* not if duplicate */
            {
              if (status_to_check != "") status_to_check= status_to_check + " or ";   /* if more than one condition */
              status_to_check= status_to_check + "sqlstate == " + d;                  /* e.g. == '45000' */
              if (pass == 1) is_right_pass= true;
            }
          }
          else if (main_token_types[j] == TOKEN_KEYWORD_SQLEXCEPTION)
          {
            if (if_statements.contains("> '02'")== false)
            {
              if (status_to_check != "") status_to_check= status_to_check + " or ";
              status_to_check= status_to_check + "string.sub(sqlstate,1,2) > '02'";
              if (pass == 2) is_right_pass= true;
            }
          }
          else if (main_token_types[j] == TOKEN_KEYWORD_NOT)
          {
            j= next_i(j, 1);
            assert(main_token_types[j] == TOKEN_KEYWORD_FOUND);
            if (token_type == TOKEN_KEYWORD_OPEN) continue;
            if (if_statements.contains("== '02'")== false)
            {
              if (status_to_check != "") status_to_check= status_to_check + " or ";
              status_to_check= status_to_check + "string.sub(sqlstate,1,2) == '02'";
              if (pass == 3) is_right_pass= true;
            }
          }
          else if (main_token_types[j] == TOKEN_KEYWORD_SQLWARNING)
          {
           if (if_statements.contains("== '01'")== false)
           {
              if (status_to_check != "") status_to_check= status_to_check + " or ";
              status_to_check= status_to_check + "string.sub(sqlstate,1,2) == '01'";
              if (pass == 4) is_right_pass= true;
           }
          }
          else if (((main_token_flags[j] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
                || (main_token_types[j] >= TOKEN_KEYWORDS_START))
          {
            break; /* presumably at start of handler code */
          }
          // It might be "," or comment or label, that's fine, we skip
          // What if it is a number? I guess if it's numeric we compare with a number (no, might start with 00/01/02?) */
        }
        if (is_right_pass == false) continue;
        if_statements= if_statements + "\n" + indent_string +
                                       "if " + status_to_check + " then " + clf_handler_name(handler_starts[i]) +
                                       "();" +
                                       action_after_call +
                                       " end;";
      }
    }
  }
  *clf_output= *clf_output + if_statements;

after_handler_calls:
  if (goto_string > "")
    *clf_output= *clf_output + "\n" + indent_string +
                             "if string.sub(sqlstate,1,2) > '02' then " +
                             goto_string +
                             " end;";
  return true;
}

/*
  Pass: token number. Return: token_number of nearest earlier BEGIN for BEGIN/END enclosing this token.
  If there is an intervening BEGIN/END or flow-control/END, we can skip over it via main_token_pointers[]
  (this might skip back to the label of the BEGIN rather than to the BEGIN itself, but I think that is okay).
  If we fail to find a BEGIN, we return -1 (probably this means we have
      "CREATE PROCEDURE|FUNCTION ... non-compound-statement;" and we have backed up to the word CREATE).
  If we are at the second END in BEGIN BEGIN END END, we will end up pointing to the first BEGIN.
  If we go all the way back to main_token_number, we will end up returning -1 (presumably we were already at top level)
      (although maybe this never happens)
  Todo: it might be nice to have a standard way to find BEGIN that isn't as tedious as searching through main_token.
  Todo: surely we need to find BEGIN in other contexts, so look for duplications of this.
        You might find cases where we skip ENDs in a different way, without using main_token_pointers[].
        You might find cases where we go forward till END, and then use main_token_pointer[] once to go to BEGIN.
*/
int MainWindow::clf_find_begin(int i_of_token)
{
  int k= i_of_token;
  int minimum_token_number= (int) main_token_number;
  if (main_token_types[k] == TOKEN_KEYWORD_END) k= main_token_pointers[k];
  for (;; --k)
  {
    assert(k >= minimum_token_number);
    if (k == minimum_token_number) return -1; /* failed to find a BEGIN */
    if (main_token_types[k] == TOKEN_KEYWORD_BEGIN) break;
    if (main_token_types[k] == TOKEN_KEYWORD_END) k= main_token_pointers[k];
  }
  return k;
}

/*
  Make a list of handlers:
    handler_count, handler_starts[], handler_code_ends[], handler_scope_ends[] handler_begin_of_declares[]
  We set up the list when we start and delete it when we end.
  Later we'll search from bottom to top so that first we're in local scope, then in encompassing scope(s).
  For handler scope: go back to the BEGIN that precedes the DECLARE handler.
     We find it by looking for END, is main_token_pointer will be to BEGIN or to the label preceding BEGIN.
  Todo: Perhaps you should disallow combining specific and non-specific e.g. FOR SQLSTATE '80000', SQLWARNING
        because the conditions have different priorities and the standard disallows such combinations.
        However, perhaps you should leave it up to the user. Or maybe you should support warnings.
*/
bool MainWindow::clf_handler_list(QString text, int main_token_number, int clf_last_token, QString *clf_output)
{
  int handler_index;
  int i;
  handler_count= 0;
  for (i= main_token_number; i < clf_last_token; ++i)
  {
    if ((main_token_types[i] == TOKEN_KEYWORD_DECLARE)
     && (main_token_types[next_i(i, 2)] == TOKEN_KEYWORD_HANDLER))
      ++handler_count;
  }
  if (handler_count == 0) return true;
  handler_starts= new int[handler_count];
  handler_code_ends= new int[handler_count];
  handler_scope_ends= new int[handler_count];
  handler_begin_of_declares= new int[handler_count];
  handler_index= 0;

  for (i= main_token_number; i < clf_last_token; ++i)
  {
    if ((main_token_types[i] != TOKEN_KEYWORD_DECLARE)
     || (main_token_types[next_i(i, 2)] != TOKEN_KEYWORD_HANDLER))
      continue;
    int i_of_declare= i;
    assert(handler_index < handler_count);

    /* Todo: Saying "i_of_begin_of_declare= main_token_pointers[j];" failed. Maybe change h_parse someday? */
    /* We're assuming BEGIN ... DECLARE END; and ... is either blank or another handler or won't have BEGIN+END */
    int i_of_begin_of_declare= 0;
    int begin_count= 0;
    for (int k= i_of_declare - 1; k > main_token_number; --k)
    {
      if (main_token_types[k] == TOKEN_KEYWORD_END)
      {
        if (main_token_types[next_i(k, 1)] == TOKEN_TYPE_OPERATOR) --begin_count;
      }
      if (main_token_types[k] == TOKEN_KEYWORD_BEGIN)
      {
        ++begin_count;
        if (begin_count <= 0) continue;
        i_of_begin_of_declare= k;
        break;
      }
    }
    {
      int i= next_i(i_of_begin_of_declare, -2);
      if (main_token_reftypes[i] == TOKEN_REFTYPE_LABEL_DEFINE) i_of_begin_of_declare= i;
      /* hparse doesn't allow x:y:begin but if someday it does, stop it because we haven't tested */
      i= next_i(i_of_begin_of_declare, -2);
      if (main_token_reftypes[i] == TOKEN_REFTYPE_LABEL_DEFINE)
      {
        *clf_output= "Sorry, we do not allow multiple labels for the same BEGIN at this time.";
        return false;
      }
    }
    assert(i_of_begin_of_declare > main_token_number);
    handler_begin_of_declares[handler_index]= i_of_begin_of_declare;
    handler_scope_ends[handler_index]= 0;
    for (int j= i_of_begin_of_declare; j < clf_last_token; ++j)
    {
      if ((main_token_types[j] == TOKEN_KEYWORD_END) && (main_token_pointers[j] == i_of_begin_of_declare))
      {
        handler_scope_ends[handler_index]= j;
        break;
      }
    }

    assert(handler_scope_ends[handler_index] != 0);

    handler_starts[handler_index]= i_of_declare; /* Todo: should this be i_of_begin_of_declare? */

    /* If it is a flow-control statement, handler code ends at the END. Otherwise it ends at the ";". */
    int i_of_statement_after_declare= 0;
    for (int i= i_of_declare + 1; i < clf_last_token; ++i)
    {
      if ((main_token_flags[i] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
      {
        i_of_statement_after_declare= i;
        break;
      }
    }
    assert(i_of_statement_after_declare != 0);
    assert(i_of_statement_after_declare < clf_last_token);
    int token= main_token_types[i_of_statement_after_declare];
    handler_code_ends[handler_index]= 0;
    /* Todo: Check whether you could simply check TOKEN_FLAG_IS_FLOW_CONTROL instead of the following. */
    if ((token == TOKEN_KEYWORD_BEGIN)
    || (token == TOKEN_KEYWORD_CASE)
    || (token == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT) /* will only be true if MariaDB 10.3 */
    || (token == TOKEN_KEYWORD_IF)
    || (token == TOKEN_KEYWORD_LOOP)
    || (token == TOKEN_KEYWORD_REPEAT)
    || (token == TOKEN_KEYWORD_WHILE))
    {
      for (int k= i_of_statement_after_declare + 1; k < clf_last_token; ++k)
      {
        if ((main_token_types[k] == TOKEN_KEYWORD_END) && (main_token_pointers[k] == i_of_statement_after_declare))
        {
          /* Found an END that matches i_of_statement_after_declare. now skip to the terminating ";". */
          while (main_token_types[k] != TOKEN_TYPE_OPERATOR) ++k;
          handler_code_ends[handler_index]= k;
          break;
        }
      }
    }
    else
    {
      for (int k= i_of_statement_after_declare;; ++k)
      {
        QString d= text.mid(main_token_offsets[k], main_token_lengths[k]);
        if (d == ";")
        {
          handler_code_ends[handler_index]= k;
          break;
        }
      }
    }
    assert(handler_starts[handler_index] < handler_code_ends[handler_index]);
    assert(handler_code_ends[handler_index] <= handler_scope_ends[handler_index]);
    ++handler_index;
  }
  /* Check: do not allow duplicate conditions for the same BEGIN. Standard restriction. */
  /* Check: do not allow handlers within handlers. Hopefully temporary restriction. */
  for (int outer_handler= 0; outer_handler < handler_count; ++outer_handler)
  {
    int outer_condition;
    for (outer_condition= handler_starts[outer_handler]; main_token_types[outer_condition] != TOKEN_KEYWORD_FOR; ++outer_condition) {;}
    for (outer_condition= outer_condition + 1; (main_token_flags[outer_condition] & TOKEN_FLAG_IS_START_STATEMENT) == 0; ++outer_condition)
    {
      int outer_condition_value= main_token_types[outer_condition];
      if ((outer_condition_value == TOKEN_TYPE_OPERATOR)
       || (outer_condition_value == TOKEN_KEYWORD_SQLSTATE)
       ||(outer_condition_value == TOKEN_KEYWORD_VALUE))
        continue;
      if ((outer_condition_value == TOKEN_TYPE_IDENTIFIER)
       || (outer_condition_value == TOKEN_TYPE_LITERAL_WITH_DIGIT))
      {
        *clf_output= "Sorry, the only handler conditions we allow at this time are sqlstate 'xxxxx', sqlexception, not found, and sqlwarning.";
        return false;
      }
      int condition_count= 0; /* If this becomes > 1, there is duplication in the same block. */
      for (int inner_handler= 0; inner_handler < handler_count; ++inner_handler)
      {
        if ((handler_starts[inner_handler] > handler_starts[outer_handler]) && (handler_code_ends[inner_handler] < handler_code_ends[outer_handler]))
        {
          *clf_output= "Sorry, we do not allow handlers within handlers at this time.";
          return false;
        }
        if (handler_begin_of_declares[inner_handler] != handler_begin_of_declares[outer_handler]) continue; /* not in the same BEGIN */
        int inner_condition;
        for (inner_condition= handler_starts[inner_handler]; main_token_types[inner_condition] != TOKEN_KEYWORD_FOR; ++inner_condition) {;}
        for (inner_condition= inner_condition + 1; (main_token_flags[inner_condition] & TOKEN_FLAG_IS_START_STATEMENT) == 0; ++inner_condition)
        {
          int inner_condition_value= main_token_types[inner_condition];
          if ((inner_condition_value == TOKEN_TYPE_OPERATOR)
           || (inner_condition_value == TOKEN_KEYWORD_SQLSTATE)
           || (inner_condition_value == TOKEN_KEYWORD_VALUE))continue;
          if (inner_condition_value == outer_condition_value)
          {
            QString d1= text.mid(main_token_offsets[inner_condition], main_token_lengths[inner_condition]);
            QString d2= text.mid(main_token_offsets[outer_condition], main_token_lengths[outer_condition]);
            if (QString::compare(d1, d2, Qt::CaseInsensitive) == 0) ++condition_count;
            if (condition_count > 1)
            {
              *clf_output= "Sorry, we don't allow duplicate handler conditions in the same scope.";
              return false;
            }
          }
        }
      }
    }
  }

  return true;
}

/*
  Return a name of a handler function for a specified TOKEN_KEYWORD_DECLARE token.
  We identify the handler by its number within the handler lists.
  Any name will do. A name like "handler_1" seems okay. Maybe a line number or a recent label would be better.
*/
QString MainWindow::clf_handler_name(int i_of_declare)
{
  for (int i= 0; i < handler_count; ++i)
  {
    if (handler_starts[i] == i_of_declare)
    {
      return "handler_" + QString::number(i);
    }
  }
  return "unknown_handler"; /* actually this must be an error */
}

/*
  Return: declared variable name or parameter name or cursor name
  Pass: i= clfi (if this is in the DECLARE) or main_token_pointers[clfi] (if this is a reference)
  Example: if i == 1 and [i] has x, return "X". Usually it's that simple but here are complexities.
  1. If it is a regular identifier, upper-case it.
     If it is a delimited identifier, strip the ""s and do not upper-case it.
  2. If any character might be illegal in a Lua name, replace it with "_" hex(unicode-value-of-character) "_"
  3. If it is a cursor, add "_CURSOR" (because cursors should have a different namespace).
  If any character was replaced, then there is a very slight chance that the name is not unique, for example
  user could have both "a_32_b" and "a b", and we could guarantee uniqueness by adding QString::number(i) i.e.
  token-number as a suffix, but we don't because (a) it really is a very slight chance (b) Lua will catch it.
  Todo: we could consider adding a suffix or a comment so it's clear what was data type + whether it was a parameter.
  i_type is TOKEN_REFTYPE_{VARIABLE|PARAMETER|CURSOR}_DEFINE
  Converting to upper case is best because (a) we're sure there's no conflict with a Lua reserved word,
  (b) we're sure there's no duplication of regular-identifier b and delimited-identifier "B", (c) this
  correctly reflects what SQL does with identifiers.
  Todo: watch out with connect_stripper, are we always checking ansi_quotes? And `...` quoting is okay?
*/
QString MainWindow::clf_v(const QString text, int i, int i_type)
{
  QString d1= text.mid(main_token_offsets[i], main_token_lengths[i]);
  if (d1.left(1) == "\"") d1= connect_stripper(d1, true);
  else d1= d1.toUpper();
  QString d2= "";
  QChar c;
  for (int i= 0; i < d1.length(); ++i)
  {
    c= d1.at(i);
    if (((c.isDigit()) && (i == 0))
     || ((c.isDigit() == false) && (c.isLetter() == false) && (c != '_')))
    {
      d2= d2 + "_" + QString::number(c.unicode()) + "_";
    }
    else d2= d2 + c;
  }
  if (i_type == TOKEN_REFTYPE_CURSOR_DEFINE) d2= d2 + "_CURSOR";
  return d2;
}

/*
  When we call sql_execute, the first parameter is a string literal with the SQL statement.
  Usually sql_execute_starter="sql_execute([[" and sql_execute_ender="]]".
  But if text contains [[ or ]] that could cause trouble. In that case we change to [=[ ... ]=]... etc.
  We go as high as 5 =s, that is, sql_execute([=====[ ... ]=====]). 5 is arbitrary, but we won't go forever.
*/
bool MainWindow::clf_make_sql_execute_starter_and_ender(QString text, QString *clf_output)
{
  QString starter_brackets;
  QString ender_brackets;
  QString equals= "=";
  int equals_count= 0;
  for (;;)
  {
    starter_brackets= "[" + equals.repeated(equals_count) + "[";
    ender_brackets= "]" + equals.repeated(equals_count) + "]";
    if ((text.contains(starter_brackets) == false)
     && (text.contains(ender_brackets) == false)) break;
    ++equals_count;
    if (equals_count > 5)
    {
      *clf_output= "Sorry, there are too many [[s and [=[s etc. in the input. The limit is [=====[.";
      return false;
    }
  }
  sql_execute_starter= "sql_execute(" + starter_brackets;
  sql_execute_ender= ender_brackets;
  return true;
}

/*
  sql_execute() takes a string containing an SQL statement and executes it.
  The code inside the sql_execute function is non-generic, that is, it works only with a particular SQL dialect.
  All the rest of the translation should be generic.
  Todo: parameters.
  Todo: true/false (for the sake of while/if/etc.) -- maybe we should return true or false or nil
  Usually we just want result[1][1] but I think returning it isn't necessary.
  Todo: at some point we might want to show an error message; m is cdata but tostring(m) will work.
  With MySQL/MariaDB we simply return the SQLSTATE that the DBMS returns.
  With Tarantool we make up an SQLSTATE = '00000' okay, '02000' not found, '45000' sqlexception.
*/
void MainWindow::clf_make_sql_execute_function(QString *clf_output)
{
  QString indent_string= clf_indent(clf_output); 
  *clf_output= *clf_output +
  "\n" + indent_string + "local sqlstate;"
  "\n" + indent_string + "local sqlresult = {};" +
  "\n" + indent_string + "local sqlmessage;";

  if (connections_dbms[0] == DBMS_TARANTOOL)
  {
    *clf_output= *clf_output +
    "\n" + indent_string + "local function sql_execute(statement, parameters)" +
    "\n" + indent_string + "    local s, r, m;" +
    "\n" + indent_string + "    s, r, m = pcall(box.execute,statement, parameters);" +
    "\n" + indent_string + "    sqlmessage = tostring(m);" +
    "\n" + indent_string + "    if r == nil and m ~= nil then sqlstate = '45000'; return false; end;" +
    "\n" + indent_string + "    if (s == false) then sqlstate = '45000'; return false; end;" +
    "\n" + indent_string + "    if (r.rows == nil) then sqlstate = '00000'; return nil; end;" +
    "\n" + indent_string + "    if (r.rows[1] == nil) then sqlstate = '02000'; return nil; end;" +
    "\n" + indent_string + "    sqlresult = r.rows;" +
    "\n" + indent_string + "    sqlstate = '00000';" +
    "\n" + indent_string + "    return true;" +
    "\n" + indent_string + "    end;"
    "\n";
  }
  else
  {
    *clf_output= *clf_output +
    "\n" + indent_string + "local function sql_execute(statement, parameters)" +
    "\n" + indent_string + "--[[" +
    "\n" + indent_string + "    THIS IS A STUB." +
    "\n" + indent_string + "    For MySQL/MariaDB, Peter Gulutzan has not written the sql_execute() code." +
    "\n" + indent_string + "    But it should be easy, fewer than 50 lines." +
    "\n" + indent_string + "    Using the C API, remembering to enclose within pcall():" +
    "\n" + indent_string + "    * Pass each parameter." +
    "\n" + indent_string + "     * Execute the statement (e.g. mysql_real_query)." +
    "\n" + indent_string + "     * If there was an error: set sqlstate and return false." +
    "\n" + indent_string + "   * If there was no result set:" +
    "\n" + indent_string + "       set sqlstate = '00000' and return nil." +
    "\n" + indent_string + "   * If there was a result set:" +
    "\n" + indent_string + "       If row count == 0, set sqlstate = '02000' and return nil." +
    "\n" + indent_string + "       Otherwise put it in sqlresult, set sqlstate = '00000', return true." +
    "\n" + indent_string + "   For an example of code that works with another DBMS, look at ocelotgui" +
    "\n" + indent_string + "   source code, function clf_make_sql_execute_function." +
    "\n" + indent_string + "]]" +
    "\n" + indent_string + "    sqlstate = '45000';" +
    "\n" + indent_string + "    return false;" +
    "\n" + indent_string + "    end;"
    "\n";
  }
}


/*
  Add matching in-scope variable names to completer_widget. Only relevant for MySQL/MariaDB compound statements.
  Todo: bool hparse_is_variable_allowed was set up because hparse_f_variables might eliminate -- but are false positives possible?
        anyway reftype will only mention variable if there was an exact match, so it is not very useful
  Todo: We could ask hparse_f_is_in_compound() though it's not really necessary.
  Todo: This was moved out of hparse.h because it depends on things that were defined after #include "hparse.h". Reorganize.
  Todo: setup_determine_what_variables_are_in_scope() returns a list that is in ``s and may be lower case.
        We simply strip the ``s and call upper() -- but what if the DECLARE actually had ``s or ""s?
  Warning: hparse_variable_must_be_int is semi-global, ensure it's false if caller is not via hparse routine.
*/
void MainWindow::hparse_f_variables_append(int hparse_i_of_statement, QString hparse_text_copy, unsigned char reftype)
{
  if ((reftype != 0) && (hparse_variable_is_allowed == true))
  {
    int declared_variables_count= 0;
    setup_determine_what_variables_are_in_scope(hparse_i_of_statement, hparse_text_copy, hparse_variable_must_be_int);
    declared_variables_count= c_variable_names.count();
    for (int i= 0; i < declared_variables_count; ++i)
    {
      QString token= c_variable_names.at(i);
      if (token.left(1) == "`") token= token.right(token.size() - 1);
      if (token.right(1) == "`") token= token.left(token.size() - 1);
      token= token.toUpper();
      completer_widget->append_wrapper(token, hparse_token, main_token_types[hparse_i], main_token_flags[hparse_i], "V");
    }
  }
}


/*
  SSL test
  --------
  This test was done with MariaDB 10.0.17 source, with files described in
  "Configuring MySQL to use SSL Connections"
  https://dev.mysql.com/doc/refman/5.0/en/using-ssl-connections.html
  1. export MARIADB=10.0.17
  2. Start server with
     mysqld ... --ssl-ca=$HOME/$MARIADB/mysql-test/std_data/cacert.pem --ssl-cert=$HOME/$MARIADB/mysql-test/std_data/server-cert.pem --ssl-key=$HOME/$MARIADB/mysql-test/std_data/server-key.pem
  3. Start client with
     ocelotgui ... --ssl-cert=$HOME/$MARIADB/mysql-test/std_data/client-cert.pem --ssl-key=$HOME/$MARIADB/mysql-test/std_data/client-key.pem
  4. SHOW STATUS LIKE 'Ssl_cipher';
  The result value was DHE-RSA-AES256-SHA. So we declared the test successful.
*/

/*
  Valgrind
  --------

  We get lots of complaints from valgrind about problems that seem to be in
  libraries, including gtk_ and g_ routines, so there is a suppression file.
  Even with the suppressions, some possibly-tolerable leakages are happening:
  * simply closing MainWindow, as opposed to ^Q, will not go via action_exit()
  * --version and --help end with exit(0)
  * dlopen() and mysql_real_connect() are leaving something behind

    This is what is in valgrind suppression file valgrind_suppressions.supp.
    Run valgrind with --suppressions=valgrind_suppressions.supp.
    Put the list in the source files somewhere.
    {
       <Addr4s>
       Memcheck:Addr4
       ...
       fun:FcConfig*
    }
    {
       <Conds>
       Memcheck:Cond
       ...
       fun:g_*
    }
    {
       <Params>
       Memcheck:Param
       ioctl(generic)
       ...
       fun:ioctl*
    }
    {
       <Leaks_g>
       Memcheck:Leak
       ...
       fun:g_*
    }
    {
       <Leaks_gtk>
       Memcheck:Leak
       ...
       fun:gtk_*
    }
    {
       <Leaks_pango>
       Memcheck:Leak
       ...
       fun:pango*
    }
    {
       <Leaks_gl>
       Memcheck:Leak
       ...
       fun:glXGetFBConfigs
    }
    {
       <Leaks_Fc>
       Memcheck:Leak
       ...
       fun:FcConfigParseAndLoad
    }
*/

#if (OCELOT_MYSQL_DEBUGGER == 1)
#include "install_sql.cpp"
#endif

#ifndef XSETTINGS
#define XSETTINGS

/*
  We originally had a series of assignments here but in older distros there were warnings
  "Warning: extended initializer lists only available with -std=c++11 or -std=gnu++11"
  so we switched to this. 140 is OCELOT_VARIABLES_SIZE and we could reduce some caller code.
  We don't have ocelot_export in the list, I don't think it's needed.
  Note: We don't get here for OCELOT_MAX_CONDITIONS and maybe other things if execute_client_statement()
        checks for them first. So there's no use having them in the table at this time.
*/
int XSettings::ocelot_variables_create()
{
  static const ocelot_variable_keywords o_v[]=
  {
    {NULL, &ocelot_batch,  1, 0, 0, TOKEN_KEYWORD_OCELOT_BATCH},
    {NULL, &ocelot_client_side_functions,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_CLIENT_SIDE_FUNCTIONS},
    {NULL, &ocelot_completer_timeout,  1000000, 0, 0, TOKEN_KEYWORD_OCELOT_COMPLETER_TIMEOUT},
    {&main_window->ocelot_dbms, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_DBMS},
    {&main_window->ocelot_debug_detached, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED},
    {&main_window->ocelot_debug_height, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_DEBUG_HEIGHT},
    {&main_window->ocelot_debug_left, NULL, 10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_DEBUG_LEFT},
    {&main_window->ocelot_debug_top, NULL, 10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_DEBUG_TOP},
    {&main_window->ocelot_debug_width, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_DEBUG_WIDTH},
    {&main_window->ocelot_explorer_action, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_ACTION},
    {&main_window->ocelot_explorer_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_EXPLORER, TOKEN_KEYWORD_OCELOT_EXPLORER_BACKGROUND_COLOR},
    {&main_window->ocelot_explorer_detached, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED},
    {&main_window->ocelot_explorer_font_family, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY, OCELOT_VARIABLE_ENUM_SET_FOR_EXPLORER, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_FAMILY},
    {&main_window->ocelot_explorer_font_size, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_SIZE, OCELOT_VARIABLE_ENUM_SET_FOR_EXPLORER, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_SIZE},
    {&main_window->ocelot_explorer_font_style, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_STYLE, OCELOT_VARIABLE_ENUM_SET_FOR_EXPLORER, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_STYLE},
    {&main_window->ocelot_explorer_font_weight, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT, OCELOT_VARIABLE_ENUM_SET_FOR_EXPLORER, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_WEIGHT},
    {&main_window->ocelot_explorer_height, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_HEIGHT},
    {&main_window->ocelot_explorer_left, NULL, 10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_LEFT},
    {&main_window->ocelot_explorer_text, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_TEXT},
    {&main_window->ocelot_explorer_text_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_EXPLORER, TOKEN_KEYWORD_OCELOT_EXPLORER_TEXT_COLOR},
    {&main_window->ocelot_explorer_top, NULL, 10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_TOP},
    {&main_window->ocelot_explorer_visible, NULL, -1, 0, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_VISIBLE},
    {&main_window->ocelot_explorer_width, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_WIDTH},
    {&main_window->ocelot_extra_rule_1_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_EXTRA_RULE_1, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_BACKGROUND_COLOR},
    {&main_window->ocelot_extra_rule_1_condition, NULL,  -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_EXTRA_RULE_1, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_CONDITION},
    {&main_window->ocelot_extra_rule_1_display_as, NULL,  -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_EXTRA_RULE_1, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_DISPLAY_AS},
    {&main_window->ocelot_extra_rule_1_text_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_EXTRA_RULE_1, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_TEXT_COLOR},
    {&main_window->ocelot_grid_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_BACKGROUND_COLOR},
    {&main_window->ocelot_grid_cell_border_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_COLOR},
    {&main_window->ocelot_grid_cell_border_size, NULL,  10, 0, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_SIZE},
    {&main_window->ocelot_grid_cell_height, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_GRID_CELL_HEIGHT},
    {&main_window->ocelot_grid_cell_width, NULL, -1, 0, 0, TOKEN_KEYWORD_OCELOT_GRID_CELL_WIDTH},
    {&main_window->ocelot_grid_detached, NULL, -1, 0, 0, TOKEN_KEYWORD_OCELOT_GRID_DETACHED},
    {&main_window->ocelot_grid_focus_cell_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_FOCUS_CELL_BACKGROUND_COLOR},
    {&main_window->ocelot_grid_font_family, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_FONT_FAMILY},
    {&main_window->ocelot_grid_font_size, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_SIZE, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_FONT_SIZE},
    {&main_window->ocelot_grid_font_style, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_STYLE, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_FONT_STYLE},
    {&main_window->ocelot_grid_font_weight, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_FONT_WEIGHT},
    {&main_window->ocelot_grid_header_background_color, NULL, -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_HEADER_BACKGROUND_COLOR},
    {&main_window->ocelot_grid_height, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_GRID_HEIGHT},
    {&main_window->ocelot_grid_html_effects, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_GRID_HTML_EFFECTS},
    {&main_window->ocelot_grid_left, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_GRID_LEFT},
    {&main_window->ocelot_grid_outer_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_OUTER_COLOR},
    {NULL, &ocelot_grid_tabs,  10000, 0, 0, TOKEN_KEYWORD_OCELOT_GRID_TABS},
    {&main_window->ocelot_grid_text_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_TEXT_COLOR},
    {&main_window->ocelot_grid_top, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_GRID_TOP},
    {&main_window->ocelot_grid_width, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_GRID_WIDTH},
    {&main_window->ocelot_histfileflags, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_HISTFILEFLAGS},
    {&main_window->ocelot_histfilesize, NULL,  2000000000, 0, 0, TOKEN_KEYWORD_OCELOT_HISTFILESIZE},
    {&main_window->ocelot_history_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY, TOKEN_KEYWORD_OCELOT_HISTORY_BACKGROUND_COLOR},
    {&main_window->ocelot_history_border_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY, TOKEN_KEYWORD_OCELOT_HISTORY_BORDER_COLOR},
    {&main_window->ocelot_history_detached, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED},
    {&main_window->ocelot_history_font_family, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY, OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_FAMILY},
    {&main_window->ocelot_history_font_size, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_SIZE, OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_SIZE},
    {&main_window->ocelot_history_font_style, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_STYLE, OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_STYLE},
    {&main_window->ocelot_history_font_weight, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT, OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_WEIGHT},
    {&main_window->ocelot_history_height, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_HISTORY_HEIGHT},
    {&main_window->ocelot_history_left, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_HISTORY_LEFT},
    {&main_window->ocelot_history_max_row_count, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_HISTORY_MAX_ROW_COUNT},
    {&main_window->ocelot_history_text_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY, TOKEN_KEYWORD_OCELOT_HISTORY_TEXT_COLOR},
    {&main_window->ocelot_history_top, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_HISTORY_TOP},
    {&main_window->ocelot_history_width, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_HISTORY_WIDTH},
    {&main_window->ocelot_histsize, NULL,  10000, 0, 0, TOKEN_KEYWORD_OCELOT_HISTSIZE},
    {NULL,  &ocelot_vertical,  1, 0, 0, TOKEN_KEYWORD_OCELOT_HORIZONTAL},
    {NULL, &ocelot_html,  1, 0, 0, TOKEN_KEYWORD_OCELOT_HTML},
    {NULL, &ocelot_html,  1, 0, 0, TOKEN_KEYWORD_OCELOT_HTMLRAW},
    {&main_window->ocelot_language, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_LANGUAGE},
    {NULL, &ocelot_log_level,  10000, 0, 0, TOKEN_KEYWORD_OCELOT_LOG_LEVEL},
    {NULL, &ocelot_max_conditions, MAX_MAX_CONDITIONS,  0, 0, TOKEN_KEYWORD_OCELOT_MAX_CONDITIONS},
    {&main_window->ocelot_menu_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_MENU, TOKEN_KEYWORD_OCELOT_MENU_BACKGROUND_COLOR},
    {&main_window->ocelot_menu_border_color, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_MENU_BORDER_COLOR},
    {&main_window->ocelot_menu_font_family, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY, OCELOT_VARIABLE_ENUM_SET_FOR_MENU, TOKEN_KEYWORD_OCELOT_MENU_FONT_FAMILY},
    {&main_window->ocelot_menu_font_size, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_SIZE, OCELOT_VARIABLE_ENUM_SET_FOR_MENU, TOKEN_KEYWORD_OCELOT_MENU_FONT_SIZE},
    {&main_window->ocelot_menu_font_style, NULL, -1, OCELOT_VARIABLE_FLAG_SET_FONT_STYLE, OCELOT_VARIABLE_ENUM_SET_FOR_MENU, TOKEN_KEYWORD_OCELOT_MENU_FONT_STYLE},
    {&main_window->ocelot_menu_font_weight, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT, OCELOT_VARIABLE_ENUM_SET_FOR_MENU, TOKEN_KEYWORD_OCELOT_MENU_FONT_WEIGHT},
    {&main_window->ocelot_menu_text_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_MENU, TOKEN_KEYWORD_OCELOT_MENU_TEXT_COLOR},
    {NULL, &ocelot_raw,  1, 0, 0, TOKEN_KEYWORD_OCELOT_RAW},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_AUTOCOMPLETE},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_BATCH},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_BREAKPOINT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_CLEAR},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_CONNECT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_CONTINUE},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_COPY},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_CUT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_DEBUG_EXIT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_EXECUTE},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_EXIT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_FIND},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_FORMAT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_NEXT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_PREVIOUS},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_HORIZONTAL},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_HTML},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_HTMLRAW},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_INFORMATION},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_KILL},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT_WINDOW},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_PASTE},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_PREVIOUS_WINDOW},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_RAW},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_REDO},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_CALL_STACK},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_SERVER_VARIABLES},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_USER_VARIABLES},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_VARIABLES},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_SELECT_ALL},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_STEP},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_UNDO},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_VERTICAL},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_XML},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMIN},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMOUT},
    {&main_window->ocelot_statement_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_BACKGROUND_COLOR},
    {&main_window->ocelot_statement_border_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_BORDER_COLOR},
    {&main_window->ocelot_statement_detached, NULL, -1, 0, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED},
    {&main_window->ocelot_statement_font_family, NULL, -1, OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_FAMILY},
    {&main_window->ocelot_statement_font_size, NULL, -1, OCELOT_VARIABLE_FLAG_SET_FONT_SIZE, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_SIZE},
    {&main_window->ocelot_statement_font_style, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_STYLE, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_STYLE},
    {&main_window->ocelot_statement_font_weight, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_WEIGHT},
    {&main_window->ocelot_statement_format_clause_indent, NULL,  8, 0, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_CLAUSE_INDENT},
    {&main_window->ocelot_statement_format_rule, NULL, -1, 0, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_RULE}, /* only used during connect */
    {&main_window->ocelot_statement_format_statement_indent, NULL, 8, 0, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_STATEMENT_INDENT},
    {&main_window->ocelot_statement_height, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HEIGHT},
    {&main_window->ocelot_statement_highlight_comment_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_COMMENT_COLOR},
    {&main_window->ocelot_statement_highlight_current_line_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR},
    {&main_window->ocelot_statement_highlight_function_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_FUNCTION_COLOR},
    {&main_window->ocelot_statement_highlight_identifier_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_IDENTIFIER_COLOR},
    {&main_window->ocelot_statement_highlight_keyword_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_KEYWORD_COLOR},
    {&main_window->ocelot_statement_highlight_literal_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_LITERAL_COLOR},
    {&main_window->ocelot_statement_highlight_operator_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_OPERATOR_COLOR},
    {&main_window->ocelot_statement_left, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_LEFT},
    {&main_window->ocelot_statement_prompt_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_PROMPT_BACKGROUND_COLOR},
    {&main_window->ocelot_statement_syntax_checker, NULL,  3, 0, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_SYNTAX_CHECKER},
    {&main_window->ocelot_statement_text_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_TEXT_COLOR},
    {&main_window->ocelot_statement_top, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_TOP},
    {&main_window->ocelot_statement_width, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_WIDTH},
    {NULL, &ocelot_vertical,  1, 0, 0, TOKEN_KEYWORD_OCELOT_VERTICAL},
    {NULL, &ocelot_xml,  1, 0, 0, TOKEN_KEYWORD_OCELOT_XML}
  };
  int i= 140;
  assert(sizeof(o_v) == sizeof(struct ocelot_variable_keywords) * i);
  memcpy(ocelot_variables, o_v, sizeof(o_v));
  return i;
}

int XSettings::ocelot_variable_set(int keyword_index, QString new_value)
{
  int offset= ocelot_variable_offset(keyword_index);
  if (offset == -1) return ER_OVERFLOW;
  bool is_font_changed= false;
  QString qv;
  if (keyword_index == TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_CONDITION) qv= main_window->connect_stripper(new_value, true);
  else qv= main_window->connect_stripper(new_value, false);
  char flags_style= ocelot_variables[offset].flags_style;
  char enums_for= ocelot_variables[offset].enums_for;
  QString *qstring_target= ocelot_variables[offset].qstring_target;
  short unsigned int *int_target= ocelot_variables[offset].int_target;
  int maximum= ocelot_variables[offset].maximum;
  if (maximum != -1)
  {
    bool is_digits= true;
    if (qv == "") is_digits= false;
    else for (int i= 0; i < qv.size(); ++i) {if (qv[i].isDigit() == false) is_digits= false; }
    if ((is_digits == false) || (qv.toInt() > maximum))
    {
      if (QString::compare(qv, "default", Qt::CaseInsensitive) == 0) qv= "default";
      if ((flags_style != OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE) || (qv != "default"))
      {
        int er= ER_ILLEGAL_VALUE; /* default = most common */
        if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_SYNTAX_CHECKER) er= ER_SYNTAX;
        if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_STATEMENT_INDENT) er= ER_FORMAT_STATEMENT;
        if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_CLAUSE_INDENT) er= ER_FORMAT_CLAUSE;
        return er;
      }
    }
  }
  if (enums_for == OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT)
  {
    int ii= main_window->shortcut(keyword_index, qv, true, true);
    if (ii == 1)
    {
      return ER_OK;
    }
    if (ii == -1)
    {
      return ER_ILLEGAL_VALUE;
    }
  }
  if (keyword_index == TOKEN_KEYWORD_OCELOT_HORIZONTAL)
  {
    int i= qv.toInt();
    if (i == 1) ocelot_vertical= 0; else ocelot_vertical= 1;
    return ER_OK;
  }
  if (keyword_index == TOKEN_KEYWORD_OCELOT_VERTICAL)
  {
    int i= qv.toInt();
    ocelot_vertical= i;
    return ER_OK;
  }
  if ((keyword_index == TOKEN_KEYWORD_OCELOT_BATCH)
   || (keyword_index == TOKEN_KEYWORD_OCELOT_HTML)
   || (keyword_index == TOKEN_KEYWORD_OCELOT_HTMLRAW)
   || (keyword_index == TOKEN_KEYWORD_OCELOT_RAW)
   || (keyword_index == TOKEN_KEYWORD_OCELOT_XML))
  {
    ocelot_batch= ocelot_html= ocelot_raw= ocelot_xml= 0;
    int i= qv.toInt();
    if (i == 1)
    {
      *int_target= i;
      if (keyword_index == TOKEN_KEYWORD_OCELOT_HTMLRAW) ocelot_html= ocelot_raw= i;
    }
    return ER_OK;
  }
  if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_RULE)
  {
    ; /* Todo: check validity of qv here? */
  }
  if ((keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED)
#if (OCELOT_MYSQL_DEBUGGER == 1)
   || (keyword_index == TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED)
#endif
#if (OCELOT_EXPLORER == 1)
   || (keyword_index == TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED)
#endif
   || (keyword_index == TOKEN_KEYWORD_OCELOT_GRID_DETACHED)
   || (keyword_index == TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED))
  {
    {
      if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED)
      {
        if (qv == "no") { main_window->menu_options_action_option_detach_statement_widget->setChecked(false); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED, false); }
        else {main_window->menu_options_action_option_detach_statement_widget->setChecked(true); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED, true); }
      }
#if (OCELOT_MYSQL_DEBUGGER == 1)
      if (keyword_index == TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED)
      {
        if (qv == "no") { main_window->menu_options_action_option_detach_debug_widget->setChecked(false); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED, false); }
        else { main_window->menu_options_action_option_detach_debug_widget->setChecked(true); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED, true); }
      }
#endif
#if (OCELOT_EXPLORER== 1)
      if (keyword_index == TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED)
      {
        if (qv == "no") { main_window->menu_options_action_option_detach_explorer_widget->setChecked(false); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED, false); }
        else { main_window->menu_options_action_option_detach_explorer_widget->setChecked(true); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED, true); }
      }
#endif
      if (keyword_index == TOKEN_KEYWORD_OCELOT_GRID_DETACHED)
      {
        if (qv == "no") { main_window->menu_options_action_option_detach_result_grid_widget->setChecked(false); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_GRID_DETACHED, false); }
        else { main_window->menu_options_action_option_detach_result_grid_widget->setChecked(true); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_GRID_DETACHED, true); }
      }
      if (keyword_index == TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED)
      {
        if (qv == "no") { main_window->menu_options_action_option_detach_history_widget->setChecked(false); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED, false); }
        else { main_window->menu_options_action_option_detach_history_widget->setChecked(true); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED, true); }
      }
    }
  }

#if (OCELOT_EXPLORER == 1)
  if (keyword_index == TOKEN_KEYWORD_OCELOT_EXPLORER_VISIBLE)
  {
    qv= qv.toLower();
    if ((qv != "yes") && (qv != "no")) return ER_ILLEGAL_VALUE;
    *qstring_target= qv;
    if (qv == "yes")
    {
      char error_or_ok_message[ER_MAX_LENGTH]; /* todo: we're not showing this message to the user */
      int ret= main_window->explorer_refresh_caller(error_or_ok_message);
      if (ret != ER_OK_REHASH) return ret;
      return ER_OK;
    }
    else main_window->explorer_widget->hide();
  }
#endif

  if ((flags_style == 0) || (flags_style == OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE))
  {
    if (qstring_target != NULL) *qstring_target= qv;
    if (int_target != NULL) *int_target=qv.toInt();
  }

  if (flags_style == OCELOT_VARIABLE_FLAG_SET_COLOR)
  {
    QString ccn= main_window->canonical_color_name(qv);
    if (ccn == "") return ER_UNKNOWN_COLOR;
    *qstring_target= ccn;
    main_window->assign_names_for_colors();
    char tmp18[256];
    strcpy(tmp18, ccn.toUtf8());
    char tmp19[256];
    strcpy(tmp19, main_window->ocelot_explorer_background_color.toUtf8());
  }

  if ((flags_style & OCELOT_VARIABLE_FLAG_SET_FONT) != 0)
  {
    QString ccn;
    if (flags_style == OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY)
    {
      /* TODO: setting font_family can fail e.g. say 'Courier' and you could get 'Sans'
               because only 'Courier New' exists. There should be a warning, and
               setting some style hint e.g. "at least it should be monospace" would be good.
               Also ER_UNKNOWN_FONT_STYLE is the wrong error message if family is unknown.
      */
      if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_FAMILY)
         ccn= main_window->canonical_font_family(qv, &main_window->ocelot_statement_font_style);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_GRID_FONT_FAMILY)
         ccn= main_window->canonical_font_family(qv, &main_window->ocelot_grid_font_style);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_HISTORY_FONT_FAMILY)
         ccn= main_window->canonical_font_family(qv, &main_window->ocelot_history_font_style);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_MENU_FONT_FAMILY)
         ccn= main_window->canonical_font_family(qv, &main_window->ocelot_menu_font_style);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_FAMILY)
         ccn= main_window->canonical_font_family(qv, &main_window->ocelot_explorer_font_style);
      if (ccn == "") return ER_UNKNOWN_FONT_STYLE;
    }
    if (flags_style == OCELOT_VARIABLE_FLAG_SET_FONT_STYLE)
    {
      if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_STYLE)
        ccn= main_window->canonical_font_style(main_window->ocelot_statement_font_family, qv);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_GRID_FONT_STYLE)
        ccn= main_window->canonical_font_style(main_window->ocelot_grid_font_family, qv);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_HISTORY_FONT_STYLE)
         ccn= main_window->canonical_font_style(main_window->ocelot_history_font_family, qv);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_MENU_FONT_STYLE)
        ccn= main_window->canonical_font_style(main_window->ocelot_menu_font_family, qv);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_STYLE)
        ccn= main_window->canonical_font_style(main_window->ocelot_explorer_font_family, qv);
      if (ccn == "") return ER_UNKNOWN_FONT_STYLE;
    }
    if (flags_style == OCELOT_VARIABLE_FLAG_SET_FONT_SIZE)
    {
      ccn= qv;
      if ((ccn.toInt() < FONT_SIZE_MIN) || (ccn.toInt() > FONT_SIZE_MAX)) return ER_UNKNOWN_FONT_SIZE;
    }
    if (flags_style == (char) OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT)
    {
      ccn= main_window->canonical_font_weight(qv);
    }
    if (ccn != *qstring_target)
    {
      *qstring_target= ccn;
      is_font_changed= true;
    }
  }

  if (enums_for == OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT)
  {
    if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR)
    {
      main_window->statement_edit_widget->highlightCurrentLine();
    }
    else
    {
      main_window->make_style_strings();
      main_window->statement_edit_widget_setstylesheet();
      if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_PROMPT_BACKGROUND_COLOR)
      {
        main_window->statement_edit_widget->statement_edit_widget_left_bgcolor= QColor(main_window->ocelot_statement_prompt_background_color);
      }
    }
  }
  if (enums_for == OCELOT_VARIABLE_ENUM_SET_FOR_GRID)
  {
    ResultGrid* r;
    main_window->make_style_strings();
    for (int i_r= 0; i_r < ocelot_grid_actual_tabs; ++i_r)
    {
      r= qobject_cast<ResultGrid*>(main_window->result_grid_tab_widget->widget(i_r));
      r->set_all_style_sheets(main_window->ocelot_grid_style_string, *qstring_target, 1, is_font_changed);
    }
  }
  if (enums_for == OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY)
  {
    main_window->make_style_strings();
    main_window->history_edit_widget->setStyleSheet(main_window->ocelot_history_style_string);
  }
  if (enums_for == OCELOT_VARIABLE_ENUM_SET_FOR_MENU)
  {
    main_window->make_style_strings();
    main_window->ui->menuBar->setStyleSheet(main_window->ocelot_menu_style_string);
  }
#if (OCELOT_EXPLORER == 1)
  if (enums_for == OCELOT_VARIABLE_ENUM_SET_FOR_EXPLORER)
  {
    if (main_window->explorer_widget != NULL)
    {
      main_window->make_style_strings();
      main_window->explorer_widget->set_all_style_sheets(main_window->ocelot_explorer_style_string, 0, 1, true);
/* todo: dunno if we need to change explorer_context_menu, it's c_widget that gets font+color, eh? */
      main_window->explorer_widget->html_text_edit->explorer_context_menu->setStyleSheet(main_window->ocelot_explorer_style_string);
      main_window->c_widget->setStyleSheet(main_window->ocelot_explorer_style_string);
    }
  }
#endif
  if (enums_for == OCELOT_VARIABLE_ENUM_SET_FOR_EXTRA_RULE_1)
  {
    main_window->make_style_strings();
  }

  if (keyword_index == TOKEN_KEYWORD_OCELOT_COMPLETER_TIMEOUT)
  {
    if (main_window->completer_widget != NULL) main_window->completer_widget->set_timer_interval();
  }

  return ER_OK;
}

/* Return true iff keyword_index is for an ocelot_ variable for a color setting */
bool XSettings::ocelot_variable_is_color(int keyword_index)
{
  int offset= ocelot_variable_offset(keyword_index);
  if (offset < 0) return false;
  unsigned char flags_style= ocelot_variables[offset].flags_style;
  if (flags_style == OCELOT_VARIABLE_FLAG_SET_COLOR) return true;
  return false;
}

/* Return true iff keyword_index is for an ocelot_ variable for a font_weight setting */
bool XSettings::ocelot_variable_is_font_weight(int keyword_index)
{
  int offset= ocelot_variable_offset(keyword_index);
  if (offset < 0) return false;
  unsigned char flags_style= ocelot_variables[offset].flags_style;
  if (flags_style == OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT) return true;
  return false;
}

/* Return true iff keyword_index is for an ocelot_ variable for a font_style setting */
bool XSettings::ocelot_variable_is_font_style(int keyword_index)
{
  int offset= ocelot_variable_offset(keyword_index);
  if (offset < 0) return false;
  unsigned char flags_style= ocelot_variables[offset].flags_style;
  if (flags_style == OCELOT_VARIABLE_FLAG_SET_FONT_STYLE) return true;
  return false;
}

/* Return true iff keyword_index is for an ocelot_ variable for a font_family setting */
bool XSettings::ocelot_variable_is_font_family(int keyword_index)
{
  int offset= ocelot_variable_offset(keyword_index);
  if (offset < 0) return false;
  unsigned char flags_style= ocelot_variables[offset].flags_style;
  if (flags_style == OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY) return true;
  return false;
}



int XSettings::ocelot_variables_size()
{
  return OCELOT_VARIABLES_SIZE;
}

XSettings::~XSettings()
{
  delete[] ocelot_variables;
}

#endif // XSETTINGS

#if (OCELOT_EXPLORER == 1)
/*
  Explorer
  --------
  Name:
    Others say "object explorer" or "navigator". Compare the name "Windows explorer".
  Position:
    It's a widget with the same priority as history|grid|statement.
    Usually on the left. Detachable. Often hidden. Default hidden. If hidden, won't be updated.
  Style:
    It's a result grid. So it is wider, and has less decoration, compared to other products' explorers.
    However, users get some features without needing to learn anything new:
    * SET works. E.g. SET ocelot_explorer_background_color = 'tan' WHERE value > 'sys'; (if you REFRESH)
    * ^Find works. (if it's visible)
    * Vertical scroll bar works.
    * One difference: dragging doesn't happen. There wouldn't be much point, since items are short.
  Columns: all of which are 'TEXT':
    #1: Min. = Unicode Black Down-Pointing Triangle or Black Right-Pointing Triangle if database or table.
        If it's a database or table, this can be clicked to hide the parts e.g. columns, or to show them again.
        (We call this "toggling".)
        Ordinarily it has a different background color (grid header background color).
    #2: object_type. S or T or V or C or P or I or E or t
    #3: object_name. for example, if object_type='T', this is a table name.
        If object_type='C', this is a column name and is taken from part_name.
  Settings ... for Explorer
    Explorer Text Color | Background Color | Font -- As with other widgets, these can all be changed.
    Visible: yes|no. Default no. So if you don't change this to 'yes', there's nothing.
    Sort alphabetically: If 'yes', objects of the same type are sorted alphabetically. Default is 'no'.
                         This might be a bad idea that we'll remove, so always in order by how DBMS returns.
    Query: a long select with unions.
      The default query selects all databases.
      Users can change this query to add WHERE clauses. Affects MySQL/MariaDB only.
    Detached|Top|Left|Width|Height:
      As with other widgets, the explorer is detachable and the explorer's size + position are settable
      when it is detached.
      Unlike with other widgets, changing width to x has an effect even if the explorer is not detached.
      The default width depends on the widths of the object names.
  What users can do when explorer is visible:
    DoubleClick:
      This will copy the cell contents to the end of the statement widget
    Right Click: puts up a context menu.
      The relevant context is what row the mouse is over.
      For example if it's over a table, then table-related menu items will appear.
      The list of possible items is in the comment preceding menu_context_t_2_explorer.
  SET statements:
    ???? Remove this? SET ocelot_grid_cell_height=0 ... WHERE ...; causes matching rows to disappear, i.e. this is our "filter".
    New keywords begin with OCELOT_EXPLORER e.g. OCELOT_EXPLORER_DETACHED
    Important one: ocelot_visible='yes'|'no'
  REFRESH:
    A bit similar to REHASH, but this gets all schemas (databases) -- so has an effect on the server.
    REFRESH is necessary because we don't know when other users might change data definitions. And it's slow.
    Whenever users say REFRESH, the explorer tables are redone.
    In another product this would be done with a View menu.
  Options:
    New options: Detach|Attach explorer widget.
  The explorer widget is actually a grid widget with html.
  To users we want it to look like it's in same class as menu|history|grid|statement.
  Re navigation:
    The scroll bar is always present.
    We want effect of Up|Down to look the same as with Completer_widget::keyPressEvent
    but the mechanism is different: Change focus_result_row_number and call explorer_display_html,
    which will call copy_html_cell, which will change colour for result_grid->focus_result_row_number.
    So in Result_qtextedit::keyPressEvent(QKeyEvent *event) we arrange that if user presses Up key:
    If (we are at position 0)
      if scroll bar position == 0 do nothing
      else change scroll bar position, which requires explorer_display_html(new-position)
                                       which requires result_grid->grid_vertical_scroll_bar->setValue(n);
    Else
      change focus_result_row_number, it is 1 before where we were
    (If it's not EXPLORER_WIDGET then Up and Down are presumably within the edit area so that's a different path.)
  TODO: Tooltip changes. In fact that's true for result grid too.
        Could be "Explorer" + "Right-click for context menu" + "See Help|Explorer" + object type = Column, X, in table Y
        There could be SET ocelot_explorer_tooltip= ... WHERE ... as there is for grid.
  Todo: Something that shows referencing|referenced relationships of foreign keys, preferably visual.
        Add to query: something that gets us foreign keys.
  Todo: If you lack privileges for an object, you should gray some things in the menu.
        This would always be true if current database = information_schema.
  Todo: Pixmaps instead of Unicode characters for Down-pointing and Right-pointing triangle.
  Todo: Dialog box for Filter (can be done with query change)
  Todo: Dialog box for Sort (can be done with query change) (we already have Settings|Sort alphabetically)
  Todo: Help|Explorer widget, and change to README.
  Todo: example.cnf should have whatever the new options are.
  Todo: Drag and Drop: This would be for building a query.
  Todo: Check for leaks, and check for result-grid changes that cause items to be destroyed and re-created.
  Todo: When font changes or some other condition changes, or new USE, automatically adjust explorer.
        Actually font changes do have immediate effect.
  Todo: Start with visible, but just leave a message saying to look at Help|Explorer.
  Todo: Shortcut. For example, typing 'C' goes to the next thing that starts with 'C' (there's also ^F FInd).
  Todo: When you first display a result grid, there is a little blank. It's batch_text_edit.
        Should it be initially hidden for all result grid? I haven't decided yet.
  Todo: Hide the explorer widget if/when not connected.
  Todo: Your initial setup of upper_layout might be dangerous, check it more thoroughly.
        Search for calculations that depend on whole width, instead of main_window width.
        Check whether a change to grid settings will affect explorer_widget (usually yes).
  Todo: It's a bit unfortunate that explorer's abbreviation is 'S' for schema but rehash's is 'D' for database.
  Todo: "MIN" is not a wonderfulname. It should be short.
        There might be some standard term. Collapse? Tables only? Hide columns? Hide parts?
  explorer_refresh_caller():
    will do rehash_scan() (as if REHASH statement was executed), then fill up oei struc,
    so that when explorer_widget->show() happens there will be an explorer widget to show.
    There are several ways it can fail, which should cause a dialog box without showing.
  Todo: Usually when we change a Settings item the result is we generate a SET statement.
  TODO: explorer_refresh_caller() should merely give error dialog boxes if something is not ready.
        explorer_rehah() should give an error dialog box if rehash/refresh fails.
  Todo: user might set e.g. vertical or raw. make sure such settings have no effect on explorer widget
  Todo: we could say, instead of "C", "C(PK,FK,I)"
  Todo: ^C i.e. Copy should be possible on explorer cells
  Todo: SET ... WHERE column IS FOREIGN KEY | PRIMARY KEY | UNIQUE | INDEXED
        You can add a Filter combobox which generates the statement
        We only need to do it if there is a SET ocelot_grid_cell_height=0 statement
  Todo: example.cnf should include the new words, including ocelot_max_settings=n if you produce that
        (mainly we should fill in the blanks for the default colours and fonts)
        (now we do have ocelot_max_conditions)
  Todo: This initializes ocelot_explorer_query to MySQL default, but we need Tarantool default
        which might change upon re-connect.
  Todo: Now that everything is in object_name we lose a bit of ability compared with
        SET ocelot_grid_... WHERE column_name ... unless we say column_type='C' means something
  Todo: In Tarantool, how good it would be to have options for creating information_schema_tables etc.!
  Todo: There could be an ocelot_explorer_focus_cell_background_color as there is for grid_cell
  Todo: If font = Nimbus mono the height is too great, although with other fonts problem wasn't noticed.
  Todo: ostrings.h needs new items for explorer-related errors and settings
  Todo:  a main-menu "set focus" or at least "set visible" shortcut, (change to "hide" when it's visible)
  Todo: Add more one-keystroke controls for navigating in explorer
  Todo: Bug: If you use one of the export options, you wipe out anything done for an earlier TEE or
        export. Somehow you've got to restore them, and/or keep separate, and/or error if they're open.
*/
void MainWindow::initialize_widget_explorer()
{
  explorer_widget->explorer_initialize();
  oei= NULL;
  oei_count= 0;
  oei_fk= NULL;
  oei_fk_count= 0;
  /* Todo: Following is also what we do for ResultGrid in result_grid_add_tab. Reduce duplication? */
  explorer_widget->installEventFilter(this); /* must catch fontChange, show, etc. */
  explorer_widget->grid_vertical_scroll_bar->installEventFilter(this);
  explorer_widget->set_all_style_sheets(ocelot_explorer_style_string, 0, 0, false);
  /* Todo: Not sure where to put this. And it's wrong if Tarantool. Compare query of rehash_scan(). */
}

/*
  Called from: connect_init().
  After we connect or reconnect, we might need to change the query that we use for the explorer.
  Todo: Flaw: This will override any change that a user makes with Settings|Explorer.
        It might be better to have two ocelot_explorer_queries, one for Tarantool, one for MySQL/MariaDB.
  Todo: think harder about how to handle switch to a different DBMS
        There might be some things made for the previous DBMS that should be deleted now.
  Todo: If explorer_refresh fails, probably because we lack an important select privilege,
        mark that explorer is disabled and explain the problem.
  Todo: Temporarily I've set auto_rehash=0. Put it back in .my.cnf.
*/
void MainWindow::initialize_widget_explorer_after_connect()
{
#if (OCELOT_MYSQL_INCLUDE == 1)
  if ((connections_dbms[0] == DBMS_MYSQL) || (connections_dbms[0] == DBMS_MARIADB))
  ocelot_explorer_query= "select 'S',schema_name,schema_name,default_character_set_name,default_collation_name\n"
                 "from information_schema.schemata\n"
                 "union all\n"
                 "select 'T',table_schema,table_name,table_type,''\n"
                 "from information_schema.tables\n"
                 "union all\n"
                 "select 'C',table_schema,table_name,column_name,column_type\n"
                 "from information_schema.columns\n"
                 "union all\n"
                 "select 'I',table_schema,table_name,index_name,column_name\n"
                 "from information_schema.statistics\n"
                 "union all\n"
                 "select 'R',trigger_schema,trigger_name,'',''\n"
                 "from information_schema.triggers\n"
                 "union all\n"
                 "select 'F',routine_schema,routine_name,routine_type,''\n"
                 "from information_schema.routines\n"
                 "where routine_type = 'FUNCTION'\n"
                 "union all\n"
                 "select 'P',routine_schema,routine_name,routine_type,''\n"
                 "from information_schema.routines\n"
                 "where routine_type = 'PROCEDURE'\n"
                 "union all\n"
                 "select 'E',event_schema,event_name,'',''\n"
                 "from information_schema.events\n"
                 ";"
         ;
#endif
  if (connections_dbms[0] == DBMS_TARANTOOL)
    ocelot_explorer_query= "select 'S','main','','',//\n"
                   "union all\n"
                   "select 'C',table_schema,table_name,column_name,data_type\n"
                   "from _columns\n"
                   "union all\n"
                   "select 'T',table_schema,table_name,table_type,''\n"
                   "from _tables;"
    ;
  char error_or_ok_message[1024];
  if (ocelot_explorer_visible  == "yes") explorer_refresh_caller(error_or_ok_message);
}


/*
  Todo:
  !! DELETE oei IF YOU SAID NEW! (no, we don't do that unless user decides to remove the whole thing)
  Method:
    Call rehash_scan with alternate_query <> NULL.
    Set up oei.
    REHASH initially calls rehash_scan with alternate_query == NULL, because we might have wrecked things for autocomplete.
    Todo #1: The second rehash_scan call is only necessary if there was a difference but we fail to check.
    Todo #2: It would be so much nicer if rehash_scan didn't have so many globals.
    Todo #3: we have flag, and if ((flag & FIELD_VALUE_FLAG_IS_NULL) != 0) might be true, but we don't use it
    Todo #5: if failure, should not be visible, eh? we fail to check for failure of explorer_display()
    Todo #6: REFRESH; statement causes this. Therefore it jumps back to 0 on the scroll bar.
             With explorer_toggle(): we could assume that scroll bar position is unchanged.
             Ideally we could try to find the same item again, and if we fail then retreat to most-recent item
             of the same type or of upper type in the hierarchy, but that gets complicated, especially if there
             has been collapsing and filtering.
*/
int MainWindow::explorer_refresh_caller(char *error_or_ok_message)
{
  int rehash_scan_result= explorer_refresh(error_or_ok_message);
  if (rehash_scan_result != ER_OK_REHASH) return rehash_scan_result; /* Todo: does user see this result? */
  explorer_widget->explorer_display();  /* effectively: explorer_display_html(0) */
  explorer_widget->show();
  return ER_OK_REHASH;
}

/*
  Execute the default query (or whatever user changed to in Settings|Explorer), create struct explorer_items oei.
  This requires SELECT ... FROM INFORMATION_SCHEMA with many UNIONS, which is also what we have to do for
  handling autocomplete, which is what rehash_scan() is for. But currently we're doing a different SELECT,
  so we always will call rehash() twice, once for autocomplete use, once for explorer use.
SET ocelot_explorer_visible='yes'; -- if already visible: depends whether something else changed, but that's a bit hard to know
                                    if not already visible: rehash
Menu context edit menu rehash:        REFRESH
REFRESH:                              explorer_refresh if ocelot_explorer_visible='yes'
--auto_rehash:                        affects REHASH not REFRESH
After explorer_refresh, vertical scroll bar should go back to start

Called from: execute_client_statement if (statement == REFRESH;)
Called from: explorer_refresh_caller() which is due to OCELOT_EXPLORER_VISIBLE='yes' or a choice on context menu
  Method:
    For each schema
      For each item of this schema
        If "T" or "V"
          add to oei
          For each item
            If "C" of this "T":
              add to oei
            If "I" of this "T":
              add to oei
        If "R" or "P" or "E" or "F":
          add to oei (these will come last because of the way the UNION was done)
  TODO: For rehash_scan_for_tarantool(), if explorer:
        We should ignore what is not in the query, e.g. if user decided not to get 'I', or added a 'WHERE'.
  Todo: Maybe we can throw away the result set as soon as we have the oei.
  Todo: Since refresh including qsort can take a second on an almost minimal information_schema,
        think of ways to speed up. E.g. check last update to see whether a change happened,
        make a special qsort table so each swap becomes smaller, assume system tables won't change,
        take advantage of all things of same type being together initially (I think).
*/
int MainWindow::explorer_refresh(char *error_or_ok_message)
{
  log("explorer_refresh start", 65);
  if (ocelot_explorer_visible == "no")
  {
    strcpy(error_or_ok_message, "REFRESH only works if explorer is visible. To make it visible, use Settings|Explorer or SET ocelot_explorer_visible='yes';");
    return ER_ERROR;
  }
  int rehash_scan_result;
  unsigned int saved_rehash_result_row_count= result_row_count;
  rehash_scan_result= rehash_scan(error_or_ok_message, ocelot_explorer_query); /* instead of "" */
  if (strncmp(error_or_ok_message, "OK", 2) != 0)
  {
    return rehash_scan_result;
  }
  if (oei != NULL)
  {
    delete [] oei;
    oei_count= 0;
    oei= NULL;
  }
  if (oei_fk != NULL)
  {
    delete [] oei_fk;
    oei_fk_count= 0;
    oei_fk= NULL;
  }
  long unsigned int r;
  char *row_pointer;
  unsigned int column_length;
  unsigned int i;

  /* Something like what happens in rehash_search(). */
  /* ?? Maybe you should have a limit on the size, like SQL Server does (65535). */
  /* todo: "* 2" is too much, you only need to allow for adding "T", which should mean nothing. */
  /*       COMMENT ON THIS TODO: ???? in fact maybe we don't even need *2 any more, eh? */
  oei= new explorer_items[rehash_result_row_count * 2];
#ifdef DBMS_TARANTOOL
  if (connections_dbms[0] == DBMS_TARANTOOL)
  {
    oei[oei_count].object_type= "S"; /* Tarantool has no schemas but we'll pretend with a dummy named "main" */
    oei[oei_count].schema_name= "main";
    oei[oei_count].object_name= "main";
    oei[oei_count].part_name= "";
    oei[oei_count].part_type= "";
    oei[oei_count].flags= EXPLORER_FLAG_MIN;
    ++oei_count;
    for (int i= 0; i < tarantool_table_names.count(); ++i)
    {
      oei[oei_count].object_type= "T";
      oei[oei_count].schema_name= "main";
      oei[oei_count].object_name= tarantool_table_names.at(i).toUtf8();
      oei[oei_count].part_name= tarantool_table_engines.at(i).toUtf8();
      oei[oei_count].part_type= "";
      oei[oei_count].flags= EXPLORER_FLAG_MIN;
      ++oei_count;
    }
    for (int i= 0; i < tarantool_column_names.count(); ++i)
    {
      oei[oei_count].object_type= "C";
      oei[oei_count].schema_name= "main";
      oei[oei_count].object_name= tarantool_column_table_names.at(i).toUtf8();
      oei[oei_count].part_name= tarantool_column_names.at(i).toUtf8();
      oei[oei_count].part_type= tarantool_type_names.at(i).toUtf8();
      oei[oei_count].flags= EXPLORER_FLAG_MIN;
      ++oei_count;
    }
    for (int i= 0; i < tarantool_index_names.count(); ++i)
    {
      QString c= "";
      int counter= 0;
      int index_column_number= tarantool_index_column_numbers.at(i).toInt();
      for (int j= 0; j < tarantool_column_names.count(); ++j)
      {
        if (tarantool_index_table_names.at(i) == tarantool_column_table_names.at(j))
        {
          if (counter == index_column_number)
          {
            c= tarantool_column_names.at(j);
            break;
          }
          ++counter;
        }
      }
      oei[oei_count].object_type= "I";
      oei[oei_count].schema_name= "main";
      oei[oei_count].object_name= tarantool_index_table_names.at(i).toUtf8();
      oei[oei_count].part_name= tarantool_index_names.at(i).toUtf8();
      oei[oei_count].part_type= c.toUtf8();
      oei[oei_count].flags= EXPLORER_FLAG_MIN;
      ++oei_count;
    }
    for (int i= 0; i < tarantool_trigger_names.count(); ++i)
    {
      oei[oei_count].object_type= "R";
      oei[oei_count].schema_name= "main";
      oei[oei_count].object_name= tarantool_trigger_names.at(i).toUtf8();
      oei[oei_count].part_name= "";
      oei[oei_count].part_type= "";
      oei[oei_count].flags= EXPLORER_FLAG_MIN;
      ++oei_count;
    }
    for (int i= 0; i < tarantool_fk_constraint_names.count(); ++i)
    {
      /* I'm not sure we really need to do anything with this */
    }
  }
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
  if (connections_dbms[0] != DBMS_TARANTOOL)
  {
    for (r= 0; r < rehash_result_row_count; ++r)
    {
      row_pointer= rehash_result_set_copy_rows[r];
      for (i= 0; i < rehash_result_column_count; ++i)
      {
        memcpy(&column_length, row_pointer, sizeof(unsigned int));
        //char flag= *(row_pointer + sizeof(unsigned int));
        row_pointer+= sizeof(unsigned int) + sizeof(char);
        /* Now row_pointer points to contents, length has # of bytes */
        {
          if (i == 0) oei[oei_count].object_type= QByteArray(row_pointer, column_length);
          if (i == 1) oei[oei_count].schema_name= QByteArray(row_pointer, column_length);
          if (i == 2) oei[oei_count].object_name= QByteArray(row_pointer, column_length);
          if (i == 3) oei[oei_count].part_name= QByteArray(row_pointer, column_length);
          if (i == 4) oei[oei_count].part_type= QByteArray(row_pointer, column_length);
          if (i == 5) oei[oei_count].part_extra= QByteArray(row_pointer, column_length);
          if (i == rehash_result_column_count - 1) /* i.e. if now we have all columns */
          {
            oei[oei_count].flags= EXPLORER_FLAG_MIN;
            ++oei_count;
          }
        }
        row_pointer+= column_length;
      }
    }
  }
#endif
  //explorer_widget->hide(); /* Is this necessary? */
  /* this is in the initialize function */
  explorer_sort();

  /* Todo: Move this I guess */
  if (connections_dbms[0] == DBMS_TARANTOOL)
  {
    unsigned int tarantool_fk_constraint_names_count= tarantool_fk_constraint_names.count();
    oei_fk= new explorer_items_fk[tarantool_fk_constraint_names_count];
    for (oei_fk_count= 0; oei_fk_count < tarantool_fk_constraint_names_count; ++oei_fk_count)
    {
      oei_fk[oei_fk_count].schema_name= "main";
      QString s= tarantool_fk_constraint_child_ids.at(oei_fk_count);
      int i_of_child_table= tarantool_table_ids.indexOf(s);
      oei_fk[oei_fk_count].table_name= tarantool_table_names.at(i_of_child_table).toUtf8();
      oei_fk[oei_fk_count].column_name= "?";
      oei_fk[oei_fk_count].ordinal_position= "1"; /* Might be multiple child_cols or parent_cols but okay */
      s= tarantool_fk_constraint_parent_ids.at(oei_fk_count);
      int i_of_parent_table= tarantool_table_ids.indexOf(s);
      oei_fk[oei_fk_count].referenced_table_name= tarantool_table_names.at(i_of_parent_table).toUtf8();
      oei_fk[oei_fk_count].referenced_column_name= "?";
      oei_fk[oei_fk_count].constraint_name= tarantool_fk_constraint_names.at(oei_fk_count).toUtf8();
    }
  }
  if (connections_dbms[0] != DBMS_TARANTOOL)
  {
    /* Todo: Maybe better to do it with order by constraint_name? */
    QString ocelot_explorer_query_fk= "SELECT table_schema, table_name, column_name, ordinal_position,\n"
                 "referenced_table_name,referenced_column_name, constraint_name\n"
                 "FROM information_schema.key_column_usage \n"
                 "ORDER BY table_schema, table_name;"
    ;
    rehash_scan_result= rehash_scan(error_or_ok_message, ocelot_explorer_query_fk); /* instead of "" */
    if (strncmp(error_or_ok_message, "OK", 2) != 0)
    {
      return rehash_scan_result;
    }
    oei_fk_count= 0;
    oei_fk= new explorer_items_fk[rehash_result_row_count];
    for (r= 0; r < rehash_result_row_count; ++r)
    {
      row_pointer= rehash_result_set_copy_rows[r];
      for (i= 0; i < rehash_result_column_count; ++i)
      {
        memcpy(&column_length, row_pointer, sizeof(unsigned int));
        //char flag= *(row_pointer + sizeof(unsigned int));
        row_pointer+= sizeof(unsigned int) + sizeof(char);
        /* Now row_pointer points to contents, length has # of bytes */
        {
          if (i == 0) oei_fk[oei_fk_count].schema_name= QByteArray(row_pointer, column_length);
          if (i == 1) oei_fk[oei_fk_count].table_name= QByteArray(row_pointer, column_length);
          if (i == 2) oei_fk[oei_fk_count].column_name= QByteArray(row_pointer, column_length);
          if (i == 3) oei_fk[oei_fk_count].ordinal_position= QByteArray(row_pointer, column_length);
          if (i == 4) oei_fk[oei_fk_count].referenced_table_name= QByteArray(row_pointer, column_length);
          if (i == 5) oei_fk[oei_fk_count].referenced_column_name= QByteArray(row_pointer, column_length);
          if (i == 6) oei_fk[oei_fk_count].constraint_name= QByteArray(row_pointer, column_length);
          if (i == rehash_result_column_count - 1) /* i.e. if now we have all columns */
          {
            ++oei_fk_count;
          }
        }
        row_pointer+= column_length;
      }
    }
    /* If we wrecked the global rehash_scan result that's used ordinarily we'll have to call rehash_scan again. */
    if (saved_rehash_result_row_count != 0) rehash_scan(error_or_ok_message, "");
    else rehash_garbage_collect();
  }
  log("explorer_refresh end", 65);
  return ER_OK_REHASH;
}

/*
  Call this if something has changed which might affect the look of an explorer, possibly including table header.
  * condition changed so each "E%n" div must change
  * ocelot_max_conditions changed to a smaller number
  Todo: error is possible, something should be returned.
  Todo: Consider calling from ocelot_variable_set() if font change, currently we change the font due to
        style sheet change but not the widget width. On the other hand, that causes displaying twice.
*/
void MainWindow::explorer_show_after_change()
{
  explorer_widget->prepare_for_display_html();
  if (explorer_widget->isVisible() == false) return;
  int gvsbv= explorer_widget->grid_vertical_scroll_bar_value;
  explorer_widget->explorer_display_html(gvsbv);
}

/*
  E.g.
    "S","information_schema",'',''
      "T","information_schema","Table-Name",""
        "C","information_schema","Table-Name","Part-Name",
        "I","information_schema","Table-Name","Part-Name",
  Case Sensitive
  Alternative: If user chose "definition order", return diff-of-row-number when names are different
  Possible enhancement: allow for case-insensitive sorting
*/
int static explorer_qsort_compare(const void *a, const void *b)
{
  struct explorer_items ea= *(struct explorer_items *) a;
  struct explorer_items eb= *(struct explorer_items *) b;
  int schema_comparison_result= QString::compare(ea.schema_name, eb.schema_name, Qt::CaseInsensitive);
  if (schema_comparison_result != 0) return schema_comparison_result;
  /* same schema name */
  //if (ea.object_type == "S") return -1;
  //if (eb.object_type == "S") return +1;
  int ea_main_number, eb_main_number;
  if (ea.object_type == "S") ea_main_number= 0;
  else if ((ea.object_type == "T") || (ea.object_type == "V") || (ea.object_type == "C") || (ea.object_type == "I")) ea_main_number= 1;
  else if (ea.object_type == "F") ea_main_number= 2;
  else if (ea.object_type == "P") ea_main_number= 3;
  else if (ea.object_type == "E") ea_main_number= 4;
  else ea_main_number= 5; /* presumably "t" */
  if (eb.object_type == "S") eb_main_number= 0;
  else if ((eb.object_type == "T") || (eb.object_type == "V") || (eb.object_type == "C") || (eb.object_type == "I")) eb_main_number= 1;
  else if (eb.object_type == "F") eb_main_number= 2;
  else if (eb.object_type == "P") eb_main_number= 3;
  else if (eb.object_type == "E") eb_main_number= 4;
  else eb_main_number= 5; /* presumably "R" */
  if (ea_main_number != eb_main_number) return ea_main_number - eb_main_number;
  /* ... so main numbers are the same ... */
  int object_comparison_result= QString::compare(ea.object_name, eb.object_name, Qt::CaseInsensitive);
  if (object_comparison_result != 0) return object_comparison_result;
  /* ... so object names are the same, which should only occur for T|V and C|I ... */
  int ea_part_type, eb_part_type;
  if ((ea.object_type == "T") || (ea.object_type == "V")) ea_part_type= 0;
  else if (ea.object_type == "C") ea_part_type= 1;
  else ea_part_type= 2; /* presumably "I" */
  if ((eb.object_type == "T") || (eb.object_type == "V")) eb_part_type= 0;
  else if (eb.object_type == "C") eb_part_type= 1;
  else eb_part_type= 2; /* presumably "I" */
  if (ea_part_type != eb_part_type) return ea_part_type - eb_part_type;
  /* ... so schema name and object name and type are the same ... */
  return QString::compare(ea.part_name, eb.part_name, Qt::CaseInsensitive);
}

/*
  Given oei that we produce in explorer_refresh(), sort so there is a hierarchy:
    schema -> object -> part, specifically 'C' and 'I' are under 'T' or 'V',
    and alphabetic within the hierarchy unless Settings|explorer said to keep defined order.
    Saying explorer_sort == "no" might be slightly faster and preserves column-definition order within table.
  Todo: Perhaps 't' should be under 'T' too.
  Todo: There could be more ways to sort.
*/
void MainWindow::explorer_sort()
{
  log("explorer_sort start", 65);

  for (unsigned int i= 0; i < oei_count; ++i)
  {
    if (oei[i].object_type == "T")
    {
      bool is_view= false;
      if ((connections_dbms[0] == DBMS_MARIADB) || (connections_dbms[0] == DBMS_MYSQL))
      {
        if (oei[i].part_name == "VIEW") /* i.e. not BASE TABLE | SYSTEM VIEW | SYSTEM VERSIONED */
          is_view= true;
      }
      else /* presumably == DBMS_TARANTOOL */
      {
        /* Todo: This only checks for user-created views starting with CREATE. Why not "sysview"? */
        QString s= QString(oei[i].part_name);
        if (s.startsWith("create", Qt::CaseInsensitive))
          is_view= true;
      }
      if (is_view)
      {
        oei[i].object_type= "V";
      }
    }
  }

  if (ocelot_explorer_sort == "yes")
  {
    qsort(oei, oei_count, sizeof(struct explorer_items), explorer_qsort_compare);
    log("explorer_sort end", 65);
    return;
  }
  explorer_items *oei_copy;
  oei_copy= new explorer_items[oei_count];
  unsigned int i_of_copy= 0;

  for (unsigned int i_of_schema= 0; i_of_schema < oei_count; ++i_of_schema)
  {
    if (oei[i_of_schema].object_type != "S") break; /* This assumes that schemas precede all other types */
    oei_copy[i_of_copy++]= oei[i_of_schema];
    for (unsigned int i_of_main= 0; i_of_main < oei_count; ++i_of_main)
    {
      if (oei[i_of_main].schema_name == oei[i_of_schema].schema_name)
      {
        if ((oei[i_of_main].object_type == "T") || (oei[i_of_main].object_type == "V"))
        {
          oei_copy[i_of_copy++]= oei[i_of_main];
          for (unsigned int i_of_column= 0; i_of_column < oei_count; ++i_of_column)
          {
            if ((oei[i_of_column].object_type == "C")
             && (oei[i_of_column].object_name == oei[i_of_main].object_name)
             && (oei[i_of_column].schema_name == oei[i_of_schema].schema_name))
              oei_copy[i_of_copy++]= oei[i_of_column];
          }
          for (unsigned int i_of_index= 0; i_of_index < oei_count; ++i_of_index)
          {
            if ((oei[i_of_index].object_type == "I")
             && (oei[i_of_index].object_name == oei[i_of_main].object_name)
             && (oei[i_of_index].schema_name == oei[i_of_schema].schema_name))
              oei_copy[i_of_copy++]= oei[i_of_index];
          }
        } /* closes if (oei[i_of_main].object_type == "T") */
        else if ((oei[i_of_main].object_type == "P")
              || (oei[i_of_main].object_type == "F")
              || (oei[i_of_main].object_type == "R")
              || (oei[i_of_main].object_type == "E"))
                oei_copy[i_of_copy++]= oei[i_of_main];
      } /* closes if (oei[i_of_main].schema_name == oei[i_of_schema].schema_name) */
    } /* closes i_of_main loop */
  } /* closes i_of_schema  loop */
  for (unsigned int i= 0; i < oei_count; ++i) oei[i]= oei_copy[i];

  delete [] oei_copy;

  /* Check */
  //for (unsigned int i= 0; i < oei_count; ++i)
  //{
  //  char tmp0[256]; strcpy(tmp0, oei[i].object_type);
  //  char tmp1[256]; strcpy(tmp1, oei[i].schema_name);
  //  char tmp2[256]; strcpy(tmp2, oei[i].object_name);
  //  char tmp3[256]; strcpy(tmp3, oei[i].part_name);
  //  printf("%s %s.%s.%s\n", tmp0,tmp1,tmp2,tmp3);
  //}
  log("explorer_sort end", 65);
}

/*
  The idea of "query" is that users can go to Settings to change the big union statement for rehash_scan()
  So far we're always returning true = OK.
  Todo: Any way to call hparse_f and reformat?
  Todo: Probably here we should check that the query has proper form e.g. selects the right number of columns.
*/
bool MainWindow::explorer_query()
{
  ;
  return true;
}

/*
  Called from hparse_f_client_statement after SET ... WHERE ocelot_explorer_text=
  For explorer the possible text values are all the oei items (explorer widget) and all the cmi items
  (explorer context menu).
  Todo: This isn't precise enough, we should be looking at part_name part_type etc.
*/
QStringList MainWindow::explorer_text_list()
{
  QStringList q;
  q.clear(); /* unnecessary? */
  for (int i= 0; i < explorer_widget->html_text_edit->explorer_context_menu->cmi_count; ++i)
    q.append(explorer_widget->html_text_edit->explorer_context_menu->cmi[i].text);
  for (unsigned int i= 0; i < oei_count; ++i)
  {
    q.append(oei[i].object_name);
  }
  return q;
}

/* Todo: This could be called when we're shutting down (?). Clean up anything made with new. */
void MainWindow::explorer_close()
{
  ;
}

/*
  In order to do a query for explorer for Tarantool, we need an information_schema equivalent.
  Luckily I produced one when working for Tarantool:
  https://www.tarantool.io/en/doc/latest/reference/reference_sql/sql_plus_lua/#sql-lua-functions
  But it can fail if some privilege is missing.
*/
//void MainWindow::make_information_schema()
//{
//}


/* Todo: Add: a function for destroying all objects created for the widget (though not the widget itself?) */

#endif //if (OCELOT_EXPLORER == 1)

#ifdef DBMS_TARANTOOL
#if (OCELOT_THIRD_PARTY==1)
#define OCELOT_THIRD_PARTY_CODE
  #include "third_party.h"
#endif
#endif


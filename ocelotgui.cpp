/*
  ocelotgui -- GUI Front End for MySQL or MariaDB

   Version: 2.3.0
   Last modified: May 30 2024
*/
/*
  Copyright (c) 2024 by Peter Gulutzan. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
*/

/*
   The class named CodeEditor inside the ocelotgui program is taken and modified from
   http://qt-project.org/doc/qt-4.8/widgets-codeeditor.html
   and therefore CodeEditor's maker's copyright and BSD license provisions
   are reproduced below. These provisions apply only for the
   part of the CodeEditor class which is included by #include "codeeditor.h".
   The program as a whole is copyrighted by Peter Gulutzan and
   licensed under GPL version 2 as stated above.
 **
 ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
 ** Contact: http://www.qt-project.org/legal
 **
 ** $QT_BEGIN_LICENSE:BSD$
 **
 ** "Redistribution and use in source and binary forms, with or without
 ** modification, are permitted provided that the following conditions are
 ** met:
 **   * Redistributions of source code must retain the above copyright
 **     notice, this list of conditions and the following disclaimer.
 **   * Redistributions in binary form must reproduce the above copyright
 **     notice, this list of conditions and the following disclaimer in
 **     the documentation and/or other materials provided with the
 **     distribution.
 **   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names
 **     of its contributors may be used to endorse or promote products derived
 **     from this software without specific prior written permission.
 **
 **
 ** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 ** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 ** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 ** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 ** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 ** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 ** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
 **
 ** $QT_END_LICENSE$
*/

#if (OCELOT_MYSQL_DEBUGGER == 1)
/*
  The routine named debug_mdbug_install inside this program is taken and modified from
  https://launchpad.net/mdbug, specifically http://bazaar.launchpad.net/~hp-mdbug-team/mdbug/trunk/view/head:/install.sql,
  and therefore MDBug's maker's copyright and GPL version 2 license provisions
  are reproduced below. These provisions apply only for the
  part of the debug_mdbug_install routine which is marked within the program.
  The program as a whole is copyrighted by Peter Gulutzan and
  licensed under GPL version 2 as stated above.

  This file is part of MDBug.

  (c) Copyright 2012 Hewlett-Packard Development Company, L.P.

  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; version 2 of the License.

  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

  You should have received a copy of the GNU General Public License along with this program; if not, see
  <http://www.gnu.org/licenses>.

  Linking MDBug statically or dynamically with other modules is making a combined work based on MDBug. Thus, the terms and
  conditions of the GNU General Public License cover the whole combination.

  In addition, as a special exception, the copyright holders of MDBug give you permission to combine MDBug with free
  software programs or libraries that are released under the GNU LGPL and with code included in the standard release
  of Eclipse under the Eclipse Public License version 1.0 (or modified versions of such code, with unchanged license).
  You may copy and distribute such a system following the terms of the GNU GPL for MDBug and the licenses of the other
  code concerned, provided that you include the source code of that other code when and as the GNU GPL requires
  distribution of source code.

  Note that people who make modified versions of MDBug are not obligated to grant this special exception for their
  modified versions; it is their choice whether to do so. The GNU General Public License gives permission to release a
  modified version without this exception; this exception also makes it possible to release a modified version which
  carries forward this exception.
*/
#endif

/*
  On Windows, ocelotgui is statically linked with libraries
  MariaDB Connector C and Qt. See COPYING.thirdparty.
*/

/*
  General comments

  These are comments about the code.
  The user manual and blog comments are elsewhere; look at README.htm or README.md or manual.htm
  or README.txt or ocelot.ca or ocelot.ca/blog or the repository that
  this program was downloaded from, probably github.com/ocelot-inc/ocelotgui.

  The code files are:
    ocelotgui.pro       small. used by Qt qmake
    ocelotgui.h         headers but no executable
    ocelotgui.cpp       executable
    install_sql.cpp     for creating debugger routines
    ocelotgui.ui        small. used to make ui_ocelotgui.h
    codeeditor.h        small. separated so license applicability is clear
    hparse.h            the recognizer
    ostrings.h          strings that contain English translatable text
    third_party.h       from tarantool-c, If cmake . -DOCELOT_THIRD_PARTY=0 then #include third_party.h won't happen

  There are three main widgets, which generally appear top-to-bottom on
  the screen: history_edit_widget = an uncomplicated text edit which gets
  retired statements and diagnostic messages; statement_edit_widget =
  a class derived from text edit ("CodeEditor") which has code for a
  prompt on the left and for syntax highlighting; result_grid_table_widget =
  a class derived from widget ("ResultGrid") which has code for tabular
  display of a result set and manipulation thereof. The result grid is
  not based on Qt's high-level tools like QTableView, it is constructed
  from basic building blocks (scroll bars and repeatedly-occurring
  QTextEdits within QFrames). There is no use of Qt's "MySQL driver".
  The code includes a tokenizer and recognizer for MySQL syntax.
  The coding style is generally according to MySQL coding guidelines
  http://dev.mysql.com/doc/internals/en/coding-guidelines.html
  but lines may be long, and sometimes spaces occur at ends of lines,
  and "if (x) y" may be preferred to "if (x) <newline> y".

  The code was written by Peter Gulutzan, except
  for about 50 lines in the codeeditor.h CodeEditor section (Digia copyright / BSD license),
  and except for most of the lines in install_sql.cpp (HP copyright / GPL license).
  Other contributors will be acknowledged here and/or in a "Help" display.

  The code #includes header files from MySQL/Oracle and from Qt/Digia,
  and may rely on MySQL or MariaDB libraries if it connects to MySQL or MariaDB servers,
  and relies on the Qt core, gui, and widgets libraries.
  Builds have been successful with several Linux distros and gcc 4.6/4.7/7.3.
  Build instructions are in the user manual or in a readme file.

  There are many comments. Searching for the word "Todo:" in the comments
  will give some idea of what's especially weak and what's planned.

  UTF8 Conversion
  Everything which will be passed to MySQL will first be converted to UTF8.
  Todo: Ensure that sending/receiving character set is UTF8, regardless of data language.
        Currently we do say ocelot_set_charset_name= "utf8"; which is passed to mysql_options()
        but the user can explicitly override that.
  Todo: When receiving, only convert characters, not binary or numeric.
  Todo: Handle Qt codecs for other character sets.
  Todo: Figure out how to handle a literal preceded by an _introducer.
  A typical set of instructions will look like this and have the comment
  "See comment "UTF8 Conversion".
     int tmp_len= QStr.toUtf8().size());                  ... See how big UTF8 will be
     char *tmp= new char[tmp_len + 1];                      ... Allocate that amount
     memcpy(tmp, QStr.toUtf8().constData()), tmp_len + 1);  ... Copy including trail '\0' byte
     ... And later, say "delete []tmp" or hope for garbage collection

  Todo: when I started, I wasn't aware that I could say
        QString::fromUtf8 to copy a C string to a QString.
        So there are several places where I copy to another temporary
        C string and then assign. Such code should be replaced.

  Todo: Allow right-click for changing individual widgets.

  See end of program for comments re valgrind.

  The usual ways to build are described in README.htm (copied to README.md or README.txt).
  An unusual way would be with Qt 4.8 source-code libraries supplied by Digia:
      Download 4.8 libraries via http://qt-project.org/downloads
         This is a source download; you'll need to do ./configure and make.
         Follow instructions in http://qt-project.org/doc/qt-4.8/install-x11.html
         After make and make install you'll have /usr/local/Trolltech/Qt-4.8.6
         At this point I got totally stuck with Qt Creator -- it refused to try to build with Qt 4.8.
         And yes, I changed the kit, I changed the paths, but it was all a waste of a lot of time.
         Well, if anyone else succeeds, let me know.
         But I "succeeded" by exiting Qt Creator, creating a new make file, and building from the shell.
         (I copy and then remove ui_ocelotgui.h, which may or may not have some importance that I missed.)
         cd ~/ocelotgui
         mv ui_ocelotgui.h ui_ocelotgui.h.bak
         /usr/local/Trolltech/Qt-4.8.6/bin/qmake ocelotgui.pro
         make
        ./ocelotgui
        That ruins what Qt Creator expects when I get back to Qt Creator, so I get back to 5.1 with:
        cd ~/ocelotgui
        /home/pgulutzan/Qt/5.1.1/gcc_64/bin/qmake ./ocelotgui.pro
        mv ui_ocelotgui.h ui_ocelotgui.h.bak
        rm ui_ocelotgui.h
        make (ignore failure)
        re-enter Qt Creator. Build | Clean all. Build all. Run.
*/

#define MYSQL_MAIN_CONNECTION 0
#define MYSQL_DEBUGGER_CONNECTION 1
#define MYSQL_KILL_CONNECTION 2
#define MYSQL_REMOTE_CONNECTION 3
#define MYSQL_MAX_CONNECTIONS 4

#include "ostrings.h"
#include "ocelotgui.h"
#include "ui_ocelotgui.h"

/* Whenever you see STRING_LENGTH_512, think: here's a fixed arbitrary allocation, which should be be fixed up. */
#define STRING_LENGTH_512 512

/* MAX_HPARSE_ERRMSG_LENGTH should be enough for all keywords that begin with "OCELOT_" */
#define MAX_HPARSE_ERRMSG_LENGTH 4440

static struct connect_arguments ocelot_ca {
  .host_as_utf8= 0,
  .database_as_utf8= 0,
  .user_as_utf8= 0,
  .password_as_utf8= 0,
  .port= MYSQL_PORT,
  .unix_socket_as_utf8= 0,
  .protocol_as_int= 0,
  .init_command_as_utf8= 0,
  .abort_source_on_error= 0,
  .auto_rehash= 1,
  .auto_vertical_output= 0,
  .batch= 0,
  .binary_mode= 0,
  .set_charset_dir_as_utf8= 0,
  .result_grid_column_names= 1,
  .column_type_info= 0,
  .comments= 0,
  .opt_compress= 0,
  .opt_connect_timeout= 0,
  .debug_check= 0,
  .debug_info= 0,
  .default_auth_as_utf8= 0,
  .set_charset_name_as_utf8= 0,
  .enable_cleartext_plugin= 0,
  .force= 0,
  .help= 0,
  .history_hist_file_is_open= false,
  .history_hist_file_is_copied= false,
  .html= 0,
  .ignore_spaces= 0,
  .line_numbers= 0,
  .opt_local_infile= 0,
  .log_level= 100,
  .max_conditions= 5,
  .max_allowed_packet= 16777216,
  .max_join_size= 1000000,
  .named_commands= 0,
  .net_buffer_length= 16384,
  .no_beep= 0,
  .no_defaults= 0,
  .one_database= 0,
  .pipe= 0,
  .plugin_dir_as_utf8= 0,
  .print_defaults= 0,
  .prompt_is_default= true,
  .quick= 0,
  .raw= 0,
  .opt_reconnect= 0,
  .safe_updates= 0,
  .secure_auth= 1,
  .select_limit= 0,
  .server_public_key_as_utf8= 0,
  .shared_memory_base_name_as_utf8= 0,
  .history_includes_warnings= 0,
  .sigint_ignore= 0,
  .silent= 0,
  .opt_ssl_as_utf8= 0,
  .opt_ssl_ca_as_utf8= 0,
  .opt_ssl_capath_as_utf8= 0,
  .opt_ssl_cert_as_utf8= 0,
  .opt_ssl_cipher_as_utf8= 0,
  .opt_ssl_crl_as_utf8= 0,
  .opt_ssl_crlpath_as_utf8= 0,
  .opt_ssl_key_as_utf8= 0,
  .opt_ssl_mode_as_utf8= 0,
  .opt_ssl_verify_server_cert= 0,
  .syslog= 0,
  .table= 0,
  .history_tee_file_is_open= false,
  .unbuffered= 0,
  .verbose= 0,
  .version= 0,
  .vertical= 0,
  .wait= 0,
  .xml= 0,
  .bar= 0,
  .line= 0,
  .pie= 0,
  .opt_can_handle_expired_passwords= 1,
  .opt_bind_as_utf8= 0,
  .opt_connect_attr_delete_as_utf8= 0,
  .opt_connect_attr_reset= 0,
  .read_default_file_as_utf8= 0,
  .read_default_group_as_utf8= 0,
  .opt_read_timeout= 0,
  .report_data_truncation= 0,
  .opt_use_result= 0,
  .grid_tabs= 16,
  .grid_actual_tabs= 0,
  .client_side_functions= 1,
  .completer_timeout= 10,
  .shortcut_connect= {'d','e','f','a','u','l','t',0},
  .shortcut_exit= {'d','e','f','a','u','l','t',0},
  .shortcut_undo= {'d','e','f','a','u','l','t',0},
  .shortcut_redo= {'d','e','f','a','u','l','t',0},
  .shortcut_cut= {'d','e','f','a','u','l','t',0},
  .shortcut_copy= {'d','e','f','a','u','l','t',0},
  .shortcut_paste= {'d','e','f','a','u','l','t',0},
  .shortcut_select_all= {'d','e','f','a','u','l','t',0},
  .shortcut_history_markup_previous= {'d','e','f','a','u','l','t',0},
  .shortcut_history_markup_next= {'d','e','f','a','u','l','t',0},
  .shortcut_format= {'d','e','f','a','u','l','t',0},
  .shortcut_zoomin= {'d','e','f','a','u','l','t',0},
  .shortcut_zoomout= {'d','e','f','a','u','l','t',0},
  .shortcut_autocomplete= {'d','e','f','a','u','l','t',0},
  .shortcut_find= {'d','e','f','a','u','l','t',0},
  .shortcut_execute= {'d','e','f','a','u','l','t',0},
  .shortcut_kill= {'d','e','f','a','u','l','t',0},
  .shortcut_next_window= {'d','e','f','a','u','l','t',0},
  .shortcut_previous_window= {'d','e','f','a','u','l','t',0},
#if (OCELOT_MYSQL_DEBUGGER == 1)
  .shortcut_breakpoint= {'d','e','f','a','u','l','t',0},
  .shortcut_continue= {'d','e','f','a','u','l','t',0},
  .shortcut_next= {'d','e','f','a','u','l','t',0},
  .shortcut_step= {'d','e','f','a','u','l','t',0},
  .shortcut_clear= {'d','e','f','a','u','l','t',0},
  .shortcut_debug_exit= {'d','e','f','a','u','l','t',0},
  .shortcut_information= {'d','e','f','a','u','l','t',0},
  .shortcut_refresh_server_variables= {'d','e','f','a','u','l','t',0},
  .shortcut_refresh_user_variables= {'d','e','f','a','u','l','t',0},
  .shortcut_refresh_variables= {'d','e','f','a','u','l','t',0},
  .shortcut_refresh_call_stack= {'d','e','f','a','u','l','t',0},
#endif
  .shortcut_batch= {'d','e','f','a','u','l','t',0},
  .shortcut_chart_bar= {'d','e','f','a','u','l','t',0},
  .shortcut_chart_line= {'d','e','f','a','u','l','t',0},
  .shortcut_chart_none= {'d','e','f','a','u','l','t',0},
  .shortcut_chart_pie= {'d','e','f','a','u','l','t',0},
  .shortcut_horizontal= {'d','e','f','a','u','l','t',0},
  .shortcut_html= {'d','e','f','a','u','l','t',0},
  .shortcut_htmlraw= {'d','e','f','a','u','l','t',0},
  .shortcut_raw= {'d','e','f','a','u','l','t',0},
  .shortcut_vertical= {'d','e','f','a','u','l','t',0},
  .shortcut_xml= {'d','e','f','a','u','l','t',0},
  .opt_named_pipe= 0,
  .opt_write_timeout= 0,
  .detach_history_widget= false,
  .detach_result_grid_widget= false,
#if (OCELOT_MYSQL_DEBUGGER == 1)
  .detach_debug_widget= false,
#endif
  .detach_statement_edit_widget= false,
#if (OCELOT_EXPLORER == 1)
  .detach_explorer_widget= false
#endif
};

#if (OCELOT_PLUGIN == 1)
static struct plugin_pass ocelot_plugin_pass {
  .type= 0,
  .ca= &ocelot_ca,
  .id= {0},
  .query= NULL,
  .error_message= NULL,
  .replacer_buffer_length= 0,
  .replacer_buffer= NULL,
  .result_set_copy= NULL,
  .result_row_count= 0,
  .result_column_count= 0,
  .display= NULL,
  .subtype= 0
};
#endif

  static int is_libmysqlclient_loaded= 0;
#if (OCELOT_MYSQL_INCLUDE == 1)
  static int is_libcrypto_loaded= 0;
  static void *libmysqlclient_handle= NULL;
  static void *libcrypto_handle= NULL;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
  static int is_libtarantool_loaded= 0;
  //static int is_libtarantoolnet_loaded= 0;
  static void *libtarantool_handle= 0;
  //static void *libtarantoolnet_handle= 0;
  /* Todo: these shouldn't be global */
  //static tnt_reply *tarantool_tnt_for_new_result_set;
  static bool tarantool_start_transaction_seen= false;
  static char tarantool_box_execute[16]= "box.execute"; /* can be changed to "box.sql.execute" */
#endif

  static  unsigned int rehash_result_column_count= 0; /* Todo: check: why isn't this long unsigned int? */
  static unsigned int rehash_result_row_count= 0;
  static char *rehash_result_set_copy= 0;       /* gets a copy of mysql_res contents, if necessary */
  static char **rehash_result_set_copy_rows= 0; /* dynamic-sized list of result_set_copy row offsets, if necessary */

  int options_and_connect(unsigned int connection_number, char *database_as_utf8);

  /* This should correspond to the version number in the comment at the start of this program. */
  static const char ocelotgui_version[]="2.3.0"; /* For --version. Make sure it's in manual too. */
  static unsigned int dbms_version_mask= FLAG_VERSION_DEFAULT;

/* Global mysql definitions */
#if (OCELOT_MYSQL_INCLUDE == 1)
  static MYSQL mysql[MYSQL_MAX_CONNECTIONS];
  static int connected[MYSQL_MAX_CONNECTIONS]= {0, 0, 0, 0};
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  pthread_t debug_thread_id;
  bool debug_thread_exists= false;
  static int connections_is_connected[MYSQL_MAX_CONNECTIONS];  /* == 1 if is connected */
  static int connections_dbms[MYSQL_MAX_CONNECTIONS];          /* == DBMS_MYSQL or other DBMS_... value */
#ifdef DBMS_TARANTOOL
/* Global Tarantool definitions */
  static struct tnt_stream *tnt[MYSQL_MAX_CONNECTIONS];
  static int tarantool_errno[MYSQL_MAX_CONNECTIONS];
  static char tarantool_errmsg[MAX_HPARSE_ERRMSG_LENGTH];
  QString tarantool_server_name= "";
  static long unsigned int tarantool_row_count[MYSQL_MAX_CONNECTIONS];
#endif

  static ldbms *lmysql= 0;
#if (OCELOT_MYSQL_INCLUDE == 1)
  static bool is_mysql_library_init_done= false;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  unsigned int mysql_errno_result= 0;

#if (OCELOT_IMPORT_EXPORT == 1)
  static struct export_settings main_exports;
#endif
  static unsigned int er_off= 0;    /* to offset er_strings language in ostrings.h */
  static unsigned int color_off= 0; /* to offset color_strings language  in ostrings.h */
  static unsigned int menu_off= 0;  /* to offset menu_strings language  in ostrings.h */

  static QString hparse_text_copy;
  static QString hparse_token;
  static int hparse_i;
  static QString hparse_expected;
  static int hparse_errno; /* 0=ok, 1=error, 2=error-unrecoverable */
  static int hparse_errno_count;
  static int hparse_token_type;
  static int hparse_statement_type= -1;
  static bool sql_mode_ansi_quotes= false;
  static bool sql_mode_no_backslash_escapes= false;
  /* hparse_f_accept can dump many expected tokens in hparse_errmsg */
  static char hparse_errmsg[MAX_HPARSE_ERRMSG_LENGTH];
  static QString hparse_next_token, hparse_next_next_token;
  static int hparse_next_token_type, hparse_next_next_token_type;
  static QString hparse_next_next_next_token, hparse_next_next_next_next_token;
  static int hparse_next_next_next_token_type, hparse_next_next_next_next_token_type;
  static int hparse_begin_count;
  static bool hparse_as_seen;
  static int hparse_flow_count;
  static bool hparse_create_trigger_seen;
  static int hparse_count_of_accepts;
  static int hparse_i_of_statement;
  static int hparse_i_of_last_accepted;
  static QString hparse_prev_token;
  static bool hparse_like_seen;
  static bool hparse_subquery_is_allowed;
  static bool hparse_variable_is_allowed;
  static bool hparse_variable_must_be_int;
  static QString hparse_delimiter_str;
  static bool hparse_sql_mode_ansi_quotes= false;
  static unsigned int hparse_dbms_mask= FLAG_VERSION_DEFAULT;
  static bool hparse_is_in_subquery= false;
  static QString hparse_specified_schema;
  static QStringList hparse_specified_list;
  static bool is_in_source_statement= false;
  static QString ocelot_query= ""; /* So one can say --ocelot_query in the command line */
/* Variables used by kill thread, but which might be checked by debugger */
#define KILL_STATE_CONNECT_THREAD_STARTED 0
#define KILL_STATE_CONNECT_FAILED 1
#define KILL_STATE_IS_CONNECTED 2
#define KILL_STATE_MYSQL_REAL_QUERY_ERROR 3
#define KILL_STATE_ENDED 4
int volatile kill_state;
int volatile kill_connection_id;

#define LONG_QUERY_STATE_STARTED 0
#define LONG_QUERY_STATE_ENDED 1
char *dbms_query;
int dbms_query_len;
int dbms_query_connection_number;
volatile int dbms_long_query_result;
volatile int dbms_long_query_state= LONG_QUERY_STATE_ENDED;

/*
   Suppress useless messages
   https://bugreports.qt.io/browse/QTBUG-57180  (Windows startup)
   https://github.com/MartinBriza/QGnomePlatform/issues/23 (Fedora)
   Originally we only suppressed if Windows but then it started to apper for Linux too.
   There's not much I can do except maybe replace all native dialogs (such as QFontDialog)
   with substitutes in this program. Qutie a lot of work just to suppress a useless message, eh?
   Todo: Failed to load module "canberra-gtk-module" which has something to do with sound
         https://cromwell-intl.com/open-source/missing-gtk-modules.html
         We don't need special sounds so suppressing would be okay.
         But I didn't bother because I only saw it with Linux + Qt4.
   Todo: consider also suppressing "OpenType support missing for script"
   Todo: Since version 1.5 I no longer use QFontDialog, maybe that means some of this is unnecessary.
*/
#if (QT_VERSION >= 0x50000)
void dump_qtmessage(QtMsgType type, const QMessageLogContext &context, const QString &msg)
{
  (void) context;
  if (type == QtWarningMsg)
  {
    if (msg.contains("CreateFontFaceFromHDC")) return;
    if (msg.contains("GtkDialog mapped without a transient parent")) return;
  }
  QByteArray localMsg = msg.toLocal8Bit();
  if (type == QtFatalMsg) abort();
}
#endif

int main(int argc, char *argv[])
{
#if (QT_VERSION >= 0x50000)
  qInstallMessageHandler(dump_qtmessage);
#endif

  QApplication main_application(argc, argv);
  MainWindow w(argc, argv);
  /* We depend on w being maximized in resizeEvent() */
  w.showMaximized();
  return main_application.exec();
}


MainWindow::MainWindow(int argc, char *argv[], QWidget *parent) :
  QMainWindow(parent),
  ui(new Ui::MainWindow)
{
  log("MainWindow start", 90); /* Ordinarily this is less than ocelot_ca.log_level so won't appear */
  initial_asserts();  /* Check that some defined | constant values are okay. */
  /* Initialization */
  main_window_maximum_width= 0;
  main_window_maximum_height= 0;
  main_token_max_count= main_token_count_in_all= main_token_count_in_statement= main_token_number= 0;
  main_token_new(1000); /* because we don't check for size == 0 during main_token_push */

  /*
    setupUi() is in ui_ocelotgui.h, which is generated by a tool named "uic",
    which is called by qmake because there is a line in ocelotgui.pro:
    FORMS    += ocelotgui.ui
    I would love to get rid of the file and just put setupUi in ocelotgui.h,
    but different versions of qmake produce different contents for ui_ocelotgui.h.
    This is the routine that attaches the menubar to MainWindow, among other things.
  */
  ui->setupUi(this);

/*
  The Menu Bar did not appear with Ubuntu 14.04.
  This might be the horrific bug
  https://bugs.launchpad.net/ubuntu/+source/appmenu-qt5/+bug/1307619
  But QT_QPA_PLATFORMTHEME= did not solve.
  So insist that the menu goes in MainWindow.
*/
#ifdef OCELOT_OS_LINUX
  ui->menuBar->setNativeMenuBar(false);
#endif
//SHIFTED!!  create_menu();

  setWindowTitle("ocelotgui");
  connections_is_connected[0]= 0;
  mysql_res= 0;
  /* client variable defaults */
  /* Most settings done here might be overridden when connect_mysql_options_2 reads options. */
  /* Todo: in fact connect_mysql_options_2 says ocelot_dbms= "" so check whether setting here is useful. */
#if (OCELOT_MYSQL_INCLUDE == 1)
  ocelot_dbms= "mysql";
  connections_dbms[0]= DBMS_MYSQL;
#else
  ocelot_dbms= "tarantool";
  connections_dbms[0]= DBMS_TARANTOOL;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

  ocelot_grid_max_row_lines= 5; /* obsolete? */               /* maximum number of lines in 1 row. warn if this is exceeded? */
  ocelot_statement_prompt_background_color= s_color_list[COLOR_LIGHTGRAY*2 + 1]; /* set early because initialize_widget_statement() depends on this */
  ocelot_grid_focus_cell_background_color= s_color_list[COLOR_WHEAT*2 + 1];;
  ocelot_grid_header_background_color= s_color_list[COLOR_LIGHTGRAY*2 + 1];
  ocelot_grid_outer_color= s_color_list[COLOR_LIGHTBLUE*2 + 1];;
  ocelot_grid_cell_border_color= s_color_list[COLOR_BLACK*2 + 1];
  ocelot_grid_cell_border_size= "1";
//  ocelot_grid_cell_drag_line_size= "5";
//  ocelot_grid_cell_width= "default";
  ocelot_grid_height= ocelot_grid_left= ocelot_grid_top= ocelot_grid_width= "default";
  ocelot_grid_html_effects= "no";
  ocelot_grid_detached= "no";
  /* Probably result_grid_table_widget_saved_font only matters if the connection dialog box has to go up. */
  QFont tmp_font;
//  QFont *saved_font;
//  tmp_font= this->font();
//  saved_font=&tmp_font;
//  result_grid_table_widget= new ResultGrid(0, saved_font, this, 0);

#if (OCELOT_EXPLORER == 1)
  ocelot_explorer_height= ocelot_explorer_left= ocelot_explorer_top= ocelot_explorer_width= "default";
  ocelot_explorer_detached= "no";
  ocelot_explorer_visible= "no";
  ocelot_explorer_sort= "no";
  /* ocelot_explorer_query is set up elsewhere, I hope (e.g. in initialize_widget_explorer) */
  explorer_widget= NULL;
#endif
  result_grid_tab_widget= new QTabWidget48(this); /* 2015-08-25 added "this" */
  result_grid_tab_widget->hide();
  main_layout= new QVBoxLayout();
  history_edit_widget= new TextEditHistory(this);         /* 2015-08-25 added "this" */
  statement_edit_widget= new CodeEditor(this);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  statement_edit_widget->is_debug_widget= false;
#endif
  QFont fixed_font= get_fixed_font();
  history_edit_widget->setFont(fixed_font);
  statement_edit_widget->setFont(fixed_font);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  create_widget_debug();
#endif
  main_window= new QWidget(this);                  /* 2015-08-25 added "this" */
  completer_widget= new Completer_widget(); completer_widget->construct(this);
  c_widget= new C_widget(); c_widget->construct(this); c_widget->setFont(fixed_font); c_widget->hide();
  ocelot_grid_cell_height= "default";              /* todo: should be changeable with Settings menu item */
  ocelot_grid_cell_width= "default";               /* todo: should be changeable with Settings menu item */
  /*
    Defaults for items that can be changed with Settings menu item.
    First we get current values, after processing of any Qt options on the command line.
    Then we make arbitrary colors for details that current values probably didn't supply.
    The settings Red=string DarkGreen=Comment Green=object Blue=keyword DarkGray=operator
    have been seen elsewhere, and also pink|magenta=built-in-function so keep that in reserve.
    Then we read option files.
  */
  set_current_colors_and_font(fixed_font); /* set ocelot_statement_text_color, ocelot_grid_text_color, etc. */
  ocelot_statement_border_color= s_color_list[COLOR_BLACK*2 + 1];
  ocelot_statement_highlight_literal_color= s_color_list[COLOR_RED*2 + 1];
  ocelot_statement_highlight_identifier_color= s_color_list[COLOR_GREEN*2 + 1];
  ocelot_statement_highlight_comment_color= s_color_list[COLOR_LIMEGREEN*2 + 1];
  ocelot_statement_highlight_operator_color= s_color_list[COLOR_DARKGRAY*2 + 1];;
  ocelot_statement_highlight_keyword_color= s_color_list[COLOR_BLUE*2 + 1];
  ocelot_statement_highlight_current_line_color= s_color_list[COLOR_YELLOW*2 + 1];
  ocelot_statement_highlight_function_color= s_color_list[COLOR_FUCHSIA*2 + 1];
  ocelot_statement_syntax_checker= "1";
  ocelot_statement_format_statement_indent= "2";
  ocelot_statement_format_clause_indent= "4";
  ocelot_statement_format_rule= "keyword becomes keyword-upper;";
#if (OCELOT_IMPORT_EXPORT == 1)
  import_export_rule_set("");
#endif
  ocelot_statement_height= ocelot_statement_left= ocelot_statement_top= ocelot_statement_width= "default";
  ocelot_statement_detached= "no";
  ocelot_debug_height= ocelot_statement_height;
  ocelot_debug_left= ocelot_statement_left;
  ocelot_debug_top= ocelot_statement_top;
  ocelot_debug_width= ocelot_statement_width;
  ocelot_debug_detached= ocelot_statement_detached;

  ocelot_history_border_color= s_color_list[COLOR_BLACK*2 + 1];
  ocelot_menu_border_color= s_color_list[COLOR_BLACK*2 + 1];
  ocelot_history_height= ocelot_history_left= ocelot_history_top= ocelot_history_width= "default";
  ocelot_history_max_row_count= "0";
  ocelot_history_detached= "no";
  ocelot_histfileflags= "L";
  ocelot_histfilesize= "2000000000";
  ocelot_histsize= "500";
  lmysql= new ldbms();                               /* lmysql will be deleted in action_file_exit(). */
  xsettings_widget= new XSettings(this);
  /* picking up possible settings options from argc+argv after setting _ defaults, so late */
  /* as a result, ocelotgui --version and ocelotgui --help will look slow */
  connect_mysql_options_2(argc, argv);               /* pick up my.cnf and command-line MySQL-related options, if any */
  if (ocelot_ca.version != 0)                           /* e.g. if user said "ocelotgui --version" */
  {
    print_version();
    exit(0);
  }
  if (ocelot_ca.help != 0)                              /* e.g. if user said "ocelotgui --help" */
  {
    print_help();
    exit(0);
  }
#if (OCELOT_PLUGIN == 1)
  /* TODO: any initializations of ocelot_plugin_pass must precede first use of plugin_widget */
  plugin_widget_list.clear();
  /* Warning: only one ocelot_query will be found, even if it's stated multiple times. ocelot_query should be a QList! */
  if (ocelot_query != "") /* if ocelot_query="..." was on the command line or in .cnf, see if it's "install plugin ..." */
  {
    bool is_set_ocelot_query_select= false;
    QString tmp;
    unsigned int diagnostic_signal; /* actually we don't use this here because we don't call put_diagnstics_in_result */
    execute_ocelot_query("set ocelot_query = " + ocelot_query, 0, NULL, &is_set_ocelot_query_select, &tmp, &diagnostic_signal);
    /* todo: better to say, somehow, that we're calling the last thing we added */
    if (plugin_widget_list.size() != 0) plugin_widget_list[0]->caller(PLUGIN_AT_PROGRAM_START, &ocelot_plugin_pass);
  }
#endif

  if (ocelot_ca.print_defaults != 0)                    /* e.g. if user said "ocelotgui --print_defaults" */
  {
    print_defaults();
    exit(0);
  }

  for (int q_i= 0; strcmp(string_languages[q_i]," ") > 0; ++q_i)
  {
    QString s= string_languages[q_i];
    if (QString::compare(ocelot_language, s, Qt::CaseInsensitive) == 0)
    {
      er_off= ER_END * q_i;
      color_off= COLOR_END * q_i;
      menu_off= MENU_END * q_i;
    }
  }
  create_menu(); // SHIFTED!
  set_dbms_version_mask(ocelot_dbms, 0);
  for (int q_i= color_off; strcmp(s_color_list[q_i]," ") > 0; ++q_i) q_color_list.append(s_color_list[q_i]);
  assign_names_for_colors();
  make_style_strings();
  //main_window->setStyleSheet(ocelot_menu_style_string);
  ui->menuBar->setStyleSheet(ocelot_menu_style_string);
  initialize_widget_history();
  initialize_widget_statement();
  /*
    2018-10-08 setFont() before adding tab with ResultGrid, in hope that ResultGrid
    will inherit and that will fix the bug where initial height is too small.
    Actually I now think that the fix this day in ocelotgui.h, where we're creating
    ResultGrid, solves the bug. But leave setFont() in for luck.
  */
  QFont grid_font= get_font_from_style_sheet(ocelot_grid_style_string);
  result_grid_tab_widget->setFont(grid_font);
  result_grid_add_tab();
  main_layout->addWidget(history_edit_widget);
  main_layout->addWidget(result_grid_tab_widget);
  main_layout->addWidget(statement_edit_widget);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  main_layout->addWidget(debug_top_widget);
#endif
#if (OCELOT_FIND_WIDGET == 1)
  find_widget= new Find_widget(this);
  main_layout->addWidget(find_widget);
#endif
#if (OCELOT_EXPLORER == 1)
  explorer_widget= new ResultGrid(lmysql, this, true, EXPLORER_WIDGET);
  //explorer_widget->setStyleSheet(ocelot_explorer_style_string);
  explorer_widget->html_text_edit->explorer_context_menu->setStyleSheet(ocelot_explorer_style_string);
  initialize_widget_explorer();
  QHBoxLayout *upper_layout= new QHBoxLayout();
  QWidget *upper_widget= new QWidget();
  upper_widget->setLayout(main_layout);
  upper_layout->addWidget(explorer_widget);
  upper_layout->addWidget(upper_widget);
  main_window->setLayout(upper_layout);
#else
  main_window->setLayout(main_layout);
#endif
  setCentralWidget(main_window);
  fill_menu_2();    /* Do this at a late stage because widgets must exist before we call connect() */
  history_edit_widget->setContextMenuPolicy(Qt::CustomContextMenu);
  connect(history_edit_widget, SIGNAL(customContextMenuRequested(const QPoint &)),
      this, SLOT(menu_context(const QPoint &)));
  statement_edit_widget->setContextMenuPolicy(Qt::CustomContextMenu);
  connect(statement_edit_widget, SIGNAL(customContextMenuRequested(const QPoint &)),
      this, SLOT(menu_context(const QPoint &)));
  /*
    If the command-line option was -p but not a password, then password input is necessary
    so put up the connection dialog box. Otherwise try immediately to connect.
    Todo: better messages so the user gets the hint: connection is necessary / password is necessary.
    Todo: check: Can you handle password with special characters?
  */
  if (ocelot_password_was_specified != 2)
  {
    statement_edit_widget->insertPlainText("CONNECT");
    action_execute(1);
  }
  else
  {
    action_file_connect(false);
  }
  statement_edit_widget->setFocus(); /* Show user we're ready to accept a statement in the statement edit widget */
  QTimer::singleShot(0, this, SLOT(initialize_after_main_window_show()));
  log("MainWindow end", 90);
}

MainWindow::~MainWindow()
{
  delete ui;
}

/*
  Some actions must wait till after MainWindow::MainWindow() has made the main window.
  E.g. if ocelotgui --ocelot_statement_detach='yes', detaching won't work right until widget sizes are known.
  Qt manuals say "A QTimer with a timeout interval of 0 will time out as soon as all the events
  in the window system's event queue have been processed." so I expect that, given that we invoke with
  QTimer::singleShot(0, this, SLOT(initialize_after_main_window_show()));
  this will happen only after all the main events (show, paint, focusin, etc.) have already been processed.
  But I still needed to issue Messagebox_flash, a drastic way to force an update.
  There will be a lot of blinking. Probably not worth worrying about.
*/
void MainWindow::initialize_after_main_window_show()
{
  if ((ocelot_history_detached == "yes")
      || (ocelot_grid_detached == "yes")
#if (OCELOT_MYSQL_DEBUGGER == 1)
      || (ocelot_debug_detached == "yes")
#endif
      || (ocelot_statement_detached == "yes"))
  {
    Messagebox_flash msgbox;
    msgbox.setText("Detaching ...");
    msgbox.exec(); /* This should display for 1 second then disappear. */
  }
  if (ocelot_history_detached == "yes") action_options_detach_history_widget(true);
  if (ocelot_grid_detached == "yes") action_options_detach_grid_widget(true);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  if (ocelot_debug_detached == "yes") action_options_detach_debug_widget(true);
#endif
  if (ocelot_statement_detached == "yes") action_options_detach_statement_widget(true);
#if (OCELOT_EXPLORER == 1)
  if (ocelot_explorer_detached == "yes") action_options_detach_explorer_widget(true);
#endif
}

/*
  We want to know the maximum widget size for dialog boxes.
  We can get this from the second time resizeEvent happens
  on MainWindow, which is asserted to be maximized.
*/
void MainWindow::resizeEvent(QResizeEvent *ev)
{
  QSize main_window_size= size();
  if (main_window_size.width() > main_window_maximum_width)
    main_window_maximum_width= main_window_size.width();
  if (main_window_size.height() > main_window_maximum_height)
    main_window_maximum_height= main_window_size.height();
  QMainWindow::resizeEvent(ev);
}

/*
  Normally there is only one result set, and therefore only one tab,
  and we hide the tabbing if there is only one tab. Abnormally there
  is more than one because a stored procedure does more than one SELECT.
  We call this at start, and we call this when we need a new tab.
  We never delete. That might be bad because Settings changes will be slower.
  We have:
  ocelot_ca.grid_tabs. The maximum. Default 16. Settable with --ocelot_grid_tabs=n.
  result_grid_tab_widget. What we add the tabs to.
  ocelot_ca.grid_actual_tabs. When we successfully add a tab, this goes up.
  Return 0 for success, 1 for failure (failure is probably because we hit maximum).
*/
int MainWindow::result_grid_add_tab()
{
  ResultGrid *r;
  int i_r= ocelot_ca.grid_actual_tabs;
  if ((ocelot_ca.grid_actual_tabs >= ocelot_ca.grid_tabs)
  && (ocelot_ca.grid_tabs != 0))
    return 1;
  {
    r= new ResultGrid(lmysql, this, true, 0);
    int new_tab_index= result_grid_tab_widget->addTab(r, QString::number(i_r + 1));
#if defined(NDEBUG)
    if (new_tab_index != i_r) {printf("assert(new_tab_index == i_r);"); exit(1); }
#else
    assert(new_tab_index == i_r);
#endif
    r->hide(); /* Maybe this isn't necessary */
  }
  {
    /* Todo: is this pointless? I don't catch fontchange anyway! */
    r= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(i_r));
    assert(r != 0);
    r->installEventFilter(this); /* must catch fontChange, show, etc. */
    r->grid_vertical_scroll_bar->installEventFilter(this);
  }
  {
    r= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(i_r));
    r->set_all_style_sheets(ocelot_grid_style_string, 0, 0, false);
  }
  ++ocelot_ca.grid_actual_tabs;
  return 0;
}

/*
  Initialize statement_edit_widget. Assume "statement_edit_widget= new CodeEditor();" already done.
  All user SQL input goes into statement_edit_widget.
  This will be a CodeEditor, which is a class derived from QTextEdit, with a prompt on the left.
  Todo: Check: after font change or main window resize, are line numbers and text in sync?
*/
void MainWindow::initialize_widget_statement()
{

  statement_edit_widget_setstylesheet();

  statement_edit_widget->setLineWrapMode(QPlainTextEdit::NoWrap);
  /* statement_edit_widget->setAcceptRichText(false); */ /* Todo: test whether this works */
  connect(statement_edit_widget->document(), SIGNAL(contentsChange(int,int,int)), this, SLOT(action_settings_statement_edit_widget_text_changed(int,int,int)));
  statement_edit_widget_text_changed_flag= 0;

  /*
    Defaults.
    The prompt can be changed with a "prompt" statement or by my.cnf contents.
    The widget-left i.e. prompt bgcolor can be changed with a menu item.
  */
  statement_edit_widget->statement_edit_widget_left_bgcolor= QColor(ocelot_statement_prompt_background_color);
  statement_edit_widget->statement_edit_widget_left_treatment1_textcolor= QColor(ocelot_statement_text_color);

  statement_edit_widget->prompt_default= ocelot_prompt;     /* Todo: change to "\N [\d]>"? */
  statement_edit_widget->prompt_as_input_by_user= statement_edit_widget->prompt_default;

  statement_edit_widget->statement_count= 0;
  statement_edit_widget->dbms_version= (QString)"";
  statement_edit_widget->dbms_database= (QString)"";
  statement_edit_widget->dbms_port= (QString)"";
  statement_edit_widget->dbms_host= (QString)"";
  statement_edit_widget->dbms_current_user= (QString)"";
  statement_edit_widget->dbms_current_user_without_host= (QString)"";
  statement_edit_widget->delimiter= ocelot_delimiter_str;
  statement_edit_widget->result= (QString)"";

  /*
    Problem: the above statements don't cause recalculation of width of prompt on the left.
    (Original calculation happens when widget is created.)
    I can force recalculation by doing an "emit" here.
    But I'm not sure this is the right way to do it.
  */
  emit statement_edit_widget->update_prompt_width(0);

  statement_edit_widget->installEventFilter(this);
  statement_edit_widget->setMouseTracking(true);
}


/* Statement widget and debug widgets both use ocelot_statement_style_string. */
void MainWindow::statement_edit_widget_setstylesheet()
{
  statement_edit_widget->setStyleSheet(ocelot_statement_style_string);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  for (int debug_widget_index= 0; debug_widget_index < DEBUG_TAB_WIDGET_MAX; ++debug_widget_index)
  {
    if (debug_widget[debug_widget_index] != 0)
    {
      debug_widget[debug_widget_index]->setStyleSheet(ocelot_statement_style_string);
    }
  }
#endif
  completer_widget->initialize(STATEMENT_WIDGET);
}

/*
  Formatter -- minimal, but this format might be okay for debugger users.
  It only works if the statement has been recognized.
  All we're trying to accomplish is
    "different statements different lines"
    "block start causes indent"
    "token replacement rules user-settable"
    "lists of columns lined up in select/update/insert/set".
  Cursor will go back to start.
  Indentation is meaningless unless there is a fixed font.
  Menu item is Edit|Format and shortcut key (which is done with setShortcut not
  eventfilter, I forget why) is Alt+Shift+F. Statements which can affect it are
    SET ocelot_statement_format_clause_indent = integer 0-8; default='4'
    SET ocelot_statement_format_statement_indent = integer 0-8; default='2'
    SET ocelot_statement_format_rule = e.g. 'identifier becomes identifier-upper'
  Todo: stop giving up when you see DELIMITER, it can be figured out.
  Todo: max_rule_tokens is # of characters, we only need # of tokens.
  Todo: worry: can output_offsets overflow?
*/
void MainWindow::action_edit_format(bool is_checked)
{
  (void)is_checked;
  log("action_edit_format", 15);
  if (((ocelot_statement_syntax_checker.toInt()) & FLAG_FOR_HIGHLIGHTS) == 0) return;
  int max_rule_tokens= ocelot_statement_format_rule.size();
  int *rule_token_offsets= new int[max_rule_tokens];
  int *rule_token_lengths= new int[max_rule_tokens];
  int *rule_token_types= new int[max_rule_tokens];
  tokenize(ocelot_statement_format_rule.data(),
           ocelot_statement_format_rule.size(),
           &rule_token_lengths[0], &rule_token_offsets[0], max_rule_tokens - 1,
          (QChar*)"33333", 1, "", 1);
  for (int i2= 0; rule_token_lengths[i2] != 0; ++i2)
  {
    QString rule_token= ocelot_statement_format_rule.mid(rule_token_offsets[i2], rule_token_lengths[i2]);
    int t= token_type(rule_token.data(), rule_token_lengths[i2], sql_mode_ansi_quotes);
    if ((t == TOKEN_TYPE_OTHER) && (rule_token_lengths[i2] < MAX_KEYWORD_LENGTH))
    {
      char key1[MAX_KEYWORD_LENGTH + 1];
      char key2[MAX_KEYWORD_LENGTH + 1];
      strcpy(key1, rule_token.toUtf8());
      t= get_keyword_index(key1, key2);
    }
    rule_token_types[i2]= t;
  }
  int *output_offsets;
  int i;
  for (i= 0; main_token_lengths[i] != 0; ++i) ;
  output_offsets= new int[i + 1];

  QString text= statement_edit_widget->toPlainText(); /* or I could just pass this to tokenize() directly */
  QString output= "";
  int indent_base= 0;
  int statement_indent= ocelot_statement_format_statement_indent.toInt();
  int clause_indent= ocelot_statement_format_clause_indent.toInt();

  int token;
  QString s;
  int token_type;
  for (i= 0; main_token_lengths[i] != 0; ++i)
  {
    if ((main_token_flags[i] & TOKEN_FLAG_IS_ERROR) != 0)
    {
      int st= 0;
      if (i > 0) st= main_token_offsets[i - 1] + main_token_lengths[i - 1];
      s= text.right(text.length() - st);
      output.append(s);
      break; /* Give up */
    }
    token_type= 0;
    token= main_token_types[i];
    if (token == TOKEN_TYPE_DELIMITER)
    {
      QString d= text.mid(main_token_offsets[i], main_token_lengths[i]);
      output.append(d);
      continue;
    }
    if (text.mid(main_token_offsets[i], 2).toUpper() == "\\G")
    {
      output.append(text.mid(main_token_offsets[i], 2));
      ++i;
      continue;
    }
    if ((main_token_flags[i] & TOKEN_FLAG_IS_START_IN_COLUMN_LIST) != 0)
      output_offsets[i]= output.length();
    if ((main_token_flags[i] & TOKEN_FLAG_IS_END_IN_COLUMN_LIST) != 0)
    {
      output.append(",");
      /* indent to where the column list began */
      int indent_of_column= 0;
      for (int k= i - 1; k >= 0; --k)
      {
        if ((main_token_flags[k] & TOKEN_FLAG_IS_START_IN_COLUMN_LIST) != 0)
        {
          int l= output_offsets[k];
          for (; (l < output.length()) && (output.mid(l, 1) <= " "); ++l) ;
          for (int m= l; ; --m)
          {
            if ((output.mid(m, 1) == "\n") || (m == 0))
            {
              if (m != 0) ++m;
              indent_of_column= l - m;
              break;
            }
          }
          break;
        }
      }
      output.append("\n");
      for (int n= 0; n < indent_of_column; ++n) output.append(" ");
    }
    else
    {
      if (token == TOKEN_KEYWORD_DELIMITER)
      {
        if (output != "") output.append("\n");
        QString d;
        d= text.mid(main_token_offsets[i], main_token_lengths[i]);
        QString e= d.toUpper();
        if (e == "DELIMITER") output.append(e);
        else output.append(d);
        if (main_token_lengths[i + 1] != 0)
        {
          int j= main_token_offsets[i] + main_token_lengths[i];
          d= text.mid(j, main_token_offsets[i + 1] - j);
          if (d.contains("\n"))
          {
            continue; /* delimiter \n = an error, but possible */
          }
          output.append(" ");
          ++i;
          d= text.mid(main_token_offsets[i], main_token_lengths[i]);
          output.append(d);
          while ((main_token_lengths[i + 1] != 0)
           && (main_token_offsets[i + 1] == main_token_offsets[i] + main_token_lengths[i]))
          {
            d= text.mid(main_token_offsets[i + 1], main_token_lengths[i + 1]);
            output.append(d);
            ++i;
          }
          continue;
        }
      }
      if (token == TOKEN_KEYWORD_PROMPT)
      {
        if (output != "") output.append("\n");
        QString d;
        d= text.mid(main_token_offsets[i], main_token_lengths[i]);
        QString e= d.toUpper();
        if (e == "PROMPT") output.append(e);
        else output.append(d);
        int k= i + 1;
        while ((main_token_lengths[k] != 0)
            && ((main_token_flags[k] & TOKEN_FLAG_IS_START_STATEMENT) == 0)
            && ((main_token_flags[k] & TOKEN_FLAG_IS_ERROR) == 0))
          ++k;
        --k;
        if (k != i)
        {
          int j;
          j= main_token_offsets[k] - (main_token_offsets[i] + main_token_lengths[i]) + main_token_lengths[k];
          d= text.mid(main_token_offsets[i] + main_token_lengths[i], j);
          output.append(d);
        }
        i= k;
        continue;
      }
      if (((main_token_flags[i] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
       || ((main_token_flags[i] & TOKEN_FLAG_IS_START_CLAUSE) != 0))
      {
        token_type= 1;
        if ((token == TOKEN_KEYWORD_BEGIN)
        || (token == TOKEN_KEYWORD_CASE)
        || (token == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT) /* will only be true if MariaDB 10.3 */
        || (token == TOKEN_KEYWORD_IF)
        || (token == TOKEN_KEYWORD_LOOP)
        || (token == TOKEN_KEYWORD_REPEAT)
        || (token == TOKEN_KEYWORD_WHILE))
          token_type= 3;
      }
      if (token_type > 0)
      {
        /* todo: check if (not already at indent-base) */
        if (output != "") output.append("\n");
        for (int k= 0; k < indent_base; ++k) output.append(" ");
        if ((main_token_flags[i] & TOKEN_FLAG_IS_START_CLAUSE) != 0)
        {
          for (int k= 0; k < clause_indent; ++k) output.append(" ");
        }
        if (token == TOKEN_KEYWORD_END)
        {
          indent_base-= statement_indent;
        }
        if (token_type == 3)
        {
          indent_base+= statement_indent;
        }
      }
      s= text.mid(main_token_offsets[i], main_token_lengths[i]);
      QString p= "";
      int p_flags= 0;
      int p_type= 0;
      if (i > 0)
      {
        p= text.mid(main_token_offsets[i - 1], main_token_lengths[i - 1]);
        p_flags= main_token_flags[i - 1];
        p_type= main_token_types[i - 1];
      }

      if (output.right(1) == "\\")
      {
        if (main_token_offsets[i] == main_token_offsets[i - 1] + main_token_lengths[i - 1])
        {
          output.append(s);
          continue;
        }
      }

      if (output.right(1) > " ")
      {
        if (main_token_types[i] == TOKEN_TYPE_OPERATOR)
        {
          if ((s == ",") || (s == ";") || (s == ")") || (s == "}") || (s == ".") || (s == ":")) {;}
          else if (s == "(")
          {
            /* no space between function name and '('. mandatory. */
            if ((p_flags & TOKEN_FLAG_IS_FUNCTION) != 0)
            {
              ;
            }
            else if (hparse_f_is_identifier(p_type) == true)
            {
              ;
            }
            else if ((p_flags & TOKEN_FLAG_IS_DATA_TYPE) != 0)
            {
              ;
            }
            else if ((p != "(")
             && ((main_token_flags[i] & TOKEN_FLAG_IS_NOT_AFTER_SPACE) == 0))
              output.append(" ");
          }
          else output.append(" ");
        }
        else
        {
          if ((p == "(") || (p == "{") || (p == ".") || (p == "@") || (p == "~")) {;}
          else if ((p == "-") || (p == "+"))
          {
            if ((main_token_flags[i - 1] & TOKEN_FLAG_IS_BINARY_PLUS_OR_MINUS) != 0)
            {
              output.append(" ");
            }
          }
          else if (s == "@") {;}
          else output.append(" ");
        }
      }
      s= statement_format_rule_apply(s, main_token_types[i], main_token_reftypes[i], main_token_flags[i], rule_token_offsets, rule_token_lengths, rule_token_types);
      output.append(s);
    }
  }
  /* Change statement widget contents with possibility of "undo" later */
  QTextCursor cur(statement_edit_widget->textCursor());
  cur.beginEditBlock();
  cur.setPosition(0);
  cur.select(QTextCursor::Document);
  cur.removeSelectedText();
  cur.insertText(output);
  cur.endEditBlock();
  delete [] output_offsets;
  delete [] rule_token_types;
  delete [] rule_token_lengths;
  delete [] rule_token_offsets;
  action_settings_statement_edit_widget_text_changed(0, 0, 0); /* This is new, trying to solve the ^Z problem */
}

/*
  ocelot_statement_format_rule_set()
  This will help with implementation of the format rules described by
  Descriptive SQL Style Guide
  https://github.com/pgulutzan/descriptive-sql-style-guide/blob/master/style.md
  The rules are applied to a current statement when user chooses Edit|Format.
  See action_edit_format() above.

  Rules are for replacing tokens.
  They are applied once per token. If rule doesn't match, skip. If does match, replace and skip the rest.

  Client statement =
  SET STATEMENT_FORMAT_RULE rule [, rule ...] ;

  rule =
  token-or-category BECOMES zero or more tokens or categories

  token-or-category =
  category name i.e. COMMENT | IDENTIFIER | KEYWORD | LITERAL| OPERATOR
  token i.e. anything that is legal in an SQL statement e.g. THEN or 'THEN', or character name
        optionally followed by modifier(s)

  character name = COMMA | NEWLINE | SEMICOLON | SPACE | TAB but these cannot be tokens

  modifier = -UPPER | -LOWER

  Default rule is keyword becomes keyword-upper;

  Tips:
    To add a newline after THEN: THEN BECOMES THEN NEWLINE
    To say that all keywords are upper case etc.: KEYWORD BECOMES KEYWORD-UPPER
    To say that != should be <>: != BECOMES <>
    To say that INT should be INTEGER: INT BECOMES INTEGER
    To say 'x' should be 'y': SET ocelot_statement_format_rule 'x' BECOMES 'y';
    So far: success with:
    SET ocelot_statement_format_rule 'x' becomes 'y';
    SET ocelot_statement_format_rule 'm' becomes 'y' 'z', 'x' becomes 'k';
    set ocelot_statement_format_rule identifier becomes identifier 5;
    set ocelot_statement_format_rule identifier becomes identifier-upper;
    SET ocelot_statement_format_rule comment becomes ;
    SET ocelot_statement_format_rule IDENTIFIER-LOWER BECOMES IDENTIFIER-UPPER;
  If there is more than one rule:
    If the token does not match, then the rule is ignored.
    If the token does match, then the token is replaced and all subsequent rules are ignored.
    Therefore sensible people will put specific rules before category rules.
    For example
      SET OCELOT_STATEMENT_FORMAT_RULE THEN BECOMES SPACE THEN, KEYWORD BECOMES KEYWORD;
      means when you see THEN you apply the first rule, therefore you do not apply the second rule.
  It's also possible to set with --ocelot_statement_format_rule='rule'
  Todo: consider escape character e.g. \; and escape reserved word e.g. \IDENTIFIER
        consider doing rules at start rather than at end
  Todo: OK message should say how many times rules were applied.
  Todo: additional modifiers:
        (KEYWORD) -RESERVED -CAPITALIZED -DATATYPE -VERB -CLAUSE_START -STATEMENT_START -IN_COMPOUND
        (COMMENT) -BRACKETED -SIMPLE -OCTOTHORPE
        (LITERAL) -STRING -FLOAT -DECIMAL -BINARY -LONG -DOUBLEQUOTED -ORDINAL
        (OPERATOR) -ARITHMETIC -COMPARISON -PUNCTUATION
        (IDENTIFIER) -DELIMITED -REGULAR -QUOTED -BACKTICKED -TABLE -COLUMN -ROUTINE
  Todo: rules for INDENT and WHITESPACE
  Todo: Additional categories: STATEMENT CLAUSE EXPRESSION SUBQUERY LIST
  Todo: Phrases e.g. CREATE ... TABLE or ALTER ... TABLE ... ADD
  Todo: just say what rules would be violated or applicable ("This is not formatted according to rules 1 and 77")
        or say what rules are being followed e.g. "To get this we would have to make these rules")
  PROBLEM: ACCEPTED: SET ocelot_statement_format_rule operator becomes identifier-upper;
  PROBLEM: MAYBE ^Z IS NOT CALLING HPARSE AGAIN? So you can't format twice.
*/

int MainWindow::statement_format_rule_set(QString text)
{
  if (((ocelot_statement_syntax_checker.toInt()) & FLAG_FOR_HIGHLIGHTS) == 0) return ER_FORMAT_RULE;
  int i;
  for (i= 0; main_token_lengths[i] != 0; ++i)
  {
    if (main_token_types[i] == TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_RULE)
    {
      ocelot_statement_format_rule= text.mid(main_token_offsets[i + 1]);
    }
  }
  return ER_OK;
}

#if (OCELOT_IMPORT_EXPORT == 1)
/*
  Called by import_export_rule_set().
  Change QString to utf8 and then to QByteArray.
  Or: if it is X'....', convert hex digits directly to QByteArray.
  Convert escapes, e.g. if QString contains \n, we want a byte value QChar::LineFeed
  According to https://dev.mysql.com/doc/refman/8.0/en/load-data.html the combinations that are escapes
  are \0 \b \n \r \t \z \N. But I haven't handled \N (NULL) yet (for IF NULL I'm taking it as two letters).
  Todo: Check: why are you saying \\Z not \\z?
  Todo: Check if there are other combinations that aren't documented.
*/
QByteArray MainWindow::to_byte_array(QString q)
{
  if ((q.mid(1, 1) == "'") && (QString::compare(q.mid(0, 1), "X", Qt::CaseInsensitive) == 0))
    return QByteArray::fromHex(q.toUtf8());
  QString s= q;
  s= s.replace("\\0", "\0");
  s= s.replace("\\b", "\b");
  s= s.replace("\\n", "\n");
  s= s.replace("\\r", "\r");
  s= s.replace("\\t", "\t");
  s= s.replace("\\Z", QChar(26)); /* should be interpreted as replacement character ^z, not checked. */
  return s.toUtf8();
}

/*
  SET ocelot_export ...; -- settings for dump of current result set, in one of several formats
  Many of the comments are about wishes that might never come true

  Some of the clauses are as in MySQL's INTO OUTPUT clauses but ocelotgui has more options and file can be local.
  (Of course one could say that about mysqldump too, but we're doing some things that mysqldump doesn't.)

  SET ocelot_export ::= 'string' | option-list
  Ordinarily one does not use 'string', but it is allowed because --ocelot_export = 'string' is allowed.
  Example: set by menu File|Export TEXT using the same default as the mysql client:
  SET ocelot_export = FORMAT 'TEXT'
    INTO 'STDOUT'
    COLUMNS TERMINATED BY X'09' ENCLOSED BY '' ESCAPED BY X'5C'
    LINES STARTING BY '' TERMINATED BY X'0A'
    MAX_ROW_COUNT 100000000 COLUMN_NAMES 'no'
    QUERY 'no' ROW_COUNT 'no' MARGIN 0 PAD 'no' LAST 'no' DIVIDER 'no' IF NULL '\N'
    IF FILE EXISTS 'append';
  SET ocelot_export = FORMAT 'TABLE'
      INTO STDOUT
      FIELDS TERMINATED BY '|' ENCLOSED BY '' ESCAPED BY ''
      LINES STARTING BY '|' TERMINATED BY X'0A';

  For most strings one can use X'....' e.g. x'09' instead of a tab character or '\t'.
  This overrides TEE and --html-raw and --xml and --raw and --batch.
  Types supported now: TEXT, TABLE, HTML, NONE
  Types to consider: JSON, YAML, LUA, HTML4, HTML5, DEFAULT (? and BATCH or RAW or XML?)
                     SQL | INSERT STATEMENTS, MSGPACK, LATEX, TROFF
  INTO 'filename' | STDOUT
    Alternatives to INTO: FILE, OUTFILE, INTO OUTFILE. hopefully '[literal]' is enough hint
    Alternatives to 'filename':| TEE | @variable | CLIPBOARD | TMPFILE | pipe/port | grid-widget | histfile
    INTO STDOUT is default
    Extra clauses to consider: IF EXISTS append | error | overwrite | add new + ordinal
                               [ADD TIMESTAMP] you could have multiple files,
                                               add timestamp or ordinal or random-string to each file name
                               [IF FILE EXISTS ERROR|APPEND|REPLACE]
                                               Default = APPEND though mysql client would say ERROR
                                               Perhaps TRUNCATE would be clearer than REPLACE
  'TEXT': (some call it DEP) (or DELIMITED?) (these defaults are for MySQL which is tab-separated but like CSV)
     MySQL Shell calls it "tabbed".
     The same items that are in MySQL/MariaDB output file, in order:
     FIELDS|COLUMNS TERMINATED BY string
     FIELDS|COLUMNS ESCAPED BY string
     FIELDS|COLUMNS [OPTIONALLY] ENCLOSED BY string
     LINES STARTING BY string TERMINATED BY string
   'TABLE': (or FIXED?) (or TABULAR?) (or PRETTY?) (or BOXES?)
     ClickHouse calls it PRETTY. MySQL Shell says result_format=table. (They also have "tabbed".)
     https://mariadb.com/kb/en/mysql-command-line-client/ says "ascii-table"
     This is the +----+ style with Box drawing as in https://en.wikipedia.org/wiki/Box-drawing_character
     (but really the +-----+ style is fixed-width, columns terminated by |, lines terminated by special-stuff)
     SET ... COLUMN BOUNDARIES '|' LINE BOUNDARIES '-' INTERSECTIONS '+' HEADER LINE BOUNDARIES '='
     Does not appply to history, which is like TABLE but has no options because we may depend on its format.
     FIELDS|COLUMNS TERMINATED BY string
     LINES TERMINATED BY '-' AND '+' (or '-+')
     HEADER LINES TERMINATED BY '=' AND '+'
     FILE STARTING BY '-' AND '+'
     FILE TERMINATED BY '-' AND '+'
   'HTML'
     This has to just dump what we got for result grid, but with different limit for max_row_count
     it's influenced by ocelot_grid_... settings
   'NONE':
     This is the default. Simple: there is no exporting.
   DEFAULT (no longer shown):
     TEE result set output will be like TABLE with -s and |s and +s, same as history output.
     So DEFAULT is what you are used to seeing with TEE.
   Applicable for all types: implemented:
     MAX ROW_COUNT n default 100000000, if it's 0 but INCLUDE QUERY then only query will go out
     COLUMN_NAMES 'yes' or 'no', if 'yes' then column names appear at start of result set
     QUERY 'yes' or 'no', if 'yes' then query appears before result set
           (default is true because exporting is like that, or false if DEFAULT)
     ROW_COUNT 'yes' or 'no', if 'yes' then row count appears before result set
     MARGIN n default 1 i.e. number of spaces before after each column, sometimes column-terminated-by does this
     PAD 'yes' or 'no'
     LAST 'yes' or 'no'
     DIVIDER 'yes' or 'no'
     IF NULL '\N' or it could be 'NULL' etc. but MySQL|MariaDB always say \N (or "fill with ****s"?) see also "Re IF NULL".
   Applicable for all types: not implemented:
     MAX_ROW_COUNT SELECTED ROWS instead of MAX_ROW_COUNT n
     WIDTH FIXED|MINIMAL|MAXIMAL i.e. should we fill in blanks with leading|trailing spaces, as if PAD ' '
       and if fixed: truncate | newline
     BINARY AS ascii | hex | 'binary' | according to MySQL 8.0 setting for mysql client
     MAXIMUM_BYTES, MAXIMUM_LINE_WIDTH
     CHARACTER SET character-set-name                       default is UTF8
     DOUBLE QUOTES     Whether it's okay to double a quote character inside quotes,
                       SQL-style, e.g. 'The''Rain'.
                       This makes no sense if ENCLOSED BY is not ", or if ESCAPED BY is operating. Override them?
                       Default = no.
     HEADER            Add Oracle-style Header separator?
     MAXIMUM_COLUMN_WIDTH = n or as-in-definition, and WRAP | WORD-WRAP | TRUNCATE, and PAD with spaces
     FLUSH AFTER EACH ROW | AT END         Default = after each row
     SKIP IF same-regexp-as-for-history    Default = nothing
                                           Or say EXCLUDE data-type
     ONLY SELECTED ROWS                    Ordinarily we always output when we have a selection
                                           So this would imply: do not output until user selects
                                           Initially nothing is selected.
                                           Would still be limited by MAX_ROW_COUNT
     ZIP or some other compression
   Re escapes within the literals in the SET statement (this is not about escapes in what's exported):
    Since tokenize() depends on (sql_mode_string.contains("NO_BACKSLASH_ESCAPES")),
    changing sql_mode can change the statement's meaning. It's best to use X'..' for single-character
    escaping. Apparently this is different from mysql client, which never escapes.
    So you can use \t for tab, just like what you see with INTO OUTFILE, but we won't recommend it.
    SELECT ... INTO OUTFILE also allows e.g. FIELDS TERMINATED BY X'0A'; so to that extent we're consistent.
    Also \ is a bit of a bother with Windows file names in the INTO clause.
    Therefore ESCAPED BY '\\' is okay just as in SELECT ... INTO OUTFILE, but we prefer X'5C'.
    Typical: X'00' nul (or \0), X'08' backspace (or \b), X'09' tab (or \t), X'0A' line feed (or \n),
             X'0D' carriage return (or \r), X'1A' control-Z (or \Z).  X'20' space (or \s),
             X'22' double quote (or \"), X'27' single quote (or \'), X'5C' (or \\)
    Warning: We do not escape what is in IF NULL strings.
    Todo: Think what to do if we're not connected to MySQL/MariaDB. Local setting? Allow set sql_mode anyway?
   Re FIELDS|COLUMNS TERMINATED BY:
     It comes at the end of every column -- except the last column! So default end-of-row is x0a not 0x090a.
     So LAST 'yes' should mean "include columns-terminated-by string after last column"
   Re ENCLOSED BY:
     OPTIONALLY means applicable for numbers but not DATE/TIME/TIMESTAMP/[VAR]CHAR/[VAR]BINARY,
     and what matters is the definition i.e. '55' is not enclosed for string columns, 1e44 is enclosed for
     numeric columns.
     NULLs are never enclosed.
   Re ESCAPED BY: (NB: import and export will differ, this is only what we do with export)
     default = \
     x'00' becomes escape+'0',
     fields-terminated-by becomes escape+fields-terminated-by e.g. x09 becomes escape+x09 (default),
     enclosed-by becomes escape+enclosed-by e.g. " becomes escape+" (there is no default),
     escaped-by becomes escape+escaped-by e.g. \ becomes escape+\ (default),
     lines-starting-by does not affect escaping,
     lines-terminated-by becomes escape+lines-terminated-by e.g. x0a becomes escape+0x0a (default)
       (but if there is more than one character then only the firstr character matters),
     But this is a reason that more than one character for enclosing makes no sense, usually.
     Re escape+'0': I guess it's rational if we say ESCAPED BY X'5C' because then the output is \0
    Re REPLACE:
      This is more flexible than ESCAPE, although may ESCAPE is a better word
      We don't need to escape "s because one can say REPLACE " WITH ""
      Sometimes that would be good because doubling "s is an expectation for some products.
    Re IF NULL:
     In MySQL/MariaDB INTO OUTFILE NULL becomes escape+N which ordinarily means \N but it's WN if ESCAPED BY 'W'
     but if ESCAPED BY '' then it should be NULL.
       (however since we have IF NULL we don't do that we take the exact if_null string),
      MySQL/MariaDB behaviour is: if ESCAPED BY is '' then say NULL, else say escaped-by-char + N.
      Saying '\N' or 'NULL' won't have that effect, so to replicate it say DEFAULT, which is default.
      We say if IF NULL value is DEFAULT then we'll do what MySQL/MariaDB do, else we output IF NULL value.
      Warning: we do not escape what is in null strings. That is:
               In copy_to_history() we do not check escapers for IF NULL values, so for
               TERMINATED BY 'U' ESCAPED BY 'U' IF NULL 'NULL'
                the result will be NULL it will not be N\ULL.
    Re ambiguity:
     mysql client can say "| Warning | 1475 | First character of the FIELDS TERMINATED string is ambiguous;
     please use non-optional and non-empty FIELDS ENCLOSED BY |".
     ... Because it's stupid if escaped-by = terminated-by = enclosed-by i.e. the same character twice.
+-
   Struct, or individual variables
     type = "TEXT", "TABLE", etc.
     maximum_rows = long unsigned int
     column_boundary = ',' (the CSV default) or '|' (the TABLE default) -- no, TEXT default is '' I guess
   Todo: Menu
     File | Export text etc.
     Dialog box for each type, with different names but affecting the same variables
     No shortcuts
     ostrings.h, French: Exportation, botes
   Todo: TEE
     Show file name that is actually used, dev/null does cancelling, temporary file is okay, pipe is okay
     Ignore trailing ;
     Allow more options after file name
     Diagnostic message if fopen failure, and warning if appending / overwriting old file
     Warn if there is a non-default export setting (display it?)
     The actual writing of the result set is currently happening in tee_export()
   Todo: skip if SELECT has an INTO OUTFILE clause
   Todo: rather than widget(0) use the rg of the current-displayed result grid, if it's tabbed.
   Todo: better error if we didn't go through hparse which is why FLAG_FOR_HIGHLIGHTS could be off
   Unlike MySQL|MariaDB, we do not say TERMINATED BY strings must be short ASCII.
   struct export_rule is defined at the start of ocelotgui.cpp, set up here, and read in ocelotgui.h
   Todo: MySQL has a warning: "Non-ASCII separator arguments are not fully supported".
         If we allow multi-byte, see the warning in copy_to_history().
         I'd like to do differently. But I'd have to know whether X'...' i.e. VARBINARY was used.
         Maybe I'd only have to insist that the escape character is ASCII. Or say it's bizarre.
   Todo: Check if user deletes or edits the output file. Currently we don't notice and there's no output.
   Todo: Maybe max_row_count could default to ocelot_history_max_row_count if we get that before calling this.
*/

void MainWindow::export_defaults(int passed_type, struct export_settings *exports)
{
  (*exports).type= passed_type;
  (*exports).file_name= "STDOUT";
  (*exports).columns_terminated_by= "|";
  (*exports).columns_optionally= false;
  (*exports).columns_escaped_by= "";
  (*exports).columns_enclosed_by= "";
  (*exports).lines_starting_by= "";
  (*exports).lines_terminated_by= "";
  (*exports).max_row_count= 100000000;
  (*exports).column_names= true;
  (*exports).query= true;
  (*exports).row_count= true;
  (*exports).margin= 1;
  (*exports).pad= true;
  (*exports).last= true;
  (*exports).divider= true;
  (*exports).if_null= "DEFAULT";
  (*exports).replace_string= "X'22'";
  (*exports).with_string= "X'22'";
  (*exports).if_file_exists= "append";
  if (passed_type == TOKEN_KEYWORD_TEXT)
  {
    (*exports).columns_enclosed_by= "";
    (*exports).columns_escaped_by= "X'5C'"; /* this will appear as \ */
    (*exports).column_names= 0;
    (*exports).columns_terminated_by= "X'09'";
    (*exports).lines_starting_by= "";
    (*exports).lines_terminated_by= "X'0A'";
    (*exports).query= false;
    (*exports).row_count= false;
    (*exports).max_row_count= 100000000;
    (*exports).margin= 0;
    (*exports).pad= false;
    (*exports).last= false;
    (*exports).divider= false;
  }
  if (passed_type == TOKEN_KEYWORD_TABLE)
  {
    (*exports).columns_escaped_by= "X'5C'";
    (*exports).lines_starting_by= "|";
    (*exports).lines_terminated_by= "X'0A'";
    /* (*exports).pad= true; should be unnecessary */
  }
  if (passed_type == TOKEN_KEYWORD_HTML)
  {
    (*exports).query= false;
    (*exports).row_count= false;
  }
}

/*
  Why recursion: We want to handle SET ocelot_export='format ''test'''; as well as ocelot_export=format 'test';
                 because --ocelot_export is possible. And it might be --ocelot_export="format 'test'"
  Why no checks: Ordinarily we've gone through hparse, eh? But we can unset that or have a command-line option.
                 Maybe that means result will be junk but I don't think there's a crash possibility.
                 Todo: We check some errors here but messages are terse English.
  Todo: I hope that if a file is already open it will be closed somewhere; I haven't checked.
  For some errors, we check at end because if a clause is duplicated it might be okay the final time.
*/
#define MAX_EXPORT_TOKENS 100 /* We could use 'new' + dynamic but with current syntax 100 is more than enough */
QString MainWindow::import_export_rule_set(QString text)
{
  log("import_export_rule_set", 15);
  struct export_settings local_exports= {0,"","","",false,"","","",0,false,false,false,0,false,false,false,"","","",""};
  export_defaults(0, &local_exports);

  QString error_message= "";
  int export_token_offsets[MAX_EXPORT_TOKENS];
  int export_token_lengths[MAX_EXPORT_TOKENS];
  int export_token_types[MAX_EXPORT_TOKENS];
  int token;
  tokenize(text.data(),
           text.size(),
           &export_token_lengths[0], &export_token_offsets[0], MAX_EXPORT_TOKENS - 1,
          (QChar*)"33333", 1, "", 1);
  /* This next bit is pared down from tokens_to_keywords(). ansi_quotes=false so "..." might be acceptable */
  {
    char key2[MAX_KEYWORD_LENGTH + 1];
    int i2, t, index;
    QString s;
    for (i2= 0; export_token_lengths[i2] != 0; ++i2)
    {
      s= text.mid(export_token_offsets[i2], export_token_lengths[i2]);
      t= token_type(s.data(), export_token_lengths[i2], false);
      if (i2 == MAX_EXPORT_TOKENS - 4) error_message= "Too many tokens";
      export_token_types[i2]= t;
      if ((t == TOKEN_TYPE_OTHER) && (export_token_lengths[i2] < MAX_KEYWORD_LENGTH))
      {
        QByteArray key_as_byte_array= s.toLocal8Bit();
        const char *key= key_as_byte_array.data();
        index= get_keyword_index(key, key2);
        if (index != -1) export_token_types[i2]= index;
      }
    }
  }

  QString s;
  QString rr= "";
  int i, i_prev_1, i_prev_2, token_prev_2;
  int lines_or_columns= 0;

  if (text == "")
  {
    local_exports.type= TOKEN_KEYWORD_NONE;
    goto ok_ok_return; /* for default initialization we pass "" */
  }
  for (i= 0; export_token_lengths[i] != 0; ++i)
  {
    token= export_token_types[i];
    QString token_string= text.mid(export_token_offsets[i], export_token_lengths[i]);
    if (token_string == "=")
    {
      int tmp_i= next_i_v(i, +1, export_token_types, export_token_lengths);
      if ((export_token_types[tmp_i] == TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE)
       || (export_token_types[tmp_i] == TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE))
      {
        QString s= text.mid(export_token_offsets[tmp_i], export_token_lengths[tmp_i]);
        s= connect_stripper(s, true);
        error_message= import_export_rule_set(s); /* recursion */
        if (error_message > "") goto ok_return;
      }
    }
    if (token == TOKEN_KEYWORD_FORMAT)
    {
      i= next_i_v(i, +1, export_token_types, export_token_lengths);
      QString s= text.mid(export_token_offsets[i], export_token_lengths[i]);
      s= connect_stripper(s, false);
      s= s.toUpper();
      if (s == "TEXT") token= TOKEN_KEYWORD_TEXT;
      else if (s == "TABLE") token= TOKEN_KEYWORD_TABLE;
      else if (s == "HTML") token= TOKEN_KEYWORD_HTML;
      else token= TOKEN_KEYWORD_NONE;
    }

    if (token == TOKEN_KEYWORD_TABLE)
    {
      local_exports.type= TOKEN_KEYWORD_TABLE;
      /* rest is default initially */
    }
    if (token == TOKEN_KEYWORD_TEXT)
    {
      export_defaults(TOKEN_KEYWORD_TEXT, &local_exports);
    }
    if (token == TOKEN_KEYWORD_HTML)
    {
      export_defaults(TOKEN_KEYWORD_HTML, &local_exports);
    }
    if (token == TOKEN_KEYWORD_NONE)
    {
      break;
    }

    if (token == TOKEN_KEYWORD_INTO)
    {
      i= next_i_v(i, +1, export_token_types, export_token_lengths);
      local_exports.file_name= text.mid(export_token_offsets[i], export_token_lengths[i]);
      local_exports.file_name= connect_stripper(local_exports.file_name, false); /* todo: consider: should we pass true rather than false here? */
    }

    if ((token == TOKEN_KEYWORD_FIELDS) || (token == TOKEN_KEYWORD_COLUMNS))
      lines_or_columns= TOKEN_KEYWORD_COLUMNS;
    if (token == TOKEN_KEYWORD_LINES)
      lines_or_columns= TOKEN_KEYWORD_LINES;
    if (token == TOKEN_KEYWORD_OPTIONALLY)
      local_exports.columns_optionally= true;

    if ((token == TOKEN_KEYWORD_MAX_ROW_COUNT)
     || (token == TOKEN_KEYWORD_NULL)
     || (token == TOKEN_KEYWORD_EXISTS)
     || (token == TOKEN_KEYWORD_COLUMN_NAMES) || (token == TOKEN_KEYWORD_QUERY)
     || (token == TOKEN_KEYWORD_ROW_COUNT)
     || (token == TOKEN_KEYWORD_MARGIN) || (token == TOKEN_KEYWORD_PAD) || (token == TOKEN_KEYWORD_LAST)
     || (token == TOKEN_KEYWORD_DIVIDER) || (token == TOKEN_KEYWORD_REPLACE) || (token == TOKEN_KEYWORD_WITH))
    {
      lines_or_columns= 0;
      i= next_i_v(i, +1, export_token_types, export_token_lengths);
      s= text.mid(export_token_offsets[i], export_token_lengths[i]);
      s= connect_stripper(s, false);
      int s_as_int= s.toInt();
      bool s_as_bool;
      if (s == "yes") s_as_bool= true;
      else s_as_bool= false;
      for (int j= 0; j < s.size(); ++j)
      {
        if (s.at(j).unicode() > 127) { error_message= "Non-ASCII"; goto ok_return; }
      }
      if (token == TOKEN_KEYWORD_MAX_ROW_COUNT) local_exports.max_row_count= s_as_int;
      if (token == TOKEN_KEYWORD_NULL) local_exports.if_null= to_byte_array(s);
      if (token == TOKEN_KEYWORD_REPLACE)
      {
        local_exports.replace_string= to_byte_array(s);
        if (local_exports.replace_string.length() > 1)
        {
          error_message= "REPLACE string maximum length = 1";
          goto ok_return;
        }
      }
      if (token == TOKEN_KEYWORD_WITH)
      {
        local_exports.with_string= to_byte_array(s);
        if (local_exports.with_string.length() > 2)
        {
          error_message= "WITH string maximum length = 2";
          goto ok_return;
        }
      }
      if (token == TOKEN_KEYWORD_EXISTS)
      {
        local_exports.if_file_exists= to_byte_array(s);
      }
      if (token == TOKEN_KEYWORD_COLUMN_NAMES) local_exports.column_names= s_as_bool;
      if (token == TOKEN_KEYWORD_QUERY) local_exports.query= s_as_bool;
      if (token == TOKEN_KEYWORD_ROW_COUNT) local_exports.row_count= s_as_bool;
      if (token == TOKEN_KEYWORD_MARGIN) local_exports.margin= s.toInt();
      if (token == TOKEN_KEYWORD_PAD) local_exports.pad= s_as_bool;
      if (token == TOKEN_KEYWORD_LAST) local_exports.last= s_as_bool;
      if (token == TOKEN_KEYWORD_DIVIDER) local_exports.divider= s_as_bool;
    }
    /* Todo: what if it's a number? or a constant like FALSE? */
    if ((token == TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE) || (token == TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE))
    {
      s= text.mid(export_token_offsets[i], export_token_lengths[i]);
      s= connect_stripper(s, false);
      i_prev_1= next_i_v(i, -1, export_token_types, export_token_lengths);         /* presumably BY */
      i_prev_2= next_i_v(i_prev_1, -1, export_token_types, export_token_lengths);

      token_prev_2= export_token_types[i_prev_2];

      if (lines_or_columns == TOKEN_KEYWORD_COLUMNS)
      {
        if (token_prev_2 == TOKEN_KEYWORD_ENCLOSED) local_exports.columns_enclosed_by= to_byte_array(s);
        else if (token_prev_2 == TOKEN_KEYWORD_ESCAPED)
        {
          local_exports.columns_escaped_by= to_byte_array(s);
          if (local_exports.columns_escaped_by.length() > 1)
          {
            error_message= "ESCAPED BY maximum length = 1";
            goto ok_return;
          }
        }
        else if (token_prev_2 == TOKEN_KEYWORD_TERMINATED) local_exports.columns_terminated_by= to_byte_array(s);
        else { error_message= "COLUMNS BAD?"; goto ok_return; }
      }
      if (lines_or_columns == TOKEN_KEYWORD_LINES)
      {
        if (token_prev_2 == TOKEN_KEYWORD_STARTING) local_exports.lines_starting_by= to_byte_array(s);
        else if (token_prev_2 == TOKEN_KEYWORD_TERMINATED) local_exports.lines_terminated_by= to_byte_array(s);
        else { error_message= "LINES BAD?"; goto ok_return; }
      }
    }
  }

  if (local_exports.file_name != "")
  {
    main_exports= local_exports;
    if (history_file_start("TEE", local_exports.file_name, &rr) == 0)
    {
      make_and_put_open_message_in_result(ER_FILE_OPEN, 0, rr);
      goto ok_ok_return;
    }
    else
    {
      goto ok_return;
    }
  }
ok_return: /* bad name, might not be okay, error_message decides that */
  if (error_message > "")
  {
    /* Todo: you could add the word "Error" and the token number and the token string */
    /* You want make_and_put_message_in_result but with ostrings that expects %, unlike E_ERROR */
    error_message= "Error " + error_message;
    put_message_in_result(error_message);
    return error_message;
  }
  if (rr == "") make_and_put_message_in_result(ER_OK, 0, (char*)"");
  else make_and_put_open_message_in_result(ER_OK_PLUS, 0, rr);
ok_ok_return:
  main_exports= local_exports;
  export_set_checked();
  return error_message;
}

/*
  Called from import_export_rule_set() or when user choice = cancel for an export dialog box.
  Menu items are in a QActionGroup so setting one choice will unset other choices.
  Re menu: If we got to import_export_rule_set() because user clicked a choice, then that choice already
           has a check mark beside it, it happens before we get here. Usually that's fine, it's no change.
           But if we put up the dialog box and user chooses cancel, that's not fine, go back to prior choice.
*/
void MainWindow::export_set_checked()
{
  QAction *q;
  if (main_exports.type == TOKEN_KEYWORD_TEXT) q= menu_spec_find_action("action_file_export_text");
  if (main_exports.type == TOKEN_KEYWORD_TABLE) q= menu_spec_find_action("action_file_export_table");
  if (main_exports.type == TOKEN_KEYWORD_HTML) q= menu_spec_find_action("action_file_export_html");
  if (main_exports.type == TOKEN_KEYWORD_NONE) q= menu_spec_find_action("action_file_export_none");
  if (q != NULL) q->setChecked(true);
}
#endif

/*
  Re TOKEN_KEYWORD_IMPORT:
    Currently for importing this is only called due to explorer_widget but probably it should be on main menu.
    We will recommend LOAD DATA because it is much much faster but import() may still be useful because:
    there are more options, every INSERT is loggable, special privilege is not required.
  Re TOKEN_KEYWORD_SOURCE:
    Todo: allow for MySQL-style or MariaDB-style comments since they may be followed by ; or may contain ;
    Executing the source-file statements is surprisingly easy: just put them in
       the statement widget. This should be activating action_settings_statement_edit_widget_changed
       and that ultimately causes execution.
       Handling multiple statements per line is okay, but SOURCE may not be witin multi-line.
       Difference from mysql client: this puts source-file statements in history, mysql client puts "source" statement.
  Re source containing INSERT:
    Ordinarily we can depend on InsertPlainText() -- which appends, and appending to statement_edit_widget
    triggers tokenize(), so the call to action_execute() has no difficulty seeing if statement is complete,
    and if so returning 1 so the appending repeats until statement works. However, some .sql files contain
    very long INSERTs, so the overhead of doing that gets noticeable. Therefore, if a line starts with
    INSERT, we try to fast-track by appending to a non-trigger buffer instead until we see a delimiter.
    This isn't perfect because we don't check for attempts to kill the statement, or for a result set.
    It's possible that other non-client non-result-set statements would benefit slightly too.
    We don't put the statement in history, though probably we should, if it's short.
    Alternative idea: put the insert data in a tmp file and use
  Todo: stop recursion i.e. source statement within source statement. That's an error.
  TODO: Would it be good if we could abort source statements with ^C? (as oposed to menu item Kill)
  TODO: Check for io error / premature eof
  TODO: This is skipping comment lines and blank lines, that's probably unnecessary.
  Todo: progress bar showing far we've progressed compared to file size in bytes.
  Todo: Kill should not just mean kill the last statement_widget statement, it should mean kill the whole thing.
  Todo: Find out why make_and_put_open_message_in_result doesn't show up.
        Would it show up if we said action_execute(1)?
  Todo: Optional initial pass just to check whether everything is valid.
  Todo: Todo: This is still bad:
        delimiter //
        drop procedure p\G
        select 5;
*/
int MainWindow::read_file(int keyword, QString s, QString table_name)
{
  log("read_file start", 70);
  QFile file(s);
  bool open_result= file.open(QIODevice::ReadOnly | QIODevice::Text);
  if (open_result == false)
  {
    make_and_put_open_message_in_result(ER_FILE_OPEN, 0, file.errorString());
    return 1;
  }
  /* Todo: this gets rid of SOURCE statement, but maybe it should be a comment in history. */
  statement_edit_widget->clear();
  QByteArray source_line;

  int last_action_execute_result= 0;

  for (;;)
  {
    if (file.atEnd() == true)
    {
       break;
    }
    /* source_line= ""; */
    source_line= file.readLine();
have_leftover:
    {
      if (keyword == TOKEN_KEYWORD_SOURCE)
      {
        if (last_action_execute_result != 1) /* sending empty lines to server would slow it */
        {
          int sls;
          for (;;)
          {
            sls= source_line.size();
            if ((sls >= 1) && (source_line.left(1) <= " ")) source_line= source_line.right(sls - 1);
            else if (source_line.left(2) == "\\G") source_line= source_line.right(sls - 2);
            else if (source_line.left(2) == "\\g") source_line= source_line.right(sls - 2);
            else if ((ocelot_delimiter_str.size() > 0) && (source_line.left(ocelot_delimiter_str.size()) == ocelot_delimiter_str)) source_line= source_line.right(sls - ocelot_delimiter_str.size());
            else break;
          }
          if (sls == 0) continue;
          if ((dbms_version_mask&FLAG_VERSION_MYSQL_OR_MARIADB_ALL) != 0)
          {
            if ((source_line.left(1) == "#") || (source_line.left(3) == "-- ")) continue; /* MySQL-MariaDB only? */
            if (source_line.left(6).toUpper() == "INSERT")
            {
               char delimiter_str[64];
               delimiter_str[63]= '\0';
               strcpy(delimiter_str, ocelot_delimiter_str.toUtf8());
               int delimiter_str_length= strlen(delimiter_str);
               /* Todo: dunno why no_backslash_escapes isn't being checked by tokenizer() too, as far as I can tell */
               /* make statement and execute it */
               int result_length;
               source_line= read_file_skip(source_line, source_line.length(),
                                delimiter_str, delimiter_str_length,
                              &file, &result_length);
               if (result_length < 0) break; /* i.e. if read_file_skip hit eof */
               if (source_line[0] != '\0')
               {
                 goto have_leftover; /* i.e. statement ended but line did not end */
               }
               continue;
             }
          }
        }
        statement_edit_widget->insertPlainText(source_line);
      }
      else /* TOKEN_KEYWORD_IMPORT */
      {
        QString s= source_line;
        s= connect_stripper(s, false);
        if (s.right(1) == "\n") s= s.left(s.size() - 1);
        if (s.right(1) == "\r") s= s.left(s.size() - 1);
        QString insert_statement= "INSERT INTO " + table_name + " VALUES (" + s + ");";
        statement_edit_widget->insertPlainText(insert_statement);
      }
      last_action_execute_result= action_execute(0);
      if (last_action_execute_result == 2)
      {
        /*
          A DBMS-calling statement failed.
          This doesn't operate exactly as --abort-source-on-error
          would for MariaDB client, because we only return 2 for
          statements that call the server and are not multiple.
        */
        if (ocelot_ca.abort_source_on_error > 0) break;
      }
   }
  }
  file.close();
  log("read_file end", 70);
  return 0;
}

/*
  Pass: statement. Initially must be INSERT statement but any non-compound non-client statement might be okay.
  Return: full statement and # of bytes left over after delimiter (-1 if eof)
          statement ends e.g. where ; or \ is seen (so you'll have to skip the delimiter)
  Although tokenize() would do the job well, this is faster.
  Gotchas: string can contain \0, can end with \G or \g
           can end with \ + something else i.e. mysql-client-style
           can contain \" or '\
           can contain "" or ''
           can contain delimiter inside quotes or comments
           can have \n while quote or comment is unfinished
  mysql client behaviour:
    See also: https://dev.mysql.com/doc/refman/8.0/en/string-literals.html
    Legal, \dx is a separate command: INSERT INTO t VALUES (5)\dx
    Legal, \ is thrown out: INSERT INTO t VALUES ('3 \dxrain')
    Legal, \n is preserved: INSERT INTO t VALUES ('\n3 rain');
    Legal, the usual: INSERT INTO t VALUES ('a' ' ' 'string');
    Legal, both rows are inserted: INSERT INTO t VALUES ('a')\ginsert into t values ('b');
    If NO_BACKSLASH_ESCAPES is false: \ escapes apply if in ''s, and if in ""s unless ansi_quotes.
    ; ends a statement even if there is a delimiter -- but that's crazy, how will compounds work?
      aha, they don't --- BEGIN NOT ATOMIC\nINSERT INTO t VALUES ('x');END; will fail
    Todo: Check tokenize(), I fear it might be missing the rule re backslash.
*/
QByteArray MainWindow::read_file_skip(QByteArray source_line, int source_line_length,
                   char *delimiter_str, int delimiter_str_length,
                   QFile *file,
                   int *result_length)
{
  QByteArray statement_result;
  char passed_expected_char= '\0';
  statement_result.clear(); /* unnecessary? */
  int statement_result_offset= 0;
  int k= 0;

  for (;;) /* loop till eof or statement end */
  {
    int statement_delimiter_length= 0;
    k= read_file_line_skip(source_line.data(), source_line_length, delimiter_str, delimiter_str_length,
                      &passed_expected_char, &statement_delimiter_length);
    if (k >= 0) /* i.e. did we reach a delimiter? */ /* actually k == 0) should be impossible */
    {
      statement_result.append(source_line, k - statement_delimiter_length);
      statement_result.append(";");
      if (source_line[k] == '\n') ++k; /* often line feed follows delimiter */
//      statement_result_offset+= k;
      source_line_length= source_line_length - k;
      source_line= QByteArray(source_line.data() + k, source_line_length); /* remainder */
//      statement_result[statement_result_offset - statement_delimiter_length]= '\0'; /* unnecessary? */
      statement_edit_widget->start_time= QDateTime::currentMSecsSinceEpoch();
      /* int insert_result= */
      lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION],
                                                        statement_result.data(), statement_result.size());
      put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
      QString query_utf16_bak= query_utf16;
      query_utf16= "/* INSERT statement */";
      history_markup_append("", true);
      query_utf16= query_utf16_bak;

      statement_result_offset= 0;
      source_line[source_line_length]= '\0';
      *result_length= source_line_length;/* i.e. we finished statement, source_line might have "leftover" */
      return source_line;
    }
    else /* k == -1 or k == -2 */
    {
      statement_result.append(source_line, source_line_length);
      statement_result_offset+= source_line_length;
      source_line_length= 0;
    }
    source_line= file->readLine();
    source_line_length= source_line.size();
    if ((source_line_length == 0) && (file->atEnd() == true))
    {
      break;
    }
//    if (fgets(source_line, 1024, *fp) == NULL) break;
  }
  *result_length= -1; /* i.e. let caller know we reached eof */
  return QByteArray();
}

int MainWindow::read_file_line_skip(char *source_line, int source_line_length,
                   char *delimiter_str, int delimiter_str_length,
                   char *passed_expected_char,
                   int *statement_delimiter_length)
{
  char c;
  char c2;
  char expected_char;
  for (int k= 0; k < source_line_length; ++k)
  {
    if (*passed_expected_char != '\0') /* i.e. if previous line had unfinished comment or quote */
    {
      expected_char= *passed_expected_char;
      *passed_expected_char= '\0';
      goto skip_till_passed_expected_char;
    }
    /* we expect source_line ends with \0 and delimiter cannot contain \0 */
    if ((delimiter_str_length != 0) && (memcmp(source_line + k, delimiter_str, delimiter_str_length) == 0))
      {
        *statement_delimiter_length= delimiter_str_length; return k + delimiter_str_length; }
    c= source_line[k];
    if ((c == ';') || (c == '\\'))
    {
      /* \ outside quotes normally will end a statement, though we don't do \dx etc. like mysql client. */
      if (c == ';') { *statement_delimiter_length= 1; return k + 1; }
      else if (source_line[k + 1] == 'G') { *statement_delimiter_length= 2; return k + 2; }
      else if (source_line[k + 1] == 'g') { *statement_delimiter_length= 2; return k + 2; }
      return k;
    }
    if ((c == '#') || ((c == '-') && (source_line[k + 1] == '-') && (source_line[k + 2] == ' ')))
    {
      /* '#' or '-- ' are comments as far as \n so line has no delimiter */
      return -1;
    }
    if ((c == '/') && (source_line[k + 1] == '*'))
    {
      expected_char= '*';
      goto skip_till_expected_char;
    }
    if ((c == '"') || (c == '`') || (c == '\x27'))
    {
      expected_char= c;
      goto skip_till_expected_char;
    }
    continue;
skip_till_expected_char:
    ++k;
skip_till_passed_expected_char:
    /* if source_line ends before comment or quote ends, return signal to check in next line */
    if (k >= source_line_length)
    {
      *passed_expected_char= expected_char;
      return -2;
    }
    c2= source_line[k];
/* Skip escaped \' or \" */
    if ((c2 == '\\') && (sql_mode_no_backslash_escapes == false)) /* but check this only for within ''s or ""s */
    {
      /* skip any escaped char, including " or ', we'll let the server take care of it */
      ++k;
      goto skip_till_expected_char;
    }
    /* Skip if single-character non-match, or * match but not followed by / */
    if ((c2 != expected_char)
     || ((expected_char == '*') && (source_line[k + 1] != '/')))
    {
      goto skip_till_expected_char;
    }
    /* Two ''s or two ""s within a quoted string don't end the string */
    if (((c2 == '\x27') && (source_line[k + 1] == '\x27'))
     || ((c2 == '"') && (source_line[k + 1] == '"')))
    {
      ++k;
      goto skip_till_expected_char;
    }
    /* end of a comment or quote so can continue in the main loop */
  }
  /* end of source_line, no delimiter seen */
  return -1;
}

QString MainWindow::statement_format_rule_apply(QString main_token, int main_token_type, unsigned char main_token_reftype, unsigned int main_token_flag, int *rule_token_offsets, int *rule_token_lengths, int *rule_token_types)
{
  (void) main_token_reftype; /* suppress "unused parameter" warning */
  (void) main_token_flag; /* suppress "unused parameter" warning */
  /* main_token_type might be an unreserved keyword but in context be used as an identifier */
  //if ((main_token_type >= TOKEN_KEYWORDS_START)
  // && ((main_token_flag & TOKEN_FLAG_IS_RESERVED) == 0)
  // && (main_token_reftype == TOKEN_REFTYPE_ANY))
  //  main_token_type= TOKEN_TYPE_IDENTIFIER;
  QString rule_token, replacee, replacer;
  int rule_type, rule_modifier_type;
  int i= 0;
  int match_type= 0; /* 0 is not match, 1 is = match, 2 is category match */
  for (; rule_token_lengths[i] != 0;)
  {
    replacee= "";
    replacer= "";
    bool is_becomes_seen= false;
    match_type= 0;
    for (; rule_token_lengths[i] != 0; ++i)
    {
      rule_token= ocelot_statement_format_rule.mid(rule_token_offsets[i], rule_token_lengths[i]);
      rule_type= rule_token_types[i];
      rule_modifier_type= 0;
      if ((rule_token_lengths[i + 1] == 1)
       && (ocelot_statement_format_rule.mid(rule_token_offsets[i + 1], 1) == "-")
       && (rule_token_lengths[i + 2] != 0))
      {
        i+= 2;
        rule_modifier_type= rule_token_types[i];
      }
      if (rule_type == TOKEN_KEYWORD_BECOMES)
      {
        is_becomes_seen= true;
        continue;
      }
      if (rule_type == TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_RULE) /* won't happen */
      {
        continue;
      }
      if ((rule_token == ",") || (rule_token == ";")) break;
      if (is_becomes_seen == false)
      {
        if (rule_type == TOKEN_KEYWORD_COMMENT)
        {
          if ((main_token_type >= TOKEN_TYPE_COMMENT_WITH_SLASH)
           && (main_token_type <= TOKEN_TYPE_COMMENT_WITH_MINUS))
          {
            replacee= main_token;
            match_type= 2;
          }
        }
        else if (rule_type == TOKEN_KEYWORD_IDENTIFIER)
        {
          if ((main_token_type >= TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK)
           && (main_token_type <= TOKEN_TYPE_IDENTIFIER_WITH_AT))
          {
            replacee= main_token;
            match_type= 2;
          }
        }
        if (rule_type == TOKEN_KEYWORD_KEYWORD)
        {
          if (main_token_type >= TOKEN_KEYWORDS_START)
          {
            replacee= main_token;
            match_type= 2;
          }
        }
        else if (rule_type == TOKEN_KEYWORD_LITERAL)
        {
          if ((main_token_type >= TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE)
           && (main_token_type <= TOKEN_TYPE_LITERAL_WITH_BRACE))
          {
            replacee= main_token;
            match_type= 2;
          }
        }
        if (rule_type == TOKEN_KEYWORD_OPERATOR)
        {
          if (main_token_type == TOKEN_TYPE_OPERATOR)
          {
            replacee= main_token;
            match_type= 2;
          }
        }
        else
        {
          if ((main_token == rule_token) && (rule_type != TOKEN_KEYWORD_KEYWORD))
          {
            replacee= rule_token;
            match_type= 1;
          }
        }
        if ((rule_modifier_type == TOKEN_KEYWORD_UPPER)
         && (main_token.toUpper() != main_token))
          match_type= 0;
        if ((rule_modifier_type == TOKEN_KEYWORD_LOWER)
         && (main_token.toLower() != main_token))
          match_type= 0;
      }
      else /* is_becomes_seen == true */
      {
        if (match_type > 0)
        {
          if (match_type == 2)
          {
            /* if category matched and this is category keyword */
            if ((rule_type == TOKEN_KEYWORD_COMMENT)
             || (rule_type == TOKEN_KEYWORD_IDENTIFIER)
             || (rule_type == TOKEN_KEYWORD_LITERAL)
             || (rule_type == TOKEN_KEYWORD_KEYWORD)
             || (rule_type == TOKEN_KEYWORD_OPERATOR))
            rule_token= replacee;
          }
          if (rule_modifier_type == TOKEN_KEYWORD_UPPER) rule_token= rule_token.toUpper();
          if (rule_modifier_type == TOKEN_KEYWORD_LOWER) rule_token= rule_token.toLower();
          if (rule_type == TOKEN_KEYWORD_COMMA) rule_token= ",";
          if (rule_type == TOKEN_KEYWORD_NEWLINE) rule_token= "\n";
          if (rule_type == TOKEN_KEYWORD_SEMICOLON) rule_token= ";";
          if (rule_type == TOKEN_KEYWORD_SPACE) rule_token= " ";
          if (rule_type == TOKEN_KEYWORD_TAB) rule_token= "\t";
          replacer.append(rule_token);
        }
      }
    }
    if (match_type > 0) break;
    if (rule_token == ";") break;
    ++i;
  }
  if (match_type > 0) return replacer;
  return main_token;
}

/*
  The event filter, for detecting:
    Has the user pressed on the vertical scroll bar of result_grid_widget?
    Has the user pressed Enter or return on statement_edit_widget?
      If the user presses Enter or Return on statement_edit_widget,
      and the last non-comment token is the delimiter (normally ";" unless DELIMITER happened),
      and the cursor is at the end i.e. after the delimiter,
      that should cause execution.
      Otherwise return false ...
      I've seen examples where, instead of "return false;", the
      instruction is "return QMainWindow::eventFilter(obj, event);".
      I think the idea there is to go direct to the main processor
      for text editing, bypassing other event filters.
  Note: statement_edit_widget mouseMoveEvent handling is in ocelotgui.h
  Todo: Consider: Perhaps this should not be in MainWindow:: but in CodeEditor::.
  Todo: Consider: Perhaps this should be a menu item, not a filter event.
                  (There's already a menu item, but it's not for Enter|Return.)
  There are a few "ocelotgui keyword" items that do not require ";" or delimiter
  provided they're the first word, for example "QUIT".
*/
bool MainWindow::eventFilter(QObject *obj, QEvent *event)
{
  return eventfilter_function(obj, event);
}

bool MainWindow::eventfilter_function(QObject *obj, QEvent *event)
{
  /*
    We got crashes in a long-running loop, ocelot_date_test().
    I figured it was because for long-running queries we set a flag and
    start a separate thread and loop with sleep + processEvents() so
    we can get here. I think this line added on 2019-01-01 prevents crashing.
    Todo: find out what the problem event is. Am I returning "true" wrongly?
    Warn: Now only shortcuts will work, the Ubuntu workaround won't be seen.
  */

  if (dbms_long_query_state == LONG_QUERY_STATE_STARTED) return false;

//  if (obj == result_grid_table_widget[0]->grid_vertical_scroll_bar)
//  {
//    /*
//      Probably some of these events don't cause scroll bar value to change,
//      I've only seen that happen for MouseMove and MouseButtonRelease.
//      But that's harmless, it only means we call scroll_event for nothing.
//    */
//    if ((event->type() == QEvent::KeyPress)
//    ||  (event->type() == QEvent::KeyRelease)
//    ||  (event->type() == QEvent::MouseButtonDblClick)
//    ||  (event->type() == QEvent::MouseButtonPress)
//    ||  (event->type() == QEvent::MouseButtonRelease)
//    ||  (event->type() == QEvent::MouseMove)
//    ||  (event->type() == QEvent::MouseTrackingChange)) return (result_grid_table_widget->scroll_event());
//  }
//  QString text; /* This is unused now */

  if (event->type() == QEvent::FocusIn)
  {
    menu_activations(obj, QEvent::FocusIn);
    if ((obj == statement_edit_widget) || (obj == completer_widget))
    {
      if (completer_widget->isHidden() == false)
      {
        completer_widget->timer_reset();
      }
    }
    else completer_widget->hide_wrapper();
    return false;
  }

  if (event->type() == QEvent::FocusOut)
  {
    menu_activations(obj, QEvent::FocusOut);
    return false;
  }

  {
    ResultGrid* r;
#if (OCELOT_EXPLORER == 1)
    for (int i_r= -1; i_r < ocelot_ca.grid_actual_tabs; ++i_r)
#else
    for (int i_r= 0; i_r < ocelot_ca.grid_actual_tabs; ++i_r)
#endif
    {
#if (OCELOT_EXPLORER == 1)
      if (i_r == -1) { r= explorer_widget; if (r == NULL) continue; }
      else
#endif
      r= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(i_r));
      if (obj == r)
      {
        if (event->type() == QEvent::FontChange) return (r->fontchange_event());
        if (event->type() == QEvent::Show) return (r->show_event());
      }
      if (obj == r->grid_vertical_scroll_bar)
      {
        return (r->vertical_scroll_bar_event(event, connections_dbms[0]));
      }
    }
  }
#if (OCELOT_MYSQL_DEBUGGER == 1)
  for (int debug_widget_index= 0; debug_widget_index < DEBUG_TAB_WIDGET_MAX; ++debug_widget_index)
  {
    if (obj == debug_widget[debug_widget_index])
    {
      if (event->type() == QEvent::MouseButtonPress)
      {
        action_debug_mousebuttonpress(event, debug_widget_index);
        return false;
      }
    }
  }
#endif

  if (event->type() != QEvent::KeyPress) return false;
  QKeyEvent *key= static_cast<QKeyEvent *>(event);
  /* See comment with label "Shortcut Duplication" */

  if (keypress_shortcut_handler(key) == true) return true;
  if (obj != statement_edit_widget) return false;
  if ((key->key() == Qt::Key_Down) && (completer_widget->key_up_or_down(+1))) return true;
  if ((key->key() == Qt::Key_Up) && (completer_widget->key_up_or_down(-1))) return true;
  if ((key->key() != Qt::Key_Enter) && (key->key() != Qt::Key_Return)) return false;
  /* No delimiter needed if Ctrl+Enter, which we'll regard as a synonym for Ctrl+E */
  if (key->modifiers() & Qt::ControlModifier)
  {
    action_execute(1);
    return true;
  }

  /*
    It's just Enter.
    If it's not at the end, not counting white space, don't try to execute.
    Anyway, don't force.
  */
  if (statement_edit_widget->textCursor().atEnd() == false)
  {
    int cursor_position= statement_edit_widget->textCursor().position();
    QString plain_text= statement_edit_widget->toPlainText();
    for (int i= cursor_position; i < plain_text.size(); ++i)
    {
      if (plain_text.mid(i, 1) > " ") return false;
    }
  }
  if (action_execute(0) == 1) return false;
  return true;
}

/*
  There are two reasons for keypress_shortcut_handler() to exist:
  1: see comment = "Shortcut duplication"
  2: we call not only from MainWindow::eventfilter_function()
     but also from TextEditWidget::keyPressEvent().
  If the keypress is a shortcut, we handle it and return true.
  If it's not, then it's probably text input, we return false.
  There was one situation that we did not handle:
    TextEditWidget handled ocelot_shortcut_copy_keysequence separately.
    Maybe it's due to the duplication of shortcuts (we use ^C for kill too but it's disabled unless we're executing)
  Todo: Maybe event->matches() is a more standard way to compare.
  Todo: Now there's redundancy -- we have setShortcut() for most of these combinations,
        and it seems to happen first, so probably we will only get here if the shortcut connection fails,
        which can happen for a disabled menu item or due to some Qt confusion or there was a case,
        I think it was Puppy Linux, where shortcuts were failing but keypresses were working.
  Todo: can we get here for a disabled menu item? I think it's possible
        if we're coming not from edit filter but from textedit key press
        event, so we should check "isenabled()" for more things.
  Todo: if e.g. action_edit_undo() does nothing because it can't find the
        classname, it should return false so keypress_shortcut_handler()
        can return false. Currently these things are all void.
  Todo: the system hasn't been tested with detached debugger widgets
        for which we've said SET ocelot_shortcut_...='something odd'.
  Todo: I'm not sure whether I want Qt's "nativeText" or "portbleText" for string conversion in this
  Re isEnabled:
    Probably menu_spec_action_all() will ignore menu items whose qaction->isEnabled() is false, so probably
    we'd get matches here. That's okay but we will still ignore them here, except for autocomplete.
  todo: for action_i(i, false) -- why false? this has something to do with options and check marks
  Todo: there was special checking for 'action_edit_copy' so copy() happened, it's gone now, but why was it there?
*/
bool MainWindow::keypress_shortcut_handler(QKeyEvent *key)
{
  Qt::KeyboardModifiers modifiers= key->modifiers();
  int qki= 0;
  if ((modifiers & Qt::ControlModifier) != 0) qki= (qki | Qt::CTRL);
  if ((modifiers & Qt::ShiftModifier) != 0) qki= (qki | Qt::SHIFT);
  if ((modifiers & Qt::AltModifier) != 0) qki= (qki | Qt::ALT);
  if ((modifiers & Qt::MetaModifier) != 0) qki= (qki | Qt::META);
  QKeySequence qk= QKeySequence(key->key() | qki);
#if (OCELOT_EXPLORER == 1)
  if (explorer_widget != NULL)
  {
    if (explorer_widget->html_text_edit->explorer_context_menu->shortcutter(qk) == true) return true;
  }
#endif
  /* Compare the QKeySequence that user typed, as QString, to menu_spec_struct_list[].shortcut; */
  QString qk_string= qk.toString(QKeySequence::NativeText);
  for (int i= 0; i < menu_spec_struct_list.size(); ++i)
  {
    if (qk_string == menu_spec_struct_list[i].shortcut)
    {
      QAction *qaction= menu_spec_struct_list[i].qaction;
      if ((qaction != NULL) && (qaction->isEnabled() == false))
      {
        if (menu_spec_struct_list[i].id != "action_edit_autocomplete") continue;
      }
      action_i(i, false);
      return true; /* so we only do the first enabled item, if there was no break then we'd do them all */
    }
  }
  return false;
}

/*
  We want to know: do we have a complete statement at the string start.
  So we find out how many tokens are in the (first) statement.
  We go forward to find the first non-comment token, the statement type.
  We go backward to find the final non-comment token, the ; or delimiter -- or not.
  Using these, and knowing what is ocelot_delimiter_str, we can decide if it's complete.
  We also check for \G or \g.
  We also check whether we're ultimately in "SOURCE file_name" because then ; may work even if not the delimiter.
  And, although ; always ends a statement, if it's not a delimiter, we return false if no delimiter later.
  Todo: after delimiter // then select 5; select 6\G should work, \G doesn't care about delimiters
*/

bool MainWindow::is_statement_complete(QString text)
{
  int number_of_tokens_in_statement= 0;
  int returned_begin_count= 0;
  int i= 0;
  int first_token_type= -1;
  int first_token_i= 0;
  //int last_token_type= -1;
  QString first_token= "";
  QString last_token= "";
  QString second_last_token= "";
  number_of_tokens_in_statement= get_next_statement_in_string(0, &returned_begin_count, false);
  for (i= 0; i < number_of_tokens_in_statement; ++i)
  {
    int t= main_token_types[i];
    if (t == TOKEN_TYPE_COMMENT_WITH_SLASH) continue;
    if (t == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE) continue;
    if (t == TOKEN_TYPE_COMMENT_WITH_MINUS) continue;
    first_token_type= t;
    first_token= text.mid(main_token_offsets[i], main_token_lengths[i]);
    first_token_i= i;
    break;
  }
  for (i= number_of_tokens_in_statement - 1; i >= 0; --i)
  {
    int t= main_token_types[i];
    if (t == TOKEN_TYPE_COMMENT_WITH_SLASH) continue;
    if (t == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE) continue;
    if (t == TOKEN_TYPE_COMMENT_WITH_MINUS) continue;
    //last_token_type= t;
    last_token= text.mid(main_token_offsets[i], main_token_lengths[i]);
    if (i > 0) second_last_token= text.mid(main_token_offsets[i - 1], main_token_lengths[i - 1]);
    break;
  }
  /* No delimiter needed if first word in first statement of the input is an ocelotgui keyword e.g. QUIT */
  /* Todo: this means that a client statement cannot be spread over two lines but for SET client-statement we wait for ; */
  if (is_client_statement(first_token_type, first_token_i, text) == true)
  {
    if (first_token_type != TOKEN_KEYWORD_SET) return true;
  }

  /* "go" or "ego", alone on the line, if --named-commands, is statement end */
  /* Todo: but these are client statements so we won't ever get here */
  /* Todo: I forget why we care. Is it in fact because the token is \G or \g? */
  if ((ocelot_ca.named_commands > 0)
  && ((first_token_type == TOKEN_KEYWORD_GO) || (first_token_type == TOKEN_KEYWORD_EGO)))
  {
    QString q;
    for (int i_off= main_token_offsets[i] - 1;; --i_off)
    {
      if (i_off < 0) q= "\n";
      else q= text.mid(i_off, 1);
      if ((q == "\n") || (q == "\r"))
      {
        return true;
      }
      if (q != " ") break;
    }
  }
  /* if create-routine && count-of-ENDs == count-of-BEGINS then ; is the end else ; is not the end */
  bool is_semicolon_maybe_completer= false;
  if ((is_in_source_statement == true) && (last_token == ";")) is_semicolon_maybe_completer= true;
  if ((ocelot_delimiter_str != ";") && (is_semicolon_maybe_completer == false))
  {
    returned_begin_count= 0;
  }
  else
  {
    int token_count= get_next_statement_in_string(0, &returned_begin_count, false);
    if (returned_begin_count == 0)
    {
      if (QString::compare(last_token, ";", Qt::CaseInsensitive) == 0)
      {
        /* Warning: this only works if we've gone through hparse */
        /* plsql routines might have var|cursor|condition before begin */
        if ((main_token_flags[token_count - 1] & TOKEN_FLAG_IS_PLSQL_DECLARE_SEMICOLON) != 0)
        {
          for (int k= token_count - 1;;--k)
          {
            if (main_token_types[k] == TOKEN_KEYWORD_BEGIN) break;
            if (k == 0)
            {
              /* saw no begin but flag counts as a begin */
              ++returned_begin_count;
              break;
            }
          }
        }
        if (returned_begin_count == 0) return true;
      }
      if (QString::compare(last_token, "G", Qt::CaseInsensitive) == 0)
      {
        if (QString::compare(second_last_token, "\\", Qt::CaseInsensitive) == 0)
        {
          return true;
        }
      }
    }
  }
  if (last_token != ocelot_delimiter_str)
  {
    if (last_token == ";")
    {
      bool is_delimiter_later= false;
      for (unsigned int j= 0; j < main_token_count_in_all; ++j)
      {
        if (main_token_lengths[j] == 0) break;
        if (main_token_types[j] == TOKEN_TYPE_DELIMITER)
        {
          is_delimiter_later= true;
        }
      }
      if (is_delimiter_later == false) return false;
    }
    else return false;
  }

  if (returned_begin_count > 0)
  {
    return false;
  }
  /* All conditions have been met. Tell caller to Execute, and eat the return key. */
  return true;
}


/*
  History
  =======

  The history widget history_edit_widget is an editable subclass of QTextEdit
  which contains retired statements + errors/warnings, scrolling
  so it looks not much different from the mysql retired-statement
  scrolling.
  However, our history does not include result sets (unless
  result_set_for_history, described later).
  These user-settable variables affect history_edit_widget:
  ocelot_history_text|background|border_color      default = system
  ocelot_history_font_family|size|style|weight     default = system
  ocelot_ca.history_includes_warnings                 default = 0 (no)
  ocelot_history_max_row_count                     default = 0 (suppressed)
  ocelot_history_{left|top|width|height}           default
  ocelot_histfileflags                             (default is "L") see also HIST and HISTIGNORE
  ocelot_histfilesize                              (default is "2000000000")
  ocelot_histsize                                  (default is "500")

  The statement is always followed by an error message,
  but ocelot_history_includes_warnings is affected by ...
  warnings  (\W) Show warnings after every statement.
  nowarning (\w) Don't show warnings after every statement.
  If the prompt is included, then we should be saving time-of-day
  for the first statement-line prompt and doing prompt_translate()
  for each line of the statement when we copy it out.
  The history_edit_widget is TextEditHistory which is derived from
  QTextEdit, differing from statement_edit_widget which is CodeEditor
  which is derived from QPlainTextEdit.

  History menu items / commands:
  * The usual edit menu items = cut, copy, paste, etc.
    Therefore we don't really need to limit history size, users can clear.
  * Previous Statement ^P and Next Statement ^N
    ? Possible alternatives: alt+up-arrow|alt+down-arrow, PgUp|PgDn
    ? Possible alternative: up-arrow if we're at top of statement widget
      (which is more like what mysql client would do)
    * disable if there's no previous / next
    * if done on statement widget, brings in from history -- dunno if history should scroll when that happens
    ? when bringing in from history to statement, don't re-execute
    * if user executes a restated statement, there's a behaviour choice: now the restated statement is last statement, or now the last-picked statement is still last statement
  * Open | Save | Close | Delete (not implemented)
    * file items, with the intent of keeping history
    * you can go back in history by going back in a file
    * format should be the same as MySQL log history
      ? but in that case, should display look like MySQL log too?
    * Save means "save what's being shown, so it's affected by Hide
  * Find | Goto
    * you need these menu items for history soon, so might as well have them for statements too
  * Hide prompt + Hide result + Hide result set
  + Settings: History Widget has different colors for prompt/statement/result/result set

  Comments unrelated to HTML work:
  Possible difficulty: our history is statement-at-a-time, not screen-at-a-time", if there are multi statements
  Certain statements might be suppressed
    * should Quit and Source go in history?
    * should only data-change statements go in history?
    * should client-statements be suppressed?
    * this is a "Filter" matter
    ? to what extent is this useful for audit?
    Wherever there's a menu item, there should also be a client-statement
    * history must include comments even if they're not sent to the server (there's some mysql-option for that)
    * Delimiter might change, so when you copy from history to statement, what should you do?
    * When the debugger comes in, statements done by the debugger are a special history category

  HTML in the history widget
  Unlike statement_edit_widget, history_edit_widget is TextEditHistory
  derived from QTextEdit and allows rich text, editable, containing HTML.
  Each history entry has: prompt, statement, result, and possibly result set.
  (Result set depends on ocelot_history_max_row_count, 0 by default, and
  see copy_to_history, it's supposed to appear like mysql client result set.)
  There are two kinds of markup:
  (1) <span style="...">...</span> for changes to color + font.
      Currently this is only used for history prompt bgcolor = statement prompt bgcolor.
  (2) <a name='[mark]'> for showing what kind of text follows.
      The markups are <a name='STATEMENT START'> ... <a name='STATEMENT END'>
                <a name='PROMPT START'> ... <a name='PROMPT END'>
                <a name='RESULT'> (ends when statement ends)
                <a name='ENTITY'> (always an entity for a single & character)
      Digia does not document or guarantee what it will do with <a>
      and we're not using it for its intended function as anchor.
      Example: "SELECT * FROM t <br> WHERE x < '&';" becomes
      <a name='STATEMENT START'>
      <span ...><a name='PROMPT'>mysql&gt;<a name='PROMPT END'></span>
      SELECT * FROM t <br>
      <a name='PROMPT'>&gt;<a name='PROMPT END'>
      WHERE a &lt; '<a name='ENTITY'>&amp;';
      <span ...><a name='RESULT'>OK</span>
      <a name='STATEMENT END'>
  Handle PgUp | PgDn by picking up next | previous STATEMENT START ... END.
  When copying to history, change < and > and & to entities but mark if '&'.
    Also: change ' and " to entities.
  When copying from history, change entities to < and > and & unless marked.
  Todo: hide prompt + result by putting whole thing within <a name='...'>.
  In order to see the HTML, say:
    QMessageBox msgBox;
    msgBox.setTextFormat(Qt::PlainText);
    msgBox.setText(history_edit_widget->toHtml());
    msgBox.exec();
  History is editable.
    If the user inputs "<" when editing the history,
    change that to an entity immediately -- but maybe Qt will do that.
  Idea: use QTextCursor to change cursor in history if PgUp|PgDn in statement.
  Idea: multiple types of result: warning, error, result set
*/

void MainWindow::initialize_widget_history()
{
  history_edit_widget->setStyleSheet(ocelot_history_style_string);
  history_edit_widget->setReadOnly(false);       /* if history shouldn't be editable, set to "true" here */
  history_edit_widget->hide();                   /* hidden until a statement is executed */
  history_markup_make_strings();
  history_edit_widget->installEventFilter(this); /* must catch focusIn */
  return;
}


/*
  Set the strings that will be used for markup comments in history widget.
  Call history_markup_make_strings() at program start.
  Todo: At the moment these could be constants but I don't think they always will be.
  Note: <br> in history_markup_statement_start is necessary; else prompt_start is ignored.
*/
void MainWindow::history_markup_make_strings()
{
  history_markup_statement_start= "<a name=\"STATEMENT START\"></a><br>";
  history_markup_statement_end=   "<a name=\"STATEMENT END\"></a>";
  history_markup_prompt_start=    "<a name=\"PROMPT START\"></a>";
  history_markup_prompt_end=      "<a name=\"PROMPT END\"></a>";
  history_markup_result=          "<a name=\"RESULT\"></a>";
  history_markup_entity=          "<a name=\"ENTITY\"></a>";
}


/* The following will append the statement to history, line-at-a-time with prompts. */
/* It seems to work except that the prompt is not right-justified. */
/* is_interactive == false if we're reading from mysql_histfile during start */
/* Todo: right justify. Make it optional to show the prompt, unless prompt can be hidden. */
void MainWindow::history_markup_append(QString result_set_for_history, bool is_interactive)
{
  QString plainTextEditContents;
  QStringList statement_lines;
  int statement_line_index;
  QString history_statement;
  plainTextEditContents= query_utf16; /* Todo: consider: why bother copying rather than using query_uitf16? */
  statement_lines= plainTextEditContents.split("\n");
  //statement_line_index= 0;                                                          /* Todo throw this useless line away */
  /* Todo: There should be a better way to ensure that Qt realizes the whole widget is rich text. */
  /* Todo: Some of this could be at start of history_edit_widget but what would happen if I cleared the whole area? */
  /* Todo: background-color of prompt could be settable for history widget, rather than = statement background color. */
  history_statement= "<i></i>";                                           /* hint that what's coming is HTML */
  history_statement.append(history_markup_statement_start);

  for (statement_line_index= 0; statement_line_index < statement_lines.count(); ++statement_line_index)
  {
    history_statement.append("<span style=\" background-color:");
    history_statement.append(ocelot_statement_prompt_background_color);
    history_statement.append(";\">");
    history_statement.append(history_markup_prompt_start);
    if (is_interactive == true) history_statement.append(history_markup_copy_for_history(statement_edit_widget->prompt_translate(statement_line_index + 1)));
    else history_statement.append("-");
    history_statement.append(history_markup_prompt_end);
    history_statement.append("</span>");
    history_statement.append(history_markup_copy_for_history(statement_lines[statement_line_index]));
    history_statement.append("<br>");
  }

  history_statement.append(history_markup_result);
  if (is_interactive == true)
    history_statement.append(history_markup_copy_for_history(statement_edit_widget->result)); /* the main "OK" or error message */
  else history_statement.append("--");
  if (result_set_for_history > "")
  {
    history_statement.append("<pre>");
    history_statement.append(history_markup_copy_for_history(result_set_for_history));
    history_statement.append("</pre>");
  }

  history_statement.append(history_markup_statement_end);

  history_edit_widget->append(history_statement);

  history_markup_counter= 0;

  if (is_interactive == false) return;

  /*  not related to markup, just a convenient place to call */
  history_file_write("HIST", query_utf16, false);
}

void MainWindow::tee_export(QString result_set_for_history)
{
  if (main_exports.query == true) history_file_write("TEE", query_utf16, true);
  if (main_exports.row_count == true) history_file_write("TEE", statement_edit_widget->result, true);
  if (main_exports.max_row_count > 0) /* ? For some reason this was "if result_set_for_history > "" */
  {
#if (OCELOT_IMPORT_EXPORT == 1)
    if (main_exports.type == TOKEN_KEYWORD_HTML)
    {
      /* Todo: There's silly repetition here. You should pass rg to tee_export! */
      ResultGrid *rg;
      rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));
      rg->display_html(0, TOKEN_KEYWORD_OCELOT_EXPORT);
    }
    else if ((main_exports.type == TOKEN_KEYWORD_DEFAULT) || (main_exports.type == TOKEN_KEYWORD_NONE))
    {
      /* todo: TOKEN_KEYWORD_DEFAULT no longer has effect, maybe we'll revive though, as "same as history" */
      history_file_write("TEE", result_set_for_history, true);
    }
    else
    {
      /* assume TEXT or TABLE */
      ResultGrid *rg;
      QString result_set_for_history;
      bool is_vertical= false;
      char file_name[128]; /* should be in the dialog box */
      strcpy(file_name, main_exports.file_name.toUtf8());
      rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));
      result_set_for_history= rg->copy_to_history(main_exports.max_row_count, is_vertical, connections_dbms[0], file_name);
    }
  }
#else
  history_file_write("TEE", result_set_for_history, true);
#endif
}


/* When copying to history, change < and > and & and " to entities. */
/* Change on 2015-03-16: change newline to <br>. */
QString MainWindow::history_markup_copy_for_history(QString inputs)
{
  QString outputs;
  QString c;
  int i;

  outputs= "";
  for (i= 0; i < inputs.length(); ++i)
  {
    c= inputs.mid(i, 1);
    if (c == "<") c= "&lt;";
    if (c == ">") c= "&gt;";
    if (c == "&") c= "&amp;";
    if (c == "\"") c= "&quot;";
    if (c == "\n") c= "<br>";
    outputs.append(c);
  }
  return outputs;
}


/* In response to edit menu "Previous statement" or "Next statement",
   make statement widget contents = a previous statement from history,
   without executing.
   When copying from history, change entities to < and > and & and "
   But the job is much bigger than that.
   Find "STATEMENT START".
   Start copying.
   Skip everything between "PROMPT START" and "PROMPT END".
   Stop copying when you see "RESULT".
*/
/* this was named history_markup_previous but let's make names of menu items consistent */
void MainWindow::action_edit_previous_statement(bool is_checked)
{
  (void)is_checked;
  ++history_markup_counter;
  if (history_markup_previous_or_next() == -1) --history_markup_counter;
}

/* this was named history_markup_next but let's make naming of edit actions consistent */
void MainWindow::action_edit_next_statement(bool is_checked)
{
  (void)is_checked;
  --history_markup_counter;
  if (history_markup_previous_or_next() == -1) ++history_markup_counter;
}


int MainWindow::history_markup_previous_or_next()
{
  QString outputs;
  QString final_outputs;
  int index_of_prompt_end;
  int index_of_a_gt, index_of_lt_a;
  int i;
  QString c;
  int search_start_point;

  QString s;
  int index_of_statement_start;
  int index_of_result;

  s= history_edit_widget->toHtml();
  search_start_point= -1;                                                    /* search starting from end of string */
  for (i= 0;;)
  {
    index_of_statement_start= s.lastIndexOf("\"STATEMENT START\"", search_start_point);
    if (index_of_statement_start == -1) return -1;                           /* (statement start not found) */
    index_of_result= s.indexOf("\"RESULT\"", index_of_statement_start);
    if (index_of_result == -1) return -1;                                    /* (result not found) */
    ++i;
    if (i >= history_markup_counter) break;                                  /* (we're at the right SELECT) */
    search_start_point= index_of_statement_start - 1;                        /* keep going back */
  }
  outputs= "";

  s= s.mid(index_of_statement_start, index_of_result - index_of_statement_start);

  /* At this point s = whatever's between statement start and result */
  /* But there might be a series of repeat(prompt-start prompt-end real-statement) till result */
  for (;;)
  {
    index_of_prompt_end= s.indexOf("\"PROMPT END\"", 0);
    if (index_of_prompt_end == -1) break;
    index_of_a_gt= s.indexOf("a>", index_of_prompt_end) + 2;
    if (index_of_a_gt == -1) break;
    index_of_lt_a= s.indexOf("<a", index_of_a_gt);
    if (index_of_lt_a == -1) break;
    outputs.append(s.mid(index_of_a_gt, index_of_lt_a - index_of_a_gt));
    s= s.mid(index_of_a_gt, -1);
  }

  /* At this point outputs = the statement but it might contain entities
     so reverse whatever happened in history_markup_copy_for_history(),
     and change <br> back to \r.
     Todo: check what happens if original statement contains an entity.
  */
  final_outputs= "";
  for (i= 0; i < outputs.length(); ++i)
  {
    if (outputs.mid(i, 4) == "<br>")
    {
      final_outputs.append("\r");
      i+= 3;
    }
    else if (outputs.mid(i, 6) == "<br />")
    {
      final_outputs.append("\r");
      i+= 5;
    }
    else if (outputs.mid(i, 4) == "&lt;")
    {
      final_outputs.append("<");
      i+= 3;
    }
    else if (outputs.mid(i, 4) == "&gt;")
    {
      final_outputs.append(">");
      i+= 3;
    }
    else if (outputs.mid(i, 5) == "&amp;")
    {
      final_outputs.append("&");
      i+= 4;
    }
    else if (outputs.mid(i, 6) == "&quot;")
    {
      final_outputs.append("\"");
      i+= 5;
    }
    else
    {
      c= outputs.mid(i, 1);
      final_outputs.append(c);
    }
  }

  statement_edit_widget->setPlainText(final_outputs);
  return 0;
}


/*
  tee+hist
  --------
  TEE
  * Code related to tee should have the comment somewhere = "for tee"
  * bool ocelot_ca.history_tee_file_is_open initially is false
  * the options --tee=filename and --no-tee exist, and they are checked (I think)
  * the client statements tee filename and notee will be seen
  * there are no menu options (todo: decide whether this is a flaw)
  * apparently the mysql client would flush, therefore we call flush() after writing
  * the mysql client would include results from queries, but we do so only for TEE (todo: decide whether this is a flaw)
  * there might be html in the output (todo: decide whether this is a flaw)
  HIST
  * read http://ocelot.ca/blog/blog/2015/08/04/mysql_histfile-and-mysql_history/
  * bool ocelot_ca.history_hist_file_is_open initially is false but it's opened if successful connect
  * --batch or --silent or setting name to /dev/null turns history off
  EITHER
  * Ignore if filename is "", is "/dev/null", or is a link to "/dev/null"
  HANDLE ^P AND ^N
    If a statement is multi-line:
      In history_file_write() if ocelot_histfileflags>"" (default is "L"), we precede with a comment:
      -- lines: n
      In history_file_to_history_widget() if we see "-- lines: " we read n lines together
  COMPATIBILITY:
    mysql and ocelotgui can both read and write .mysql_history
    mysql does not have our multi-line trick so won't show multi-line statements correctly
    mysql writes statements that fail, ocelotgui doesn't
    mysql will of course see our added comment line but user can ignore it, or set ocelot_histfileflags
   QRegExp is unavailable in Qt 6. Todo: We have never tested the replacemnt QRegularExpression code.
*/
void MainWindow::history_file_write(QString history_type, QString text_line, bool nflag)  /* see comment=tee+hist */
{
  if (history_type == "TEE")
  {
    if (ocelot_ca.history_tee_file_is_open == false) return;
  }
  else
  {
    if (ocelot_ca.history_hist_file_is_open == false) return;
    /* see Wildcard Matching section in http://doc.qt.io/qt-4.8/qregexp.html */
    int qfrom= 0;
    int qindex;
    QString qs;
    for (;;)
    {
#if (QT_VERSION >= 0x60000)
      QRegularExpression rx;
#else
      QRegExp rx;
#endif
      if (qfrom >= ocelot_histignore.length()) break;
      qindex= ocelot_histignore.indexOf(":", qfrom, Qt::CaseInsensitive);
      if (qindex == -1) qindex= ocelot_histignore.length();
      qs= ocelot_histignore.mid(qfrom, qindex - qfrom);
#if (QT_VERSION >= 0x60000)
      rx= QRegularExpression(qs, QRegularExpression::CaseInsensitiveOption);
      QRegularExpressionMatch match = rx.match(text_line);
      if (match.hasMatch() == true) return;
#else
      rx= QRegExp(qs);
      rx.setPatternSyntax(QRegExp::Wildcard);
      rx.setCaseSensitivity(Qt::CaseInsensitive);
      if (rx.exactMatch(text_line) == true) return;
#endif
      qfrom= qindex + 1;
    }
  }

  QString s= text_line;
  int query_len= s.toUtf8().size();                  /* See comment "UTF8 Conversion" */
  char *query= new char[query_len + 1];
  memcpy(query, s.toUtf8().constData(), query_len + 1);
  query[query_len]= '\0';                            /* todo: think: is this necessary? */
  if (history_type == "TEE")
  {
    ocelot_history_tee_file.write(query, strlen(query));
    /* We need the \n but not an extra \n if we append. */
    if ((main_exports.type == TOKEN_KEYWORD_DEFAULT) || (nflag == true))
    {
      ocelot_history_tee_file.write("\n", strlen("\n"));
    }
    ocelot_history_tee_file.flush();
  }
  else
  {
    if (ocelot_histfileflags > "")
    {
      char f_line[4096];
      int lines_count= 1;
      for (char *cquery= query; *cquery != '\0'; ++cquery) if (*cquery == '\n') ++lines_count;
      char prompt[64 * 3 + 1];
      if (ocelot_histfileflags.contains("P", Qt::CaseInsensitive) == true)
      {
        QString s_prompt= statement_edit_widget->prompt_translate(1);
        if (s_prompt.size() > 64) s_prompt= s_prompt.right(64);
        strcpy(prompt, s_prompt.toUtf8());
      }
      else prompt[0]= '\0';
      sprintf(f_line, "-- lines: %d %s\n", lines_count, prompt);
      ocelot_history_hist_file.write(f_line, strlen(f_line));
    }
    ocelot_history_hist_file.write(query, strlen(query));
    ocelot_history_hist_file.write("\n", strlen("\n"));
    ocelot_history_hist_file.flush();
  }
  delete []query;
}


/* Todo: we're returning a detailed error message for tee but not for hist */
int MainWindow::history_file_start(QString history_type, QString file_name, QString *rr) /* see comment=tee+hist */
{
  *rr= "";
  QString file_name_to_open;
  if (history_type == "TEE")
  {
    file_name_to_open= ocelot_history_tee_file_name;
    if (ocelot_ca.history_tee_file_is_open == true)
    {
      ocelot_history_tee_file.close();
      ocelot_ca.history_tee_file_is_open= false;
    }
  }
  else
  {
    file_name_to_open= ocelot_history_hist_file_name;
    if (ocelot_ca.history_hist_file_is_open == true)
    {
      ocelot_history_hist_file.close();
      ocelot_ca.history_hist_file_is_open= false;
    }
    if (ocelot_ca.batch != 0) return 1;                     /* if --batch happened, no history */
    if (ocelot_ca.silent != 0) return 1;                    /* if --silent happened, no history */
  }

  if (file_name != "") file_name_to_open= file_name;
  int query_len= file_name_to_open.toUtf8().size();  /* See comment "UTF8 Conversion" */
  char *query= new char[query_len + 1];
  memcpy(query, file_name_to_open.toUtf8().constData(), query_len + 1);
  query[query_len]= '\0';                            /* todo: think: is this necessary? */

  /* If file name == "/dev/null" or something that links to "/dev/null", don't try to open. */
  if (file_name_to_open == "/dev/null") { delete []query; return 0; }
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
  char tmp_link_file[9 + 1];
  if (readlink(query, tmp_link_file, 9 + 1) == 9)
  {
    if (memcmp(tmp_link_file, "/dev/null", 9) == 0) {delete []query; return 0; }
  }
#endif

  bool open_result;
  if (history_type == "TEE")
  {
    QString q_file_name= query;
    if (q_file_name.compare("stdout", Qt::CaseInsensitive) == 0)
    {
      /* todo: check: should I be adding other QIODevice flags? */
      open_result= ocelot_history_tee_file.open(stdout, QIODevice::WriteOnly);
      *rr= q_file_name;
    }
    else
    {
      QFileInfo file_info(query);
      QString absolute_file_path= file_info.absoluteFilePath();
      ocelot_history_tee_file.setFileName(query);
      if (strcmp(main_exports.if_file_exists.data(), "error") == 0)
      {
#if (QT_VERSION < 0x50b00)
        /* QT_VERSION < 5.11 at compile-time, but QIODevice::NewOnly was made legal in Qt 5.11 */
        if (file_info.exists() == true) open_result= false;
        else open_result= ocelot_history_tee_file.open(QIODevice::WriteOnly | QIODevice::Text);
#else
        open_result= ocelot_history_tee_file.open(QIODevice::NewOnly | QIODevice::Text);
#endif
      }
      else if (strcmp(main_exports.if_file_exists.data(), "replace") == 0)
      {
        open_result= ocelot_history_tee_file.open(QIODevice::ReadWrite | QIODevice::Truncate | QIODevice::Text);
      }
      else /* strcmp(main_exports.if_file_exists.data(), "append") == 0 */
        open_result= ocelot_history_tee_file.open(QIODevice::Append | QIODevice::Text);
      if (open_result == true) *rr= absolute_file_path;
      else *rr= absolute_file_path + " " + ocelot_history_tee_file.errorString();
    }
    delete []query;
    if (open_result == false) return 0;
    ocelot_ca.history_tee_file_is_open= true;
    ocelot_history_tee_file_name= file_name_to_open;
    return 1;
  }
  else
  {
    ocelot_history_hist_file.setFileName(query);
    open_result= ocelot_history_hist_file.open(QIODevice::Append | QIODevice::Text);
    delete []query;
    if (open_result == false) return 0;
    ocelot_ca.history_hist_file_is_open= true;
    ocelot_history_hist_file_name= file_name_to_open;
    return 1;
  }
  return 0;
}


void MainWindow::history_file_stop(QString history_type)   /* see comment=tee+hist */
{
  if (history_type == "TEE")
  {
    ocelot_history_tee_file.close();
    ocelot_ca.history_tee_file_is_open= false;
  }
  else
  {
    ocelot_history_hist_file.close();
    ocelot_ca.history_hist_file_is_open= false;
  }
}

/*
  This is putting in the history widget, indeed, BUT ...
  Todo: The history widget seems to grow when I type something for the first time
  Todo: Make sure there's no disaster if file is /dev/null or blank.
  We try to open the history file during each connect.
  If we successfully open, but only the first time, we copy its lines to the history widget.
  Re histsize: Read file backward searching for \n, then read forward dumping to history_widget.
  Re histfilesize: If we need to shrink, at end, re-open for write, copy what's kept, truncate.
  We back up statement-at-a-time rather than line-at-a-time if there are -- lines: comments.
  Todo: Do it all with QFile
*/
#define HISTORY_BUFFER_SIZE 8192
#define LINES_SIZE 10
void MainWindow::history_file_to_history_widget()         /* see comment=tee+hist */
{
  char history_buffer[HISTORY_BUFFER_SIZE + LINES_SIZE + 16];
  history_buffer[0]= '\0';
  FILE *history_file;
  if (ocelot_ca.batch != 0) return;                          /* if --batch happened, no history */
  if (ocelot_ca.silent != 0) return;                         /* if --silent happened, no history */
  if (ocelot_ca.history_hist_file_is_copied == true) return;        /* we've alredy done this */
  //if (ocelot_ca.history_hist_file_is_open == false) return;
  {
    int query_len= ocelot_history_hist_file_name.toUtf8().size();  /* See comment "UTF8 Conversion" */
    char *query= new char[query_len + 1];
    memcpy(query, ocelot_history_hist_file_name.toUtf8().constData(), query_len + 1);
    query[query_len]= '\0';                            /* todo: think: is this necessary? */
    history_file= fopen(query, "r");
    delete []query;
  }
  int histfilesize= ocelot_histfilesize.toInt();
  int histsize= ocelot_histsize.toInt();
  int file_size; /* could be size_t but history files won't be multi-gigabyte */
  int file_position;
  int file_position_at_histsize= -1;
  int file_position_at_histfilesize= -1;
  int line_counter= 0;
  if (history_file == NULL) goto returner;
  if (fseek(history_file, 0 , SEEK_END) != 0) {fclose(history_file); goto returner; }
  file_size= ftell(history_file);
  file_position= file_size;
  if (file_size <= histfilesize)
  {
    /* We will not need to truncate */
    if (histsize == 0) {fclose(history_file); goto returner; } /* Don't need to read or write */
    file_position_at_histfilesize= 0;
  }
  if (histsize == 0) file_position_at_histsize= file_size;
  if (histfilesize == 0) file_position_at_histfilesize= 0;
  if (histsize != 0) ++histsize; /* +1 because to go back 5 lines we skip 6 newlines */
  if (histfilesize != 0) ++histfilesize;
  for (;;)
  {
    int file_read_size;
    if (file_position > HISTORY_BUFFER_SIZE) file_read_size= HISTORY_BUFFER_SIZE;
    else file_read_size= file_position;
    file_position-= file_read_size;
    if (file_read_size == 0) break;
    memcpy(history_buffer + file_read_size, history_buffer, LINES_SIZE + 16);
    if (fseek(history_file, file_position, SEEK_SET) != 0) {fclose(history_file); goto returner; }
    int l= fread(history_buffer, 1, file_read_size, history_file);
    if (l != file_read_size) {fclose(history_file); goto returner; }
    for (int j= file_read_size - 1; j >= 0; --j)
    {
      if (*(history_buffer + j) == '\n')
      {
        ++line_counter;
        int statement_line_count= history_line(history_buffer + j + 1);
        if (statement_line_count > 0) line_counter-= statement_line_count; /* partial skip "lines: " */
        if ((line_counter == histsize) || (line_counter == histfilesize))
        {
          int file_position_at_lf= file_position + j;
          if (line_counter == histsize)
          {
            file_position_at_histsize= file_position_at_lf;
          }
          if (line_counter == histfilesize)
          {
            file_position_at_histfilesize= file_position_at_lf;
          }
          if ((file_position_at_histsize != -1) && (file_position_at_histfilesize != -1)) break;
        }
      }
    }
    if ((file_position_at_histsize != -1) && (file_position_at_histfilesize != -1)) break;
  }
  ++file_position_at_histsize; /* ?? what if there's nothing here? */
  if (fseek(history_file, file_position_at_histsize, SEEK_SET) != 0) {fclose(history_file); goto returner; }
  while (fgets(history_buffer, sizeof history_buffer, history_file) != NULL) /* put all non-"" in history  widget */
  {
    int statement_line_count= history_line(history_buffer);
    if (statement_line_count > 0)
    {
      query_utf16= "";
      for (int j= 0; j < statement_line_count; ++j)
      {
        if (fgets(history_buffer, sizeof history_buffer, history_file) == NULL) break;
        query_utf16.append(history_buffer);
      }
    }
    else query_utf16= history_buffer;
    query_utf16= query_utf16.trimmed();
    if (query_utf16 > "") history_markup_append("", false);
  }
  fclose(history_file);
  if ((file_position_at_histfilesize > 0) || (histfilesize == 0)) /* must we truncate the file? */
  {
    ocelot_history_hist_file.setFileName(ocelot_history_hist_file_name);
    if (ocelot_history_hist_file.open(QIODevice::ReadWrite | QIODevice::Text) == true)
    {
      int new_file_size;
      if (histfilesize == 0) new_file_size= 0;
      else
      {
        int o= file_position_at_histfilesize + 1;
        new_file_size= file_size - o;
        int n= 0;
        for (;;)
        {
          ocelot_history_hist_file.seek(o);
          int l= ocelot_history_hist_file.read(history_buffer, HISTORY_BUFFER_SIZE);
          if (l <= 0) break;
          o+= l;
          ocelot_history_hist_file.seek(n);
          int l2= ocelot_history_hist_file.write(history_buffer, l);
          n+= l2;
          if (l < HISTORY_BUFFER_SIZE) break;
        }
      }
      ocelot_history_hist_file.resize(new_file_size);
      ocelot_history_hist_file.close();
    }
  }
returner:
  ocelot_ca.history_hist_file_is_copied= true;
  query_utf16= er_strings[er_off + ER_START_OF_SESSION];
  return;
}

/* Pass: history line, which might be -- lines: n */
/* Return: n. 0 if it isn't -- lines: n. */
int MainWindow::history_line(char *l)
{
  if (strncmp(l, "-- lines: ", LINES_SIZE) == 0)
  {
    char tmp[64];
    int i= 0;
    char *c;
    for (c= l + LINES_SIZE; isdigit(*c); ++c) tmp[i++]= *c;
    tmp[i]= '\0';
    return atoi(tmp);
   }
  return 0;
}


/* General comments about shortcuts

  Shortcuts -- set variable value, or do setShortcut().
  Example:
    At the beginning of this program we have a declaration
    ocelot_ca.shortcut_exit= "default"; where .shortcut_exit size is 80
    The figure 80 is big enough for "Ctrl+Shift+Alt+F12\0" (19) 4 times
    but not for multiple keys.
    We can change it with a setting in a .cnf file e.g. .my.cnf:
    ocelot_shortcut_key = 'Alt+L'
    We can change it with a SET statement:
    SET ocelot_shortcut_exit = 'Ctrl+q';
    or
    SET ocelot_shortcut_exit = 'default';
    or
    SET ocelot_shortcut_exit = 'ALT+A,Alt+B';
  See also http://doc.qt.io/qt-4.8/qkeysequence.html#fromString
  I have tested
  SET ocelot_shortcut_exit = 'Alt+L';
  and it works (File|Exit menu shows Alt+L, and Alt+L causes quit).
  Thus this changes what's in create_menu(), above.
  Called from create_menu(),execute_client_statement(),connect_set_variable().
  Return 1 if it's ocelot_ca.shortcut_exit etc., even if it fails.
  You might want to "set" e.g. ocelot_shortcut_exit= value;
  You might want to "do" e.g. menu_file_action_file_exit->setShortcut(value); (todo: this is an obsolete statement)
  You might want to both "set" and "do".
  Todo: ensure two keys don't have the same action (error check).
        We already have an ambiguity for ^C = Copy and ^C = Kill,
        but we try to solve that by disabling Copy before executing.
  Todo: Ensure string is valid -- error checks and warnings|errors.
        I commented out the check for displayable ASCII or F1-F12
        because e.g. Ctrl+Tab is okay. But I don't know a way to
        check whether the window manager will grab a key sequence
        so we won't see it (e.g. Alt+Tab on X11).
  Todo: syntax checker should see this.
  Todo: all the other shortcut keys.
  Todo: also, something for "what to execute" e.g. SQL statement.
  Todo: return 0 if token1 first characters are not "ocelot_shortcut_"
  Todo: There is no GUI "shortcut editor" here, but such things exist:
        see doc.qt.io/qt-5/qkeysequenceedit.html#details.
        We could show a table with current settings, and let
        users pick or type in a key sequence.
  Warn: Although we can handle multiple-key shortcuts,
        the workaround for the Qt/Ubuntu bug in eventfilter_function
        only looks at one key.
  Warn: We don't say default = QKeySequence::Zoomin for zoomin, because
        it is Ctrl++ (Qt::CTRL + Qt::Key_Plus). But + requires shift.
        It seems more common to use without shift, which is Ctrl+=.
        http://doc.qt.io/archives/qt-4.8/qkeysequence.html section
        "Keyboard Layout Issues" mentions this but I didn't understand.
  Warn: There are some slightly-standardized keysequences, see them in
        Qt https://doc-snapshots.qt.io/qt5-5.9/qkeysequence.html#StandardKey-enum
        Eclipse http://help.eclipse.org/mars/index.jsp?topic=%2Forg.eclipse.platform.doc.user%2Freference%2Fref-keybindings.htm
        Visual Studio https://code.visualstudio.com/docs/getstarted/keybindings
        Wikipedia https://en.wikipedia.org/wiki/Table_of_keyboard_shortcuts
        In the past we failed to follow. In the future we should follow.

      QKeySequence k= QKeySequence(source_as_utf8);
      if ((k.count() < 1) || (k.count() > 4)) return -1;
      if (k.isEmpty()) return -1;
      if (k.toString() < " ") return -1;
//      for (unsigned int i= 0; i < (unsigned) k.count(); ++i)
//      {
//        int qi= k.operator[](i);
//        qi= (qi & ~(Qt::CTRL | Qt::SHIFT | Qt::ALT | Qt::META));
//        bool is_ok= false;
//        if ((qi >= Qt::Key_Space) && (qi <= Qt::Key_ydiaeresis)) is_ok= true;
//        if ((qi >= Qt::Key_F1) && (qi <= Qt::Key_F12)) is_ok= true;
//        if (is_ok == false) return -1;
//      }
*/


/*
  Shortcut duplication
  Example:
    In create_menu():
      connect(menu_file_action_file_exit, SIGNAL(triggered()), this, SLOT(action_file_exit()));
      menu_file_action_file_exit->setShortcut(QKeySequence::Quit);
    In eventFilter():
      if (key->matches(QKeySequence::Quit))
      {
        action_file_exit();
        return true;
      }
  With Ubuntu 12.04 the menu shortcut is executed.
  With Ubuntu 15.04 the event filter is executed.
  That is: the duplication in the event filter is a workaround for the fact that,
  on some distro versions, some menu shortcuts are missed. Maybe it's a Qt bug.
  Maybe it's an Ubuntu bug: https://bugs.launchpad.net/ubuntu/+source/texmaker/+bug/1386111
*/

/*
  Create the menu.
  Apparently the menubar already exists because of the call to UiSetup() earlier. Incomprehensible.
  Todo: Consider making a table with the menu settings. Something like this ...

  Initially menu_spec_make_menu() puts together a menu_spec_struct with .id = a fixed unique menu | menuitem name,
  menu_title = e.g. "File", menu_type = = a number with a different value for menu versus menuitem versus separator
  versus submenu etc., menu_item = e.g. "Connect", shortcut_default = e.g. QKeySequence::Open, keyword =
  TOKEN_KEYWORD_OCELOT_SHORTCUT_CONNECT.
  Later something will fill in:
  .shortcut based on shortcut_default, .qmenu = QMenu* due to addMenu(), qaction = QAction* due to addAction().
  Todo: caption/hint?
  Todo: toolbar? (we could add action to toolbox)
  Todo: icon?
  Todo: setStatusTip()?
    Also set up more with setShortcuts(), setStatusTip(), ...
    Also add action to toolbox
     This would addMenu() multiple times for the same menu, so I use a different name each time.
    I should show what the shortcuts are; unfortunately for most actions the shortcut differs according to platform

    Sure, I tried using & for various menu items e.g. E&xit -- but then Alt+x did not work!
  create_menu() makes a skeleton, fill_menu() comes when we know options from command-line and my.cnf
  Todo: we used to have exitAction->setPriority(QAction::LowPriority); maybe it wasn't such a bad idea
  Todo: We used to have a QActionGroup for exports, but disabled it when enabling menu_spec.
        The choices in the export-related exclusive QActionGroup should have radio buttons not check marks.
        Maybe figure out what went wrong, since illustrations suggested this would be automatic.
        Maybe try adding to ocelot_menu_style_string: QMenu::indicator:exclusive:checked{image: ...}.
        Maybe make your own icons and set them when checked.
  Todo: Are we using (this) whenever we can?
*/
void MainWindow::create_menu()
{
  menu_spec_make_function();
  menu_spec_make_menu();

#if (OCELOT_IMPORT_EXPORT == 1)
  QMenu *menu_file_export= menu_spec_find_menu("menu_export");
  if (menu_file_export != NULL) menu_file_export->setEnabled(false);
#endif


}

/*
  Set shortcuts to defaults (we said earlier what shortcut_default is).
  set checkeds to defaults (we said earlier that they're checkable)..
  Todo: checkeds used to be done for exports, now that's missing.
*/
void MainWindow::fill_menu_2()
{
  for (int i=0; i < menu_spec_struct_list.size(); ++i) /* Set shortcuts for all menu items that have defaults */
  {
    if (menu_spec_struct_list[i].shortcut_default != "") shortcut_set(i, "default");
  }
  for (int i= 0; i < menu_spec_struct_list.size(); ++i)
  {
    QString id= menu_spec_struct_list.at(i).id;
    QAction *qaction= menu_spec_struct_list.at(i).qaction;
    if (qaction == NULL) continue; /* unlikely */
    if (id == "action_run_kill") qaction->setEnabled(false);
    if (id == "action_options_detach_history_widget") qaction->setChecked(ocelot_ca.detach_history_widget);
    if (id == "action_options_detach_grid_widget") qaction->setChecked(ocelot_ca.detach_result_grid_widget);
#if (OCELOT_MYSQL_DEBUGGER == 1)
    if (id == "action_options_detach_debug_widget") qaction->setChecked(ocelot_ca.detach_debug_widget);
#endif
    if (id == "action_options_detach_statement_widget") qaction->setChecked(ocelot_ca.detach_statement_edit_widget);
#if (OCELOT_EXPLORER == 1)
    if (id == "action_options_detach_explorer_widget") qaction->setChecked(ocelot_ca.detach_explorer_widget);
#endif
  }
#if (OCELOT_MYSQL_DEBUGGER == 1)
  debug_menu_enable_or_disable(TOKEN_KEYWORD_BEGIN); /* Disable most of debug menu */
#endif
}

/*
  The menu_spec_* structures and functions
  Convention: guaranteed ocelotgui won't produce strings containing , or ; or " (maybe it makes parsing easier)
  Convention: guaranteed ocelotgui will have .id = MainWindow:: method name, if QAction
  QList<struct menu_spec_struct> menu_spec_struct_list;
  Construct menu_spec_struct_list for first time
  todo: some way of putting submenu items in QActionGroup as before
  The setup comes after the switch to French if ocelotgui --ocelot_language='french'
  Warning: titles that start & can surprise, e.g. "&Options" would means that Alt+O takes the menu
  Todo: maybe separators should have qmenu != NULL
  Re .shortcut_default
    Some defaults come from Qt's enum QKeySequence::StandardKey, e.g. QKeySequence::Open, which toString() will probably
    translate to "Ctrl+O" because that's the default in typical environments and because toString()'s default
    is native rather than portable. Also QKeySequence::Undo QKeySequence::Redo QKeySequence::Cut QKeySequence::Copy
    QKeySequence::Paste QKeySequence::SelectAll QKeySequence::Zoomout QKeySequence::Cancel QKeySequence::NextChild
    QKeySequence::PreviousChild.
    With Puppy Linux --non-KDE non-Gnome -- QKeySequence::Quit fails so there's hardcoding: "Ctrl+Q".
    Todo: Consider using QKeySequence::Find for "Find".
    Todo: Consider using something other than "Tab" for autocomplete, it's only there to be like mysql. Ctrl+Space?
    Todo: Consider using "Run Ctrl+R" rather than "Execute ctrl+E"
    Todo: Consider using "Cancel Esc" rather than "Kill Ctrl+C" which is imitating mysql client
          because there seemed to be occasional problems although "Copy" should be disabled whenever "Kill" is enabled.
  Warning: be careful about changing id for menu, there may be routines that specifically look for that id.
*/

void MainWindow::menu_spec_make_function()
{
  menu_function_struct_list.append({"action_file_connect", false, &MainWindow::action_file_connect, NULL});
  menu_function_struct_list.append({"action_file_connect", false, &MainWindow::action_file_connect, NULL});
  menu_function_struct_list.append({"action_file_exit", false, &MainWindow::action_file_exit, NULL});
#if (OCELOT_IMPORT_EXPORT == 1)
  menu_function_struct_list.append({"action_file_export_text", false, &MainWindow::action_file_export_text, NULL});
  menu_function_struct_list.append({"action_file_export_table", false, &MainWindow::action_file_export_table, NULL});
  menu_function_struct_list.append({"action_file_export_html", false, &MainWindow::action_file_export_html, NULL});
  menu_function_struct_list.append({"action_file_export_none", false, &MainWindow::action_file_export_none, NULL});
#endif
  menu_function_struct_list.append({"action_edit_undo", false, &MainWindow::action_edit_undo, NULL});
  menu_function_struct_list.append({"action_edit_redo", false, &MainWindow::action_edit_redo, NULL});
  menu_function_struct_list.append({"action_edit_cut", false, &MainWindow::action_edit_cut, NULL});
  menu_function_struct_list.append({"action_edit_copy", false, &MainWindow::action_edit_copy, NULL});
  menu_function_struct_list.append({"action_edit_paste", false, &MainWindow::action_edit_paste, NULL});
  menu_function_struct_list.append({"action_edit_select_all", false, &MainWindow::action_edit_select_all, NULL});
  menu_function_struct_list.append({"action_edit_previous_statement", false, &MainWindow::action_edit_previous_statement, NULL});
  menu_function_struct_list.append({"action_edit_next_statement", false, &MainWindow::action_edit_next_statement, NULL});
  menu_function_struct_list.append({"action_edit_format", false, &MainWindow::action_edit_format, NULL});
  menu_function_struct_list.append({"action_edit_zoomin", false, &MainWindow::action_edit_zoomin, NULL});
  menu_function_struct_list.append({"action_edit_zoomout", false, &MainWindow::action_edit_zoomout, NULL});
  menu_function_struct_list.append({"action_edit_autocomplete", false, &MainWindow::action_edit_autocomplete, NULL});
#if (OCELOT_FIND_WIDGET == 1)
  menu_function_struct_list.append({"action_edit_find", false, &MainWindow::action_edit_find, NULL});
#endif
  menu_function_struct_list.append({"action_run_execute", false, &MainWindow::action_run_execute, NULL});
  menu_function_struct_list.append({"action_run_kill", false, &MainWindow::action_run_kill, NULL});
  menu_function_struct_list.append({"action_settings_menu", false, &MainWindow::action_settings_menu, NULL});
  menu_function_struct_list.append({"action_settings_history", false, &MainWindow::action_settings_history, NULL});
  menu_function_struct_list.append({"action_settings_grid", false, &MainWindow::action_settings_grid, NULL});
  menu_function_struct_list.append({"action_settings_statement", false, &MainWindow::action_settings_statement, NULL});
  menu_function_struct_list.append({"action_settings_debug", false, &MainWindow::action_settings_debug, NULL});
  menu_function_struct_list.append({"action_settings_extra_rule_1", false, &MainWindow::action_settings_extra_rule_1, NULL});
  menu_function_struct_list.append({"action_settings_explorer", false, &MainWindow::action_settings_explorer, NULL});
  menu_function_struct_list.append({"action_options_detach_history_widget", false, &MainWindow::action_options_detach_history_widget, NULL});
  menu_function_struct_list.append({"action_options_detach_grid_widget", false, &MainWindow::action_options_detach_grid_widget, NULL});
#if (OCELOT_CHART_OR_QCHART == 1)
  menu_function_struct_list.append({"action_options_detach_debug_widget", false, &MainWindow::action_options_detach_debug_widget, NULL});
#endif
  menu_function_struct_list.append({"action_options_detach_statement_widget", false, &MainWindow::action_options_detach_statement_widget, NULL});
#if (OCELOT_EXPLORER == 1)
  menu_function_struct_list.append({ "action_options_detach_explorer_widget", false, &MainWindow::action_options_detach_statement_widget, NULL});
#endif
  menu_function_struct_list.append({"action_options_next_window", false, &MainWindow::action_options_next_window, NULL});
  menu_function_struct_list.append({"action_options_previous_window", false, &MainWindow::action_options_previous_window, NULL});
#if (OCELOT_CHART_OR_QCHART == 1)
  menu_function_struct_list.append({"action_options_bar", false, &MainWindow::action_options_bar, NULL});
#endif
  menu_function_struct_list.append({"action_options_batch", false, &MainWindow::action_options_batch, NULL});
  menu_function_struct_list.append({"action_options_horizontal", false, &MainWindow::action_options_horizontal, NULL});
  menu_function_struct_list.append({"action_options_html", false, &MainWindow::action_options_html, NULL});
  menu_function_struct_list.append({"action_options_htmlraw", false, &MainWindow::action_options_htmlraw, NULL});
#if (OCELOT_CHART_OR_QCHART == 1)
   menu_function_struct_list.append({"action_options_line", false, &MainWindow::action_options_line, NULL});
   menu_function_struct_list.append({"action_options_none", false, &MainWindow::action_options_none, NULL});
   menu_function_struct_list.append({"action_options_pie", false, &MainWindow::action_options_pie, NULL});
#endif
   menu_function_struct_list.append({"action_options_raw", false, &MainWindow::action_options_raw, NULL});
   menu_function_struct_list.append({"action_options_vertical", false, &MainWindow::action_options_vertical, NULL});
   menu_function_struct_list.append({"action_options_xml", false, &MainWindow::action_options_xml, NULL});
#if (OCELOT_MYSQL_DEBUGGER == 1)
   menu_function_struct_list.append({"action_debug_breakpoint", false, &MainWindow::action_debug_breakpoint, NULL});
   menu_function_struct_list.append({"action_debug_continue", false, &MainWindow::action_debug_continue, NULL});
   menu_function_struct_list.append({"action_debug_next", false, &MainWindow::action_debug_next, NULL});
   menu_function_struct_list.append({"action_debug_step", false, &MainWindow::action_debug_step, NULL});
   menu_function_struct_list.append({"action_debug_clear", false, &MainWindow::action_debug_step, NULL});
   menu_function_struct_list.append({"action_debug_exit", false, &MainWindow::action_debug_exit, NULL});
   menu_function_struct_list.append({"action_debug_information", false, &MainWindow::action_debug_information, NULL});
   menu_function_struct_list.append({"action_debug_refresh_server_variables", false, &MainWindow::action_debug_refresh_server_variables, NULL});
   menu_function_struct_list.append({"action_debug_refresh_user_variables", false, &MainWindow::action_debug_refresh_user_variables, NULL});
   menu_function_struct_list.append({"action_debug_refresh_variables", false, &MainWindow::action_debug_refresh_variables, NULL});
   menu_function_struct_list.append({"action_debug_refresh_call_stack", false, &MainWindow::action_debug_refresh_call_stack, NULL});
#endif
   menu_function_struct_list.append({"action_help_about", false, &MainWindow::action_help_about, NULL});
   menu_function_struct_list.append({"action_help_the_manual", false, &MainWindow::action_help_the_manual, NULL});
#if (OCELOT_MYSQL_INCLUDE == 1)
   menu_function_struct_list.append({"action_help_libmysqlclient", false, &MainWindow::action_help_libmysqlclient, NULL});
#endif
   menu_function_struct_list.append({"action_help_settings", false, &MainWindow::action_help_settings, NULL});
}

/*
  Make action -- that's done by new QAction().
  Connect action to menu -- that's done by addMenu()
  Connect action to function -- done by having the action and the function pointer in the same menu_spec_struct_list row.
  Todo: QGroupAction for the submenus, used to be there.
*/

/*
  Called due to SET ocelot_query = INSERT INTO MENUS VALUES (id, menu_title, menu_item, action);
  In menu_spec_make_menu() we have append()s for all the initial items, this can happen later for a single item.
  We pass id = id of action, and will make id of menu = menu_title + menuitem (todo: should be unique).
  action: for a menuitem or submenuitem this is the name of the function that's called when user clicks
          or [menu] or [submenu] or [separator] -- or it's an SQL statement ending with ;
  todo: check if there's a problem when names begin with &E etc. and whether that makes two shortcuts
*/
int MainWindow::menu_spec_insert_one(QString id, QString menu_title, QString menu_item, QString action)
{
  QString id_of_menu= "";
  int i_of_new_item= menu_spec_struct_list.size();
  QMenu *qmenu= NULL;

  /* If menu_title <> "", find it */
  int i_of_upper_menu= -1;
  int i_of_upper_submenu= -1;
  for (int i= 0; i < menu_spec_struct_list.size(); ++i)
  {
    if ((menu_spec_struct_list[i].menu_type == MENU_SPEC_TYPE_MENU) && (menu_title == menu_spec_struct_list[i].menu_title))
      i_of_upper_menu= i;
    if ((menu_spec_struct_list[i].menu_type == MENU_SPEC_TYPE_SUBMENU) && (menu_title == menu_spec_struct_list[i].menu_item))
      i_of_upper_submenu= i;
  }
  if (action == "[menu]")
  {
    /* todo: if menu_title already exists, skip */
    /* assume menu_title is okay e.g. not blank */
    /* menu_item is meaningless maybe it should be blanked? */
    if (i_of_upper_menu != -1) return ER_OK; /* there's already a menu with the same menu_title so skip it */
    menu_spec_struct_list.append(
         {id, MENU_SPEC_TYPE_MENU, menu_title, menu_item, "", "", id, NULL, NULL,
          action, "", -1, ""}   );
    qmenu= menu_spec_add_menu(i_of_new_item);
    return ER_OK;
  }
  /* If there is no currently-existing menu or submenu with this menu_title, we'll make a new menu */
  if ((i_of_upper_menu == -1) && (i_of_upper_submenu == -1))
  {
    id_of_menu= menu_title + "_" + menu_item; /* todo: this might not be unique enough, check for a duplicate */
    menu_spec_struct_list.append(
       {id_of_menu, 0, menu_title, "", "", "", id_of_menu, NULL, NULL,
        "", "", -1, ""}   );
    qmenu= menu_spec_add_menu(i_of_new_item);
    ++i_of_new_item;
  }
  else
  {
    if (i_of_upper_menu != -1)
    {
      qmenu= menu_spec_struct_list[i_of_upper_menu].qmenu;
      id_of_menu= menu_spec_struct_list[i_of_upper_menu].id;
    }
    else
    {
      qmenu= menu_spec_struct_list[i_of_upper_submenu].qmenu;
      id_of_menu= menu_spec_struct_list[i_of_upper_submenu].id;
    }
  }
  if (action == "[separator]")
  {
    if (qmenu == NULL) printf("qmenu == NULL\n"); /* this should not happen */
    else
    {
      menu_spec_struct_list.append(
     {id, MENU_SPEC_TYPE_SEPARATOR, menu_title, menu_item, "", "", id_of_menu, NULL, NULL,
      action, "", -1, ""}   );
      qmenu->addSeparator();
    }
  }
  else if (action == "[submenu]")
  {
    /* todo: menu must exist */
    if (i_of_upper_submenu != -1) return ER_OK; /* there's already a submenu with the same menu_title so skip it */
    QMenu *qmenu_of_this= qmenu->addMenu(menu_item);
    menu_spec_struct_list.append(
       {id, MENU_SPEC_TYPE_SUBMENU, menu_title, menu_item, "", "", id_of_menu, qmenu_of_this, NULL,
        action, "", -1, ""}   );
    /* Flaw: we do not store the menu that the submenu belongs to, I guess we depend on id_of_menu */
  }
  else /* menuitem or submenuitem */
  {
    if (qmenu == NULL) printf("qmenu == NULL\n"); /* this should not happen */
    else
    {
      menu_spec_struct_list.append(
       {id, MENU_SPEC_TYPE_MENUITEM, menu_title, menu_item, "", "", id_of_menu, NULL, NULL,
        action, "", -1, ""}   );
      menu_spec_add_action(i_of_new_item, qmenu);
    }
  }
  return ER_OK;
}


/* This is not needed just after menu_spec_make_menu() because for the initial setup the addresses are pre-set. */
/* todo: needs work before it works */
//void MainWindow::menu_spec_set_addresses()
//{
//  for (int i= 0; i < menu_spec_struct_list.size();++i)
//  {
//    if ((menu_spec_struct_list[i].menu_type == MENU_SPEC_TYPE_MENU)
//     || (menu_spec_struct_list[i].menu_type == MENU_SPEC_TYPE_MENUITEM))
//    {
//      QMenu *qmenu_pointer= menu_spec_find_menu(menu_spec_struct_list[i].menu_name);
//      if (qmenu_pointer != NULL) menu_spec_struct_list[i].qmenu= qmenu_pointer;
//    }
//    if (menu_spec_struct_list[i].menu_type == MENU_SPEC_TYPE_MENUITEM)
//    {
//      QAction *qaction_pointer= menu_spec_find_action(menu_spec_struct_list[i].id);
//      if (qaction_pointer != NULL) menu_spec_struct_list[i].qaction= qaction_pointer;
//    }
//  }
//}

/*
  Construct menu. This happens before connect or setup of most widgets.
  Re qmenu: We look for "does it already exist in menu_spec_struct_list earlier". (It must, unless it is itself a menu.)
            If it does, we copy .qmenu from the earlier qmenu.
            This is why, although order is important, it's possible to add to File menu, then Edit menu, then File menu again.
  Todo: Failure to match is an error, but you need to clear i.e. remove anything you've
        done already, and then return an error message. Also maybe addMenu() or addAction() can fail.
  It's a big single string which a C plugin can replace (see example in plugin.c).
  Re the separator before 'libmysqlclient':  Qt says I should also do "addSeparator" if Motif style. Harmless.
  Todo: find out why if I use QString appends "ocelot_plugin_pass.query= query.toUtf8().Data()" has nul bytes at the start.
*/
void MainWindow::menu_spec_make_menu()
{
  char insert[]="INSERT INTO menus VALUES (";
  char b[65536];
  unsigned int blen= 0;
  blen+= sprintf(b + blen, "%s'menu_file','%s','','[menu]');",
               insert, menu_strings[menu_off + MENU_FILE]);
  blen+= sprintf(b + blen, "%s'action_file_connect', '%s', '%s', 'action_file_connect');",
               insert, menu_strings[menu_off + MENU_FILE], menu_strings[menu_off + MENU_FILE_CONNECT]);
  blen+= sprintf(b + blen, "%s'action_file_exit', '%s', '%s', 'action_file_exit');",
               insert, menu_strings[menu_off + MENU_FILE], menu_strings[menu_off + MENU_FILE_EXIT]);
#if (OCELOT_IMPORT_EXPORT == 1)
  blen+= sprintf(b + blen, "%s'separator_1', '%s', '%s', '[separator]');",
               insert, menu_strings[menu_off + MENU_FILE], "");
  blen+= sprintf(b + blen, "%s'menu_export', '%s', '%s', '[submenu]');",
               insert, menu_strings[menu_off + MENU_FILE], "Export");
  blen+= sprintf(b + blen, "%s'action_file_export_text', '%s', '%s', 'action_file_export_text');",
               insert, "Export", "text");
  blen+= sprintf(b + blen, "%s'action_file_export_table', '%s', '%s', 'action_file_export_table');",
               insert, "Export", "table");
  blen+= sprintf(b + blen, "%s'action_file_export_html', '%s', '%s', 'action_file_export_html');",
               insert, "Export", "html");
  blen+= sprintf(b + blen, "%s'action_file_export_none', '%s', '%s', 'action_file_export_none');",
               insert, "Export", "none");
#endif
  blen+= sprintf(b + blen, "%s'menu_edit','%s','','[menu]');",
               insert, menu_strings[menu_off + MENU_EDIT]);
  blen+= sprintf(b + blen, "%s'action_edit_undo', '%s', '%s', 'action_edit_undo');",
               insert, menu_strings[menu_off + MENU_EDIT], menu_strings[menu_off + MENU_EDIT_UNDO]);
  blen+= sprintf(b + blen, "%s'action_edit_redo', '%s', '%s', 'action_edit_redo');",
               insert, menu_strings[menu_off + MENU_EDIT], menu_strings[menu_off + MENU_EDIT_REDO]);
  blen+= sprintf(b + blen, "%s'separator_2', '%s', '%s', '[separator]');",
               insert, menu_strings[menu_off + MENU_EDIT], "");
  blen+= sprintf(b + blen, "%s'action_edit_cut', '%s', '%s', 'action_edit_cut');",
               insert, menu_strings[menu_off + MENU_EDIT], menu_strings[menu_off + MENU_EDIT_CUT]);
  blen+= sprintf(b + blen, "%s'action_edit_copy', '%s', '%s', 'action_edit_copy');",
               insert, menu_strings[menu_off + MENU_EDIT], menu_strings[menu_off + MENU_EDIT_COPY]);
  blen+= sprintf(b + blen, "%s'action_edit_paste', '%s', '%s', 'action_edit_paste');",
               insert, menu_strings[menu_off + MENU_EDIT], menu_strings[menu_off + MENU_EDIT_PASTE]);
  blen+= sprintf(b + blen, "%s'separator_3', '%s', '%s', '[separator]');",
               insert, menu_strings[menu_off + MENU_EDIT], "");
  blen+= sprintf(b + blen, "%s'action_edit_select_all', '%s', '%s', 'action_edit_select_all');",
               insert, menu_strings[menu_off + MENU_EDIT], menu_strings[menu_off + MENU_EDIT_SELECT_ALL]);
  blen+= sprintf(b + blen, "%s'action_edit_previous_statement', '%s', '%s', 'action_edit_previous_statement');",
               insert, menu_strings[menu_off + MENU_EDIT], menu_strings[menu_off + MENU_EDIT_PREVIOUS_STATEMENT]);
  blen+= sprintf(b + blen, "%s'action_edit_next_statement', '%s', '%s', 'action_edit_next_statement');",
               insert, menu_strings[menu_off + MENU_EDIT], menu_strings[menu_off + MENU_EDIT_NEXT_STATEMENT]);
  blen+= sprintf(b + blen, "%s'action_edit_format', '%s', '%s', 'action_edit_formatl');",
               insert, menu_strings[menu_off + MENU_EDIT], menu_strings[menu_off + MENU_EDIT_FORMAT]);
  blen+= sprintf(b + blen, "%s'action_edit_zoomin', '%s', '%s', 'action_edit_zoomin');",
               insert, menu_strings[menu_off + MENU_EDIT], menu_strings[menu_off + MENU_EDIT_ZOOMIN]);
  blen+= sprintf(b + blen, "%s'action_edit_zoomout', '%s', '%s', 'action_edit_zoomout');",
               insert, menu_strings[menu_off + MENU_EDIT], menu_strings[menu_off + MENU_EDIT_ZOOMOUT]);
  blen+= sprintf(b + blen, "%s'action_edit_autocomplete', '%s', '%s', 'action_edit_autocomplete');",
               insert, menu_strings[menu_off + MENU_EDIT], menu_strings[menu_off + MENU_EDIT_AUTOCOMPLETE]);
#if (OCELOT_FIND_WIDGET == 1)
  blen+= sprintf(b + blen, "%s'action_edit_find', '%s', '%s', 'action_edit_find');",
               insert, menu_strings[menu_off + MENU_EDIT], menu_strings[menu_off + MENU_EDIT_FIND]);
#endif
  blen+= sprintf(b + blen, "%s'menu_run','%s','','[menu]');",
               insert, menu_strings[menu_off + MENU_RUN]);
  blen+= sprintf(b + blen, "%s'action_run_execute', '%s', '%s', 'action_run_execute');",
               insert, menu_strings[menu_off + MENU_RUN], menu_strings[menu_off + MENU_RUN_EXECUTE]);
  blen+= sprintf(b + blen, "%s'action_run_kill', '%s', '%s', 'action_run_kill');",
               insert, menu_strings[menu_off + MENU_RUN], menu_strings[menu_off + MENU_RUN_KILL]);
  blen+= sprintf(b + blen, "%s'menu_settings','%s','','[menu]');",
               insert, menu_strings[menu_off + MENU_SETTINGS]);
  blen+= sprintf(b + blen, "%s'action_settings_menu', '%s', '%s', 'action_settings_menu');",
               insert, menu_strings[menu_off + MENU_SETTINGS], menu_strings[menu_off + MENU_SETTINGS_MENU]);
  blen+= sprintf(b + blen, "%s'action_settings_history', '%s', '%s', 'action_settings_history');",
               insert, menu_strings[menu_off + MENU_SETTINGS], menu_strings[menu_off + MENU_SETTINGS_HISTORY_WIDGET]);
  blen+= sprintf(b + blen, "%s'action_settings_grid', '%s', '%s', 'action_settings_grid');",
               insert, menu_strings[menu_off + MENU_SETTINGS], menu_strings[menu_off + MENU_SETTINGS_GRID_WIDGET]);
  blen+= sprintf(b + blen, "%s'action_settings_statement', '%s', '%s', 'action_settings_statement');",
               insert, menu_strings[menu_off + MENU_SETTINGS], menu_strings[menu_off + MENU_SETTINGS_STATEMENT_WIDGET]);
 #if (OCELOT_MYSQL_DEBUGGER == 1)
  blen+= sprintf(b + blen, "%s'action_settings_debug', '%s', '%s', 'action_settings_debug');",
               insert, menu_strings[menu_off + MENU_SETTINGS], menu_strings[menu_off + MENU_SETTINGS_DEBUG_WIDGET]);
#endif
  blen+= sprintf(b + blen, "%s'action_settings_extra_rule_1', '%s', '%s', 'action_settings_extra_rule_1');",
               insert, menu_strings[menu_off + MENU_SETTINGS], menu_strings[menu_off + MENU_SETTINGS_EXTRA_RULE_1]);
 #if (OCELOT_EXPLORER == 1)
  blen+= sprintf(b + blen, "%s'action_settings_explorer', '%s', '%s', 'action_settings_explorer');",
               insert, menu_strings[menu_off + MENU_SETTINGS], menu_strings[menu_off + MENU_SETTINGS_EXPLORER_WIDGET]);
#endif
  blen+= sprintf(b + blen, "%s'menu_options','%s','','[menu]');",
               insert, menu_strings[menu_off + MENU_OPTIONS]);
  blen+= sprintf(b + blen, "%s'action_options_detach_history_widget', '%s', '%s', 'action_options_detach_history_widget');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_DETACH_HISTORY_WIDGET]);
  blen+= sprintf(b + blen, "%s'action_options_detach_grid_widget', '%s', '%s', 'action_options_detach_grid_widget');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_DETACH_RESULT_GRID_WIDGET]);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  blen+= sprintf(b + blen, "%s'action_options_detach_debug_widget', '%s', '%s', 'action_options_detach_debug_widget');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_DETACH_DEBUG_WIDGET]);
#endif
  blen+= sprintf(b + blen, "%s'action_options_detach_statement_widget', '%s', '%s', 'action_options_detach_statement_widget');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_DETACH_STATEMENT_WIDGET]);
#if (OCELOT_EXPLORER == 1)
  blen+= sprintf(b + blen, "%s'action_options_detach_explorer_widget', '%s', '%s', 'action_options_detach_explorer_widget');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_DETACH_EXPLORER_WIDGET]);
#endif
  blen+= sprintf(b + blen, "%s'action_options_next_window', '%s', '%s', 'action_options_next_window');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_NEXT_WINDOW]);
  blen+= sprintf(b + blen, "%s'action_options_previous_window', '%s', '%s', 'action_options_previous_window');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_PREVIOUS_WINDOW]);
#if (OCELOT_CHART_OR_QCHART == 1)
  blen+= sprintf(b + blen, "%s'action_options_bar', '%s', '%s', 'action_options_bar');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_BAR]);
#endif
  blen+= sprintf(b + blen, "%s'action_options_batch', '%s', '%s', 'action_options_batch');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_BATCH]);
  blen+= sprintf(b + blen, "%s'action_options_horizontal', '%s', '%s', 'action_options_horizontal');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_HORIZONTAL]);
  blen+= sprintf(b + blen, "%s'action_options_html', '%s', '%s', 'action_options_html');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_HTML]);
  blen+= sprintf(b + blen, "%s'action_options_htmlraw', '%s', '%s', 'action_options_htmlraw');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_HTMLRAW]);
#if (OCELOT_CHART_OR_QCHART == 1)
  blen+= sprintf(b + blen, "%s'action_options_line', '%s', '%s', 'action_options_line');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_LINE]);
  blen+= sprintf(b + blen, "%s'action_options_none', '%s', '%s', 'action_options_none');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_NONE]);
  blen+= sprintf(b + blen, "%s'action_options_pie', '%s', '%s', 'action_options_pie');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_PIE]);
#endif
  blen+= sprintf(b + blen, "%s'action_options_raw', '%s', '%s', 'action_options_raw');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_RAW]);
  blen+= sprintf(b + blen, "%s'action_options_vertical', '%s', '%s', 'action_options_vertical');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_VERTICAL]);
  blen+= sprintf(b + blen, "%s'action_options_xml', '%s', '%s', 'action_options_xml');",
               insert, menu_strings[menu_off + MENU_OPTIONS], menu_strings[menu_off + MENU_OPTIONS_RESULT_DISPLAY_XML]);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  blen+= sprintf(b + blen, "%s'menu_debug','%s','','[menu]');",
               insert, menu_strings[menu_off + MENU_DEBUG]);
  blen+= sprintf(b + blen, "%s'action_debug_breakpoint', '%s', '%s', 'action_debug_breakpoint');",
               insert, menu_strings[menu_off + MENU_DEBUG], menu_strings[menu_off + MENU_DEBUG_BREAKPOINT]);
  blen+= sprintf(b + blen, "%s'action_debug_continue', '%s', '%s', 'action_debug_continue');",
               insert, menu_strings[menu_off + MENU_DEBUG], menu_strings[menu_off + MENU_DEBUG_CONTINUE]);
  blen+= sprintf(b + blen, "%s'action_debug_next', '%s', '%s', 'action_debug_next');",
                insert, menu_strings[menu_off + MENU_DEBUG], menu_strings[menu_off + MENU_DEBUG_NEXT]);
  blen+= sprintf(b + blen, "%s'action_debug_step', '%s', '%s', 'action_debug_step');",
               insert, menu_strings[menu_off + MENU_DEBUG], menu_strings[menu_off + MENU_DEBUG_STEP]);
  blen+= sprintf(b + blen, "%s'action_debug_clear', '%s', '%s', 'action_debug_clear');",
               insert, menu_strings[menu_off + MENU_DEBUG], menu_strings[menu_off + MENU_DEBUG_CLEAR]);
  blen+= sprintf(b + blen, "%s'action_debug_exit', '%s', '%s', 'action_debug_exit');",
               insert, menu_strings[menu_off + MENU_DEBUG], menu_strings[menu_off + MENU_DEBUG_EXIT]);
  blen+= sprintf(b + blen, "%s'action_debug_information', '%s', '%s', 'action_debug_information');",
               insert, menu_strings[menu_off + MENU_DEBUG], menu_strings[menu_off + MENU_DEBUG_INFORMATION]);
  blen+= sprintf(b + blen, "%s'action_debug_refresh_server_variables', '%s', '%s', 'action_debug_refresh_server_variables');",
               insert, menu_strings[menu_off + MENU_DEBUG], menu_strings[menu_off + MENU_DEBUG_REFRESH_SERVER_VARIABLES]);
  blen+= sprintf(b + blen, "%s'action_debug_refresh_user_variables', '%s', '%s', 'action_debug_refresh_user_variables');",
               insert, menu_strings[menu_off + MENU_DEBUG], menu_strings[menu_off + MENU_DEBUG_REFRESH_USER_VARIABLES]);
  blen+= sprintf(b + blen, "%s'action_debug_refresh_variables', '%s', '%s', 'action_debug_refresh_variables');",
               insert, menu_strings[menu_off + MENU_DEBUG], menu_strings[menu_off + MENU_DEBUG_REFRESH_VARIABLES]);
  blen+= sprintf(b + blen, "%s'action_debug_refresh_call_stack', '%s', '%s', 'action_debug_refresh_call_stack');",
                insert, menu_strings[menu_off + MENU_DEBUG], menu_strings[menu_off + MENU_DEBUG_REFRESH_CALL_STACK]);
#endif
  blen+= sprintf(b + blen, "%s'menu_help','%s','','[menu]');",
               insert, menu_strings[menu_off + MENU_HELP]);
  blen+= sprintf(b + blen, "%s'action_help_about', '%s', '%s', 'action_help_about');",
               insert, menu_strings[menu_off + MENU_HELP], menu_strings[menu_off + MENU_HELP_ABOUT]);
  blen+= sprintf(b + blen, "%s'action_help_the_manual', '%s', '%s', 'action_help_the_manual');",
               insert, menu_strings[menu_off + MENU_HELP], menu_strings[menu_off + MENU_HELP_THE_MANUAL]);
  blen+= sprintf(b + blen, "%s'separator_4', '%s', '%s', '[separator]');",
               insert, menu_strings[menu_off + MENU_HELP], "");
#if (OCELOT_MYSQL_INCLUDE == 1)
  blen+= sprintf(b + blen, "%s'action_help_libmysqlclient', '%s', '%s', 'action_help_libmysqlclient');",
               insert, menu_strings[menu_off + MENU_HELP], menu_strings[menu_off + MENU_HELP_LIBMYSQLCLIENT]);
#endif
  blen+= sprintf(b + blen, "%s'action_help_settings', '%s', '%s', 'action_help_settings');",
               insert, menu_strings[menu_off + MENU_HELP], menu_strings[menu_off + MENU_HELP_SETTINGS]);
/*
  Here is a slightly older version of b[], copied here to make the effect of the above sprintfs a bit more readable.
  If ostrings.h didn't have an undocumented ption for --ocelot_languages, this would be all we'd need.
  char b[]=
  "INSERT INTO menus VALUES ('menu_file', 'File', '', '[menu]');"
  "INSERT INTO menus VALUES ('action_file_connect', 'File', 'Connect', 'action_file_connect');"
  "INSERT INTO menus VALUES ('action_file_exit', 'File', 'Exit', 'action_file_exit');"
#if (OCELOT_IMPORT_EXPORT == 1)
  "INSERT INTO menus VALUES ('separator_1', 'File', '', '[separator]');"
  "INSERT INTO menus VALUES ('menu_export', 'File', 'Export', '[submenu]');"
  "INSERT INTO menus VALUES ('action_file_export_text', 'Export', 'text', 'action_file_export_text');"
  "INSERT INTO menus VALUES ('action_file_export_table', 'Export', 'table', 'action_file_export_table');"
  "INSERT INTO menus VALUES ('action_file_export_html', 'Export', 'html', 'action_file_export_html');"
  "INSERT INTO menus VALUES ('action_file_export_none', 'Export', 'none', 'action_file_export_none');"
#endif
  "INSERT INTO menus VALUES ('menu_edit', 'Edit', '', '[menu]');"
  "INSERT INTO menus VALUES ('action_edit_undo', 'Edit', 'Undo', 'action_edit_undo');"
  "INSERT INTO menus VALUES ('action_edit_redo', 'Edit', 'Redo', 'action_edit_redo');"
  "INSERT INTO menus VALUES ('Separator_2', 'Edit', '', '[separator]');"
  "INSERT INTO menus VALUES ('action_edit_cut', 'Edit', 'Cut', 'action_edit_cut');"
  "INSERT INTO menus VALUES ('action_edit_copy', 'Edit', 'Copy', 'action_edit_copy');"
  "INSERT INTO menus VALUES ('action_edit_paste', 'Edit', 'Paste', 'action_edit_paste');"
  "INSERT INTO menus VALUES ('Separator_3', 'Edit', '', '[separator]');"
  "INSERT INTO menus VALUES ('action_edit_select_all', 'Edit', 'Select all', 'action_edit_select_all');"
  "INSERT INTO menus VALUES ('action_edit_previous_statement', 'Edit', 'Previous statement', 'action_edit_previous_statement');"
  "INSERT INTO menus VALUES ('action_edit_next_statement', 'Edit', 'Next statement', 'action_edit_next_statement');"
  "INSERT INTO menus VALUES ('action_edit_format', 'Edit', 'Format', 'action_edit_format');"
  "INSERT INTO menus VALUES ('action_edit_zoomin', 'Edit', 'Zoom in', 'action_edit_zoomin');"
  "INSERT INTO menus VALUES ('action_edit_zoomout', 'Edit', 'Zoom out', 'action_edit_zoomout');"
  "INSERT INTO menus VALUES ('action_edit_autocomplete', 'Edit', 'Autocomplete', 'action_edit_autocomplete');"
#if (OCELOT_FIND_WIDGET == 1)
  "INSERT INTO menus VALUES ('action_edit_find', 'Edit', 'Find', 'action_edit_find');"
#endif
  "INSERT INTO menus VALUES ('menu_run', 'Run', '', '[menu]');"
  "INSERT INTO menus VALUES ('action_run_execute', 'Run', 'Execute', 'action_run_execute');"
  "INSERT INTO menus VALUES ('action_run_kill', 'Run', 'Kill', 'action_run_kill');"
  "INSERT INTO menus VALUES ('menu_settings', 'Settings', '', '[menu]');"
  "INSERT INTO menus VALUES ('action_settings_menu', 'Settings', 'Menu', 'action_settings_menu');"
  "INSERT INTO menus VALUES ('action_settings_history', 'Settings', 'History Widget', 'action_settings_history');"
  "INSERT INTO menus VALUES ('action_settings_grid', 'Settings', 'Grid widget', 'action_settings_grid');"
  "INSERT INTO menus VALUES ('action_settings_statement', 'Settings', 'Statement Widget', 'action_settings_statement');"
 #if (OCELOT_MYSQL_DEBUGGER == 1)
  "INSERT INTO menus VALUES ('action_settings_debug', 'Settings', 'Debug Widget', 'action_settings_debug');"
#endif
  "INSERT INTO menus VALUES ('action_Settings_extra_rule_1', 'Settings', 'Extra Rule 1', 'action_settings_extra_rule_1');"
 #if (OCELOT_EXPLORER == 1)
  "INSERT INTO menus VALUES ('action_settings_explorer', 'Settings', 'Explorer Ridget', 'action_settings_explorer');"
#endif
  "INSERT INTO menus VALUES ('menu_options', 'Options', '', '[menu]');"
  "INSERT INTO menus VALUES ('action_options_detach_history_widget', 'Options', 'detach history widget', 'action_options_detach_history_widget');"
  "INSERT INTO menus VALUES ('action_options_detach_grid_widget', 'Options', 'detach grid widget', 'action_options_detach_grid_widget');"
#if (OCELOT_MYSQL_DEBUGGER == 1)
  "INSERT INTO menus VALUES ('action_options_detach_debug_widget', 'Options', 'detach debug widget', 'action_options_detach_debug_widget');"
#endif
  "INSERT INTO menus VALUES ('action_options_detach_statement_widget', 'Options', 'detach statement widget', 'action_options_detach_statement_widget');"
#if (OCELOT_EXPLORER == 1)
  "INSERT INTO menus VALUES ('action_options_detach_explorer_widget', 'Options', 'detach explorer widget', 'action_options_detach_explorer_widget');"
#endif
  "INSERT INTO menus VALUES ('action_options_next_window', 'Options', 'next wndow', 'action_options_next_window');"
  "INSERT INTO menus VALUES ('action_options_previous_window', 'Options', 'previous window', 'action_options_previous_window');"
#if (OCELOT_CHART_OR_QCHART == 1)
  "INSERT INTO menus VALUES ('action_options_bar', 'Options', 'result display = ''bar''', 'action_options_bar');"
#endif
  "INSERT INTO menus VALUES ('action_options_batch', 'Options', 'result display = ''batch''', 'action_options_batch');"
  "INSERT INTO menus VALUES ('action_options_horizontal', 'Options', 'result_display = ''horizontal''', 'action_options_horizontal');"
  "INSERT INTO menus VALUES ('action_options_html', 'Options', 'result_display = ''html''', 'action_options_html');"
  "INSERT INTO menus VALUES ('action_options_htmlraw', 'Options', 'result display = ''htmlraw''', 'action_options_htmlraw');"
 #if (OCELOT_CHART_OR_QCHART == 1)
  "INSERT INTO menus VALUES ('action_options_line', 'Options', 'result display = ''line''', 'action_options_line');"
  "INSERT INTO menus VALUES ('action_options_none', 'Options', 'result display = ''none''', 'action_options_none');"
  "INSERT INTO menus VALUES ('action_options_pie', 'Options', 'result display = ''pie''', 'action_options_pie');"
 #endif
  "INSERT INTO menus VALUES ('action_options_raw', 'Options', 'result display = ''raw''', 'action_options_raw');"
  "INSERT INTO menus VALUES ('action_options_vertical', 'Options', 'result display = ''vertical''', 'action_options_vertical');"
  "INSERT INTO menus VALUES ('action_options_xml', 'Options', 'result display = ''xml''', 'action_options_xml');"
#if (OCELOT_MYSQL_DEBUGGER == 1)
  "INSERT INTO menus VALUES ('menu_debug', 'Debug', '', '[menu]');"
  "INSERT INTO menus VALUES ('action_debug_breakpoint', 'Debug', 'Breakpoint', 'action_debug_breakpoint');"
  "INSERT INTO menus VALUES ('action_debug_continue', 'Debug', 'Continue',);"
  "INSERT INTO menus VALUES ('action_debug_next', 'Debug', 'Next', 'action_debug_next');"
  "INSERT INTO menus VALUES ('action_debug_step', 'Debug', 'Step', 'action_debug_step');"
  "INSERT INTO menus VALUES ('action_debug_clear', 'Debug', 'Clear', 'action_debug_clear');"
  "INSERT INTO menus VALUES ('action_debug_exit', 'Debug', 'Exit', 'action_debug_exit');"
  "INSERT INTO menus VALUES ('action_debug_information', 'Debug', 'Information', 'action_debug_information');"
  "INSERT INTO menus VALUES ('action_debug_refresh_server_variables', 'Debug', 'Refresh server variables', 'action_debug_refresh_server_variables');"
  "INSERT INTO menus VALUES ('action_debug_refresh_user_variables', 'Debug', 'Refresh user variables', 'action_debug_refresh_user_variables');"
  "INSERT INTO menus VALUES ('action_debug_refresh_variables', 'Debug', 'Refresh variables', 'action_debug_refresh_variables');"
  "INSERT INTO menus VALUES ('action_debug_refresh_call_stack', 'Debug', 'Refresh call stack', 'action_debug_refresh_call_stack');"
  "INSERT INTO menus VALUES ('menu_help', 'Help', '', '[menu]');"
  "INSERT INTO menus VALUES ('action_help_about', 'Help', 'About', 'action_help_about');"
  "INSERT INTO menus VALUES ('action_help_the_manual', 'Help', 'The Manual', 'action_help_the_manual');"
  "INSERT INTO menus VALUES ('Separator_4', 'Help', '', '[separator]');"
#if (OCELOT_MYSQL_INCLUDE == 1)
  "INSERT INTO menus VALUES ('action_help_libmysqlclient', 'Help', 'libmysqlclient', 'action_help_libmysqlclient');"
#endif
  "INSERT INTO menus VALUES ('action_help_settings', 'Help', 'settings', 'action_help_settings');"
  ;
*/
  QString query;
#if (OCELOT_PLUGIN == 1)
  if (plugin_widget_list.size() > 0)
  {
    ocelot_plugin_pass.query= b;
    int return_code= plugin_widget_list_caller(PLUGIN_MAKE_MENU, "");
    if (return_code ==  PLUGIN_RETURN_OK_AND_REPLACED)
      query= QString::fromUtf8(ocelot_plugin_pass.replacer_buffer, ocelot_plugin_pass.replacer_buffer_length);
    else query= b;
  }
  else query= b;
#else
  query= b;
#endif
  /* Warning: following assumes query has only INSERTS with correct syntax, as above. */
  int desired_count= query.size() + 1;
  int *token_offsets= new int[desired_count];
  int *token_lengths= new int[desired_count];
  token_lengths[0]= 0;
  tokenize(query.data(),
           query.size(),
           &token_lengths[0], &token_offsets[0], desired_count,
          (QChar*)"33333", 2, ";", 1);
  /* Copying what's in execute_ocelot_query but fewer assumptions because this is called very early */
  QString id= ""; QString menu_title= ""; QString menuitem= ""; QString action= "";
  int j= 0;
  for (int i_of_q= 0; token_lengths[i_of_q] != 0; ++i_of_q)
  {
    QString q_token= query.mid(token_offsets[i_of_q], token_lengths[i_of_q]);
    if (q_token.left(1) == "'") /* i.e. is it string literal */
    {
      q_token= connect_stripper(q_token, true);
      if (j == 0) id= q_token;
      if (j == 1) menu_title= q_token;
      if (j == 2) menuitem= q_token;
      if (j == 3) action= q_token;
      ++j;
    }
    if (q_token == ";") /* i.e. is it end of INSERT */
    {
      menu_spec_insert_one(id, menu_title, menuitem, action);
      id= ""; menu_title= ""; menuitem= ""; action= "";
      j= 0;
    }
  }
  delete [] token_lengths;
  delete [] token_offsets;

  /* default shortcuts and keywords (initially fixed, no-ops if plugin changes id) */

  /* Following should probably be in a separate proc because one might delete a menuitem then insert it again */

  for (int k= 0; k < menu_spec_struct_list.size(); ++k)
  {
    if (menu_spec_struct_list[k].id == "action_file_connect")
    {
      QKeySequence qks_open= QKeySequence::Open; QString qks_open_string= qks_open.toString();
      menu_spec_struct_list[k].shortcut_default= qks_open_string;
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_CONNECT;
    }
    if (menu_spec_struct_list[k].id == "action_file_exit")
    {
      menu_spec_struct_list[k].shortcut_default= "Ctrl+Q";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_EXIT;
    }
    if (menu_spec_struct_list[k].id == "action_edit_undo")
    {
      QKeySequence qks_undo= QKeySequence::Undo; QString qks_undo_string= qks_undo.toString();
      menu_spec_struct_list[k].shortcut_default= qks_undo_string;
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_UNDO;
    }
    if (menu_spec_struct_list[k].id == "action_edit_redo")
    {
      QKeySequence qks_redo= QKeySequence::Redo; QString qks_redo_string= qks_redo.toString();
      menu_spec_struct_list[k].shortcut_default= qks_redo_string;
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_REDO;
    }
    if (menu_spec_struct_list[k].id == "action_edit_cut")
    {
      QKeySequence qks_cut= QKeySequence::Cut; QString qks_cut_string= qks_cut.toString();
      menu_spec_struct_list[k].shortcut_default= qks_cut_string;
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_CUT;
    }
    if (menu_spec_struct_list[k].id == "action_edit_copy")
    {
      QKeySequence qks_copy= QKeySequence::Copy; QString qks_copy_string= qks_copy.toString();
      menu_spec_struct_list[k].shortcut_default= qks_copy_string;
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_COPY;
    }
    if (menu_spec_struct_list[k].id == "action_edit_paste")
    {
      QKeySequence qks_paste= QKeySequence::Paste; QString qks_paste_string= qks_paste.toString();
      menu_spec_struct_list[k].shortcut_default= qks_paste_string;
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_PASTE;
    }
    if (menu_spec_struct_list[k].id == "action_edit_select_all")
    {
      QKeySequence qks_select_all= QKeySequence::SelectAll; QString qks_select_all_string= qks_select_all.toString();
      menu_spec_struct_list[k].shortcut_default= qks_select_all_string;
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_SELECT_ALL;
    }
    if (menu_spec_struct_list[k].id == "action_edit_previous_statement")
    {
      menu_spec_struct_list[k].shortcut_default= "Ctrl+P";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_PREVIOUS;
    }
    if (menu_spec_struct_list[k].id == "action_edit_next_statement")
    {
      menu_spec_struct_list[k].shortcut_default= "Ctrl+N";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_NEXT;
    }
    if (menu_spec_struct_list[k].id == "action_edit_format")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+Shift+F";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_FORMAT;
    }
    if (menu_spec_struct_list[k].id == "action_edit_zoomin")
    {
      menu_spec_struct_list[k].shortcut_default= "Ctrl+=";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMIN;
    }
    if (menu_spec_struct_list[k].id == "action_edit_zoomout")
    {
      QKeySequence qks_zoomout= QKeySequence::ZoomOut; QString qks_zoomout_string= qks_zoomout.toString();
      menu_spec_struct_list[k].shortcut_default= qks_zoomout_string;
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMOUT;
    }
    if (menu_spec_struct_list[k].id == "action_edit_autocomplete")
    {
      menu_spec_struct_list[k].shortcut_default= "Tab";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_AUTOCOMPLETE;
    }
#if (OCELOT_FIND_WIDGET == 1)
    if (menu_spec_struct_list[k].id == "action_edit_find")
    {
      menu_spec_struct_list[k].shortcut_default= "Ctrl+F";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_FIND;
    }
#endif
    if (menu_spec_struct_list[k].id == "action_run_execute")
    {
      menu_spec_struct_list[k].shortcut_default= "Ctrl+E";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_EXECUTE;
    }
    if (menu_spec_struct_list[k].id == "action_run_kill")
    {
      menu_spec_struct_list[k].shortcut_default= "Ctrl+C";;
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_KILL;
    }
    if (menu_spec_struct_list[k].id == "action_options_detach_history_widget")
    {
      menu_spec_struct_list[k].qaction->setCheckable(true);
    }
    if (menu_spec_struct_list[k].id == "action_options_result_grid_widget")
    {
      menu_spec_struct_list[k].qaction->setCheckable(true);
    }
#if (OCELOT_MYSQL_DEBUGGER == 1)
    if (menu_spec_struct_list[k].id == "action_options_detach_debug_widget")
    {
      menu_spec_struct_list[k].qaction->setCheckable(true);
    }
#endif
    if (menu_spec_struct_list[k].id == "action_options_detach_statement_widget")
    {
      menu_spec_struct_list[k].qaction->setCheckable(true);
    }
#if (OCELOT_EXPLORER == 1)
    if (menu_spec_struct_list[k].id == "action_options_detach_explorer_widget")
    {
      menu_spec_struct_list[k].qaction->setCheckable(true);
    }
#endif
    if (menu_spec_struct_list[k].id == "action_options_next_child")
    {
      QKeySequence qks_next_child= QKeySequence::NextChild; QString qks_next_child_string= qks_next_child.toString();
      menu_spec_struct_list[k].shortcut_default= qks_next_child_string;
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT_WINDOW;
    }
    if (menu_spec_struct_list[k].id == "action_options_previous_child")
    {
      QKeySequence qks_previous_child= QKeySequence::PreviousChild; QString qks_previous_child_string= qks_previous_child.toString();
      menu_spec_struct_list[k].shortcut_default= qks_previous_child_string;
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_PREVIOUS_WINDOW;
    }
    if (menu_spec_struct_list[k].id == "action_options_bar")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+Shift+B";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_BAR;
    }
    if (menu_spec_struct_list[k].id == "action_options_batch")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+Shift+1";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_BATCH;
    }
    if (menu_spec_struct_list[k].id == "action_options_horizontal")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+Shift+2";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_HORIZONTAL;
    }
    if (menu_spec_struct_list[k].id == "action_options_html")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+Shift+3";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_HTML;
    }
    if (menu_spec_struct_list[k].id == "action_options_htmlraw")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+Shift+4";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_HTMLRAW;
    }
#if (OCELOT_CHART_OR_QCHART == 1)
    if (menu_spec_struct_list[k].id == "action_options_line")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+Shift+L";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_LINE;
    }
    if (menu_spec_struct_list[k].id == "action_options_none")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+Shift+N";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_NONE;
    }
    if (menu_spec_struct_list[k].id == "action_options_pie")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+Shift+P";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_PIE;
    }
#endif
    if (menu_spec_struct_list[k].id == "action_options_raw")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+Shift+5";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_RAW;
    }
    if (menu_spec_struct_list[k].id == "action_options_vertical")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+Shift+6";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_VERTICAL;
    }
    if (menu_spec_struct_list[k].id == "action_options_xml")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+Shift+7";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_XML;
    }
#if (OCELOT_MYSQL_DEBUGGER == 1)
    if (menu_spec_struct_list[k].id == "action_debug_breakpoint")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+1";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_BREAKPOINT;
    }
    if (menu_spec_struct_list[k].id == "action_debug_continue")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+2";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_CONTINUE;
    }
    if (menu_spec_struct_list[k].id == "action_debug_next")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+3";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT;
    }
    if (menu_spec_struct_list[k].id == "action_debug_step")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+5";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_STEP;
    }
    if (menu_spec_struct_list[k].id == "action_debug_clear")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+6";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_CLEAR;
    }
    if (menu_spec_struct_list[k].id == "action_debug_exit")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+7";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_DEBUG_EXIT;
    }
    if (menu_spec_struct_list[k].id == "action_debug_information")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+8";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_INFORMATION;
    }
    if (menu_spec_struct_list[k].id == "action_debug_refresh_server_variables")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+9";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_SERVER_VARIABLES;
    }
    if (menu_spec_struct_list[k].id == "action_debug_refresh_user_variables")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+0";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_USER_VARIABLES;
    }
    if (menu_spec_struct_list[k].id == "action_debug_refresh_variables")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+A";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_VARIABLES;
    }

    if (menu_spec_struct_list[k].id == "action_debug_refresh_call_stack")
    {
      menu_spec_struct_list[k].shortcut_default= "Alt+B";
      menu_spec_struct_list[k].keyword= TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_CALL_STACK;
    }
#endif
  }
}

/* Pass: i = offset in menu_spec_struct_list. Do: addMenu(), connct menu to menu_about_to_show(). */
QMenu* MainWindow::menu_spec_add_menu(int i)
{
  QMenu *qmenu= ui->menuBar->addMenu(menu_spec_struct_list[i].menu_title);
  menu_spec_struct_list[i].qmenu= qmenu;
  connect(menu_spec_struct_list[i].qmenu,&QMenu::aboutToShow,this,&MainWindow::menu_about_to_show);
  return qmenu;
}

/* Pass: i = offset in menu_spec_struct_list. Do: addAction(), connect action to menu_spec_action_all(). For type = 1. */
QAction* MainWindow::menu_spec_add_action(int i, QMenu *qmenu)
{
  if (qmenu == NULL) { printf("qmenu == NULL\n"); return NULL; }
  menu_spec_struct_list[i].qmenu= qmenu; /* Hmm, this is assuming that qactions are all after qmenus */
  QAction* new_action = new QAction(menu_spec_struct_list[i].menu_item, this);
  qmenu->addAction(new_action);
  menu_spec_struct_list[i].qaction= new_action;
  /* Hmm, you don't want to do this multiple times, move it */
  connect(new_action, SIGNAL(triggered(bool)), this, SLOT(menu_spec_action_all(bool)));
  return new_action; /* although I think we never use the return so menu_spec_add_action() could be void */
}

/*
  We'll get here for every menu where menu_spec_struct_list[i].type == 0 (i.e. we don't check if == 2).
  Todo: it would be more useful if we knew which menu
  Todo: have a plugin here.
  Todo: maybe this is a good time to see what is the focus widget, somewhere else we have a hard time knowing that
        because the menu becomes the focus widget, if this shows what it was before then that will be handy
        e.g. action_edit_undo() looks at QApplication::focusWidget()
  Todo: I hope all the recent method-name changes aren't affecting what e.g. action_edit_undo() thinks is the name!
  Warning: if all that's happening is that the user is shifting the mouse around the top of the menu bar,
           menu_about_to_show will happen multiple times
*/
void MainWindow::menu_about_to_show()
{
  /* printf("**** menu_about_to_show!\n"); */
}

/*
  menu_spec_reset cancels that menu_spec_make_menu made new QActions + QMenus + separators, and connected to slots.
  go backwards so that actions will be deleted before menus
  it would be simpler to just delete all the qmenus -- delete + remke menuBar? -- but this is also a place to do error checks
  But nothing calls this, it's just here in case someday we want to delete.
*/
#ifdef MENU_SPEC_RESET_MENU
void MainWindow::menu_spec_reset_menu()
{
  for (int i= menu_spec_struct_list.size() - 1; i >= 0; --i)
  {
    if ((menu_spec_struct_list[i].menu_type == MENU_SPEC_TYPE_MENU)
     || (menu_spec_struct_list[i].menu_type == MENU_SPEC_TYPE_SUBMENU))
    {
      QMenu *qmenu= menu_spec_struct_list[i].qmenu;
      if (qmenu == NULL) printf("**** qmenu is NULL\n");
      else
      {
        for (int j= 0; j < qmenu->actions().size(); ++j)
        {
          QAction *qaction= qmenu->actions().at(j);
          if (qaction->isSeparator()) printf("**** isSeparator!\n");
          else if (qaction->menu()) { printf("**** isMenu!\n"); delete qaction->menu(); }
          else { printf("**** action!\n"); delete qaction; } /* do I need to remove? */
        }
        delete qmenu;
        menu_spec_struct_list[i].qmenu= NULL;
      }
    }
    if (menu_spec_struct_list[i].menu_type == MENU_SPEC_TYPE_MENUITEM)
    {
      QAction *qaction= menu_spec_struct_list[i].qaction;
      if (qaction == NULL) printf("**** Error, qaction == NULL\n");
      else
      {
        QMenu *qmenu= menu_spec_struct_list[i].qmenu;
if (qmenu == NULL) printf("**** qmenu == NULL\n");
        bool is_action_in_menu= false;
        for (int j= 0; j < qmenu->actions().size(); ++j)
        {
          if (qaction == qmenu->actions().at(j)) is_action_in_menu= true;
        }
        if (is_action_in_menu == false) printf("**** Error. action not in menu\n");
        /* Hmm. I would like to check that it's connected, if type == 1 */
        delete qaction;
        menu_spec_struct_list[i].qaction= NULL;
      }
    }
  }
  int menubar_size= ui->menuBar->children().size();
  if (menubar_size != 0) printf("**** menubar not empty, %d children!\n", menubar_size); /* always happens */
}
#endif //#ifdef MENU_SPEC_RESET_MENU

/* Warning: "Export" is a menu so we assume it's unique, even though it's a component of "menu_file" */
QMenu* MainWindow::menu_spec_find_menu(QString menu_name)
{
  for (int i= 0; i < menu_spec_struct_list.size(); ++i)
  {
    if (menu_name == menu_spec_struct_list[i].menu_name)
    {
      if (menu_spec_struct_list[i].qmenu == NULL) printf("qmenu == NULL\n"); /* this should not happen */
      return menu_spec_struct_list[i].qmenu;
    }
  }
  printf("end menu_spec_find_menu -- FAIL!\n"); /* this should not happen */
  return NULL;
}

/* Todo: is it right that we're comparing with id not action? I think so. */
QAction* MainWindow::menu_spec_find_action(QString action_name)
{
  for (int i= 0; i < menu_spec_struct_list.size(); ++i)
  {
    if (action_name == menu_spec_struct_list[i].id)
    {
      return menu_spec_struct_list[i].qaction;
      //return menu_file_action_file_connect;
    }
  }
  /* It's okay if find fails (actions can be deleted), but don't try to use the result! Usually just ignore NULL. */
  return NULL;
}

int MainWindow::menu_spec_find_id(QString id)
{
  id= connect_stripper(id, false);
  for (int i= 0; i < menu_spec_struct_list.size(); ++i)
  {
    if (id == menu_spec_struct_list[i].id)
    {
      return i;
    }
  }
  return -1;
}

/* reverse whatever was done in menu_spec_add_action() and connect()s */
/* Assumptions: delete qaction automatically removes connect() of its slot and abouttoshow slot and removes from qmenu */
/* We don't delete menus, only menuitems */
/* todo: hparse should have a pick list */
int MainWindow::menu_spec_delete_via_id(QString id)
{
  int i= menu_spec_find_id(id); /* same search + error check as for shortcut_set_via_id */
  if (i == -1) return ER_0_ROWS_RETURNED;
  int menu_type= menu_spec_struct_list.at(i).menu_type;
  if (menu_type != MENU_SPEC_TYPE_MENUITEM) return ER_0_ROWS_RETURNED;
  // QMenu *qmenu= menu_spec_struct_list.at(i).qmenu;
  QAction *qaction= menu_spec_struct_list.at(i).qaction;
  menu_spec_struct_list.removeAt(i);
  delete qaction;
  return ER_OK;
}

/* A short wrapper around setEnabled for when we're not calling from MainWindow */
void MainWindow::menu_set_enabled(QString menu_id, bool is_enable_or_disable)
{
  QAction *qaction= menu_spec_find_action(menu_id);
  if (qaction != NULL) qaction->setEnabled(is_enable_or_disable);
}

/*
  This has to be the slot for all menus and menu items. It's in public slots.
  Use sender() to find what the qaction is, call action_all to find the action and do something about it
  Todo: check: I'm pretty sure we won't get here for a disabled menu item, but probably should make sure.
*/
void MainWindow::menu_spec_action_all(bool is_checked)
{
  QAction *qaction_pointer= qobject_cast<QAction*>(sender());
  for (int i= 0; i < menu_spec_struct_list.size();++i)
  {
    if (menu_spec_struct_list[i].menu_type == MENU_SPEC_TYPE_MENUITEM) /* ?? Huh? what if it's menu or it's got a sub? */
    {
      if (qaction_pointer == menu_spec_struct_list[i].qaction) /* Should this only be if menu item? */
      {
        action_i(i, is_checked);
        break;
      }
    }
  }
}

/*
  Called from menu_spec_action_all or keypress_shortcut_handler
  We know that menu_spec_struct_list[i] is the menu item that we want to act on.
  If action ends with ";" then it's an SQL query that just needs to be dumped in the statement widget.
  Else: look for the menuitem's function in menu_function_struct_list the fixed list of MainWindow:: functions that are
  there for all the initial menus. If it's not there, look in the plugins list because menuitem actions can be plugin names.
*/
void MainWindow::action_i(int i, bool is_checked)
{
  int j;
  for (j= 0; j < menu_function_struct_list.size(); ++j)
  {
    if (menu_spec_struct_list[i].action == menu_function_struct_list[j].name) break;
  }
  if (j == menu_function_struct_list.size())
  {
    /* "If it ends with ; it is considered to be SQL, it will be put in statement widget ready to execute." */
    QString menu_spec_action= menu_spec_struct_list[i].action;
    if (menu_spec_action.right(1) == ";")
    {
      statement_edit_widget->setPlainText(menu_spec_action);
      return;
    }
#if (OCELOT_PLUGIN == 1)
    if (plugin_widget_list.size() > 0)
    {
      QString text= statement_edit_widget->toPlainText();
      ocelot_plugin_pass.query= text.toUtf8().data();
      int return_code= plugin_widget_list_caller(PLUGIN_MENU_CHOICE, menu_spec_action);
      if (return_code ==  PLUGIN_RETURN_OK_AND_REPLACED)
      {
        text= QString::fromUtf8(ocelot_plugin_pass.replacer_buffer, ocelot_plugin_pass.replacer_buffer_length);
        statement_edit_widget->setPlainText(text);
      }
    }
#endif
  }
  else /* action is in the official list */
  {
    void (MainWindow::*method_pointer)(bool)= menu_function_struct_list[j].p_method;
    //void (MainWindow::*method_pointer)(bool)= menu_spec_struct_list[i].p_method;
    //menu_spec_struct_list[i].p_function; /* BUT THIS DOES NOT CALL! */
    (this->*method_pointer)(is_checked); /* This is how I call a pointer to a method in MainWindow */
  }
}

/*
  Called from shortcut_set_via_id(), shortcut_set_via_keyword(), fill_menu_2() -- we already know menu_spec_struct_list index.
  Actually shortcut ordinarily is triggered due to setShortcut, keypress_shortcut_handler() is more like a backup.
  Todo: We allow duplicate shortcuts. When checking, also note whether a menu name starts with &
        because e.g. if menu name is &Options then Alt+O wants to go to the Options menu, it conflicts with the shortcut.
  Tip: remove qaction->setShortcut(k) if you want shortcuts to be handled via keypress_shortcut_handler and be not displayed.
*/
int MainWindow::shortcut_set(int i, QString value)
{
  QAction *qaction= menu_spec_struct_list[i].qaction;
  if (qaction == NULL) return ER_0_ROWS_RETURNED; /* menu? */
  value= connect_stripper(value, false);
  if (value == "default") value= menu_spec_struct_list[i].shortcut_default;
  int er= ER_OK;
  if (value == "") qaction->setShortcut(QKeySequence());
  else
  {
    QKeySequence k= QKeySequence(value);
    /* too many keys? too few? malformed string? todo: hmm, this doesn't seem to catch malformed strings*/
    if ((k.count() < 1) || (k.isEmpty()) || (k.toString() < "")) return ER_ILLEGAL_VALUE;
    value= k.toString(QKeySequence::NativeText); /* converting back to string should make it canonical? */
    if (value == "") return ER_ILLEGAL_VALUE;
    for (int j= 0; j < menu_spec_struct_list.size(); ++j)
    {
      if (j == i) continue;
      if (menu_spec_struct_list[j].shortcut == "") continue;
      QKeySequence k2= QKeySequence(menu_spec_struct_list[j].shortcut);
      if (k == k2) er= ER_DUPLICATE;
    }
    qaction->setShortcut(k);
    }
  menu_spec_struct_list[i].shortcut= value;
  return er;
}

/*
  Some todos related to shortcuts:
    Todo: error if different QAction has the same shortcut (but beware, if we used a QKeySequence:: default
          and it turns out that in a different environment that default is not what it is on Windows or Linux)
    Todo: think of a default for a plugin
    Todo: Test that the sequence would work
  Todo: Change menu_title, but it's trickier, qmenu will change if it's old or will be created if it's new.
*/
int MainWindow::menu_set_via_id(QString target, QString id, QString value)
{
  int i= menu_spec_find_id(id);
  if (i == -1)
  {
    return ER_0_ROWS_RETURNED;
  }
  value= connect_stripper(value, false);
  if (target == "MENU_ITEM")
  {
    menu_spec_struct_list[i].menu_item= value;
    QAction *qaction= menu_spec_struct_list[i].qaction;
    if (qaction != NULL) qaction->setText(value);
  }
  else if (target == "SHORTCUT")
  {
    /* i.e. this is shortcut_set_via_id */
    return shortcut_set(i, value);
  }
  else /* target == "ACTION" */ menu_spec_struct_list[i].action= value;
  return ER_OK;
}

/*
  This is the shortcut handling when we have a keyword e.g. OCELOT_KEYWORD_SHORTCUT_UNDO, which is obsolete.
  Find keyword by searching in menu_spec_struct_list, then use shortcut_set() to change it.
*/
int MainWindow::shortcut_set_via_keyword(int target, QString token3)
{
  for (int i= 0; i < menu_spec_struct_list.size(); ++i)
  {
    if (target == menu_spec_struct_list[i].keyword)
      return shortcut_set(i, token3);
  }
  return ER_0_ROWS_RETURNED; /* actually this might be an error that the menu item doesn't exist (they can be deleted) */
}

/*
  Edit Menu Dispatcher

  We have only one edit menu, but we have multiple edit widgets.
  So the connect-signal-slot code in create_menu() jumps to menu_edit slots.
  The alternatives were: Multiple Document Interface, or multiple windows. I thought this was easier.
  For example, for cut: the slot is action_edit_cut, it gets the focused widget and calls its cut().
  But Undo and Redo are complicated: for some widgets they're enabled, for some widgets they're not.
  TODO: We are not enabling|disabling edit menu items properly. We should be saying (examples):
        Initially, menu_edit_action_cut->setEnabled(false);
        When creating any editor widget,
          connect(widget, SIGNAL(copyAvailable(bool)),menu_edit_action_cut, SLOT(setEnabled(bool)));
        When we want to know if something can be pasted,
          connect(QApplication::clipboard(), SIGNAL(dataChanged()), this, SLOT(processClipboardChange()));
          qMimeData* x= clipboard->mimeData();
          qStringList* y= x->formats();
          int z= y->size();
          if (z > 0) menu_edit_action_paste->setEnabled();                 << wrong, you only know if paste is possible
        If something is selected and focus changes: de-select      
  TODO: I have no idea what "else if (strcmp(class_name, "+") == 0)"
        is for, maybe it's a bug. Compare action_edit_redo().
*/
void MainWindow::action_edit_undo(bool is_checked)
{
  (void)is_checked;
  QWidget* focus_widget= QApplication::focusWidget();
  const char *class_name= focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
    action_undo();
  else if (strcmp(class_name, "Result_qtextedit") == 0)
    qobject_cast<Result_qtextedit*>(focus_widget)->undo();
  else if (strcmp(class_name, "TextEditHistory") == 0)
    qobject_cast<TextEditHistory*>(focus_widget)->undo();
  else if (strcmp(class_name, "QTextEdit") == 0)
    qobject_cast<QTextEdit*>(focus_widget)->undo();
  else if (strcmp(class_name, "+") == 0)
    qobject_cast<QTextEdit*>(focus_widget)->undo();
}
void MainWindow::action_edit_redo(bool is_checked)
{
  (void)is_checked;
  QWidget* focus_widget= QApplication::focusWidget();
  if (focus_widget == 0) return; /* This would be unexpected */
  const char *class_name= focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
    action_redo();
  else if (strcmp(class_name, "Result_qtextedit") == 0)
    qobject_cast<Result_qtextedit*>(focus_widget)->redo();
  else if (strcmp(class_name, "TextEditHistory") == 0)
    qobject_cast<TextEditHistory*>(focus_widget)->redo();
  else if (strcmp(class_name, "QTextEdit") == 0)
    qobject_cast<QTextEdit*>(focus_widget)->redo();
}
void MainWindow::action_edit_cut(bool is_checked)
{
  (void)is_checked;
  QWidget* focus_widget= QApplication::focusWidget();
  if (focus_widget == 0) return; /* This would be unexpected */
  const char *class_name= focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
    qobject_cast<CodeEditor*>(focus_widget)->cut();
  else if (strcmp(class_name, "Result_qtextedit") == 0)
    qobject_cast<Result_qtextedit*>(focus_widget)->cut();
  else if (strcmp(class_name, "TextEditHistory") == 0)
    qobject_cast<TextEditHistory*>(focus_widget)->cut();
  else if (strcmp(class_name, "QTextEdit") == 0)
    qobject_cast<QTextEdit*>(focus_widget)->cut();
}
void MainWindow::action_edit_copy(bool is_checked)
{
  (void)is_checked;
  QWidget* focus_widget= QApplication::focusWidget();
  if (focus_widget == 0) return; /* This would be unexpected */
  const char *class_name= focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
    qobject_cast<CodeEditor*>(focus_widget)->copy();
  else if (strcmp(class_name, "Result_qtextedit") == 0)
    /* see Result_qtextedit::copy() later in this file */
    qobject_cast<Result_qtextedit*>(focus_widget)->copy();
  else if (strcmp(class_name, "TextEditHistory") == 0)
    qobject_cast<TextEditHistory*>(focus_widget)->copy();
  else if (strcmp(class_name, "QTextEdit") == 0)
    qobject_cast<QTextEdit*>(focus_widget)->copy();
}
void MainWindow::action_edit_paste(bool is_checked)
{
  (void)is_checked;
  QWidget* focus_widget= QApplication::focusWidget();
  if (focus_widget == 0) return; /* This would be unexpected */
  const char *class_name= focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
    qobject_cast<CodeEditor*>(focus_widget)->paste();
  else if (strcmp(class_name, "Result_qtextedit") == 0)
    /* see Result_qtextedit::paste() later in this file */
    qobject_cast<Result_qtextedit*>(focus_widget)->paste();
  if (strcmp(class_name, "TextEditHistory") == 0)
    qobject_cast<TextEditHistory*>(focus_widget)->paste();
  else if (strcmp(class_name, "QTextEdit") == 0)
    qobject_cast<QTextEdit*>(focus_widget)->paste();
}
void MainWindow::action_edit_select_all(bool is_checked)
{
  (void)is_checked;
  QWidget* focus_widget= QApplication::focusWidget();
  if (focus_widget == 0) return; /* This would be unexpected */
  const char *class_name= focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
    qobject_cast<CodeEditor*>(focus_widget)->selectAll();
  else if (strcmp(class_name, "Result_qtextedit") == 0)
    qobject_cast<Result_qtextedit*>(focus_widget)->selectAll();
  else if (strcmp(class_name, "TextEditHistory") == 0)
    qobject_cast<TextEditHistory*>(focus_widget)->selectAll();
  else if (strcmp(class_name, "QTextEdit") == 0)
    qobject_cast<QTextEdit*>(focus_widget)->selectAll();
}
/*
  zoom in/out won't work by calling default zoomIn()/zoomOut(), probably
  because we use style sheets. So we'll get the current style
  sheet, add an increment (currently always +1 or -1), change
  the style sheet. This does not affect what's set with Settings.
  That's deliberate. Zooming is temporary, setting is permanent.
  Re extracting: Compare what we do with get_font_from_style_sheet().
  Todo: Changing font size won't affect images, we need special handling.
  Todo: Maybe we should qobject_cast for setStyleSheet() too.
  Todo: BUG: If you just click on a ResultGrid cell, thinking you have
        given it the focus, and then you click Ctrl++ or Ctrl-- i.e.
        the shortcut not the menu item, it doesn't recognize it.
        Click away, then come back, and it does recognize it.
  Re Result_qtextedit:
    For unknown reasons qobject_cast<Result_qtextedit*>(focus_widget)->styleSheet() returns blank.
    Maybe it has something to do with setHtml(). Anyway, we have a workaround that increases/decreases
    font size for all result grids. This might be okay temporarily but it doesn't generate a SET statement,
    and it would be fine to have something that increased cell size as well as font (especially fine if
    there is an image, and it would be fine to have something that zooms only to the cell in focus.
*/
void MainWindow::action_edit_zoominorout(int increment)
{
  QWidget* focus_widget= QApplication::focusWidget();
  if (focus_widget == 0) return; /* This would be unexpected */
  QString old_stylesheet;
  const char *class_name= focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
    old_stylesheet= qobject_cast<CodeEditor*>(focus_widget)->styleSheet();
  else if (strcmp(class_name, "Result_qtextedit") == 0)
    old_stylesheet= ocelot_grid_style_string;
  else if (strcmp(class_name, "TextEditHistory") == 0)
    old_stylesheet= qobject_cast<TextEditHistory*>(focus_widget)->styleSheet();
  else if (strcmp(class_name, "QTextEdit") == 0)
    old_stylesheet= qobject_cast<QTextEdit*>(focus_widget)->styleSheet();
  else return; /* This would be unexpected. */
  int i= old_stylesheet.indexOf("font-size:");
  if (i == -1) return;
  i+= sizeof("font-size:");
  int j= old_stylesheet.indexOf("pt", i);
  if (j == -1) return;
  QString old_font_size= old_stylesheet.mid(i-1, j-(i-1));
  int font_size= old_font_size.toInt();
  font_size+= increment;
  if (font_size < FONT_SIZE_MIN) font_size= FONT_SIZE_MIN;
  if (font_size > FONT_SIZE_MAX) font_size= FONT_SIZE_MAX;
  QString new_stylesheet= old_stylesheet.mid(0, i-1);
  new_stylesheet.append(QString::number(font_size));
  new_stylesheet.append(old_stylesheet.mid(j,old_stylesheet.size()-j));
  focus_widget->setStyleSheet(new_stylesheet);
  if (strcmp(class_name, "Result_qtextedit") == 0)
    xsettings_widget->ocelot_variable_set(TOKEN_KEYWORD_OCELOT_GRID_FONT_SIZE, QString::number(font_size));
  return;
}
void MainWindow::action_edit_zoomin(bool is_checked)
{
  (void)is_checked;
  action_edit_zoominorout(FONT_SIZE_ZOOM_INCREMENT);
}
void MainWindow::action_edit_zoomout(bool is_checked)
{
  (void)is_checked;
  action_edit_zoominorout(-FONT_SIZE_ZOOM_INCREMENT);
}

/*
  The autocomplete shortcut is handled by event filter which
  calls keypress_shortcut_handler() which calls menu_edit_autocomplete()
  directly. Therefore we can only get here if the user chooses
  the autocomplete menu item rather than press a shortcut key.
  And in that case we don't care if the return is false.
*/
void MainWindow::action_edit_autocomplete(bool is_checked)
{
  (void)is_checked;
  QAction *menu_edit_action_autocomplete= menu_spec_find_action("action_edit_autocomplete");
  if (menu_edit_action_autocomplete != NULL) /* unlikely */
  {
    if (completer_widget->shortcut_override(menu_edit_action_autocomplete->shortcut()) == true) return;
 }
  menu_edit_autocomplete();
}

/*
  Called from edit menu choice = autocomplete or keypress_shortcut_handler().
  Depends on rehash, ocelot_ca.auto_rehash etc. e.g. was REHASH called.
  The extra checking here applies because default key is Tab Qt::Key_Tab,
  we want to return false if we don't handle it as a shortcut,
  so that it will simply be added to the widget contents.
  Put ``s or ""s around if they appear to be necessary.
  Todo: in MySQL/MariaDB lower-case letters might apper in regular identifiers, depending on settings.
  Todo: should we be using sql_mode_ansi_quotes or hparse_sql_mode_ansi_quotes?
*/
bool MainWindow::menu_edit_autocomplete()
{
  QString text;
  {
    if (completer_widget->isHidden() == false)
    {
      if (statement_edit_widget->hasFocus() == true)
      {
        QString tool_tip;
        QString word= completer_widget->get_selected_item(&tool_tip);
        int i;
        for (i= 0; main_token_lengths[i] != 0; ++i)
        {
          if ((main_token_flags[i] & TOKEN_FLAG_IS_ERROR) != 0) break;
        }
        if ((main_token_flags[i] & TOKEN_FLAG_IS_ERROR) == 0) return true;
        text= statement_edit_widget->toPlainText();
        if (tool_tip == "i")
        {
          bool is_regular= true;
          for (int i= 0; i < word.length(); ++i)
          {
            QChar c= word.at(i);
            if (c.isLetter())
            {
              if (c.isLower()) {is_regular= false; break; }
            }
            else if (c.isNumber())
            {
              if (i == 0) {is_regular= false; break; }
            }
            else if (c == '_')
            {
              continue;
            }
            else
            {
              is_regular= false; break;
            }
          }
          if (is_regular == false)
          {
            if (sql_mode_ansi_quotes == true) word= "\"" + word + "\"";
            else word= "`" + word + "`";
          }
        }
        if (word.left(1) != "[")
        {
          int offset;
          if (main_token_lengths[i] == 0)
          {
            offset= text.size();
            word= " " + word;
          }
          else offset= main_token_offsets[i];
          QString new_text= text.left(offset);
          new_text.append(word);
          int rest_start= offset + main_token_lengths[i];
          new_text.append(text.right(text.size() - rest_start));
          statement_edit_widget->setPlainText(new_text);
          QTextCursor c= statement_edit_widget->textCursor();
          c.movePosition(QTextCursor::End);
          statement_edit_widget->setTextCursor(c);
          completer_widget->updater();
          return true;
        }
      }
    }
  }
  return false;
}

#if (OCELOT_FIND_WIDGET == 1)
void MainWindow::action_edit_find(bool is_checked)
{
  (void)is_checked;
  find_widget->find_widget_activate();
}
#endif

/*
  The required size of main_token_offsets|lengths|types|flags is
  #-of-tokens + 1. We allocate lots more than enough after calculating
  x = (size-in-bytes + 1) rounded up to nearest 1000.
  We never reduce and perhaps that will appear to be a memory leak.
  todo: check if 'new' fails.
*/
void MainWindow::main_token_new(int text_size)
{
  unsigned int desired_count;
  desired_count= text_size + 1;
  if (desired_count >= main_token_max_count)
  {
    if (main_token_max_count != 0)
    {
      delete [] main_token_offsets;
      delete [] main_token_lengths;
      delete [] main_token_types;
      delete [] main_token_flags;
      delete [] main_token_pointers;
      delete [] main_token_reftypes;
    }
    desired_count= (desired_count - (desired_count % 1000)) + 1000;
    main_token_offsets= new int[desired_count];
    main_token_lengths= new int[desired_count];
    main_token_lengths[0]= 0;
    main_token_types= new int[desired_count];
    main_token_flags= new unsigned int[desired_count];
    main_token_pointers= new int[desired_count];
    main_token_reftypes= new unsigned char[desired_count];
    main_token_max_count= desired_count;
  }
}

/* I'm now defining HAVE_PUSH_AND_POP for the debugger stub */
#define HAVE_PUSH_AND_POP 1
#ifdef HAVE_PUSH_AND_POP
/*
  Saving and restoring the main_token variables.
  This was conceived for a trick with subqueries that I didn't do,
  but $setup uses it now. The problem is that main_token_*
  variables are global (okay, bad early laziness, but refactoring
  now would be hard). So save them when you're about to parse
  something else e.g. a local subquery, and restore when the
  subquery is done. Optimistically I call this push + pop, but
  in fact can only save one level. Expect text to be saved elsewhere.
*/
void MainWindow::main_token_push()
{
#if (QT_VERSION >= 0x50c00) /* todo: actually it's the c++ version that should be checked not the Qt version */
  static_assert(sizeof(main_token_offsets[0]) == sizeof(int), "");
  static_assert(sizeof(main_token_lengths[0]) == sizeof(int), "");
  static_assert(sizeof(main_token_types[0]) == sizeof(int), "");
  static_assert(sizeof(main_token_flags[0]) == sizeof(unsigned int), "");
  static_assert(sizeof(main_token_pointers[0]) == sizeof(int), "");
  static_assert(sizeof(main_token_reftypes[0]) == sizeof(unsigned char), "");
#endif
  saved_main_token_count_in_all= main_token_count_in_all;
  saved_main_token_count_in_statement= main_token_count_in_statement;
  saved_main_token_number= main_token_number;
  saved_main_token_offsets= new int[saved_main_token_count_in_all];
  saved_main_token_lengths= new int[saved_main_token_count_in_all];
  saved_main_token_types= new int[saved_main_token_count_in_all];
  saved_main_token_flags= new unsigned int[saved_main_token_count_in_all];
  saved_main_token_pointers= new int[saved_main_token_count_in_all];
  saved_main_token_reftypes= new unsigned char[saved_main_token_count_in_all];
  memcpy(saved_main_token_offsets, main_token_offsets, saved_main_token_count_in_all * sizeof(int));
  memcpy(saved_main_token_lengths, main_token_lengths, saved_main_token_count_in_all * sizeof(int));
  memcpy(saved_main_token_types, main_token_types, saved_main_token_count_in_all * sizeof(int));
  memcpy(saved_main_token_flags, main_token_flags, saved_main_token_count_in_all * sizeof(unsigned int));
  memcpy(saved_main_token_pointers, main_token_pointers, saved_main_token_count_in_all * sizeof(int));
  memcpy(saved_main_token_reftypes, main_token_reftypes, saved_main_token_count_in_all * sizeof(unsigned char));
}

void MainWindow::main_token_pop()
{
  memcpy(main_token_offsets, saved_main_token_offsets, saved_main_token_count_in_all * sizeof(int));
  memcpy(main_token_lengths, saved_main_token_lengths, saved_main_token_count_in_all * sizeof(int));
  memcpy(main_token_types, saved_main_token_types, saved_main_token_count_in_all * sizeof(int));
  memcpy(main_token_flags, saved_main_token_flags, saved_main_token_count_in_all * sizeof(unsigned int));
  memcpy(main_token_pointers, saved_main_token_pointers, saved_main_token_count_in_all * sizeof(int));
  memcpy(main_token_reftypes, saved_main_token_reftypes, saved_main_token_count_in_all * sizeof(unsigned char));
  delete [] saved_main_token_reftypes;
  delete [] saved_main_token_pointers;
  delete [] saved_main_token_flags;
  delete [] saved_main_token_types;
  delete [] saved_main_token_lengths;
  delete [] saved_main_token_offsets;
  main_token_count_in_all= saved_main_token_count_in_all;
  main_token_count_in_statement= saved_main_token_count_in_statement;
  main_token_number= saved_main_token_number;
}
#endif


/*
  ACTIONS
  ! All action_ functions used to be in the "public slots:" of ocelotgui.h, but now some are called from :menu_spec_action_all
*/

/*
  action_settings_statement_edit_widget_text_changed() is a slot.
  Actually the connect() was for statement_edit_widget->document()'s
  contentsChange(), rather than statement_edit_widget's textChanged(),
  but I don't see any difference.
  This routine can cause the document to change, causing a signal
  and we get action_settings_statement_edit_widget_text_changed() again.
  It would be infinite. We have two ways to prevent the loop, and we
  use them both (yes it's redundant but this loop really worries me):
    exit if a global flag is on
    disconnect to ensure this slot won't be activated by signals that it itself generates.
  Todo: A hang occurs sometimes, and log() suggests it's in this routine.
        That's why there are so many log() and assert() invocations.
  Until May 2017 I used blockSignals(true)+blockSignals(false) instead
  of disconnect+connect; also I set statement_edit_widget_text_changed_flag= 1;
  within the routine; I hope these changes are safe.
*/
void MainWindow::action_settings_statement_edit_widget_text_changed(int position,int chars_removed,int chars_added)
{
  log("action_settings_statement_edit_widget_text_changed start", 90);
  if (statement_edit_widget_text_changed_flag != 0)
  {
    position_for_redo= position;
    chars_removed_for_redo= chars_removed;
    chars_added_for_redo= chars_added;
    return;
  }
  log("action_settings_statement_edit_widget_text_changed after flag check", 90);
  //statement_edit_widget_text_changed_flag= 1;
  //statement_edit_widget->document()->blockSignals(true);
  disconnect(statement_edit_widget->document(), SIGNAL(contentsChange(int,int,int)), this, SLOT(action_settings_statement_edit_widget_text_changed(int,int,int)));
  QString text;
  int i;
  int pos;

  /* Syntax highlighting */
  text= statement_edit_widget->toPlainText(); /* or I could just pass this to tokenize() directly */

#if (OCELOT_PLUGIN == 1)
  if (plugin_widget_list.size() > 0)
  {
    ocelot_plugin_pass.query= text.toUtf8().data();
    int return_code= plugin_widget_list_caller(PLUGIN_TEXT_CHANGED, "");
    if (return_code ==  PLUGIN_RETURN_OK_AND_REPLACED)
      text= QString::fromUtf8(ocelot_plugin_pass.replacer_buffer, ocelot_plugin_pass.replacer_buffer_length);
  }
#endif
  /* Todo: avoid total tokenize() + tokens_to_keywords() if user is just adding at end */
  main_token_new(text.size());
  tokenize(text.data(),
           text.size(),
           main_token_lengths, main_token_offsets, main_token_max_count,
           (QChar*)"33333", 1, ocelot_delimiter_str, 1);

  tokens_to_keywords(text, 0, sql_mode_ansi_quotes);
  if (((ocelot_statement_syntax_checker.toInt()) & FLAG_FOR_HIGHLIGHTS) != 0)
  {
    hparse_f_multi_block(text); /* recognizer */
  }
  log("action_settings_statement_edit_widget_text_changed after hparse_f_multi_block", 90);
  completer_widget->updater();
  /* This "sets" the colour, it does not "merge" it. */
  /* Do not try to set underlines, they won't go away. */
  QTextDocument *pDoc= statement_edit_widget->document();
  QTextCursor cur(pDoc);

  /* cur.select (QTextCursor::Document); */ /* desperate attempt to fix so undo/redo is not destroyed ... does not work */

  QTextCharFormat format_of_other;
  format_of_other.setForeground(QColor(qt_color(ocelot_statement_text_color)));
  pos= 0;
  /* cur.setPosition(pos, QTextCursor::KeepAnchor); */

  cur.joinPreviousEditBlock(); /* was cur.beginEditBlock() till 2017-07-23 */
  /* ought to affect undo/redo stack? */

  {
    /* This sets everything to normal format / no underline. Gets overridden by token formats. */
    QTextCharFormat format_of_white_space;
    cur.setPosition(0, QTextCursor::MoveAnchor);
    cur.setPosition(text.size(), QTextCursor::KeepAnchor);
    format_of_white_space= format_of_other;
    format_of_white_space.setUnderlineStyle(QTextCharFormat::NoUnderline);
    cur.setCharFormat(format_of_white_space);
  }

  log("action_settings_statement_edit_widget_text_changed loop start", 90);
  for (i= 0; main_token_lengths[i] != 0; ++i)
  {
    assert(main_token_lengths[i] > 0);
    assert(main_token_lengths[i] <= text.size());
    assert(main_token_offsets[i] >= 0);
    assert(main_token_offsets[i] <= text.size());
    assert(pos >= 0);
    assert(pos <= text.size());
    assert(i >= 0);
    assert(i <= (int) main_token_max_count);
    QTextCharFormat format_of_current_token;
    /* Todo: find out why this is necessary. It looks redundant but without it there's trouble. */
    for (; pos < main_token_offsets[i]; ++pos)
    {
      cur.setPosition(pos, QTextCursor::MoveAnchor);
      format_of_current_token= format_of_other;
      format_of_current_token.setUnderlineStyle(QTextCharFormat::NoUnderline);
      cur.setCharFormat(format_of_current_token);
      /* cur.clearSelection(); */
    }
    QString mid_next_token= "";
    if (main_token_lengths[i + 1] == 1) mid_next_token= text.mid(main_token_offsets[i + 1], 1);
    format_of_current_token= get_format_of_current_token(main_token_types[i], main_token_flags[i], mid_next_token);
    /* Todo: consider using SpellCheckUnderline instead of WaveUnderline. */
    if ((main_token_flags[i] & TOKEN_FLAG_IS_ERROR) != 0)
    {
      format_of_current_token.setUnderlineStyle(QTextCharFormat::WaveUnderline);
      format_of_current_token.setUnderlineColor(Qt::red);
    }
    else
    {
      //format_of_current_token.setUnderlineStyle(QTextCharFormat::NoUnderline);
    }

    cur.setPosition(pos, QTextCursor::MoveAnchor);
    cur.setPosition(pos + main_token_lengths[i], QTextCursor::KeepAnchor);
    cur.setCharFormat(format_of_current_token);
    pos+= main_token_lengths[i];
  }
  log("action_settings_statement_edit_widget_text_changed loop end", 90);
  cur.endEditBlock();

  /* Todo: consider what to do about trailing whitespace. */

  widget_sizer(); /* Perhaps adjust relative sizes of the main widgets. */
  log("action_settings_statement_edit_widget_text_changed after widget_sizer", 90);
  //statement_edit_widget->document()->blockSignals(false);
  connect(statement_edit_widget->document(), SIGNAL(contentsChange(int,int,int)), this, SLOT(action_settings_statement_edit_widget_text_changed(int,int,int)));
  //statement_edit_widget_text_changed_flag= 0;

  log("action_settings_statement_edit_widget_text_changed end", 90);
}


QTextCharFormat MainWindow::get_format_of_current_token(int token_type, int token_flags, QString mid_next_token)
{
  QTextCharFormat format_of_literal;
  format_of_literal.setForeground(QColor(qt_color(ocelot_statement_highlight_literal_color)));
  QTextCharFormat format_of_identifier;
  format_of_identifier.setForeground(QColor(qt_color(ocelot_statement_highlight_identifier_color)));
  QTextCharFormat format_of_comment;
  format_of_comment.setForeground(QColor(qt_color(ocelot_statement_highlight_comment_color)));
  QTextCharFormat format_of_operator;
  format_of_operator.setForeground(QColor(qt_color(ocelot_statement_highlight_operator_color)));
  QTextCharFormat format_of_reserved_word;
  format_of_reserved_word.setForeground(QColor(qt_color(ocelot_statement_highlight_keyword_color)));
  QTextCharFormat format_of_function;
  format_of_function.setForeground(QColor(qt_color(ocelot_statement_highlight_function_color)));
  QTextCharFormat format_of_other;
  format_of_other.setForeground(QColor(qt_color(ocelot_statement_text_color)));
  QTextCharFormat format_of_current_token;
  int t= token_type;
  if (t == TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE) format_of_current_token= format_of_literal;
  if (t == TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE) format_of_current_token= format_of_literal;
  if (t == TOKEN_TYPE_LITERAL_WITH_DIGIT) format_of_current_token= format_of_literal;
  /* literal_with_brace == literal */
  if (t == TOKEN_TYPE_LITERAL_WITH_BRACE) format_of_current_token= format_of_literal; /* obsolete? */
  if (t == TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK) format_of_current_token= format_of_identifier; /* same check as in hparse_f_is_identifier()? */
  if (t == TOKEN_TYPE_IDENTIFIER_WITH_DOUBLE_QUOTE) format_of_current_token= format_of_identifier;
  if (t == TOKEN_TYPE_IDENTIFIER) format_of_current_token= format_of_identifier;
  if (t == TOKEN_TYPE_IDENTIFIER_WITH_AT) format_of_current_token= format_of_identifier;
  if (t == TOKEN_TYPE_COMMENT_WITH_SLASH) format_of_current_token= format_of_comment;
  if (t == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE) format_of_current_token= format_of_comment;
  if (t == TOKEN_TYPE_COMMENT_WITH_MINUS) format_of_current_token= format_of_comment;
  if (t == TOKEN_TYPE_OPERATOR) format_of_current_token= format_of_operator;
  if (t >= TOKEN_KEYWORDS_START)
  {
    if (((token_flags & TOKEN_FLAG_IS_FUNCTION) != 0)
     && (mid_next_token == "("))
    {
      format_of_current_token= format_of_function;
    }
    else format_of_current_token= format_of_reserved_word;
  }
  if (t == TOKEN_TYPE_OTHER) format_of_current_token= format_of_other;

  return format_of_current_token;
}

/*
  For menu item "connect" we said connect(...SLOT(action_file_connect())));
  By default this is on and associated with File|Connect menu item.
  Actually connect will be attempted depending on defaults and command-line parameters.
*/
void MainWindow::action_file_connect(bool is_checked)
{
  (void)is_checked;
  action_file_connect_once(tr("File|Connect"));
}


/*
  If we're connecting, action_file_connect() calls action_file_connect_once with arg = "File|Connect".
  If we're printing for --help, print_help calls action_file_connect_once with arg = "Print".
  If we're printing for --print_defaults, print_defaults should do something similar.
  Todo:
  If user types OK and there's an error, repeat the dialog box with a new message e.g. "Connect failed ...".
  This is called from program-start!
  This should put "CONNECT" in the statement widget and cause its execution, so it shows up on the history widget.
*/

void MainWindow::action_file_connect_once(QString message)
{
  int column_count;
  QString *row_form_label;
  int *row_form_type;
  int *row_form_is_password;
  QString *row_form_data;
  QString *row_form_width;
  QString row_form_title;
  QString row_form_message;
  int i;
  Row_form_box *co;
  //row_form_label= 0; /* we don't use std::nothrow so we are assuming that 'new' will not fail */
  //row_form_type= 0;
  //row_form_is_password= 0;
  //row_form_data= 0;
  //row_form_width= 0;
  column_count= 85; /* If you add or remove items, you have to change this */
  row_form_label= new QString[column_count];
  row_form_type= new int[column_count];
  row_form_is_password= new int[column_count];
  row_form_data= new QString[column_count];
  row_form_width= new QString[column_count];
  row_form_label[i=0]= QString(strvalues[TOKEN_KEYWORD_HOST].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_host; row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PORT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.port); row_form_width[i]= '\x04';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_USER].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_user; row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DATABASE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_database; row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SOCKET].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_unix_socket; row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PASSWORD].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 1; row_form_data[i]= ocelot_password; row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PROTOCOL].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_protocol; row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_INIT_COMMAND].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_init_command; row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_ABORT_SOURCE_ON_ERROR].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.abort_source_on_error); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_AUTO_REHASH].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.auto_rehash); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_AUTO_VERTICAL_OUTPUT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.auto_vertical_output); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_BATCH].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.batch); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_BINARY_MODE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.binary_mode); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_BIND_ADDRESS].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_bind_address; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_CHARACTER_SETS_DIR].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_set_charset_dir; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_COLUMN_NAMES].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.result_grid_column_names); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_COLUMN_TYPE_INFO].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.column_type_info); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_COMMENTS].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.comments); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_COMPRESS].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.opt_compress); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_CONNECT_EXPIRED_PASSWORD].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.opt_can_handle_expired_passwords); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_CONNECT_TIMEOUT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.opt_connect_timeout); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEBUG].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_debug; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEBUG_CHECK].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.debug_check); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEBUG_INFO].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.debug_info); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEFAULT_AUTH].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_default_auth; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEFAULT_CHARACTER_SET].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_set_charset_name; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEFAULTS_EXTRA_FILE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_defaults_extra_file; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEFAULTS_FILE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_defaults_file; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DEFAULTS_GROUP_SUFFIX].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_defaults_group_suffix; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DELIMITER].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_delimiter_str; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_ENABLE_CLEARTEXT_PLUGIN].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.enable_cleartext_plugin); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_EXECUTE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_execute; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_FORCE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.force); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_HELP].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0;  row_form_data[i]= QString::number(ocelot_ca.help); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_HISTFILE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_history_hist_file_name; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_HISTIGNORE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_histignore; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_HTML].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.html); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_IGNORE_SPACES].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.ignore_spaces); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_LD_RUN_PATH].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_ld_run_path; row_form_width[i]= '\x05';
  if (is_libmysqlclient_loaded != 0) row_form_type[i]= (row_form_type[i] | READONLY_FLAG);
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_LINE_NUMBERS].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.line_numbers); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_LOCAL_INFILE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.opt_local_infile); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_LOGIN_PATH].chars).toLower();; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_login_path; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_MAX_ALLOWED_PACKET].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.max_allowed_packet); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_MAX_JOIN_SIZE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.max_join_size); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_NAMED_COMMANDS].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.named_commands); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_NET_BUFFER_LENGTH].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.net_buffer_length); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_NO_BEEP].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.no_beep); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_NO_DEFAULTS].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.no_defaults); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_OCELOT_DBMS].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_dbms; row_form_width[i]= '\x09';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_ONE_DATABASE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.one_database); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PAGER].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_pager; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PIPE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.pipe); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PLUGIN_DIR].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_plugin_dir; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PRINT_DEFAULTS].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.print_defaults); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PROMPT].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_prompt; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_QUICK].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.quick); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_RAW].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.raw); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_RECONNECT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.opt_reconnect); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SAFE_UPDATES].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.safe_updates); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SECURE_AUTH].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.secure_auth); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SELECT_LIMIT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.select_limit); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SERVER_PUBLIC_KEY].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_server_public_key; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SHARED_MEMORY_BASE_NAME].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_shared_memory_base_name; row_form_width[i]= '\x05';
  /* It used to crash if I said number(ocelot_ca.history_includes_warnings). Problem has disappeared. */
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SHOW_WARNINGS].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.history_includes_warnings); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SIGINT_IGNORE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.sigint_ignore); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SILENT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.silent); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_CA].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_ca; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_CAPATH].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_capath; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_CERT].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_cert; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_CIPHER].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_cipher; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_CRL].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_crl; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_CRLPATH].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_crlpath; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_KEY].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_key; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_MODE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_opt_ssl_mode; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SSL_VERIFY_SERVER_CERT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.opt_ssl_verify_server_cert); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_SYSLOG].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.syslog); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_TABLE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.table); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_TEE].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= ocelot_history_tee_file_name; row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_UNBUFFERED].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.unbuffered); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_VERBOSE].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.verbose); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_VERSION].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.version); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_VERTICAL].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.vertical); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_WAIT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.wait); row_form_width[i]= '\x05';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_XML].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(ocelot_ca.xml); row_form_width[i]= '\x05';
  assert(i == column_count - 1);
  if (message == "Print")
  {
    char output_string[5120];
    for (int j= 0; j < i; ++j)
    {
      strcpy(output_string, row_form_label[j].toUtf8());
      printf("%-34s", output_string);
      strcpy(output_string, row_form_data[j].toUtf8());
      printf("%s\n", output_string);
    }
  }
  else /* if (message == "File|Connect") */
  {

    row_form_title= menu_strings[menu_off + MENU_CONNECTION_DIALOG_BOX];
    row_form_message= message;

    co= new Row_form_box(column_count, row_form_label,
                                       row_form_type,
                                       row_form_is_password, row_form_data,
  //                                     row_form_width,
                                       row_form_title,
                                       menu_strings[menu_off + MENU_FILE_CONNECT_HEADING],
                                       this);
    co->exec();

    if (co->is_ok == 1)
    {
      ocelot_host= row_form_data[0].trimmed();
      ocelot_ca.port= to_long(row_form_data[1].trimmed());
      ocelot_user= row_form_data[2].trimmed();
      ocelot_database= row_form_data[3].trimmed();
      ocelot_unix_socket= row_form_data[4].trimmed();
      ocelot_password= row_form_data[5].trimmed();
      ocelot_protocol= row_form_data[6].trimmed(); ocelot_ca.protocol_as_int= get_ocelot_protocol_as_int(ocelot_protocol);
      ocelot_init_command= row_form_data[7].trimmed();
      ocelot_ca.abort_source_on_error= to_long(row_form_data[8].trimmed());
      ocelot_ca.auto_rehash= to_long(row_form_data[9].trimmed());

      i= 10;
      ocelot_ca.auto_vertical_output= to_long(row_form_data[i++].trimmed());
      ocelot_ca.batch= to_long(row_form_data[i++].trimmed());
      ocelot_ca.binary_mode= to_long(row_form_data[i++].trimmed());
      ocelot_bind_address= row_form_data[i++].trimmed();
      ocelot_set_charset_dir= row_form_data[i++].trimmed(); /* "character_sets_dir" */
      ocelot_ca.result_grid_column_names= to_long(row_form_data[i++].trimmed());
      ocelot_ca.column_type_info= to_long(row_form_data[i++].trimmed());
      ocelot_ca.comments= to_long(row_form_data[i++].trimmed());
      ocelot_ca.opt_compress= to_long(row_form_data[i++].trimmed());
      ocelot_ca.opt_can_handle_expired_passwords= to_long(row_form_data[i++].trimmed());
      ocelot_ca.opt_connect_timeout= to_long(row_form_data[i++].trimmed());
      ocelot_debug= row_form_data[i++].trimmed();
      ocelot_ca.debug_check= to_long(row_form_data[i++].trimmed());
      ocelot_ca.debug_info= to_long(row_form_data[i++].trimmed());
      ocelot_default_auth= row_form_data[i++].trimmed();
      ocelot_set_charset_name= row_form_data[i++].trimmed(); /* "default_character_set" */
      ocelot_defaults_extra_file= row_form_data[i++].trimmed();
      ocelot_defaults_file= row_form_data[i++].trimmed();
      ocelot_defaults_group_suffix= row_form_data[i++].trimmed();
      ocelot_delimiter_str= row_form_data[i++].trimmed();
      ocelot_ca.enable_cleartext_plugin= to_long(row_form_data[i++].trimmed());
      ocelot_execute= row_form_data[i++].trimmed();
      ocelot_ca.force= to_long(row_form_data[i++].trimmed());
      ocelot_ca.help= to_long(row_form_data[i++].trimmed());
      ocelot_history_hist_file_name= row_form_data[i++].trimmed();
      ocelot_histignore= row_form_data[i++].trimmed();
      ocelot_ca.html= to_long(row_form_data[i++].trimmed());
      ocelot_ca.ignore_spaces= to_long(row_form_data[i++].trimmed());
      ocelot_ld_run_path= row_form_data[i++].trimmed();
      ocelot_ca.line_numbers= to_long(row_form_data[i++].trimmed());
      ocelot_ca.opt_local_infile= to_long(row_form_data[i++].trimmed());
      ocelot_login_path= row_form_data[i++].trimmed();
      ocelot_ca.max_allowed_packet= to_long(row_form_data[i++].trimmed());
      ocelot_ca.max_join_size= to_long(row_form_data[i++].trimmed());
      ocelot_ca.named_commands= to_long(row_form_data[i++].trimmed());
      ocelot_ca.net_buffer_length= to_long(row_form_data[i++].trimmed());
      ocelot_ca.no_beep= to_long(row_form_data[i++].trimmed());
      ocelot_ca.no_defaults= to_long(row_form_data[i++].trimmed());
      connect_set_variable("ocelot_dbms", "=", row_form_data[i++].trimmed());
      ocelot_ca.one_database= to_long(row_form_data[i++].trimmed());
      ocelot_pager= row_form_data[i++].trimmed();
      ocelot_ca.pipe= to_long(row_form_data[i++].trimmed());
      ocelot_plugin_dir= row_form_data[i++].trimmed();
      ocelot_ca.print_defaults= to_long(row_form_data[i++].trimmed());
      ocelot_prompt= row_form_data[i++].trimmed();
      ocelot_ca.quick= to_long(row_form_data[i++].trimmed());
      ocelot_ca.raw= to_long(row_form_data[i++].trimmed());
      ocelot_ca.opt_reconnect= to_long(row_form_data[i++].trimmed());
      ocelot_ca.safe_updates= to_long(row_form_data[i++].trimmed());
      ocelot_ca.secure_auth= to_long(row_form_data[i++].trimmed());
      ocelot_ca.select_limit= to_long(row_form_data[i++].trimmed());
      ocelot_server_public_key= row_form_data[i++].trimmed();
      ocelot_shared_memory_base_name= row_form_data[i++].trimmed();
      ocelot_ca.history_includes_warnings= to_long(row_form_data[i++].trimmed());
      ocelot_ca.sigint_ignore= to_long(row_form_data[i++].trimmed());
      ocelot_ca.silent= to_long(row_form_data[i++].trimmed());
      ocelot_opt_ssl= row_form_data[i++].trimmed();
      ocelot_opt_ssl_ca= row_form_data[i++].trimmed();
      ocelot_opt_ssl_capath= row_form_data[i++].trimmed();
      ocelot_opt_ssl_cert= row_form_data[i++].trimmed();
      ocelot_opt_ssl_cipher= row_form_data[i++].trimmed();
      ocelot_opt_ssl_crl= row_form_data[i++].trimmed();
      ocelot_opt_ssl_crlpath= row_form_data[i++].trimmed();
      ocelot_opt_ssl_key= row_form_data[i++].trimmed();
      ocelot_opt_ssl_mode= row_form_data[i++].trimmed();
      ocelot_ca.opt_ssl_verify_server_cert= to_long(row_form_data[i++].trimmed());
      ocelot_ca.syslog= to_long(row_form_data[i++].trimmed());
      ocelot_ca.table= to_long(row_form_data[i++].trimmed());
      ocelot_history_tee_file_name= row_form_data[i++].trimmed();
      ocelot_ca.unbuffered= to_long(row_form_data[i++].trimmed());
      ocelot_ca.verbose= to_long(row_form_data[i++].trimmed());
      ocelot_ca.version= row_form_data[i++].trimmed().toInt();
      ocelot_ca.vertical= to_long(row_form_data[i++].trimmed());
      ocelot_ca.wait= to_long(row_form_data[i++].trimmed());
      ocelot_ca.xml= to_long(row_form_data[i++].trimmed());
      assert(i == column_count);
      /* This should ensure that a record goes to the history widget */
      /* Todo: clear statement_edit_widget first */
      statement_edit_widget->insertPlainText("CONNECT");
      action_execute(1);
      if (ocelot_init_command > "")
      {
        statement_edit_widget->insertPlainText(ocelot_init_command);
        action_execute(1);
      }
    }
    delete(co);
  }

  /* if (row_form_width != 0) */ delete [] row_form_width;
  /* if (row_form_data != 0) */ delete [] row_form_data;
  /* if (row_form_is_password != 0)  */ delete [] row_form_is_password;
  /* if (row_form_type != 0) */ delete [] row_form_type;
  /* if (row_form_label != 0) */ delete [] row_form_label;
}

/*
  For menu item "exit" we said connect(...SLOT(action_file_exit())));
  By default this is on and associated with File|Exit menu item.
  Stop the program.
  Re result_grid_tab_widget->close():
    MainWindow close will close children anyway but this forces a certain ordering.
    If result grid is not closed first, you can get a crash by selecting, then
    detaching, then setting focus to the result grid, then ^Q to exit.
    Todo: since this is a kludge not a fix, investigate more. Maybe valgrind would help.
*/
void MainWindow::action_file_exit(bool is_checked)
{
  (void)is_checked;
  QAction *qaction_debug_exit= menu_spec_find_action("action_debug_exit");
#if (OCELOT_PLUGIN == 1)
  if (plugin_widget_list.size() > 0)
  {
    ocelot_plugin_pass.subtype= MENU_FILE_EXIT;
    int return_code= plugin_widget_list_caller(PLUGIN_MENU_ACTION, "");
    if (return_code == PLUGIN_RETURN_SKIP) return;
  }
#endif
  log("action_file_exit start", 90);
  if (ocelot_dbms.contains("tarantool", Qt::CaseInsensitive))
  {
    /* Todo: if there was a successful connection, close it */
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
#ifdef DBMS_TARANTOOL
#if (OCELOT_THIRD_PARTY != 1)
    if (is_libtarantool_loaded == 1) { dlclose(libtarantool_handle); is_libtarantool_loaded= 0; }
    //if (is_libtarantoolnet_loaded == 1) { dlclose(libtarantoolnet_handle); is_libtarantoolnet_loaded= 0; }
#endif
#endif
#endif
  }
#if (OCELOT_MYSQL_INCLUDE == 1)
  else
  {
#if (OCELOT_MYSQL_DEBUGGER == 1)
    /* Get rid of debuggee if it's still around. */
    /* Todo: this might not be enough. Maybe you should be intercepting the "close window" event. */
    if ((qaction_debug_exit != NULL) && (qaction_debug_exit->isEnabled() == true)) action_debug_exit(false);
#endif
    /* Usually this closes main connection, kill connection or debug connection probably are = 0 */
    for (int i= 0; i < MYSQL_MAX_CONNECTIONS; ++i)
    {
      if (connected[i] != 0)
      {
        lmysql->ldbms_mysql_close(&mysql[i]);
        connected[i]= 0;
      }
    }
    if (is_mysql_library_init_done == true)
    {
      /*
        This assumes mysql_thread_end() was done for any debugger or kill threads,
        but we don't call mysql_thread_end() for the main thread (is that okay?).
        If we don't call mysql_library_end(), we'll get a few extra valgrind complaints.
      */
#if (MINGW_MARIADB == 0)
      lmysql->ldbms_mysql_library_end();
#endif
      is_mysql_library_init_done= false;
    }
    /* Some code added 2015-08-25 due to valgrind */
    if (lmysql != 0) { delete lmysql; lmysql= 0; }
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
    if (is_libmysqlclient_loaded == 1) { dlclose(libmysqlclient_handle); is_libmysqlclient_loaded= 0; }
    if (is_libcrypto_loaded == 1) { dlclose(libcrypto_handle); is_libcrypto_loaded= 0; }
#endif
  }
#endif //if (OCELOT_MYSQL_INCLUDE == 1)
  delete_utf8_copies();
  log("action_file_exit mid", 90);
  result_grid_tab_widget->close(); /* See the comment before the start of this function */
  close(); /* Assuming quitOnLastWindowClosed is applicable, the program should exit so log won't happen */
  log("action_file_exit end", 90);
}

#if (OCELOT_IMPORT_EXPORT == 1)

/*
  Especially for dialog boxes, there will be times that we want a list box of possibilities.
  I'd like to produce the list once and consistently.
  And I know that hparse can figure out what's possible.
  Example: I want to get a list of the export types.
           Pass SET ocelot_export = format
           Result: TEXT or TABLE or HTML or NONE (and maybe someday DEFAULT) will be in hparse_expected.
           Split that  into a QStringList with " or " as separator with QString::split().
           Warning: It's case sensitive so OR won't split, but " or " within a string or name will split.
  Todo: Figure out how dangerous this is and when it is possible to call it safely.
        In mitigation, notice that the plan is to call this when we're going to generate a new statement.
  Todo: Doubtless there will be more than one fake statement, so figure out how to decrease overhead.
  Todo: Watch for overflow, don't pass big fake statements, we're expecting main_token_ stuff is sufficient.
  Todo: Save completer_widget, or use it rather than hparse_expected, or make sure you don't call it.
  Todo: Once this is okay, row_form_box() should be able to take a combo box based on
        a fake statement that produces the choices for a list box,
        and the initial list box choice is the fake statement to produce the choices,
        and is_password is no longer a flag, there's either password-type or normal-text or combo box.
*/
QStringList MainWindow::fake_statement(QString fake_statement_text)
{
  log("fake_statement", 15);
  main_token_push();
  main_token_lengths[0]= 0;
  tokenize(fake_statement_text.data(),
           fake_statement_text.size(), /* todo: check: should this be fake_statement.text.data().size()? */
           &main_token_lengths[0], &main_token_offsets[0], 10,
          (QChar*)"33333", 1, ocelot_delimiter_str, 1);
  tokens_to_keywords(fake_statement_text, 0, sql_mode_ansi_quotes);
  main_token_number= 0;
  hparse_f_multi_block(fake_statement_text);
  QStringList string_list= hparse_expected.split(" or ");
  main_token_pop();
  return string_list;
}

/*
  Called from: action_file_export_text() action_file_export_table() action_file_export_html()
  For menu item "export ..." we said connect(...SLOT(action_file_export_...())));
  This is on (if there is a result set to export, and associated with File|Export submenu items.
  passed_type = TOKEN_KEYWORD_TEXT | TABLE | HTML | etc. i.e. the submenu choice
  Very similar to action_file_connect_once(QString message)
  Todo: Use menu_strings[menu_off + n] as we do in action_file_connect_once().
  When row_form_password[]==2, row_form_box() will call fake_statement to produce possibilities for a combo box.
  Warning: clicking the menu item causes it to be checked, which isn't what I want if dialog box result = cancel.
  Warning: we only pass TOKEN_KEYWORD_EXPORT, the plan for TOKEN_KEYWORD_IMPORT is rather long-term.
*/

int MainWindow::action_file_export_function(int export_or_import, int passed_type)
{
  (void)export_or_import;
  struct export_settings local_exports= {0,"","","",false,"","","",0,false,false,false,0,false,false,false,"","","",""};
  export_defaults(passed_type, &local_exports);

  QString message= "export";
  int column_count;
  QString row_form_title;
  QString row_form_message;
  int i;
  Row_form_box *co;
  int co_is_ok;
  if ((passed_type == TOKEN_KEYWORD_TEXT) || (passed_type == TOKEN_KEYWORD_TABLE))
    column_count= 19; /* If you add or remove items, you have to change this */
  else
    column_count= 4;
  QString *row_form_label= new QString[column_count];
  int *row_form_type= new int[column_count];
  int *row_form_is_password= new int[column_count];
  QString *row_form_data= new QString[column_count];
  QString *row_form_width= new QString[column_count];
  row_form_label[i=0]= "into"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= local_exports.file_name; row_form_width[i]= '\x04';
  if ((passed_type == TOKEN_KEYWORD_TEXT) || (passed_type == TOKEN_KEYWORD_TABLE))
  {
    row_form_label[++i]= "columns terminated by"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_file_export_function_value(local_exports.columns_terminated_by); row_form_width[i]= '\x04';
    row_form_label[++i]= "columns enclosed by"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_file_export_function_value(local_exports.columns_enclosed_by); row_form_width[i]= '\x04';
    row_form_label[++i]= "  (optionally)"; row_form_type[i]= 0; row_form_is_password[i]= 3; row_form_data[i]= bool_to_string(local_exports.columns_optionally); row_form_width[i]= '\x04';
    row_form_label[++i]= "columns escaped by"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_file_export_function_value(local_exports.columns_escaped_by); row_form_width[i]= '\x04';
    row_form_label[++i]= "lines starting by"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_file_export_function_value(local_exports.lines_starting_by); row_form_width[i]= '\x04';
    row_form_label[++i]= "lines terminated by"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_file_export_function_value(local_exports.lines_terminated_by); row_form_width[i]= '\x04';
  }
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_MAX_ROW_COUNT].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(local_exports.max_row_count); row_form_width[i]= '\x50';
  row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_COLUMN_NAMES].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 3; row_form_data[i]= bool_to_string(local_exports.column_names); row_form_width[i]= '\x50';
  if ((passed_type == TOKEN_KEYWORD_TEXT) || (passed_type == TOKEN_KEYWORD_TABLE))
  {
    row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_QUERY].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 3; row_form_data[i]= bool_to_string(local_exports.query); row_form_width[i]= '\x50';
    row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_ROW_COUNT].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 3; row_form_data[i]= bool_to_string(local_exports.row_count); row_form_width[i]= '\x50';
    row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_MARGIN].chars).toLower(); row_form_type[i]= NUM_FLAG; row_form_is_password[i]= 0; row_form_data[i]= QString::number(local_exports.margin); row_form_width[i]= '\x50';
    row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_PAD].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 3; row_form_data[i]= bool_to_string(local_exports.pad); row_form_width[i]= '\x50';
    row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_LAST].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 3; row_form_data[i]= bool_to_string(local_exports.last); row_form_width[i]= '\x50';
    row_form_label[++i]= QString(strvalues[TOKEN_KEYWORD_DIVIDER].chars).toLower(); row_form_type[i]= 0; row_form_is_password[i]= 3; row_form_data[i]= bool_to_string(local_exports.divider); row_form_width[i]= '\x50';
    row_form_label[++i]= "if null"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_file_export_function_value(local_exports.if_null); row_form_width[i]= '\x04';
    row_form_label[++i]= "replace"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_file_export_function_value(local_exports.replace_string); row_form_width[i]= '\x04';
    row_form_label[++i]= "  with"; row_form_type[i]= 0; row_form_is_password[i]= 0; row_form_data[i]= action_file_export_function_value(local_exports.with_string); row_form_width[i]= '\x04';
  }
  row_form_label[++i]= "if file exists"; row_form_type[i]= 0; row_form_is_password[i]= 4; row_form_data[i]= action_file_export_function_value(local_exports.if_file_exists); row_form_width[i]= '\x04';
  assert(i == column_count - 1);
  /* if (message == "File|Connect") */
  {
    row_form_title= "Export Dialog Box"; /* todo: there should be something in ostrings.h for this */
    row_form_message= message;

    co= new Row_form_box(column_count, row_form_label,
                                       row_form_type,
                                       row_form_is_password, row_form_data,
  //                                     row_form_width,
                                       row_form_title,
                                       "options (often the defaults are good so you can just press OK)",
                                       this);
    co->exec();
    co_is_ok= co->is_ok;
    if (co->is_ok == 1)
    {
      /* local_exports.type= TOKEN_KEYWORD_TEXT|TABLE|HTML|NONE */
      local_exports.type= passed_type;
      local_exports.file_name= row_form_data[i=0].trimmed();
      ++i;
      if ((passed_type == TOKEN_KEYWORD_TEXT) || (passed_type == TOKEN_KEYWORD_TABLE))
      {
        local_exports.columns_terminated_by= row_form_data[i++].trimmed().toUtf8();
        local_exports.columns_enclosed_by= row_form_data[i++].trimmed().toUtf8();
        local_exports.columns_optionally= string_to_bool(row_form_data[i++]); /* don't need to trim? */
        local_exports.columns_escaped_by= row_form_data[i++].trimmed().toUtf8();
        local_exports.lines_starting_by= row_form_data[i++].trimmed().toUtf8();
        local_exports.lines_terminated_by= row_form_data[i++].trimmed().toUtf8();
      }
      local_exports.max_row_count= to_long(row_form_data[i++].trimmed());
      local_exports.column_names= string_to_bool(row_form_data[i++]);
      if ((passed_type == TOKEN_KEYWORD_TEXT) || (passed_type == TOKEN_KEYWORD_TABLE))
      {
        local_exports.query= string_to_bool(row_form_data[i++]);
        local_exports.row_count= string_to_bool(row_form_data[i++]);
        local_exports.margin= row_form_data[i++].trimmed().toUtf8().toInt();
        local_exports.pad= string_to_bool(row_form_data[i++]);
        local_exports.last= string_to_bool(row_form_data[i++]);
        local_exports.divider= string_to_bool(row_form_data[i++]);
        local_exports.if_null= row_form_data[i++].trimmed().toUtf8();
        local_exports.replace_string= row_form_data[i++].trimmed().toUtf8();
        local_exports.with_string= row_form_data[i++].trimmed().toUtf8();
      }
      local_exports.if_file_exists= row_form_data[i++].trimmed().toUtf8();
      /* todo: maybe I should be appending with row_form_data[] and letting the statement be not fake */
      QString text;
      QString token;
      text= "SET ocelot_export = FORMAT ";
      main_token_count_in_statement= 4;
      if (local_exports.type == TOKEN_KEYWORD_TEXT) token= "'text' ";
      else if (local_exports.type == TOKEN_KEYWORD_TABLE) token= "'table' ";
      else if (local_exports.type == TOKEN_KEYWORD_HTML) token= "'html' ";
      text= text + token;
      ++main_token_count_in_statement;
      text= text + action_file_export_function_clause("INTO", local_exports.file_name);
      main_token_count_in_statement+= 2;
      if ((local_exports.type == TOKEN_KEYWORD_TEXT) || (local_exports.type == TOKEN_KEYWORD_TABLE))
      {
        /* e.g. X'09' tab for text or '|' for table */
        text= text + action_file_export_function_clause("\nCOLUMNS TERMINATED BY", local_exports.columns_terminated_by);
        /* e.g. '' for text or '' for table */
        if (local_exports.columns_optionally == true) text= text + " OPTIONALLY ";
        text= text + action_file_export_function_clause("ENCLOSED BY", local_exports.columns_enclosed_by);
        /* e.g. '\' for text or '' for table */
        text= text + action_file_export_function_clause("ESCAPED BY", local_exports.columns_escaped_by);
        /* e.g. '' for text or '|' for table */
        text= text + action_file_export_function_clause("LINES STARTING BY", local_exports.lines_starting_by);
        /* e.g. X'0A' line feed for text or X'0A' for table */
        text= text + action_file_export_function_clause("TERMINATED BY", local_exports.lines_terminated_by);
        main_token_count_in_statement+= 3 + 1 + 2 + 1 + 2 + 1 + 3 + 1 + 2 + 1;
      }
      text= text + action_file_export_function_clause_i("\nMAX_ROW_COUNT", local_exports.max_row_count);
      text= text + action_file_export_function_clause_b("COLUMN_NAMES", local_exports.column_names);
      main_token_count_in_statement+= 1 + 1 + 1 + 1;
      if ((local_exports.type == TOKEN_KEYWORD_TEXT) || (local_exports.type == TOKEN_KEYWORD_TABLE))
      {
        text= text + action_file_export_function_clause_b("QUERY", local_exports.query);
        text= text + action_file_export_function_clause_b("ROW_COUNT", local_exports.row_count);
        text= text + action_file_export_function_clause_i("MARGIN", local_exports.margin);
        text= text + action_file_export_function_clause_b("PAD", local_exports.pad);
        text= text + action_file_export_function_clause_b("LAST", local_exports.last);
        text= text + action_file_export_function_clause_b("DIVIDER", local_exports.divider);
        text= text + action_file_export_function_clause("\nIF NULL", local_exports.if_null);
        text= text + action_file_export_function_clause("\nREPLACE", local_exports.replace_string);
        text= text + action_file_export_function_clause("WITH", local_exports.with_string);
        main_token_count_in_statement+= 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 2 + 1 + 1;
      }
      text= text + action_file_export_function_clause("\nIF FILE EXISTS", local_exports.if_file_exists);
      main_token_count_in_statement+= 3 + 1;
      text= text + ";";
      ++main_token_count_in_statement;
      action_change_one_setting_execute(text);
      /* menu_file_export_..._action->setChecked(...) has happened if the execution succeeded */
    }
    else
    {
      /* user chose cancel, so the check mark should go back to the original place */
      export_set_checked();
    }
    delete(co);
  }

  delete [] row_form_width;
  delete [] row_form_data;
  delete [] row_form_is_password;
  delete [] row_form_type;
  delete [] row_form_label;
  return co_is_ok;
}

const char *MainWindow::bool_to_string(bool input)
{
  if (input == true) return "yes"; /* TEST!!! */
  else return "'no'";
}

bool MainWindow::string_to_bool(QString input)
{
  if (input == "yes") return true;
  else return false;
}


/*
  Called from: action_file_export_function(), for assigning values that might contain characters that don't display.
  Todo: there's a reverse of this somewhere, not what it is.
*/
QString MainWindow::action_file_export_function_value(QString input)
{
  QString token_for_value= "";
  QString c2;
  for (int i= 0; i < input.size(); ++i)
  {
    c2= input.mid(i, 1);
    if (c2 == "\x08") { token_for_value= token_for_value + "\\b"; continue; }
    if (c2 == "\x09") { token_for_value= token_for_value + "\\t"; continue; }
    if (c2 == "\x0a") { token_for_value= token_for_value + "\\n"; continue; }
    if (c2 == "\x0d") { token_for_value= token_for_value + "\\r"; continue; }
    /* nothing needed for \, I think */
    if (c2 == "\x20") { token_for_value= token_for_value + "\\s"; continue; }
    token_for_value= token_for_value + c2;
  }
  return token_for_value;
}

/*
  An export row_form_box string can be unquoted or hex-quoted, e.g. D or X'44'.
  If it's unquoted, change ' inside the string to '' and surround with ''s.
  If it's hex-quoted, don't change.
  Apparently it's already stripped.
  Todo: This doesn't have to be just for export, it could be good for all row_form_box strings.
*/
QString MainWindow::action_file_export_function_clause(QString keywords, QString literal)
{
  if ((literal.mid(1, 1) == "'") && (QString::compare(literal.mid(0, 1), "X", Qt::CaseInsensitive) == 0))
    return " " + keywords + " " + literal + " ";
  QString escaped_literal= "";
  for (int i= 0; i < literal.size(); ++i)
  {
    QString c= literal.mid(i, 1);
    //if (c == "\\") escaped_literal= escaped_literal + c;
    if (c == "'") escaped_literal= escaped_literal + c;
    escaped_literal= escaped_literal + c;
  }
  return " " + keywords + " '" + escaped_literal + "' ";
}

QString MainWindow::action_file_export_function_clause_i(QString keywords, int literal)
{
  return " " + keywords + " " + QString::number(literal) + " ";
}

QString MainWindow::action_file_export_function_clause_b(QString keywords, bool literal)
{
  QString r= "'yes'";
  if (literal == false) r= "'no'";
  return " " + keywords + " " + r + " ";
}


void MainWindow::action_file_export_text(bool is_checked)
{
  (void)is_checked;
  action_file_export_function(TOKEN_KEYWORD_EXPORT, TOKEN_KEYWORD_TEXT);
}

void MainWindow::action_file_export_table(bool is_checked)
{
  (void)is_checked;
  action_file_export_function(TOKEN_KEYWORD_EXPORT, TOKEN_KEYWORD_TABLE);
}

void MainWindow::action_file_export_html(bool is_checked)
{
  (void)is_checked;
  action_file_export_function(TOKEN_KEYWORD_EXPORT, TOKEN_KEYWORD_HTML);
}

void MainWindow::action_file_export_none(bool is_checked)
{
  (void)is_checked;
  main_token_count_in_statement= 5;
  action_change_one_setting_execute("SET OCELOT_EXPORT = NONE;");
}


#endif

/*
  detach
  For SET ocelot_statement_detached (etc.) = "yes|no"; perhaps caused by menu item = Options|detach statement widget
  Major changes for version 1.7 May+June 2022:
    Separate functions for each widget type were consolidated into one function, detach_widget().
    Method "hide + setGeometry + show" worked on only some distros, failed especially badly with Kaos.
    Possibly windows maximized flag was part of the problem, so showNormal() instead.
    Also the height was confusing because when a widget gets detached it increases by title bar size at least.
  Major changes for version 1.8 November 2022:
    Explorer.
  widget_type = TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED or TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED or TOKEN_KEYWORD_OCELOT_GRID_DETACHED or TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED
  TODO: Don't shrink so much that you lose something major in main window
        (maybe expand main window to include title bar size?)
        However, result isn't disastrous if main window is currently too small.
  Would "floating" be a better word than "detached"? or "undock"? or "detachable"?
  Todo: Change border, size, title, frame width, position. Perhaps in Settings dialog.
        Update: now Settings dialog does allow for change of size and position.
  Todo: Menu keys should be slotted to the new window as well as the main window. E.g. control-Q.
        Update: that's what the detach is for.
  Todo: How to bring to front / bring to back? Currently it's always in front of main widget.
  Todo: title bar of result grid widget could show part of query and number of rows.
  Todo: Maybe these should be detached by default, or always detached.
  Todo: Check: Do you lose the parent? If that happens, there will be memory leaks.
  Todo: Detached widgets optionally could have their own menus. Lots of work.
        * Similar to create_menu() with all addActions() work, but mostly
          we can (after separating actions and adding #defines) copy with
          QAction *actionb = menu_edit->actions().at(EDIT_MENU_UNDO);
        * In every routine that uses action_edit_menu_undo etc., pass
          QMenu object so you can use actions().at.
        Otherwise click on menu changes focus to undetached widget.
  Todo: stop using setText("literal"), put translatable messages in ostrings.h
  If top = 'default' then shrink main and put revised widget at bottom.
  If left|width|height = 'default' then we keep current values after detaching.
  Remember: x is left-right axis, y is top-bottom
  Todo: options|detach_history_widget is now useless and obsolete! SET is what matters!
        but we keep options in case we want to make a shortcut
  Todo: support other values: 'current', 'max', 'min', 'always on top', 'no buttons', '30%'
  Todo: (static) main must go back to original size if 'attach'
  Todo: I'm confused: include or exclude window frame? See http://doc.qt.io/qt-5/application-windows.html#window-geometry
  Todo: Equivalent of detach_start and detach_stop for grid widget + debug widget (+ statement widget?)
  Todo: We lose current focus when we detach. Save and restore it.
  Todo: indicate how many pixels each item takes currently, by adding to the combobox
  Todo: * ctrl + tab, ctrl + backtab ... don't work with detached, I tried for a while but gave up
  Todo: * a shortcut for bring to top and focus
  Todo: example.cnf: ocelot_{history|grid|debug_statement}_{detached|top|left|height|width} = n
  Todo: * In ostrings.h: add "attach ..."
  Todo: * Some shortcuts for attach|detach
  Todo: * check again re example.cnf and documentation
  Todo: Possible bug: Kaos only (?): check mark doesn't appear before the word "attach" on options menu
  Todo: bug: if we detach with command-line option, and prompt has time-of-day, time-of-day won't change
*/

/*
  Flags for setWindowFlags().
  Doesn't include Qt::WindowCloseButtonHint so there will be no close button.
  Doesn't include Qt::WindowStaysOnTopHint but in fact it will be on top of other widgets of app.
*/
#define DETACHED_WINDOW_FLAGS Qt::CustomizeWindowHint | Qt::WindowTitleHint | Qt::WindowMinMaxButtonsHint | Qt::WindowSystemMenuHint

void MainWindow::action_options_detach_history_widget(bool is_checked)
{
  if (is_checked)
  {
    ocelot_history_detached= "no";
    new_ocelot_history_detached= "yes";
  }
  else
  {
    ocelot_history_detached= "yes";
    new_ocelot_history_detached= "no";
  }
  action_change_one_setting(ocelot_history_detached, new_ocelot_history_detached, TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED);
}

void MainWindow::action_options_detach_grid_widget(bool is_checked)
{
  if (is_checked)
  {
    ocelot_grid_detached= "no";
    new_ocelot_grid_detached= "yes";
  }
  else
  {
    ocelot_grid_detached= "yes";
    new_ocelot_grid_detached= "no";
  }
  action_change_one_setting(ocelot_grid_detached, new_ocelot_grid_detached, TOKEN_KEYWORD_OCELOT_GRID_DETACHED);
}

#if (OCELOT_MYSQL_DEBUGGER == 1)
void MainWindow::action_options_detach_debug_widget(bool is_checked)
{
  if (is_checked)
  {
    ocelot_debug_detached= "no";
    new_ocelot_debug_detached= "yes";
  }
  else
  {
    ocelot_debug_detached= "yes";
    new_ocelot_debug_detached= "no";
  }
  action_change_one_setting(ocelot_debug_detached, new_ocelot_debug_detached, TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED);
}
#endif

void MainWindow::action_options_detach_statement_widget(bool is_checked)
{
  if (is_checked)
  {
    ocelot_statement_detached= "no";
    new_ocelot_statement_detached= "yes";
  }
  else
  {
    ocelot_statement_detached= "yes";
    new_ocelot_statement_detached= "no";
  }
  action_change_one_setting(ocelot_statement_detached, new_ocelot_statement_detached, TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED);
}

#if (OCELOT_EXPLORER == 1)
void MainWindow::action_options_detach_explorer_widget(bool is_checked)
{
  if (is_checked)
  {
    ocelot_explorer_detached= "no";
    new_ocelot_explorer_detached= "yes";
  }
  else
  {
    ocelot_explorer_detached= "yes";
    new_ocelot_explorer_detached= "no";
  }
  action_change_one_setting(ocelot_explorer_detached, new_ocelot_explorer_detached, TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED);
}
#endif

/*
  See comments preceding action_options_detach_history_widget().
*/
void MainWindow::detach_widget(int widget_type, bool checked)
{
  if (isVisible() == false) return; /* this can be false if main window hasn't appeared yet */
  static int shrink= 0; /* I forget why this is static, but it shouldn't matter. */
  QWidget *widget; /* = statement_edit_widget etc. */
  QString widget_left, widget_top, widget_width, widget_height; /* integer values or "default" */
  QAction *menu_options_action_options_detach_widget; /* e.g. *action_options_detach_statement_widget */
  int menu_options_detach_widget; /* e.g. MENU_OPTIONS_DETACH_STATEMENT_WIDGET */
  QString widget_text; /* e.g. "statement widget" */
  int x, y, w, h;
  if (widget_type == TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED)
  {
    widget= (QWidget*) statement_edit_widget;
    menu_options_action_options_detach_widget= menu_spec_find_action("action_options_detach_statement_widget");
    widget_text= "statement widget";
    menu_options_detach_widget= MENU_OPTIONS_DETACH_STATEMENT_WIDGET;
    widget_left= ocelot_statement_left; widget_top= ocelot_statement_top; widget_width= ocelot_statement_width; widget_height= ocelot_statement_height;
    ocelot_ca.detach_statement_edit_widget= checked;
  }
#if (OCELOT_MYSQL_DEBUGGER == 1)
  else if (widget_type == TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED)
  {
    widget= (QWidget*) debug_tab_widget;
    menu_options_action_options_detach_widget= menu_spec_find_action("action_options_detach_debug_widget");
    widget_text= "debug widget";
    menu_options_detach_widget= MENU_OPTIONS_DETACH_DEBUG_WIDGET;
    widget_left= ocelot_debug_left; widget_top= ocelot_debug_top; widget_width= ocelot_debug_width; widget_height= ocelot_debug_height;
    ocelot_ca.detach_statement_edit_widget= checked; /* Todo: should this be ocelot_ca.detach_debug_widget= checked? */
  }
#endif
#if (OCELOT_EXPLORER == 1)
  else if (widget_type == TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED)
  {
    widget= (QWidget*) explorer_widget;
    menu_options_action_options_detach_widget= menu_spec_find_action("action_options_detach_explorer_widget");
    widget_text= "explorer widget";
    menu_options_detach_widget= MENU_OPTIONS_DETACH_EXPLORER_WIDGET;
    widget_left= ocelot_explorer_left; widget_top= ocelot_explorer_top; widget_width= ocelot_explorer_width; widget_height= ocelot_explorer_height;
    ocelot_ca.detach_explorer_widget= checked;
  }
#endif
  else if (widget_type == TOKEN_KEYWORD_OCELOT_GRID_DETACHED)
  {
    widget= (QWidget*) result_grid_tab_widget;
    QAction *action_options_detach_grid_widget= menu_spec_find_action("action_options_detach_grid_widget");
    menu_options_action_options_detach_widget= action_options_detach_grid_widget;
    widget_text= "result grid widget";
    menu_options_detach_widget= MENU_OPTIONS_DETACH_RESULT_GRID_WIDGET;
    widget_left= ocelot_grid_left; widget_top= ocelot_grid_top; widget_width= ocelot_grid_width; widget_height= ocelot_grid_height;
    ocelot_ca.detach_result_grid_widget= checked;
  }
  else /* if (widget_type == TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED) */
  {
    widget= (QWidget*) history_edit_widget;
    menu_options_action_options_detach_widget= menu_spec_find_action("action_options_detach_history_widget");
    widget_text= "history widget";
    menu_options_detach_widget= MENU_OPTIONS_DETACH_HISTORY_WIDGET;
    widget_left= ocelot_history_left; widget_top= ocelot_history_top; widget_width= ocelot_history_width; widget_height= ocelot_history_height;
    ocelot_ca.detach_history_widget= checked;
  }
  if ( menu_options_action_options_detach_widget == NULL) return; /* perhaps it was deleted from the menu */
  QPoint widget_point= widget->mapToGlobal(QPoint(0, 0));
  QRect widget_rect= widget->rect();
  if (widget_left == "default") x= widget_point.x();
  else x= widget_left.toInt();
  if (widget_top == "default") y= widget_point.y();
  else y= widget_top.toInt();
  if (widget_width == "default") w= widget_rect.width();
  else w= widget_width.toInt();
  if (widget_height == "default") h= widget_rect.height();
  else h= widget_height.toInt();
  bool is_visible= widget->isVisible();
  QPoint main_point= mapToGlobal(QPoint(0, 0));
  QRect main_rect= rect();
  if (checked)
  {
    menu_options_action_options_detach_widget->setText("attach " + widget_text);
    widget->setWindowFlags(Qt::Window | DETACHED_WINDOW_FLAGS);
    widget->setWindowTitle(widget_text);
    if (widget_top == "default")
    {
      shrink= widget_rect.height();
      shrink+= QApplication::style()->pixelMetric(QStyle::PM_TitleBarHeight);
      int main_rect_height= main_rect.height() - shrink;
      showNormal();
      //hide();
      setGeometry(main_point.x(), main_point.y(), main_rect.width(), main_rect_height);
      //show();
      y= main_point.y() + main_rect_height + QApplication::style()->pixelMetric(QStyle::PM_TitleBarHeight);
    }
    else shrink= 0;
    if (is_visible)
    {
      //widget->hide();
      widget->setGeometry(x, y, w, h - QApplication::style()->pixelMetric(QStyle::PM_TitleBarHeight));
      if (widget_type == TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED) history_edit_widget->detach_start();
      //widget->show();
    }
  }
  else
  {
    if (shrink != 0)
    {
      int main_rect_height= main_rect.height() + shrink;
      setGeometry(main_point.x(), main_point.y(), main_rect.width(), main_rect_height);
      shrink= 0;
    }
    menu_options_action_options_detach_widget->setText(menu_strings[menu_off + menu_options_detach_widget]);
    widget->setWindowFlags(Qt::Widget);
    if (widget_type == TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED) history_edit_widget->detach_stop();
  }
  if (is_visible) widget->show();
}

/*
  Next/Prev focus widget. Qt hardcodes tab | Shift+Tab (backtab) see
  http://www.vikingsoft.eu/keyboard-navigation-and-the-event-system/
  but we want to allow putting tab in any editable window, that is,
  we hardcode autocomplete shortcut = tab but allow it to go in.
  I'm confused about whether the window manager e.g. KDE always will
  override (as it does for Alt+Tab), but I know that if I try
  SET ocelot_shortcut_autocomplete = 'Alt+Tab';
  I get an error message = Illegal value.
  Row_form_box uses setTabChangesFocus() but nothing else does.
  In result grid, maybe we could have Tab for "next cell" and
  shift+tab for "next window". and something else for "Next Tab".
  But, mainly: next/prev is done with a customizable shortcut
  associated with QKeySequence::NextChild / QKeySequence::PreviousChild
  focusNextPrevChild(true) focusNextPrevChild(false).
  See also "Navigating Between Window Panes" according to Microsoft
  https://msdn.microsoft.com/en-us/library/ms971323.aspx
  Todo: for detached windows:
    We can switch to a detached window with setActiveWindow (setFocus won't do,
    something to do with lack of parent). But we would have to keep track of
    whether we want from grid to statement (or tried to), and how to go to the
    first cell in a grid from history. It could be more complicated if
    there are more detached windows, and some might be hidden
    e.g. completer_widget.
    Trick: by comparing QApplication::focusWidget() you can see if focus changed.
    Trick: by seeing if focusNextPrevChild returned false you can see if focus changed.
    But how do you specify you are going to a grid from history?
    I tried going through children till there were no more children, that just crashed.
*/

void MainWindow::action_options_next_window(bool is_checked)
{
  (void)is_checked;
  focusNextPrevChild(true);
  return;
}

void MainWindow::action_options_previous_window(bool is_checked)
{
  (void)is_checked;
  focusNextPrevChild(false);
}

/*
  User chose Options|result_display_html|result_display_horizontal|result_display_vertical etc.
  So we change display type, and display again.
  If there is no current widget, the display type changes but there is nothing to re-display.
  Todo: if no change, do nothing
        i.e. compare new and old -- but we ought to be disabling the menu choices anyway
  Todo: show starting with row at current location, not at start
        i.e. change vertial scroll bar
  Todo: disable menu if no current display
  Todo: this isn't doing a permanent change, and maybe that's wrong
        (if you want permanent change, try SET ocelot_batch=1; etc.)
  Todo: there's some checking here to prevent a crash if no result set is on display,
        but I'm not at all sure that it's enough
*/
void MainWindow::action_options_change_result_display(QString next)
{
  int current_index= result_grid_tab_widget->currentIndex();
  if ((current_index >= 0)
   && (current_index <= (ocelot_ca.grid_actual_tabs - 1)))
  {
    ResultGrid *rg;
    rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(current_index));
    if ((rg != NULL) && (rg->isVisible()))
    {
      unsigned short int new_ocelot_bar= 0;
      unsigned short int new_ocelot_batch= 0;
      unsigned short int new_ocelot_html= 0;
      unsigned short int new_ocelot_line= 0;
      unsigned short int new_ocelot_pie= 0;
      unsigned short int new_ocelot_raw= 0;
      unsigned short int new_ocelot_vertical= 0;
      unsigned short int new_ocelot_xml= 0;
      //unsigned short int old_ocelot_batch= rg->copy_of_ocelot_batch;
      //unsigned short int old_ocelot_html= rg->copy_of_ocelot_html;
      //unsigned short int old_ocelot_raw= rg->copy_of_ocelot_raw;
      //unsigned short int old_ocelot_vertical= rg->copy_of_ocelot_vertical;
      //unsigned short int old_ocelot_xml= rg->copy_of_ocelot_xml;
      if (next == "bar") {new_ocelot_bar= 1; }
      if (next == "batch") {new_ocelot_batch= 1; }
      if (next == "horizontal") {;}
      if (next == "html") {new_ocelot_html= 1; }
      if (next == "htmlraw") {new_ocelot_html= 1; new_ocelot_raw= 1; }
      if (next == "line") {new_ocelot_line= 1; }
      if (next == "pie") {new_ocelot_pie= 1; }
      if (next == "raw") {new_ocelot_raw= 1; }
      if (next == "vertical") {new_ocelot_vertical= 1;  }
      if (next == "xml") {new_ocelot_xml= 1;  }
      rg->display(1,
                  new_ocelot_vertical,
                  new_ocelot_batch, new_ocelot_html,
                  new_ocelot_raw, new_ocelot_xml,
                  ocelot_ca.result_grid_column_names, new_ocelot_bar, new_ocelot_line, new_ocelot_pie);
    }
  }
}

void MainWindow::action_options_bar(bool is_checked)
{
  (void)is_checked;
#if (OCELOT_CHART_OR_QCHART == 1)
   action_change_one_setting("", "bar", TOKEN_KEYWORD_OCELOT_GRID_CHART);
//#else
//  action_options_change_result_display("bar");
#endif
}
void MainWindow::action_options_batch(bool is_checked)
{
  (void)is_checked;
  action_options_change_result_display("batch");
}
void MainWindow::action_options_horizontal(bool is_checked)
{
  (void)is_checked;
  action_options_change_result_display("horizontal");
}
void MainWindow::action_options_html(bool is_checked)
{
  (void)is_checked;
  action_options_change_result_display("html");
}
void MainWindow::action_options_htmlraw(bool is_checked)
{
  (void)is_checked;
  action_options_change_result_display("htmlraw");
}
void MainWindow::action_options_line(bool is_checked)
{
  (void)is_checked;
#if (OCELOT_CHART_OR_QCHART == 1)
  action_change_one_setting("", "line", TOKEN_KEYWORD_OCELOT_GRID_CHART);
//#else
//  action_options_change_result_display("line");
#endif
}
void MainWindow::action_options_none(bool is_checked)
{
  (void)is_checked;
#if (OCELOT_CHART_OR_QCHART == 1)
  action_change_one_setting(" ", "", TOKEN_KEYWORD_OCELOT_GRID_CHART);
//#else
//  action_options_change_result_display("");
#endif
}
void MainWindow::action_options_pie(bool is_checked)
{
  (void)is_checked;
#if (OCELOT_CHART_OR_QCHART == 1)
   action_change_one_setting("", "pie", TOKEN_KEYWORD_OCELOT_GRID_CHART);
//#else
//  action_options_change_result_display("pie");
#endif
}
void MainWindow::action_options_raw(bool is_checked)
{
  (void)is_checked;
  action_options_change_result_display("raw");
}
void MainWindow::action_options_vertical(bool is_checked)
{
  (void)is_checked;
  action_options_change_result_display("vertical");
}
void MainWindow::action_options_xml(bool is_checked)
{
  (void)is_checked;
  action_options_change_result_display("xml");
}


/*
  Called from action_help_about("ocelotgui_logo.png") and action_help_the_manual("README.htm").
  We might assume that the docs including .png or .jpg files are on application_dir_path
  -- applicationDirPath() ""Returns the directory that contains the application executable" --
  but at build time one can pass -DOCELOTGUI_DOCDIR=x, indeed this is what happens with
  an install via cmake+cpack because they want the docs on /usr/share/doc not /usr/bin.
  But maybe cmake said it would go to /usr/local/share/doc but in fact it went to /usr/share/doc.
  So if we fail once, we try again after stripping /local from the path.
  Todo: have more choice where to look for README.htm
        we could try: according to an option = "documentation" directory
                      ld_run_path, ocelot_login_path, ocelot_plugin_dir
                      some other path used by Qt or MySQL or Linux
                      (prefer the path that has everything)
   We used to look for README.md but Debian gzips that, it doesn't gzip README.htm.
*/
QString MainWindow::get_doc_path(QString file_name)
{
#ifdef OCELOTGUI_DOCDIR
  QString application_dir_path= OCELOTGUI_DOCDIR;
#else
  QString application_dir_path= QCoreApplication::applicationDirPath();
#endif
  QString readme_path= application_dir_path;
  readme_path.append("/");
  readme_path.append(file_name);
  QFile file(readme_path);
  if (file.open(QIODevice::ReadOnly | QIODevice::Text))
  {
    file.close();
    return application_dir_path;
  }
 #ifdef OCELOTGUI_DOCDIR
  int index_of_local= application_dir_path.indexOf("/local/");
  if (index_of_local != -1)
  {
    QString left_path= application_dir_path.left(index_of_local);
    QString right_path= application_dir_path.right(application_dir_path.length() - (index_of_local + strlen("/local")));
    application_dir_path= left_path + right_path;
    readme_path= application_dir_path;
    readme_path.append("/");
    readme_path.append(file_name);
    file.setFileName(readme_path);
    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
      file.close();
      return application_dir_path;
    }
  }
#endif
  return "";
}


void MainWindow::action_help_about(bool is_checked)
{
  (void)is_checked;
  QString the_text= "\
<img src=\"./ocelotgui_logo.png\" alt=\"ocelotgui_logo.png\">\
<b>ocelotgui -- Graphical User Interface</b><br>Copyright (c) 2024 by Peter Gulutzan.<br>\
This program is free software: you can redistribute it and/or modify \
it under the terms of the GNU General Public License as published by \
the Free Software Foundation, version 2 of the License,<br>\
<br>\
This program is distributed in the hope that it will be useful, \
but WITHOUT ANY WARRANTY; without even the implied warranty of \
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the \
GNU General Public License for more details.<br>\
<br>\
You should have received a copy of the GNU General Public License \
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.";

  the_text.append("<br><br>");
  the_text.append(get_version());
#if (OCELOT_MYSQL_INCLUDE == 1)
  if (is_mysql_library_init_done == true)
  {
    the_text.append("<br>using DBMS client library version ");
#if (MINGW_MARIADB == 0)
    the_text.append(lmysql->ldbms_mysql_get_client_info());
#else
     the_text.append("built_with_mingw_mariadb");
#endif
#ifdef OCELOT_OS_LINUX
#if (OCELOT_STATIC_LIBRARY==0)
    /* RDLD_DI_ORIGIN gives only library. RDLD_DI_LINKMAP gives all but needs #include <link.h>. */
    if (is_libmysqlclient_loaded == 1)
    {
       struct link_map *map;
       the_text.append("(");
       if (dlinfo(libmysqlclient_handle, RTLD_DI_LINKMAP, &map) != -1)
       {
         if (map != NULL) the_text.append(map->l_name);
       }
       the_text.append(")");
    }
#endif
#endif
  }
#endif //if (OCELOT_MYSQL_INCLUDE == 1)
  if (statement_edit_widget->dbms_version > "")
  {
    the_text.append("<br>using ");
    the_text.append(dbms_name()); /* "mysql" or "mariadb" or "tarantool" */
    the_text.append(" DBMS server version ");
    the_text.append(statement_edit_widget->dbms_version);
  }
#if (OCELOT_MYSQL_DEBUGGER == 1)
  the_text.append("<br>Some source code related to the debugger feature is ");
  the_text.append("<br>(c) Copyright 2012 Hewlett-Packard Development Company, L.P.");
#endif
#if (OCELOT_STATIC_LIBRARY == 1)
  the_text.append("<br>Static-linked to MariaDB Connector C library");
  the_text.append("<br>Copyright (C) 2000 MySQL AB & MySQL Finland AB & TCX DataKonsult AB");
  the_text.append("<br>Static-linked to Qt's GUI library");
  the_text.append("<br>Copyright 2008-2014 Digia Plc. All rights reserved.");
#endif
  QString application_dir_path= get_doc_path("ocelotgui_logo.png");
  if (application_dir_path != "")
  {
    QString img_path= "img src=\"";
    img_path.append(application_dir_path);
    img_path.append("/");
    the_text.replace("img src=\"", img_path);
  }

  the_text.append("<br> app path "); the_text.append(QCoreApplication::applicationDirPath());

  Message_box *message_box;
  message_box= new Message_box("Help|About", the_text, 500, "", er_strings[er_off + ER_OK], "", this);
  message_box->exec();
  delete message_box;
}


/*
  the_manual_widget will be shown when user clicks Help | The Manual.
  It does not inherit the fonts+colors settings of the main window (that's a message_box todo).
  It reads the manual from README.htm.
  It uses HTML.
  README.htm refers to img src="...png|jpg" files, we expect them on the same directory as README.htm.
   Todo: Help | X should find X in the manual and display only X.
*/
void MainWindow::action_help_the_manual(bool is_checked)
{
  (void)is_checked;
  QString the_text="\
  <BR><h1>ocelotgui</h1>  \
  <BR>  \
  <BR>Version 2.3.0, April 19 2024  \
  <BR>  \
  <BR>  \
  <BR>Copyright (c) 2024 by Peter Gulutzan. All rights reserved.  \
  <BR>  \
  <BR>This program is free software; you can redistribute it and/or modify  \
  <BR>it under the terms of the GNU General Public License as published by  \
  <BR>the Free Software Foundation; version 2 of the License.  \
  <BR>  \
  <BR>This program is distributed in the hope that it will be useful,  \
  <BR>but WITHOUT ANY WARRANTY; without even the implied warranty of  \
  <BR>MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the  \
  <BR>GNU General Public License for more details.  \
  <BR>  \
  <BR>You should have received a copy of the GNU General Public License  \
  <BR>along with this program; if not, write to the Free Software  \
  <BR>Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA  \
  <BR>  \
  <BR>  \
  <BR>For the most recent version of the manual, see \
  <BR>https://github.com/ocelot-inc/ocelotgui#user-manual \
    ";
  QString application_dir_path= get_doc_path("README.htm");
  if (application_dir_path != "")
  {
    QString readme_path= application_dir_path;
    readme_path.append("/");
    readme_path.append("README.htm");
    QFile file(readme_path);
    if (file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
      QString line;
      QTextStream in(&file);
      the_text= "";
      while(!in.atEnd())
      {
        line= in.readLine();
        the_text.append(line);
        the_text.append(" ");
      }
      file.close();
      QString img_path= "img src=\"";
      img_path.append(application_dir_path);
      img_path.append("/");
      the_text.replace("img src=\"", img_path);
    }
  }
  Message_box *message_box;
  /* Don't use width=960 if screen width is smaller, e.g. on a VGA screen. */
#if (QT_VERSION >= 0x50000)
  QScreen *screen= QGuiApplication::primaryScreen();
  int desktop_width= screen->availableGeometry().width();
#else
  QDesktopWidget desktop;
  int desktop_width= desktop.availableGeometry().width();
#endif
  if (desktop_width > (960 + 50)) message_box= new Message_box("Help|The Manual", the_text, 960, "", er_strings[er_off + ER_OK], "", this);
  else message_box= new Message_box("Help|The Manual", the_text, desktop_width - 50, "", er_strings[er_off + ER_OK], "", this);
  message_box->exec();
  delete message_box;
}

#if (OCELOT_MYSQL_INCLUDE == 1)
void MainWindow::action_help_libmysqlclient(bool is_checked)
{
  (void)is_checked;
  QString the_text= "<b>libmysqlclient</b><br>\
  Before ocelotgui can try to connect to a MySQL server, \
  it needs a shared library named libmysqlclient \
  (file name on Linux is 'libmysqlclient.so' and/or 'libmysqlclient.so.18'). \
  If a mysql client was installed, possibly due to install \
  of a package named 'libmysqlclient-dev' or something similar, \
  then this file exists ... somewhere. \
  ocelotgui searches for libmysqlclient.so in these directories:<br> \
  (1) as specified by environment variable LD_RUN_PATH<br> \
  (2) as specified by environment variable LD_LIBRARY_PATH<br> \
  (3) as specified during build in file ocelotgui.pro, \
  which are by default hard-coded as: /usr/local/lib \
  /usr/mysql/lib /usr/local/mysql/lib /usr/lib /usr/local/lib/mysql \
  /usr/lib/mysql /usr/local /usr/local/mysql /usr/local /usr, etc.<br> \
  If a message appears saying libmysqlclient cannot be found, \
  or if there is a suspicion that an obsolete copy of libmysqlclient \
  was found, a possible solution is:<br> \
  1. Find the right libmysqlclient.so with Linux 'find' or 'locate'. \
  Suppose it is /home/jeanmartin/libmysqlclient.so.<br> \
  2. Specify the library when starting ocelotgui, thus:<br> \
  LD_RUN_PATH=/home/jeanmartin ocelotgui<br> \
  ... ocelotgui will also look for libmariadbclient.so or \
  libmariadb.so in the same fashion but will look first for \
  libmysqlclient.so unless one starts with ocelot_dbms='mariadb'.";
  Message_box *message_box;
  message_box= new Message_box("Help|libmysqlclient", the_text, 500, "", er_strings[er_off + ER_OK], "", this);
  message_box->exec();
  delete message_box;
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

void MainWindow::action_help_settings(bool is_checked)
{
  (void)is_checked;
  QString the_text= "<b>settings</b><br>\
  For all widgets, the color and font are changeable.<br>\
          <br>\
  CHANGING COLORS<br>\
  For example, to change the statement background color to dark blue:<br>\
  * Click the menu item Settings<br>\
    then click Statement Widget<br>\
    then click the box on the right of the Statement Background Color line<br>\
    then click on the word 'DarkBlue' in the list of choices<br>\
    then click OK to confirm<br>\
  * Or, Start ocelotgui with a parameter:<br>\
    ocelotgui --ocelot_statement_background-color='DarkBlue'<br>\
  * Or, put a line permanently in an option file such as ~/.my.cnf<br>\
    [ocelot]<br>\
    ocelot_statement_background_color='DarkBlue'<br>\
  * Or, execute a statement<br>\
    SET ocelot_statement_background_color='DarkBlue';<br>\
  Color names may be any of the many names listed on this W3C chart: \
  http://www.w3.org/wiki/CSS/Properties/color/keywords \
  as well as additions from this unofficial X11 chart: \
  https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart. \
  Hexadecimal-RGB values for example '#0000FE' are allowed in parameters or statements. \
  <br>\
  <br>\
  CHANGING FONTS<br>\
  For example, to change the menu font to italic:<br>\
  * Click the menu item Settings<br>\
    then click Menu<br>\
    then click the Font box <br>\
    then scroll to and click on an italic choice<br>\
    then click OK to confirm<br>\
  * Or, Start ocelotgui with a parameter:<br>\
    ocelotgui --ocelot_menu_font_style='italic'<br>\
  * Or, put a line permanently in an option file such as ~/.my.cnf<br>\
    [ocelot]<br>\
    ocelot_menu_font_style='italic'<br>\
  * Or, execute a statement<br>\
    SET ocelot_menu_font_style = 'italic';<br>\
  Some font changes do not take effect until after the next statement \
  is executed. \
  Some extremely large font sizes will be accepted but \
  the results will be ugly.";
  Message_box *message_box;
  message_box= new Message_box("Help|libmysqlclient", the_text, 500, "", er_strings[er_off + ER_OK], "", this);
  message_box->exec();
  delete message_box;
}


/*
  Problem: to do syntax highlighting, one must have a slot
  action_settings_statement_edit_widget_text_changed() to intercept
  every change in action_settings_statement_edit_widget. But, when
  user chooses Undo, that interception happens again, which
  negates the effects of undo. Therefore, instead of getting
  slot() invoked directly, I get to action_undo() which temporarily
  disables use of action_settings_statement_edit_widget_changed().
  And of course the same considerations apply for redo().
  KLUDGE #1: In action_settings_statement_edit_widget_changed(), change
             cur.beginEditBlock() to cur.joinPreviousEditBlock()
             so the syntax-highlight will be merged with the
             content change.
  KLUDGE #2: If a change is done via key stroke, then the stack
             gets 2 items, one of which is junk (just moving the
             cursor to after the first word), and wow, I wish I
             knew why. If a change is done via cut-and-paste,
             there's only one item. So I have to look at what
             the change was, and discard the junk item if I find
             it with undo, or put it back on the stack if I find
             it with redo.
  KLUDGE #3: Usually redo() moves the cursor the end, and wow, I
             wish I knew why. So I calculate where it should be =
             position of the first character that differs, plus
             (chars added - chars removed) (if positive).
  Todo: consider: will there be a bug if syntax highlighting is disabled?
        (currently it seems that disabling doesn't work so I can't test)
  Todo: see what happens for other situations besides
        key stroke | cut | paste. E.g. we get rid of a
        statement at a time in multi-statement sendings.
  Todo: menu item enable|disable -- not simple, it will
        depend what has focus
*/
void MainWindow::action_undo()
{
  log("action_undo start", 90);
  statement_edit_widget_text_changed_flag= 1;
  QString text_before= statement_edit_widget->toPlainText();
  statement_edit_widget->undo();
  QString text_after= statement_edit_widget->toPlainText();
  if (text_before == text_after)
    statement_edit_widget->undo();
  statement_edit_widget_text_changed_flag= 0;
  log("action_undo end", 90);
}

void MainWindow::action_redo()
{
  log("action_redo start", 90);
  QTextCursor cur= statement_edit_widget->textCursor();
  QString text_before= statement_edit_widget->toPlainText();
  statement_edit_widget_text_changed_flag= 1;
  statement_edit_widget->redo();
  int final_pos_for_redo;
  QString text_after_1= statement_edit_widget->toPlainText();
  statement_edit_widget->redo();
  QString text_after_2= statement_edit_widget->toPlainText();
  if (text_after_2 != text_after_1)
    statement_edit_widget->undo();
  statement_edit_widget_text_changed_flag= 0;
  for (final_pos_for_redo= 0; final_pos_for_redo < text_before.length(); ++final_pos_for_redo)
  {
    if (text_before.mid(final_pos_for_redo,1) != text_after_1.mid(final_pos_for_redo,1))
      break;
  }
  if (chars_added_for_redo > chars_removed_for_redo)
    final_pos_for_redo+= (chars_added_for_redo - chars_removed_for_redo);
  if (final_pos_for_redo > text_after_1.length())
  {
    log("FINAL_POS_FOR_REDO WAS ADJUSTED", 90);
    final_pos_for_redo= text_after_1.length();
  }
  cur.setPosition(final_pos_for_redo);
  statement_edit_widget->setTextCursor(cur);
  log("action_redo end", 90);
}

/*
  When focusOut happens for one of the main widgets (the ones that have
  an event filter on them), we might be switching to the menu bar.
  (I wish I knew for sure, but if it's to something else, no harm done.)
  On the edit menu, some items should be enabled or disabled (gray).
  Inefficient, but these actions don't happen dozens of times per second.
  Incredibly, installeventfilter for menuBar + look for focusIn or
  focusOut on menuBar didn't work, so this will have to do.
  Objects with event filters are: ResultGrid, CodeEditor,
  QScrollBar, TextEditHistory, so they all cause a call to here,
  but we only care about CodeEditor and TextEditHistory. Also we
  call from TextEditWidget::focusOutEvent(), an override rather
  than an editfilter event.
  Warn: TextEditWidget::focusInEvent() is also an override rather than
        an editfilter event, because (I don't know why) otherwise we
        don't see when TextEditWidget get focus or loses focus.
        This is the only time when QEvent::focusIn matters. So usually
        menu_activations() for menu_activations(QEvent::focusIn)
        is a waste of time. Remember, though, that shortcuts often won't
        work if the menu item is disabled.
  Todo: Incredibly, availableRedoSteps() only works for CodeEditor i.e.
        statement_edit_widget. I wish I knew why, but rather than spend
        more hours, will just assume redo is otherwise always okay.
        Maybe someday look harder.
  Todo: Saving the object so you'd know to setFocus to it after being on
        the menu would be good, at the moment it isn't automatic if the
        widget is detached.
  Todo: Other edit menu items can be enabled|disabled:
        previous statement, next statement.
  Todo: if font_size already <= FONT_SIZE_MIN, disable zoomout.
        if font_size already >= FONT_SIZE_MAX, disable zoomout.
        (Get the widget's ->styleSheet() as you do elsewhere.)
  Todo: check if ExpectedWidget can be affected here
  Todo: we could have is_can_find for menu_edit_action_find but at the moment it's always enabled
*/
void MainWindow::menu_activations(QObject *focus_widget, QEvent::Type qe)
{
  bool is_can_undo= true, is_can_redo= true;
  bool is_can_copy= false, is_can_cut= false, is_can_paste= false;
  bool is_can_format= false, is_can_zoomin= false, is_can_zoomout= false;
  bool is_can_autocomplete= false;
  const char *class_name= focus_widget->metaObject()->className();
#if (OCELOT_FIND_WIDGET == 1)
  if (qe == QEvent::FocusOut)
  {
    last_focus_widget= focus_widget;
  }
#endif
  // Todo: This is odd. if (qe == QEvent::FocusIn) isn't checked
  if (strcmp(class_name, "CodeEditor") == 0)
  {
    CodeEditor *t= qobject_cast<CodeEditor*>(focus_widget);
    QTextDocument *doc= t->document();
    if (doc->availableUndoSteps() <= 0) is_can_undo= false;
    if (doc->availableRedoSteps() <= 0) is_can_redo= false;
    is_can_copy= is_can_cut= t->textCursor().hasSelection();
    is_can_paste= t->canPaste();
    is_can_format= is_can_zoomin= is_can_zoomout= !doc->isEmpty();
    is_can_autocomplete= !completer_widget->isHidden();
  }
  else if (strcmp(class_name, "TextEditHistory") == 0)
  {
    TextEditHistory *t= qobject_cast<TextEditHistory*>(focus_widget);
    QTextDocument *doc= t->document();
    if (doc->availableUndoSteps() <= 0) is_can_undo= false;
    is_can_copy= is_can_cut= t->textCursor().hasSelection();
    is_can_paste= t->canPaste();
    is_can_format= false;
    is_can_zoomin= is_can_zoomout= !doc->isEmpty();
  }
  else if (strcmp(class_name, "Result_qtextedit") == 0)
  {
    Result_qtextedit *t= qobject_cast<Result_qtextedit*>(focus_widget);
    QTextDocument *doc= t->document();
    if (doc->availableUndoSteps() <= 0) is_can_undo= false;
    if (doc->availableRedoSteps() <= 0) is_can_redo= false;
    is_can_copy= is_can_cut= t->textCursor().hasSelection();
    is_can_paste= t->canPaste();
    is_can_format= false;
    is_can_zoomin= is_can_zoomout= !doc->isEmpty();
  }
  else
  {
    return;
  }
  QAction *menu_edit_action_undo= menu_spec_find_action("action_edit_undo");
  if (menu_edit_action_undo != NULL) menu_edit_action_undo->setEnabled(is_can_undo);
  QAction *menu_edit_action_redo= menu_spec_find_action("action_edit_redo");
  if (menu_edit_action_redo != NULL) menu_edit_action_redo->setEnabled(is_can_redo);
  QAction *menu_edit_action_cut= menu_spec_find_action("action_edit_cut");
  if (menu_edit_action_cut != NULL) menu_edit_action_cut->setEnabled(is_can_cut);
  QAction *menu_edit_action_copy= menu_spec_find_action("action_edit_copy");
  if (menu_edit_action_copy != NULL) menu_edit_action_copy->setEnabled(is_can_copy);
  QAction *menu_edit_action_paste= menu_spec_find_action("action_edit_paste");
  if (menu_edit_action_paste != NULL) menu_edit_action_paste->setEnabled(is_can_paste);
  QAction *menu_edit_action_formatter= menu_spec_find_action("action_edit_format");
  if (menu_edit_action_formatter != NULL) menu_edit_action_formatter->setEnabled(is_can_format);
  QAction *menu_edit_action_zoomin= menu_spec_find_action("action_edit_zoomin");
  if (menu_edit_action_zoomin != NULL) menu_edit_action_zoomin->setEnabled(is_can_zoomin);
  QAction *menu_edit_action_zoomout= menu_spec_find_action("action_edit_zoomout");
  if (menu_edit_action_zoomout != NULL) menu_edit_action_zoomout->setEnabled(is_can_zoomout);
  QAction *menu_edit_action_autocomplete= menu_spec_find_action("action_edit_autocomplete");
  if (menu_edit_action_autocomplete != NULL) menu_edit_action_autocomplete->setEnabled(is_can_autocomplete);
}


/*
  Comments relevant to action_settings_statement(), action_settings_grid(), action_settings_history(), action_settings_menu() ...
  These let the user select the colors and font for some widgets.
  Qt documentation says: "QApplication maintains a system/theme font which serves as a default for all widgets."
  So I'll assume that the Main Window always has that font, but let user change widgets that are within it.
  It's best to use a fixed-width font for most widgets, but I won't force that.
  Todo: consider: Should we pass default = current font (what we changed to last time) rather than default = main window font?
  Todo: Looks like there's a small problem with the history_edit_widget -- it might scroll.
        Probably what we want is: if we're at the bottom before the font change, then move to the bottom after the change.
*/
/* Todo: before se->delete(), check if WA_DeleteOnClose is off, always, for sure. */
/* Todo: edit_widget_text_changed() etc. should only be done if one of the ocelot_statement_highlight variables changed */
/* Todo: edit_widget_text_changed() etc. should be preceded by "emit"? */
/* Todo: put setStyleSheet() in an "if": only redo if ocelot_statement_style_string changed. */
/* Todo: after doing a setStyleSheet() change, put in history as "SET @..." statements. */
/* Todo: make sure there's no need to call set_current_colors_and_font(); */
/*
   Todo: Get default color too.
   I can get colors too, based on
   color= widget.palette().color(QPalette::Window);            formerly known as QPalette::Background
   color= widget.palette().color(QPalette::WindowText);           formerly known as QPalette::Foreground
   but    color.name() gives the color as "#RRGGBB" -- but I want a name!
   But your problem is: it might be RGB originally. You'd have to accept RGB.
   Luckily setStyleSheet will accept it, e.g. statement_edit_widget->setStyleSheet("background:rgb(200,100,150);");
   See also http://www.w3.org/TR/SVG/types.html#ColorKeywords "recognized color keyword names".
*/

/* NB: ocelot_statement_detached should be set after setting top|left|width|height not before */
void MainWindow::action_settings_statement(bool is_checked)
{
  (void)is_checked;
  Settings *se= new Settings(STATEMENT_WIDGET, this);
  int result= se->exec();
  if (result == QDialog::Accepted)
  {
    //make_style_strings();
    //statement_edit_widget_setstylesheet();
    /* For each changed Settings item, produce and execute a settings-change statement. */
    action_change_one_setting(ocelot_statement_text_color, new_ocelot_statement_text_color,TOKEN_KEYWORD_OCELOT_STATEMENT_TEXT_COLOR);
    action_change_one_setting(ocelot_statement_background_color, new_ocelot_statement_background_color,TOKEN_KEYWORD_OCELOT_STATEMENT_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_statement_border_color, new_ocelot_statement_border_color,TOKEN_KEYWORD_OCELOT_STATEMENT_BORDER_COLOR);
    action_change_one_setting(ocelot_statement_font_family, new_ocelot_statement_font_family,TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_FAMILY);
    action_change_one_setting(ocelot_statement_font_size, new_ocelot_statement_font_size,TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_SIZE);
    action_change_one_setting(ocelot_statement_font_style, new_ocelot_statement_font_style,TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_STYLE);
    action_change_one_setting(ocelot_statement_font_weight, new_ocelot_statement_font_weight,TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_WEIGHT);
    action_change_one_setting(ocelot_statement_highlight_literal_color, new_ocelot_statement_highlight_literal_color,TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_LITERAL_COLOR);
    action_change_one_setting(ocelot_statement_highlight_identifier_color, new_ocelot_statement_highlight_identifier_color,TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_IDENTIFIER_COLOR);
    action_change_one_setting(ocelot_statement_highlight_comment_color, new_ocelot_statement_highlight_comment_color,TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_COMMENT_COLOR);
    action_change_one_setting(ocelot_statement_highlight_operator_color, new_ocelot_statement_highlight_operator_color,TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_OPERATOR_COLOR);
    action_change_one_setting(ocelot_statement_highlight_keyword_color, new_ocelot_statement_highlight_keyword_color,TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_KEYWORD_COLOR);
    action_change_one_setting(ocelot_statement_prompt_background_color, new_ocelot_statement_prompt_background_color,TOKEN_KEYWORD_OCELOT_STATEMENT_PROMPT_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_statement_highlight_current_line_color, new_ocelot_statement_highlight_current_line_color,TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR);
    action_change_one_setting(ocelot_statement_highlight_function_color, new_ocelot_statement_highlight_function_color,TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_FUNCTION_COLOR);
    action_change_one_setting(ocelot_statement_syntax_checker, new_ocelot_statement_syntax_checker,TOKEN_KEYWORD_OCELOT_STATEMENT_SYNTAX_CHECKER);

    /* Todo: consider: maybe you have to do a restore like this */
    //text= statement_edit_widget->toPlainText(); /* or I could just pass this to tokenize() directly */
    //tokenize(text.data(),
    //         text.size(),
    //         main_token_lengths, main_token_offsets, MAX_TOKENS, (QChar*)"33333", 1, ocelot_delimiter_str, 1);
    //tokens_to_keywords(text);
    /* statement_edit_widget->statement_edit_widget_left_bgcolor= QColor(ocelot_statement_prompt_background_color); */
    statement_edit_widget->statement_edit_widget_left_treatment1_textcolor= QColor(ocelot_statement_text_color);
    action_settings_statement_edit_widget_text_changed(0, 0, 0);            /* only for highlight? repaint so new highlighting will appear */
    /* Todo: Check: Do we need to change style settings for this stuff? */
    action_change_one_setting(ocelot_statement_height, new_ocelot_statement_height, TOKEN_KEYWORD_OCELOT_STATEMENT_HEIGHT);
    action_change_one_setting(ocelot_statement_left, new_ocelot_statement_left, TOKEN_KEYWORD_OCELOT_STATEMENT_LEFT);
    action_change_one_setting(ocelot_statement_top, new_ocelot_statement_top, TOKEN_KEYWORD_OCELOT_STATEMENT_TOP);
    action_change_one_setting(ocelot_statement_width, new_ocelot_statement_width, TOKEN_KEYWORD_OCELOT_STATEMENT_WIDTH);
    action_change_one_setting(ocelot_statement_detached, new_ocelot_statement_detached, TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED);
  }
  delete(se);
}

/*
  The setstylesheet here could take a long time if there are many child widgets being displayed.
*/
/* NB: ocelot_history_detached should be set after setting top|left|width|height not before */
void MainWindow::action_settings_grid(bool is_checked)
{
  (void)is_checked;
  Settings *se= new Settings(GRID_WIDGET, this);
  int result= se->exec();
  if (result == QDialog::Accepted)
  {
    //make_style_strings();                                                      /* I think this should be commented out */
    //result_grid_tab_widget[0]->set_all_style_sheets();
    /* For each changed Settings item, produce and execute a settings-change statement. */
    action_change_one_setting(ocelot_grid_text_color, new_ocelot_grid_text_color, TOKEN_KEYWORD_OCELOT_GRID_TEXT_COLOR);
    action_change_one_setting(ocelot_grid_focus_cell_background_color, new_ocelot_grid_focus_cell_background_color, TOKEN_KEYWORD_OCELOT_GRID_FOCUS_CELL_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_grid_background_color, new_ocelot_grid_background_color, TOKEN_KEYWORD_OCELOT_GRID_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_grid_header_background_color, new_ocelot_grid_header_background_color, TOKEN_KEYWORD_OCELOT_GRID_HEADER_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_grid_font_family, new_ocelot_grid_font_family, TOKEN_KEYWORD_OCELOT_GRID_FONT_FAMILY);
    action_change_one_setting(ocelot_grid_font_size, new_ocelot_grid_font_size, TOKEN_KEYWORD_OCELOT_GRID_FONT_SIZE);
    action_change_one_setting(ocelot_grid_font_style, new_ocelot_grid_font_style, TOKEN_KEYWORD_OCELOT_GRID_FONT_STYLE);
    action_change_one_setting(ocelot_grid_font_weight, new_ocelot_grid_font_weight, TOKEN_KEYWORD_OCELOT_GRID_FONT_WEIGHT);
    action_change_one_setting(ocelot_grid_cell_border_color, new_ocelot_grid_cell_border_color, TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_COLOR);
    action_change_one_setting(ocelot_grid_outer_color, new_ocelot_grid_outer_color, TOKEN_KEYWORD_OCELOT_GRID_OUTER_COLOR);
    action_change_one_setting(ocelot_grid_cell_height, new_ocelot_grid_cell_height, TOKEN_KEYWORD_OCELOT_GRID_CELL_HEIGHT);
    action_change_one_setting(ocelot_grid_cell_border_size, new_ocelot_grid_cell_border_size, TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_SIZE);
    action_change_one_setting(ocelot_grid_cell_width, new_ocelot_grid_cell_width, TOKEN_KEYWORD_OCELOT_GRID_CELL_WIDTH);
    /* Todo: check: do we need to change style sheet for this stuff? */
    action_change_one_setting(ocelot_grid_height, new_ocelot_grid_height, TOKEN_KEYWORD_OCELOT_GRID_HEIGHT);
    action_change_one_setting(ocelot_grid_left, new_ocelot_grid_left, TOKEN_KEYWORD_OCELOT_GRID_LEFT);
    action_change_one_setting(ocelot_grid_top, new_ocelot_grid_top, TOKEN_KEYWORD_OCELOT_GRID_TOP);
    action_change_one_setting(ocelot_grid_width, new_ocelot_grid_width, TOKEN_KEYWORD_OCELOT_GRID_WIDTH);
    action_change_one_setting(ocelot_grid_html_effects, new_ocelot_grid_html_effects, TOKEN_KEYWORD_OCELOT_GRID_HTML_EFFECTS);
    action_change_one_setting(ocelot_grid_detached, new_ocelot_grid_detached, TOKEN_KEYWORD_OCELOT_GRID_DETACHED);
  }
  delete(se);
}

#if (OCELOT_MYSQL_DEBUGGER == 1)
/* !!!!! FIX !!!!! */
void MainWindow::action_settings_debug(bool is_checked)
{
  (void)is_checked;
  Settings *se= new Settings(DEBUG_WIDGET, this);
  int result= se->exec();
  if (result == QDialog::Accepted)
  {
    /* Todo: check: do we need to change style sheet for this stuff? */
    action_change_one_setting(ocelot_debug_height, new_ocelot_debug_height, TOKEN_KEYWORD_OCELOT_DEBUG_HEIGHT);
    action_change_one_setting(ocelot_debug_left, new_ocelot_debug_left, TOKEN_KEYWORD_OCELOT_DEBUG_LEFT);
    action_change_one_setting(ocelot_debug_top, new_ocelot_debug_top, TOKEN_KEYWORD_OCELOT_DEBUG_TOP);
    action_change_one_setting(ocelot_debug_width, new_ocelot_debug_width, TOKEN_KEYWORD_OCELOT_DEBUG_WIDTH);
    action_change_one_setting(ocelot_debug_detached, new_ocelot_debug_detached, TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED);
 }
  delete(se);
}
#endif

#if (OCELOT_EXPLORER == 1)
/* !!!!! FIX !!!!! */
void MainWindow::action_settings_explorer(bool is_checked)
{
  (void)is_checked;
  Settings *se= new Settings(EXPLORER_WIDGET, this);
  int result= se->exec();
  if (result == QDialog::Accepted)
  {
    ocelot_explorer_sort= new_ocelot_explorer_sort;
    if (ocelot_explorer_query != new_ocelot_explorer_query)
    {
      /* Todo: if the query is invalid, QDialog::Accepted shouldn't matter, this should fail */
      if (explorer_query() == true) ocelot_explorer_query= new_ocelot_explorer_query;
    }
    action_change_one_setting(ocelot_explorer_text_color, new_ocelot_explorer_text_color, TOKEN_KEYWORD_OCELOT_EXPLORER_TEXT_COLOR);
    action_change_one_setting(ocelot_explorer_background_color, new_ocelot_explorer_background_color, TOKEN_KEYWORD_OCELOT_EXPLORER_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_explorer_font_family, new_ocelot_explorer_font_family, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_FAMILY);
    action_change_one_setting(ocelot_explorer_font_size, new_ocelot_explorer_font_size, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_SIZE);
    action_change_one_setting(ocelot_explorer_font_style, new_ocelot_explorer_font_style, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_STYLE);
    action_change_one_setting(ocelot_explorer_font_weight, new_ocelot_explorer_font_weight, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_WEIGHT);
    action_change_one_setting(ocelot_explorer_visible, new_ocelot_explorer_visible, TOKEN_KEYWORD_OCELOT_EXPLORER_VISIBLE);
    action_change_one_setting(ocelot_explorer_height, new_ocelot_explorer_height, TOKEN_KEYWORD_OCELOT_EXPLORER_HEIGHT);
    action_change_one_setting(ocelot_explorer_left, new_ocelot_explorer_left, TOKEN_KEYWORD_OCELOT_EXPLORER_LEFT);
    action_change_one_setting(ocelot_explorer_top, new_ocelot_explorer_top, TOKEN_KEYWORD_OCELOT_EXPLORER_TOP);
    action_change_one_setting(ocelot_explorer_width, new_ocelot_explorer_width, TOKEN_KEYWORD_OCELOT_EXPLORER_WIDTH);
    action_change_one_setting(ocelot_explorer_detached, new_ocelot_explorer_detached, TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED);
  }
  delete(se);
}
#endif

/*
  TODO: extra_rule_1 could affect statement | prompt | word, not just cell
  TODO: Action could be to invoke a Lua procedure, not just char/hex/image
  TODO: There are lots of things to add to Condition and to Display As
*/
void MainWindow::action_settings_extra_rule_1(bool is_checked)
{
  (void)is_checked;
  Settings *se= new Settings(EXTRA_RULE_1, this);
  int result= se->exec();
  if (result == QDialog::Accepted)
  {
    action_change_one_setting(ocelot_extra_rule_1_condition, new_ocelot_extra_rule_1_condition, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_CONDITION);
    action_change_one_setting(ocelot_extra_rule_1_text_color, new_ocelot_extra_rule_1_text_color, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_TEXT_COLOR);
    action_change_one_setting(ocelot_extra_rule_1_background_color, new_ocelot_extra_rule_1_background_color, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_extra_rule_1_display_as, new_ocelot_extra_rule_1_display_as, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_DISPLAY_AS);
 }
  delete(se);
}

/* NB: ocelot_history_detached should be set after setting top|left|width|height not before */
void MainWindow::action_settings_history(bool is_checked)
{
  (void)is_checked;
  Settings *se= new Settings(HISTORY_WIDGET, this);
  int result= se->exec();
  if (result == QDialog::Accepted)
  {
    //make_style_strings();
    //history_edit_widget->setStyleSheet(ocelot_history_style_string);
    action_change_one_setting(ocelot_history_text_color, new_ocelot_history_text_color, TOKEN_KEYWORD_OCELOT_HISTORY_TEXT_COLOR);
    action_change_one_setting(ocelot_history_background_color, new_ocelot_history_background_color, TOKEN_KEYWORD_OCELOT_HISTORY_BACKGROUND_COLOR);
    action_change_one_setting(ocelot_history_border_color, new_ocelot_history_border_color, TOKEN_KEYWORD_OCELOT_HISTORY_BORDER_COLOR);
    action_change_one_setting(ocelot_history_font_family, new_ocelot_history_font_family, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_FAMILY);
    action_change_one_setting(ocelot_history_font_size, new_ocelot_history_font_size, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_SIZE);
    action_change_one_setting(ocelot_history_font_style, new_ocelot_history_font_style, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_STYLE);
    action_change_one_setting(ocelot_history_font_weight, new_ocelot_history_font_weight, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_WEIGHT);
    action_change_one_setting(ocelot_history_height, new_ocelot_history_height, TOKEN_KEYWORD_OCELOT_HISTORY_HEIGHT);
    action_change_one_setting(ocelot_history_left, new_ocelot_history_left, TOKEN_KEYWORD_OCELOT_HISTORY_LEFT);
    action_change_one_setting(ocelot_history_max_row_count, new_ocelot_history_max_row_count, TOKEN_KEYWORD_OCELOT_HISTORY_MAX_ROW_COUNT);
    action_change_one_setting(ocelot_history_top, new_ocelot_history_top, TOKEN_KEYWORD_OCELOT_HISTORY_TOP);
    action_change_one_setting(ocelot_history_width, new_ocelot_history_width, TOKEN_KEYWORD_OCELOT_HISTORY_WIDTH);
    action_change_one_setting(ocelot_history_detached, new_ocelot_history_detached, TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED);
  }
  delete(se);
}

/* We used to change main_window but there's too much inheriting. Really, menu is what matters. */
void MainWindow::action_settings_menu(bool is_checked)
{
  (void)is_checked;
  Settings *se= new Settings(MAIN_WIDGET, this);
  int result= se->exec();
  if (result == QDialog::Accepted)
  {
    //make_style_strings();
    //main_window->setStyleSheet(ocelot_menu_style_string);
    //ui->menuBar->setStyleSheet(ocelot_menu_style_string);
      action_change_one_setting(ocelot_menu_text_color, new_ocelot_menu_text_color, TOKEN_KEYWORD_OCELOT_MENU_TEXT_COLOR);
      action_change_one_setting(ocelot_menu_background_color, new_ocelot_menu_background_color, TOKEN_KEYWORD_OCELOT_MENU_BACKGROUND_COLOR);
      action_change_one_setting(ocelot_menu_border_color, new_ocelot_menu_border_color, TOKEN_KEYWORD_OCELOT_MENU_BORDER_COLOR);
      action_change_one_setting(ocelot_menu_font_family, new_ocelot_menu_font_family, TOKEN_KEYWORD_OCELOT_MENU_FONT_FAMILY);
      action_change_one_setting(ocelot_menu_font_size, new_ocelot_menu_font_size, TOKEN_KEYWORD_OCELOT_MENU_FONT_SIZE);
      action_change_one_setting(ocelot_menu_font_style, new_ocelot_menu_font_style, TOKEN_KEYWORD_OCELOT_MENU_FONT_STYLE);
      action_change_one_setting(ocelot_menu_font_weight, new_ocelot_menu_font_weight, TOKEN_KEYWORD_OCELOT_MENU_FONT_WEIGHT);
  }
  delete(se);
}

/*
  If a Settings-menu use has caused a change:
  Produce a settings-change SQL statement, e.g.
  SET ocelot_statement_background_color = 'red'
  and execute it.
  If it's a color, it might be an RGB, in that case change to name first.
*/
void MainWindow::action_change_one_setting(QString old_setting,
                                           QString new_setting,
                                           int keyword_index)
{
  if (old_setting != new_setting)
  {
    QString text;
    {
      old_setting= new_setting;
      main_token_number= 0;
      text= "SET ";
      text.append(strvalues[keyword_index].chars);
      text.append(" = ");
      text.append("'");
      QString source= new_setting;
      if (xsettings_widget->ocelot_variable_is_color(keyword_index) == true)
        source= rgb_to_color(new_setting);
      for (int i= 0; i < source.length(); ++i)
      {
        QString c= source.mid(i, 1);
        text.append(c);
        if (c == "'") text.append(c);
      }
      text.append("';");
      main_token_count_in_statement= 5;
    }
    action_change_one_setting_execute(text);
  }
}

/*
  called from action_change_one_setting due to most menu items that require change
  called from action_file_export_function due to menu item that requires change for export (in that case it's fake)
*/
void MainWindow::action_change_one_setting_execute(QString text)
{
  log("action_change_one_setting_execute", 15);
  main_token_new(text.size());
  tokenize(text.data(),
           text.size(),
           main_token_lengths, main_token_offsets,
           main_token_max_count, (QChar*)"33333", 1,
           ocelot_delimiter_str, 1);
  tokens_to_keywords(text, 0, sql_mode_ansi_quotes);
  action_execute_one_statement(text);
  history_edit_widget->verticalScrollBar()->setValue(history_edit_widget->verticalScrollBar()->maximum());
}

/*
  Pass QString with rgb name '#RRGGBB'.
  Find that string in q_color_list.
  If it's not there: add it.
*/
QString MainWindow::q_color_list_name(QString rgb_name)
{
  for (int i= 1; i < q_color_list.size(); i+= 2)
  {
    if (QString::compare(rgb_name, q_color_list[i], Qt::CaseInsensitive) == 0) return rgb_name;
  }
  q_color_list.append(rgb_name);
  q_color_list.append(rgb_name);
  return rgb_name;
}

/*
  It's possible to say SET [ocelotgui color name] = rgb_name e.g. "#FFFFFF"
  or have rgb_name in an options file or get an RGB name with set_current_colors_and_fonts().
  We'd prefer to show as W3C names where possible, X11 names as second choice, if English.
  But where the color is not in the W3C or X11 lists, we'll add.
*/
void MainWindow::assign_names_for_colors()
{
  if (ocelot_statement_text_color.left(1) == "#") ocelot_statement_text_color= q_color_list_name(ocelot_statement_text_color);
  if (ocelot_statement_background_color.left(1) == "#") ocelot_statement_background_color= q_color_list_name(ocelot_statement_background_color);
  if (ocelot_statement_border_color.left(1) == "#") ocelot_statement_border_color= q_color_list_name(ocelot_statement_border_color);
  if (ocelot_statement_highlight_literal_color.left(1) == "#") ocelot_statement_highlight_literal_color= q_color_list_name(ocelot_statement_highlight_literal_color);
  if (ocelot_statement_highlight_identifier_color.left(1) == "#") ocelot_statement_highlight_identifier_color= q_color_list_name(ocelot_statement_highlight_identifier_color);
  if (ocelot_statement_highlight_comment_color.left(1) == "#") ocelot_statement_highlight_comment_color= q_color_list_name(ocelot_statement_highlight_comment_color);
  if (ocelot_statement_highlight_operator_color.left(1) == "#") ocelot_statement_highlight_operator_color= q_color_list_name(ocelot_statement_highlight_operator_color);
  if (ocelot_statement_highlight_keyword_color.left(1) == "#") ocelot_statement_highlight_keyword_color= q_color_list_name(ocelot_statement_highlight_keyword_color);
  if (ocelot_statement_prompt_background_color.left(1) == "#") ocelot_statement_prompt_background_color= q_color_list_name(ocelot_statement_prompt_background_color);
  if (ocelot_statement_highlight_current_line_color.left(1) == "#") ocelot_statement_highlight_current_line_color= q_color_list_name(ocelot_statement_highlight_current_line_color);
  if (ocelot_statement_highlight_function_color.left(1) == "#") ocelot_statement_highlight_function_color= q_color_list_name(ocelot_statement_highlight_function_color);
  if (ocelot_grid_text_color.left(1) == "#") ocelot_grid_text_color= q_color_list_name(ocelot_grid_text_color);
  if (ocelot_grid_focus_cell_background_color.left(1) == "#") ocelot_grid_focus_cell_background_color= q_color_list_name(ocelot_grid_focus_cell_background_color);
  if (ocelot_grid_background_color.left(1) == "#") ocelot_grid_background_color= q_color_list_name(ocelot_grid_background_color);
  if (ocelot_grid_header_background_color.left(1) == "#") ocelot_grid_header_background_color= q_color_list_name(ocelot_grid_header_background_color);
  if (ocelot_grid_cell_border_color.left(1) == "#") ocelot_grid_cell_border_color= q_color_list_name(ocelot_grid_cell_border_color);
  if (ocelot_grid_outer_color.left(1) == "#") ocelot_grid_outer_color= q_color_list_name(ocelot_grid_outer_color);
  if (ocelot_history_text_color.left(1) == "#") ocelot_history_text_color= q_color_list_name(ocelot_history_text_color);
  if (ocelot_history_background_color.left(1) == "#") ocelot_history_background_color= q_color_list_name(ocelot_history_background_color);
  if (ocelot_history_border_color.left(1) == "#") ocelot_history_border_color= q_color_list_name(ocelot_history_border_color);
  if (ocelot_menu_text_color.left(1) == "#") ocelot_menu_text_color= q_color_list_name(ocelot_menu_text_color);
  if (ocelot_menu_background_color.left(1) == "#") ocelot_menu_background_color= q_color_list_name(ocelot_menu_background_color);
  if (ocelot_menu_border_color.left(1) == "#") ocelot_menu_border_color= q_color_list_name(ocelot_menu_border_color);
  if (ocelot_extra_rule_1_text_color.left(1) == "#") ocelot_extra_rule_1_text_color= q_color_list_name(ocelot_extra_rule_1_text_color);
  if (ocelot_extra_rule_1_background_color.left(1) == "#") ocelot_extra_rule_1_background_color= q_color_list_name(ocelot_extra_rule_1_background_color);
#if (OCELOT_EXPLORER == 1)
  if (ocelot_explorer_text_color.left(1) == "#") ocelot_explorer_text_color= q_color_list_name(ocelot_explorer_text_color);
  if (ocelot_explorer_background_color.left(1) == "#") ocelot_explorer_background_color= q_color_list_name(ocelot_explorer_background_color);
#endif
}


/*
  Todo: something has to be figured out about border width and border colors.
  I think, uncertainly, that the default border width is 0 and the color is Palette:shadow i.e. black.
  Possibly I could get the original value from QWidget::styleSheet() is some startup parameter changed it?
  Possibly I'd need to get a QFrame with a lineWidth() and frameWidth()?
  Possibly I should just assume that border width = 0px except for main window, and
  take out any mention of border in the Settings dialogs.
*/
void MainWindow::set_current_colors_and_font(QFont fixed_font)
{
  QFont font;

  QWidget *widget= new QWidget(); /* A dummy to which Qt will assign default settings for palette() etc. */
  ocelot_statement_text_color= statement_edit_widget->palette().color(QPalette::WindowText).name(); /* = QPalette::Foreground */
  ocelot_statement_background_color= statement_edit_widget->palette().color(QPalette::Window).name(); /* = QPalette::Background */
  font= statement_edit_widget->font();
  ocelot_statement_font_family= font.family();
  ocelot_statement_font_style= get_font_style_as_string(font);
  ocelot_statement_font_size= QString::number(font.pointSize()); /* Warning: this returns -1 if size was specified in pixels */
  ocelot_statement_font_weight= canonical_font_weight(QString::number(font.weight()));

  ocelot_grid_text_color= widget->palette().color(QPalette::WindowText).name(); /* = QPalette::Foreground */
  ocelot_grid_background_color= widget->palette().color(QPalette::Window).name(); /* = QPalette::Background */
  font= fixed_font;
  ocelot_grid_font_family= font.family();
  ocelot_grid_font_style= get_font_style_as_string(font);
  ocelot_grid_font_size= QString::number(font.pointSize()); /* Warning: this returns -1 if size was specified in pixels */
  ocelot_grid_font_weight= canonical_font_weight(QString::number(font.weight()));

  ocelot_history_text_color= history_edit_widget->palette().color(QPalette::WindowText).name(); /* = QPalette::Foreground */
  ocelot_history_background_color=history_edit_widget->palette().color(QPalette::Window).name(); /* = QPalette::Background */
  font= history_edit_widget->font();
  ocelot_history_font_family= font.family();
  ocelot_history_font_style= get_font_style_as_string(font);
  ocelot_history_font_size= QString::number(font.pointSize()); /* Warning: this returns -1 if size was specified in pixels */
  ocelot_history_font_weight= canonical_font_weight(QString::number(font.weight()));

  ocelot_menu_text_color= ui->menuBar->palette().color(QPalette::WindowText).name(); /* = QPalette::Foreground */
  ocelot_menu_background_color= ui->menuBar->palette().color(QPalette::Window).name(); /* = QPalette::Background */
  font= ui->menuBar->font();
  ocelot_menu_font_family= font.family();
  ocelot_menu_font_style= get_font_style_as_string(font);
  ocelot_menu_font_size= QString::number(font.pointSize()); /* Warning: this returns -1 if size was specified in pixels */
  ocelot_menu_font_weight= canonical_font_weight(QString::number(font.weight()));

  ocelot_extra_rule_1_text_color= widget->palette().color(QPalette::WindowText).name(); /* = QPalette::Foreground */
  ocelot_extra_rule_1_background_color= widget->palette().color(QPalette::Window).name(); /* = QPalette::Background */
  ocelot_extra_rule_1_condition= "data_type LIKE '%BLOB'";
  ocelot_extra_rule_1_display_as= "char";

#if (OCELOT_EXPLORER == 1)
  ocelot_explorer_text_color= ui->menuBar->palette().color(QPalette::WindowText).name(); /* = QPalette::Foreground */
  ocelot_explorer_background_color= ui->menuBar->palette().color(QPalette::Window).name(); /* = QPalette::Background */
  font= fixed_font;
  ocelot_explorer_font_family= font.family();
  ocelot_explorer_font_style= get_font_style_as_string(font);
  ocelot_explorer_font_size= QString::number(font.pointSize()); /* Warning: this returns -1 if size was specified in pixels */
  ocelot_explorer_font_weight= canonical_font_weight(QString::number(font.weight()));
#endif

  delete widget;
}

QString MainWindow::get_font_style_as_string(QFont font)
{
  if (font.style() == QFont::StyleNormal) return "normal";
  if (font.style() == QFont::StyleItalic) return "italic";
  return "oblique";
}

/*
  Call this for the initial default font, which we want as fixed pitch.
  It can be overridden by command-line options, SET statements, etc.
  Usually by default Qt will make a widget with a non-fixed font,
  this might be controlled by qtconfig-qt4 if Qt4,
  this might be controlled by (say) Gnome|KDE settings if Qt5.
  Do not use
    #if QT_VERSION >= 0x50200
    QFontDatabase::systemFont(QFontDatabase::FixedFont)
    #endif
    because Qt5 distribution is for "Qt5", not "Qt5.2+",
    but we can find the default by making a dummy with "NoSuchFont".
  If default is fixed: good, return it.
  Else search QFontDatabase for the font with the most points
  Else return the default.
  Points:
    If (first word match) +3 e.g. if default="Ubuntu" "Ubuntu Mono" wins
    If (dummy default match) +2 e.g. "DejaVu Sans Mono" often wins
    If (exact size match) +1
    If (close size match) +1
    If (weight match) +1
    If (italic match) +1
    If not ("*Webdings*" or "*Wingdings*" or "*Dingbats* or "*emoji" or "*orya*") +2
    ... But first part of the calculation differs in Windows because we got "MS Gothic" (yuck).
        Instead it is: If (Consolas | Lucida Console | Courier New) +3
  After you get it, it should determine the initial style sheets.
  Windows generates warnings if I don't exclude some fonts,
  but I suppress some of the warnings.
  Todo: consider changing QApplication font rather than individual fonts.
  Todo: there's a memory leak, though unimportant (we only call once)
  Todo: maybe consider italic == oblique and vice versa
*/
QFont MainWindow::get_fixed_font()
{
  QWidget *w1= new QWidget();
  QFont f1= w1->font();
  QFontInfo fi(f1);
  if (fi.fixedPitch()) return f1;
  int point_size= fi.pointSize();
  int weight= fi.weight();
  QFont::Style font_style= fi.style();
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
  QString first_word= fi.family();
  if (first_word.indexOf(" ") != -1)
    first_word= first_word.left(first_word.indexOf(" "));
  first_word= first_word.toUpper();
  int first_word_length= first_word.length();
#endif
  QFontDatabase database;
  QPlainTextEdit plain;
  QFont fo3("NoSuchFont", point_size, weight);
  fo3.setStyle(font_style);
  fo3.setStyleHint(QFont::TypeWriter);
  plain.setFont(fo3);
  QString recommended_family= plain.fontInfo().family();
  QString winner_font_family= "";
  int winner_font_point_size= 0;
  int winner_font_weight= 0;
  QFont::Style winner_font_font_style= QFont::StyleNormal;
  int winner_font_points= 0;
  foreach (const QString &family, database.families())
  {
#ifdef OCELOT_OS_NONLINUX
    {
      QString f= family.toUpper();
      if ((family == "FIXEDSYS") || (family == "MODERN")
       || (family == "SANS SERIF") || (family == "MS SERIF")
       || (family == "ROMAN") || (family == "SCRIPT")
       || (family == "SMALL FONTS") || (family == "SYSTEM")
       || (family == "TERMINAL"))
         continue;
    }
#endif
    int this_points= 0;
    QFont fo1= QFont(family, point_size, weight);
    fo1.setStyle(font_style);
    fo1.setStyleHint(QFont::TypeWriter);
    plain.setFont(fo1);
    if ((plain.fontInfo().fixedPitch())
     && (plain.fontInfo().pointSize() > 5))
    {
      if ((plain.fontInfo().family().toUpper().contains("WINGDING"))
       || (plain.fontInfo().family().toUpper().contains("WEBDING"))
       || (plain.fontInfo().family().toUpper().contains("EMOJI"))
       || (plain.fontInfo().family().toUpper().contains("ORYA"))
       || (plain.fontInfo().family().toUpper().contains("DINGBAT")))
       ;
      else this_points+= 2;
      if (plain.fontInfo().family() == recommended_family)
        this_points+= 2;
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
      if (plain.fontInfo().family().left(first_word_length).toUpper() == first_word)
        this_points+= 3;
#else
      QString f= plain.fontInfo().family();
      f= f.toUpper();
      if ((f == "CONSOLAS") || (f == "COURIER NEW") || (f == "LUCIDA CONSOLE"))
        this_points+= 3;
#endif
      if (plain.fontInfo().pointSize() == point_size)
        this_points+= 1;
      if ((plain.fontInfo().pointSize() >= (point_size * 0.9))
       && (plain.fontInfo().pointSize() <= (point_size * 1.2)))
        this_points+= 1;
      if (plain.fontInfo().weight() == weight)
        this_points+= 1;
      if (plain.fontInfo().style() == font_style)
        this_points+= 1;
      if (this_points > winner_font_points)
      {
        winner_font_family= plain.fontInfo().family();
        winner_font_point_size= plain.fontInfo().pointSize();
        winner_font_weight= plain.fontInfo().weight();
        winner_font_font_style= plain.fontInfo().style();
        winner_font_points= this_points;
      }
    }
  }
  if (winner_font_points == 0) return f1;
  QFont winner_font= QFont(winner_font_family,
                           winner_font_point_size,
                           winner_font_weight);
  winner_font.setStyle(winner_font_font_style);
  return winner_font;
}

/*
  Given RGB, return color name for current language
  If current language is not English, this may not be the
  canonical color name.
  It might be a bug if we don't find the rgb in s_color_list,
  but there a few extra RGBs in q_color_list.
  Todo: I think there's redundancy somewhere, that is,
        some other procedure does the same thing.
*/
/*
  Test: change q_i = 0 to q_i= color_off
        change q_i + color_off to q_i
*/
QString MainWindow::rgb_to_color(QString rgb)
{
  char rgb_as_utf8[128]; /* actually max rgb len = 7, allow for error */
  strcpy(rgb_as_utf8, rgb.toUpper().toUtf8());
  for (int q_i= color_off; strcmp(s_color_list[q_i]," ") > 0; q_i+= 2)
  {
    if (strcmp(s_color_list[q_i + 1], rgb_as_utf8) == 0)
    {
      QString color_name= s_color_list[q_i];
      return color_name;
    }
  }
  return rgb;
}


/*
  Pass: a string which is supposed to have a color name.
  Return: a canonical color name, i.e. an RGB value.
  1. Check color_list (names). If match, return RGB. Might be a case change e.g. Gray not gray.
  2. Accept some color name variants, e.g. Gray not grey, return RGB.
     They appear in http://www.w3.org/TR/SVG/types.html#ColorKeywords.
  3. Put the color in a QColor. If result is invalid, return "" which means invalid.
  4. Get the color back as #RRGGBB
  5. Return the #RRGGBB color.
  This does not mean that absolutely no synonyms are allowed
  -- two names may have the same #RRGGBB, as with Fuchsia|Magenta.
*/
QString MainWindow::canonical_color_name(QString color_name_string)
{
  QString s;
  QString co;

  co= color_name_string;

  if (co.left(1) != "#")
  {
    /*
      Todo: This appears to work for setting colors that contain ''
      but what if I SET ... = "...''..." elsewhere?
      Also: I think co.replace() does the job, I don't need to assign.
    */
    if (co.contains("''")) co= co.replace("''", "'");

    /* Search #1: in the color list for the current language offset. */
    for (int i= color_off; strcmp(s_color_list[i], "") > 0; i+= 2)
    {
      s= s_color_list[i];
      if (QString::compare(co, s, Qt::CaseInsensitive) == 0)
      {
        s= s_color_list[i + 1];                /* Return the RGB */
        return s;
      }
    }

    /* Search #2: Fixed list of variants equivalent to some W3C words */
    if (QString::compare(color_name_string, "Cornflower", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_CORNFLOWERBLUE*2 + 1];
    if (QString::compare(color_name_string, "Darkgrey", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_DARKGRAY*2 + 1];
    if (QString::compare(color_name_string, "DarkSlateGrey", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_DARKSLATEGRAY*2 + 1];
    if (QString::compare(color_name_string, "DimGrey", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_DIMGRAY*2 + 1];
    if (QString::compare(color_name_string, "Grey", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_GRAY*2 + 1];
    if (QString::compare(color_name_string, "LightGoldenrod", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_LIGHTGOLDENRODYELLOW*2 + 1];
    if (QString::compare(color_name_string, "LightGrey", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_LIGHTGRAY*2 + 1];
    if (QString::compare(color_name_string, "LightSlateGrey", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_LIGHTSLATEGRAY*2 + 1];
    if (QString::compare(color_name_string, "NavyBlue", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_NAVY*2 + 1];
    if (QString::compare(color_name_string, "SlateGrey", Qt::CaseInsensitive) == 0) return s_color_list[COLOR_SLATEGRAY*2 + 1];

    /* Search #3: in the color list for all languages */
    {
      int lc;
      for (lc= 0; strcmp(string_languages[lc], "") != 0; ++lc) ;
      for (int j= 0; j < lc; ++j)
      {
        for (int i= j * COLOR_END; strcmp(s_color_list[i], "") > 0; i+= 2)
        {
          s= s_color_list[i];
          if (QString::compare(co, s, Qt::CaseInsensitive) == 0)
          {
            s= s_color_list[i + 1];                /* Return the RGB */
            return s;
          }
        }
      }
    }
  }

  /*
    It's not in any of our color lists, but it might be a name that Qt
    will accept anyway (e.g. in some version that I'm unaware of),
    or it was passed with an initial # so it's some variant of #RGB.
    But make sure it's valid, and convert to the canonical: #RRGGBB.
    NB: returning "" means error but not every caller checks for that.
  */

  QColor qq_color;
  qq_color.setNamedColor(co);
  if (qq_color.isValid() == false) return "";                 /* bad color, maybe bad format */
  QString qq_color_name= qq_color.name();                      /* returns name as "#RRGGBB" */

  //for (int i= color_off + 1; strcmp(s_color_list[i], "") > 0; i+= 2)
  //{
  //  s= s_color_list[i];
  //  if (QString::compare(qq_color_name, s, Qt::CaseInsensitive) == 0)
  //  {
  //    s= s_color_list[i - 1];
  //    return s;
  //  }
  //}
  return qq_color_name;
}


/* Called from: make_style_strings(). We allow sixteen color names that Qt doesn't like. */
QString MainWindow::qt_color(QString color_name)
{
  if (QString::compare(color_name, "Aqua", Qt::CaseInsensitive) == 0) return "#00FFFF"; /* = Cyan */
  if (QString::compare(color_name, "Fuchsia", Qt::CaseInsensitive) == 0) return "#FF00FF"; /* = Magenta */
  if (QString::compare(color_name, "GrayX11", Qt::CaseInsensitive) == 0) return "#BEBEBE";
  if (QString::compare(color_name, "GreenX11", Qt::CaseInsensitive) == 0) return "#00FF00";
  if (QString::compare(color_name, "Indigo", Qt::CaseInsensitive) == 0) return "#4B0082";
  if (QString::compare(color_name, "Lime", Qt::CaseInsensitive) == 0) return "#00FF00"; /* = Green */
  if (QString::compare(color_name, "MaroonX11", Qt::CaseInsensitive) == 0) return "#B03060";
  if (QString::compare(color_name, "Olive", Qt::CaseInsensitive) == 0) return "#808000";
  if (QString::compare(color_name, "PurpleX11", Qt::CaseInsensitive) == 0) return "#A020F0";
  if (QString::compare(color_name, "RebeccaPurple", Qt::CaseInsensitive) == 0) return "#663399";
  if (QString::compare(color_name, "Silver", Qt::CaseInsensitive) == 0) return "#C0C0C0";
  if (QString::compare(color_name, "Teal", Qt::CaseInsensitive) == 0) return "#008080";
  if (QString::compare(color_name, "WebGray", Qt::CaseInsensitive) == 0) return "#808080";
  if (QString::compare(color_name, "WebGreen", Qt::CaseInsensitive) == 0) return "#008000";
  if (QString::compare(color_name, "WebMaroon", Qt::CaseInsensitive) == 0) return "#7F0000";
  if (QString::compare(color_name, "WebPurple", Qt::CaseInsensitive) == 0) return "#7F007F";
  return color_name;
}


/*
  Pass: a string which is supposed to have a font weight. Return: a canonical font weight, a css number.
  See comment in ocelotgui.h that begins with the words "Font comments"
*/
QString MainWindow::canonical_font_weight(QString font_weight_string)
{
  int fwi= fontweights_index_via_chars(font_weight_string);
  int font_weight_as_int= fontweightsvalues[fwi].css_number; /* e.g. if font is "Light" we get 300 */
  char tmp_font_weight_string[64];
  strcpy(tmp_font_weight_string, font_weight_string.toUtf8());
  return QString::number(font_weight_as_int);
}

/* Pass: weight string. */
/* Return: offset within fontweightsvalues so e.g. you can get fontweightsvalues[i].qt_number. Or: -1. */
/* If it is a number less than 100 we assume that it's a QFont value, else we assume that it's a css value. */
/* todo: maybe if it's not a known name we should return the index for "normal"? */
int MainWindow::fontweights_index_via_chars(QString weight_string)
{
  QString weight_lower= weight_string.toLower();
  for (int i= 0; i < FONTWEIGHTSVALUES_SIZE; ++i)
  {
    if ((weight_lower == fontweightsvalues[i].chars)
     || (weight_lower == fontweightsvalues[i].alternate_chars))
      return i;
  }
  bool ok;
  int weight_as_int= weight_lower.toInt(&ok);
  if (ok == false) return -1;
  if (weight_as_int < 100) return fontweights_index_via_qt_number(weight_as_int);
  return fontweights_index_via_css_number(weight_as_int);
}

/*
  Pass: int for QFont to recognize, e.g. QFont::Light | Qt::Bold
  Return: index of e.g. Qt::Bold within fontweightvalues so we can get chars or css_number
  If the value is < Qt::Bold but >= Qt::DemiBold return index of Qt::DemiBold
*/
int MainWindow::fontweights_index_via_qt_number(int qt_number)
{
  int i;
  for (i= 1; i < FONTWEIGHTSVALUES_SIZE; ++i)
  {
    if (qt_number < (int)fontweightsvalues[i].qt_number) break;
  }
  return i - 1;
}

/*
  Pass: int for css to recognize, e.g. 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900
  Return: index of e.g. 700 ("bold") within fontweightvalues so we can get chars or qt_number
  If the value is < 700 but >= 600 return index of 600
*/
int MainWindow::fontweights_index_via_css_number(int css_number)
{
  int i;
  for (i= 1; i < FONTWEIGHTSVALUES_SIZE; ++i)
  {
    if (css_number < (int)fontweightsvalues[i].css_number) break;
  }
  return i - 1;
}


/*
  Pass font_family. Return font_family lower case stripped, or if it is invalid return "".
  This may also change font_style.
  If you set to a family that has neither "italic" nor "oblique", style should be "normal".
  Re Qt "font matching algorithm":
    There is no function that checks whether a family exists. We tried looking up the family
    via QFontDatabase but then QFontDialog can fail, for example "sans serif" is in QFontDatabase but not in QFontDialog,
    "sans regular" is in QFontDialog but not in QFontDatabase.
    Todo: make your own QFontDialog that depends on QFontDatabase. (This was done in version 1.5.)
  Switching to QFontinfo family solves the problem that QDialogBox has alias 'Sans', it's really 'DejaVu Sans'.
  Unfortunately QFontInfo also changes 'Ubuntu Light' to 'Ubuntu' but I will insist on using QFontInfo()'s decisions.
  Unfortunately 'padmaa italic' is in QFontDialog but QFontDatabase has only 'Regular' and 'Normal'.
*/
QString MainWindow::canonical_font_family(QString font_family_string, QString* font_style_string)
{
  QString new_font_family_string= connect_stripper(font_family_string, false);
  QFontDatabase font_database;
  QFont font= QFont(new_font_family_string);
  QFontInfo qfontinfo= QFontInfo(font);
  new_font_family_string= qfontinfo.family();
  const QStringList font_styles= font_database.styles(new_font_family_string);
  if (font_styles.count() == 0) return ""; /* Actually I don't think this is possible */
  QString new_font_style_string= canonical_font_style(new_font_family_string, *font_style_string);
  if (new_font_style_string == "") new_font_style_string= canonical_font_style(new_font_family_string, "normal");
  *font_style_string= new_font_style_string;
  return new_font_family_string;
}

/*
  Pass: a string which is supposed to have a font style. Return: a canonical font style.
  If it's not an expected value, return "normal" even though it might be invalid.
  We might change "italic" to "oblique" or vice versa depending on family --
  although you could set italic for a font that allows only oblique,
  later QDialogBox wouldn't find it.
  If the return is "" then I think it's safest to ignore and leave unchanged.
  Some QFontDatabase entries are "Regular" "Bold Oblique" "Light" etc. We only care about "Italic" and/or "Oblique".
  I don't use QStringList::contains() because it is new in Qt 5.12.
  Todo: This doesn't allow for families that have both italic and oblique. Prefer what is passed.
*/
QString MainWindow::canonical_font_style(QString font_family_string, QString font_style_string)
{
  QFontDatabase font_database;
  const QStringList font_styles= font_database.styles(font_family_string);
  if (font_styles.count() == 0) return ""; /* Presumably if there are no styles that means no such family */
  QString new_font_style_string= font_style_string.toLower();
  if (new_font_style_string == "normal") return new_font_style_string;
  if ((new_font_style_string == "italic")
   || (new_font_style_string == "oblique"))
  {
    QString font_database_name;
    for (int i= 0; i < font_styles.count(); ++i)
    {
      font_database_name= font_styles.at(i);
      if (QString::compare(font_styles.at(i), "italic", Qt::CaseInsensitive) == 0) return "italic";
      if (QString::compare(font_styles.at(i), "oblique", Qt::CaseInsensitive) == 0) return "oblique";
    }
  }
  /* Some fonts allow italics in QFontDialog but don't show italics in QFontDatabase. */
  if (new_font_style_string == "italic")
  {
    QFont font_of_family= QFont(font_family_string);
    font_of_family.setStyle(QFont::StyleItalic);
    QFont::Style style_of_family= font_of_family.style();
    if (style_of_family == QFont::StyleItalic) return "italic";
  }

  return "";
}


/* Called from: action_settings_statement() etc. Make a string that setStyleSheet() can use. */
/*
  Todo: I wasn't able to figure out a simple way to emphasize widget title, for example make it bold.
  Todo: Notice hardcoded "gray" for QMenu::item:disabled? We could have
        more selectable options for that, and for other QMenu::item
        pseudo- stuff, and QMenu::separator.
        E.g. QMenu:item:selected if you can decide on a colour.
  TODO: Also for QTextedit we should have ...:selected because right now
        when you select and then change focus, you lose the colour.
  Todo: Consider: font-size can be [ small | medium | large | x-large | xx-large ] | <size>pt | <size>px
  Warning: Changing border:1px could affect Completer_widget::size_and_position_change()
*/
void MainWindow::make_style_strings()
{
  make_one_style_string(&ocelot_statement_style_string,
                        qt_color(ocelot_statement_text_color),
                        qt_color(ocelot_statement_background_color),
                        "1",
                        qt_color(ocelot_statement_border_color),
                        ocelot_statement_font_family,
                        ocelot_statement_font_size,
                        ocelot_statement_font_style,
                        ocelot_statement_font_weight,
                           false);
  make_one_style_string(&ocelot_grid_style_string,
                        qt_color(ocelot_grid_text_color),
                        qt_color(ocelot_grid_background_color),
                        ocelot_grid_cell_border_size,
                        qt_color(ocelot_grid_focus_cell_background_color),
                        ocelot_grid_font_family,
                        ocelot_grid_font_size,
                        ocelot_grid_font_style,
                        ocelot_grid_font_weight,
                        false);
  make_one_style_string(&ocelot_history_style_string,
                        qt_color(ocelot_history_text_color),
                        qt_color(ocelot_history_background_color),
                        "1",
                        qt_color(ocelot_history_border_color),
                        ocelot_history_font_family,
                        ocelot_history_font_size,
                        ocelot_history_font_style,
                        ocelot_history_font_weight,
                        false);
  make_one_style_string(&ocelot_grid_header_style_string,
                        qt_color(ocelot_grid_text_color),
                        qt_color(ocelot_grid_header_background_color),
                        ocelot_grid_cell_border_size,
                        qt_color(ocelot_grid_focus_cell_background_color),
                        ocelot_grid_font_family,
                        ocelot_grid_font_size,
                        ocelot_grid_font_style,
                        ocelot_grid_font_weight,
                        false);
  make_one_style_string(&ocelot_menu_style_string,
                        qt_color(ocelot_menu_text_color),
                        qt_color(ocelot_menu_background_color),
                        "1",
                        qt_color(ocelot_menu_border_color),
                        ocelot_menu_font_family,
                        ocelot_menu_font_size,
                        ocelot_menu_font_style,
                        ocelot_menu_font_weight,
                        true);
  make_one_style_string(&ocelot_extra_rule_1_style_string,
                        qt_color(ocelot_extra_rule_1_text_color),
                        qt_color(ocelot_extra_rule_1_background_color),
                        ocelot_grid_cell_border_size,
                        qt_color(ocelot_grid_focus_cell_background_color),
                        ocelot_grid_font_family,
                        ocelot_grid_font_size,
                        ocelot_grid_font_style,
                        ocelot_grid_font_weight,
                        false);
#if (OCELOT_EXPLORER == 1)
  make_one_style_string(&ocelot_explorer_style_string,
                        qt_color(ocelot_explorer_text_color),
                        qt_color(ocelot_explorer_background_color),
                        "1",
                        qt_color(ocelot_menu_border_color),
                        ocelot_explorer_font_family,
                        ocelot_explorer_font_size,
                        ocelot_explorer_font_style,
                        ocelot_explorer_font_weight,
                        false);
#endif
}

/* called from make_style_strings (above) and Settings function text_for_font_example_filler in ocelotgui.h */
/* We enclose font-family in ''s because some names country [foundry] */
void MainWindow::make_one_style_string(QString *style_string,
                                       QString text_color,
                                       QString background_color,
                                       QString border_size,
                                       QString border_color,
                                       QString font_family,
                                       QString font_size,
                                       QString font_style, QString font_weight, bool is_menu)
{
  *style_string= "";
  if (is_menu)   (*style_string).append("* {");
  (*style_string).append("color:"); (*style_string).append(text_color);
  (*style_string).append(";background-color:"); (*style_string).append(background_color);
  (*style_string).append(";border:");
  (*style_string).append(border_size);
  (*style_string).append("px solid ");
  (*style_string).append(border_color);
  font_family= font_family.trimmed();
  font_family= connect_stripper(font_family, false);
  font_family= "'" + font_family + "'";
  (*style_string).append(";font-family:"); (*style_string).append(font_family);
  (*style_string).append(";font-size:"); (*style_string).append(font_size);
  (*style_string).append("pt;font-style:"); (*style_string).append(font_style);
  font_weight= font_weight.trimmed();
  (*style_string).append(";font-weight:"); (*style_string).append(canonical_font_weight(font_weight));
  if (is_menu)
  {
    (*style_string).append("} ");
    (*style_string).append("QMenu::item:disabled {");
    (*style_string).append("background-color:gray");
    (*style_string).append("}");
  }
}


/*
  Use: ocelot_grid_style string. Return: max height of one char, and combined height of borders.
  Assume that ocelot_grid_style_string also has "...border:...px...".

  This is always a problem.
  Simply doing QFontMetrics() for the widget you're working on won't work till show() happens.
  Todo: probably the spacing could look a little tidier.
  Todo: right now we do nothing with width, we could add that later
        (for one Latin character, or for a passed string).
  Todo: Find out why one must magic numbers to prevent vertical scroll bars from appearing.
        It seems to depend on font size -- with bigger fonts I could add smaller numbers.
  Todo: This is working for Row_form_box, now get it working for the result grid.
  Beware: height() is internal height but setMinimumSize() may depend on external height.
*/
void MainWindow::component_size_calc(int *character_height, int *borders_height)
{
  {
    QFont font= get_font_from_style_sheet(ocelot_grid_style_string);
    QFontMetrics fm(font);
    *character_height= fm.lineSpacing();
    /* See also the  kludge in grid_column_size_calc */
  }
  {
    int border_size_start= ocelot_grid_style_string.indexOf("border:");
    int border_size_end= ocelot_grid_style_string.indexOf("px", border_size_start);
    QString border_size= ocelot_grid_style_string.mid(border_size_start + 7, border_size_end - (border_size_start + 7));
    border_size= border_size.trimmed(); /* probably unnecessary */
    bool ok;
    int border_size_as_int= border_size.toInt(&ok);
    assert(ok == true);
    assert(border_size_as_int >= 0);
    *borders_height= border_size_as_int * 2 + 9;
  }
}


/*
  Pass: style_string. Return: QFont.
  In practice we always pass ocelot_grid_style_string and all we care about is height.
  Assume that style string always has "font-family... font-size:...pt;...font-weight:...".
  style_string has points not pixels, because the dialog box for getting a font always uses points.
  Here we make a new QFont based on font-family, font-size, font-weight (NB: all are necessary);
  from this font we can calculate a widget's internal height in pixels.
  Alternative: we could create a widget, apply style_string to it, then ask what its font is,
  but that's probably a bit slower because we have to show() the widget first.
  Some font weights are Qt 5.6: https://doc-snapshots.qt.io/qt5-5.6/qfont.html#Weight-enum
  Todo: we are tokenizing klunkily. This caused an assert with
        ... ;font-weight:400} QMenu::item:disabled {background-color:gray}
        because we expected either ; or end-of-string. So we added a check for } there too.
        But there are other things that could be wrong with strings.
*/
QFont MainWindow::get_font_from_style_sheet(QString style_string)
{
  QString font_family= "";
  int font_size_as_int= -1;
  bool font_style_as_bool= false;
  int font_weight_as_int= -1;
  {
    int font_family_start= style_string.indexOf("font-family:");
    int font_family_end= style_string.indexOf(";", font_family_start);
    font_family= style_string.mid(font_family_start + 12, font_family_end - (font_family_start + 12));
    font_family= font_family.trimmed();
    assert(font_family > "");
  }
  {
    int font_size_start= style_string.indexOf("font-size:");
    int font_size_end= style_string.indexOf("pt", font_size_start);
    QString font_size= style_string.mid(font_size_start + 10, font_size_end - (font_size_start + 10));
    font_size= font_size.trimmed();
    bool ok;
    font_size_as_int= font_size.toInt(&ok);
    assert(ok == true);
    assert(font_size_as_int >= 1);
  }
  {
    int font_style_start= style_string.indexOf("font-style:");
    int font_style_end= style_string.indexOf(";", font_style_start);
    QString font_style= style_string.mid(font_style_start + 11, font_style_end - (font_style_start + 11));
    font_style= font_style.trimmed();
    assert(font_style > "");
    if (QString::compare(font_style,"normal",Qt::CaseInsensitive) == 0) font_style_as_bool= false;
    if (QString::compare(font_style,"italic",Qt::CaseInsensitive) == 0) font_style_as_bool= true;
    if (QString::compare(font_style,"oblique",Qt::CaseInsensitive) == 0) font_style_as_bool= true;
  }
  {
    int font_weight_start= style_string.indexOf("font-weight:");
    int font_weight_end= style_string.indexOf(";", font_weight_start);
    if (font_weight_end < 0) font_weight_end= style_string.indexOf("}", font_weight_start);
    if (font_weight_end < 0) font_weight_end= style_string.length();
    QString font_weight= style_string.mid(font_weight_start + 12, font_weight_end - (font_weight_start + 12));
    font_weight= font_weight.trimmed();
    int fwi= fontweights_index_via_chars(font_weight);
    font_weight_as_int= fontweightsvalues[fwi].qt_number; /* e.g. if font is "Light" we get QFont::Light */
    assert(font_weight_as_int >= 0);
  }
  QFont font(font_family, font_size_as_int, font_weight_as_int, font_style_as_bool);
  return font;
}

/* Warning: assumption that color: comes before background-color: */
QString MainWindow::get_color_from_style_sheet(QString style_string)
{
  int color_start= style_string.indexOf("color:");
  int color_end= style_string.indexOf(";", color_start);
  QString color= style_string.mid(color_start + 6, color_end - (color_start + 6));
  return color;
}

QString MainWindow::get_background_color_from_style_sheet(QString style_string)
{
  int background_color_start= style_string.indexOf("background-color:");
  int background_color_end= style_string.indexOf(";", background_color_start);
  QString color= style_string.mid(background_color_start + 17, background_color_end - (background_color_start + 17));
  return color;
}

/*
  Get the next statement in a string.
  Pass: string, offset within string. Or: main_token number.
  Return: length i.e. # of tokens including delimiter or ; so offset can be right next time
          length == 0 would mean end-of-string
  Re how to find the end of a statement:
     For each token
       If (token == BEGIN or ELSEIF or IF or LOOP or REPEAT or WHILE) ++begin_count
       If (token == END --begin_count
     If (token == delimiter) this is the end
     If (no more tokens) this is the end
     If (token == ';' and begin_count == 0) this is the end
     Todo: What about \G etc.?
     NB: it's an error if begin_count>0 and this is the end, caller might return client error
  Re CLIENT_MULTI_STATEMENT: this would work too, but in the long term I'll want to
     know for sure: which statement returned result set X? Since a CALL can return
     multiple result sets, I didn't see a way to figure that out.
  Re: Don't bother with begin_count if PROCEDURE or FUNCTION or TRIGGER
      or EVENT hasn't been seen. But sometimes BEGIN or DECLARE can be
      starts of compound statements.
  Re: package_executable_section_begin_seen. CREATE PACKAGE BODY can end
      with END, or with BEGIN END. In the latter case we have too many
      BEGINs because we count CREATE PACKAGE as equivalent to BEGIN.
      So anything associated with this variable is an attempt to avoid
      the miscount.
  Beware: insert into t8 values (5); prompt w (unlike mysql client we wait for ';' here)
  Beware: create procedure p () begin end// select 5//
  Beware: input might be a file dump, and statements might be long.
  Todo: think about delimiter. Maybe delimiters don't count if you're in a delimiter statement?
  Todo: this doesn't allow for the possibility of "END comment WHILE|LOOP|REPEAT;"
  Todo: although label:begin declare v1 int; end; is illegal, it's confusing to miss the begin.
        we end up splitting the "end;" into a separate statement.
*/
int MainWindow::get_next_statement_in_string(int passed_main_token_number,
                                             int *returned_begin_count,
                                             bool check_if_client)
{
  int i;
  int begin_count= 0;
  QString last_token, second_last_token;
  QString text;
  int i_of_first_non_comment_seen= -1;
  bool begin_seen= false;
  text= statement_edit_widget->toPlainText(); /* Todo: decide whether I'm doing this too often */
  /*
    First, check for client statement, because the rules for client statement end are:
    ; OR delimiter OR \n OR \n\r
    but a DELIMITER statement ends with first whitespace after its argument
    or next client statement? or next statement of any kind?
  */
  bool client_statement_seen= false;
  bool create_package_seen= false;
  bool package_executable_section_begin_seen= false;
  for (i= passed_main_token_number; main_token_lengths[i] != 0; ++i)
  {
    int token= main_token_types[i];
    if ((token == TOKEN_TYPE_COMMENT_WITH_SLASH)
     || (token == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
     || (token == TOKEN_TYPE_COMMENT_WITH_MINUS))
      continue;
    if (is_client_statement(token, i, text) == true) client_statement_seen= true;
    break;
  }
  if ((client_statement_seen == true) && (check_if_client == true))
  {
    int client_statement_type= main_token_types[i];
    for (/* i= i*/; main_token_lengths[i] != 0; ++i)
    {
      /* Client statements can end with \n alone but SET (which is Ocelot-specific not defined by MySQL) needs ; */
      if ((main_token_lengths[i + 1] != 0) && (client_statement_type != TOKEN_KEYWORD_SET))
      {
        int j= main_token_offsets[i] + main_token_lengths[i];
        bool line_break_seen= false;
        while (j < main_token_offsets[i + 1])
        {
          if (j >= text.size()) break; /* I think this is impossible but added for safety on 2021-08-13 */
          if (text.mid(j, 1) == "\n")
          {
            line_break_seen= true;
            break;
          }
          ++j;
        }
        if (line_break_seen == true)
        {
          ++i;
          break;
        }
      }
      int token= main_token_types[i];
      if ((token == TOKEN_TYPE_COMMENT_WITH_SLASH)
       || (token == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
       || (token == TOKEN_TYPE_COMMENT_WITH_MINUS))
      {
        continue;
      }
      last_token= text.mid(main_token_offsets[i], main_token_lengths[i]);
      if (QString::compare(ocelot_delimiter_str, ";") != 0)
      {
        if (QString::compare(last_token, ocelot_delimiter_str) == 0)
        {
          ++i; break;
        }
      }
      if (QString::compare(last_token, ";") == 0)
      {
        ++i; break;
      }
    }
  }
  else
  {
    bool is_maybe_in_compound_statement= false;
    bool is_create_trigger= false;
    bool is_create_routine= false;
    int statement_type= -1;
    if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0)
    {
      QString word0= "", word1= "", word2= "";
      int word_number= 0;
      for (i= passed_main_token_number; main_token_lengths[i] != 0; ++i)
      {
        if ((main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_SLASH)
         || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
         || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_MINUS))
          continue;
        if (word_number == 0) word0= text.mid(main_token_offsets[i], main_token_lengths[i]);
        if (word_number == 1) word1= text.mid(main_token_offsets[i], main_token_lengths[i]);
        if (word_number == 2)
        {
          word2= text.mid(main_token_offsets[i], main_token_lengths[i]);
          break;
        }
        ++word_number;
      }
      statement_type= get_statement_type_low(word0, word1, word2);
    }
    last_token= "";
    for (i= passed_main_token_number; main_token_lengths[i] != 0; ++i)
    {
      if ((hparse_dbms_mask & FLAG_VERSION_PLSQL) != 0)
      {
        if (main_token_types[i] == TOKEN_KEYWORD_DECLARE)
        {
          is_maybe_in_compound_statement= true;
        }
        if (main_token_types[i] == TOKEN_KEYWORD_BEGIN)
        {
          begin_seen= true;
        }
      }
      second_last_token= last_token;
      last_token= text.mid(main_token_offsets[i], main_token_lengths[i]);
      if (QString::compare(ocelot_delimiter_str, ";") != 0)
      {
        if (QString::compare(last_token, ocelot_delimiter_str) == 0)
        {
          ++i; break;
        }
      }
      if ((QString::compare(last_token, "G", Qt::CaseInsensitive) == 0)
       && (QString::compare(second_last_token, "\\", Qt::CaseInsensitive) == 0))
      {
        ++i; break;
      }
      if ((QString::compare(last_token, ";") == 0) && (begin_count == 0))
      {
        if (((dbms_version_mask & FLAG_VERSION_PLSQL) != 0)
         && (is_maybe_in_compound_statement == true)
         && (begin_seen == false))
        {
          ; /* pl/sql: e.g. skip ; if it's between declare and begin */
        }
        else
        {
          ++i; break;
        }
      }
      if (i_of_first_non_comment_seen != -1)
      {
        if (main_token_types[i_of_first_non_comment_seen] == TOKEN_KEYWORD_CREATE)
        {
          if (main_token_types[i] == TOKEN_KEYWORD_TRIGGER)
          {
            is_maybe_in_compound_statement= true;
            is_create_trigger= true;
          }
          if ((main_token_types[i] == TOKEN_KEYWORD_PROCEDURE)
          ||  (main_token_types[i] == TOKEN_KEYWORD_FUNCTION)
          ||  (main_token_types[i] == TOKEN_KEYWORD_EVENT))
          {
            is_maybe_in_compound_statement= true;
            is_create_routine= true;
          }
          if (main_token_types[i] == TOKEN_KEYWORD_PACKAGE) /* new */
          { /* new */
            is_maybe_in_compound_statement= true; /* new */
            ++begin_count;       /* new */
            begin_seen= true; /* new */
            create_package_seen= true;
          } /* new */
        }
      }
      if (i_of_first_non_comment_seen == -1)
      {
        if (((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0) && (is_create_routine == false))
        {
          if (statement_type == TOKEN_KEYWORD_DO_LUA)
          {
            is_maybe_in_compound_statement= true;
          }
        }
        else
        {
          /* Following should only occur if we're sure it's MariaDB */
          if ((main_token_types[i] == TOKEN_KEYWORD_BEGIN)
          ||  (main_token_types[i] == TOKEN_KEYWORD_CASE)
          ||  (main_token_types[i] == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT)
          ||  (main_token_types[i] == TOKEN_KEYWORD_IF)
          ||  (main_token_types[i] == TOKEN_KEYWORD_LOOP)
          ||  (main_token_types[i] == TOKEN_KEYWORD_REPEAT)
          ||  (main_token_types[i] == TOKEN_KEYWORD_WHILE))
          {
            is_maybe_in_compound_statement= true;
          }
        }
        if ((main_token_types[i] != TOKEN_TYPE_COMMENT_WITH_SLASH)
         && (main_token_types[i] != TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
         && (main_token_types[i] != TOKEN_TYPE_COMMENT_WITH_MINUS))
        {
          i_of_first_non_comment_seen= i;
        }
      }
      /* For some reason the following was checking TOKEN_KEYWORD_ELSEIF too. Removed. */
      if (is_maybe_in_compound_statement == true)
      {
        if (((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0) && (is_create_routine == false))
        {
          if (statement_type == TOKEN_KEYWORD_DO_LUA)
          {
            if ((main_token_types[i] == TOKEN_KEYWORD_DO_LUA)
            ||  (main_token_types[i] == TOKEN_KEYWORD_IF)
            ||  (main_token_types[i] == TOKEN_KEYWORD_FUNCTION)
            ||  (main_token_types[i] == TOKEN_KEYWORD_REPEAT))
            {
              ++begin_count;
            }
            if ((main_token_types[i] == TOKEN_KEYWORD_END)
            ||  (main_token_types[i] == TOKEN_KEYWORD_UNTIL))
            {
              --begin_count;
            }
          }
          else if (is_create_trigger == true)
          {
            if (main_token_types[i] == TOKEN_KEYWORD_BEGIN)
            {
              ++begin_count;
            }
            if (main_token_types[i] == TOKEN_KEYWORD_END)
            {
              --begin_count;
            }
          }
        }
        else
        {
          if ((main_token_types[i] == TOKEN_KEYWORD_BEGIN)
          ||  ((main_token_types[i] == TOKEN_KEYWORD_CASE)   && ((i == i_of_first_non_comment_seen) || (main_token_types[i - 1] != TOKEN_KEYWORD_END)))
          ||  ((main_token_types[i] == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT) && ((i == i_of_first_non_comment_seen) || (main_token_types[i - 1] != TOKEN_KEYWORD_END)))
          ||  ((main_token_types[i] == TOKEN_KEYWORD_IF)     && ((i == i_of_first_non_comment_seen) || (main_token_types[i - 1] != TOKEN_KEYWORD_END)))
          ||  ((main_token_types[i] == TOKEN_KEYWORD_LOOP)   && ((i == i_of_first_non_comment_seen) || (main_token_types[i - 1] != TOKEN_KEYWORD_END)))
          ||  ((main_token_types[i] == TOKEN_KEYWORD_REPEAT) && ((i == i_of_first_non_comment_seen) || (main_token_types[i - 1] != TOKEN_KEYWORD_END)))
          ||  ((main_token_types[i] == TOKEN_KEYWORD_WHILE)  && ((i == i_of_first_non_comment_seen) || (main_token_types[i - 1] != TOKEN_KEYWORD_END))))
          {
            if ((create_package_seen)
             && (main_token_types[i] == TOKEN_KEYWORD_BEGIN)
             && ((hparse_dbms_mask & FLAG_VERSION_PLSQL) != 0) /* line added 2024-01-30, MariaDB 11.4 default won't have as|is */
             && (begin_count == 1))
            {
              int j= next_i(i, -1);
              if ((main_token_types[j] != TOKEN_KEYWORD_AS)
               && (main_token_types[j] != TOKEN_KEYWORD_IS))
                package_executable_section_begin_seen= true;
            }
            ++begin_count;
          }
          if ((main_token_types[i] == TOKEN_KEYWORD_END)
           || (main_token_types[i] == TOKEN_KEYWORD_END_IN_CREATE_STATEMENT)) /* new */
          {
            --begin_count;
            if ((package_executable_section_begin_seen)
             && (begin_count == 1))
              --begin_count;
          }
        }
      }
    }
  }
  *returned_begin_count= begin_count;

  /* If delimiter follows ; then it's part of the statement, to be stripped later. */
  bool delimiter_seen= false;
  if (text.mid(main_token_offsets[i], main_token_lengths[i]) == ocelot_delimiter_str)
  {
    delimiter_seen= true;
  }

  /*
    If comment follows ; on the same line, then we'll take it as part of the statement.
    But if it comes after delimiter other than ; then we won't take it as part of the
    statement, because we have to strip delimiters before sending to the server,
    and for that we expect the delimiter token to be the last token in the statement.
    Todo: it might be better to not expect token to be the last token in the statement.
    Todo: there might be more than one comment.
  */
  bool comment_seen= false;
  if ((i > 0)
   && (main_token_lengths[i] != 0)
   && ((ocelot_delimiter_str == ";")
    || (text.mid(main_token_offsets[i - 1], main_token_lengths[i - 1]) != ocelot_delimiter_str))
   //&& ((i < 2)
   // || (text.mid(main_token_offsets[i - 1], main_token_lengths[i - 1]).toUpper() != "G")
   // || (text.mid(main_token_offsets[i - 2], main_token_lengths[i - 2]) != "\\"))
          )

  {
    if ((main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_SLASH)
     || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
     || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_MINUS))
    {
      comment_seen= true;
      int j= main_token_offsets[i - 1] + main_token_lengths[i - 1];
      while (j < main_token_offsets[i])
      {
        if (text.mid(j,1) == "\n")
        {
          comment_seen= false;
        }
        ++j;
      }
    }
  }
  if ((delimiter_seen == true) || (comment_seen == true)) ++i;
  return i - passed_main_token_number;
}


/*
  Make statement ready to send to server: strip comments and delimiter, output UTF8.
  We have an SQL statement that's ready to go to the server.
  We have a guarantee that the result i.e. "char *query" is big enough.
  Rremove comments if that's what the user requested with --skip-comments which is default.
  Remove final token if it's delimiter but not ';'.
  Ignore last token(s) if delimiter, \G, \g, or (sometimes) go, ego.
  Todo: there's a conversion to UTF8 but it should be to what server expects.
  Todo: um, in that case, make server expect UTF8.
  Re comment stripping: currently this is default because in mysql client it's default
    but there should be no assumption that this will always be the case,
    so some sort of warning might be good. The history display has to include
    the comments even if they're not sent to the server, so the caller of this
    routine will use both (original string,offset,length) and (returned string).
    Comments should be replaced with a single space.
    Do not strip comments that start with / * ! or / * M !
  Re Tarantool comment stripping: "#" does not begin a comment,
    and inline comments will be trouble if ocelot_ca.comments <> 0
    because they're not legal in Lua (we don't try to solve that).
  Todo: Tarantool comments are different, eh?
  Todo: It's silly to call this every time you call real_query.
        Do it once, and you don't even need to call tokenize() again.
*/
int MainWindow::make_statement_ready_to_send(QString text, char *dbms_query, int dbms_query_len, int connection_number)
{
  log("make_statement_ready_to_send start", 80);
  int  *token_offsets;
  int  *token_lengths;
  int desired_count;
  unsigned int i;
  QString q;
  char *tmp;
  int tmp_len;
  //unsigned int token_count;
  desired_count= dbms_query_len + 1;
  token_offsets= new int[desired_count];
  token_lengths= new int[desired_count];
  token_lengths[0]= 0;
  tokenize(text.data(),
           text.size(),
           &token_lengths[0], &token_offsets[0], desired_count - 1,
          (QChar*)"33333", 1, ocelot_delimiter_str, 1);
  dbms_query[0]= '\0';
  for (i= 0; token_lengths[i] != 0; ++i)
  {
    if (ocelot_ca.comments == 0)
    {
      /* TOKEN_TYPE_COMMENT_WITH_SLASH */
      /* or TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE */
      /* or TOKEN_TYPE_COMMENT_WITH_MINUS */
      if ((text.mid(token_offsets[i], 2) == "/*")
       || (text.mid(token_offsets[i], 2) == "--")
       || ((text.mid(token_offsets[i], 1) == "#")
           && (connections_dbms[connection_number] != DBMS_TARANTOOL)))
      {
        if ((text.mid(token_offsets[i], 3) != "/*!")
         && (text.mid(token_offsets[i], 4) != "/*M!"))
        {
          strcat(dbms_query," ");
          continue;
        }
      }
    }
    /* Don't send \G or \g */
    if ((token_lengths[i + 1] == 1)
     && (text.mid(token_offsets[i], 2).toUpper() == "\\G"))
    {
      ++i;
      continue;
    }
    /* Don't send delimiter unless it is ; */
    if ((ocelot_delimiter_str != ";")
     && (text.mid(token_offsets[i], ocelot_delimiter_str.length()) == ocelot_delimiter_str))
    {
      break;
    }
    /* Preserve whitespace after a token, unless this is the last token */
    int token_length;
    if (token_lengths[i + 1] == 0) token_length= token_lengths[i];
    else token_length= token_offsets[i + 1] - token_offsets[i];
    q= text.mid(token_offsets[i], token_length);
    tmp_len= q.toUtf8().size();           /* See comment "UTF8 Conversion" */
    tmp= new char[tmp_len + 1];
    memcpy(tmp, q.toUtf8().constData(), tmp_len);
    tmp[tmp_len]= 0;
    assert(strlen(dbms_query) + strlen(tmp) <= (unsigned int) dbms_query_len);
    strcat(dbms_query, tmp);
    delete [] tmp;
  }
  delete [] token_offsets;
  delete [] token_lengths;
  log("make_statement_ready_to_send end", 80);
  return (strlen(dbms_query));
}

#if (OCELOT_MYSQL_INCLUDE == 1)
/*
  select_1_row() is a convenience routine, made because frequently there are single-row selects.
  And if they are multiple-row selects, we can always do them one-at-a-time with limit and offset clauses.
  Pass: select statement. Return: unexpected_error, expected to be ""
  And up to 5 string variables from the first row that gets selected.
  This should be used only if you know that no fields are null.
*/
QString select_1_row_result_1, select_1_row_result_2, select_1_row_result_3, select_1_row_result_4, select_1_row_result_5;
QString MainWindow::select_1_row(const char *select_statement)
{
  MYSQL_RES *res= NULL;
  MYSQL_ROW row= NULL;
  const char *unexpected_error= NULL;
  QString s;
  unsigned int num_fields;

  if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], select_statement, strlen(select_statement)))
  {
    unexpected_error= "select failed";
  }

  if (unexpected_error == NULL)
  {
    res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
    if (res == NULL)
    {
      unexpected_error= "mysql_store_result failed";
    }
  }

  if (unexpected_error == NULL)
  {
    num_fields= lmysql->ldbms_mysql_num_fields(res);
    row= lmysql->ldbms_mysql_fetch_row(res);
    if (row == NULL)
    {
      unexpected_error= er_strings[er_off + ER_MYSQL_FETCH_ROW_FAILED]; /* Beware! Look for a proc that compares routine with this string value! */
    }
    else
    {
      if (num_fields > 0) select_1_row_result_1= QString::fromUtf8(row[0]);
      if (num_fields > 1) select_1_row_result_2= QString::fromUtf8(row[1]);
      if (num_fields > 2) select_1_row_result_3= QString::fromUtf8(row[2]);
      if (num_fields > 3) select_1_row_result_4= QString::fromUtf8(row[3]);
      if (num_fields > 4) select_1_row_result_5= QString::fromUtf8(row[4]);
    }
  }

  if (res != NULL) lmysql->ldbms_mysql_free_result(res);

  if (unexpected_error != NULL) s= unexpected_error;
  else s= "";
  return s;
}
#endif //if (OCELOT_MYSQL_INCLUDE == 1)

/* volatile ints were here. moved up on 2019-01-01 */

#if (OCELOT_MYSQL_DEBUGGER == 1)

/*
  Debug

  Re debug_top_widget: It's a QWidget which contains a status line and debug_tab_widget.

  Re debug_tab_widget: It's a QTabWidget which may contain more than one debug_widget.

  Re debug_widget: it's derived from CodeEditor just as statement_edit_widget is, and it uses the
  same stylesheet as statement_edit_widget. It starts hidden, but debug|initialize shows it.
  It will contain the text of a procedure which is being debugged.
  Actually debug_widget[] occurs 10 times -- todo: there's no check for overflow.

  Re statements that come via statement_edit_widget: suppose the statement is "$DEB p8;".
  During tokens_to_keywords() we recognize that this is TOKEN_KEYWORD_DEBUG_DEBUG and highlight appropriately.
  During execute_client_statement(), after we check if statement_type == TOKEN_DEBUG_DEBUG_DEBUG and find that
  it's true, there's a call to action_debug_debug() followed by "return 1". When we're in action_debug_debug(),
  we have access to main_tokens so we can say things like "QString s= text.mid(main_token_offsets[i], main_token_lengths[i]);".
*/

/* This means "while debugger is going check status 20 times per second" (50 = 50 milliseconds). */
#define DEBUG_TIMER_INTERVAL 50

#define DEBUGGEE_STATE_0 0
#define DEBUGGEE_STATE_CONNECT_THREAD_STARTED 1
#define DEBUGGEE_STATE_BECOME_DEBUGEE_CONNECTION 2
#define DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP 3
#define DEBUGGEE_STATE_CONNECT_FAILED -1
#define DEBUGGEE_STATE_MYSQL_REAL_QUERY_ERROR -2
#define DEBUGGEE_STATE_MYSQL_STORE_RESULT_ERROR -3
#define DEBUGGEE_STATE_MYSQL_FETCH_ROW_ERROR -4
#define DEBUGGEE_STATE_BECOME_DEBUGGEE_CONNECTION_ERROR -5
#define DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP_ERROR -6
#define DEBUGGEE_STATE_END -7

char debuggee_channel_name[128]= "";
int volatile debuggee_state= DEBUGGEE_STATE_0;
char debuggee_state_error[STRING_LENGTH_512]= "";
char debuggee_information_status_debugger_name[32];
char debuggee_information_status_debugger_version[8];
char debuggee_information_status_timestamp_of_status_message[32];
char debuggee_information_status_number_of_status_message[8];
char debuggee_information_status_icc_count[8];
char debuggee_information_status_schema_identifier[256];
char debuggee_information_status_routine_identifier[256];
char debuggee_information_status_line_number[8];
char debuggee_information_status_is_at_breakpoint[8];
char debuggee_information_status_is_at_tbreakpoint[8];
char debuggee_information_status_is_at_routine_exit[8];
char debuggee_information_status_stack_depth[8];
char debuggee_information_status_last_command[256];
char debuggee_information_status_last_command_result[256];
char debuggee_information_status_commands_count[8];
char debuggee_database[256];

QString debug_routine_schema_name[DEBUG_TAB_WIDGET_MAX + 1];
QString debug_routine_name[DEBUG_TAB_WIDGET_MAX + 1];

QString debug_q_schema_name_in_statement;
QString debug_q_routine_name_in_statement;
QString debug_statement;

QTimer *debug_timer;                                    /* For calling action_debug_timer_status() every 1/10 seconds */
int debug_timer_old_line_number;
char debug_timer_old_schema_identifier[256];
char debug_timer_old_routine_identifier[256];
int volatile debuggee_connection_id;                             /* Save this if you need to kill the debuggee (an unusual need) */
int debug_timer_old_commands_count;
int debug_timer_old_number_of_status_message;
int debug_timer_old_icc_count;
int debug_timer_old_debug_widget_index;



/*
  Enable or disable debug menu items.
  If debug succeeds: most items after debug are enabled. (Todo: eventually all should be enabled.)
  If exit succeeds: most items after debug are disabled.
*/
void MainWindow::debug_menu_enable_or_disable(int statement_type)
{
  bool e;

  if (statement_type == TOKEN_KEYWORD_BEGIN) e= false;
  if (statement_type == TOKEN_KEYWORD_DEBUG_DEBUG) e= true;
  if (statement_type == TOKEN_KEYWORD_DEBUG_EXIT) e= false;
  for (int i= 0; i < menu_spec_struct_list.size(); ++i)
  {
    if ((menu_spec_struct_list.at(i).menu_name == "menu_debug")
     && (menu_spec_struct_list.at(i).menu_type == MENU_SPEC_TYPE_MENUITEM))
    {
      QAction *qaction= menu_spec_struct_list.at(i).qaction;
      if (qaction != NULL) qaction->setEnabled(e);
    }
  }
}


void MainWindow::create_widget_debug()
{
  /* We make debug_tab_widget now but we don't expect anyone to see it until debug|setup happens. */
  /* Todo: should you create with an initially-hidden flag? */
  debug_top_widget= new QWidget(this);              /* 2015-08-25 added "this" */
  debug_top_widget->hide();                         /* hidden until debug|initialize is executed */

  /*
    Todo: check: am I doing it right by saying parent = debug_top_widget
    i.e. will automatic delete happen when debug_top_widget is deleted?
    or will there be a memory leak?
    Hmm, why do I care? I don't delete debug_top_widget anyway, do I?
    Hmm Hmm, yes I do but it must be an error.
  */

  debug_line_widget= new QLineEdit(debug_top_widget);
  debug_line_widget->setText("Debugger Status = Inactive");
  debug_tab_widget= new QTabWidget(debug_top_widget);

  debug_top_widget_layout= new QVBoxLayout(debug_top_widget);
  debug_top_widget_layout->addWidget(debug_line_widget);
  debug_top_widget_layout->addWidget(debug_tab_widget);
  debug_top_widget->setLayout(debug_top_widget_layout);

  /* We make debug_timer now but we don't start it until debug status can be shown. */
  debug_timer= new QTimer(this);
  connect(debug_timer, SIGNAL(timeout()), this, SLOT(action_debug_timer_status()));

  /* This must be done before we set statement stylesheet. */
  for (int i= 0; i < DEBUG_TAB_WIDGET_MAX; ++i) debug_widget[i]= 0;

}


//#include <pthread.h>

/*
  The debuggee is a separate thread and makes its own connection using ocelot_ parameters just like the main connection.
  Problem: debuggee_thread() cannot be in MainWindow (at least, I didn't figure out how to make it in MainWindow).
  That explains why I made a lot of things global.
  Todo: Check: Why do you end statements with ";"?
  Todo: If an error occurs, copy the whole thing into a fixed-size char so debugger can see it.
        And notice that the result is that the thread ends, so beware of racing and worry about cleanup.
*/

void* debuggee_thread(void* unused)
{
  (void) unused; /* suppress "unused parameter" warning */
  char call_statement[512];
  int is_connected= 0;
  MYSQL_RES *debug_res= NULL;
  MYSQL_ROW debug_row= NULL;
  const char *unexpected_error= NULL;

  debuggee_connection_id= 0;

  memset(debuggee_state_error, 0, STRING_LENGTH_512);
  debuggee_state= DEBUGGEE_STATE_CONNECT_THREAD_STARTED;

  for (;;)
  {
    /*
      The debuggee connection.
      Todo: the_connect() could easily fail: parameters are changed, # of connections = max, password no longer works, etc.
            ... so you should try to pass back a better explanation if the_connect() fails here.
    */
    if (options_and_connect(MYSQL_DEBUGGER_CONNECTION, debuggee_database))
    {
       debuggee_state= DEBUGGEE_STATE_CONNECT_FAILED;
       strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
       break;
    }
    is_connected= 1;

    /* Get connection_id(). This is only in case regular "exit" fails and we have to issue a kill statement. */
    strcpy(call_statement, "select connection_id();");
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_DEBUGGER_CONNECTION], call_statement, strlen(call_statement)))
    {
      debuggee_state= DEBUGGEE_STATE_MYSQL_REAL_QUERY_ERROR;
      strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
      break;
    }
    debug_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_DEBUGGER_CONNECTION]);
    if (debug_res == NULL)
    {
      debuggee_state= DEBUGGEE_STATE_MYSQL_STORE_RESULT_ERROR;
      strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
      break;
    }
    debug_row= lmysql->ldbms_mysql_fetch_row(debug_res);
    if (debug_row == NULL)
    {
      debuggee_state= DEBUGGEE_STATE_MYSQL_FETCH_ROW_ERROR;
      strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
      lmysql->ldbms_mysql_free_result(debug_res);
      break;
    }
    debuggee_connection_id= atoi(debug_row[0]);
    lmysql->ldbms_mysql_free_result(debug_res);

    strcpy(call_statement, "call xxxmdbug.become_debuggee_connection('");
    strcat(call_statement, debuggee_channel_name);
    strcat(call_statement, "');");
    debuggee_state= DEBUGGEE_STATE_BECOME_DEBUGEE_CONNECTION;
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_DEBUGGER_CONNECTION], call_statement, strlen(call_statement)))
    {
      debuggee_state= DEBUGGEE_STATE_BECOME_DEBUGGEE_CONNECTION_ERROR;
      strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
      break;
    }
    /*
      Originally we just had debuggee_wait_loop here.
      Then the PREPARE+EXECUTE failed because of a procedure that contained a SELECT.
      So I replaced debuggee_wait_loop()'s PREPARE with "LEAVE".
      The actual execution will be done here in C.
      Todo: Replace all debuggee_wait_loop() with a C routine.
      Todo: Catch errors -- debuggee_wait_loop() didn't necessarily end via LEAVE x.
    */
    strcpy(call_statement, "call xxxmdbug.debuggee_wait_loop();");
    debuggee_state= DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP;
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_DEBUGGER_CONNECTION], call_statement, strlen(call_statement)))
    {
      debuggee_state= DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP_ERROR;
      strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
      break;
    }
    {
      char xxxmdbug_status_last_command_result[512];
      if (lmysql->ldbms_mysql_query(&mysql[MYSQL_DEBUGGER_CONNECTION], "select @xxxmdbug_status_last_command_result"))
      {
        /* This can happen, for example if debug command failed. */
        debuggee_state= DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP_ERROR;
        unexpected_error=" select @xxxmdbug_status_last_command_result failed";
        strcpy(debuggee_state_error, "no result from last command");
        break;
      }
      debug_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_DEBUGGER_CONNECTION]);
      if (debug_res == NULL)
      {
        unexpected_error= "mysql_store_result failed";
      }
      if (lmysql->ldbms_mysql_num_fields(debug_res) != 1)
      {
        unexpected_error= "wrong field count";
        lmysql->ldbms_mysql_free_result(debug_res);
        break;
      }
      debug_row= lmysql->ldbms_mysql_fetch_row(debug_res);
      if (debug_row == NULL)
      {
        unexpected_error= "mysql_fetch_row failed";
        lmysql->ldbms_mysql_free_result(debug_res);
       break;
      }
      strcpy(xxxmdbug_status_last_command_result, debug_row[0]);
      lmysql->ldbms_mysql_free_result(debug_res);
      /* There are various errors that xxxmdbug.check_surrogate_routine could have returned. */
      if ((strstr(xxxmdbug_status_last_command_result,"Error reading setup log") != 0)
       || (strstr(xxxmdbug_status_last_command_result,"is incorrect format for a surrogate identifier") != 0)
       || (strstr(xxxmdbug_status_last_command_result,"is not found once in xxxmdbug.setup_log") != 0)
       || (strstr(xxxmdbug_status_last_command_result,"was set up with an older debugger version") != 0)
       || (strstr(xxxmdbug_status_last_command_result,"original was not found") != 0)
       || (strstr(xxxmdbug_status_last_command_result,"original was altered") != 0)
       || (strstr(xxxmdbug_status_last_command_result,"surrogate was not found") != 0))
      {
        debuggee_state= DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP_ERROR;
        strncpy(debuggee_state_error, xxxmdbug_status_last_command_result, STRING_LENGTH_512 - 1);
        break;
      }
    }
    if (lmysql->ldbms_mysql_query(&mysql[MYSQL_DEBUGGER_CONNECTION], "select @xxxmdbug_what_to_call"))
    {
      unexpected_error=" select @xxxmdbug_what_to_call failed";
      break;
    }
    debug_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_DEBUGGER_CONNECTION]);
    if (debug_res == NULL)
    {
      unexpected_error= "mysql_store_result failed";
    }
    if (lmysql->ldbms_mysql_num_fields(debug_res) != 1)
    {
      unexpected_error= "wrong field count";
      lmysql->ldbms_mysql_free_result(debug_res);
      break;
    }
    debug_row= lmysql->ldbms_mysql_fetch_row(debug_res);
    if (debug_row == NULL)
    {
      unexpected_error= "mysql_fetch_row failed";
      lmysql->ldbms_mysql_free_result(debug_res);
      break;
    }
    strcpy(call_statement, debug_row[0]);
    lmysql->ldbms_mysql_free_result(debug_res);
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_DEBUGGER_CONNECTION], call_statement, strlen(call_statement)))
    {
      debuggee_state= DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP_ERROR;
      strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
    }
    else
    {
        /*
          Following is pretty much the same as for MYSQL_MAIN_CONNECTION.
          We're just throwing result sets away. NB: the statement has not
          really ended -- when there's a result set MySQL temporarily drops
          out of the procedure, and resumes during each iteration of this loop.
          Todo: we can put each result into the result grid widget as it comes;
          we'll have to decide whether the debugger should do it, or the main.
        */
        if (lmysql->ldbms_mysql_more_results(&mysql[MYSQL_DEBUGGER_CONNECTION]))
        {
          debug_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_DEBUGGER_CONNECTION]);
          if (debug_res != 0)
          {
            lmysql->ldbms_mysql_free_result(debug_res);

            if (lmysql->ldbms_mysql_more_results(&mysql[MYSQL_DEBUGGER_CONNECTION]))
            {
              while (lmysql->ldbms_mysql_next_result(&mysql[MYSQL_DEBUGGER_CONNECTION]) == 0)
              {
                debug_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_DEBUGGER_CONNECTION]);
                if (debug_res != 0) lmysql->ldbms_mysql_free_result(debug_res);
              }
              debug_res= 0;
            }
          }
        }
      debuggee_state= DEBUGGEE_STATE_END;
    }
    break;
  }

  /* Todo: Even after failure, get rid of result sets. But, oddly, lmysql->ldbms_mysql_next_result() never returns anything. */
  /* This just would throw any results away, which is what happens also with MYSQL_MAIN_CONNECTION. */
  /* What I'd have liked to do is: have the main connection put the result set up on the main screen. */
  //while (lmysql->ldbms_mysql_next_result(&mysql[MYSQL_DEBUGGER_CONNECTION]) == 0) ;
  //if (lmysql->ldbms_mysql_more_results(&mysql[MYSQL_DEBUGGER_CONNECTION]))
  //{
  //  while (lmysql->ldbms_mysql_next_result(&mysql[MYSQL_DEBUGGER_CONNECTION]) == 0)
  //  {
  //    debug_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_DEBUGGER_CONNECTION]);
  //    if (debug_res != 0) lmysql->ldbms_mysql_free_result(debug_res);
  //  }
  //  debug_res= 0;
  //}
  if (unexpected_error != NULL)
  {
    strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_DEBUGGER_CONNECTION]), STRING_LENGTH_512 - 1);
  }
  /* Cleanup */
  /* Shut the connection, which seems to cause disconnect automatically. */
  if (is_connected == 1) lmysql->ldbms_mysql_close(&mysql[MYSQL_DEBUGGER_CONNECTION]);

  /* Typically we'll reach this point with last_command_result = "debuggee_wait_loop() termination" */

  /* Here I am overwriting DEBUGGEE_WAIT_LOOP_ERROR / DEBUGGEE_STATE_END. Maybe they're informative but they caused trouble. */
  //debuggee_state= DEBUGGEE_STATE_0;
  /* options_and_connect called mysql_init which called mysql_thread_init, so cancel it */
  lmysql->ldbms_mysql_thread_end();
  /* The thread will end. */
  return ((void*) NULL);
}


/*
  Debug|Install -- install the debugger routines and tables in xxxmdbug.
  The actual CREATE statements are all xxxmdbug_install_sql in
  a separate file, install_sql.cpp, so that it's clear what the HP-licence part is.
  debug|install menu item is commented out, one must say $INSTALL
  Todo: decide what to do if it's already installed.
  Todo: privilege check
  Todo: what we really should be doing: passing the original command, in all cases.
*/
//void MainWindow::action_debug_install()
//{
//  statement_edit_widget->setPlainText("$INSTALL");
//  action_execute(1);
//}

void MainWindow::debug_install_go()
{
  char x[32768];
  char command_string[2048];
  QString qstring_error_message;

  if (debug_error((char*)"") != 0) return;

  if ((statement_edit_widget->dbms_version.mid(1,1) == ".")
  &&  (statement_edit_widget->dbms_version < "5.5"))
  {
    strcpy(command_string, er_strings[er_off + ER_DEBUGGER_REQUIRES]);
    if (debug_error(command_string) != 0) return;
  }

  qstring_error_message= debug_privilege_check(TOKEN_KEYWORD_DEBUG_INSTALL);
  if (qstring_error_message != "")
  {
    strcpy(command_string, qstring_error_message.toUtf8());
    if (debug_error(command_string) != 0) return; /* setup wouldn't be able to operate so fail */
  }

  if (debug_mdbug_install_sql(&mysql[MYSQL_MAIN_CONNECTION], x) < 0)
  {
      put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
      return;
    //if (debug_error((char*)"Install failed") != 0) return;
  }
  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
}

/* For copyright and license notice of debug_mdbug_install function contents, see beginning of this program. */
void debug_mdbug_install()
{
  ;
}
/* End of debug_mdbug_install. End of effect of licence of debug_mdbug_install_function contents. */


/*
  Debug|Setup
  Format =  $setup [options] object-name-list;
  debug|setup menu item is removed, one must say $SETUP ...

  Todo: This should put up a list box with the routines which the user can execute. No hard coding of test.p8 and test.p9.
        Or, it should look in the log for the last setup by this user, and re-do it.
  Todo: Shortcut = Same as last time.
  Todo: Search for schema name not just routine name.
  Todo: $setup does a GET_LOCK() so that two users won't do $setup at
        the same time. Figure out a better way.
  Todo: Check that 'install' has happened -- but for now it's OK, at least we return some sort of error.

  May 2018: $setup had to be totally rewritten, because it wouldn't work
  with MySQL 8.0. For explanation read
  https://ocelot.ca/blog/blog/2017/08/22/no-more-mysql-proc-in-mysql-8-0
  So the old unused code in install_sql.cpp still exists, and if we say
  #define NEW_SETUP 0 then it will still be invoked for test purposes,
  but now $setup code is entirely in ocelotgui.cpp (and incidentally
  is entirely written by Peter Gulutzan, only the old
  code in install_sql.cpp was written for HP).
*/
#define NEW_SETUP 1

#if (NEW_SETUP == 0)
void MainWindow::debug_setup_go(QString text)
{
  if (hparse_dbms_mask & FLAG_VERSION_MYSQL_8_0)
  {
    QMessageBox msgbox;
     QString s= "Sorry, the ocelotgui debugger won't work with MySQL 8.0. ";
     s.append("For explanation read https://ocelot.ca/blog/blog/2017/08/22/no-more-mysql-proc-in-mysql-8-0/");
     s.append("We have replacement code that we believe will work -- ");
     s.append("try rebuilding ocelotgui after changing the line saying ");
     s.append("#define NEW_SETUP 0 to #define NEW_SETUP 1.");
     msgbox.setText(s);
     msgbox.exec();
     return;
  }
  char command_string[512];
  int index_of_number_1, index_of_number_2;
  QString qstring_error_message;
  QString q_routine_schema, q_routine_name;

  /* Todo: Check that 'install' has happened -- but for now it's OK, at least we return some sort of error. */
  /* Todo: use debug_error instead, provided debug_error gets rid of any problematic ''s */
  qstring_error_message= debug_privilege_check(TOKEN_KEYWORD_DEBUG_SETUP);
  if (qstring_error_message != "")
  {
    strcpy(command_string, qstring_error_message.toUtf8());
    if (debug_error(command_string) != 0) return; /* setup wouldn't be able to operate so fail */
  }
  if (debug_parse_statement(text, command_string, &index_of_number_1, &index_of_number_2) < 0)
  {
    if (debug_error(command_string) != 0) return;
  }

  q_routine_schema= debug_q_schema_name_in_statement;
  q_routine_name= debug_q_routine_name_in_statement;
  if ((q_routine_schema == "") || (q_routine_name == ""))
  {
    if (debug_error((char*)er_strings[er_off + ER_MISSING_ROUTINE_NAMES]) != 0) return;
  }
  /* Todo: since yes there is a bug, but we want to get this out, just release the lock instead of doing the right thing. */
  {
    QString result_string= select_1_row("SELECT is_free_lock('xxxmdbug_lock')");
    if (select_1_row_result_1.toInt() != 0)
    {
      //if (debug_error((char*)"Another user has done $setup and caused a lock. This might be an ocelotgui bug.") != 0) return;
      result_string= select_1_row("SELECT release_lock('xxxmdbug_lock')");
    }
  }

  /* Throw away the first word i.e. "$setup" and execute "call xxxmdbug.setup('...')". */
  char call_statement[512 + 128];
  strcpy(call_statement, "call xxxmdbug.setup('");
  strcat(call_statement, strstr(command_string, " ") + 1);
  strcat(call_statement, "')");

  if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement)))
  {
    put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
    return;
    //if (debug_error((char*)"call xxxmdbug.setup() failed.") != 0) return;
  }
  debug_setup_mysql_proc_insert();
}
#endif


/*
  The following routine replaces the procedures xxxmdbug.mysql_proc_insert()
  and xxxmdbug.mysql_proc_insert_caller() in install_sql.cpp, which are no
  longer called from xxxmdbug.setup(). The effect is the same,
  but there is no INSERT into a mysql-database table.
  Also: definition_of_surrogate_routine will have three statements: DROP IF EXISTS, SET, CREATE.
        I could execute them all at once, but prefer to separate. Assume original name didn't contain ;.
        ... For icc_core routines the SET statement might be missing, I don't know why.
*/
/* TODO: THIS IS NO GOOD! YOU DO NOT WANT TO INSERT INTO MYSQL.PROC! */
void MainWindow::debug_setup_mysql_proc_insert()
{
  log("debug_setup_mysql_proc_insert start", 90);
  char command[512];
  MYSQL_RES *res= NULL;
  MYSQL_ROW row= NULL;
  const char *unexpected_error= NULL;
  unsigned int num_fields;
  unsigned int num_rows;
  QString definition_of_surrogate_routine;
  int it_is_ok_if_proc_is_already_there;
  QString list_of_drop_statements= "";

  lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "select * from xxxmdbug.routines");
  res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
  if (res != NULL)
  {
    num_rows= lmysql->ldbms_mysql_num_rows(res);
    lmysql->ldbms_mysql_free_result(res);
    res= NULL;
    if (num_rows - 3 >= DEBUG_TAB_WIDGET_MAX)
    {
      sprintf(command, er_strings[er_off + ER_SETUP], num_rows - 3, DEBUG_TAB_WIDGET_MAX - 1);
      put_message_in_result(command);
      return;
    }
  }
  lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "SET @xxxmdbug_saved_sql_mode=@@sql_mode");
  /*
    Go through all the rows of mysql.proc, doing DROP IF EXISTS and CREATE.
    If a create fails, we will later have a cleanup which should drop what we created.
  */
  int index_of_semicolon, index_of_set, index_of_create;
  QString first_query, second_query, third_query;
  //int second_iteration_is_necessary= 0;
  res= NULL;
  //for (int iteration=0; iteration <= 1; ++iteration)
  {
    //if ((iteration == 1) && (second_iteration_is_necessary == 0))
    //{
    //  break;
    //}
    if (res != NULL) /* Actually this can't be true now but assume someday we'll revive the for loop */
    {
      lmysql->ldbms_mysql_free_result(res);
      res= NULL;
    }
    row= NULL;

    strcpy(command,
    "SELECT TRIM(BOTH '`' FROM schema_identifier_of_original),"
    "       TRIM(BOTH '`' FROM routine_identifier_of_original),"
    "       TRIM(BOTH '`' FROM routine_identifier_of_surrogate),"
    "       definition_of_surrogate_routine,"
    "       offset_of_begin "
    "FROM xxxmdbug.routines");

    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], command, strlen(command)))
    {
      unexpected_error= "select failed";
    }
    if (unexpected_error == NULL)
    {
      res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
      if (res == NULL) unexpected_error= "mysql_store_result failed";
    }
    if (unexpected_error == NULL)
    {
      num_fields= lmysql->ldbms_mysql_num_fields(res);
      if (num_fields != 5) unexpected_error= "wrong field count";
    }

    if (unexpected_error == NULL)
    {
      MYSQL_RES *res_2= NULL;
      for (;;)
      {
        row= lmysql->ldbms_mysql_fetch_row(res);
        if (row == NULL) break;
        it_is_ok_if_proc_is_already_there= 0;
        /* todo: make sure row[2] i.e. routine_identifier_of_surrogate is not null */
        if ((strcmp(row[2], "icc_process_user_command_r_server_variables") == 0)
         || (strcmp(row[2], "icc_process_user_command_set_server_variables") == 0))
        {
          /* We will not insert icc_process_user_command_r_server_variables
             or icc_process_user_command_set_server_variables into mysql.proc
             if it already exists. This is okay as long as there is no change of
             DBMS server version or engine or plugin. But recommend always:
             DROP PROCEDURE xxxmdbug.icc_process_user_command_r_server_variables; */
          it_is_ok_if_proc_is_already_there= 1;
        }
        else
        {
          /* MDBug might not care if the routine definition was blank, but we do. */
          char tmp[512];
          MYSQL_ROW row_2= NULL;
          unsigned int num_rows_2= 0;
          strcpy(tmp, "select routine_definition from information_schema.routines where routine_schema='");
          strcat(tmp, row[0]);
          strcat(tmp, "' and routine_name='");
          strcat(tmp, row[1]);
          strcat(tmp, "'");
          if (lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], tmp)) num_rows_2= 0;
          else
          {
            res_2= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
            if (res_2 != NULL)
            {
              num_rows_2= lmysql->ldbms_mysql_num_rows(res_2);
            }
          }
          if (num_rows_2 == 1)
          {
            row_2= lmysql->ldbms_mysql_fetch_row(res_2);
            if ((row_2 == NULL) || (row_2[0] == NULL) || (strcmp(row_2[0],"") == 0))
            {
              lmysql->ldbms_mysql_free_result(res_2);
              res_2= NULL;
              /* ""Could not get a routine definition for %s.%s" ... */
              sprintf(tmp, er_strings[er_off + ER_COULD_NOT_GET], row[0], row[1]);
              /* Todo: merge this sort of stuff into debug_error() */
              unexpected_error= "create failed";
              put_message_in_result(tmp);
              //second_iteration_is_necessary= 1;
              break;
            }
          }
          if (res_2 != NULL)
          {
            lmysql->ldbms_mysql_free_result(res_2);
            res_2= NULL;
          }
        }
        definition_of_surrogate_routine= QString::fromUtf8(row[3]);
        index_of_semicolon= definition_of_surrogate_routine.indexOf(";");
        index_of_set= definition_of_surrogate_routine.indexOf("SET session sql_mode = '", index_of_semicolon);
        if (index_of_set == -1) index_of_create= definition_of_surrogate_routine.indexOf("CREATE ", index_of_semicolon);
        else index_of_create= definition_of_surrogate_routine.indexOf("CREATE ", index_of_set);
        if (index_of_create == -1) unexpected_error= "bad definition_of_surrogate_routine";
        if (unexpected_error == NULL)
        {
          if (index_of_set == -1) first_query= definition_of_surrogate_routine.mid(0, index_of_create - 1);
          else first_query= definition_of_surrogate_routine.mid(0, index_of_set - 1);
          if (index_of_set != -1) second_query= definition_of_surrogate_routine.mid(index_of_set, index_of_create - index_of_set);
          third_query= definition_of_surrogate_routine.mid(index_of_create, -1);
          if (it_is_ok_if_proc_is_already_there == 0)
          {
            if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], first_query.toUtf8(), strlen(first_query.toUtf8())))
            {
              /* Actually, a failed drop will have to be considered to be okay. */
            }
          }
          if ((unexpected_error == NULL) && (index_of_set != -1))
          {
            if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], second_query.toUtf8(), strlen(second_query.toUtf8())))
            {
              unexpected_error= "set failed";
              break;
            }
          }
          if (unexpected_error == NULL)
          {
            //if (iteration == 0)
            {
              /* Kludge. If we have DEFINER=@ we have to change to DEFINER=''@''. */
              {
                int i;
                i= third_query.indexOf("DEFINER=@");
                if (i > 0)
                {
                  third_query.insert(i + 8, "''");
                }
                i=third_query.indexOf("@ PROCEDURE `");
                if (i < 0) i=third_query.indexOf("@ FUNCTION `");
                if (i < 0) i=third_query.indexOf("@ TRIGGER `");
                if (i > 0)
                {
                  third_query.insert(i + 1, "''");
                }
              }
              if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], third_query.toUtf8(), strlen(third_query.toUtf8())))
              {
                /* If there's an error, the diagnostics here should go all the way back up to the user. */
                if (it_is_ok_if_proc_is_already_there == 0)
                {
                  unexpected_error= "create failed";
                  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
                  //second_iteration_is_necessary= 1;
                  if (res != NULL)
                  {
                    lmysql->ldbms_mysql_free_result(res);
                    res= NULL;
                  }
                  break;
                }
              }
              list_of_drop_statements.append(first_query);
            }
          }
        }
      }
      if (res != NULL)
      {
        lmysql->ldbms_mysql_free_result(res);
        res= NULL;
      }
      if (res_2 != NULL)
      {
        lmysql->ldbms_mysql_free_result(res_2);
        res_2= NULL;
      }
    }
    if (res != NULL)
    {
      lmysql->ldbms_mysql_free_result(res);
      res= NULL;
    }
  }
  if (res != NULL)
  {
    lmysql->ldbms_mysql_free_result(res);
    res= NULL;
  }

  log("debug_setup_mysql_proc_insert end", 90);
  lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "set session sql_mode=@xxxmdbug_saved_sql_mode");

  if (unexpected_error != NULL)
  {
    while (list_of_drop_statements > " ")
    {
      int i= list_of_drop_statements.indexOf(";") + 1;
      if (i <= 0) break;
      QString first_query= list_of_drop_statements.left(i);
      if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], first_query.toUtf8(), strlen(first_query.toUtf8())))
      {
        ; /* create failed, cleanup failed, but what can I do? */
      }
      list_of_drop_statements= list_of_drop_statements.right(list_of_drop_statements.size() - i);
    }
    if (strcmp(unexpected_error, "create failed") ==0) return; /* we already have the diagnostics */
    put_message_in_result(unexpected_error);
    return;
  }
  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
}


/*
  debug_privilege_check() -- check in advance whether some debuggee-related privileges exist
  It will be more convenient if the user is told in advance, and is told multiple problems at once.
  Of course I could search for the grants, but it's easier to try it and see what happens.
  However, this doesn't consider all possibilities and is only called before initializing.
  To see if you have execute privilege, see if you can select from information_schema.routines, rather than execute.
  A variant of that would be selecting where routine_definition > '' if you want to look for all privileges.
  As well as the checks here, $setup also needs routine_definition > '' i.e. you must be routine creator
  or you must have select privilege on mysql.proc.
  Todo: check other possible things that the debuggee could do, and check all routines not just xxxmdbug.command.
        one way would be to say 'command' OR 'other_routine' ... but putting into a loop would be better, I think.
  Todo: xxxmdbug.command calls xxxmdbug.privilege_checks which will generate a signal,
        but I'm wondering whether it's good because it sends messages using init_connect every time.
  statement_type = TOKEN_KEYWORD_DEBUG_DEBUG or TOKEN_KEYWORD_DEBUG_SETUP or TOKEN_KEYWORD_DEBUG_INSTALL.
*/
QString MainWindow::debug_privilege_check(int statement_type)
{
  QString s= "";
  char call_statement[512];
  unsigned int num_rows;
  MYSQL_RES *res;
  QString result_string;

  if (connections_is_connected[0] != 1)
  {
    s.append("Not connected");
    return s;
  }

  if (statement_type == TOKEN_KEYWORD_DEBUG_INSTALL)
  {
    /* Somebody has to have said: grant create, drop, create routine, alter routine, select, insert, update, delete, select on xxxmdbug.* ... */
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "create database xxxmdbug");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need create privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "drop table if exists xxxmdbug.xxxmdbug");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "create table xxxmdbug.xxxmdbug (s1 int)");
    if ((s == "") && (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142)) s.append("Need create privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'select * from xxxmdbug.xxxmdbug'");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need select privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'insert into xxxmdbug.xxxmdbug values (1)'");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need insert privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'delete from xxxmdbug.xxxmdbug'");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need delete privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'update xxxmdbug.xxxmdbug set s1 = 1'");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need update privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "drop table xxxmdbug.xxxmdbug");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need drop privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "drop procedure if exists xxxmdbug.xxxmdbug");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "create procedure xxxmdbug.xxxmdbug () set @a = 1");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need create routine privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "drop procedure xxxmdbug.xxxmdbug");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1370) s.append("Need alter routine privilege on xxxmdbug.*. ");
    return s;
  }

  /* First make sure xxxmdbug exists */
  num_rows= 0;
  if (lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "select * from information_schema.schemata where schema_name = 'xxxmdbug'"))
  {
    s.append("Cannot select from information_schema");
    return s;
  }
  res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
  if (res != NULL)
  {
    num_rows= lmysql->ldbms_mysql_num_rows(res);
    lmysql->ldbms_mysql_free_result(res);
  }
  if (num_rows != 1)
  {
    s.append("Cannot access database xxxmdbug. Check that $install was done and privileges were granted.");
    return s;
  }

  if ((statement_type == TOKEN_KEYWORD_DEBUG_DEBUG) || (statement_type == TOKEN_KEYWORD_DEBUG_SETUP))
  {
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'select * from xxxmdbug.readme union all select * from xxxmdbug.copyright'");/* Returns 1142 if SELECT denied */
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need select privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'create temporary table xxxmdbug.xxxmdbug_tmp (s1 int)'");/* Returns 1044 if CREATE TEMPORARY denied */
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need create temporary privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
  }

  if (statement_type == TOKEN_KEYWORD_DEBUG_DEBUG)
  {
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'set global init_connect = @@init_connect'");/* Returns 1227 if you need SUPER */
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1227) s.append("Need super privilege. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'call xxxmdbug.command()'");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need execute privilege on xxxmdbug.command. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
  }

  if (statement_type == TOKEN_KEYWORD_DEBUG_SETUP)
  {
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare stmt1 from 'select * from mysql.proc'");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1142) s.append("Need select privilege on mysql.proc. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");

    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'create table xxxmdbug.xxxmdbug_nontmp (s1 int)'");/* Returns 1044 if CREATE TEMPORARY denied */
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need create privilege on xxxmdbug.*. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");

    /* Can't prepare create-routine statements so test by actually creating and dropping a trivial for-test-only routine */
    sprintf(call_statement, "create procedure xxxmdbug.xxxmdbugp () set @a=@a");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement);
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need create routine privilege on xxxmdbug.*. ");
    else
    {
      sprintf(call_statement, "drop procedure xxxmdbug.xxxmdbugp");
      lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement);
      if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need drop routine privilege on xxxmdbug.*. ");
    }
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'call xxxmdbug.setup()'");
    if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need execute privilege on xxxmdbug.setup. ");
    lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");

    result_string= select_1_row("select count(*) from information_schema.tables where table_schema = 'xxxmdbug' and table_name = 'setup_log'" );
    if (result_string != "") s.append(result_string);
    else if (select_1_row_result_1.toInt() != 0)
    {
      lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'select * from xxxmdbug.setup_log'");
      if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need select privilege on xxxmdbug.setup_log. ");
      lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
      lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "prepare xxxmdbug_stmt from 'insert into setup_log select * from xxxmdbug.setup_log'");
      if (lmysql->ldbms_mysql_errno(&mysql[MYSQL_MAIN_CONNECTION]) == 1044) s.append("Need insert privilege on xxxmdbug.setup_log. ");
      lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "deallocate prepare xxxmdbug_stmt");
      /* Todo: Find out why repair table is sometimes necessary. I know it can get corrupted but don't yet know why. */
      if (lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], "repair table xxxmdbug.setup_log"))
      {
        s.append("Repair Table xxxmdbug.setup_log failed");
      }
      else
      {
        res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
        if (res != NULL) lmysql->ldbms_mysql_free_result(res);
      }
    }
  }

  /* TODO: Following isn't good. */

  result_string= select_1_row("select count(*) from information_schema.routines where routine_schema = 'xxxmdbug' and routine_name = 'command'" );
  if (result_string != "") s.append(result_string);
  else if (select_1_row_result_1.toInt() == 0) s.append("Need execute privilege for xxxmdbug.*. ");
  return s;
}


/*
  Called from: debug_debug_go(), debug_breakpoint_or_clear_go(), or other debug_ routines that might contain arguments.
  An SQL statement may contain comments, plus semicolon and/or delimiter, which should be stripped before passing to xxxmdbug.
  Also these procedures need to know: which tokens (if any) are for schema, routine, start line number, end line number.
  For example from "$DEBUG x.y -- comment;", we want to produce "debug x.y" and the offsets of x and y.
  Possible are: breakpoint/tbreakpoint location information [condition information]
                clear [schema_identifier[.routine_identifier]] line_number_minimum [-line_number_maximum]
                debug [schema_identifier[.routine_identifier]
                delete breakpoint number
  This does not detect syntax errors, we assume xxxmdbug.command() will return an error immediately for a syntax error.
  So it's not really a parse, but should find the tokens that matter.
  (Of course, hparse code is called by default, so parsing will happen.)
  Todo: see if confusion happens if there's condition information, or parameters enclosed inside ''s.
  If there is clearly an error, debug_parse_statement() returns -1 and command_string has an error message.
  We pass text, but we tokenized, so we have main_token_* tables and
  main_token_number and main_token_count_in_statement.
*/
int MainWindow::debug_parse_statement(QString text,
                           char *command_string,
                           int *index_of_number_1,
                           int *index_of_number_2)
{
  char token[512];
  int i, s_len;
  int token_type;
  QString s;
//  int index_of_dot= -1;
//  int index_of_minus= -1;
  int statement_type= 0;
  //bool left_parenthesis_seen= false;
  bool name_is_expected= false; /* true if syntax demands [schema_name.]routine_name at this point */
  char default_schema_name[512];

  strcpy(default_schema_name, "");
  debug_q_schema_name_in_statement="";
  debug_q_routine_name_in_statement="";
  *index_of_number_1= -1;
  *index_of_number_2= -1;
  strcpy(command_string, "");
  int last_token= main_token_number + main_token_count_in_statement;
  for (i= main_token_number;
       ((i < last_token) && (main_token_lengths[i] != 0));
       ++i)
  {
    token_type= main_token_types[i];
    if ((token_type == TOKEN_TYPE_COMMENT_WITH_SLASH)
     || (token_type == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
     || (token_type == TOKEN_TYPE_COMMENT_WITH_MINUS)) continue;
    s= text.mid(main_token_offsets[i], main_token_lengths[i]);

    if ((token_type >= TOKEN_KEYWORD_DEBUG_BREAKPOINT)
     && (token_type <= TOKEN_KEYWORD_DEBUG_TBREAKPOINT)
     && (strcmp(command_string, "") == 0))
    {
      /* We're at the first word, which is the statement type. Write it in full. */
      statement_type= token_type;
      if (token_type == TOKEN_KEYWORD_DEBUG_BREAKPOINT) { strcpy(command_string, "breakpoint"); name_is_expected= true; }
      if (token_type == TOKEN_KEYWORD_DEBUG_CLEAR) { strcpy(command_string, "clear"); name_is_expected= true; }
      if (token_type == TOKEN_KEYWORD_DEBUG_CONTINUE) strcpy(command_string, "continue");
      if (token_type == TOKEN_KEYWORD_DEBUG_DEBUG) { strcpy(command_string, "debug"); name_is_expected= true; }
      if (token_type == TOKEN_KEYWORD_DEBUG_DELETE) strcpy(command_string, "delete");
      if (token_type == TOKEN_KEYWORD_DEBUG_EXECUTE) strcpy(command_string, "execute");
      if (token_type == TOKEN_KEYWORD_DEBUG_EXIT) strcpy(command_string, "exit");
      if (token_type == TOKEN_KEYWORD_DEBUG_INFORMATION) strcpy(command_string, "information");
      if (token_type == TOKEN_KEYWORD_DEBUG_INSTALL) strcpy(command_string, "install");
      if (token_type == TOKEN_KEYWORD_DEBUG_LEAVE) strcpy(command_string, "leave");
      if (token_type == TOKEN_KEYWORD_DEBUG_NEXT) strcpy(command_string, "next");
      if (token_type == TOKEN_KEYWORD_DEBUG_REFRESH) strcpy(command_string, "refresh");
      if (token_type == TOKEN_KEYWORD_DEBUG_SET) strcpy(command_string, "set");
      if (token_type == TOKEN_KEYWORD_DEBUG_SETUP) { strcpy(command_string, "setup"); name_is_expected= true; }
      if (token_type == TOKEN_KEYWORD_DEBUG_SKIP) strcpy(command_string, "skip");
      if (token_type == TOKEN_KEYWORD_DEBUG_SOURCE) strcpy(command_string, "source");
      if (token_type == TOKEN_KEYWORD_DEBUG_STEP) strcpy(command_string, "step");
      if (token_type == TOKEN_KEYWORD_DEBUG_TBREAKPOINT) { strcpy(command_string, "tbreakpoint"); name_is_expected= true; }
      continue;
    }

    s= text.mid(main_token_offsets[i], main_token_lengths[i]);
    s_len= s.toUtf8().size(); /* See comment "UTF8 Conversion" */
    if (s_len + 1 >= 512) { strcpy(command_string, "overflow"); return -1; }
    memcpy(token, s.toUtf8().constData(), s_len);
    token[s_len]= 0;
    if (token[0] == ';') continue;
    if (s == ocelot_delimiter_str) continue;
//    if (token[0] == '.') index_of_dot= i;
//    if (token[0] == '-') index_of_minus= i;
//    if (token[0] == '(') left_parenthesis_seen= true;
    if (name_is_expected)
    {
      if ((token_type == TOKEN_TYPE_OTHER)
       || (token_type == TOKEN_TYPE_IDENTIFIER) /* same check as in hparse_f_is_identifier()? */
       || (token_type == TOKEN_TYPE_IDENTIFIER_WITH_DOUBLE_QUOTE)
       || (token_type == TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK))
      {
        /* It's possibly a routine name, and we're expecting a routine name. */
        char tmp_schema_name[512];
        char tmp_routine_name[512];
        int s2_len;
        QString s2;
        if (text.mid(main_token_offsets[i + 1], 1) == ".")
        {
          /* schema-name . routine_name */
          if ((main_token_types[i + 2] == TOKEN_TYPE_OTHER)
           || (main_token_types[i + 2] == TOKEN_TYPE_IDENTIFIER) /* same check as in hparse_f_is_identifier()? */
           || (token_type == TOKEN_TYPE_IDENTIFIER_WITH_DOUBLE_QUOTE) /* todo: better check why this is "token_type" */
           || (main_token_types[i + 2] == TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK))
          {
            strcpy(tmp_schema_name, token);
            s2= text.mid(main_token_offsets[i + 2], main_token_lengths[i + 2]);
            s2_len= s2.toUtf8().size(); /* See comment "UTF8 Conversion" */
            if (s2_len + 1 + s_len + 1 >= 512) { strcpy(command_string, "overflow"); return -1; }
            memcpy(tmp_routine_name, s2.toUtf8().constData(), s2_len);
            tmp_routine_name[s2_len]= 0;
            i+= 2;
          }
          else
          {
            strcpy(command_string, "Expected routine-name after .");
            return -1;
          }
        }
        else
        {
          /* Just routine name. Fill in [default schema name]. Todo: shouldn't require a server request so frequently. */
          if (strcmp(default_schema_name, "") == 0)
          {
            QString result_string;
            select_1_row_result_1= "";
            result_string= select_1_row("select database()");
            if (result_string != "") { strcpy(command_string, "Need to know default database but select database() failed"); return -1; }
            if (select_1_row_result_1== "") { strcpy(command_string, "Need to know default database but select database() returned nothing"); return -1; }
            s2= select_1_row_result_1;
            s2_len= s2.toUtf8().size();
            if (s2_len + 1 + s_len + 1 >= 512) { strcpy(command_string, "overflow"); return -1; }
            memcpy(default_schema_name, s2.toUtf8().constData(), s2_len);
            default_schema_name[s2_len]= 0;
          }
          strcpy(tmp_routine_name, token);
          strcpy(tmp_schema_name, default_schema_name);
        }
        name_is_expected= false;

        QString aa= tmp_schema_name;
        aa= connect_stripper(aa, true);
        strcpy(tmp_schema_name, aa.toUtf8());
        aa= tmp_routine_name;
        aa= connect_stripper(aa, true);
        strcpy(tmp_routine_name, aa.toUtf8());

        strcpy(token, tmp_schema_name);
        strcat(token, ".");
        strcat(token, tmp_routine_name);

        {
          QString result_string;
          char query_for_select_check[1280];
          sprintf(query_for_select_check, "select count(*) from information_schema.routines where routine_schema='%s' and routine_name='%s'", tmp_schema_name, tmp_routine_name);
          result_string= select_1_row(query_for_select_check);
          if (result_string != "") { strcpy(command_string, "Tried to check routine name but select from information_schema.routines failed"); return -1; }
          if (select_1_row_result_1.toInt() == 0)
          {
            sprintf(command_string, "Could not find routine %s.%s", tmp_schema_name, tmp_routine_name);
            return -1;
          }

        }

        debug_q_schema_name_in_statement= tmp_schema_name;
        debug_q_routine_name_in_statement= tmp_routine_name;
      }
      else
      {
        /* It's not possibly a routine identifier, and we're expecting a routine identifier. */
        strcpy(command_string, "Expected a routine name"); return -1;
      }
    }
    if ((token[0] == ',') && (statement_type == TOKEN_KEYWORD_DEBUG_SETUP)) name_is_expected= true;

    if ((token_type == TOKEN_TYPE_LITERAL_WITH_DIGIT)
     || (token_type == TOKEN_TYPE_LITERAL))
    {
      if (*index_of_number_1 == -1) *index_of_number_1= i;
      else if (*index_of_number_2 == -1) *index_of_number_2= i;
    }
    if (strlen(command_string) + strlen(token) + 1 >= 512) { strcpy(command_string, "overflow"); return -1; }
    if (strcmp(command_string, "") != 0) strcat(command_string, " ");
    strcat(command_string, token);
  }
  return 0;
}


/*
  First: find the surrogate routine that debuggee will call (if it's not there, error = you should call setup).
  Todo: schema_name could be '.' i.e. default
  Then: put up debug_top_widget
  Then: execute xxxmdbug.command(...,'debug ...')
  Todo: check that surrogate routine is not obsolete, i.e. timestamp is after original routine's timestamp
  Todo: check that everything in the group is present and executable
  Todo: check that user is the same ... but how can you do that? Is it only in setup_log?
  Todo: get rid of initialize() from menu
  Todo: when starting, make sure debuggee is not already running -- even a finished routine is not over
  Todo: if clicking causes you to get to action_debug_debug() you must generate a $DEBUG statement -- but how click a list??
*/
//void MainWindow::action_debug_debug()
//{
//  /* Figure out what the parameter should be -- it's not text, eh? */
//  QString parameter;
//  debug_debug_go(parameter);
//}


/*
  Call debug_error((char*)"error-text") whenever, in one of the debug routines, you encounter an error.
  Call debug_error((char*)"") regardless, at the start of a debug routine, so basic prerequisite checks can happen.
  For example, if the user says "$debug test.x" and there is no surrogate for x, we want the user to see:
  Error 1644 (05678) Surrogate not found.
  TODO: make sure all the debug-routine failures go through here!
  Todo: if the error is due to a failure of the last call, add what that last call's error message was.
*/
int MainWindow::debug_error(char *text)
{
//  unsigned int statement_type;

  if (connections_is_connected[0] == 0)
  {
    /* Unfortunately this might not get through. */
    make_and_put_message_in_result(ER_NOT_CONNECTED, 0, (char*)"");
    return 1;
  }

  if (debuggee_state < 0)
  {
    char tmp_string[STRING_LENGTH_512]="";
    char tmp_string_2[STRING_LENGTH_512 + 64];
    if (debuggee_state != DEBUGGEE_STATE_END)
    {
      /* debuggee_state_error should tell us something, but remove all ' first */
      strcpy(tmp_string, debuggee_state_error);
      for (int i= 0; tmp_string[i] != '\0'; ++i) if (tmp_string[i] == '\047') tmp_string[i]= ' ';
    }
    if (debuggee_state == DEBUGGEE_STATE_END)
    {
      make_and_put_message_in_result(ER_ROUTINE_HAS_STOPPED, 0, (char*)"");
    }
    else
    {
      sprintf(tmp_string_2, "'%s %d. %s'", "debuggee_state:", debuggee_state, tmp_string);
      put_message_in_result(tmp_string_2);
    }
    return 1;
  }


  if (strcmp(text,"") != 0)
  {
    put_message_in_result(text);
    return 1;
  }

  return 0;
}


/* $DEBUG [schema.]routine [(parameters)] */
void MainWindow::debug_debug_go(QString text) /* called from execute_client_statement() or action_debug_debug() */
{
  log("debug_debug_go", 90);
  char routine_schema[512];
  char routine_name[512];
  char call_statement[512];
  QString result_string;
  QString qstring_error_message;
  int current_widget_index;
  QString q_routine_schema, q_routine_name;
  char command_string[2048];
  int index_of_number_1, index_of_number_2;
  /* Todo: Check that 'debug' has not happened */
  if (debug_parse_statement(text, command_string, &index_of_number_1, &index_of_number_2) < 0)
  {
    if (debug_error(command_string) != 0) return;
  }

  q_routine_schema= debug_q_schema_name_in_statement;
  q_routine_name= debug_q_routine_name_in_statement;

  if ((q_routine_schema == "") || (q_routine_name == ""))
  {
    if (debug_error((char*)er_strings[er_off + ER_MISSING_ROUTINE_NAME]) != 0) return;
  }

  /*
    If a $debug was started before, and didn't finish, we demand that the user do $exit.
    We could instead call debug_exit_go(1).
    Perhaps $exit will fail somehow, and users will be falsely told they can't debug.
    That's a bug but better than hanging, which is a risk if we make two debug threads.
  */
  if (debug_thread_exists == true)
  {
    if (debug_error((char*)er_strings[er_off + ER_DEBUG_IS_ALREADY_RUNNING]) != 0) return;
  }

  if (debuggee_state < 0) debuggee_state= DEBUGGEE_STATE_0;
  if (debuggee_state == DEBUGGEE_STATE_END) debuggee_state= DEBUGGEE_STATE_0;
  if (debug_error((char*)"") != 0) return;

  strcpy(routine_schema, q_routine_schema.toUtf8());
  strcpy(routine_name, q_routine_name.toUtf8());

  if (debuggee_state > 0)
  {
    if (debug_error((char*)er_strings[er_off + ER_DEBUG_IS_ALREADY_RUNNING]) != 0) return;
  }

  qstring_error_message= debug_privilege_check(TOKEN_KEYWORD_DEBUG_DEBUG);
  if (qstring_error_message != "")
  {
    strcpy(command_string, qstring_error_message.toUtf8());
    if (debug_error(command_string) != 0) return; /* debuggee wouldn't be able to operate so fail */
  }
  /* Call xxxmdbug.debuggee_get_surrogate_name */
  strcpy(call_statement, "CALL xxxmdbug.debuggee_get_surrogate_name('");
  strcat(call_statement, routine_name);
  strcat(call_statement, "','");
  strcat(call_statement, routine_schema);
  strcat(call_statement, "',@schema_identifier,@surrogate_routine_identifier,@routine_type,@remainder_of_original_name)");
if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement)))
  {
    if (debug_error((char*)er_strings[er_off + ER_SURROGATE]) != 0) return;
  }
  result_string= select_1_row("select @schema_identifier, concat(left(@surrogate_routine_identifier,11), '%'), @routine_type, @remainder_of_original_name, isnull(@schema_identifier)");
  if (result_string != "")
  {
    char char_result_string[512];
    strcpy(char_result_string, result_string.toUtf8());
    if (debug_error(char_result_string) != 0) return;
  }
  /* select_1_row_result_1 = @schema_identifier. select_1_row_result_2 = left(@surrogate_routine_identifier,11) || '%'. */

  /* Todo: this checks whether select returned null, good. But it should make even more certain that $debug will succeed. */
  if (select_1_row_result_5.toInt() == 1)
  {
    if (debug_error((char*)er_strings[er_off + ER_SURROGATE_NOT_FOUND]) != 0) return;
  }
  //QString routine_schema_name_for_search= select_1_row_result_1;
  QString routine_name_for_search= select_1_row_result_2;
  /*
    This will find all surrogate routines which have the same prefix, xxxmdbug___
    That means they're in the same group. Ignore icc_core.
    Get only the part that's not part of the prefix.
    Don't ask for schema name, group's routines can be in different schema.
    Interesting idea: you could have a way to show both the surrogate and the original.
  */
  int i, j;
  char i_as_string[16];
  /* Todo: n should not be hard-coded here, it limits us to only 10 routines can be searched */
  for (i= 0, j= 0; j < DEBUG_TAB_WIDGET_MAX; ++i)
  {
    sprintf(i_as_string, "%d", i);
    strcpy(call_statement, "select routine_schema, right(routine_name,length(routine_name)-12) from information_schema.routines ");
    strcat(call_statement, "where routine_name like '");
    strcat(call_statement, routine_name_for_search.toUtf8());
    strcat(call_statement, "' order by routine_name limit 1 offset ");
    strcat(call_statement, i_as_string);
    result_string= select_1_row(call_statement);
    if (result_string != "")
    {
      char char_result_string[512];
      if (result_string == er_strings[er_off + ER_MYSQL_FETCH_ROW_FAILED]) break;
      strcpy(char_result_string, result_string.toUtf8());
      if (debug_error(char_result_string) != 0) return;
    }
    if (select_1_row_result_2 != "icc_core")
    {
      /* Todo: debug_routine_schema_name and debug_routine_name are global so setup() will ruin them. Fix that! */
      debug_routine_schema_name[j]= select_1_row_result_1;
      debug_routine_name[j]= select_1_row_result_2;
      ++j;
    }
  }
  /* Todo: check: can this crash if there are DEBUG_TAB_WIDGET_MAX routines? Is this unnecessary if there are DEBUG_TAB_WIDGET_MAX routines? */
  debug_routine_name[j]= "";

  int debug_widget_index;

  /* Todo: check if this is useless. You're supposed to have called debug_delete_tab_widgets[] during $exit. */
  for (debug_widget_index= 0; debug_widget_index < DEBUG_TAB_WIDGET_MAX; ++debug_widget_index)
  {
    debug_widget[debug_widget_index]= 0;
  }
  /* After this point, some items that get created are persistent, so be sure to clear them if there's an error. */
  //MYSQL_RES *debug_res;
  //MYSQL_ROW row;
  QString routine_definition;
  current_widget_index= -1;
  for (debug_widget_index= 0; debug_widget_index < DEBUG_TAB_WIDGET_MAX; ++debug_widget_index)
  {
    if (strcmp(debug_routine_name[debug_widget_index].toUtf8(), "") == 0) break;
    strcpy(call_statement, "select routine_definition from information_schema.routines where routine_schema = '");
    strcat(call_statement, debug_routine_schema_name[debug_widget_index].toUtf8());
    strcat(call_statement, "' and routine_name = '");
    strcat(call_statement, debug_routine_name[debug_widget_index].toUtf8());
    strcat(call_statement, "'");
    QString error_return= select_1_row(call_statement);
    if (error_return != "")
    {
      debug_delete_tab_widgets();                          /* delete already-made widgets. Rest of 'exit' shouldn't happen. */
      {
        /* Could not find a routine in the $setup group: ... */
        char t_error_return[256];
        char t_schema_name[256];
        char t_routine_name[256];
        strcpy(t_error_return, error_return.toUtf8());
        strcpy(t_schema_name, debug_routine_schema_name[debug_widget_index].toUtf8());
        strcpy(t_routine_name, debug_routine_name[debug_widget_index].toUtf8());
        sprintf(call_statement,
                er_strings[er_off + ER_COULD_NOT_FIND_A_ROUTINE],
                t_error_return,
                t_schema_name,
                t_routine_name);
      }
      debug_error(call_statement);                         /* Todo: you forgot to look for icc_core */
      return;
    }
    routine_definition= select_1_row_result_1;             /* = information_schema.routines.routine_definition */
    if (routine_definition == "")
    {
      debug_delete_tab_widgets();
      {
        /* Could not get a routine definition for ... */
        char t_routine_name[256];
        strcpy(t_routine_name, debug_routine_name[debug_widget_index].toUtf8());
        sprintf(call_statement, er_strings[er_off + ER_COULD_NOT_GET], t_routine_name);
      }
      if (debug_error(call_statement)) return;
    }
    debug_widget[debug_widget_index]= new CodeEditor(this);
    debug_widget[debug_widget_index]->is_debug_widget= true;
    debug_widget[debug_widget_index]->statement_edit_widget_left_bgcolor= QColor(ocelot_statement_prompt_background_color);
    debug_widget[debug_widget_index]->statement_edit_widget_left_treatment1_textcolor= QColor(ocelot_statement_text_color);

    debug_maintain_prompt(0, debug_widget_index, 0); /* clear prompt_as_input_by_user */

    debug_widget[debug_widget_index]->setStyleSheet(ocelot_statement_style_string);

    /* todo: call 'refresh breakpoints' and debug_maintain_prompt() for breakpoints that already have been set up. */
    debug_widget[debug_widget_index]->prompt_default= (QString)"\\2 \\L";
    debug_widget[debug_widget_index]->result= (QString)"ABCDEFG";
    debug_widget[debug_widget_index]->setPlainText(routine_definition);

    debug_widget[debug_widget_index]->setReadOnly(false);                 /* if debug shouldn't be editable, set to "true" here */
    debug_widget[debug_widget_index]->installEventFilter(this);           /* is this necessary? */
    debug_tab_widget->addTab(debug_widget[debug_widget_index], debug_routine_name[debug_widget_index]);
    if ((QString::compare(debug_routine_name[debug_widget_index], q_routine_name, Qt::CaseInsensitive) == 0)
    &&  (QString::compare(debug_routine_schema_name[debug_widget_index], q_routine_schema, Qt::CaseInsensitive) == 0))
    {
      current_widget_index= debug_widget_index;
    }
  }
  if (current_widget_index == -1)
  {
    debug_delete_tab_widgets();
    if (debug_error((char*)er_strings[er_off + ER_ROUTINE_IS_MISSING])) return;
  }
  debug_tab_widget->setCurrentIndex(current_widget_index);

  /* Getting ready to create a separate thread for the debugger and 'attach' to it */

  char error_message[512];

  debuggee_state= DEBUGGEE_STATE_0;
  /*
    We want the debuggee default database to be the main default
    database, but that's not necessarily ocelot_ca.database_as_utf8
    because maybe we had a USE statement.
    Todo: I'm a bit unclear what to do if this fails.
  */
  if (select_1_row("select database()") != "") debuggee_database[0]= '\0';
  else strcpy(debuggee_database, select_1_row_result_1.toUtf8());

  /*
    We want a channel name that will differ from what others might choose.
    Arbitrary decision = debug_channel_name will be "ch#" || connection-number-of-main-connection.
    It could be uniquified beyond that if necessary, e.g. add user name.
    Todo: this could be moved so it doesn't happen every time $debug happens. */

  sprintf(debuggee_channel_name, "ch#%d", statement_edit_widget->dbms_connection_id);
  /* Create a debuggee thread. */
  /* Todo: consider whether it would have been better to use the Qt QThread function */
  int pthread_create_result= pthread_create(&debug_thread_id, NULL, &debuggee_thread, NULL);
#if defined(NDEBUG)
    if (pthread_create_result != 0) {printf("assert(pthread_create_result == 0);"); exit(1); }
#else
    assert(pthread_create_result == 0);
#endif
  debug_thread_exists= true;
  /*
    Wait till debuggee has indicated that it is about to call debuggee_wait_loop().
    Todo: Give a better diagnostic if this doesn't happen.
    Todo: Is it possible to fail anyway? If so, sleep + repeat?
    Todo: This gives up after 1 second. Maybe on a heavily loaded machine that's too early?
  */
  for (int k= 0; k < 100; ++k)
  {
    QThread48::msleep(10);
    if (debuggee_state == DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP) break;
  }
  QThread48::msleep(10); /* in case debuggee_wait_loop() fails immediately */
  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    /* Todo: if somehow (bizarrely) debuggee_state >= 0, then the thread did not end and needs to be stopped. */
    debug_delete_tab_widgets();
    sprintf(error_message, er_strings[er_off + ER_DEBUGGEE_NOT_RESPONDING], debuggee_state);
    if (debug_error(error_message) != 0) return;
  }
  /*
    Attach to the debuggee.
    Todo: Check: is it possible for this to fail because thread has not connected yet? If so, sleep + repeat?
    Todo: Check: why use insertPlainText not setPlainText?
  */
  strcpy(call_statement, "call xxxmdbug.command('");
  strcat(call_statement, debuggee_channel_name);
  strcat(call_statement, "', 'attach');\n");
  if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement)))
  {
    /* Attach failed. Doubtless there's some sort of error message. Put it out now, debug_exit_go() won't override it. */
    put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
    debug_exit_go(1); /* This tries to tell the debuggee to stop, because we're giving up. */
    return;
  }
  debug_timer_old_line_number= -1;
  debug_timer_old_schema_identifier[0]= '\0';
  debug_timer_old_routine_identifier[0]= '\0';
  debug_timer_old_commands_count= -1;
  debug_timer_old_number_of_status_message= -1;
  debug_timer_old_icc_count= -1;
  debug_timer_old_debug_widget_index= -1;
  debug_timer->start(DEBUG_TIMER_INTERVAL);
  /* By the way, we fill in [schema.] if it's missing, because otherwise default would be 'test'. */

  //  strcpy(call_statement, "debug ");
  //if (strcmp(routine_schema, "") != 0)
  //{
  //  strcat(call_statement, routine_schema);
  //  strcat(call_statement, ".");
  //}
  //strcat(call_statement, routine_name);

  if (debug_call_xxxmdbug_command(command_string) != 0)
  {
    /* Debug failed. Doubtless there's some sort of error message. Put it out now, debug_exit_go() won't override it. */
    put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
    debug_exit_go(1); /* This tries to tell the debuggee to stop, because we're giving up. */
    return;
  }
  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
  /* TODO: next line was removed TEMPORARILY. But maybe highlighting will occur due to temporary breakpoint? */
  //debug_highlight_line(); /* highlight the first line. todo: should be the first executable line, no? */
  debug_top_widget->show(); /* Is this necessary? I think so because initially debug_window should be hidden. */
  debug_menu_enable_or_disable(TOKEN_KEYWORD_DEBUG_DEBUG);             /* Until now most debug menu items were gray. */
}


/*
  Change the contents of debug_widget[debug_widget_index]->prompt_as_input_by_user.
  action: 0 = initialize/clear, 1 = add breakpoint, 2 = delete breakpoint, 3 = add tbreakpoint
  line_number: irrelevant if action == 0, else line number for add/clear
  We have to set the prompt -- the separated-from-the-text stuff on the left -- so that it shows
  the line numbers with \2 \L, and shows the breakpoints with K(line-number).
  We avoid 'refresh breakpoints' because it waits for debuggee to be free; hope it doesn't get out of synch.
  We should end up with something like "\2 \L \K(5,red,) \K(4,red,)" if there are breakpoints on line 5 and line 4.
  Todo: Even if we're doing adds, do all the deletes first so that if this is called twice there won't be a duplicate.
        (Todo: I think the debuggee would not make duplicates, but that needs checking.)
  Todo: breakpoint and tbreakpoint look the same in this scheme.
*/
void MainWindow::debug_maintain_prompt(int action, int debug_widget_index, int line_number)
{
  if (action == 0)                                                         /* clear */
  {
    debug_widget[debug_widget_index]->prompt_as_input_by_user= (QString)"\\2 \\L";
    return;
  }
  QString prompt_including_symbol;
  QString breakpoint_symbol;

  prompt_including_symbol= (QString)" \\K(";
  prompt_including_symbol.append(QString::number(line_number));
  breakpoint_symbol= QChar(0x24b7);                                        /* CIRCLED LATIN CAPITAL LETTER B */
  prompt_including_symbol.append(",red,");
  prompt_including_symbol.append(breakpoint_symbol);
  prompt_including_symbol.append(")");

  if (action == 2)                                                        /* delete (well, actually: clear */
  {
    /* I don't expect that indexOf() could return -1, and I ignore it if it does happen. */
    int index_of_prompt;
    index_of_prompt= debug_widget[debug_widget_index]->prompt_default.indexOf(prompt_including_symbol);
    if (index_of_prompt >= 0) debug_widget[debug_widget_index]->prompt_default.remove(index_of_prompt, prompt_including_symbol.size());
    index_of_prompt= debug_widget[debug_widget_index]->prompt_as_input_by_user.indexOf(prompt_including_symbol);
    if (index_of_prompt >= 0) debug_widget[debug_widget_index]->prompt_as_input_by_user.remove(index_of_prompt, prompt_including_symbol.size());
  }
  if ((action == 1) || (action == 3))                                    /* add */
  {
    debug_widget[debug_widget_index]->prompt_default.append(prompt_including_symbol);
    debug_widget[debug_widget_index]->prompt_as_input_by_user.append(prompt_including_symbol);
  }
}


/*
  Find out what is current routine and current line, put a symbol beside it.
  Execute a command e.g. "debug test.p8 5".
  So far: we get block_number = current line number - 1.
  Todo: we don't show the B in a circle!
  Do not confuse with action_mousebuttonpress which also generates "$breakpoint ...".
*/
void MainWindow::action_debug_breakpoint(bool is_checked)
{
  (void)is_checked;
  log("action_debug_breakpoint", 90);
  char command[512];
  int line_number;
  char line_number_as_string[10];

  int debug_widget_index= debug_tab_widget->currentIndex();
  /* I can't imagine how currentIndex() could be == -1, but if it is, do nothing. */
  if (debug_widget_index < 0) return;
  line_number= debug_widget[debug_widget_index]->block_number + 1;
  sprintf(line_number_as_string, "%d", line_number);
  strcpy(command, "$BREAKPOINT ");
  strcat(command, debug_routine_schema_name[debug_widget_index].toUtf8());
  strcat(command,".");
  strcat(command, debug_routine_name[debug_widget_index].toUtf8());
  strcat(command, " ");
  strcat(command, line_number_as_string);

  statement_edit_widget->setPlainText(command);
  action_execute(1);
}


/*
  "breakpoint" and "clear" and "tbreakpoint" have the same argument syntax so we use the same routine for all,
  passing statement_type == TOKEN_KEYWORD_DEBUG_BREAKPOINT or TOKEN_KEYWORD_DEBUG_CLEAR.
  Todo: "$breakpoint ... hit_count = N" is not working.
  Todo: "$breakpoint ... variable_name <> old" is not working.
*/
void MainWindow::debug_breakpoint_or_clear_go(int statement_type, QString text)
{
  char command_string[512];
  int index_of_number_1, index_of_number_2;
  QString routine_name;
  QString schema_name;

  /* Todo: Check that 'debug' has happened */
  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_error((char*)er_strings[er_off + ER_NO_DEBUG_SESSION]) != 0) return;
  }

  if (debug_parse_statement(text, command_string, &index_of_number_1, &index_of_number_2) < 0)
  {
    char error_message[512];
    if (statement_type == TOKEN_KEYWORD_DEBUG_BREAKPOINT)
      strcpy(error_message, er_strings[er_off + ER_BREAKPOINT_SYNTAX]);
    else if (statement_type == TOKEN_KEYWORD_DEBUG_TBREAKPOINT)
      strcpy(error_message, er_strings[er_off + ER_TBREAKPOINT_SYNTAX]);
    else
      strcpy(error_message, er_strings[er_off + ER_CLEAR_SYNTAX]);
    if (debug_error(error_message) != 0) return;
  }
  schema_name= debug_q_schema_name_in_statement;
  routine_name= debug_q_routine_name_in_statement;

  if ((schema_name == "") || (routine_name == ""))
  {
    if (debug_error((char*)er_strings[er_off + ER_MISSING_ROUTINE_NAME]) != 0) return;
  }

  if (debug_error((char*)"") != 0) return;

  if (debug_call_xxxmdbug_command(command_string) != 0)
  {
    put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
    return;
  }

  /* Figure out line number and debug_widget_index from the index variables. */
  /* Todo: This is failing to compare schema name. */

  int debug_widget_index;

  for (debug_widget_index= 0; debug_widget_index < DEBUG_TAB_WIDGET_MAX; ++debug_widget_index)
  {
    if (debug_widget[debug_widget_index] != 0)
    {
      if ((QString::compare(routine_name, debug_routine_name[debug_widget_index]) == 0)
       && (QString::compare(schema_name, debug_routine_schema_name[debug_widget_index]) == 0)) break;
    }
  }

  if (debug_widget_index == DEBUG_TAB_WIDGET_MAX)
  {
    if (debug_error((char*)"No such routine") != 0) return;
  }

  int line_number_1, line_number_2;
  QString q_line_number;
  q_line_number= text.mid(main_token_offsets[index_of_number_1], main_token_lengths[index_of_number_1]);
  line_number_1= q_line_number.toInt();
  if (index_of_number_2 == -1) line_number_2= line_number_1;
  else
  {
    q_line_number= text.mid(main_token_offsets[index_of_number_2], main_token_lengths[index_of_number_2]);
    line_number_2= q_line_number.toInt();
  }

  for (int i= line_number_1; i <= line_number_2; ++i)
  {
    if (i > debug_widget[debug_widget_index]->blockCount())
    {
      break;
    }
    if (statement_type == TOKEN_KEYWORD_DEBUG_BREAKPOINT) debug_maintain_prompt(1, debug_widget_index, i);
    if (statement_type == TOKEN_KEYWORD_DEBUG_CLEAR) debug_maintain_prompt(2, debug_widget_index, i);
    if (statement_type == TOKEN_KEYWORD_DEBUG_TBREAKPOINT) debug_maintain_prompt(3, debug_widget_index, i);
  }
  /*
    Todo: I have had trouble, sometimes the breakpoint symbols don't show up unless I click on the line.
          I think that one of these kludges is helping, but I don't know if it always helps,
          and I don't know which of the two lines is actually fixing the problem,
          and I don't know whether there's a better way. So find out, eh?
  */
  debug_widget[debug_widget_index]->repaint();
  debug_widget[debug_widget_index]->viewport()->update();
  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
}


/*
  Todo: The problem with "delete n" is we don't know which breakpoint is n.
  Of course it's in xxxmdbug.breakpoints, but "r breakpoints" only works if we're at a breakpoint.
*/
void MainWindow::debug_delete_go()
{
  make_and_put_message_in_result(ER_DELETE_STATEMENT, 0, (char*)"");
}


/*
  We will get here if mouse button pressed on debug_tab_widget (we don't know which debug_widget yet, possibly none of them).
  What's it good for? Probably this will be the main way to set a breakpoint.
  I think we'll need to find a right mousebutton press and put up a menu.
  But maybe it would be better if debug_window had a menu bar.
  In ddd, one of the many options is: double-click. But I didn't succeed with doubleclick.
  Todo: figure out what to do if there's already a breakpoint here. Clear it? Right now we're just duplicating it.
*/
void MainWindow::action_debug_mousebuttonpress(QEvent *event, int which_debug_widget_index)
{
  log("action_debug_mousebutonpress", 90);
  int line_number;
  char command[1280];
  char schema_name[512];
  char routine_name[512];
  int debug_widget_index;

  QMouseEvent *mouse_event= static_cast<QMouseEvent*> (event);            /* Get line number where mousepress happened */
  QPoint point= mouse_event->pos();
  debug_widget_index= debug_tab_widget->currentIndex();
  /* I saw a crash once so maybe these checks aren't to paranoid. But I don't know whether they avoid the crash. */
  if (debug_widget_index == -1) return;                                   /* Check for an impossible condition */
  if (debug_widget_index > DEBUG_TAB_WIDGET_MAX) return;                  /* "" */
  if (which_debug_widget_index >= debug_tab_widget->count()) return;      /* "" */
  if (which_debug_widget_index != debug_widget_index) return;             /* "" */
  QTextCursor text_cursor= debug_widget[debug_widget_index]->cursorForPosition(point);
  line_number= text_cursor.blockNumber() + 1;

  strcpy(schema_name, debug_routine_schema_name[debug_widget_index].toUtf8());
  strcpy(routine_name, debug_routine_name[debug_widget_index].toUtf8());

  sprintf(command, "$breakpoint %s.%s %d", schema_name, routine_name, line_number);
  statement_edit_widget->setPlainText(command);                           /* Execute "$breakpoint ..." */
  action_execute(1);
}


/*
  Debug|Clear
  Similar code is in action_debug_breakpoint().
  Do not confuse with Debug|Delete: "$delete 5" clears a breakpoint #5.
  Todo: Check that somewhere something says debug_maintain_prompt(2, debug_widget_index, line_number);
*/
void MainWindow::action_debug_clear(bool is_checked)
{
  (void)is_checked;
  log("action_debug_clear", 90);
  char command[512];
  int line_number;
  char line_number_as_string[10];

  int debug_widget_index= debug_tab_widget->currentIndex();
  /* I can't imagine how currentIndex() could be == -1, but if it is, do nothing. */
  if (debug_widget_index < 0) return;
  line_number= debug_widget[debug_widget_index]->block_number + 1;
  sprintf(line_number_as_string, "%d", line_number);
  strcpy(command, "$CLEAR ");
  strcat(command, debug_routine_schema_name[debug_widget_index].toUtf8());
  strcat(command,".");
  strcat(command, debug_routine_name[debug_widget_index].toUtf8());
  strcat(command, " ");
  strcat(command, line_number_as_string);
  statement_edit_widget->setPlainText(command);
  action_execute(1);
}


/*
  Debug|Continue -- "CALL xxxmdbug.command([channel-name],'continue');" as a client statement
*/
void MainWindow::action_debug_continue(bool is_checked)
{
  (void)is_checked;
  log("action_debug_continue", 90);
  statement_edit_widget->setPlainText("$CONTINUE");
  action_execute(1);
}

/*
  Debug|Step
  This is much like Debug|Continue, but we don't care if we end up on a permanent breakpoint.
*/
void MainWindow::action_debug_step(bool is_checked)
{
  (void)is_checked;
  log("action_debug_step", 90);
  statement_edit_widget->setPlainText("$STEP");
  action_execute(1);
}

/*
  Debug|Leave
  This isn't working quite right. It gets out of loops, but if it's
  in a subroutine then it will try to execute all the way to the end
  of the main routine. (A breakpoint can stop that from happening.)
  So we will allow the $LEAVE statement but not advertise it on the menu.
*/
//void MainWindow::action_debug_leave()
//{
//    statement_edit_widget->setPlainText("$LEAVE");
//    action_execute(1);
//}


/* $SKIP seems to act like $CONT which isn't terribly useful */
void MainWindow::debug_skip_go()
{
  make_and_put_message_in_result(ER_SKIP_STATEMENT, 0, (char*)"");
}


void MainWindow::debug_source_go()
{
  make_and_put_message_in_result(ER_SOURCE_STATEMENT, 0, (char*)"");
}


/*
  $SET declared_variable_name = value;
  Todo: As an additional error check: look up declared_variable_name in xxxmdbug.variables.
  TODO: BUG: $set x = 'literal'; results in a syntax error so say only numbers are allowed.
*/
void MainWindow::debug_set_go(QString text)
{
  char command_string[5120];
  int index_of_number_1, index_of_number_2;

  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_error((char*)er_strings[er_off + ER_NO_DEBUG_SESSION]) != 0) return;
  }
  if (debug_parse_statement(text, command_string, &index_of_number_1, &index_of_number_2) < 0)
  {
    if (debug_error((char*)er_strings[er_off + ER_OVERFLOW]) != 0) return;
    return;
  }
  debug_call_xxxmdbug_command(command_string);
  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
}


/*
  $execute sql-statement
  todo: this will fail if first token is a comment
  todo: get rid of this, it fails
*/
void MainWindow::debug_execute_go()
{
  make_and_put_message_in_result(ER_EXECUTE_STATEMENT, 0, (char*)"");

//  QString s;
//  char command_string[5120];
//  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
//  {
//    if (debug_error((char*)"No debug session in progress") != 0) return;
//  }
//  if (debug_error((char*)"") != 0) return;
//
//  s= "execute ";
//  s.append(text.right(text.length() - (main_token_offsets[main_token_number] + main_token_lengths[main_token_number])));
//  QMessageBox msgbox;
//  msgbox.setText(s);
//  msgbox.exec();
//  strcpy(command_string, s.toUtf8());
//  printf("command_string=%s.\n", command_string);
//  debug_call_xxxmdbug_command(s.toUtf8());
//  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
////  put_message_in_result("This statement is not supported at this time");
}


/* For: $next, $continue, $refresh */
/* The following could be used for all the $... statements where one merely passes the command on to the debuggee */
/* We strip the comments and the ; but if there's junk after the first word it will cause an error, as it should. */
/* Todo: Should you add a semicolon? */
/* Todo: For some reason "$refresh variables;" returns a message with
   ok, 40 rows affected", I don't know where the 40 came from. */
void MainWindow::debug_other_go(QString text)
{
  char command_string[512];
  int index_of_number_1, index_of_number_2;
  QString q_schema_name, q_routine_name;

  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_error((char*)er_strings[er_off + ER_NO_DEBUG_SESSION]) != 0) return;
  }
  if (debug_parse_statement(text, command_string, &index_of_number_1, &index_of_number_2) < 0)
  {
    if (debug_error((char*)er_strings[er_off + ER_OVERFLOW]) != 0) return;
    return;
  }
  q_schema_name= debug_q_schema_name_in_statement;
  q_routine_name= debug_q_routine_name_in_statement;
  if (debug_error((char*)"") != 0) return;
  if (debug_call_xxxmdbug_command(command_string) != 0) return;
  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
}


/*
  Debug|Next
*/
void MainWindow::action_debug_next(bool is_checked)
{
  (void)is_checked;
  log("action_debug_next", 90);
  statement_edit_widget->setPlainText("$NEXT");
  action_execute(1);
}


/*
  Debug|Skip
  Commented out -- not working at this time
*/
//void MainWindow::action_debug_skip()
//{
//  statement_edit_widget->setPlainText("$SKIP");
//  action_execute(1);
//}


/*
  Given 'information status' schema + routine name, find out what the tab number is and make it current.
  Then change the cursor to point to a particular line.
  After the cursor is set to the line, the CodeEditor's highlightCurrentLine wil highlight it.
  Remember, blockNumber() is base 0
  Todo: If the call was completed, you shouldn't be here -- the line number will be too big!
*/
void MainWindow::debug_highlight_line()
{
  QTextCursor cursor;
  int debug_widget_index;
  int new_line_number;
  QString debuggee_schema_identifier;
  QString debuggee_routine_identifier;

  for (debug_widget_index= 0; debug_widget_index < DEBUG_TAB_WIDGET_MAX; ++debug_widget_index)
  {
    debuggee_schema_identifier= debuggee_information_status_schema_identifier;
    debuggee_schema_identifier= connect_stripper(debuggee_schema_identifier, false);
    debuggee_routine_identifier= debuggee_information_status_routine_identifier;
    debuggee_routine_identifier= connect_stripper(debuggee_routine_identifier, false);
    if (QString::compare(debuggee_schema_identifier, debug_routine_schema_name[debug_widget_index]) == 0)
    {
      if (QString::compare(debuggee_routine_identifier, debug_routine_name[debug_widget_index]) == 0)
      {
        break; /* now we know that debug_widget_index is for the tab of the routine the debuggee's at */
      }
    }
  }

  if (debug_widget_index >= DEBUG_TAB_WIDGET_MAX)
  {
    /* I think it's impossible that routine won't be there, but if it isn't, do nothing. */
    /* Well, not quite impossible -- schema or routine might be "unknown" or "". That's probably harmless. */
    /* Todo: Change status line, on supposition that the routine has not started or has ended. */
      return;
  }

  debug_tab_widget->setCurrentWidget(debug_widget[debug_widget_index]);

  new_line_number= atoi(debuggee_information_status_line_number);

  --new_line_number;

  /*
    Something like QTextCursor::HighlightCurrentLine. Make the background light red.
    This cancels the "current line" background (which is light yellow), and can be cancelled by it -- I think that's okay.
  */

  /* If this is a different debug_widget than the last one, this should turn highlight off for the last one. */
  if (debug_widget_index != debug_timer_old_debug_widget_index)
  {
    if (debug_timer_old_debug_widget_index != -1)
    {
      /* if (debug_timer_old_debug_widget_index != -1) */ /* identicalInnerCondition */
      {
        QList<QTextEdit::ExtraSelection> old_extraSelections;
        debug_widget[debug_timer_old_debug_widget_index]->setExtraSelections(old_extraSelections);
      }
    }
    debug_timer_old_debug_widget_index= debug_widget_index;
  }

  QList<QTextEdit::ExtraSelection> extraSelections;

  QTextEdit::ExtraSelection selection;

  /* debug highlight color = current line color e.g. yellow, but faded */
  QColor lineColor= QColor(ocelot_statement_highlight_current_line_color).lighter(160);

  QTextDocument* doc= debug_widget[debug_widget_index]->document();
  QTextBlock block;
  /* new_line_number will be -2 if "debuggee_wait_loop ended". probably -1 is impossible */
  if (new_line_number == -2) block= doc->findBlockByNumber(doc->blockCount() - 1);
  else if (new_line_number < 0) block= doc->findBlockByNumber(0);
  else block= doc->findBlockByNumber(new_line_number);
  int pos= block.position();

  selection.format.setBackground(lineColor);
  selection.format.setProperty(QTextFormat::FullWidthSelection, true);
  selection.cursor= QTextCursor(doc);
  selection.cursor.setPosition(pos, QTextCursor::MoveAnchor);
  selection.cursor.setPosition(pos + 1, QTextCursor::KeepAnchor);
  selection.cursor.clearSelection();
  extraSelections.append(selection);
  debug_widget[debug_widget_index]->setExtraSelections(extraSelections);

  /*
    I don't understand why selection.cursor.setPosition(pos) does not
    really move the cursor, I think it's got do with whether the cursor
    is a copy. Anyway, without the following code, if the highlighted
    line moves off the screen, it won't be visible unless the user
    scrolls up or down.
    The user can move the cursor too, this only overrides temporarily.
  */
  QTextCursor c =  debug_widget[debug_widget_index]->textCursor();
  c.setPosition(pos);
  debug_widget[debug_widget_index]->setTextCursor(c);
  //debug_widget[debug_widget_index]->ensureCursorVisible(); /* I think we don't need this */
}


/*
  Debug|Delete
*/
//void MainWindow::action_debug_delete()
//{
//  printf("STUB: delete\n");
//}


/*
  Debug|Exit
  = "CALL xxxmdbug.command([channel-name],'exit');" as a client statement
  Check debuggee_state. If it's not DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP, debuggee_wait_loop() is not going on. THIS APPLIES FOR MANY COMMANDS!
  Send "exit" command, which should cause debuggee to exit debuggee_wait_loop() and return from the thread function.
  Wait up to 1 second for "exit" to work.
  If it didn't work, "kill debuggee-connection-id".
  TODO: If debuggee fails to respond, it's up to you to kill it.
  TODO: Call this when main window exits, otherwise the thread's connection is immortal.
  TODO: I wish there was some way to clear up init_connect now too.
  Todo: menu item to shut down debugger, and hide debug_tab_widget, close the connection, and kill the thread.
  Todo: when would you like to get rid of debug_widgets[]?
  We call debug_menu_enable_or_disable(TOKEN_KEYWORD_DEBUG_EXIT) after calling debug_exit_go().
*/
void MainWindow::action_debug_exit(bool is_checked)
{
  (void)is_checked;
  log("action_debug_exit", 90);
  statement_edit_widget->setPlainText("$EXIT");
  action_execute(1);
}


/* flagger == 0 means this is a regular $exit; flagger == 1 means we're getting rid of stuff due to a severe severe error */
void MainWindow::debug_exit_go(int flagger)
{
  log("debug_exit_go", 90);
  char call_statement[512];

  QAction *menu_debug_action_file_exit= menu_spec_find_action("action_debug_exit");
  if ((menu_debug_action_file_exit != NULL) && (flagger == 0))
  {
    /* Todo: merge this with debug_error somehow, and make sure nothing's enabled/disabled unless debug/exit succeeded! */
    if (menu_debug_action_file_exit->isEnabled() == false)
    {
      make_and_put_message_in_result(ER_DEBUG_NOT_DONE, 0, (char*)"");
      return;
    }
  }
  debug_top_widget->hide();
  debug_timer->stop();
  /* Todo: more cleanup e.g. kill the debuggee thread, close the connection, even if it's not responding */
  /* Todo: yet more cleanup if you want to get rid of the setup result */

  debug_delete_tab_widgets();

  if (debuggee_state == DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_call_xxxmdbug_command("exit") != 0)
    {
      put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
      return;
    }
    for (int kk= 0; kk < 10; ++kk) {QThread48::msleep(100); if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP) break; }
    if ((debuggee_state == DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP) && (debuggee_connection_id != 0))
    {
      sprintf(call_statement, "kill %d", debuggee_connection_id);

      if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement)))
      {
        sprintf(call_statement, "SIGNAL SQLSTATE '05678' SET message_text='exit failed and kill failed -- try executing manually: kill %d'", debuggee_connection_id);
        lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement));
      }
    }
  }

  /* This should erase left-over messages in the pipe, such as the 'i status' message. Probably there's only one. */
  QString error_return;
  sprintf(call_statement, "%s%s%s","call xxxmdbug.dbms_pipe_receive('xxxmdbug_",debuggee_channel_name,
          "', 1, @xxxmdbug_tmp_1, @xxxmdbug_tmp_2)");
  for (int i= 0; i < 50; ++i)                                              /* 50 is an arbitrary big number */
  {
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement))) break;
    error_return= select_1_row("select @xxxmdbug_tmp_1");
    if (error_return != "") break;
    if (select_1_row_result_1 == "") break;
  }

  /* $install was saying "Suggested next step is: $EXIT" even though $EXIT was already done. */
  debuggee_state= DEBUGGEE_STATE_0;

  /*
     We call pthread_join so that memory is freed.
     But it might wait forever if debug thread is loopy.
     Perhaps we should kill the thread if we suspect that.
     Anyway: $exit is slow, and pthread_join is probably the cause.
  */
  if (debug_thread_exists == true)
  {
    int pthread_join_result= pthread_join(debug_thread_id, NULL);
#if defined(NDEBUG)
    if (pthread_join_result != 0) {printf("assert(pthread_join_result == 0);"); exit(1); }
#else
    assert(pthread_join_result == 0);
#endif
    debug_thread_exists= false;
  }

  if (flagger == 0)
  {
    put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0); /* This should show the result of the final call or select, so it should be "ok" */
  }
}


/* This is called from $exit, but also might be called from $debug if $debug fails */
/* We're reversing the effects of "new CodeEditor() and "addTab()" in debug_debug_go(). */
void MainWindow::debug_delete_tab_widgets()
{
  debug_tab_widget->clear(); /* equivalent to removeTab() for all tab widgets */
  for (int debug_widget_index= 0; debug_widget_index < DEBUG_TAB_WIDGET_MAX; ++debug_widget_index)
  {
    if (debug_widget[debug_widget_index] != 0)
    {
      debug_widget[debug_widget_index]->removeEventFilter(this);
      delete debug_widget[debug_widget_index];
      debug_widget[debug_widget_index]= 0;
    }
  }
}


/*
  Debug|Information
*/
void MainWindow::action_debug_information(bool is_checked)
{
  (void)is_checked;
  log("action_debug_information", 90);
  if (debug_call_xxxmdbug_command("information status") != 0) return;
  statement_edit_widget->insertPlainText("select * from xxxmdbug.information_status;");
  action_execute(1);
}


/*
  Debug|Refresh server variables
*/
void MainWindow::action_debug_refresh_server_variables(bool is_checked)
{
  (void)is_checked;
  log("action_debug_refresh_server_variables", 90);
  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_error((char*)er_strings[er_off + ER_NO_DEBUG_SESSION]) != 0) return;
  }
  if (debug_call_xxxmdbug_command("refresh server_variables") != 0) return;
  statement_edit_widget->insertPlainText("select * from xxxmdbug.server_variables;");
  action_execute(1);
}


/*
  Debug|Refresh user variables
*/
void MainWindow::action_debug_refresh_user_variables(bool is_checked)
{
  (void)is_checked;
  log("action_debug_refresh_user_variables", 90);
  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_error((char*)er_strings[er_off + ER_NO_DEBUG_SESSION]) != 0) return;
  }
  if (debug_call_xxxmdbug_command("refresh user_variables") != 0) return;
  statement_edit_widget->insertPlainText("select * from xxxmdbug.user_variables;");
  action_execute(1);
}


/*
  Debug|Refresh variables
*/
void MainWindow::action_debug_refresh_variables(bool is_checked)
{
  (void)is_checked;
  log("action_debug_refresh_variables", 90);
  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_error((char*)er_strings[er_off + ER_NO_DEBUG_SESSION]) != 0) return;
  }
  if (debug_call_xxxmdbug_command("refresh variables") != 0) return;
  statement_edit_widget->insertPlainText("select * from xxxmdbug.variables;");
  action_execute(1);
}


/*
  Debug|Refresh call_stack
*/
void MainWindow::action_debug_refresh_call_stack(bool is_checked)
{
  (void)is_checked;
  log("action_debug_refresh_call_stack", 90);
  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debug_error((char*)er_strings[er_off + ER_NO_DEBUG_SESSION]) != 0) return;
  }
  if (debug_call_xxxmdbug_command("refresh call_stack") != 0) return;
  statement_edit_widget->insertPlainText("select * from xxxmdbug.call_stack;");
  action_execute(1);
}


/*
  Called from: action_debug_exit(), action_debug_debug(), action_debug_information(),
  and anything else which requires xxxmdbug.command -- except 'attach', except
  'information status' from from action_debug_timer_status().
  Make the SQL statement that is actually executed, but don't trouble the user with
  the details by showing it. For example, if the user said "$DEBUG test.p8", we
  execute "call xxxmdbug.command('channel#...','debug test.p8')" and return the
  result from that.
  Todo: unstripper might be okay but if the command has ''s within ''s
        then converting to 0x... and hex bytes would maybe be better
        (I decided against connect_unstripper since it's not a QString.)
*/
int MainWindow::debug_call_xxxmdbug_command(const char *command)
{
  char call_statement[512];

  char command_unstripped[512];
  QString s= command;
  s= connect_unstripper(s);
  strcpy(command_unstripped, s.toUtf8());

  strcpy(call_statement, "call xxxmdbug.command('");
  strcat(call_statement, debuggee_channel_name);
  strcat(call_statement, "', ");
  strcat(call_statement, command_unstripped);
  strcat(call_statement, ");\n");
  if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement)))
  {
    /* Initially this can happen because we start the timer immediately after we call 'attach'. */
    put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
    return 1;
  }
  debug_statement= command;

  //put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0)???

  /* We no longer try to get the debuggee response with debug_information_status(). */
  //if (strcmp(command, "information status") != 0)
  //{
  //  QString debuggee_response= "Debuggee response = ";
  //  if (debug_information_status((char *)command) != 0)
  //    {
  //    debuggee_response.append("(none). Possibly debuggee is still executing the last command, which was: ");
  //    debuggee_response.append(debuggee_information_status_last_command);
  //  }
  //  else
  //  {
  //    debuggee_response.append(debuggee_information_status_last_command_result);
  //  }
  //  history_edit_widget->append(debuggee_response);
  //}
  return 0;
}


/*
  INFORMATION STATUS -- internal
  We should call this after 'attach' or after 'debug' to see whether there's been some success.
  Most contacts with the debugger should get a quick response, unless the last was 'continue' or 'step ...' (?)
  ... Actually, check that: maybe 'continue' acknowledges receipt before continuing.
  ... And I think that 'continue' will still cause messages, if it's inside stored-procedure code that's being debugged.
*/
int MainWindow::debug_information_status(char *last_command)
{
  int k;

  /* TODO: JUST GET RID OF THIS PROC. I NO LONGER SEE ANY POINT TO IT. */

  for (k= 0; k < 100; ++k)
  {
    /*
       By sleeping, we give the QTimer a chance to call action_debug_timer_status() and update status.
       But it doesn't work! I guess it's because sleeping doesn't restart the event loop!
    */
    QThread48::msleep(100);
    if (strcmp(debuggee_information_status_last_command, last_command) == 0)
    {
      /* todo: this is not enough! you should be checking also if the command number has gone up! */
      break;
    }
  }

  /* k >= 100 means the 100-iteration loop containing a 10-ms sleep has gone by without a match for last_commnd */
  /* the caller will probably generate a warning */
  if (k >= 100) return 1; else return 0;
}


/*
  QTimer *debug_timer: every 100 milliseconds (every 1/10 second), while the debuggee
  is running, the timer event will invoke action_debug_timer() which updates the status.
  Todo: Start it when debuggee starts, stop it when debuggee stops.
  If a new information status message has appeared, display it.
  Todo: make sure timer is stopped before debug_tab_window is closed.
  Todo: This won't necessarily catch errors, because of the 1/10 second intervals and
        because multiple commands can be sent asynchronously. Think of a way!
        Meanwhile, just say: "If you must know the result, you must wait after each command."
  Todo: It would be faster to interpret the 'information status' results in C code here,
        rather than using xxxmdbug.information_status repeatedly.
        Besides, selecting from xxxmdbug.information_status can change the state of the main mysql connection.
        Maybe you should create a different connection?
  Todo: Worry about race conditions. The main thread could look at a status variable before all
        the status variables are updaated by this function. This might be alleviated by
        updating the counter last, but some sort of mutex might have to be considered.
  Todo: Check whether something closes the connection.
        Maybe it would be safest to say that, once a connection is open, it stays open.
        Hmm, why is this a worry, since we're doing the searching on main connection not debuggee connection?
  Todo: I have seen the xxxmdbug.command() cause "send+receive error" meaning a change to init_connect failed.
        Maybe xxxmdbug.commnd() shouldn't try to change init_connect -- after all, we're not trying to send, only receive.
*/
void MainWindow::action_debug_timer_status()
{
  log("action_debug_timer_status", 20);
  char call_statement[512];
  MYSQL_RES *debug_res= NULL;
  MYSQL_ROW row= NULL;
  char unexpected_error[512];
  int unexpected_new_error= 0;
  /*
    DANGER
    When the main line is running SQL statements, it calls
    QApplication::processEvents(), so there can be horrible
    conflicts -- action_debug_timer_status() runs SQL too.
    Either we must disable the Run|Kill feature, or disable
    the timer. Here, we've chosen to disable the timer.
  */
  if (dbms_long_query_state == LONG_QUERY_STATE_STARTED)
  {
    log("action_debug_timer_status return", 20);
    return;
  }
  unexpected_error[0]= '\0';
  strcpy(call_statement, "call xxxmdbug.command('");
  strcat(call_statement, debuggee_channel_name);
  strcat(call_statement, "', 'information status')");

  if (debuggee_state != DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP)
  {
    if (debuggee_state == DEBUGGEE_STATE_DEBUGGEE_WAIT_LOOP_ERROR)
    {
      char tmp[256];
      int l= strlen(debuggee_state_error);
      if (l > 255) l= 255;
      memcpy(tmp, debuggee_state_error, l);
      tmp[l]= '\0';
      sprintf(unexpected_error, er_strings[er_off + ER_DEBUGGEE_WAIT_LOOP], tmp);
    }
    else
    {
      if ((debuggee_state < 0) || (debuggee_state == DEBUGGEE_STATE_END)) strcpy(unexpected_error, "debuggee_wait_loop ended");
      else strcpy(unexpected_error, er_strings[er_off + ER_DEBUGGEE_WAIT_LOOP_IS_NOT]);
    }
  }
  if (unexpected_error[0] == '\0')
  {
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], call_statement, strlen(call_statement)))
    {
      /* Initially this can happen because we start the timer immediately after we call 'attach'. */
      strcpy(unexpected_error, er_strings[er_off + ER_I_STATUS_FAILED]);
    }
  }
  if (unexpected_error[0]== '\0')
  {
    const char *query= "select * from xxxmdbug.information_status";
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], query, strlen(query)))
    {
      strcpy(unexpected_error, er_strings[er_off + ER_I_STATUS_FAILED_NOT_SEVERE]);
    }
  }
  if (unexpected_error[0] == '\0')
  {
    debug_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
    if (debug_res == NULL)
    {
      strcpy(unexpected_error, er_strings[er_off + ER_MYSQL_STORE_RESULT_FAILED]);
    }
  }
  if (unexpected_error[0] == '\0')
  {
    row= lmysql->ldbms_mysql_fetch_row(debug_res);
    if (row == NULL)
    {
      strcpy(unexpected_error, er_strings[er_off + ER_MYSQL_FETCH_ROW_FAILED]);
    }
    else
    {
      if (lmysql->ldbms_mysql_num_fields(debug_res) < 14)
      {
        strcpy(unexpected_error, er_strings[er_off + ER_MYSQL_NUM_FIELDS]);
      }
      else
      {
        /* Just kludging -- I think something is overflowing. Todo: Find out what's really going on. */
        memset(debuggee_information_status_debugger_name, 0, 32);
        memset(debuggee_information_status_debugger_version, 0, 8);
        memset(debuggee_information_status_timestamp_of_status_message, 0, 32);
        memset(debuggee_information_status_number_of_status_message, 0, 8);
        memset(debuggee_information_status_icc_count, 0, 8);
        memset(debuggee_information_status_schema_identifier, 0, 256);
        memset(debuggee_information_status_routine_identifier, 0, 256);
        memset(debuggee_information_status_line_number, 0, 8);
        memset(debuggee_information_status_is_at_breakpoint, 0, 8);
        memset(debuggee_information_status_is_at_tbreakpoint, 0, 8);
        memset(debuggee_information_status_is_at_routine_exit, 0, 8);
        memset(debuggee_information_status_stack_depth, 0, 8);
        memset(debuggee_information_status_last_command, 0, 256);
        memset(debuggee_information_status_last_command_result, 0, 256);
        memset(debuggee_information_status_commands_count, 0, 8);

        if (row[0] != NULL) strncpy(debuggee_information_status_debugger_name, row[0], 32 - 1);
        if (row[1] != NULL) strncpy(debuggee_information_status_debugger_version, row[1], 8 - 1);
        if (row[2] != NULL) strncpy(debuggee_information_status_timestamp_of_status_message, row[2], 32 - 1);
        if (row[3] != NULL) strncpy(debuggee_information_status_number_of_status_message, row[3], 8 - 1);
        if (row[4] != NULL) strncpy(debuggee_information_status_icc_count, row[4], 8 - 1);
        if (row[5] != NULL) strncpy(debuggee_information_status_schema_identifier, row[5], 256 - 1);
        if (row[6] != NULL) strncpy(debuggee_information_status_routine_identifier, row[6], 256 - 1);
        if (row[7] != NULL) strncpy(debuggee_information_status_line_number, row[7], 8 - 1);
        if (row[8] != NULL) strncpy(debuggee_information_status_is_at_breakpoint, row[8], 8 - 1);
        if (row[9] != NULL) strncpy(debuggee_information_status_is_at_tbreakpoint, row[9], 8 - 1);
        if (row[10] != NULL) strncpy(debuggee_information_status_is_at_routine_exit, row[10], 8 - 1);
        if (row[11] != NULL) strncpy(debuggee_information_status_stack_depth, row[11], 8 - 1);
        if (row[12] != NULL) strncpy(debuggee_information_status_last_command, row[12], 256 - 1);
        if (row[13] != NULL) strncpy(debuggee_information_status_last_command_result, row[13], 256 - 1);
        if (row[14] != NULL) strncpy(debuggee_information_status_commands_count, row[14], 8 - 1);
      }
    }
  }
  if (debug_res != NULL) lmysql->ldbms_mysql_free_result(debug_res);
  if (unexpected_error[0] != '\0')
  {
    if (strcmp(debuggee_information_status_last_command_result, unexpected_error) != 0)
    {
      /* This should be considered as a status change, as if it's a new i status message */
      unexpected_new_error= 1;
      int l= strlen(unexpected_error);
      if (l > 255) l= 255;
      memcpy(debuggee_information_status_last_command_result, unexpected_error, l);
      debuggee_information_status_last_command_result[l]= '\0';
    }
  }
    //printf("debuggee_information_status_debugger_name=%s.\n", debuggee_information_status_debugger_name);
    //printf("debuggee_information_status_debugger_version=%s.\n", debuggee_information_status_debugger_version);
    //printf("debuggee_information_status_timestamp_of_status_message=%s.\n", debuggee_information_status_timestamp_of_status_message);
    //printf("debuggee_information_status_number_of_status_message=%s.\n", debuggee_information_status_number_of_status_message);
    //printf("debuggee_information_status_icc_count=%s.\n", debuggee_information_status_icc_count);
    //printf("debuggee_information_status_schema_identifier=%s.\n", debuggee_information_status_schema_identifier);
    //printf("debuggee_information_status_routine_identifier=%s.\n", debuggee_information_status_routine_identifier);
    //printf("debuggee_information_status_line_number=%s.\n", debuggee_information_status_line_number);
    //printf("debuggee_information_status_is_at_breakpoint=%s.\n", debuggee_information_status_is_at_breakpoint);
    //printf("debuggee_information_status_is_at_tbreakpoint=%s.\n", debuggee_information_status_is_at_tbreakpoint);
    //printf("debuggee_information_status_is_at_routine_exit=%s.\n", debuggee_information_status_is_at_routine_exit);
    //printf("debuggee_information_status_stack_depth=%s.\n", debuggee_information_status_stack_depth);
    //printf("debuggee_information_status_last_command=%s.\n", debuggee_information_status_last_command);
    //printf("debuggee_information_status_last_command_result=%s.\n", debuggee_information_status_last_command_result);
    //printf("debuggee_information_status_commands_count=%s.\n", debuggee_information_status_commands_count);

  /* If a status message would probably confuse a rational user, change it. */
    if (strstr(debuggee_information_status_last_command_result, "completed CALL") != NULL)
      strcpy(debuggee_information_status_last_command_result, "Routine has stopped. Suggested next step is: $EXIT");

    if (strstr(debuggee_information_status_last_command_result, "Failed, the expected command is debug") != NULL)
      strcpy(debuggee_information_status_last_command_result, "Routine has stopped and continuing past the end is not possible.  Suggested next step is: $EXIT");

  /*
    When execution ends, we still have line number = 0 and "stopped at breakpoint".
    That's misleading, but rather than change MDBug, let's override what it returns.
    Also: last command isn't always updated if execution has ended.
  */
  if (strcmp(debuggee_information_status_last_command_result, "debuggee_wait_loop ended") == 0)
  {
    strcpy(debuggee_information_status_line_number, "-1");
    strcpy(debuggee_information_status_is_at_breakpoint, "no");
    strcpy(debuggee_information_status_is_at_routine_exit, "yes");
    strcpy(debuggee_information_status_last_command, debug_statement.toUtf8());
    /* todo: what about debuggee_information_status_last_command_result? */
  }
  /*
    Change line_edit i.e. status widget, and maybe change highlight, if there's a new message.
    It would be extremely wasteful to update every time, i.e. every 1/10 second, if there's no change.
    Apparently the change that you can depend on is icc_count, not commands_count or number_of_status_message.
    I don't think there's any need to check whether line number + routine name have changed, but see below.
  */
  if ((debug_timer_old_commands_count != atoi(debuggee_information_status_commands_count))
  ||  (debug_timer_old_number_of_status_message != atoi(debuggee_information_status_last_command))
  ||  (debug_timer_old_icc_count != atoi(debuggee_information_status_icc_count))
  ||  (debug_timer_old_line_number != atoi(debuggee_information_status_line_number))
  ||  (unexpected_new_error == 1))
  {
    char result[2048];
    strcpy(result, "Debugger status = ");
    if (strcmp(debuggee_information_status_schema_identifier, "unknown") != 0)
    {
      strcat(result, "(Current position: ");
      strcat(result, debuggee_information_status_schema_identifier);
      strcat(result, ".");
      strcat(result, debuggee_information_status_routine_identifier);
      strcat(result, " line ");
      strcat(result, debuggee_information_status_line_number);
      strcat(result, ")");
    }
    strcat(result, "(Last debug command: ");
    strcat(result, debuggee_information_status_last_command);
    strcat(result, ", result: ");
    strcat(result, debuggee_information_status_last_command_result);
    strcat(result, ")");

    if (strcmp(debuggee_information_status_is_at_breakpoint, "yes") == 0)
    {
      strcat(result, "(STOPPED AT BREAKPOINT)");
    }

    if (strcmp(debuggee_information_status_is_at_routine_exit, "yes") == 0)
    {
      strcat(result, "(STOPPED AT ROUTINE EXIT)");
    }
    debug_line_widget->setText(result);
    /*
      If and only if the line number or routine name or schema name has changed,
      highlight i.e. change background color in order to show where we're at now.
      Formerly this checked "if (strcmp(debuggee_information_status_is_at_breakpoint, "yes") == 0)"
      i.e. are we at a breakpoint, but I no longer see why that matters.
      Besides, '$breakpoint' does not move the position.
    */
    if ((debug_timer_old_line_number != atoi(debuggee_information_status_line_number))
     || (strcmp(debug_timer_old_schema_identifier, debuggee_information_status_schema_identifier) == 0)
     || (strcmp(debug_timer_old_routine_identifier, debuggee_information_status_routine_identifier) == 0))
    {
      debug_highlight_line();
      debug_timer_old_line_number= atoi(debuggee_information_status_line_number);
      strcpy(debug_timer_old_schema_identifier, debuggee_information_status_schema_identifier);
      strcpy(debug_timer_old_routine_identifier, debuggee_information_status_routine_identifier);
    }
    debug_timer_old_commands_count= atoi(debuggee_information_status_commands_count);
    debug_timer_old_number_of_status_message= atoi(debuggee_information_status_last_command);
    debug_timer_old_icc_count= atoi(debuggee_information_status_icc_count);
  }
  log("action_debug_timer_status end", 20);
}
#endif // if (OCELOT_MYSQL_DEBUGGER == 1)


/*
  For menu item "Execute|Kill" we must start another thread,
  which connects and issues a Kill query-id.
  The kill thread has a subset of the actions of the debug thread so see also debug_thread.
  Possible variant: keep it alive and use it for monitoring.
*/
void* kill_thread(void* unused)
{
  (void) unused; /* suppress "unused parameter" warning */
#if (OCELOT_MYSQL_INCLUDE == 1)
  char call_statement[512];
  int is_connected;
  is_connected= 0;
  kill_state= KILL_STATE_CONNECT_THREAD_STARTED;
  for (;;)
  {
    if (options_and_connect(MYSQL_KILL_CONNECTION, ocelot_ca.database_as_utf8))
    {
      kill_state= KILL_STATE_CONNECT_FAILED;
      break;
    }
    is_connected= 1;
    kill_state= KILL_STATE_IS_CONNECTED;
    sprintf(call_statement, "kill query %d", kill_connection_id);
    if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_KILL_CONNECTION], call_statement, strlen(call_statement)))
    {
      kill_state= KILL_STATE_MYSQL_REAL_QUERY_ERROR;
      break;
    }
    kill_state= KILL_STATE_ENDED;
    break;
  }
  if (is_connected == 1) lmysql->ldbms_mysql_close(&mysql[MYSQL_KILL_CONNECTION]);
  lmysql->ldbms_mysql_thread_end();
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  return ((void*) NULL);
}

bool is_kill_requested;

/*
  Todo: This is no good if the running query isn't
  on the main connection.
*/
void MainWindow::action_run_kill(bool is_checked)
{
  (void)is_checked;
  pthread_t thread_id;

  if (connections_is_connected[0] != 1) return; /* impossible */
  is_kill_requested= true;
  if (dbms_long_query_state == LONG_QUERY_STATE_STARTED)
  {
    kill_connection_id= statement_edit_widget->dbms_connection_id;
    pthread_create(&thread_id, NULL, &kill_thread, NULL);
    /* no pthread_join here -- what would be the point of waiting? */
  }
}

#if (OCELOT_MYSQL_INCLUDE == 1)
/*
  Implementing ^C i.e. control-C i.e. menu item Run|Kill ...
  Once an SQL statement or SQL statement series has been accepted, user input
  is restricted to "kill" (a few other events are tolerated but not ones that cause statements),
  so around the loop inside action_execute() there is some enabling and disabling.
  SQL statements are done in a separate thread, dbms_long_query();
  in the main thread there is a wait-loop which stops when the thread ends;
  the wait-loop includes QApplication::ProcessEvents() so a "Kill" will be seen.
  "Kill" causes the SQL statement to end (if there's one running).
  ^C is an appropriate shortcut although it usually means "clip".
  Kill sets a flag so that if there are multiple statements, they are all aborted.
  dbms_long_query is only for potentially-slow SQL statements that might need to be killed.
  Todo: this could be done via a permanently-existing thread or pool of threads.
  Todo: QThread is more portable than pthread, although it looks harder to understand.
  Todo: put this together with the dbms_* routines in ocelotgui.h in a separate class.
  Normally dbms_query_connection_number is for the main connection.
*/
void* dbms_long_query_thread(void* unused)
{
  (void) unused; /* suppress "unused parameter" warning */

  dbms_long_query_result= lmysql->ldbms_mysql_real_query(&mysql[dbms_query_connection_number], dbms_query, dbms_query_len);
  dbms_long_query_state= LONG_QUERY_STATE_ENDED;
  return ((void*) NULL);
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

#if (OCELOT_MYSQL_INCLUDE == 1)
/* Todo: This assumes connection_number must be MYSQL_MAIN_CONNECTION */
void* dbms_long_next_result_thread(void* unused)
{
  (void) unused; /* suppress "unused parameter" warning */

  dbms_long_query_result= lmysql->ldbms_mysql_next_result(&mysql[MYSQL_MAIN_CONNECTION]);
  dbms_long_query_state= LONG_QUERY_STATE_ENDED;
  return ((void*) NULL);
}
#endif //#if (ocelot_MYSQL_INCLUDE == 1)

void MainWindow::action_run_execute(bool is_checked)
{
  (void)is_checked;
  action_execute(1);
}

/*
  For menu item "execute" we said (...SLOT(action_execute(1))));
  By default this is on and associated with File|Execute menu item.
  Execute what's in the statement widget.
  The statement widget might contain multiple statements.
  Return: 0 = ok, 1 = syntax checker failed with "No"; 2 = DBMS error
  Todo: the enable|disable stuff here should be done for all QMenu items in menu_spec, not the specific predefined ones!
*/
int MainWindow::action_execute(int force)
{
  QString text;
  int return_value= 0;
  log("action_execute start", 90);
  for (;;)
  {
    int returned_begin_count;
    main_token_number= 0;
    text= statement_edit_widget->toPlainText(); /* or I could just pass this to tokenize() directly */
    main_token_count_in_statement= get_next_statement_in_string(main_token_number,
                                                                &returned_begin_count,
                                                                true);
    if (main_token_count_in_statement == 0) break;
    /* If the next statement is unfinished, we usually want to ignore it. */
    if ((force == 0) && (is_statement_complete(text) == false)) return 1;
    /*
      We probably call hparse_f_multi_block continuously during statement edit,
      but this redundancy is harmless (we're not short of time, eh?).
      This checks for errors in the whole string, not just the first statement.
    */
    if (((ocelot_statement_syntax_checker.toInt()) & FLAG_FOR_ERRORS) != 0)
    {
      hparse_f_multi_block(text);
      /* TODO: QMessageBox jiggle, it displays then moves to centre */
      if ((hparse_errno != 0) || (hparse_errno_count != 0))
      {
        Message_box *message_box;
        message_box= new Message_box(er_strings[er_off + ER_THE_SYNTAX_CHECKER_THINKS], hparse_errmsg, 500,
                                     er_strings[er_off + ER_DO_YOU_WANT_TO_CONTINUE],
                                     er_strings[er_off + ER_YES], er_strings[er_off + ER_NO],
                                     this);
        message_box->exec();
        if (message_box->result == 2)
        {
          delete message_box;
          return 1;
        }
        delete message_box;
      }
      log("FLAG_FOR_ERRORS seen. end of if", 90);
    }
    /* While executing, we allow no more statements, but a few things are enabled. */
    /* This makes the menu seem to blink. If that's not OK, turn off sub-items not main menu items. */
    /* Todo: maybe other things should be disabled|enabled as we do with is_can_copy. */
    QAction *menu_edit_action_copy= menu_spec_find_action("action_edit_copy");
    bool is_can_copy; if (menu_edit_action_copy != NULL) is_can_copy= menu_edit_action_copy->isEnabled();
QMenu *menu_file= menu_spec_find_menu("menu_file");
    if (menu_file != NULL) menu_file->setEnabled(false);
QMenu *menu_edit= menu_spec_find_menu("menu_edit");
    if (menu_edit != NULL) menu_edit->setEnabled(false);
    if (menu_edit_action_copy != NULL) menu_edit_action_copy->setEnabled(false);
    QAction *menu_run_action_execute= menu_spec_find_action("action_run_execute");
    if (menu_run_action_execute != NULL) menu_run_action_execute->setEnabled(false);
    QAction *menu_run_action_run_kill= menu_spec_find_action("action_run_kill");
    if (menu_run_action_run_kill != NULL) {if (ocelot_ca.sigint_ignore == 0) menu_run_action_run_kill->setEnabled(true); }
QMenu *menu_settings= menu_spec_find_menu("menu_settings");
    if (menu_settings != NULL) menu_settings->setEnabled(false);
#if (OCELOT_MYSQL_DEBUGGER == 1)
QMenu *menu_debug= menu_spec_find_menu("menu_debug");
    if (menu_debug != NULL) menu_debug->setEnabled(false);
#endif
QMenu *menu_help= menu_spec_find_menu("menu_help");
    if (menu_help != NULL) menu_help->setEnabled(false);
    statement_edit_widget->setReadOnly(true);
    is_kill_requested= false;
    return_value= action_execute_one_statement(text);
    if (menu_file != NULL) menu_file->setEnabled(true);
    if (menu_edit != NULL) menu_edit->setEnabled(true);
    if (menu_edit_action_copy != NULL) menu_edit_action_copy->setEnabled(is_can_copy);
    if (menu_run_action_execute != NULL) menu_run_action_execute->setEnabled(true);
    if (menu_run_action_run_kill != NULL) menu_run_action_run_kill->setEnabled(false);
    if (menu_settings != NULL) menu_settings->setEnabled(true);
#if (OCELOT_MYSQL_DEBUGGER == 1)
    if (menu_debug != NULL) menu_debug->setEnabled(true);
#endif
    if (menu_help != NULL) menu_help->setEnabled(true);
    statement_edit_widget->setReadOnly(false);
    /*
      In remove_statement there is a removeSelectedText() call, which
      causes action_settings_statement_edit_widget_text_changed() -- twice.
      We only want it to happen once, so we'll control it ourselves.
      Importantly, it will call tokenize() and hparse_f_multi_block()
      so main_token_... variables will all change.
      Todo: check again, I think the above statement might be false.
    */
    log("before remove_statement", 90);
    statement_edit_widget_text_changed_flag= 1;
    remove_statement(text);
    statement_edit_widget_text_changed_flag= 0;
    log("after remove_statement", 90);
    action_settings_statement_edit_widget_text_changed(0, 0, 0);
    //widget_sizer();
    /* Try to set history cursor at end so last line is visible. Todo: Make sure this is the right time to do it. */
    history_edit_widget->verticalScrollBar()->setValue(history_edit_widget->verticalScrollBar()->maximum());
    history_edit_widget->show(); /* Todo: find out if this is really necessary */
    if (is_kill_requested == true) break;
  }
  log("action_execute end", 90);
  if (return_value != 0)
  {
    return 2;
  }
  return 0;
}

/*
  Remove the first statement in statement_edit_widget,
  including any whitespace after the statement end.
  This is equivalent to statement_edit_widget->clear() if there is only one statement.
  But when a user has cut-and-pasted several statements, we execute one at a time.
  There are other ways to do this e.g. clear() followed by insertText().
  Unanswered question: do we want to clear undo/redo history?
  Unanswered question: do we want to clear selection?
  Unanswered question: do we want to move the visible cursor?
*/
void MainWindow::remove_statement(QString text)
{
  //statement_edit_widget->clear(); /* ?? this is supposed to be a slot. does that matter? */

  QTextCursor q= statement_edit_widget->textCursor();

  int offset_of_statement_end= 0;

  if (main_token_count_in_statement > 0)
  {
    offset_of_statement_end= main_token_offsets[main_token_count_in_statement - 1]
                             + main_token_lengths[main_token_count_in_statement - 1];
  }

  for (;;)
  {
    QString c= text.mid(offset_of_statement_end, 1);
    if (c == "") break;
    if (c > " ") break;\
    ++offset_of_statement_end;
  }

  q.setPosition(0, QTextCursor::MoveAnchor);
  q.setPosition(offset_of_statement_end, QTextCursor::KeepAnchor);
  q.removeSelectedText();


  //q.select(QTextCursor::LineUnderCursor);

  //statement_edit_widget->textCursor().insertText(text);
}

/*
  Todo: There are a few things yet to be considered.
     I'm not 100% confident about the way I'm clearing the old results out, e.g. "delete result_form_text[...]".
     Would it be more efficient to remove only the ones between new column count and old column count?
       No, because data type can change, it might not be a text field the next time around.
     Should I be saying "delete later" somehow?
     Does memory leak?
*/
int MainWindow::action_execute_one_statement(QString text)
{
  log("action_execute_one_statement", 80);
  log(".. raw:: html", 1000);
  //QString text;
  MYSQL_RES *mysql_res_for_new_result_set= NULL;
  unsigned short int is_vertical= ocelot_ca.vertical; /* true if --vertical or \G or ego */
  /*
    ecs_return = what execute_client_statement() returns = 0 "not client and needs server",
    1 "handled entirely by client (so skip what follows), 2 "?", 3 "ocelot_query_select and does not need server"
  */
  unsigned int ecs_return= 0; /* 1 means "is client statement", 2 dunno, 3 */
  unsigned return_value= 0;
  int ocelot_query_result= 0;
  bool is_ocelot_query_in_client= false;
  unsigned int diagnostic_signal= DIAGNOSTIC_0;
  QString fillup_result;

  ++statement_edit_widget->statement_count;
  /*
    Todo: There should be an indication that something is being executed.
    Possibly, on the title bar, setPlainText(tr("Executing ...")
    Possibly there should be a status widget or a progress bar.
    Whatever it is, turn it on now and turn it off when statement is done.
    Update: the Run|Execute menu item changes, which is slightly helpful.
  */
  /* Apparently there is no need for a call to tokenize() here, it seems certain that it's already been called. */
  int query_utf16_len= main_token_offsets[main_token_number+main_token_count_in_statement - 1]
                       + main_token_lengths[main_token_number+main_token_count_in_statement - 1]
                       - main_token_offsets[main_token_number];

  query_utf16= text.mid(main_token_offsets[main_token_number], query_utf16_len);

  QString last_token;
  bool strip_last_token= false;
  int length_of_last_token_in_statement= main_token_lengths[main_token_number + main_token_count_in_statement - 1];
  int type_of_last_token_in_statement= main_token_types[main_token_number + main_token_count_in_statement - 1];
  last_token= text.mid(main_token_offsets[main_token_number+main_token_count_in_statement - 1],
                       length_of_last_token_in_statement);
  if ((length_of_last_token_in_statement == 1) && ((type_of_last_token_in_statement == TOKEN_KEYWORD_EGO) || (type_of_last_token_in_statement == TOKEN_KEYWORD_GO)))
  {
    length_of_last_token_in_statement= 2;
    strip_last_token= true;
    if (type_of_last_token_in_statement == TOKEN_KEYWORD_EGO) is_vertical= 1;
  }

  /* Strip last word if it's delimiter or (when --named-commands, not only token) go|ego. */
  /* todo: this is obsolete now */
  if (last_token == ocelot_delimiter_str) strip_last_token= true;
  else if ((ocelot_ca.named_commands > 0) && (main_token_count_in_statement > 1))
  {
    if (type_of_last_token_in_statement == TOKEN_KEYWORD_GO) strip_last_token= true;
    if (type_of_last_token_in_statement == TOKEN_KEYWORD_EGO)
    {
      strip_last_token= true;
      is_vertical= 1;
    }
  }
  if (strip_last_token == true)
  {
    query_utf16_copy= text.mid(main_token_offsets[main_token_number], query_utf16_len-length_of_last_token_in_statement);
  }
  else query_utf16_copy= query_utf16;

  statement_edit_widget->start_time= QDateTime::currentMSecsSinceEpoch(); /* will be used for elapsed-time display */
  int additional_result= 0;
  ecs_return= execute_client_statement(text, &additional_result);
  if (ecs_return == 3) is_ocelot_query_in_client= true;
  QString result_set_for_history= "";
  if (ecs_return != 1)
  {
    /* The statement was not handled entirely by the client, it must be passed to the DBMS. */

#if (OCELOT_PLUGIN == 1)
  if (plugin_widget_list.size() > 0)
  {
    ocelot_plugin_pass.query= query_utf16.toUtf8().data();
    int return_code= plugin_widget_list_caller(PLUGIN_EXECUTE_ONE_STATEMENT, "");
    if (return_code ==  PLUGIN_RETURN_OK_AND_REPLACED)
      query_utf16= QString::fromUtf8(ocelot_plugin_pass.replacer_buffer, ocelot_plugin_pass.replacer_buffer_length);
    if (return_code == PLUGIN_RETURN_SKIP) goto statement_is_aborted;
  }
#endif

    bool do_something= true;

    if (is_ocelot_query_in_client == false)
    {
      /* If DBMS is not (yet) connected, except for certain SET ocelot_... statements, this is an error. */
      if ((connections_is_connected[0] == 0) && (ecs_return != 0))
      {
        if (ecs_return == 2) make_and_put_message_in_result(ER_OK, 0, (char*)"");
        else make_and_put_message_in_result(ER_NOT_CONNECTED, 0, (char*)"");
        do_something= false;
      }
    }
    /* If --one-database, and USE caused default database to change, error */
    if ((ocelot_ca.one_database > 0) && (ocelot_database != statement_edit_widget->dbms_database))
    {
      make_and_put_message_in_result(ER_ONE_DATABASE, 0, (char*)"");
      do_something= false;
    }

    if (do_something == true)
    {
      /* Look for a CREATE TABLE statement with a SERVER clause. */
      /* Todo: Make sure you only execute what's in utf16_copy */
      bool is_create_table_server;
#ifdef DBMS_TARANTOOL
      int result= create_table_server(text, &is_create_table_server, main_token_number, main_token_count_in_statement);
      dbms_long_query_result= result;
#else
      dbms_long_query_result= 0;
      is_create_table_server= false;
#endif
      if (is_create_table_server == false)
      {
        bool is_semiselect_seen= false;
#if (OCELOT_EXTENDER == 1)
        QString new_query= "";
        int er_semiselect= ER_OK;
        if ((ocelot_statement_syntax_checker.toInt() & 7) == 7)
        {
          if ((hparse_dbms_mask & FLAG_VERSION_MYSQL_OR_MARIADB_ALL) != 0)
          {
            for (unsigned int i_of_s= main_token_number; i_of_s < main_token_number + main_token_count_in_statement; ++i_of_s)
            {
              if ((main_token_flags[i_of_s] & TOKEN_FLAG_IS_SEMISELECT_ALL) == TOKEN_FLAG_IS_SEMISELECT) { is_semiselect_seen= true; break; }
            }
            if (is_semiselect_seen == true)
            {
              for (unsigned int i_of_s= main_token_number; i_of_s < main_token_number + main_token_count_in_statement; ++i_of_s)
              {
                if ((main_token_flags[i_of_s] & TOKEN_FLAG_IS_SEMISELECT_ALL) != TOKEN_FLAG_IS_SEMISELECT)
                {
                  new_query= new_query + text.mid(main_token_offsets[i_of_s], main_token_lengths[i_of_s]) + " ";
                }
                else
                {
                  /* A semiselect will stretch as far as a closing ) or ; Or: till what's in hparse_f_select_part_2() */
                  unsigned int j_of_s;
                  int parentheses_count= 0; /* this might help with e.g. "(SHOW ERRORS);" */
                  int i_of_mid= -1;
                  int offset_of_into= -1;
                  int innodb_status_count= 0;
                  for (j_of_s= i_of_s + 1; j_of_s < main_token_number + main_token_count_in_statement; ++j_of_s)
                  {
                    if (main_token_types[j_of_s] == TOKEN_TYPE_OPERATOR)
                    {
                      QString s_of_j_of_s= text.mid(main_token_offsets[j_of_s], main_token_lengths[j_of_s]);
                      if (s_of_j_of_s == ";") break; /* todo: check whether we actually ever get here */
                      if (s_of_j_of_s == "(") ++parentheses_count;
                      if (s_of_j_of_s == ")")
                      {
                        --parentheses_count;
                        if (parentheses_count < 0) break;
                      }
                    }
                    if ((main_token_types[j_of_s] == TOKEN_KEYWORD_ENGINE)
                     || (text.mid(main_token_offsets[j_of_s], main_token_lengths[j_of_s]).toUpper() == "INNODB")
                     || (main_token_types[j_of_s] == TOKEN_KEYWORD_STATUS))
                      ++innodb_status_count;
                    if ((main_token_flags[j_of_s]&TOKEN_FLAG_IS_SEMISELECT_ALL) == TOKEN_FLAG_IS_SEMISELECT_MID) /*e.g. "ORDER" */
                      i_of_mid= j_of_s;
                    if ((main_token_flags[j_of_s]&TOKEN_FLAG_IS_SEMISELECT_ALL) == TOKEN_FLAG_IS_SEMISELECT_END) /*e.g. ")" or ";" or "ORDER" */
                    {
                      break;
                    }
                    if (main_token_types[j_of_s] == TOKEN_KEYWORD_INTO)
                    {
                      if ((i_of_mid != -1) && ((unsigned int) i_of_mid <= j_of_s))
                      {
                        offset_of_into= main_token_offsets[j_of_s] - main_token_offsets[i_of_mid];
                      }
                    }
                  }
                  QString semiselect;
                  QString semiselect_part_2;
                  if ((i_of_mid == -1) || ((unsigned int) i_of_mid == j_of_s))
                  {
                    semiselect= text.mid(main_token_offsets[i_of_s], main_token_offsets[j_of_s] - main_token_offsets[i_of_s]);
                    semiselect_part_2= "";
                  }
                  else
                  {
                    semiselect= text.mid(main_token_offsets[i_of_s], main_token_offsets[i_of_mid] - main_token_offsets[i_of_s]);
                    semiselect_part_2= text.mid(main_token_offsets[i_of_mid], main_token_offsets[j_of_s] - main_token_offsets[i_of_mid]);
                  }
                  char error_or_ok_message[256]; /* todo: integrate */
                  QString select_statement;
                  er_semiselect= extender_scan(error_or_ok_message, semiselect, &select_statement, semiselect_part_2, offset_of_into, innodb_status_count);
                  if ((er_semiselect != ER_OK) && (er_semiselect != ER_OK_PLUS) && (er_semiselect != ER_WARNING)) break;
                  new_query= new_query + select_statement;
                  /* Todo: CHECK IF ERROR_OR_OK_MESSAGE IS GOOD */
                  i_of_s= j_of_s - 1;
                }
              }
            }
          }
        }
        if (is_semiselect_seen == true)
        {
          /* if the internal semiselect failed, we'll skip this, so that the error message has internal semiselect result */
          if ((er_semiselect == ER_OK) || (er_semiselect == ER_OK_PLUS) || (er_semiselect == ER_WARNING))
          {
            execute_real_query(new_query, MYSQL_MAIN_CONNECTION, &text);
          }
        }
#endif
        if (is_semiselect_seen == false)
        {
          ocelot_query_result= execute_ocelot_query(query_utf16, MYSQL_MAIN_CONNECTION, &text, &is_ocelot_query_in_client,
                                                    &fillup_result, &diagnostic_signal);
          if (ocelot_query_result == ER_ERROR)
          {
            is_create_table_server= true; /* Fake. it's not create table server but should have same effect. */
            dbms_long_query_result= ocelot_query_result;
          }
          else if (is_ocelot_query_in_client == true)
          {
            dbms_long_query_result= false;
          }
          else
          {
            if (ocelot_query_result == -1) execute_real_query(query_utf16, MYSQL_MAIN_CONNECTION, &text);
            else dbms_long_query_result= ocelot_query_result;
          }
        }
      }
      if (dbms_long_query_result)
      {
        /* beep() hasn't been tested because getting sound to work on my computer is so hard */
        if (ocelot_ca.no_beep == 0) QApplication::beep();
        return_value= 1;
        if (is_create_table_server == false)
          put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, diagnostic_signal);
      }
      else {
        /*
          It was a successful SQL statement, and now look if it returned a result.
          If it did, as determined by looking at the mysql_res that lmysql->ldbms_mysql_store_result() returns,
          then free the previous mysql_res and delete the previous result grid,
          before setting up new ones.
          This means that statements which don't return result sets don't cause clearing
          of old result sets from the screen, e.g. SET has no effect on result grid.
          This means that momentarily there will be an old mysql_res and a new mysql_res.
          That takes up memory. If it were easy to check in advance whether a statement
          caused a result set (e.g. with mysql_next_result or by looking at whether the
          statement is SELECT SHOW etc.), that would be better.
        */
        /* TEMPORARY TEST!!!! */
        ResultGrid *rg;
        if (diagnostic_signal == DIAGNOSTIC_1) goto statement_is_over;
        if (is_ocelot_query_in_client == true)
        {
          rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));
          goto after_fillup;
        }
#ifdef DBMS_TARANTOOL
        if (connections_dbms[0] == DBMS_TARANTOOL)
        {
          if (tarantool_get_result_set(0, 0) == 0) goto statement_is_over; /* if zero result sets, stop */
          mysql_res_for_new_result_set= 0;
//          unsigned int main_token_flags_first;
//          int statement_type= get_statement_type(main_token_number, main_token_count_in_statement, &main_token_flags_first);
//          if ((statement_type == TOKEN_KEYWORD_SELECT)
//           || (statement_type == TOKEN_KEYWORD_VALUES)
//           || (statement_type == TOKEN_KEYWORD_LUA)
//           || ((main_token_flags_first & TOKEN_FLAG_IS_LUA) != 0))
          {
            int result_set_type;
            tarantool_result_set_init(0,&tarantool_row_count[MYSQL_MAIN_CONNECTION],&result_set_type);
            if ((result_set_type == RESULT_TYPE_0) || (result_set_type == RESULT_TYPE_1))
              mysql_res_for_new_result_set= 0;
            else
            {
              /* Yes mysql_res_for_new_result_set will be invalid. Fix, eh? */
              {
                MYSQL_RES r;
                mysql_res_for_new_result_set= &r;
              }
            }
          }
        }
        if (connections_dbms[0] != DBMS_TARANTOOL)
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
        mysql_res_for_new_result_set= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
#else
        {;}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
        if (mysql_res_for_new_result_set == 0)
        {
          /*
            Last statement did not cause a result set. We could hide the grid and shrink the
            central window with "result_grid_tab_widget[0]->hide()", but we don't.
          */
#if (OCELOT_MYSQL_INCLUDE == 1)
          get_sql_mode(main_token_types[main_token_number], text, false, main_token_number);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
          put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, diagnostic_signal);
        }
        else
        {
#ifdef DBMS_TARANTOOL
          if (connections_dbms[0] == DBMS_TARANTOOL)
          {
            /* TODO: Free the last reply, equivalent to mysql_free_result */
            /* (but not this early, because we might call extra_result_sets() */
          }
          else
#endif
          {
          if (mysql_res != 0)
            {
#if (OCELOT_MYSQL_INCLUDE == 1)
              lmysql->ldbms_mysql_free_result(mysql_res); /* This is the place we free if myql_more_results wasn't true, see below. */
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
            }
#if (OCELOT_MYSQL_INCLUDE == 1)
            mysql_res= mysql_res_for_new_result_set;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
            /* We need to think better what to do if we exceed MAX_COLUMNS */
            /* ... or maybe not, it seems we got rid of MAX_COLUMNS */
            /*
              Todo: consider whether it would be appropriate to set grid width with
              result_grid_tab_widget[0]->result_column_count= lmysql->ldbms_mysql_num_fields(mysql_res);
              but it may be unnecessary, and may cause a crash in garbage_collect()
            */
#if (OCELOT_MYSQL_INCLUDE == 1)
            result_row_count= lmysql->ldbms_mysql_num_rows(mysql_res);                /* this will be the height of the grid */
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
          }
          {
            fillup_prepare();
            rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));
            //QFont tmp_font;
            //tmp_font= rg->font();
            fillup_result= rg->fillup(mysql_res,
                    //&tarantool_tnt_reply,
                    connections_dbms[0],
                    //this,
                    lmysql, ocelot_ca.client_side_functions,
                    MYSQL_MAIN_CONNECTION,
                    true);
after_fillup:
            if (fillup_result != "OK")
            {
              /* fillup() failure is unexpected so this is crude */
              put_message_in_result(fillup_result);
              return_value= 1;
              goto statement_is_aborted;
            }
#if (OCELOT_CHART_OR_QCHART == 1)
           /* Kludge. I'd much prefer to know why is repeat needed if it's first select and ocelot_grid_chart exists. */
           bool is_repeat_needed= false;
           if (rg->isVisible() == false)
           {
             if (rg->evaluate_for_chart(true) == true) is_repeat_needed= true;
           }
#endif
            rg->display(0,
                        ocelot_ca.vertical,
                        ocelot_ca.batch, ocelot_ca.html, ocelot_ca.raw, ocelot_ca.xml,
                        ocelot_ca.result_grid_column_names,
                        ocelot_ca.bar, ocelot_ca.line, ocelot_ca.pie);
            result_grid_tab_widget->setCurrentWidget(rg);
            result_grid_tab_widget->tabBar()->hide();
            /* next line redundant? display() ends with show() */
            rg->show();
            result_grid_tab_widget->show(); /* Maybe this only has to happen once */
#if (OCELOT_CHART_OR_QCHART == 1)
            if (is_repeat_needed == true)
            rg->display(0,
                        ocelot_ca.vertical,
                        ocelot_ca.batch, ocelot_ca.html, ocelot_ca.raw, ocelot_ca.xml,
                        ocelot_ca.result_grid_column_names,
                        ocelot_ca.bar, ocelot_ca.line, ocelot_ca.pie);
#endif
          }
          /*
            Following is no-op by default because ocelot_history_max_row_count=0
          */
          log("copy_to_history (before)", 80);
          if ((ocelot_ca.grid_actual_tabs > 0)
           && (result_set_for_history == ""))
          {
            rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));
            result_set_for_history= rg->copy_to_history(ocelot_history_max_row_count.toLong(), is_vertical, connections_dbms[0], NULL);
          }
          log("copy_to_history (after)", 80);
          /* Todo: small bug: elapsed_time calculation happens before lmysql->ldbms_mysql_next_result(). */
          /* You must call lmysql->ldbms_mysql_next_result() + lmysql->ldbms_mysql_free_result() if there are multiple sets */
          put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, diagnostic_signal); /* Do this while we still have number of rows */
          //history_markup_append(result_set_for_history, true);
          int result_grid_table_widget_index= 1;
#ifdef DBMS_TARANTOOL
          if (connections_dbms[0] == DBMS_TARANTOOL)
          {
            int result_set_type;
            for (;;)
            {
              if (tarantool_get_result_set(0, result_grid_table_widget_index) == 0) break;
              tarantool_result_set_init(0,&tarantool_row_count[MYSQL_MAIN_CONNECTION],&result_set_type);
              extra_result_set(result_grid_table_widget_index, is_vertical);
              ++result_grid_table_widget_index;
            }
          }
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
          if ((connections_dbms[0] != DBMS_TARANTOOL)
           && (lmysql->ldbms_mysql_more_results(&mysql[MYSQL_MAIN_CONNECTION])))
          {
            lmysql->ldbms_mysql_free_result(mysql_res);
            /*
              We started with CLIENT_MULTI_RESULT flag (not CLIENT_MULTI_STATEMENT).
              We expect that a CALL to a stored procedure might return multiple result sets
              plus a status result at the end. The following lines try to pick up and display
              the extra result sets, up to a fixed maximum, and just throw away everything
              after that, to avoid the dreaded out-of-sync error message.
              If it's an ordinary select, lmysql->ldbms_mysql_free_result(mysql_res) happens later, see above.
            */
            log("sleep loop start", 90);
            for (;;)
            {
              dbms_long_query_state= LONG_QUERY_STATE_STARTED;
              pthread_t thread_id;
              pthread_create(&thread_id, NULL, &dbms_long_next_result_thread, NULL);

              for (;;)
              {
                QThread48::msleep(10);
                if (dbms_long_query_state == LONG_QUERY_STATE_ENDED) break;
                QApplication::processEvents();
              }
              pthread_join(thread_id, NULL);

              if (dbms_long_query_result != 0)
              {
                return_value= 1;
                /* If mysql_next_result) == 1 means error, -1 means no more. */
                /* TODO: don't do this for SOURCE. Check for beep. */
                if (dbms_long_query_result == 1)
                {
                  put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, diagnostic_signal);
                  //history_markup_append("", true);
                }
                break;
              }
              mysql_res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
              if (mysql_res == NULL) continue;
              extra_result_set(result_grid_table_widget_index, is_vertical);
              ++result_grid_table_widget_index;
              if (mysql_res != 0) lmysql->ldbms_mysql_free_result(mysql_res);
            }
            log("sleep loop end", 90);
            mysql_res= 0;
          }
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
        }
      }
      //put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, diagnostic_signal);
    }
  }
statement_is_over:
  /* statement is over */
  /* todo: bug: start of session has an elapsed time */
  if ((ecs_return == 0) && (connections_dbms[0] == DBMS_TARANTOOL) && (ocelot_query_result != ER_ERROR))
    put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, diagnostic_signal);
statement_is_aborted:
  log("action_execute_one_statement end", 80);
  if (additional_result != TOKEN_KEYWORD_SOURCE)
  {
    history_markup_append(result_set_for_history, true); /* add prompt+statement+result to history, with markup */
    tee_export(result_set_for_history);
  }
  return return_value;
}

/*
  Call this if there is more than one result set.
  From MySQL|MariaDB this can happen if a stored procedure has multiple SELECTs.
  From Tarantool this can happen if a start transaction ... commit|rollback block has multiple SELECTs.
  Make a tabbed widget and put the new result set in the latest tab.
  There is a maximum = result_grid_tabs. There are more commens preceding result_grid_add_tab().
*/
void MainWindow::extra_result_set(int result_grid_table_widget_index, unsigned short int is_vertical)
{
  /* todo: consider appending row count to result message */
  /* I think the following will help us avoid the "status" return. */
  if (result_grid_table_widget_index == ocelot_ca.grid_actual_tabs)
  {
    result_grid_add_tab();
  }

  if (result_grid_table_widget_index < ocelot_ca.grid_actual_tabs)
  {
    ResultGrid* r;
    r= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(result_grid_table_widget_index));
    result_grid_tab_widget->tabBar()->show(); /* is this in the wrong place? */
    if (connections_dbms[0] == DBMS_TARANTOOL)
    { result_row_count= 1; } /* TODO: YOU OUGHT TO BE DOING SOMETHING! */
#if (OCELOT_MYSQL_INCLUDE == 1)
    else
      result_row_count= lmysql->ldbms_mysql_num_rows(mysql_res);                /* this will be the height of the grid */
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
    QString fillup_result= r->fillup(mysql_res,
              //&tarantool_tnt_reply,
              connections_dbms[0],
              //this,
              lmysql,
              ocelot_ca.client_side_functions,
              MYSQL_MAIN_CONNECTION,
              true);

    /* TODO: Check that fillup() returned "OK" before you call display() */
    /*       If fillup_result <> "Ok" pass back up the line */
    /* TODO: this had rg-> rather than r->. I don't know why. Do we need to do more checking? */
    r->display(0,
                is_vertical,
                ocelot_ca.batch, ocelot_ca.html, ocelot_ca.raw, ocelot_ca.xml,
                ocelot_ca.result_grid_column_names,
                ocelot_ca.bar, ocelot_ca.line, ocelot_ca.pie);
    /* next line redundant? display() ends with show() */
    /* what is r? */
    /* TODO: REMOVE IT!!!! */
//    r->show();

    //Put in something based on this if you want extra results to go to history:
    //... result_grid_table_widget[result_grid_table_widget_index]->copy_to_history(); etc.
  }
}

/*
  Bottom-level call to DBMS.
  We call this when we know that there will be no more change
  to the query (no local-subquery substitution, but maybe
  stripping of comments and delimiters other than ;).
  During this query we allocate or use globals:
  dbms_query, dbms_query_len, dbms_query_connection.
  The query might go to either the main or the local
  connection, the local connection might be either
  mysql or tarantool.
  Todo: Tarantool can't be killed so easily. Make a fiber?
*/
int MainWindow::execute_real_query(QString query, int connection_number, const QString *alltext)
{
  log("execute_real_query start", 80);
#if (OCELOT_PLUGIN == 1)
  if (plugin_widget_list.size() > 0)
  {
    ocelot_plugin_pass.query= query.toUtf8().data();
    if (plugin_widget_list_caller(PLUGIN_REAL_QUERY, "") ==  PLUGIN_RETURN_OK_AND_REPLACED)
      query= QString::fromUtf8(ocelot_plugin_pass.replacer_buffer, ocelot_plugin_pass.replacer_buffer_length);
  }
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
  /*
    If the last error was CR_SERVER_LOST 2013 or CR_SERVER_GONE_ERROR 2006,
    and it might be possible to reconnect, try.
    But if mysql_ping() fails, I don't see much that we can do.
  */
  if ((mysql_errno_result == 2006) || (mysql_errno_result == 2013))
  {
    if (ocelot_ca.opt_reconnect > 0) lmysql->ldbms_mysql_ping(&mysql[MYSQL_MAIN_CONNECTION]);
  }
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  /* todo: figure out why you used global dbms_query for this */
  /* TODO: BUG. This statement caused a crash when ocelot_ca.comments == 0:
         create procedure p27 ()
           begin
           declare xxx int;
           declare yyy int;
           set xxx = 0;
           while xxx < 1000 do
             set xxx = xxx;
             set xxx = xxx + 1;
             end while;
           end
      We work around it by allocating double what we need for dbms_query. */
  dbms_query_len= query.toUtf8().size();           /* See comment "UTF8 Conversion" */
  dbms_query= new char[(dbms_query_len + 1) * 2];
  dbms_query_len= make_statement_ready_to_send(query,
                                               dbms_query,
                                               dbms_query_len + 1,
                                               connection_number);
  assert(strlen(dbms_query) < ((unsigned int) dbms_query_len + 1) * 2);
  dbms_query_connection_number= connection_number;
#ifdef DBMS_TARANTOOL
  /* todo: for tarantool as for mysql, call with a separate thread so it's killable and so processsEvents() happens. */
  if (connections_dbms[connection_number] == DBMS_TARANTOOL)
  {
    dbms_long_query_result= tarantool_real_query(dbms_query, dbms_query_len, MYSQL_MAIN_CONNECTION, main_token_number, main_token_count_in_statement, alltext);
    dbms_long_query_state= LONG_QUERY_STATE_ENDED;
  }
  else
#endif
  {
#if (OCELOT_MYSQL_INCLUDE == 1)
    pthread_t thread_id;
    dbms_long_query_state= LONG_QUERY_STATE_STARTED;
    pthread_create(&thread_id, NULL, &dbms_long_query_thread, NULL);
    for (;;)
    {
      QThread48::msleep(10);
      if (dbms_long_query_state == LONG_QUERY_STATE_ENDED) break;
      QApplication::processEvents();
    }
    pthread_join(thread_id, NULL);
    //     dbms_long_query_result= lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], dbms_query, dbms_query_len);
    //     dbms_long_query_state= LONG_QUERY_STATE_ENDED;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  }
  delete []dbms_query;
  log("execute_real_query return", 80);
  return dbms_long_query_result;
}

/*
  Called from ocelot_execute_one_statement()
  SCENARIO 1: done entirely in client, we don't even need to be connected. Preceded by SET ocelot_query:
    INSERT INTO plugins VALUES ('library','action'); library might be called soname in some contexts
    DELETE FROM plugins WHERE action = 'value';
    INSERT INTO menus VALUES ('id', 'menu_title', 'menu_item', 'action');
    UPDATE menus SET menu_item | action | shortcut = 'value' WHERE id = 'value';
    DELETE FROM menus WHERE id = 'value';
    SELECT * FROM plugins | menus | conditional_settings;
    SELECT 'literal' [AS id] [, 'literal' [AS id] ...] UNION ALL SELECT 'literal'[, 'literal' ...
  Re INSERT: Blanks are OK. If thing in menu field already exists and is a menuitem, this will be a submenuitem.
             Special actions, really non-actions
  Todo: There's no UPDATE menus SET menu_title ... which would affect multiple places and might require a new menu.
        There's no way to update a separator.
  Todo: UPDATE menus SET visible='yes|no' ... or SET icon='value' or enabled or other things that affect menu looks
  Todo: BEGIN ... END so there's one big statement that we parse entirely before executing each part
  Todo: CALL plugin-name
  SCENARIO 2: check for "SET ocelot_query =" before calling execute_real_query.
  At the last moment, hijack what's intended for execute_real_query, do whatever is in the string after "=",
  and return something that will look as if we did execute_real_query with the query that the user asked for
  (we actually return a union of selects of literals thus avoiding need for create privileges).
  So far this is only for SET ocelot_query = show foreign keys of [table_schema.]table_name; and
                          SET ocelot_query = show erdiagram of table_schema [options];
  The statement can be generated by an explorer option.
  Todo: "Foreign Key Relationship Diagram" (like an Entity-Relationship Diagram) (idea may be superseded now?)
        Show one table with mono-font ASCII text and arrows (later see how to show with HTML)
        Outgoing and incoming arrows on the right.
        Different colour for each FK.
        Adherence to ER pattern requirements as much as seems reasonable.
        If connected to Tarantool, or unexpected format, just call execute_real_query.
        Allow SHOW INDEXES OF table, + show procedure and trigger relationships somehow
        If a table has more than one foreign key we could do a horizontal rather than vertical display e.g.
            Table#1      Foreign Key #1   Foreign Key #2
                         On Table #2      On Table #2
            -----        --------------   --------------
            Column#1     Column           Column
            Column#2     Column
            Column#3                      Column
  Todo: As in crlf() we could say sorry this won't work unless syntax checker on, or maybe we could call
        hparse_f_multi, instead of doing the specific parsing in this function.
        (Update: now we call hparse_f_multi.)
  Todo: This is a bit obsolete now because when we make explorer visible we permanently set up oei_fk[]
  Warning: the push+pop here will not work if something else pushed and then called here, also some testing is needed
           and push+pop might be slow if there are lots of statements in the input
  Sometimes we might replace query_in_client so that fillup_in_client() will do something local.
  Sometimes connect_unstripper() will be needed

*/
/* the late tokenize only does 10 words, which is enough since I think tokenize() will ignore comments */
#define MAX_OCELOT_STATEMENT_TOKENS 20
int MainWindow::execute_ocelot_query(QString query, int connection_number, const QString *alltext,
                                     bool *is_ocelot_query_in_client, QString *fillup_result, unsigned int *diagnostic_signal)
{
  log("execute_ocelot_query", 80);
  char *fks_query;
  int fks_query_len;
  int counter;
  QString d_table_name, d_column_name, d_ordinal_position, d_constraint_name, d_referenced_table_name, d_referenced_column_name;
  QString fks;
  *is_ocelot_query_in_client= false; /* becomes true again if we do a successful SELECT via this function */
  int *token_offsets; /* hmm, in other places token_offsets is unsigned, I wonder if we ever try to put -1 in it */
  int *token_lengths;
  int *token_types;
  int desired_count;
  bool is_early_return= false;
/* restart: */ /* jump back to here if SELECT * produces a new query */
  main_token_push();
  main_token_new(query.size() + 1); /* This might be needed if --ocelot_query = long statement */
  main_token_lengths[0]= 0;
  tokenize(query.data(),
           query.size(),
           &main_token_lengths[0], &main_token_offsets[0], main_token_max_count,
          (QChar*)"33333", 2, ocelot_delimiter_str, 1);
  tokens_to_keywords(query, 1, sql_mode_ansi_quotes);

  main_token_number= 0;
  hparse_f_multi_block(query);
  if (hparse_errno > 0)
  {
    put_message_in_result(hparse_errmsg);
    main_token_pop();
    return ER_ERROR; /* unfortunately, not hparse_errno, the caller won't check for that */
  }
  /* So now we know there is no syntax error, and the comments are stripped. */
  /* Make a copy of main, possibly with a few slight changes -- here is where we could replace expressions! */

  desired_count= query.length() + 1; /* allocate as if every byte in query is a one-byte token */
  token_offsets= new int[desired_count];
  token_lengths= new int[desired_count];
  token_types= new int[desired_count];

  int j= 0;
  for (int i= 0; ; ++i)
  {
    QString token= query.mid(main_token_offsets[i], main_token_lengths[i]);
    if (token == "-")
    {
      token_offsets[j]= main_token_offsets[i];
      token_types[j]= main_token_types[i];
      token_lengths[j]= 1 + main_token_lengths[i + 1];
      ++i;
      ++j;
      if (main_token_lengths[i] == 0) break;
      continue;
    }
    token_offsets[j]= main_token_offsets[i];
    token_lengths[j]= main_token_lengths[i];
    token_types[j]= main_token_types[i];
    if (main_token_lengths[i] == 0) break;
    ++j;
  }
  main_token_pop(); /* because from now on we will use token_offsets + token_lengths */
  /* Todo: this is okay for menus but missing plugins | conditional_settings */
  if (token_types[3] == TOKEN_KEYWORD_INSERT)
  {
    QString table= query.mid(token_offsets[5], token_lengths[5]).toUpper();
    if (table == "MENUS")
    {
      /* e.g. SET ocelot_query = INSERT INTO menus VALUES ('id','menu_title','menu_item', 'function'); */
      QString id= ""; QString menu_title= ""; QString menuitem= ""; QString function= "";
      int i= 4; int j= 0;
      for (;;++i)
      {
        if (token_lengths[i] == 0) break;
        if (token_types[i] == TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE)
        {
          QString token= query.mid(token_offsets[i], token_lengths[i]);
          token= connect_stripper(token, false);
          if (j == 0) id= token;
          if (j == 1) menu_title= token;
          if (j == 2) menuitem= token;
          if (j == 3) function= token;
          ++j;
        }
      }
      int er= menu_spec_insert_one(id, menu_title, menuitem, function);
      if (er == ER_OK) put_message_in_result("OK, 1 row");
      else put_message_in_result("Error");
      *diagnostic_signal= DIAGNOSTIC_1;
      is_early_return= true;
    }
    else
    {
      /* e.g. INSERT INTO plugins VALUES ('soname','plugin'); */
      /* todo: error message */
      QString plugin_id= query.mid(token_offsets[10], token_lengths[10]);
      plugin_id= connect_stripper(plugin_id, true);
      QString plugin_soname= query.mid(token_offsets[8], token_lengths[8]);
      int er= insert_plugin(plugin_id, plugin_soname, alltext);
      if (er == ER_OK) put_message_in_result("OK, 1 row");
//      else put_message_in_result("Error");
      *diagnostic_signal= DIAGNOSTIC_1;
      is_early_return= true;
    }
  }
  if (main_token_types[3] == TOKEN_KEYWORD_UPDATE)
  {
    /* e.g. SET ocelot_query = UPDATE menus SET shortcut = 'a' WHERE id = 'action_options_line'; */
    QString target= query.mid(token_offsets[6], token_lengths[6]).toUpper();
    QString id= query.mid(token_offsets[12], token_lengths[12]);
    QString value= query.mid(token_offsets[8], token_lengths[8]);
    int er= menu_set_via_id(target, id, value);
    /* We won't get here with er!=0 due to nonexistent id because that's considered a syntax error */
    put_message_in_result(er_strings[er_off + er]);
    *diagnostic_signal= DIAGNOSTIC_1;
    is_early_return= true;
  }
  if (main_token_types[3] == TOKEN_KEYWORD_DELETE)
  {
    /* e.g. SET ocelot_query = DELETE FROM plugins|menus WHERE action = 'b'; */
    QString table= query.mid(token_offsets[5], token_lengths[5]).toUpper();
    QString id= query.mid(token_offsets[9], token_lengths[9]);
    int er;
    if (table == "MENUS") er= menu_spec_delete_via_id(id);
    else { id= connect_stripper(id, false); er= delete_plugin(id); }
    /* We won't get here with er!=0 due to nonexistent id because that's considered a syntax error */
    put_message_in_result(er_strings[er_off + er]);
    *diagnostic_signal= DIAGNOSTIC_1;
    is_early_return= true;
  }
  if (token_types[3] == TOKEN_KEYWORD_SELECT)
  {
    QString result;
    fillup_prepare();
    ResultGrid *rg;
    rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));
    if (query.mid(token_offsets[4], token_lengths[4]) != "*")
    {
      /* For SET ocelot_query = SELECT ... UNION ALL SELECT ..., say *is_ocelot_query_in_client == true and just return */
      *is_ocelot_query_in_client= true;
      result= rg->fillup_in_client(query, token_lengths, token_offsets);
      *fillup_result= result;
      unsigned long r= rg->result_row_count;
      if (r == 1) put_message_in_result("OK, 1 row");
      else put_message_in_result(QString::number(r) + " rows");
      *diagnostic_signal= DIAGNOSTIC_2;
      is_early_return= true;
    }
    else
    {
      /* e.g. SELECT * FROM menus; or SELECT * FROM plugins; or SELECT * FROM conditional_settings; */
      if (query.mid(token_offsets[6], token_lengths[6]).toUpper() == "MENUS")
      {
        query= "";
        for (int i= 0, ngc= 0; i < menu_spec_struct_list.size(); ++i)
        {
//          if ((menu_spec_struct_list[i].menu_type != MENU_SPEC_TYPE_MENUITEM)
//           && (menu_spec_struct_list[i].menu_type != MENU_SPEC_TYPE_SEPARATOR)) continue;
          if (ngc > 0) query= query + " UNION ALL ";
          query= query + "SELECT " + connect_unstripper(menu_spec_struct_list[i].id);
          if (ngc == 0) query= query + " AS id";
          query= query + "," + connect_unstripper(menu_spec_struct_list[i].menu_title);
          if (ngc == 0) query= query + " AS menu_title";
          query= query + "," + connect_unstripper(menu_spec_struct_list[i].menu_item);
          if (ngc == 0) query= query + " AS menu_item";
          query= query + "," + connect_unstripper(menu_spec_struct_list[i].action);
          if (ngc == 0) query= query + " AS action";
          query= query + "," + connect_unstripper(menu_spec_struct_list[i].shortcut);
          if (ngc == 0) query= query + " AS shortcut";
          ++ngc;
        }
      }
      else if (query.mid(token_offsets[6], token_lengths[6]).toUpper() == "PLUGINS")
      {
        if (plugin_widget_list.size() == 0)
        {
          query= "SELECT 'Empty result set' AS EMPTY_SET";
        }
        else /* plugins */
        {
          query= "";
          for (int i= 0; i  < plugin_widget_list.size(); ++i)
          {
            if (i > 0) query= query + " UNION ALL ";
            query= query + "SELECT ";
            Plugin *plugin_widget= plugin_widget_list[i];
            query= query + connect_unstripper(plugin_widget->soname);
            if (i == 0) query= query + " AS library";
            query= query + "," + connect_unstripper(plugin_widget->id);
            if (i == 0) query= query + " AS action";
          }
        }
      }
      else
      {
        if (conditional_settings.count() == 0)
        {
          query= "SELECT 'Empty result set' AS EMPTY_SET";
        }
        else
        {
          query= "";
          for (int i= 0; i  < conditional_settings.count(); ++i)
          {
            if (i > 0) query= query + " UNION ALL ";
            query= query + "SELECT ";
            QString id= "C" + QString::number(i + 1);
            query= query + connect_unstripper(id);
            if (i == 0) query= query + " AS id";
            query= query + "," + connect_unstripper(conditional_settings.at(i));
            if (i == 0) query= query + " AS conditional_setting";
          }
        }
      }
      query= query + ";";
      delete [] token_types;
      delete [] token_lengths;
      delete [] token_offsets;

      desired_count= query.length() + 1; /* allocate as if every byte in query is a one-byte token */
      token_offsets= new int[desired_count];
      token_lengths= new int[desired_count];
      token_types= new int[desired_count]; /* warning: actually we won't recall tokens_to_keywords */
      main_token_lengths[0]= 0;
      tokenize(query.data(),
               query.size(),
               &token_lengths[0], &token_offsets[0], desired_count,
              (QChar*)"33333", 2, ocelot_delimiter_str, 1);
      *is_ocelot_query_in_client= true;
      result= rg->fillup_in_client(query, token_lengths, token_offsets);
      *fillup_result= result;
      unsigned long r= rg->result_row_count;
      if (r == 1) put_message_in_result("OK, 1 row");
      else put_message_in_result(QString::number(r) + " rows");
      *diagnostic_signal= DIAGNOSTIC_2;
      is_early_return= true;
    }
  }
  if (is_early_return)
  {
    delete [] token_types;
    delete [] token_lengths;
    delete [] token_offsets;
    return ER_OK;
  }

/* TODO: The following was done before there was a way to make tiny changes for expressions. Do it the way it's done above. */
  char error_or_ok_message[ER_MAX_LENGTH];
#ifdef DBMS_TARANTOOL
//  if (connections_dbms[connection_number] == DBMS_TARANTOOL) return -1;
#endif
  int real_return;
//  int token_offsets[MAX_OCELOT_STATEMENT_TOKENS];
//  int token_lengths[MAX_OCELOT_STATEMENT_TOKENS];
//  tokenize(query.data(),
//           query.size(),
//           &token_lengths[0], &token_offsets[0], MAX_OCELOT_STATEMENT_TOKENS - 1,
//          (QChar*)"33333", 2, "", 1);
  int query_type= 0;
  unsigned int i;
  QString table_name= "";
  QString schema_name= "";
  bool is_invalid_query= false;
//  int option= 0;

  for (int j= 0;; ++j)
  {
    QString token= query.mid(token_offsets[j], token_lengths[j]);
    token= token.toUpper();
    if ((j == 0) && (token != "SET")) {is_invalid_query= true; break; }
    if ((j == 1) && (token != "OCELOT_QUERY")) {is_invalid_query= true; break; }
    if ((j == 2) && (token != "=")) {is_invalid_query= true; break; }
    if ((j == 3) && (token != "SHOW")) {is_invalid_query= true; break; }
    if ((j == 4) && (token != "FOREIGN")) {is_invalid_query= true; break; }
    if ((j == 5) && (token != "KEYS")) {is_invalid_query= true; break; }
    if ((j == 6) && (token != "OF")) {is_invalid_query= true; break; }
    if (j == 7) table_name= token;
    if ((j == 8) && (token != ".")) break;
    if (j == 9) {schema_name= table_name; table_name= token; break; }
  }
  if (is_invalid_query == false) query_type= TOKEN_KEYWORD_FOREIGN;
  else
  {
    is_invalid_query= false;
    for (int j= 0;; ++j)
    {
      QString token= query.mid(token_offsets[j], token_lengths[j]);
      token= token.toUpper();
      if ((j == 0) && (token != "SET")) {is_invalid_query= true; break; }
      if ((j == 1) && (token != "OCELOT_QUERY")) {is_invalid_query= true; break; }
      if ((j == 2) && (token != "=")) {is_invalid_query= true; break; }
      if ((j == 3) && (token != "SHOW")) {is_invalid_query= true; break; }
      if ((j == 4) && (token != "ERDIAGRAM")) {is_invalid_query= true; break; }
      if ((j == 5) && (token != "OF")) {is_invalid_query= true; break; }
      if (j == 6)
      {
        if (token_lengths[j] == 0) {is_invalid_query= true; break; }
        schema_name= query.mid(token_offsets[j], token_lengths[j]);
      }
      if (j == 7) break;
    }
    if (is_invalid_query == true)
    {
      delete [] token_types;
      delete [] token_lengths;
      delete [] token_offsets;
      return -1;
    }
    query_type= TOKEN_KEYWORD_ERDIAGRAM;
  }

  if (query_type == TOKEN_KEYWORD_ERDIAGRAM)
  {
    if (ocelot_explorer_visible == "no")
    {
      put_message_in_result("Error. SHOW ERDIAGRAM only works if explorer is visible. To make it visible, use Settings|Explorer or SET ocelot_explorer_visible='yes';");
      delete [] token_types;
      delete [] token_lengths;
      delete [] token_offsets;
      return ER_ERROR;
    }
#if (OCELOT_ERDIAGRAM == 1)
  if (oei_count != 0) /* Actually, since explorer is visible, we can be sure oei_count != 0, eh? */
  {
    schema_name= connect_stripper(schema_name, false);
//    ERDiagram *erdiagram_widget= new ERDiagram(this, schema_name, query);
    ERDiagram *erdiagram_widget= new ERDiagram(this, schema_name, query);
    erdiagram_widget->exec(); /* or maybe I should say open() and setModal(false)? */
    delete erdiagram_widget;
    delete [] token_types;
    delete [] token_lengths;
    delete [] token_offsets;
    return ER_OK;
  }
#endif
    delete [] token_types;
    delete [] token_lengths;
    delete [] token_offsets;
    return 1;
  }

  /* rest of this routine is for query_type == TOKEN_KEYWORD_FOREIGN */

  table_name= connect_stripper(table_name, false);
  schema_name= connect_stripper(schema_name, false);
  if (table_name == "")
  {
    delete [] token_types;
    delete [] token_lengths;
    delete [] token_offsets;
    return -1;
  }
  unsigned int saved_rehash_result_row_count= result_row_count;
  QString query2= "SELECT 'D',database(),'','','','' "
                  "UNION ALL "
                  "SELECT table_name, column_name, ordinal_position, "
                  "constraint_name, "
                  "referenced_table_name, referenced_column_name "
                  "FROM information_schema.key_column_usage "
                  "WHERE table_name = '";
   query2= query2 + table_name;
   query2= query2 + "' AND referenced_column_name IS NOT NULL ";
   if (schema_name == "") query2= query2 + " AND table_schema = database() ";
   else query2= query2 + " AND table_schema = '" + schema_name + "' ";
   query2= query2 + " ORDER BY 4, 3;";

  int rehash_scan_result= rehash_scan(error_or_ok_message, query2);
  if (rehash_scan_result != ER_OK_REHASH)
  {
    put_message_in_result(error_or_ok_message);
    delete [] token_types;
    delete [] token_lengths;
    delete [] token_offsets;
    return 1;
  }
  long int r;
  char *row_pointer;
  int column_length;
  fks= "";
  counter= 0;
  for (r= 0; r < rehash_result_row_count; ++r)
  {
    row_pointer= rehash_result_set_copy_rows[r];
    for (i= 0; i < rehash_result_column_count; ++i)
    {
      memcpy(&column_length, row_pointer, sizeof(unsigned int));
      //char flag= *(row_pointer + sizeof(unsigned int));
      row_pointer+= sizeof(unsigned int) + sizeof(char);
      /* Now row_pointer points to contents, length has # of bytes */
      QByteArray m(row_pointer, column_length);
      if (i == 0) d_table_name= QString(m);
      if (i == 1) d_column_name= QString(m);
      if (i == 2) d_ordinal_position= QString(m);
      if (i == 3) d_constraint_name= QString(m);
      if (i == 4) d_referenced_table_name= QString(m);
      if (i == 5) d_referenced_column_name= QString(m);
      row_pointer+= column_length;
    }
    if (r == 0) continue;
    if (counter > 0)
      fks= fks + "UNION ALL\n";
//    if ((counter != 0) && (d_ordinal_position == "1"))
//    {
//      fks= fks + "SELECT '', '', '', '', ''\n";
//      fks= fks + "UNION ALL\n";
//    }
    if (d_ordinal_position == "1")
    {
      fks= fks + "SELECT '" + d_constraint_name + "' AS `Name`,'" + d_table_name + "' AS `Table`,'" + d_column_name + "' AS `Column`,'" + d_referenced_table_name + "' AS `Referenced Table`,'" + d_referenced_column_name + "' AS `Referenced column`\n";
    }
    else
    {
      fks= fks + "SELECT '" + d_constraint_name + "' AS `Name`,'" + d_table_name + "' AS `Table`,'" + d_column_name + "' AS `Column`,'" + d_referenced_table_name + "' AS `Referenced Table`,'" + d_referenced_column_name + "' AS `Referenced column`\n";
    }
    ++counter;
  }
  fks= fks + ";";

  /* If we wrecked the global rehash_scan result that's used ordinarily we'll have to call rehash_scan again. */
  if (saved_rehash_result_row_count != 0) rehash_scan(error_or_ok_message, "");
  else rehash_garbage_collect();

  fks_query_len= fks.toUtf8().size();                  /* See comment "UTF8 Conversion" */
  fks_query= new char[fks_query_len + 1];
  strcpy(fks_query, fks.toUtf8());
  real_return= execute_real_query(fks_query, connection_number, alltext);
  delete []fks_query;
  delete [] token_types;
  delete [] token_lengths;
  delete [] token_offsets;
  return real_return;
}


/*
  We see "DELIMITER".
  If the thing that follows is 'literal' or "literal" or `identifier`: that's the delimiter.
  Otherwise delimiter is what follows as far as next whitespace or eof
  DELIMITER ; means "go back to the default i.e. ;".
  This is called from hparse_f_client_statement() because it affects parse of later statements.
  This is called from execute_client_statement() because DELIMITER is a client statement.
  One difference from mysql client:
    If mysql client sees "DELIMITER <return>" or "DELIMITER ''" it's an error.
    But we consider that equivalent to "DELIMITER ;"
  We return ";" if nothing follows or quoted blank string follows; mysql client would say error.
  2023-05-07: We no longer stop on ; because DELIMITER ;; is legal
*/
QString MainWindow::get_delimiter(QString token, QString text, int offset)
{
  QString token_to_return;
  if ((token.mid(0, 1) == "`") || (token.mid(0, 1) == "'") || (token.mid(0, 1) == "\""))
  {
    token_to_return= connect_stripper(token, false);
  }
  else
  {
    token_to_return= "";
    for (int i= offset;; ++i)
    {
      QString c= text.mid(i, 1);
      if (c <= " ") break;
//      if (c == ";")
//      {
//        if (token_to_return == "") token_to_return= ";";
//        break;
//      }
      token_to_return.append(c);
    }
  }
  return token_to_return;
}


/*
  Get a value that would be would be legal as input.
  Called from execute_client_statement()
  Legal values are: "yes" or "no"
  Return = input (stripped, lower case if string), or "" which means "INVALID"
*/
QString MainWindow::detached_value(QString input)
{
  QString ccn= connect_stripper(input, false);
  ccn= ccn.toLower();
  if ((ccn == "no") || (ccn == "yes")) return ccn;
  return "";
}

/*
  Get a value that would be would be legal as input.
  Called from execute_client_statement()
  Legal values are: "default" or integer >= 0
  Return = input (stripped, lower case if string), or "" which means "INVALID"
*/
QString MainWindow::rect_value(QString input)
{
  QString ccn= connect_stripper(input, false);
  ccn= ccn.toLower();
  if (ccn == "default") return ccn;
  bool toint_is_ok;
  int toint_result;
  toint_result= ccn.toInt(&toint_is_ok);
  if ((toint_is_ok == false) || (toint_result < 0)) return "";
  return ccn;
}


/*
 Handle "client statements" -- statements that the client itself executes.
  Possible client statements:
  DELIMITER delimiter
  CONNECT ... (Todo: CONNECT depends entirely on settings, it should be possible to have arguments)
*/


/*
  Todo: We want all the mysql commands to work just the way that they work in mysql.
        We will not depend on TOKEN_KEYWORD_... for this because "\" and "q" are separate tokens,
        and "q| is case sensitive.
*/

#define MAX_SUB_TOKENS 22
int MainWindow::execute_client_statement(QString text, int *additional_result)
{
  log("execute_client_statement", 70);
//  int i= 0;
  int i2= 0;
  int  sub_token_offsets[MAX_SUB_TOKENS + 2];
  int  sub_token_lengths[MAX_SUB_TOKENS + 2];
  int  sub_token_types[MAX_SUB_TOKENS + 2];
  int true_text_size, true_token_count; /* size and count ignoring delimiter */
  //QString text;                      /* Todo: see if text should be a global */
  unsigned int statement_type;

  for (int i= main_token_number;; ++i)
  {
    if (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_SLASH
    ||  main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE
    ||  main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_MINUS) continue;
    if (main_token_lengths[i] == 0)
    {
      statement_type= 0;
      break;
    }
    statement_type= main_token_types[i];
    break;
  }

  //text= statement_edit_widget->toPlainText(); /* or I could just pass this to tokenize() directly */

  /* Calculate size. Don't count delimiter unless it's a delimiter statement. */
  true_text_size= query_utf16_copy.size();

  int query_utf16_size= query_utf16.size();
  int query_utf16_copy_size= query_utf16_copy.size();
  if ((query_utf16_size == query_utf16_copy_size) || (statement_type == TOKEN_KEYWORD_DELIMITER))
  {
    /* there was no delimiter, or there was a delimiter but it's a delimiter statement */
    true_text_size= query_utf16_size;
    true_token_count= main_token_count_in_statement;
  }
  else
  {
    /* There was a delimiter, and it's not a delimiter statement */
    true_text_size= query_utf16_copy_size;
    true_token_count= main_token_count_in_statement - 1;
  }

  /* Make a copy of the first few tokens, ignoring comments. */
  /* And ignore the first token if it is \ because second token is the same */
  for (unsigned int i= main_token_number; /* main_token_lengths[i] != 0 && */ i < main_token_number + true_token_count; ++i)
  {
    /* Todo: find out why you have to figure out type again -- isn't it already known? */
    QString s= text.mid(main_token_offsets[i], main_token_lengths[i]);
    int t= token_type(s.data(), main_token_lengths[i], sql_mode_ansi_quotes);
    if (t == TOKEN_TYPE_COMMENT_WITH_SLASH
    ||  t == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE
    ||  t == TOKEN_TYPE_COMMENT_WITH_MINUS) continue;
    if ((i2 == 0) && (s == "\\"))
    {
      continue;
    }
    sub_token_offsets[i2]= main_token_offsets[i];
    sub_token_lengths[i2]= main_token_lengths[i];
    sub_token_types[i2]= main_token_types[i];
    ++i2;
    if (i2 > MAX_SUB_TOKENS) break;
  }
  sub_token_offsets[i2]= 0;
  sub_token_lengths[i2]= 0;
  sub_token_types[i2]= 0;

  /*
    CONNECT or \r.
    Defaults should have been set earlier. The user had a chance to change the defaults with SET.
    Currently the only possible dbms is "mysql", otherwise nothing happens.
    (or Tarantool, eh?)
    Ignore any other words in the statement.
    Todo: accept the mysql-client syntax, which has a few extras on it for reconnect.
    Todo: connect_mysql() returns an int, find out why you're not looking at it
  */
  /* Todo: We could easily modify so that we don't need sub_token_..., we could just skip comments. */
  if (statement_type == TOKEN_KEYWORD_CONNECT)
  {
    history_file_to_history_widget(); /* TODO: Maybe this is the wrong time to call? */
    QString rr;
    history_file_start("HIST", ocelot_history_hist_file_name, &rr);
#if (OCELOT_MYSQL_INCLUDE == 0)
    if ((ocelot_dbms.contains("mysql", Qt::CaseInsensitive) == true) || (ocelot_dbms.contains("mariadb", Qt::CaseInsensitive) == true))
    {
      printf("Built with OCELOT_MYSQL_INCLUDE=0 so ocelot_dbms cannot be 'mysql' or 'mariadb'.\n");
      exit(1);
    }
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
    if (connections_dbms[0] == DBMS_MYSQL) connect_mysql(MYSQL_MAIN_CONNECTION);
#ifdef DBMS_MARIADB
    if (connections_dbms[0] == DBMS_MARIADB) connect_mysql(MYSQL_MAIN_CONNECTION);
#endif
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
    if (connections_dbms[0] == DBMS_TARANTOOL) connect_tarantool(MYSQL_MAIN_CONNECTION, "DEFAULT", "DEFAULT", "DEFAULT", "DEFAULT");
#endif
    if (ocelot_ca.prompt_is_default == true) prompt_default();
    return 1;
  }
  /* Todo: this isn't robust, it will fail if we ever allow other words e.g. IF NOT EXISTS after CREATE. */
  if ((statement_type == TOKEN_KEYWORD_CREATE)
   && (sub_token_types[1] == TOKEN_KEYWORD_LUA))
  {
    if ((sub_token_types[2] == TOKEN_KEYWORD_PROCEDURE)
     || (sub_token_types[2] == TOKEN_KEYWORD_FUNCTION))
    {
      clf(text);
      return 1;
    }
  }


#ifdef DBMS_TARANTOOL
  /*
    CREATE SERVER id FOREIGN DATA WRAPPER tarantool
    OPTIONS (PORT ..., HOST ..., PASSWORD, ... USER ...)
    Do Tarantool connect for the sake of create_table_server.
    Todo: check port isn't re-used
  */
  if ((statement_type == TOKEN_KEYWORD_CREATE)
   && (sub_token_types[1] == TOKEN_KEYWORD_SERVER)
   && (sub_token_lengths[2] != 0)
   && (sub_token_types[3] == TOKEN_KEYWORD_FOREIGN)
   && (sub_token_lengths[4] != 0)
   && (sub_token_types[5] != 0)
   && (sub_token_lengths[6] != 0))
  {
    QString wrapper_name= text.mid(sub_token_offsets[6], sub_token_lengths[6]);
    wrapper_name= connect_stripper(wrapper_name, true);
    wrapper_name= wrapper_name.toUpper();
    if (wrapper_name == "OCELOT_TARANTOOL")
    {
      QString create_server_port= "DEFAULT";
      QString create_server_host= "DEFAULT";
      QString create_server_password= "DEFAULT";
      QString create_server_user= "DEFAULT";
      QString curr, prev;
      for (int i= 9; ; ++i)
      {
        if ((i >= MAX_SUB_TOKENS) || (sub_token_lengths[i] == 0))
        {
          make_and_put_message_in_result(ER_CREATE_SERVER_SYNTAX, 0, (char*)"");
          return 1;
        }
        curr= text.mid(sub_token_offsets[i], sub_token_lengths[i]);
        if (curr == ")") break;
        if ((main_token_types[i] >= TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE)
         && (main_token_types[i] <= TOKEN_TYPE_LITERAL_WITH_BRACE))
        {
          if (prev == "PORT") create_server_port= connect_stripper(curr, true);
          if (prev == "HOST") create_server_host= connect_stripper(curr, true);
          if (prev == "PASSWORD") create_server_password= connect_stripper(curr, true);
          if (prev == "USER") create_server_user= connect_stripper(curr, true);
        }
        prev= curr.toUpper();
      }
      int result= connect_tarantool(MYSQL_REMOTE_CONNECTION,
                                    create_server_port,
                                    create_server_host,
                                    create_server_password,
                                    create_server_user);
      if (result == 0)
      {
        tarantool_server_name= connect_stripper(text.mid(sub_token_offsets[2], sub_token_lengths[2]), true);
        connections_dbms[MYSQL_REMOTE_CONNECTION]= DBMS_TARANTOOL;
      }
      else
      {
        tarantool_server_name= "";
        connections_dbms[MYSQL_REMOTE_CONNECTION]= 0;
      }
      return 1;
    }
  }
#endif

  /* QUIT or \q. mysql equivalent. Todo: add to history box before exiting. */
  if ((statement_type == TOKEN_KEYWORD_QUIT)
  ||  (statement_type == TOKEN_KEYWORD_EXIT))
  {
    action_file_exit(false);
    return 1;
  }

  /*
     CLEAR or \c: mysql equivalent.
     Really this just means "ignore the statement".
     It goes into history though.
  */
  if (statement_type == TOKEN_KEYWORD_CLEAR)
  {
    return 1;
  }

#if (OCELOT_MYSQL_INCLUDE == 1)
  /* USE or \u: mysql equivalent. */
  if (statement_type == TOKEN_KEYWORD_USE)
  {
    QString s;
    int mysql_select_db_result;
    if ((i2 >= 2) && (sub_token_types[0] == TOKEN_KEYWORD_USE)) s= text.mid(sub_token_offsets[1], sub_token_lengths[1]);
    else if (i2 >= 3) s= text.mid(sub_token_offsets[2], sub_token_lengths[2]);
    else
    {
      make_and_put_message_in_result(ER_USE, 0, (char*)"");
      return 1;
    }
    /* If database name is in quotes or delimited, strip. Todo: stripping might be necessary in lots of cases. */
    s= connect_stripper(s, false);
    int query_len= s.toUtf8().size();                  /* See comment "UTF8 Conversion" */
    char *query= new char[query_len + 1];
    memcpy(query, s.toUtf8().constData(), query_len + 1);

    mysql_select_db_result= lmysql->ldbms_mysql_select_db(&mysql[MYSQL_MAIN_CONNECTION], query);
    delete []query;
    if (mysql_select_db_result != 0) put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
    else
    {
      statement_edit_widget->dbms_database= s;
      if (ocelot_ca.auto_rehash != 0)
      {
        char error_or_ok_message[ER_MAX_LENGTH];
        int i= rehash_scan(error_or_ok_message, "");
        if (i == ER_OK_REHASH)
        {
          put_message_in_result(error_or_ok_message);
          return 1;
        }
      }
      make_and_put_message_in_result(ER_DATABASE_CHANGED, 0, (char*)"");
    }
    return 1;
  }
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

  /* SOURCE or \.: mysql equivalent. */
  if (statement_type == TOKEN_KEYWORD_SOURCE)
  {
    /* Everything as far as statement end is source file name. Todo: so why connect_stripper? */
    QString s;
    unsigned statement_length= /* text.size() */ true_text_size;
    if (i2 >= 2) s= text.mid(sub_token_offsets[1], statement_length - (sub_token_offsets[1] - sub_token_offsets[0]));
    else
    {
      make_and_put_message_in_result(ER_SOURCE, 0, (char*)"");
      return 1;
    }
    s= connect_stripper(s, true);
    is_in_source_statement= true; /* So is_statement_complete() will say statement can end with ; */
    read_file(TOKEN_KEYWORD_SOURCE, s, "");
    is_in_source_statement= false;
    /* Without the following, the final line of source would go into the history twice. */
    *additional_result= TOKEN_KEYWORD_SOURCE;
    return 1;
  }

  /* PROMPT or \R: mysql equivalent. */
  /* This overrides the default setting which is made from ocelot_prompt during connect. */
  if (statement_type == TOKEN_KEYWORD_PROMPT)
  {
    QString s;
    unsigned statement_length= true_text_size /* text.size() */;
    if ((i2 >= 2) && (sub_token_types[1] != TOKEN_KEYWORD_USE))
      s= text.mid(sub_token_offsets[1], statement_length - (sub_token_offsets[1] - sub_token_offsets[0]));
    else if (i2 >= 3) s= text.mid(sub_token_offsets[2], statement_length - (sub_token_offsets[1] - sub_token_offsets[0]));
    else if (i2 == 1)
    {
      prompt_default(); /* Just "prompt" or "prompt;" with no args */
      return 1;
    }
    else
    {
      ocelot_ca.prompt_is_default= false; /* todo: check: shouldn't this be true? */
      statement_edit_widget->prompt_as_input_by_user= statement_edit_widget->prompt_default;
      ocelot_prompt= statement_edit_widget->prompt_default;
    emit statement_edit_widget->update_prompt_width(0); /* not necessary with Qt 5.2 */
      /* Todo: output a message */
      return 1;
    }
    statement_edit_widget->prompt_as_input_by_user= s;
    ocelot_prompt= s;
    emit statement_edit_widget->update_prompt_width(0); /* not necessary with Qt 5.2 */
    ocelot_ca.prompt_is_default= false;
    make_and_put_message_in_result(ER_OK, 0, (char*)"");
    return 1;
  }

  /* WARNINGS or \W: mysql equivalent. This overrides a command-line option. */
  if (statement_type == TOKEN_KEYWORD_WARNINGS)
  {
    ocelot_ca.history_includes_warnings= 1;
    make_and_put_message_in_result(ER_OK, 0, (char*)"");
    return 1;
  }

  /* NOWARNING or \w: mysql equivalent. This overrides a command-line option. */
  if (statement_type == TOKEN_KEYWORD_NOWARNING)
  {
    ocelot_ca.history_includes_warnings= 0;
    make_and_put_message_in_result(ER_OK, 0, (char*)"");
    return 1;
  }

  /* DELIMITER or \d: mysql equivalent. */
  if (statement_type == TOKEN_KEYWORD_DELIMITER)
  {
    QString s= text.mid(sub_token_offsets[1], sub_token_lengths[1]);
    QString s_result= get_delimiter(s, text, sub_token_offsets[1]);
    if (s_result == "")
    {
      make_and_put_message_in_result(ER_DELIMITER, 0, (char*)"");
      return 1;
    }
    ocelot_delimiter_str= s_result;
    make_and_put_message_in_result(ER_OK, 0, (char*)"");
    return 1;
    }

  /* Todo: the following are placeholders, we want actual actions like what mysql would do. */
  if (statement_type == TOKEN_KEYWORD_QUESTIONMARK)
  {
    make_and_put_message_in_result(ER_HELP, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_CHARSET)
  {
    make_and_put_message_in_result(ER_CHARSET, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_EDIT)
  {
    make_and_put_message_in_result(ER_EDIT, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_EGO)
  {
    make_and_put_message_in_result(ER_EGO, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_GO)
  {
    make_and_put_message_in_result(ER_GO, 0, (char*)"");
  }
  if (statement_type == TOKEN_KEYWORD_HELP_IN_CLIENT)
  {
    make_and_put_message_in_result(ER_HELP, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_NOPAGER)
  {
    make_and_put_message_in_result(ER_NOPAGER, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_NOTEE) /* see comment=tee+hist */
  {
    history_file_stop("TEE");
    make_and_put_message_in_result(ER_OK, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_PAGER)
  {
    make_and_put_message_in_result(ER_PAGER, 0, (char*)"");
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_PRINT)
  {
    make_and_put_message_in_result(ER_PRINT, 0, (char*)"");
    return 1;
  }
#if (OCELOT_EXPLORER == 1)
  if (statement_type == TOKEN_KEYWORD_REFRESH)
   {
     char error_or_ok_message[ER_MAX_LENGTH];
     explorer_refresh_caller(error_or_ok_message); /* todo: this returns an int result which we don't use */
     put_message_in_result(error_or_ok_message);
     return 1;
   }
#endif
  if (statement_type == TOKEN_KEYWORD_REHASH)   /* Regardless whether ocelot_ca.auto_rehash = 1 */
  {
    char error_or_ok_message[ER_MAX_LENGTH];
    rehash_scan(error_or_ok_message, ""); /* We don't check if return = ER_OK but if it failed then rehash_result_row_count = 0 */
    put_message_in_result(error_or_ok_message);
    return 1;
  }
  /* TODO: "STATUS" should output as much information as the mysql client does. */
  /* Todo: connections_is_connected is still 1 after lost connection or SHUTDOWN, fix that somewhere */
  if (statement_type == TOKEN_KEYWORD_STATUS)
  {
    if (connections_is_connected[0] != 1) make_and_put_message_in_result(ER_NOT_CONNECTED, 0, (char*)"");
    else
    {
      char dbms_version[256];
      char dbms_host[256];
      char dbms_port[256];
      char buffer[1024];
      strcpy(dbms_version, statement_edit_widget->dbms_version.toUtf8());
      strcpy(dbms_host, statement_edit_widget->dbms_host.toUtf8());
      strcpy(dbms_port, statement_edit_widget->dbms_port.toUtf8());
      sprintf(buffer, er_strings[er_off + ER_STATUS], dbms_version, dbms_host, dbms_port);
#ifdef DBMS_TARANTOOL
      if (connections_dbms[0] == DBMS_TARANTOOL)
      {
        char tmp[32];
        sprintf(tmp, " iproto_schema_version = %lu", (unsigned long) tarantool_tnt_reply.schema_id);
        strcat(buffer, tmp);
      }
#endif
      put_message_in_result(buffer);
    }
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_SYSTEM)
  {
    /*
      With mysql client "system ls" would do an ls with system. We use popen not system.
      I don't know whether there is a Windows equivalent; mysql client doesn't support one.
      So the easiest thing for a Windows port is:
      make_and_put_message_in_result(tr("SYSTEM is not implemented."));
      Todo: allow "kill" -- some research required about how to stop a shell command.
      Todo: reconsider: maybe output should go to result grid rather than history.
    */
    QString s;
    unsigned statement_length= true_text_size /* text.size() */;
    s= text.mid(sub_token_offsets[1], statement_length - (sub_token_offsets[1] - sub_token_offsets[0]));
    char *command_string= new char[s.size() + 1];
    memcpy(command_string, s.toUtf8().constData(), s.size() + 1);
    put_message_in_result(""); /* unnecessary? */
    FILE *fp;
    int status;
    char result_line[STRING_LENGTH_512]; /* arbitrary maximum expected line length */
    fp= popen(command_string, "r");
    if (fp == NULL) make_and_append_message_in_result(ER_POPEN_FAILED, 0, (char*)"");
    else
    {
      while (fgets(result_line, STRING_LENGTH_512, fp) != NULL)
      {
        statement_edit_widget->result.append(result_line);
      }
      status= pclose(fp);
      if (status == -1) make_and_append_message_in_result(ER_PCLOSE_FAILED, 0, (char*)"");
      /* We do not bother to check whether the command failed, display will be blank. */
    }
    delete [] command_string;
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_TEE) /* see comment=tee+hist */
  {
    /* Everything as far as statement end is tee file name. Compare how we do SOURCE file name. */
    QString s;
    unsigned statement_length= /* text.size() */ true_text_size;
    if (i2 >= 2) s= text.mid(sub_token_offsets[1], statement_length - (sub_token_offsets[1] - sub_token_offsets[0]));
    else s= "";
    QString rr;
    if (history_file_start("TEE", s, &rr) == 0)
    {
      make_and_put_open_message_in_result(ER_FILE_OPEN, 0, rr);
    }
    else
    {
      make_and_put_open_message_in_result(ER_OK_PLUS, 0, rr);
    }
    return 1;
  }
#if (OCELOT_MYSQL_DEBUGGER == 1)
  if (statement_type == TOKEN_KEYWORD_DEBUG_DEBUG)
  {
    debug_debug_go(text);
    return 1;
  }
  if ((statement_type == TOKEN_KEYWORD_DEBUG_BREAKPOINT)
   || (statement_type == TOKEN_KEYWORD_DEBUG_CLEAR)
   || (statement_type == TOKEN_KEYWORD_DEBUG_TBREAKPOINT))
  {
    debug_breakpoint_or_clear_go(statement_type, text);
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_SETUP)
  {
    debug_setup_go(text);
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_INSTALL)
  {
    debug_install_go();
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_EXIT)
  {
    debug_exit_go(0);
    debug_menu_enable_or_disable(TOKEN_KEYWORD_DEBUG_EXIT);
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_DELETE)
  {
    debug_delete_go();
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_EXECUTE)
  {
    debug_execute_go();
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_SKIP)
  {
    debug_skip_go();
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_SET)
  {
    debug_set_go(text);
    return 1;
  }
  if (statement_type == TOKEN_KEYWORD_DEBUG_SOURCE)
  {
    debug_source_go();
    return 1;
  }
  if ((statement_type == TOKEN_KEYWORD_DEBUG_CONTINUE)
   || (statement_type == TOKEN_KEYWORD_DEBUG_EXECUTE)
   || (statement_type == TOKEN_KEYWORD_DEBUG_INFORMATION)
   || (statement_type == TOKEN_KEYWORD_DEBUG_LEAVE)
   || (statement_type == TOKEN_KEYWORD_DEBUG_NEXT)
   || (statement_type == TOKEN_KEYWORD_DEBUG_REFRESH)
   || (statement_type == TOKEN_KEYWORD_DEBUG_STEP))
  {
    /* All the other debug commands go to the same place. */
    debug_other_go(text);
    return 1;
  }
#endif
  /* See whether general format is SET ocelot_... = value ;". Read comment with label = "client variables" */
  if (i2 >= 4)
  {
    if ((sub_token_types[0] == TOKEN_KEYWORD_SET) && (sub_token_types[1] == TOKEN_KEYWORD_OCELOT_QUERY))
    {
      /* It's SET ocelot_query = but some such queries are purely client i.e. they don't require connection to server. */
      if ((sub_token_types[3] == TOKEN_KEYWORD_INSERT)
       || (sub_token_types[3] == TOKEN_KEYWORD_DELETE)
       || (sub_token_types[3] == TOKEN_KEYWORD_SELECT)
       || (sub_token_types[3] == TOKEN_KEYWORD_UPDATE))
      {
        return 3; /* meaning "no error if no connection and expect execute_ocelot_query to handle it" */
      }
      return 0;
    }
    if ((sub_token_types[0] == TOKEN_KEYWORD_SET)
      && (sub_token_types[1] >= TOKEN_KEYWORD_OCELOT_BATCH) && (sub_token_types[1] <= TOKEN_KEYWORD_OCELOT_XML))
    {
      if (sub_token_types[1] == TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_RULE)
      {
        int er= statement_format_rule_set(text);
        make_and_put_message_in_result(er, 0, (char*)"");
        return 1;
      }
#if (OCELOT_IMPORT_EXPORT == 1)
      if (sub_token_types[1] == TOKEN_KEYWORD_OCELOT_EXPORT)
      {
        import_export_rule_set(text);
        /* make_and_put_message_in_reult is done within import_export_rule_set */
        return 1;
      }
#endif
      if (sub_token_types[1] == TOKEN_KEYWORD_OCELOT_MAX_CONDITIONS)
      {
        QString new_value_string= text.mid(sub_token_offsets[3], sub_token_lengths[3]);
        int candidate= new_value_string.toInt();
        ocelot_ca.max_conditions= candidate;
        if (candidate > MAX_MAX_CONDITIONS)
        {
          char tmp_for_error[256];
          sprintf(tmp_for_error, "Error. MAX_MAX_CONDITIONS = %d\n", MAX_MAX_CONDITIONS);
          put_message_in_result(tmp_for_error);
          return 1;
        }
        if (conditional_settings.count() > ocelot_ca.max_conditions)
        {
          while (conditional_settings.count() > ocelot_ca.max_conditions) /* remove existing in reverse order */
            conditional_settings.removeAt(0);
          explorer_show_after_change();
        }
        put_message_in_result("OK");
        return 1;
      }
#if (OCELOT_CHART_OR_QCHART == 1)
      if (sub_token_types[1] == TOKEN_KEYWORD_OCELOT_GRID_CHART)
      {
        /* Todo: find out why things go wrong if I don't have column names. and this should only be temporary. */
        ocelot_ca.result_grid_column_names= 1;
        /* todo: validity check of new value string */
        if (sub_token_types[4] == TOKEN_KEYWORD_WHERE) ;
        else
        {
          /* unconditional setting so remove any conditional settings */
          int i= conditional_settings.count() - 1;
          while (i >= 0)
          {
            if (conditional_settings.at(i).left(22) == "SET OCELOT_GRID_CHART ")
            {
              conditional_settings.removeAt(i);
            }
            --i;
          }
        }
      }
#endif
      /* set ocelot_... can be followed by multiple assignments and a where clause */
      /* warning: assignements can succeed and later statement can fail */
      int er_of_set_statement= 0;
      int i_of_set_statement= main_token_number; /* start at beginning and skip till after set */
      while ((main_token_types[i_of_set_statement] < TOKEN_KEYWORD_OCELOT_BATCH)
        || (main_token_types[i_of_set_statement] > TOKEN_KEYWORD_OCELOT_XML))
      {
        ++i_of_set_statement; /* it will skip at least once, but we know ocelot_ is in the statement */
      }


      int main_token_type_after_set= main_token_types[i_of_set_statement];

      /* We do not want to call ocelot_variable_set() if there is a WHERE after the assignments */
      int iossc= i_of_set_statement;
      for (;;)
      {
        if ((main_token_types[iossc] == TOKEN_TYPE_OPERATOR) || (main_token_lengths[iossc] == 0)) break;
        iossc= next_i(iossc, 1);
        if (text.mid(main_token_offsets[iossc], main_token_lengths[iossc]) != "=") break;
        iossc= next_i(iossc, 1);
        if ((main_token_types[iossc] == TOKEN_TYPE_OPERATOR) || (main_token_lengths[iossc] == 0)) break;
        iossc= next_i(iossc, 1);
        if (text.mid(main_token_offsets[iossc], main_token_lengths[iossc]) != ",") break;
        iossc= next_i(iossc, 1);
      }
      if (main_token_types[iossc] == TOKEN_KEYWORD_WHERE) i_of_set_statement= iossc; /* because we will skip */
      else
      {
        for (;;)
        {
          int token_type= main_token_types[i_of_set_statement];
          i_of_set_statement= next_token(i_of_set_statement); /* to "=" (if syntax ok) */
          i_of_set_statement= next_token(i_of_set_statement); /* to operand (if syntax ok) */
          er_of_set_statement= xsettings_widget->ocelot_variable_set(token_type,
                text.mid(main_token_offsets[i_of_set_statement], main_token_lengths[i_of_set_statement]));
          if (er_of_set_statement != ER_OK) break;
          i_of_set_statement= next_token(i_of_set_statement); /* to , or where (if syntax ok) */
          if (text.mid(main_token_offsets[i_of_set_statement], main_token_lengths[i_of_set_statement]) != ",")
            break;
          i_of_set_statement= next_token(i_of_set_statement); /* to next assignment (if syntax ok) */
        }
      }
      if (main_token_types[i_of_set_statement] == TOKEN_KEYWORD_WHERE)
      {
        if (conditional_settings.count() >= ocelot_ca.max_conditions)
        {
          char msg[512];
          sprintf(msg, "Error: maximum number of conditional statements is %d. To increase, say SET ocelot_max_conditions=N;", ocelot_ca.max_conditions);
          put_message_in_result(msg);
          return 1;
        }
        er_of_set_statement= conditional_settings_insert(text);
        if (er_of_set_statement == ER_OK) explorer_show_after_change();
      }
#if (OCELOT_CHART_OR_QCHART == 1)
      /* If it was "set ocelot_grid_chart = ...", we might need to change an existing displayed result set. */
      /* We were doing this inside ocelot_variable_set() but that was a bug, we must check the WHERE clause first. */
      if ((main_token_type_after_set == TOKEN_KEYWORD_OCELOT_GRID_CHART) && (er_of_set_statement == ER_OK))
      {
        ResultGrid* r;
        for (int i_r= 0; i_r < ocelot_ca.grid_actual_tabs; ++i_r)
        {
          r= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(i_r));
          if (r->isVisible() == true) r->display(1, 0, 0, 1, 0, 0, ocelot_ca.result_grid_column_names, 0, 0, 0);
        }
     }
#endif

      /* if there's junk after assignments and where, it's ignored */
      make_and_put_message_in_result(er_of_set_statement, 0, (char*)"");
      return 1;
    }
  }
  return 0; /* not client statement */
}

/*
  Called from prompt_default() and action_help_about (for Help|About)
  Return "tarantool" or "mysql" or "mariadb".
  If connected to MariaDB, dbms_version will contain that. But if connected to MySQL, we have only numbers.
*/
QString MainWindow::dbms_name()
{
  QString s= ocelot_dbms;
  QString dbms_name;
  if (s.contains("Tarantool", Qt::CaseInsensitive)) dbms_name= "tarantool";
  else
  {
    if (connections_is_connected[0] == 1) s= statement_edit_widget->dbms_version;
    if (s.contains("MariaDB", Qt::CaseInsensitive)) dbms_name= "mariadb";
    else dbms_name= "mysql";
  }
  return dbms_name;
}

bool MainWindow::is_context_menu_name(int token_type)
{
  if ((token_type== TOKEN_KEYWORD_OCELOT_EXPLORER_ACTION)
   || (token_type == TOKEN_KEYWORD_OCELOT_EXPLORER_APPLICABLE_DBMSS)
   || (token_type == TOKEN_KEYWORD_OCELOT_EXPLORER_APPLICABLE_TYPES)
   || (token_type == TOKEN_KEYWORD_OCELOT_EXPLORER_ENABLED)
   || (token_type == TOKEN_KEYWORD_OCELOT_EXPLORER_SHORTCUT)
   || (token_type == TOKEN_KEYWORD_OCELOT_EXPLORER_TEXT))
    return true;
  return false;
}

/*
  Set prompt to default default.
  Do this if (user says prompt;) or (at start if ocelot_ca.prompt_is_default == true)
  If --ocelot_dbms was specified: ocelot_dbms + >
  Else if connection happened to MariaDB: MariaDB>
  Else mysql>
*/
void MainWindow::prompt_default()
{
  ocelot_prompt= dbms_name() + ">"; /* e.g. "mysql>" */
  ocelot_ca.prompt_is_default= true;
  statement_edit_widget->prompt_default= ocelot_prompt;
  statement_edit_widget->prompt_as_input_by_user= statement_edit_widget->prompt_default;
  emit statement_edit_widget->update_prompt_width(0); /* not necessary with Qt 5.2 */
}

/*
  For a client statement: SET target = 'literal' WHERE x opr y [AND x opr y...]; + comments
  Canonize so that style_sheet_setter() can parse easily.
  Probably hparse will catch errors before we get here but maybe we don't call hparse.
  Todo: Everything could be fixed-size (space padded) except the final comparand to make it even easier for style_sheet_setter().
        And you could disallow ''s in the final comparand.
  Todo: there's a way to tell tokenize() to skip comments so maybe the check here is not necessary
*/
#define MAX_CONDITIONAL_STATEMENT_TOKENS 100
int MainWindow::conditional_settings_insert(QString text)
{
  log("conditional_settings_insert", 15);
  int token_offsets[MAX_CONDITIONAL_STATEMENT_TOKENS];
  int token_lengths[MAX_CONDITIONAL_STATEMENT_TOKENS];
  tokenize(text.data(),
           text.size(),
           &token_lengths[0], &token_offsets[0], MAX_CONDITIONAL_STATEMENT_TOKENS - 1,
          (QChar*)"33333", 2, "", 1);
  QString o= "";
  QString token;
  QString token_2;
  int expected_token= 1;
  for (int i= 0;; ++i)
  {
    token= text.mid(token_offsets[i], token_lengths[i]);
    if ((token.mid(0, 2) == "/*") || (token.mid(0, 2) == "--") || (token.mid(0, 1) == "#")) continue; /* skip comments */
    QString token_upper= token.toUpper();
    if (expected_token == 1)
    {
      if (token_upper != "SET") return ER_ERROR;
      o.append(token_upper + " ");
      expected_token= 2;
      continue;
    }
    if (expected_token == 2)
    {
     int token_type= get_keyword_index_from_qstring(token_upper);
      /* Checking that it's OCELOT_EXPLORER_BACKGROUND_COLOR, OCELOT_GRID_FONT_STYLE, etc. */
      if ((strvalues[token_type].reserved_flags & FLAG_VERSION_CONDITIONAL) == 0)
         return ER_ERROR;
      token_2= token_upper;
      o.append(token_upper + " ");
      expected_token= 3;
      continue;
    }
    if (expected_token == 3)
    {
      if (token != "=") return ER_ERROR;
      o.append(token_upper + " ");
      expected_token= 4;
      continue;
    }
    if (expected_token == 4)
    {
      /* e.g. font_..., tooltip, cell_height, cell_width -- anything that does not mention color */
      if (token_2.contains("COLOR") == false) o.append(token + " ");
      else {
        if ((token.left(1) != "'") || (token.right(1) != "'")) return ER_ILLEGAL_VALUE;
        token= token.mid(1, token.size() -2);
        QString ccn= canonical_color_name(token);
        if (ccn == "") return ER_UNKNOWN_COLOR;
        o.append("'" + ccn.toLower() + "' ");
      }
      expected_token= 5;
      continue;
    }
    if (expected_token == 5)
    {
      if (token == ",")
      {
        o.append(", ");
        expected_token= 2;
        continue;
      }
      if (token_upper != "WHERE") return ER_ERROR;
      o.append(token_upper + " ");
      expected_token= 6;
      continue;
    }
    if (expected_token == 6)
    {
      if ((token_upper != "COLUMN_NAME")
       && (token_upper != "COLUMN_NUMBER")
       && (token_upper != "COLUMN_TYPE")
       && (token_upper != "ROW_NUMBER")
       && (token_upper != "VALUE")) /* the only permissible explorer word */
        return ER_ERROR;
      o.append(token_upper + " ");
      expected_token= 7;
      continue;
    }
    if (expected_token == 7)
    {
      if ((token_upper != "=")
       && (token_upper != ">=")
       && (token_upper != ">")
       && (token_upper != "<=")
       && (token_upper != "<")
       && (token_upper != "<>")
       && (token_upper != "==")
       && (token_upper != "!=")
       && (token_upper != "IS")
       && (token_upper != "REGEXP"))
        return ER_ERROR;
      o.append(token_upper + " ");
      expected_token= 8;
      continue;
    }
    if (expected_token == 8)
    {
      if (token.size() == 0) return ER_ILLEGAL_VALUE;
      o.append(token + " ");
      expected_token= 9;
      continue;
    }
    if (expected_token == 9)
    {
      if (token == ";")
      {
        o.append(";");
        break;
      }
      else if ((token_upper == "AND") || (token_upper == "OR"))
      {
        o.append(token_upper + " ");
        expected_token= 6;
        continue;
      }
      else return ER_ERROR;
    }
  }
  /* Increase conditional_settings.count() which could slow display so ocelot_max_conditionals should be small. */
  conditional_settings.append(o);
  /* Immediate evaluation for explorer action | shortcut | text which are permanent */
  for (int i_of_cmi= 0; i_of_cmi < explorer_widget->html_text_edit->explorer_context_menu->cmi_count; ++i_of_cmi)
  {
    bool result_of_evaluate= false;
    QString cs_new_style_sheet;
    QString style_string= ocelot_explorer_style_string;
    QString cs_new_tooltip;
    QString cs_new_cell_height;
    QString cs_new_cell_width;
    QString cs_new_action= "[]";
    QString cs_new_enabled= "[]";
    QString cs_new_shortcut= "[]";
    QString cs_new_text= "[]";
    QString string= explorer_widget->html_text_edit->explorer_context_menu->cmi[i_of_cmi].text;
    /* Todo: Stripping lead+trail spaces does not remove a shortcut. Should we remove shortcuts? */
    //string= string.trimmed(); unnecessary?
    QByteArray string_utf8= string.toUtf8();
    result_of_evaluate= explorer_widget->conditional_setting_evaluate(conditional_settings.count() - 1,
                                        1,           /* i.e. result set column number */
                                        1,       /* e.g. text_frame->ancestor_grid_result_row_number */
                                        string_utf8.data(),       /* e.g. text_frame->content_pointer */
                                        0,          /* e.g. FIELD_VALUE_FLAG_IS_NULL */
                                        string_utf8.size(), /* e.g. text_frame->content_length */
                                        TEXTEDITFRAME_CELL_TYPE_DETAIL,  /* e.g. text_frame->cell_type */
                                        style_string,
                                        false,
                                        &cs_new_tooltip,
                                        &cs_new_style_sheet,
                                        &cs_new_cell_height,
                                        &cs_new_cell_width,
                                        &cs_new_action,
                                        &cs_new_enabled,
                                        &cs_new_shortcut,
                                        &cs_new_text,
                                        NULL);
    if (result_of_evaluate == true)
    {
      if (cs_new_action != "[]") explorer_widget->html_text_edit->explorer_context_menu->cmi[i_of_cmi].action= cs_new_action;
      if (cs_new_enabled != "[]") explorer_widget->html_text_edit->explorer_context_menu->cmi[i_of_cmi].enabled= cs_new_enabled.toLower();
      if (cs_new_shortcut != "[]") explorer_widget->html_text_edit->explorer_context_menu->cmi[i_of_cmi].shortcut= cs_new_shortcut;
      if (cs_new_text != "[]") explorer_widget->html_text_edit->explorer_context_menu->cmi[i_of_cmi].text= cs_new_text;
    }
  }
  return 0;
}


/*
  REHASH
  Make a cache of all objects in the current database.
  Not a great name, but mysql client requires "rehash" for something
  vaguely similar (they store some column names with a hash) (we don't).
  Currently we're taking in table_name, column_name from information_schema
  for the current database, into result_set_copy.
  Called if: REHASH statement, USE statement + auto_rehash > 0. and connect?
             Or for explorer, or for set ocelot_query = show foreign keys
  Todo: Allow REHASH [TABLES|TRIGGERS|etc.] [database.]name or *
        There might be multiple databases and multiple connections
  Todo: Allow triggers events procedures functions indexes
  Todo: Hover provides more information about the object
  Todo: We know declared variables or other things made within a
        routine (see hparse_f_labels etc.) but didn't merge with
        the results of this routine
  Todo: add rehash to Options menu
  Todo: see correlations | aliases
  Todo: error messages
  Todo: information_schema.engines if MySQL version >= 5.6
  Todo: information_schema.character_sets if MySQL version >= 5.?
  Beware: You don't have read access for everything.
  Beware: Names might be case sensitive.
  Beware: Qualifier might indicate a different database.
  Columns are "table.column"
  Symbols: 'D' database 'C' column 'T' table 'F' function 'P' procedure 't' trigger 'E' event 'I' index
           'K' keyword and 'i' identifier-unknown-type (temporary) 'V' variable
   When is rehash_scan() called:
    Only the "REHASH" statement does anything for sure.
    During connect | reconnect | "use" statement, we look at
    --auto-rehash or --no-auto-rehash or --skip-auto-rehash. We do.
    During "use" statement, we could redo rehashing. We do.
    So default = TRUE which is like --auto-rehash being default but only if connect.
    This affects unsigned short ocelot_ca.auto_rehash.
  When is rehash_search() called:
    When user hits ` i.e. backtick show the choices.
    When user hits ocelot_shortcut_autocomplete_keysequence which by
    default is \t i.e. tab Qt::Key_Tab, if there's an unambiguous name,
    fill it in (don't worry about what happens if user hits tab twice).
  Why we do a single unioned search with unnecessary columns:
    If we did multiple searches, we would affect MAX_QUERIES_PER_HOUR
    more. But this means there could be thousands of entries
    in the cache, and searches are sequential.
    Todo: add an order-by in the select, and do binary searches.
  Todo: if error, show results of mysql_error as well (as we do when user-input statements fail)
*/

int MainWindow::rehash_scan(char *error_or_ok_message, QString alternate_query)
{
#ifdef DBMS_TARANTOOL
  if ((connections_is_connected[0] == 1) && (connections_dbms[0] == DBMS_TARANTOOL))
    return rehash_scan_for_tarantool(error_or_ok_message, alternate_query);
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
  MYSQL_RES *res= NULL;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  ResultGrid *rg= NULL;
//  QString s;
  int er;                                                  /* for errors e.g. ER_NOT_CONNECTED */
#if (OCELOT_MYSQL_INCLUDE == 1)
  unsigned int *result_max_column_widths;                     /* dynamic-sized list of actual maximum widths in detail columns */
  result_max_column_widths= 0;
  int count_of_columns= 0;
  int count_of_tables= 0;
  int count_of_functions= 0;
  int count_of_procedures= 0;
  int count_of_triggers= 0;
  int count_of_events= 0;
  int count_of_indexes= 0;
#endif //#OCELOT_MYSQL_INCLUDE == 1)
  rehash_garbage_collect(); /* garbage_collect from the last rehash, if any. */

  if (connections_is_connected[0] != 1)
  {
    er= ER_NOT_CONNECTED;
    goto error_return;
  }
#if (OCELOT_MYSQL_INCLUDE == 1)
  /* Todo: Now 1024 isn't big enough if alternate_query <> NULL, because user can make up something big. */
  char query[1024];
if (alternate_query == "")
  sprintf(query, "select 'D',database(),'','' "
                 "union all "
                 "select 'C',table_name,column_name,'' "
                   "from information_schema.columns "
                 "where table_schema = database() "
                 "union all "
                 "select 'T',table_name,table_type,'' "
                 "from information_schema.tables "
                 "where table_schema = database() "
                 "union all "
                 "select 'F',routine_name,routine_type,'' "
                 "from information_schema.routines "
                 "where routine_schema = database() and routine_type = 'FUNCTION' "
                 "union all "
                 "select 'P',routine_name,routine_type,'' "
                 "from information_schema.routines "
                 "where routine_schema = database() and routine_type = 'PROCEDURE' "
                 "union all "
                 "select 't',trigger_name,'','' "
                 "from information_schema.triggers "
                 "where trigger_schema = database() "
                 "union all "
                 "select 'E',event_name,'','' "
                 "from information_schema.events "
                 "where event_schema = database() "
                 "union all "
                 "select 'I',table_name,index_name,column_name "
                 "from information_schema.statistics "
                 "where table_schema = database() "
         );
else
{
  strcpy(query, alternate_query.toUtf8());
}
  if (lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], query))
  {
    er= ER_SELECT_FAILED;
    goto error_return;
  }
  res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
  if (res == NULL)
  {
    er= ER_MYSQL_STORE_RESULT_FAILED;
    goto error_return;
  }
  rehash_result_column_count= lmysql->ldbms_mysql_num_fields(res);
  rehash_result_row_count= lmysql->ldbms_mysql_num_rows(res);
  if ((rehash_result_column_count == 0) || (rehash_result_row_count == 0))
  {
    lmysql->ldbms_mysql_free_result(res);
    er= ER_0_ROWS_RETURNED;
    goto error_return;
  }

  result_max_column_widths= new unsigned int[rehash_result_column_count];
  ResultGrid* result_grid;
  result_grid= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));
  {
    result_grid->scan_rows(
            rehash_result_column_count, /* result_column_count, */
            rehash_result_row_count, /* result_row_count, */
            res, /* grid_mysql_res, */
            &rehash_result_set_copy,
            &rehash_result_set_copy_rows,
            &result_max_column_widths);
    lmysql->ldbms_mysql_free_result(res);
  }
  delete [] result_max_column_widths;
  /* First set of rows is 'D',database(),''. If it's null, error. */
  char database_name[512];
  {
    rehash_get_database_name(database_name);
    if (database_name[0] == '\0')
    {
      er= ER_NO_DATABASE_SELECTED;
      goto error_return;
    }
  }
  long unsigned int r;
  for (r= 0; r < rehash_result_row_count; ++r)
  {
    char *row_pointer;
    unsigned int column_length;
    char column_value[512];
    row_pointer= rehash_result_set_copy_rows[r];
    memcpy(&column_length, row_pointer, sizeof(unsigned int));
    row_pointer+= sizeof(unsigned int) + sizeof(char);
    strncpy(column_value, row_pointer, column_length);
    column_value[column_length]= '\0';
    /* Todo: If explorer, we should count "S" schema and "V" view and "T" triggers as well. */
    if (strcmp(column_value, "C") == 0) ++count_of_columns;
    if (strcmp(column_value, "T") == 0) ++count_of_tables;
    if (strcmp(column_value, "F") == 0) ++count_of_functions;
    if (strcmp(column_value, "P") == 0) ++count_of_procedures;
    if (strcmp(column_value, "t") == 0) ++count_of_triggers;
    if (strcmp(column_value, "E") == 0) ++count_of_events;
    if (strcmp(column_value, "I") == 0) ++count_of_indexes;
  }
  if (rg != NULL) delete rg;

  er= ER_OK_REHASH;
  sprintf(error_or_ok_message, er_strings[er_off + er],
          database_name, count_of_tables, count_of_columns, count_of_functions, count_of_procedures, count_of_triggers, count_of_events, count_of_indexes);
  return er;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
error_return:
  if (rg != 0) delete rg;
  rehash_garbage_collect();
  strcpy(error_or_ok_message, er_strings[er_off + er]);
  return er;
}

/* Call if rehash_scan starts, rehash_scan fails, explorer or "show foreign keys" wipes out rehash_scan result */
/* Todo: maybe we should be garbage-collecting when disconnecting too */
void MainWindow::rehash_garbage_collect()
{
  if (rehash_result_set_copy != 0) { delete [] rehash_result_set_copy; rehash_result_set_copy= 0; }
  if (rehash_result_set_copy_rows != 0) { delete [] rehash_result_set_copy_rows; rehash_result_set_copy_rows= 0; }
  rehash_result_column_count= 0;
  rehash_result_row_count= 0;
}

#ifdef DBMS_TARANTOOL
int MainWindow::rehash_scan_for_tarantool(char *error_or_ok_message, QString alternate_query)
{
  (void)alternate_query;
  int count_of_columns= 0;
  int count_of_tables= 0;
  int count_of_functions= 0;
  int count_of_procedures= 0;
  int count_of_triggers= 0;
//  int count_of_fk_constraints= 0;
  int count_of_events= 0;
  int count_of_indexes= 0;
  int er;                                                  /* for errors e.g. ER_NOT_CONNECTED */
  {
    if (strcmp(tarantool_box_execute, "No SQL") == 0)
    {
      tarantool_errno[0]= 9998;
      er= ER_SELECT_FAILED;
      goto error_return;
    }

    /* We replaced eval() with tnt_select calls so we can use fewer privileges. */
    tarantool_table_ids.clear(); tarantool_table_names.clear();
    tarantool_column_table_names.clear(); tarantool_column_names.clear();
#if (OCELOT_EXPLORER == 1)
    tarantool_type_names.clear(); tarantool_table_engines.clear(); tarantool_index_column_numbers.clear();
#endif
    tarantool_index_table_names.clear(); tarantool_index_names.clear();
    tarantool_trigger_names.clear();
    tarantool_fk_constraint_names.clear();
    tarantool_fk_constraint_child_ids.clear();
    tarantool_fk_constraint_parent_ids.clear();
    rehash_scan_one_space(281); /* 281 is "_vspace" */
    rehash_scan_one_space(289); /* 289 is "_vindex" */
    rehash_scan_one_space(328); /* 328 is "_trigger" */
    rehash_scan_one_space(356); /* 356 is "_fk_constraint" */
    count_of_tables= tarantool_table_names.count();
    count_of_columns= tarantool_column_names.count();
    count_of_indexes= tarantool_index_names.count();
    count_of_triggers= tarantool_trigger_names.count();
//    count_of_fk_constraints= tarantool_fk_constraint_names.count();
#ifdef OLD_STYLE
    /*
      This is how to use Lua to produce what looks like an SQL result set.
      Todo:: This does 'C', 'T', 't', 'I'. It could do more, see MySQL/MariaDB SELECT below.
    */
    char lua_request[]=
       "do\
         local output_tuple\
         local output_table_of_tuples = {}\
         local vspace_list = {}\
         local x, y\
         local vspace_row_number, vspace_row, vspace_name, vspace_row_column_count, vspace_row_column_number\
         local vindex_list = {}\
         local vindex_row_number, vindex_row, vindex_name\
         local trigger_list = {}\
         local trigger_row_number, trigger_row, trigger_name\
         x, y = pcall(function () vspace_list = box.space._vspace:select() end)\
         if x then\
           for vspace_row_number = 1,#vspace_list do\
             vspace_row = vspace_list[vspace_row_number]\
             vspace_name = vspace_row[3]\
             vspace_row_column_count = #vspace_row[7]\
             if vspace_row_column_count ~= nil and vspace_row_column_count > 0 then\
               for vspace_row_column_number = 1, vspace_row_column_count do\
                 output_tuple = box.tuple.new('C', vspace_name, vspace_row[7][vspace_row_column_number].name)\
                 table.insert(output_table_of_tuples, output_tuple)\
                end\
             end\
           end\
           for vspace_row_number = 1,#vspace_list do\
             vspace_row = vspace_list[vspace_row_number]\
             vspace_name = vspace_row[3]\
             output_tuple = box.tuple.new('T', vspace_name, 'T')\
             table.insert(output_table_of_tuples, output_tuple)\
           end\
           x, y = pcall(function () trigger_list = box.space._trigger:select() end)\
           if x then\
             for trigger_row_number = 1,#trigger_list do\
               trigger_row = trigger_list[trigger_row_number]\
               trigger_name = trigger_row[1]\
               output_tuple = box.tuple.new('t', trigger_name, '')\
               table.insert(output_table_of_tuples, output_tuple)\
             end\
           end\
           x, y = pcall(function () vindex_list = box.space._vindex:select() end)\
           if x then\
             for vindex_row_number = 1,#vindex_list do\
               vindex_row = vindex_list[vindex_row_number]\
               vindex_name = vindex_row[3]\
               vspace_name = box.space._vspace:select(vindex_row[1])[1][3]\
               output_tuple = box.tuple.new('I', vspace_name, vindex_name)\
               table.insert(output_table_of_tuples, output_tuple)\
             end\
           end\
         end\
         local output_table_final = \
         {\
           ['metadata']=\
           {\
             {['name']='COLUMN_1',['type']='string'},\
             {['name']='COLUMN_2',['type']='string'},\
             {['name']='COLUMN_3',['type']='string'}\
           }\
           ,\
           ['rows']=\
           output_table_of_tuples\
         }\
         return output_table_final\
       end\
     ";

    /* Todo: Solve this mystery: why does result == 0 even if tarantool_execute_sql fails? */

    result= tarantool_execute_lua(lua_request, strlen(lua_request), 0);

    if (result != 0)
    {
      er= ER_SELECT_FAILED;
      goto error_return;
    }
    rg= new ResultGrid(lmysql, this, false, 0);
    MYSQL_RES *mysql_res_for_new_result_set= NULL;
    rg->fillup(mysql_res_for_new_result_set,
              //&tarantool_tnt_reply,
              connections_dbms[MYSQL_MAIN_CONNECTION],
              //this,
              lmysql, ocelot_ca.client_side_functions,
              MYSQL_MAIN_CONNECTION,
              false);

    tarantool_tnt_reply_data_p= tarantool_tnt_reply.data;
    rehash_result_column_count= tarantool_num_fields();
    rehash_result_row_count= tarantool_num_rows(MYSQL_MAIN_CONNECTION);
    if ((rehash_result_column_count == 0) || (rehash_result_row_count == 0))
    {
      er= ER_0_ROWS_RETURNED;
      goto error_return;
    }
#endif // OLD_STYLE
  }

  char database_name[512];
  strcpy(database_name, "main");
  er= ER_OK_REHASH;
  sprintf(error_or_ok_message, er_strings[er_off + er],
          database_name, count_of_tables, count_of_columns, count_of_functions, count_of_procedures, count_of_triggers, count_of_events, count_of_indexes);
  rehash_result_row_count= count_of_tables + count_of_columns + count_of_triggers + count_of_indexes;
  return er;
error_return:
  rehash_result_column_count= 0;
  rehash_result_row_count= 0;
  strcpy(error_or_ok_message, er_strings[er_off + er]);
  return er;
}

/*
  For picking out fields we want from Tarantool system spaces _vspace or _vindex or _trigger
  Re possible changes in format:
    Todo: This will fail if the name fields are not in the expected positions. We should check "format" clauses in _space.
    If new fields are added at the end, or if the order ofiems in the column list changes, we should be safe.
  Re index column:
    In _vindex column 5 there is a "parts" array. For system tables members are usually arrays.
    For SQL tables members are usually maps. Although multi-column indexes are possible, we only note the first.
    If members are arrays then the column that the index part refers to is the first array item.
    If members are maps then the column that the index part refers to is the one named "field".
    We put this number in index_column_numbers but the job is not done yet -- we convert it later
    to a column name for oei[].part_type.
*/
void MainWindow::rehash_scan_one_space(int space_number)
{
  int field_number_of_id;
  int field_number_of_name;
  int field_number_of_columns;
#if (OCELOT_EXPLORER == 1)
  int field_number_of_engine= -1;
  int field_number_of_sql= -1;
#endif
  if (space_number == 281) /* 281 is "_vspace" */
  {
    field_number_of_id= 0;
    field_number_of_name= 2;
    field_number_of_columns= 6;
#if (OCELOT_EXPLORER == 1)
    field_number_of_engine= 3;
    field_number_of_sql= 5;
    /* field_number_of_columns= 6; */
#endif
  }
  if (space_number == 289) /* 289 is "_vindex" */
  {
    field_number_of_id= 0;
    field_number_of_name= 2;
    field_number_of_columns= 5;
  }
  if (space_number == 328) /* 328 is "_trigger" */
  {
    field_number_of_id= 1;
    field_number_of_name= 0;
    field_number_of_columns= -1;
  }
  if (space_number == 356) /* 356 is "_fk_constraint", late addition for foreign keys */
  {
    field_number_of_id= -1; /* we'll get child_id and parent_id in a more hardcoded way */
    field_number_of_name= 0;
    field_number_of_columns= -1;
  }
  int returned_result_set_type;
  tarantool_execute_lua_select(0, space_number); /* 0 is assumed connection number, e.g. space_number is 280 "_space" */
  if (tarantool_errno[0] != 0)
  {
    result_row_count= 0;
    return;
  }
  result_row_count= tarantool_num_rows(0); /* hmm. maybe I should prefer result_set_init()? */
  if (result_row_count == 0) return;
  const char *tarantool_tnt_reply_data_copy;
  tarantool_tnt_reply_data_copy= tarantool_seek_0(&returned_result_set_type); /* "seek to row 0" */
  for (unsigned int row_number= 0; row_number < result_row_count; ++row_number)
  {
    QString table_id;
    QString table_name;
    int number_of_fields= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy);
    for (int field_number= 0; field_number < number_of_fields; ++field_number)
    {
      if ((field_number == field_number_of_id)
       && (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_UINT))
      {
        uint32_t id= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy);
        table_id= QString::number(id);
      }

      else if ((field_number == 1) && (space_number == 356) /* Version 1.9 addition for foreign keys */
        & (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_UINT))
      {
        uint32_t id= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy);
        tarantool_fk_constraint_child_ids << QString::number(id);
      }
      else if ((field_number == 2) && (space_number == 356) /* Version 1.9 addition for foreign keys */
        & (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_UINT))
      {
        uint32_t id= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy);
        tarantool_fk_constraint_parent_ids << QString::number(id);
      }

      else if ((field_number == field_number_of_name)
            && (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_STR))
      {
        const char *value;
        uint32_t value_length;
        value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
        QString returned_string= QString::fromUtf8(value, value_length);
        if (space_number == 281)
        {
          table_name= returned_string;
          tarantool_table_ids << table_id;
          tarantool_table_names << table_name;
        }
        if (space_number == 289)
        {
          int index_of_table_name= tarantool_table_ids.indexOf(table_id);
          if (index_of_table_name >= 0)
          {
            tarantool_index_table_names << tarantool_table_names.at(index_of_table_name);
            tarantool_index_names << returned_string;
          }
        }
        if (space_number == 328)
        {
          tarantool_trigger_names << returned_string;
        }
        if (space_number == 356)
        {
          tarantool_fk_constraint_names << returned_string;
        }
      }
#if (OCELOT_EXPLORER == 1)
      else if ((field_number == field_number_of_engine)
            && (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_STR))
      {
        /* blackhole | memtx | vinyl | sysview | service. We might replace with what's in 'sql'. */
        const char *value;
        uint32_t value_length;
        value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
        QString returned_string= QString::fromUtf8(value, value_length);
        tarantool_table_engines << returned_string;
      }
      else if ((field_number == field_number_of_sql)
            && (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_MAP))
      {
        /* Possibly: 'sql'+create-view-statement, 'view'+true. let's take the 'sql'. */
        /* Todo: much here is a duplicate of what we do for field_number_of_columns */
        uint32_t number_of_map_members= lmysql->ldbms_mp_decode_map(&tarantool_tnt_reply_data_copy);
        for (unsigned int i= 0; i < number_of_map_members; ++i)
        {
          const char *value;
          uint32_t value_length;
          QString returned_string;
          int typex= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy);
          if (typex != MP_STR)
          {
            value_length= 0;
            lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);
          }
          else
          {
            value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
            returned_string= QString::fromUtf8(value, value_length);
            if ((value_length == 3) && (returned_string == "sql"))
            {
              value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
              returned_string= QString::fromUtf8(value, value_length);
              int i_of_last_engine= tarantool_table_engines.size() - 1;
              tarantool_table_engines[i_of_last_engine]= returned_string;
            }
            else
              lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy); /* skip */
          }
        }
      }
      else if ((field_number == field_number_of_columns)
            && (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_ARRAY)
            && (space_number == 289)) /* see comment preceding this function = "Re index column" */
      {
        const char *tarantool_tnt_reply_data_copy_pushed= tarantool_tnt_reply_data_copy; /* push */
        int column_5_field_number= -1;
        uint32_t number_of_column_5_parts= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy);
        for (unsigned int part_number= 0; part_number < number_of_column_5_parts; ++part_number)
        {
          int type_of= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy);
          if (type_of == MP_ARRAY)
          {
            uint32_t i_array_count= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy);
            for (unsigned int i_array_number= 0; i_array_number < i_array_count; ++i_array_number)
            {
              int array_element_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy);
              if (array_element_type == MP_UINT)
              {
                column_5_field_number= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy);
                break;
              }
              else lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);
            }
          }
          else if (type_of == MP_MAP)
          {
            uint32_t i_map_count= lmysql->ldbms_mp_decode_map(&tarantool_tnt_reply_data_copy);
            const char *value= NULL;
            uint32_t value_length;
            for (unsigned int i_map_number= 0; i_map_number < i_map_count * 2; ++i_map_number)
            {
              int map_element_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy);
              if (map_element_type == MP_STR)
              {
                value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
              }
              else if (map_element_type == MP_UINT)
              {
                uint32_t x= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy);
                if ((value_length == 5) && memcmp(value, "field",5) == 0)
                {
                  column_5_field_number= x;
                  break;
                }
              }
              else lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);
            }
          }
          else lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);      /* skip */
          if (column_5_field_number != -1) break;
        }
        tarantool_index_column_numbers << QString::number(column_5_field_number);
        tarantool_tnt_reply_data_copy= tarantool_tnt_reply_data_copy_pushed; /* pop */
        lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);      /* skip */
      }
#endif
      else if ((field_number == field_number_of_columns)
            && (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) == MP_ARRAY))
      {
        uint32_t number_of_columns= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy);
        for (unsigned int column_number= 0; column_number < number_of_columns; ++column_number)
        {
          uint32_t number_of_map_members= lmysql->ldbms_mp_decode_map(&tarantool_tnt_reply_data_copy);
          for (unsigned int i= 0; i < number_of_map_members; ++i)
          {
            const char *value;
            uint32_t value_length;
            QString returned_string;
            if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) != MP_STR)
            {
              value_length= 0;
              lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);
            }
            else
            {
              value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
              returned_string= QString::fromUtf8(value, value_length);
            }
            if ((value_length == 4) && (returned_string == "name"))
            {
              if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy) != MP_STR)
              {
                lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);
              }
              else
              {
                value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
                returned_string= QString::fromUtf8(value, value_length);
                tarantool_column_table_names << table_name;
                tarantool_column_names << returned_string;
              }
            }
            else
            {
#if (OCELOT_EXPLORER == 1)
              if ((value_length == 4) && (returned_string == "type"))
              {
                value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &value_length);
                returned_string= QString::fromUtf8(value, value_length);
                tarantool_type_names << returned_string;
              }
              else
#endif
              lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy); /* skip type */
            }
          }
        }
      }
      else
      {
        lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);      /* skip */
      }
    }
  }
}
#endif

/*
  Called from hparse_f_multi_block() for adding to the "Expecting:" list
  Pass: search string. Return: column name matching searching string.
  Re ""s: An identifier if starts-with-digit or has-lower-case or has-non-alpha-or-digit isn't regular.
          So making it a delimited identifier seems reasonable in this context.
          But in MySQL/MariaDB it's complicated due to ansi-quotes, backtick use, and whether lower-case matters.
          So for now we only check for Tarantool.
  Todo: We only look at column[1] column_name. We should look at column[0] table_name.
  Todo: Matching reftype is fine but we could also match column's table or index's table if we know it.
        !! NOW WE KNOW IT! Well, for column anyway.
  Todo: Should not the search be case insensitive?
  Todo: Consider stopping display after TARANTOOL_MAX_FIELD_NAME_LENGTH or MYSQL_MAX_IDENTIFIER_LENGTH characters.
  Todo: "count_of_hits > 100" is arbitrary, and also you should add "..."
  Todo: Perhaps the QByteArray() trick here could be used elsewhere where we're currently using strncpy().
  Todo: We avoid duplicates e.g. "primary".
        But that disturbs the order, and something that occurs more often should be first.
        And if you ever get more info e.g. column-type or table-of-index then it will be ambiguous.
  Todo: We could call QStringList::sort()
  Todo: Comparisons are case insensitive but don't have to be if "" encloses
  Todo: Change pass of TOKEN_TYPE_IDENTIFIER if in fact it's within backticks or ""s
  Todo: If it's a function, call completer_widget->append_wrapper with final argument i.e. flags|= TOKEN_FLAG_IS_FUNCTION
*/
QString MainWindow::rehash_search(QString table_name, char *search_string, int reftype,
                    QString hparse_token,
                    bool is_exact_required,
                    QString specified_schema,
                    QStringList specified_list)
{
  QStringList special_handling_names;
  if (search_string[0] == '"') ++search_string;
  else if (search_string[0] == '`') ++search_string;

  long unsigned int r;
  char *row_pointer;
  unsigned int column_length;
  unsigned int i;
  QString column_value;
  QStringList column_value_list;
  unsigned int search_string_length;
//  QString tmp_word= "";
  int count_of_hits= 0;
  char desired_types[TOKEN_REFTYPE_MAX]= "";
  unsigned int column_to_match= 0;
  search_string_length= strlen(search_string);
  column_value_list.clear();
  if ((reftype == TOKEN_REFTYPE_COLUMN)
   || (reftype == TOKEN_REFTYPE_TABLE_OR_COLUMN)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN_OR_FUNCTION)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN_OR_FUNCTION_OR_VARIABLE)
   || (reftype == TOKEN_REFTYPE_COLUMN_OR_USER_VARIABLE)
   || (reftype == TOKEN_REFTYPE_COLUMN_OR_VARIABLE)
   || (reftype == TOKEN_REFTYPE_TABLE_OR_COLUMN_OR_FUNCTION))
  {
    strcpy(desired_types, "C");
    column_to_match= 2;
  }
  else if ((reftype == TOKEN_REFTYPE_FUNCTION)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_FUNCTION))
  {
    strcpy(desired_types, "F");
    column_to_match= 1;
  }
  else if ((reftype == TOKEN_REFTYPE_PROCEDURE)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_PROCEDURE))
  {
    strcpy(desired_types, "P");
    column_to_match= 1;
  }
  else if ((reftype == TOKEN_REFTYPE_FUNCTION_OR_PROCEDURE)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_FUNCTION_OR_PROCEDURE))
  {
    strcpy(desired_types, "FP");
    column_to_match= 1;
  }
  else if ((reftype == TOKEN_REFTYPE_TABLE)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_TABLE))
  {
    strcpy(desired_types, "T");
    column_to_match= 1;
  }
  else if ((reftype == TOKEN_REFTYPE_TRIGGER)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_TRIGGER))
  {
    strcpy(desired_types, "t");
    column_to_match= 1;
  }
  else if ((reftype == TOKEN_REFTYPE_EVENT)
   || (reftype == TOKEN_REFTYPE_DATABASE_OR_EVENT))
  {
    strcpy(desired_types, "E");
    column_to_match= 1;
  }
  else if (reftype == TOKEN_REFTYPE_INDEX)
  {
    strcpy(desired_types, "I");
    column_to_match= 2;
  }
  else if ((reftype == TOKEN_REFTYPE_DATABASE) && (ocelot_explorer_visible == "yes"))
  {
    strcpy(desired_types, "D");
    column_to_match= 1;
  }
  else
  {
    return "not rehashed";
  }
  bool is_special_handling= false;
  if (desired_types[0] == 'D') /* For database|schema rehash isn't useful but explorer is. */
  {
#ifdef DBMS_TARANTOOL
    if (connections_dbms[0] == DBMS_TARANTOOL)
    {
      column_value_list.append("main");
      count_of_hits= 1;
      goto ok_return;
    }
#endif
    special_handling_names.clear();
    for (unsigned int i_of_oei= 0; i_of_oei < oei_count; ++i_of_oei)
    {
      if (oei[i_of_oei].object_type == "S")
      {
        special_handling_names << oei[i_of_oei].object_name;
      }
    }
    is_special_handling= true;
  }

  if ((desired_types[0] == 'T') && (specified_schema > "")) /* for erdiagram (table list) */
  {
    is_special_handling= true;
  }

  if ((connections_dbms[0] == DBMS_TARANTOOL) || (is_special_handling == true))
  {
    QStringList *q= NULL;
    QStringList *q2= NULL;
    if (desired_types[0] == 'D') q= &special_handling_names;
    else if ((desired_types[0] == 'T') && (specified_schema > "")) q= &specified_list;
#ifdef DBMS_TARANTOOL
    else if (desired_types[0] == 'T') q= &tarantool_table_names;
    else if (desired_types[0] == 't') q= &tarantool_trigger_names;
    else if (desired_types[0] == 'I') { q= &tarantool_index_names; q2= &tarantool_index_table_names; }
    else if (desired_types[0] == 'C') { q= &tarantool_column_names; q2= &tarantool_column_table_names; }
#endif
    if (q != NULL)
    {
      for (int i= 0; i < (*q).count(); ++i)
      {
        QString s= (*q).at(i);
        if ((q2 != NULL) && (table_name > ""))
        {
          if (QString::compare((*q2).at(i), table_name, Qt::CaseInsensitive) != 0) continue;
        }
        if (is_exact_required == true)
        {
          if (QString::compare(s, search_string, Qt::CaseInsensitive) == 0) return s;
        }
        else
        {
          if (search_string_length < (unsigned) s.length())
          {
            if (QString::compare(s.left(search_string_length), search_string, Qt::CaseInsensitive) == 0)
            {
              if (count_of_hits > 100) break;
              ++count_of_hits;
              column_value_list.append(s);
            }
          }
        }
      }
    }
    goto ok_return;
  }
  /* not Tarantool, not (database + explorer) */
  for (r= 0; r < rehash_result_row_count; ++r)
  {
    row_pointer= rehash_result_set_copy_rows[r];
    bool is_table_matched= true;
    for (i= 0; i < rehash_result_column_count; ++i)
    {
      memcpy(&column_length, row_pointer, sizeof(unsigned int));
      row_pointer+= sizeof(unsigned int) + sizeof(char);
      /* Now row_pointer points to contents, length has # of bytes */
      if (i == 0)
      {
        assert(column_length == 1);
        if (strchr(desired_types, *row_pointer) == NULL) break;
      }
      if ((i == 1) && (column_to_match == 2) && (table_name > ""))
      {
        QByteArray table_value_as_qbytearray= QByteArray(row_pointer, column_length);
        if (QString::compare(table_value_as_qbytearray, table_name, Qt::CaseInsensitive) != 0) is_table_matched= false;
      }
      if ((i == column_to_match) && (is_table_matched == true))
      {
        if (is_exact_required == true)
        {
          QByteArray column_value_as_qbytearray= QByteArray(row_pointer, column_length);
          if (QString::compare(column_value_as_qbytearray, search_string, Qt::CaseInsensitive) == 0)
          {
            QString s= column_value_as_qbytearray;
            return s;
          }
          else
          {
            ;
          }
        }
        else
        {
          QByteArray column_value_as_qbytearray= QByteArray(row_pointer, column_length);
          if (search_string_length < column_length)
          {
            {
              column_value= column_value_as_qbytearray;
              if (column_value_list.contains(column_value) == false)
              {
                column_value_list.append(column_value);
                ++count_of_hits;
                if (count_of_hits > 10) break;
              }
            }
          }
        }
      }
      row_pointer+= column_length;
    }
    if (count_of_hits > 100) break;
  }
ok_return:
  if (count_of_hits == 0) return "";
  for (int i= 0; i < column_value_list.size(); ++i)
  {
    QString token= column_value_list.at(i);
    /* TEST!!!! */
    QString hparse_s= hparse_token;
    if (hparse_s.left(1) == "\"") hparse_s= hparse_s.right(hparse_s.size() - 1);
    if (hparse_s.left(1) == "`") hparse_s= hparse_s.right(hparse_s.size() - 1);
    completer_widget->append_wrapper(token, hparse_s, TOKEN_TYPE_IDENTIFIER, 0, desired_types);
    //tmp_word.append(column_value_list.at(i));
    //tmp_word.append(" ");
  }
  return "OK";
}

void MainWindow::rehash_get_database_name(char *database_name)
{
  *database_name= '\0';
  if (rehash_result_set_copy == 0) return;
  char *row_pointer;
  unsigned int column_length;
  row_pointer= rehash_result_set_copy_rows[0];
  memcpy(&column_length, row_pointer, sizeof(unsigned int));
  row_pointer+= sizeof(unsigned int) + sizeof(char);
  row_pointer+= column_length;
  memcpy(&column_length, row_pointer, sizeof(unsigned int));
  row_pointer+= sizeof(unsigned int);
  if ((*row_pointer & FIELD_VALUE_FLAG_IS_NULL) != 0) return;
  row_pointer+= sizeof(char);
  strncpy(database_name, row_pointer, column_length);
  *(database_name + column_length)= '\0';
}

#if (OCELOT_EXTENDER == 1)
/*
  The code is a bit like rehash_scan().
  The alternate_query value is what I call a "semiselect", i.e. ANALYZE, CHECK, CHECKSUM, DESC|DESCRIBE, EXPLAIN, HELP, SHOW.
  Execute it, and convert the result set into SELECT ... UNION ALL SELECT ...
  Example (simplified to show only one DESCRIBE column ('S1') and only two rows):
    DESCRIBE t7 WHERE `Field` > '';
    In hparse.h we established that the DESCRIBE is marked with TOKEN_FLAG_IS_SEMISELECT, the WHERE is marked with
    TOKEN_FLAG_IS_SEMISELECT_MID, the ; is marked with TOKEN_FLAG_IS_SEMISELECT_END. So before calling here we were able
    to figure out that there is an initial section "DESCRIBE t7" which we will pass to the server, and a trailing section
    "WHERE `Field` > ''" which we will apply to the server results. What we'll do is
    describe t7;                    << Send this to the server
    (SELECT * FROM                   << Always produce this at start
    (SELECT ... UNION SELECT ...)    << Produce SELECT ... UNION SELECT ... from the server results
    AS ocelot_extender_result_set  << Always produce this after the SELECT ... UNION SELECT ...
    where `Field` > ''               << Produce whatever hparse.h saw when doing hparse_f_select_part_2(), might be blank
    )                                << Always produce this at end
    So that we end up with
    (select * from (SELECT 's1' AS `Field` union all select 's1') AS ocelot_extender_result_set WHERE `Field` > '')
  Beware: Sometimes names can be reserved words, e.g. DESCRIBE table_name; emits a column named Null.
          So I put within ``s. Alternatively I could use ""s if sql_mode allows, or check first if name is really reserved.
*/
int MainWindow::extender_scan(char *error_or_ok_message, QString alternate_query, QString *select_statement_out, QString semiselect_part_2, int offset_of_into, int innodb_status_count)
{
  MYSQL_RES *res= NULL;
  ResultGrid *rg= NULL;
  int er;                                                  /* for errors e.g. ER_NOT_CONNECTED */
  char *result_field_names_pointer;
  unsigned int v_length;
  QString fillup_result;
  QString this_column_name;
  char result_field_name[256];
  unsigned int extender_result_column_count= 0; /* Todo: check: why isn't this long unsigned int? */
  unsigned int extender_result_row_count= 0;
  char **extender_result_set_copy_rows= 0; /* dynamic-sized list of result_set_copy row offsets, if necessary */
  char *extender_result_field_names;
  QStringList extender_column_names;
  QList<int> extender_column_types;
  QString select_statement= "";
  long unsigned int r;
  /* Todo: this isn't big enough if SHOW has a big WHERE clause */
  char query[2048];
  strcpy(query, alternate_query.toUtf8());
  /* todo: add ";" */
  if (lmysql->ldbms_mysql_query(&mysql[MYSQL_MAIN_CONNECTION], query))
  {
    er= ER_SELECT_FAILED;
    goto error_return;
  }
  /* Todo: say "false" instead of "true" after there's a fix for the apparent bug with is_displayable */
  rg= new ResultGrid(lmysql, this, true, 0);

  res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
  if (res == NULL)
  {
    er= ER_MYSQL_STORE_RESULT_FAILED;
    goto error_return;
  }
  fillup_result= rg->fillup(res,
            //&tarantool_tnt_reply,
            connections_dbms[0],
            //this,
            lmysql, ocelot_ca.client_side_functions,
            MYSQL_MAIN_CONNECTION,
            false);
  if (fillup_result != "OK")
  {
//    /* fillup() failure is unexpected so this is crude */
//    put_message_in_result(fillup_result);
//    return_value= 1;
//    goto statement_is_aborted;
      er= ER_ERROR;       /* Todo: this message doesn't capture what fillup_result actually says */
      goto error_return;
  }
  extender_result_row_count= rg->result_row_count;
  if (extender_result_row_count == 0)
  {
    er= ER_0_ROWS_RETURNED;
    goto error_return;
  }
  extender_result_column_count= rg->result_column_count;
  extender_result_set_copy_rows= rg->result_set_copy_rows;
  extender_result_field_names= rg->result_field_names;
  {
    extender_column_names.clear(); /* unnecessary if by QStringList is initially clear */
    extender_column_types.clear(); /* unnecessary if by QList is initially clear */
    result_field_names_pointer= &extender_result_field_names[0];
    for (unsigned int j= 0; j < extender_result_column_count; ++j)
    {
      memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
      result_field_names_pointer+= sizeof(unsigned int);
      memcpy(result_field_name, result_field_names_pointer, v_length);
      result_field_name[v_length]= '\0';
      result_field_names_pointer+= v_length;
      this_column_name= result_field_name;
      extender_column_names.append(this_column_name);
      unsigned short int column_type= extender_result_data_type(rg->result_field_types[j]);
      extender_column_types.append(column_type);
    }
  }
  for (r= 0; r < extender_result_row_count; ++r)
  {
    char *row_pointer;
    unsigned int column_length;
    QString column_value;
    row_pointer= extender_result_set_copy_rows[r];
    unsigned int col;
    char field_value_flags;
    if (r == 0) select_statement= "(SELECT * FROM (SELECT ";
    else /* if (r > 0) */ select_statement= select_statement + " UNION ALL SELECT ";
    for (col= 0; col < extender_result_column_count; ++col)
    {
      memcpy(&column_length, row_pointer, sizeof(unsigned int));
      field_value_flags= *(row_pointer + sizeof(unsigned int));
      row_pointer+= sizeof(unsigned int) + sizeof(char);
      column_value= QString::fromUtf8(row_pointer, column_length);
      if ((innodb_status_count == 3) && (extender_result_row_count == 1) && (extender_result_column_count == 3))
      {
        if (col < 2) { row_pointer+= column_length; continue; }
        select_statement= select_statement + extender_flattener(column_value);
        break;
      }
      if (col > 0) select_statement= select_statement + ",";
      /* todo: should I try to use NULL_STRING here? */
      if ((field_value_flags & FIELD_VALUE_FLAG_IS_NULL) != 0) select_statement= select_statement + "NULL";
      else if (extender_column_types.at(col) == OCELOT_DATA_TYPE_NUMBER) select_statement= select_statement + column_value;
      else select_statement= select_statement + connect_unstripper(column_value);
      if (r == 0)
      {
        select_statement= select_statement + " AS `" + extender_column_names.at(col) + "`";
      }
      row_pointer+= column_length;
    }
  }
  select_statement= select_statement + ") AS ocelot_extender_result_set ";
  if (offset_of_into != -1)
  {
    select_statement= select_statement + semiselect_part_2.mid(0, offset_of_into);
    select_statement= select_statement + ")";
    select_statement= select_statement + semiselect_part_2.mid(offset_of_into, semiselect_part_2.length() - offset_of_into);
  }
  else
  {
    select_statement= select_statement + semiselect_part_2;
    select_statement= select_statement + ")";
  }
  /* todo: ";" appropriate here? */
  er= ER_OK;
  //sprintf(error_or_ok_message, er_strings[er_off + er],
  //        database_name, count_of_tables, count_of_columns, count_of_functions, count_of_procedures, count_of_triggers, count_of_events, count_of_indexes);
  /* fall through into error_return with er == ER_OK */
error_return:
  if (rg != NULL) delete rg; /* This caused an occasional crash but I think I have made a workaround for that. */
  if (res != NULL) lmysql->ldbms_mysql_free_result(res);
//  if (extender_result_set_copy != 0) { delete [] extender_result_set_copy; }
//  if (extender_result_set_copy_rows != 0) { delete [] extender_result_set_copy_rows; }
  /* any more garbage_collect to do? */
  strcpy(error_or_ok_message, er_strings[er_off + er]);
  *select_statement_out= select_statement;
  return er;
}

/* nearly the same as cha_result_data_type() but I'm not sure whether Charts can be disabled */
unsigned short int MainWindow::extender_result_data_type(unsigned short int result_field_type)
{
  unsigned short int ft= result_field_type;
  if ((ft == OCELOT_DATA_TYPE_DATE) || (ft == OCELOT_DATA_TYPE_TIME) || (ft == OCELOT_DATA_TYPE_DATETIME)
   || (ft == OCELOT_DATA_TYPE_VAR_STRING) || (ft == OCELOT_DATA_TYPE_STRING) || (ft == OCELOT_DATA_TYPE_TEXT))
    return OCELOT_DATA_TYPE_STRING;
  if ((ft == OCELOT_DATA_TYPE_DECIMAL) || (ft == OCELOT_DATA_TYPE_TINY) || (ft == OCELOT_DATA_TYPE_SHORT)
   || (ft == OCELOT_DATA_TYPE_LONG) || (ft == OCELOT_DATA_TYPE_FLOAT) || (ft == OCELOT_DATA_TYPE_DOUBLE)
   || (ft == OCELOT_DATA_TYPE_LONGLONG) || (ft == OCELOT_DATA_TYPE_INT24)
   || (ft == OCELOT_DATA_TYPE_NEWDECIMAL) || (ft == OCELOT_DATA_TYPE_INTEGER)
   || (ft == OCELOT_DATA_TYPE_UNSIGNED) || (ft == OCELOT_DATA_TYPE_NUMBER))
    return OCELOT_DATA_TYPE_NUMBER;
  if (ft == OCELOT_DATA_TYPE_NULL) return OCELOT_DATA_TYPE_NUMBER; /* But NULL isn't a number! Just for testing though. */
  return OCELOT_DATA_TYPE_BLOB;
}

/*
  We've seen that (innodb_status_count == 3) that means we saw the words ENGINE and INNODB STATUS in the input,
  and we've seen that there's 1 row and 3 columns (which is "certain") although we won't assume it).
  We ignored the first two columns. We're passing the value of the third column. Flatten it.
  We want a table with: HEADING | CATEGORY | SUBCATEGORY | COUNTER.
  Rule #1: a line between ===============s is a heading.
  Rule #2: a line between ---------------s is a category of the last-mentioned heading
  Rule #3: a line after a category is a list of subcategories of the last-mentioned category
  Rule #4: Commas delimit subcategories (if there are no commas then there is only one subcategory)
  Rule #5: If a subcategory ends or starts with a number, break it up into: subcategory | number
  Rulle #6: If the first subcategory in a line is a capitalized word, repeat it for other subcategories in the same line
  Rule #7: Lines that bein with --- are subcategory prefixes. (This mainly applies for ---TRANSACTIONS)
  Rule #8: The text "No buffer pool page gets since the last printout" should be interpreted as "0 buffer pool page gets since the last printout"
  Rule #9: If a line ends with number "/s", that equals
  Rule #A: If a heading is followed immediately by another heading, i.e. is blank, we put out heading ... 0
  Rule #X: There are a few more ad-hoc adjustments, see the code
  Known Flaws
    COLUMN_COUNTER is string, if I made it numeric then the display would have post-decimal digits even for integers.
    "Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s"
      we would repeat "Pages "
    "table size 34679, node heap has 0 buffer(s)"
      we won't see the 0
    "Spin rounds per wait: 20.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx"
      "Spin rounds per wait:" should be a prefix
    "Purge done for trx's n:o < 236 undo n:o < 0 state: running
      looks hopeless
    "I/O sum[0]:cur[0], unzip sum[0]:cur[0]"
      looks hopeless
    "LATEST FOREIGN KEY ERROR" or "LATEST DETECTED DEADLOCK"
      we don't choke completely but the result looks pretty bad
    "Buffer pool hit rate 1000 / 1000"
      we see the second 1000
*/
QString MainWindow::extender_flattener(QString column_value)
{
  QString select_statement("");
  QStringList ql= column_value.split("\n");
  QString equals("=");
  QString dash("-");
  QString column_heading("");
  QString column_category("");
  QString subcategory_prefix("");
  int line_count= 0;
  for (int i= 0; i < ql.size(); ++i)
  {
    QString qline= ql.at(i);
    if (qline.length() == 0) continue;
    if (qline == equals.repeated(qline.length())) /* if =====s, the next line will be column_1 */
    {
      QString left_of_line= ql.at(i + 1).left(19);
      column_heading= connect_unstripper(left_of_line);
      i+= 2;
      continue;
    }
    if (qline == dash.repeated(qline.length())) /* if -----s, the next line will be category */
    {
      column_category= connect_unstripper(ql.at(i + 1));
      subcategory_prefix= "";
      i+= 2;
      if ((ql.at(i + 1) == dash.repeated(ql.at(i + 1).length())) && (line_count > 0)) /* empty category? */
      {
        select_statement= select_statement + " UNION ALL SELECT " + column_heading + "," + column_category + ", ''" + ", 0 ";
      }
      continue;
    }
    if (column_category == "") continue; /* no -------s yet */
    if (qline.left(3) == "---") { subcategory_prefix= qline + " "; continue; }
    QStringList subcategory_list= qline.split(",");
    for (int j=0; j < subcategory_list.size(); ++j) /* for each subcategory */
    {
      QString column_subcategory= subcategory_list.at(j).trimmed();
      if (column_subcategory == "No buffer pool page gets since the last printout")
        column_subcategory= "0 buffer pool page gets since the last printout";
      bool is_number_solidus_s_seen= false;
      if (column_subcategory.right(2) == "/s")
      {
        QString c= column_subcategory.mid(column_subcategory.length() - 3, 1);
        if ((c >= "0") && (c <= "9"))
        {
          is_number_solidus_s_seen= true;
          column_subcategory= column_subcategory.left(column_subcategory.length() - 2);
        }
      }
      QString column_counter= "";
      for (;;) /* subcategory ends with number? */
      {
        bool is_digit= false;
        QString c= column_subcategory.right(1);
        if ((c >= "0") && (c <= "9")) is_digit= true;
        if ((c == ".") && (column_counter != "")) is_digit= true;
        if (is_digit == true)
        {
          column_counter= c + column_counter;
          column_subcategory= column_subcategory.left(column_subcategory.length() - 1);
        }
        else break;
      }
      if (is_number_solidus_s_seen == true) column_subcategory= column_subcategory + " (/s)";
      if (column_counter == "")
      {
        for (;;) /* (else) subcategory starts with number? */
        {
          bool is_digit= false;
          QString c= column_subcategory.left(1);
          if ((c >= "0") && (c <= "9")) is_digit= true;
          if ((c == ".") && (column_counter != "")) is_digit= true;
          if (is_digit == true)
          {
            column_counter= c + column_counter;
            column_subcategory= column_subcategory.right(column_subcategory.length() - 1);
          }
          else break;
        }
      }
      if (subcategory_prefix > "") column_subcategory= subcategory_prefix + column_subcategory; /* e.g. ---TRANSACTIONS */

      if (j > 0) /* this is not first subcategory in line and first word in first subcategory in line is Capitalized? */
      {
        QString first_subcategory= subcategory_list.at(0).trimmed();
        QString first_word = first_subcategory.section(" ", 0, 0, QString::SectionIncludeTrailingSep);
        if (first_word.right(1) == " ")
        {
          QChar first_word_first_char= first_word.at(0);
          if (first_word_first_char.isUpper() == true)
          {
            column_subcategory= first_word + column_subcategory;
          }
        }
      }
      column_subcategory= connect_unstripper(column_subcategory);
      column_counter= connect_unstripper(column_counter);
      if ((line_count > 0) || (j > 0)) select_statement= select_statement + " UNION ALL SELECT ";
      select_statement= select_statement + column_heading;
      if ((line_count == 0) && (j == 0)) select_statement= select_statement + " AS HEADING ";
      select_statement= select_statement + "," + column_category;
      if ((line_count == 0) && (j == 0)) select_statement= select_statement + " AS CATEGORY ";
      select_statement= select_statement + "," + column_subcategory;
      if ((line_count == 0) && (j == 0)) select_statement= select_statement + " AS SUBCATEGORY ";
      select_statement= select_statement + "," + column_counter;
      if ((line_count == 0) && (j == 0)) select_statement= select_statement + " AS COUNTER ";
    }
    ++line_count;
  }
  return select_statement;
}

#endif // #if (OCELOT_EXTENDER == 1)


/*
  Call widget_sizer() from action_execute() to resize the three
  main_layout widgets if necessary.
  Todo: so far widget_sizer() is just ideas, mostly unimplemented.
  The widgets are in a layout (although grid and history and debug leave the layout if detached).
  But the maximum sizing can be helped by me. Some rules are:
  * If history_edit_widget is higher than needed without scrolling, shrink it.
  * If user has manually expanded a window, leave it.
    ** But a grid should snap back to a minimum size
  * A select() should be visible, up to some maximum line count, even if a result set has many rows.
  * We need a scroll bar for the whole main window. But maybe not for all the main_layout widgets?
  * The widget might be detached -- in that case the sizes of other widgets won't matter.
  * The statement window can shrink quite a bit because after action_execute() there's nothing in it.
  Probably TitleBarHeight won't matter because we set the bar to vertical (update: no, I gave up on vertical)
  Probably PM_DefaultFrameWidth won't matter but I'm not sure what it is.
  So far all I've thought about is a special case for detaching.
    It's a bit silly to allow for height of a horizontal scroll bar, if there is no scroll bar.
  Maybe we should use the WA_DontShowOnScreen trick for this and for size_calc.
*/
void MainWindow::widget_sizer()
{
  int history_edit_widget_height;
  /*
    This would work, but only if show() is called before widget_sizer().
    But if history_edit_widget becomes something other than plain text,
    we'd have to do something like this ...
    history_edit_widget_height= history_edit_widget->document()->size().height();
    history_edit_widget->setMaximumHeight(history_edit_widget_height);
  */
  QFontMetrics history_font(history_edit_widget->font());
  history_edit_widget_height= (history_edit_widget->document()->lineCount() + 1) * history_font.lineSpacing();
  history_edit_widget_height+= QApplication::style()->pixelMetric(QStyle::PM_ScrollBarExtent);
  history_edit_widget->setMaximumHeight(history_edit_widget_height);
}


/*
  If the response to a MySQL query is an error, put error information
  in statement_edit_widget->result and return error number. Else return 0.
  This should only be called for mysql calls, not for client commands.
  For a Tarantool query, we put together all error messages during tarantool_get_messages().
*/
/*
  Todo: the elapsed-time calculation in the diagnostics is calculated at the wrong time,
  it includes the time to set up the widgets. Move it to just after statement-execution.
*/
void MainWindow::put_diagnostics_in_result(unsigned int connection_number, unsigned int diagnostic_signal)
{
#if (OCELOT_MYSQL_INCLUDE == 1)
  unsigned int mysql_warning_count;
  char mysql_error_and_state[50]; /* actually we should need less than 50 */
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  char elapsed_time_string[50];   /* actually we should need less than 50 */
  QString s1, s2;
  /* Display may include: how long the statement took, to nearest tenth of a second. Todo: fix calculation. */
  {
    qint64 statement_end_time= QDateTime::currentMSecsSinceEpoch();
    qint64 elapsed_time= statement_end_time - statement_edit_widget->start_time;
    long int elapsed_time_as_long_int= (long int) elapsed_time;
    float elapsed_time_as_float= (float) elapsed_time_as_long_int / 1000; /* todo: round */
    sprintf(elapsed_time_string, " (%.1f seconds)", elapsed_time_as_float);
  }
  if (diagnostic_signal != DIAGNOSTIC_0) /* If execute_ocelot_query already pasted a result without the server */
  {
    statement_edit_widget->result.append(elapsed_time_string);
    return;
  }
#ifdef DBMS_TARANTOOL
  if (connections_dbms[connection_number] == DBMS_TARANTOOL)
  {
    s1= tarantool_get_messages(connection_number);
    s1.append(elapsed_time_string);
    statement_edit_widget->result= s1;
    return;
  }
#endif
  if ((connections_dbms[connection_number] != DBMS_MYSQL)
   && (connections_dbms[connection_number] != DBMS_MARIADB))
  {
    statement_edit_widget->result= "Bad connection."; /* shouldn't happen! */
    return;
  }
#if (OCELOT_MYSQL_INCLUDE == 1)
  mysql_errno_result= lmysql->ldbms_mysql_errno(&mysql[connection_number]);
  mysql_warning_count= lmysql->ldbms_mysql_warning_count(&mysql[connection_number]);
  if (mysql_errno_result == 0)
  {
    s1= er_strings[er_off + ER_OK];
    s1.append(" ");

    /* This should output, e.g. "Records: 3 Duplicates: 0 Warnings: 0" -- but actually nothing happens. */
    if (lmysql->ldbms_mysql_info(&mysql[connection_number])!= NULL)
    {
      /* This only works for certain insert, load, alter or update statements */
      s1.append(tr(lmysql->ldbms_mysql_info(&mysql[connection_number])));
    }
    else
    {
      sprintf(mysql_error_and_state, er_strings[er_off + ER_ROWS_AFFECTED], lmysql->ldbms_mysql_affected_rows(&mysql[connection_number]));
      s1.append(mysql_error_and_state);
      if (mysql_warning_count > 0)
      {
        sprintf(mysql_error_and_state, er_strings[er_off + ER_WARNING], mysql_warning_count);
        s1.append(mysql_error_and_state);
        if (mysql_warning_count > 1) s1.append("s");
      }
    }
    s1.append(elapsed_time_string);
    if (mysql_warning_count > 0)
    {
      if (ocelot_ca.history_includes_warnings > 0)
      {
        lmysql->ldbms_mysql_query(&mysql[connection_number], "show warnings");
        MYSQL_RES *mysql_res_for_warnings;
        MYSQL_ROW warnings_row;
        QString s;
        // unsigned long connect_lengths[0];
        mysql_res_for_warnings= lmysql->ldbms_mysql_store_result(&mysql[connection_number]);
        assert(mysql_res_for_warnings != NULL);
        //for (unsigned int wi= 0; wi <= lmysql->ldbms_mysql_warning_count(&mysql[connection_number]); ++wi)
        int count_of_fields= lmysql->ldbms_mysql_num_fields(mysql_res_for_warnings);
#if defined(NDEBUG)
        if (count_of_fields != 3) {printf("assert(count_of_fields == 3);"); exit(1); }
#else
        assert(count_of_fields == 3);
#endif
        for (;;)
        {
          warnings_row= lmysql->ldbms_mysql_fetch_row(mysql_res_for_warnings);
          if (warnings_row == NULL) break;
          unsigned long *lengths= lmysql->ldbms_mysql_fetch_lengths(mysql_res_for_warnings);
          unsigned long required_size= lengths[0] + lengths[1] + lengths[2] + 16;
          char *long_warning= new char[required_size];
          sprintf(long_warning, "\n%s (%s) %s.", warnings_row[0], warnings_row[1], warnings_row[2]);
          s1.append(long_warning);
          delete []long_warning;
        }
        lmysql->ldbms_mysql_free_result(mysql_res_for_warnings);
      }
    }
  }
  if (mysql_errno_result > 0)
  {
    s1= er_strings[er_off + ER_ERROR];
    sprintf(mysql_error_and_state, "%u (%s) ", mysql_errno_result, lmysql->ldbms_mysql_sqlstate(&mysql[connection_number]));
    s1.append(mysql_error_and_state);
    s2= lmysql->ldbms_mysql_error(&mysql[connection_number]);
    s1.append(s2);
  }
  put_message_in_result(s1);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
}


/*
  Called from execute_client_statement() and from debugger.
  Effect is like put_diagnostics_in_result() when the server returns an error,
  but without elapsed time or sqlstate or error number.
  Todo: consider putting in elapsed time.
*/
void MainWindow::put_message_in_result(QString s1)
{
#if (OCELOT_PLUGIN == 1)
  if (plugin_widget_list.size() > 0)
  {
    ocelot_plugin_pass.error_message= s1.toUtf8().data();
    if (plugin_widget_list_caller(PLUGIN_ERROR_MESSAGE, "") ==  PLUGIN_RETURN_OK_AND_REPLACED)
      s1= QString::fromUtf8(ocelot_plugin_pass.replacer_buffer, ocelot_plugin_pass.replacer_buffer_length);
  }
#endif
  statement_edit_widget->result= s1;
}

/*
  Todo: truncate if length would be greater than ER_MAX_LENGTH
*/
void MainWindow::make_and_put_message_in_result(
        unsigned int er_number,
        int er_numeric_parameter,
        char *er_string_parameter)
{
  char buffer[ER_MAX_LENGTH];
  if (strstr(er_strings[er_off + er_number], "%s") != NULL)
    sprintf(buffer, er_strings[er_off + er_number], er_string_parameter);
  else
    sprintf(buffer, er_strings[er_off + er_number], er_numeric_parameter);
  put_message_in_result(buffer);
}

void MainWindow::make_and_put_open_message_in_result(
        unsigned int er_number, /* either ER_FILE_OPEN or ER_OK_PLUS */
        int er_numeric_parameter,
        QString file_name)
{
  char er_string_parameter[1024]; /* todo: should depend on file_name.size() */
  char buffer[ER_MAX_LENGTH];
  strcpy(er_string_parameter, file_name.toUtf8());
  if (strstr(er_strings[er_off + er_number], "%s") != NULL)
    sprintf(buffer, er_strings[er_off + er_number], er_string_parameter);
  else
    sprintf(buffer, er_strings[er_off + er_number], er_numeric_parameter);
  put_message_in_result(buffer);
}

void MainWindow::make_and_append_message_in_result(
        unsigned int er_number,
        int er_numeric_parameter,
        char *er_string_parameter)
{
  char buffer[ER_MAX_LENGTH];
  if (strstr(er_strings[er_off + er_number], "%s") != NULL)
    sprintf(buffer, er_strings[er_off + er_number], er_string_parameter);
  else
    sprintf(buffer, er_strings[er_off + er_number], er_numeric_parameter);
  statement_edit_widget->result.append(buffer);
}


/*
   tokenize(): Produce a list of tokens given an SQL statement using MySQL rules.

   Example: SELECT `a` FROM t; will give:
     token_offsets[0] -> SELECT, token_lengths=0] = 6
     token_offsets[1] -> `a`, token_lengths[1] = 3
     token_offsets[2] -> FROM, token_lengths[2] = 4
     token_offsets[3] -> t, token_lengths[3] = 1
     token_offsets[4] -> ;, token_lengths[4] = 1
     token_offsets[5] -> `'0', token_lengths[5] = 0
   Most character sets are OK because all breaks are ASCII.

  What to pass:
    Token_lengths[] gets the length of the token
    Token_offsets[] gets where the token starts within text
    Max_tokens is the size of token_lengths[] and token_offsets
      This is what I actually depend on but C++ insists I state the size.
    Version is what to compare when you say / * ! nnnnn
      It must be a 5-character string.
      It will be compared with the 5 digits following '!', if any
      If comparison fails, / * ! is treated as / * style comment
    Comment behaviour influences what will happen with comments
      1: save whole comment as one token.
         useful for syntax highlighting.
      2: ignore whole comment.
         useful for debug.
      3: save whole comment as multiple tokens, include markers
         useful for html markup.
      4: save whole comment as multiple tokens, ignore markers
    Special_token is a string, possibly blank, which will be treated as a single n-byte token
    even if it contains special characters. In this program we use it for delimiters.
    Minus behaviour influences what will happen with '-' i.e. 0x2d i.e. hyphen-minus
      1: '-' is an operator, this is the norm when tokenizing SQL
      2: '-' is a token part, this is the norm when tokenizing options

  If ocelot_dbms='tarantool':
    #... is not a comment
    [[...]] is a string
    .. is an operator
    == is an operator
    todo: =[[...]]= and nested strings
    no backslash escapes e.g. \' \" \\ are not escaped single characters inside strings

  Adjusting the tokenizer for Qt:
    With tokenize(QString text, char* comment_handling) we find the tokens of a string in statement.
    The results go to token_offsets[] and token_lengths[].
    According to Qt documentation:
      QString contains QChars. It's really UTF-16 except that a surrogate pair counts as two QChars.
      I won't use Qchar's helpers (isHighSurrogate, isLowSurrogate, isDigit, isLetter, isSpace, isNull)
      because I can't be sure that MySQL/MariaDB parser will always act the same way.
      I'm assuming nobody has played with the exec's codec, whatever that means.
      I'm assuming that the compiler will treat each QChar as unsigned.
      So I know that if something is "QString str" then I can compare characters within it to
      "QChar('u')" or "QChar(0x00e7)" etc. and I can get substrings with str.mid(position,length).
  The original program is tokenize.c which is a standalone that uses unsigned char* not QString.
  Todo: Flaw: In Tarantool/Lua [[...]] is TOKEN_TYPE_LITERAL_WITH_BRACKET but in Tarantool/SQL [ and ]
        will be TOKEN_TYPE_OPERATOR. So if we see [[ we try to determine whether the string is SQL or Lua.
        But we don't skip back to statement start so would be confused by lua-statement; sql-statement.
        And we assume if a word starts / and * it's SQL, but don't check for other kinds of comments.
        Tarantool/Lua still might confused by [[ or ]] in strings or comments but that's not our problem.
*/

void MainWindow::tokenize(QChar *text, int text_length, int *token_lengths,
                           int *token_offsets, int max_tokens, QChar *version,
                           int passed_comment_behaviour, QString special_token,
                           int minus_behaviour)
{
  log("tokenize start", 50);
  int token_number;
  QChar expected_char;
  int char_offset;
  QChar expected_char_at_comment_end;
  int comment_behaviour;
  QChar version_inside_comment[6];
  int n;

  expected_char_at_comment_end=' ';
  comment_behaviour=passed_comment_behaviour;
  token_number= 0;
  char_offset= 0;
next_token:
  token_lengths[token_number]= 0;
  token_offsets[token_number]= char_offset;
next_char:
  if (token_number >= (max_tokens - 1)) goto string_end;
  /* Following IFs happen to be in order by ASCII code */
  if (char_offset >= text_length) goto string_end; /* this is the usual check for end of string */
  if (text[char_offset] == '\x00') goto string_end;  /* \0 end of string (probably will never happen) */
  /* Check whether special_token occurs at this point. */
  {
    int special_token_length, special_token_offset;
    special_token_length= special_token.length();
    if ((special_token_length > 0)
    &&  (char_offset + special_token_length <= text_length))
    {
      for (special_token_offset= 0; special_token_offset < special_token_length; ++special_token_offset)
      {
        QChar special_token_char= special_token.at(special_token_offset);
        if (special_token_char != text[char_offset+special_token_offset]) break;
      }
      if (special_token_offset == special_token_length)
      {
        n= special_token_length;
        goto n_byte_token;
      }
    }
  }
  if (text[char_offset] <= ' ') goto white_space; /* space tab ff etc. = white space */
  if (text[char_offset] == '!')                 /* ! might be start of != otherwise one-byte token */
  {
    expected_char= '=';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
#ifdef DBMS_TARANTOOL
    if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0)
    {
      expected_char= '<';
      if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
      expected_char= '>';
      if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    }
#endif
    goto one_byte_token;
  }
  if (text[char_offset] == '"')    /* " starts a token until next " but watch for ""s and end-of-string and escape */
  {
    expected_char= '"';
    goto skip_till_expected_char;
  }
  if (text[char_offset] == '#')          /* # starts a comment */
  {
    if ((dbms_version_mask&FLAG_VERSION_TARANTOOL) != 0) goto one_byte_token;
    expected_char= '\n';
    goto comment_start;
  }
  if (text[char_offset] == '%') goto one_byte_token; /* % one-byte token */
  if (text[char_offset] == '&')     /* & might be start of &&. otherwise one-byte token */
  {
    expected_char= '&';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    goto one_byte_token;
  }
  if (text[char_offset] == '\x27')     /* ' starts a token until next ' but watch for end-of-string and escape */
  {
    expected_char= '\x27';
    goto skip_till_expected_char;
  }
  if (text[char_offset] == '(') goto one_byte_token; /* ( one-byte token */
  if (text[char_offset] == ')') goto one_byte_token; /* ) one-byte token */
  if (text[char_offset] == '*') /* * one-byte token unless * / and we're inside a comment */
  {
    if ((expected_char_at_comment_end == '/') && (char_offset + 1 < text_length) && (text[char_offset + 1] == '/'))
    {
      expected_char_at_comment_end= ' ';
      if (comment_behaviour == 3)
      {
        expected_char= '/';
        goto skip_till_expected_char;
      }
      if (comment_behaviour == 4)
      {
        n= 2;
        goto n_byte_token_skip;
      }
    }
    else goto one_byte_token;
  }
  if (text[char_offset] == '+') goto one_byte_token; /* + one-byte token */
  if (text[char_offset] == ',') goto one_byte_token; /* , one-byte token */
  if (text[char_offset] == '-') /* MySQL 5.7.9 JSON-colum->path operator */
  {
    expected_char= '>';
    if ((char_offset + 1  < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
  }
  if (minus_behaviour != 2) {
    if ((dbms_version_mask&FLAG_VERSION_TARANTOOL) == 0)
    {
      if (text[char_offset] == '-')     /* - one-byte token, unless -- comment */
      {
        if ((char_offset + 1 < text_length) && (text[char_offset + 1]  == '-'))
        {
          if ((char_offset + 2 < text_length) && (text[char_offset + 2] <= ' '))
          {
            expected_char= '\n';
            goto comment_start;
          }
        }
        goto one_byte_token;
      }
    }
    else
    {
      if (text[char_offset] == '-')     /* - one-byte token, unless -- comment */
      {
        if ((char_offset + 1 < text_length) && (text[char_offset + 1]  == '-'))
        {
          if (((char_offset + 2 < text_length) && (text[char_offset + 2] == '['))
           && ((char_offset + 3 < text_length) && (text[char_offset + 3] == '[')))
          {
            goto string_starting_with_bracket_start;
          }
          else
          {
            expected_char= '\n';
            goto comment_start;
          }
        }
        goto one_byte_token;
      }
    }
  }
  if (text[char_offset] == '.')     /* . part of token if previous or following is digit. otherwise one-byte token */
  {
    if (char_offset + 1 < text_length)
    {
      if ((text[char_offset + 1] >= '0') && (text[char_offset + 1] <= '9')) goto part_of_token;
      /* .. is an operator in MariaDB 10.3 for ... end for */
      if ((text[char_offset + 1] == '.')
       && ((hparse_dbms_mask & FLAG_VERSION_MARIADB_10_3) != 0))
      {
        n= 2;
        goto n_byte_token;
      }
    }
    if (token_lengths[token_number] > 0)
    {
      if ((text[char_offset - 1] >= '0') && (text[char_offset - 1] <= '9'))
      {
        int j;
        for (j= token_offsets[token_number]; j < char_offset; ++j)
        {
          if (text[j] > '9') goto one_byte_token;
        }
        goto part_of_token;
      }
    }
    goto one_byte_token;
  }
  if (text[char_offset] == '/') /* / one-byte token unless it's '/' followed by '*' */
  {
    expected_char= '/';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == '*')) goto comment_starting_with_slash_start;
    goto one_byte_token;
  }
  if ((text[char_offset] >= '0') && (text[char_offset] <= '9')) goto part_of_token; /* digit part of token */
  if (text[char_offset] == ':')    /* : might be start of := otherwise one-byte token */
  {
    if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0) expected_char= ':';
    else expected_char= '=';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    goto one_byte_token;
  }
  if (text[char_offset] == ';') goto one_byte_token; /* ; one-byte token */
  if (text[char_offset] == '<')       /* < might be start of <=  or << or <=> or <>. otherwise one-byte token */
  {
    expected_char= '=';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char))
    {
      if ((char_offset + 2 < text_length) && (text[char_offset + 2] == '>'))
      {
        expected_char= '>';
        goto skip_till_expected_char;
      }
      goto skip_till_expected_char;
    }
    expected_char= '>';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    expected_char= '<';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    goto one_byte_token;
  }
  if (text[char_offset] == '=')
  {
#ifdef DBMS_TARANTOOL
    if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0)
    {
      expected_char= '=';
      if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    }
#endif
    goto one_byte_token;          /* = one-byte token */
  }
  if (text[char_offset] == '>')   /* > might be start of >= or >>. otherwise one-byte token */
  {
    expected_char= '=';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    expected_char= '>';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    goto one_byte_token;
  }
  if (text[char_offset] == '?') goto one_byte_token; /* ? one-byte token? */
  if (text[char_offset] == '@') /* @ start of @token or start of @@token otherwise one-byte token */
  {
    if (token_lengths[token_number] == 0) goto part_of_token;
    if (token_lengths[token_number] == 1)
    {
      if (text[char_offset - 1] == '@') goto part_of_token;
    }
    goto one_byte_token;
  }
  if (text[char_offset] == '[')
  {
    if ((dbms_version_mask&FLAG_VERSION_TARANTOOL) != 0)
    {
      expected_char= '[';
      if ((char_offset + 1 < text_length) && (text[char_offset + 1] == '['))
      {
        QString tmp_s= QString(text, char_offset); /* I wonder: could I say text-> and skip this assignment? */
        QString word0, word1, word2;
        if (token_number > 0) word0= tmp_s.mid(token_offsets[0],token_lengths[0]); else word0= "";
        if (token_number > 1) word1= tmp_s.mid(token_offsets[1],token_lengths[1]); else word1= "";
        if (token_number > 2) word2= tmp_s.mid(token_offsets[2],token_lengths[2]); else word2= "";
        int tmp_statement_type;
        if ((word0.mid(0,2) == "/*") || (word1.mid(0,2) == "/*") || (word2.mid(0,2) == "/*"))
          tmp_statement_type= TOKEN_KEYWORD_SQL;
        else tmp_statement_type= get_statement_type_low(word0, word1, word2);
        if (tmp_statement_type == TOKEN_KEYWORD_DO_LUA) goto string_starting_with_bracket_start;
      }
    }
    goto one_byte_token; /* [ one-byte token which is never used except maybe in Tarantool arrays */
  }
  if (text[char_offset] == '\x5c')  goto one_byte_token; /* \ one-byte token which is never used */
  if (text[char_offset] == ']') goto one_byte_token; /* ] one-byte token which is never used */
  if (text[char_offset] == '^') goto one_byte_token; /* ^ one-byte token */
  if (text[char_offset] == '`')        /* ` starts a token until next ` but watch for end-of-string and escape */
  {
    expected_char= '`';
    goto skip_till_expected_char;
  }
  /* Changed handling of {...} on February 1 2016 */
  if (text[char_offset] == '{') goto one_byte_token;
  if (text[char_offset] == '}') goto one_byte_token;
  //if (text[char_offset] == '{')      /* { starts a token until next } but watch for end-of-string */
  //{
  //  expected_char= '}';
  //  goto skip_till_expected_char;
  //}
  if (text[char_offset] == '|')      /* | might be start of ||. otherwise one-byte token */
  {
    expected_char= '|';
    if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    goto one_byte_token;
  }
  if (text[char_offset] == '}') goto one_byte_token; /* } one-byte token which is never used */
  if (text[char_offset] == '~') /* ~ one-byte token unless Tarantool+Lua */
  {
#ifdef DBMS_TARANTOOL
    if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0)
    {
      expected_char= '=';
      if ((char_offset + 1 < text_length) && (text[char_offset + 1] == expected_char)) goto skip_till_expected_char;
    }
#endif
   goto one_byte_token;
  }
  /* Remaining possibilities are:
     $, 0 to 9, A to Z, a to z
     >127 (top-bit-on is probably a continuation byte of a utf-8 character)
     _ DEL */
part_of_token:
  ++char_offset;
  ++token_lengths[token_number];
  goto next_char;
string_end:
  if (token_lengths[token_number] > 0) token_lengths[token_number + 1]= 0;
  log("tokenize end", 50);
  return;
white_space:
  if (token_lengths[token_number] > 0) ++token_number;
  ++char_offset;
  goto next_token;
string_starting_with_bracket_start:
  if (token_lengths[token_number] > 0)
  {
    ++token_number;
    token_lengths[token_number]= 0;
    token_offsets[token_number]= char_offset;
  }
  for (;;)
  {
    if (char_offset >= text_length) goto string_end;
    if (text[char_offset] == '\x00') goto string_end;
    if ((char_offset + 1 < text_length)
     && (text[char_offset] == ']')
     && (text[char_offset + 1] == ']'))
     {
       char_offset+= 2;
       token_lengths[token_number]+= 2;
       break;
     }
    ++char_offset;
    ++token_lengths[token_number];
  }
  ++token_number;
  goto next_token;
comment_starting_with_slash_start:
comment_start:
  comment_behaviour= passed_comment_behaviour;

  if (text[char_offset] == '/')
  {
    if ((char_offset + 2 < text_length) && (text[char_offset + 2] == '!'))
    {
      if ((char_offset + 8 < text_length) && (text[char_offset + 3] >= '0') && (text[char_offset + 3] <= '9'))
      {
        version_inside_comment[0]= text[char_offset + 3];
        version_inside_comment[1]= text[char_offset + 4];
        version_inside_comment[2]= text[char_offset + 5];
        version_inside_comment[3]= text[char_offset + 6];
        version_inside_comment[4]= text[char_offset + 7];
        version_inside_comment[5]= '\x00';
      }
      else
      {
        version_inside_comment[0]= '\x00';
      }
      if (strcmp((char*)version, (char*)version_inside_comment) >= 0)
      {
        if (comment_behaviour == 1) comment_behaviour= 3;
        if (comment_behaviour == 2) comment_behaviour= 4;
        expected_char= ' ';
        expected_char_at_comment_end= '/';
        if (comment_behaviour == 4)
        {
          char_offset+= 3 + strlen((char*)version_inside_comment);
          goto next_token;
        }
        goto skip_till_expected_char;
      }
    }
  }

  if (comment_behaviour == 3)
  {
    expected_char_at_comment_end= expected_char; /* / or \n */
    if (text[char_offset] == '#') goto one_byte_token;
    if (text[char_offset] == '-') expected_char='-';
    if (text[char_offset] == '/') expected_char='*';
  }
  if (comment_behaviour == 4)
  {
    /* comment_behaviour=4 means ignore / * and * / but not comment contents */
    expected_char_at_comment_end= expected_char; /* / or \n */
    if (text[char_offset] == '#') n= 1;
    else n= 2;
    goto n_byte_token_skip;
  }
skip_till_expected_char:
  /* No break if we're facing N'...' or X'...' or B'...' or @`...` or @a"..." */
  /* Todo: check: I might have forgotten N"..." etc. */
  if (token_lengths[token_number] == 1)
  {
    if (expected_char == '\x27')
    {
      if ((text[char_offset - 1] == 'N') || (text[char_offset - 1] == 'X') || (text[char_offset - 1] == 'B')
              ||(text[char_offset - 1] == 'n') || (text[char_offset - 1] == 'x') || (text[char_offset- 1] == 'b'))
      {
        goto skip_till_expected_char_2;
      }
    }
    if ((expected_char == '`') || (expected_char == '"'))
    {
      if (text[char_offset - 1] == '@')
      {
        goto skip_till_expected_char_2;
      }
    }
  }
  if (token_lengths[token_number] > 0)
  {
    ++token_number;
    token_lengths[token_number]= 0;
    token_offsets[token_number]= char_offset;
  }
skip_till_expected_char_2:
  ++char_offset;
  ++token_lengths[token_number];
  if (char_offset >= text_length) goto string_end;
  if (text[char_offset] == '\x00') goto string_end;
  if (text[char_offset] != expected_char) goto skip_till_expected_char_2;
  /* No match if / not preceded by *, \' or '' inside ''s, \" or "" inside ""s or `` inside ``s */
  if ((expected_char == '/') && (text[char_offset - 1] != '*')) goto skip_till_expected_char_2;

  /* Adjustment on 2021-08-19 because SELECT '\\'; wasn't being tokenized correctly, apparently. */
  //if ((expected_char == '\x27') && (text[char_offset - 1] == '\x5c')) goto skip_till_expected_char_2;
  //if ((expected_char == '"') && (text[char_offset - 1] == '\x5c')) goto skip_till_expected_char_2;
#if (OCELOT_MYSQL_INCLUDE == 1)
  if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) == 0)
  {
    if ((expected_char == '\x27') || (expected_char == '"'))
    {
      if (text[char_offset - 1] == '\x5c')
      {
        if ((char_offset <= 2) || (text[char_offset - 2] != '\x5c')) goto skip_till_expected_char_2;
      }
    }
  }
#endif
  if ((expected_char == '\x27') || (expected_char == '"') || (expected_char == '`'))
  {
    if ((char_offset + 1 < text_length) && (expected_char == text[char_offset + 1]))
    {
      ++char_offset;
      ++token_lengths[token_number];
      goto skip_till_expected_char_2;
    }
  }
  ++char_offset;
  ++token_lengths[token_number];
  if ((expected_char == '/') || (expected_char == '\n'))
  {
    if (comment_behaviour == 2)
    {
      /*
        comment_behaviour=2 means "ignore comments (treat them as whitespace)",
        so ignore, i.e. go for next token without incrementing token_number.
      */
      goto next_token;
    }
    if (comment_behaviour == 4)
    {
      if (expected_char == expected_char_at_comment_end)
      {
        /*
          comment_behaviour=4 means "don't ignore comments but treat begin/end
          marks as whitespace" so declare there's no more end-marks, then ignore.
        */
        expected_char_at_comment_end= ' ';
        goto next_token;
      }
    }
  }
  ++token_number;
  goto next_token;
one_byte_token: /* we know that coming token length is 1 */
  if (token_lengths[token_number] > 0) ++token_number;
  token_offsets[token_number]= char_offset;
  token_lengths[token_number]= 1;
  ++char_offset;
  ++token_number;
  goto next_token;
n_byte_token:   /* we know that coming token length is n */
  if (token_lengths[token_number] > 0) ++token_number;
  token_offsets[token_number]= char_offset;
  token_lengths[token_number]= n;
  char_offset+= n;
  ++token_number;
  goto next_token;
n_byte_token_skip:
  if (token_lengths[token_number] > 0) ++token_number;
  char_offset+= n;
  goto next_token;
}


/*
  token_type() should be useful for syntax highlighting and for hovering.
  However, it's rudimentary. If parsing routines are called, they'll override.
  Pass: token, token length. we assume it's at least 1.
  Return: type
  I could have figured this out during tokenize(), but didn't.
  See also tokens_to_keywords().
*/
int MainWindow::token_type(QChar *token, int token_length, bool ansi_quotes)
{
  if (token_length == 0) return TOKEN_TYPE_OTHER;
  /* Check whether token == delimiter_str. similar to a comparison with special_token in tokenize(). */
  {
    int special_token_length, special_token_offset;
    special_token_length= ocelot_delimiter_str.length();
    if ((special_token_length > 0)
    &&  (special_token_length == token_length))
    {
      for (special_token_offset= 0; special_token_offset < special_token_length; ++special_token_offset)
      {
        QChar special_token_char= ocelot_delimiter_str.at(special_token_offset);
        if (special_token_char != *(token+special_token_offset)) break;
      }
      if (special_token_offset == special_token_length)
      {
        return TOKEN_TYPE_OPERATOR;
      }
    }
  }

  if (*token == '\x27') return TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE;

  if (token_length > 1)
  {
    if ((*token == 'N') || (*token == 'X') || (*token == 'B')
     || (*token == 'n') || (*token == 'x') || (*token == 'b'))
    {
     if (*(token + 1) == '\x27') return TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE;
    }
    if ((*token == '[') && (*(token + 1) == '['))
    {
      return TOKEN_TYPE_LITERAL_WITH_BRACKET;
    }
  }
  if (*token == '"')
  {
    if (ansi_quotes) return TOKEN_TYPE_IDENTIFIER_WITH_DOUBLE_QUOTE;
    return TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE;
  }
  if ((*token >= '0') && (*token <= '9')) return TOKEN_TYPE_LITERAL_WITH_DIGIT;
  if ((token_length > 1) && (*token == '.'))
  {
    if ((*(token + 1)>= '0') && (*(token + 1) <= '9')) return TOKEN_TYPE_LITERAL_WITH_DIGIT;
  }
  //if (*token == '{') return TOKEN_TYPE_LITERAL_WITH_BRACE;
  if ((*token == '{') || (*token == '}')) return TOKEN_TYPE_OPERATOR;
  if ((*token == '[') || (*token == ']'))
  {
    if (dbms_version_mask&FLAG_VERSION_TARANTOOL) return TOKEN_TYPE_OPERATOR;
  }
  if (*token == '`') return TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK;
  if (*token == '@') return TOKEN_TYPE_IDENTIFIER_WITH_AT;
  if (token_length > 1)
  {
    if ((*token == '/') && (*(token + 1) == '*')) return TOKEN_TYPE_COMMENT_WITH_SLASH;
    if ((*token == '*') && (*(token + 1) == '/')) return TOKEN_TYPE_COMMENT_WITH_SLASH;
  }
  if (*token == '#')
  {
    if (dbms_version_mask&FLAG_VERSION_TARANTOOL) return TOKEN_TYPE_OPERATOR;
    return TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE;
  }
  if (token_length > 1)
  {
    if ((*token == '-') && (*(token + 1) == '-')) return TOKEN_TYPE_COMMENT_WITH_MINUS;
  }
  if ((*token > ' ') && (*token < 'A') && (*token != '$')) return TOKEN_TYPE_OPERATOR;
  return TOKEN_TYPE_OTHER;
}

/*
  We depend on some defined | constant values being correct, the right size, in order, etc.
  So at the start we call these checks. So far most of them are related to strvalues.
  Things will only go wrong if the code or the platform changes.
  The time-consuming check is commented out, re-enable it if you changed something significant.
  Todo: rather than asserts, do runtime tests iff debug mode.
*/
void MainWindow::initial_asserts()
{
  /* Maximum QString length = sizeof(int)/4. Maximum LONGBLOB length = 2**32. So 32 bit int is ok. */
  assert(sizeof(int) >= 4);

  #ifdef OCELOT_OS_LINUX
  #if defined(NDEBUG)
    if (MENU_FONT != 99) {printf("assert(MENU_FONT != 99);"); exit(1); }
  #else
    assert(MENU_FONT == 99); /* See kludge alert in ocelotgui.h Settings() */
  #endif
  #else
    assert(MENU_FONT != 0);  /* i.e. "if Windows, we don't care." */
  #endif

  assert(TOKEN_REFTYPE_MAX == 91); /* See comment after ocelotgui.h TOKEN_REFTYPE_MAX */

  //printf("TOKEN_KEYWORD__UTf8MB4 == %d\n", TOKEN_KEYWORD__UTF8MB4);

  //printf("TOKEN_KEYWORD_OCELOT_XML - TOKEN_KEYWORD_OCELOT_BATCH=%d\n", TOKEN_KEYWORD_OCELOT_XML - TOKEN_KEYWORD_OCELOT_BATCH);

  /* If the following assert happens, you inserted/removed something in strvalues[] */
  /* without changing KEYWORD_LIST_SIZE in tokens_to_keywords(). */
  /* That is okay but you must change all occurrences of KEYWORD_LIST_SIZE to the new size */
  /* and you should also temporarily uncomment the "test strvalues" test below. */
  assert(TOKEN_KEYWORD__UTF8MB4 == KEYWORD_LIST_SIZE - 1);

  /* If the following assert happens, you inserted/removed an OCELOT_... item in strvalues. */
  /* That is okay but you must change this occurrence of "152" to the new size */
  /* and you should also look whether SET statements cause an overflow */
  /* See hparse.h comment "If you add to this, hparse_errmsg might not be big enough." */
  /* Temporarily uncomment the check later whether ocelot_keyword_lengths > MAX_HPARSE_ERRMSG_LENGTH */
  assert(TOKEN_KEYWORD_OCELOT_XML - TOKEN_KEYWORD_OCELOT_BATCH == 152);

  /* If the following assert happens, you put something before "?" in strvalues[]. */
  /* That is okay but you must ensure that the first non-placeholder is strvalues[TOKEN_KEYWORDS_START]. */
  assert(TOKEN_KEYWORD_QUESTIONMARK == TOKEN_KEYWORDS_START);

#ifdef ADDITIONAL_ASSERTS
  //* Test strvalues is ordered by bsearching for every item. */
  // This is commented out i.e. we don't define ADDITIONAL_ASSERTS unless there has been a change to the list */
  char *p_item;
  unsigned long index;
  char l[MAX_KEYWORD_LENGTH+1]= "";
  for (int ii= TOKEN_KEYWORD_QUESTIONMARK; ii < KEYWORD_LIST_SIZE; ++ii)
   {
     char *k= (char*) &strvalues[ii].chars;
     if (strcmp(k, l) <= 0) {printf("k <= l!\n"); exit(0); }
     printf("ii=%d\n", ii);
     printf("k=%s.\n", k);
     p_item= (char*) bsearch(k, strvalues, KEYWORD_LIST_SIZE, sizeof(struct keywords), (int(*)(const void*, const void*)) strcmp);
     assert(p_item != NULL);
     index= ((((unsigned long)p_item - (unsigned long)strvalues)) / sizeof(struct keywords));
     printf("ii=%d, index=%ld, k=%s. l=%s.\n", ii, index, k, l);
     if (index != strvalues[ii].token_keyword) exit(0);
     assert(index == strvalues[ii].token_keyword);
     strcpy(l, k);
   }
  assert(strcmp(strvalues[TOKEN_KEYWORD_QUESTIONMARK].chars, "?") == 0);
  assert(strcmp(strvalues[TOKEN_KEYWORD__UTF8MB4].chars, "_UTF8MB4") == 0);
  {
    int ocelot_keyword_lengths= 200; /* approximately what hparse_f_errormsg() adds */
    for (int ii= TOKEN_KEYWORD_OCELOT_BATCH; ii <= TOKEN_KEYWORD_OCELOT_XML; ++ii)
    {
      char *k= (char*) &strvalues[ii].chars;
      printf("k=%s.\n", k);
      ocelot_keyword_lengths+= strlen(k) + 3;
    }
    if (ocelot_keyword_lengths > MAX_HPARSE_ERRMSG_LENGTH)
    {
      printf("ocelot_keyword_lengths=%d\n", ocelot_keyword_lengths);
      printf("MAX_HPARSE_ERRMSG_LENGTH=%d\n", MAX_HPARSE_ERRMSG_LENGTH);
      exit(0);
    }
  }
#endif //ADDITIONAL_ASSERTS
}

void MainWindow::tokens_to_keywords(QString text, int start, bool ansi_quotes)
{
  log("tokens_to_keywords start", 80);

  //QString text;
  QString s= "";
  int t;
  int index;
  char key2[MAX_KEYWORD_LENGTH + 1];
  int i2;

  //text= statement_edit_widget->toPlainText();
  for (i2= start; main_token_lengths[i2] != 0; ++i2)
  {
    /* Get the next word. */
    s= text.mid(main_token_offsets[i2], main_token_lengths[i2]);
    t= token_type(s.data(), main_token_lengths[i2], ansi_quotes);
    main_token_types[i2]= t;
    main_token_flags[i2]= 0;
    main_token_pointers[i2]= 0;
    main_token_reftypes[i2]= 0;
    if ((t == TOKEN_TYPE_OTHER) && (main_token_lengths[i2] < MAX_KEYWORD_LENGTH))
    {
      /* It's not a literal or operator. Maybe it's a keyword. Convert it to char[]. */
      QByteArray key_as_byte_array= s.toLocal8Bit();
      const char *key= key_as_byte_array.data();
      index= get_keyword_index(key, key2);

      if (index != -1)
      {
        /* It's in the list, so instead of TOKEN_TYPE_OTHER, make it TOKEN_KEYWORD_something. */
        if ((strvalues[index].reserved_flags & dbms_version_mask) != 0)
          main_token_flags[i2]= (main_token_flags[i2] | TOKEN_FLAG_IS_RESERVED);
        if ((strvalues[index].built_in_function_flags & dbms_version_mask) != 0)
        {
          main_token_flags[i2]= (main_token_flags[i2] | TOKEN_FLAG_IS_FUNCTION);
        }
        if ((strvalues[index].reserved_flags & FLAG_VERSION_LUA) != 0)
          main_token_flags[i2]= (main_token_flags[i2] | TOKEN_FLAG_IS_MAYBE_LUA);
        //index+= TOKEN_KEYWORDS_START; commented out on 2019-02-27
        main_token_types[i2]= index;
      }
#if (OCELOT_MYSQL_DEBUGGER == 1)
      else
      {
        /* It's not in the list, but if it's unambiguously $DEB[UG] etc. then consider it a debug keyword. */
        if ((key2[0] == '$') && (key2[1] != '\0'))
        {
          if (strncmp(key2, "$BREAKPOINT", strlen(key2)) == 0) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_BREAKPOINT;
          if ((strlen(key2) > 2) && (strncmp(key2, "$CLEAR", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_CLEAR;
          if ((strlen(key2) > 2) && (strncmp(key2, "$CONTINUE", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_CONTINUE;
          if ((strlen(key2) > 3) && (strncmp(key2, "$DEBUG", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_DEBUG;
          if ((strlen(key2) > 3) && (strncmp(key2, "$DELETE", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_DELETE;
          if ((strlen(key2) > 3) && (strncmp(key2, "$EXECUTE", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_EXECUTE;
          if ((strlen(key2) > 3) && (strncmp(key2, "$EXIT", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_EXIT;
          if ((strlen(key2) > 3) && (strncmp(key2, "$INFORMATION", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_INFORMATION;
          if ((strlen(key2) > 3) && (strncmp(key2, "$INSTALL", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_INSTALL;
          if (strncmp(key2, "$LEAVE", strlen(key2)) == 0) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_LEAVE;
          if (strncmp(key2, "$NEXT", strlen(key2)) == 0) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_NEXT;
          if (strncmp(key2, "$REFRESH", strlen(key2)) == 0) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_REFRESH;
          if (strcmp(key2, "$SET") == 0) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_SET;
          if ((strlen(key2) > 4) && (strncmp(key2, "$SETUP", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_SETUP;
          if ((strlen(key2) > 2) && (strncmp(key2, "$SKIP", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_SKIP;
          if ((strlen(key2) > 2) && (strncmp(key2, "$SOURCE", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_SOURCE;
          if ((strlen(key2) > 2) && (strncmp(key2, "$STEP", strlen(key2)) == 0)) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_STEP;
          if (strncmp(key2, "$TBREAKPOINT", strlen(key2)) == 0) main_token_types[i2]= TOKEN_KEYWORD_DEBUG_TBREAKPOINT;
        }
      }
#endif
    }
  }

  /* Global. Sometimes we'll want to know how many tokens there are. */
  main_token_count_in_all= i2;

  main_token_types[i2]= 0; /* since main_token_lengths[i2] == 0, types and flags etc. are too. */
  main_token_flags[i2]= 0;
  main_token_pointers[i2]= 0;
  main_token_reftypes[i2]= 0;

  /* The special cases of BEGIN, DO, END, FUNCTION, ROW. */
  int i_of_function= -1;
  int i_of_do= -1;
  int start_of_body= find_start_of_body(text, start, &i_of_function, &i_of_do);

  tokens_to_keywords_revert(start_of_body, i_of_function, i_of_do, text, start);

  /*
    The special case of "?". Although tokenize() says ? is an operator,
    we might have to treat it as a keyword meaning "help".
  */
  if (main_token_lengths[start] == 1)
  {
    s= text.mid(main_token_offsets[start], 1);
    if (s == QString("?")) main_token_types[start]= TOKEN_KEYWORD_QUESTIONMARK;
  }

  /*
    The special cases of "\q" etc.:
    If token[0] is "\" and token[q] == "q" (lower case only), that's equivalent to "quit".
    They're still separate tokens -- changing tokenize() to say "\=" is not a keyword is not
    appropriate because "\" really should be an operator. But treat both tokens as the
    same keyword, TOKEN_KEYWORD_QUIT.
    This is for mysql compatibility.
    I couldn't find a consistent rule, but it seems that the statement pair could be at the
    start, could be at the end, or could be at the end before a delimiter.
    The list is in order by TOKEN_KEYWORD_... value.
  */
  /* Todo: There is interference with the statement "prompt \u" and maybe other special prompts */
  /* Todo: This is completely wrecked if start!=0 because of delimiter */
  int xx= -1;
  if (i2 >= 2)
  {
    /* Todo: what about the delimiter? */
    if ((main_token_offsets[1] == 1)
     && (main_token_lengths[1] == 1)
     && (text.mid(main_token_offsets[0], main_token_lengths[0]) == "\\"))
    {
      xx= 0;
    }
    else if ((main_token_lengths[main_token_count_in_all - 2] == 1)
     && (main_token_lengths[main_token_count_in_all - 1] == 1)
     && (text.mid(main_token_offsets[main_token_count_in_all - 2], main_token_lengths[main_token_count_in_all - 2]) == "\\"))
    {
      xx= main_token_count_in_all - 2;
    }
  }
  if (i2 >= 3)
  {
    s= text.mid(main_token_offsets[i2 - 1], main_token_lengths[i2 - 1]);
    /* Todo: compare with delimiter, which isn't always semicolon. */
    if (s == (QString)ocelot_delimiter_str)
    {
      if ((main_token_lengths[main_token_count_in_all - 3] == 1)
       && (main_token_lengths[main_token_count_in_all - 2] == 1)
       && (text.mid(main_token_offsets[main_token_count_in_all - 3], main_token_lengths[main_token_count_in_all - 3]) == "\\"))

      {
        xx= main_token_count_in_all - 3;
      }
    }
  }
  if (xx >= 0)
  {
    s= text.mid(main_token_offsets[xx], 2);
    if (s == QString("\\?")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_QUESTIONMARK;
    if (s == QString("\\C")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_CHARSET;
    if (s == QString("\\c")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_CLEAR;
    if (s == QString("\\r")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_CONNECT;
    if (s == QString("\\d")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_DELIMITER;
    if (s == QString("\\e")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_EDIT;
    if (s == QString("\\G")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_EGO;
    if (s == QString("\\g")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_GO;
    if (s == QString("\\h")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_HELP_IN_CLIENT;
    if (s == QString("\\n")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_NOPAGER;
    if (s == QString("\\t")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_NOTEE;
    if (s == QString("\\w")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_NOWARNING;
    if (s == QString("\\P")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_PAGER;
    if (s == QString("\\p")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_PRINT;
    if (s == QString("\\R")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_PROMPT;
    if (s == QString("\\q")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_QUIT;
    if (s == QString("\\#")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_REHASH;
    if (s == QString("\\.")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_SOURCE;
    if (s == QString("\\s")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_STATUS;
    if (s == QString("\\!")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_SYSTEM;
    if (s == QString("\\T")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_TEE;
    if (s == QString("\\u")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_USE;
    if (s == QString("\\W")) main_token_types[xx]= main_token_types[xx + 1]= TOKEN_KEYWORD_WARNINGS;
  }
  log("tokens_to_keywords end", 80);
}

/*
  Pass a word. Return a pointer to the keywords list, or 0 if word is not in keywords list.
  And change key2, which must be big enough to store the biggest word, to upper(key).
  Todo: the calculation in the return might not be portable, maybe use strvalues[x].token_keyword
*/
int MainWindow::get_keyword_index(const char *key, char *key2)
{
  int i;
  char *p_item;
  /* Uppercase it. I don't necessarily have strupr() or strcmpi(). */
  for (i= 0; (*(key + i) != '\0') && (i < MAX_KEYWORD_LENGTH); ++i) key2[i]= toupper(*(key + i));
  key2[i]= '\0';
  /* Search it with library binary-search. Assume KEYWORD_LIST_SIZE items and everything MAX_KEYWORD_LENGTH bytes long. */
  p_item=  (char*) bsearch(key2, strvalues, KEYWORD_LIST_SIZE, sizeof(struct keywords), (int(*)(const void*, const void*)) strcmp);
  if (p_item == NULL) return -1;
  return (int)((((unsigned long)p_item - (unsigned long)strvalues)) / sizeof(struct keywords));
}

/*
  Todo: There are a few places where we do something like this,
        change them to calls to get_keyword_index_from_qstring().
*/
int MainWindow::get_keyword_index_from_qstring(QString key)
{
  char key1[MAX_KEYWORD_LENGTH + 1];
  char key2[MAX_KEYWORD_LENGTH + 1];
  strcpy(key1, key.toUtf8());
  return get_keyword_index(key1, key2);
}

/*
  Return true if the passed token number is for the first word of a client statement.
*/
bool MainWindow::is_client_statement(int token, int i,QString text)
{
  if ((token == TOKEN_KEYWORD_QUESTIONMARK)
  ||  (token == TOKEN_KEYWORD_CHARSET)
  ||  (token == TOKEN_KEYWORD_CLEAR)
  ||  (token == TOKEN_KEYWORD_CONNECT)
  ||  (token == TOKEN_KEYWORD_DELIMITER)
  ||  (token == TOKEN_KEYWORD_EDIT)
  ||  (token == TOKEN_KEYWORD_EGO)
  ||  (token == TOKEN_KEYWORD_EXIT)
  ||  (token == TOKEN_KEYWORD_GO)
  ||  (token == TOKEN_KEYWORD_HELP_IN_CLIENT)
  ||  (token == TOKEN_KEYWORD_NOPAGER)
  ||  (token == TOKEN_KEYWORD_NOTEE)
  ||  (token == TOKEN_KEYWORD_NOWARNING)
  ||  (token == TOKEN_KEYWORD_PAGER)
  ||  (token == TOKEN_KEYWORD_PRINT)
  ||  (token == TOKEN_KEYWORD_PROMPT)
  ||  (token == TOKEN_KEYWORD_QUIT)
#if (OCELOT_EXPLORER == 1)
  ||  (token == TOKEN_KEYWORD_REFRESH)
#endif
  ||  (token == TOKEN_KEYWORD_REHASH)
  ||  (token == TOKEN_KEYWORD_SOURCE)
  ||  (token == TOKEN_KEYWORD_STATUS)
  ||  (token == TOKEN_KEYWORD_SYSTEM)
  ||  (token == TOKEN_KEYWORD_TEE)
  ||  (token == TOKEN_KEYWORD_USE)
  ||  (token == TOKEN_KEYWORD_WARNINGS))
    return true;
  if (token == TOKEN_KEYWORD_SET)
  {
    if (main_token_lengths[i + 1] > 7)
    {
      QString s= text.mid(main_token_offsets[i + 1], 7);
      if (QString::compare(s, "OCELOT_", Qt::CaseInsensitive) == 0)
      {
        return true;
      }
    }
  }
#if (OCELOT_MYSQL_DEBUGGER == 1)
  if ((token >= TOKEN_KEYWORD_DEBUG_BREAKPOINT)
   && (token <= TOKEN_KEYWORD_DEBUG_TBREAKPOINT))
    return true;
#endif
  return false;
}

/*
  Find start of body in CREATE ... FUNCTION|PROCEDURE|TRIGGER statement
  This is tricky and might need revisiting if syntax changes in later MySQL versions.
  First find out whether the statement is CREATE ... FUNCTION|PROCEDURE|TRIGGER|EVENT.
  A definer clause might have to be skipped.
  If it's CREATE TRIGGER: skip till past FOR EACH ROW.
                          but watch for new PRECEDES|FOLLOWS clauses
  If it's CREATE EVENT: skip till past ON and past DO.
  If it's CREATE PROCEDURE|FUNCTION:
    skip past ()s
   (Function) Skip returns clause i.e. skip until anything is seen which is not one of the following:
      anything within ()s
      ASCII BIGINT BINARY BIT BLOB BOOL BOOLEAN CHAR CHARACTER CHARSET COLLATE DATE DATETIME DEC
      DECIMAL DOUBLE ENUM FLOAT
      GEOMETRY GEOMETRYCOLLECTION INT INTEGER LINESTRING LONGBLOB LONGTEXT MEDIUMBLOB MEDIUMINT MEDIUMTEXT
      MULTILINESTRING MULTIPOINT MULTIPOLYGON NUMERIC POINT POLYGON PRECISION RETURNS
      SERIAL SET(...) SMALLINT TIME TIMESTAMP TINYBLOB TINYINT TINYTEXT UNICODE UNSIGNED VARCHAR VARYING YEAR ZEROFILL
      name if previous is CHARSET | CHARACTER SET | COLLATE
   (Function or Procedure) Skip words that are in characteristics i.e.
     COMMENT 'string', LANGUAGE SQL, DETERMINISTIC, NOT DETERMINISTIC,
     CONTAINS SQL, NO SQL, READS SQL DATA, MODIFIES SQL DATA,
     SQL SECURITY DEFINER, SQL SECURITY INVOKER
   (Function or Procedure) Watch for Oracle-style {IS|AS} body
   Skipping comments too
   Return: offset for first word of body, or -1 if not-create-routine | body-not-found
   todo: there might be a problem with "create procedure|function function ...".
   No worries: even if this doesn't get everything right, parsing will come later.
*/
int MainWindow::find_start_of_body(QString text, int start, int *i_of_function, int *i_of_do)
{
  int i;
  int create_seen= 0;
  int procedure_seen= 0;
  int function_seen= 0;
  int trigger_seen= 0;
  int trigger_for_seen= 0;
  int trigger_row_seen= 0;
  int trigger_precedes_seen= 0;
  int trigger_name_seen= 0;
  int parameter_list_seen= 0;
  int parentheses_count= 0;
  int characteristic_seen= 0;
  int data_type_seen= 0;
  int character_set_seen= 0;
  int collate_seen= 0;
  int event_seen= 0;
  int event_do_seen= 0;
  int event_on_seen= 0;

  for (i= start; main_token_lengths[i] != 0; ++i)
  {
    if ((main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
     || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_SLASH)
     || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_MINUS))
    {
      continue;
    }
    if (trigger_precedes_seen == 1)
    {
      if (main_token_types[i] == TOKEN_TYPE_OPERATOR)
      {
        trigger_name_seen= 0;
        continue;
      }
      if (trigger_name_seen == 1)
      {
        return i;
      }
      trigger_name_seen= 1;
      continue;
    }
    if (trigger_row_seen == 1)
    {
      if ((main_token_types[i] == TOKEN_KEYWORD_PRECEDES)
       || (main_token_types[i] == TOKEN_KEYWORD_FOLLOWS))
      {
        trigger_precedes_seen= 1;
        continue;
      }
      return i;
    }
    if (event_do_seen == 1)
    {
      return i;
    }
    if (main_token_types[i] == TOKEN_KEYWORD_CREATE)
    {
      create_seen= 1;
      continue;
    }
    if (create_seen != 1)
    {
      return -1;
    }
    if (main_token_types[i] == TOKEN_KEYWORD_PROCEDURE)
    {
      procedure_seen= 1;
      continue;
    }
    if (main_token_types[i] == TOKEN_KEYWORD_FUNCTION)
    {
      function_seen= 1;
      *i_of_function= i;
      continue;
    }
    if (main_token_types[i] == TOKEN_KEYWORD_TRIGGER)
    {
      trigger_seen= 1;
      continue;
    }
    if (main_token_types[i] == TOKEN_KEYWORD_EVENT)
    {
      event_seen= 1;
      continue;
    }
    if (trigger_seen == 1)
    {
      if (main_token_types[i] == TOKEN_KEYWORD_FOR) trigger_for_seen= 1;
      if (trigger_for_seen == 1)
      {
        if (main_token_types[i] == TOKEN_KEYWORD_ROW) trigger_row_seen= 1;
      }
    }
    if (event_seen == 1)
    {
      if (main_token_types[i] == TOKEN_KEYWORD_ON)
      {
        event_on_seen= 1;
      }
      if (event_on_seen == 1)
      {
        if (main_token_types[i] == TOKEN_KEYWORD_DO)
        {
          *i_of_do= i;
          event_do_seen= 1;
        }
      }
    }
    if ((function_seen == 1) || (procedure_seen == 1))
    {
      if ((parameter_list_seen == 0) && (main_token_types[i] == TOKEN_TYPE_OPERATOR) && (main_token_lengths[i] == 1))
      {
        if (text.mid(main_token_offsets[i], main_token_lengths[i]) == "(")
        {
          ++parentheses_count;
          continue;
        }
        if (text.mid(main_token_offsets[i], main_token_lengths[i]) == ")")
        {
          --parentheses_count;
          if (parentheses_count == 0)
          {
            parameter_list_seen= 1;
            continue;
          }
        }
      }
    }

    if ((function_seen == 1) && (parameter_list_seen == 1) && (characteristic_seen == 0))
    {
      if (text.mid(main_token_offsets[i], main_token_lengths[i]) == "(")
      {
        ++parentheses_count;
        continue;
      }
      if (text.mid(main_token_offsets[i], main_token_lengths[i]) == ")")
      {
        --parentheses_count;
        continue;
      }
      if (parentheses_count != 0)
      {
        continue;
      }
      if (main_token_types[i] == TOKEN_KEYWORD_RETURNS)
      {
        continue;
      }
      if (data_type_seen == 0)
      {
        if ((main_token_types[i] == TOKEN_KEYWORD_ASCII)
         || (main_token_types[i] == TOKEN_KEYWORD_BIGINT)
         || (main_token_types[i] == TOKEN_KEYWORD_BFILE)
         || (main_token_types[i] == TOKEN_KEYWORD_BIGINT)
         || (main_token_types[i] == TOKEN_KEYWORD_BINARY)
         || (main_token_types[i] == TOKEN_KEYWORD_BINARY_DOUBLE)
         || (main_token_types[i] == TOKEN_KEYWORD_BINARY_FLOAT)
         || (main_token_types[i] == TOKEN_KEYWORD_BIT)
         || (main_token_types[i] == TOKEN_KEYWORD_BLOB)
         || (main_token_types[i] == TOKEN_KEYWORD_BOOL)
         || (main_token_types[i] == TOKEN_KEYWORD_BOOLEAN)
         || (main_token_types[i] == TOKEN_KEYWORD_CHAR)
         || (main_token_types[i] == TOKEN_KEYWORD_CHARACTER)
         || (main_token_types[i] == TOKEN_KEYWORD_DATE)
         || (main_token_types[i] == TOKEN_KEYWORD_DATETIME)
         || (main_token_types[i] == TOKEN_KEYWORD_DEC)
         || (main_token_types[i] == TOKEN_KEYWORD_DECIMAL)
         || (main_token_types[i] == TOKEN_KEYWORD_DOUBLE)
         || (main_token_types[i] == TOKEN_KEYWORD_ENUM)
         || (main_token_types[i] == TOKEN_KEYWORD_FLOAT)
         || (main_token_types[i] == TOKEN_KEYWORD_GEOMETRY)
         || (main_token_types[i] == TOKEN_KEYWORD_GEOMETRYCOLLECTION)
         || (main_token_types[i] == TOKEN_KEYWORD_INT)
         || (main_token_types[i] == TOKEN_KEYWORD_INTEGER)
         || (main_token_types[i] == TOKEN_KEYWORD_JSON)
         || (main_token_types[i] == TOKEN_KEYWORD_LINESTRING)
         || (main_token_types[i] == TOKEN_KEYWORD_LONGBLOB)
         || (main_token_types[i] == TOKEN_KEYWORD_LONGTEXT)
         || (main_token_types[i] == TOKEN_KEYWORD_MEDIUMBLOB)
         || (main_token_types[i] == TOKEN_KEYWORD_MEDIUMINT)
         || (main_token_types[i] == TOKEN_KEYWORD_MEDIUMTEXT)
         || (main_token_types[i] == TOKEN_KEYWORD_MULTILINESTRING)
         || (main_token_types[i] == TOKEN_KEYWORD_MULTIPOINT)
         || (main_token_types[i] == TOKEN_KEYWORD_MULTIPOLYGON)
         || (main_token_types[i] == TOKEN_KEYWORD_NUMBER)
         || (main_token_types[i] == TOKEN_KEYWORD_NUMERIC)
         || (main_token_types[i] == TOKEN_KEYWORD_NVARCHAR2)
         || (main_token_types[i] == TOKEN_KEYWORD_POINT)
         || (main_token_types[i] == TOKEN_KEYWORD_POLYGON)
         || (main_token_types[i] == TOKEN_KEYWORD_RAW)
         || (main_token_types[i] == TOKEN_KEYWORD_SERIAL)
         || (main_token_types[i] == TOKEN_KEYWORD_SET)
         || (main_token_types[i] == TOKEN_KEYWORD_SMALLINT)
         || (main_token_types[i] == TOKEN_KEYWORD_TIME)
         || (main_token_types[i] == TOKEN_KEYWORD_TIMESTAMP)
         || (main_token_types[i] == TOKEN_KEYWORD_TINYBLOB)
         || (main_token_types[i] == TOKEN_KEYWORD_TINYINT)
         || (main_token_types[i] == TOKEN_KEYWORD_TINYTEXT)
         || (main_token_types[i] == TOKEN_KEYWORD_UNICODE)
         || (main_token_types[i] == TOKEN_KEYWORD_VARCHAR)
         || (main_token_types[i] == TOKEN_KEYWORD_VARCHAR2)
         || (main_token_types[i] == TOKEN_KEYWORD_VARCHARACTER)
         || (main_token_types[i] == TOKEN_KEYWORD_YEAR))
        {
          data_type_seen= 1;
          continue;
        }
      }
      if (data_type_seen == 1)
      {
        if ((main_token_types[i] == TOKEN_KEYWORD_PRECISION)
         || (main_token_types[i] == TOKEN_KEYWORD_VARYING)
         || (main_token_types[i] == TOKEN_KEYWORD_UNSIGNED)
         || (main_token_types[i] == TOKEN_KEYWORD_ZEROFILL))
        {
          continue;
        }
        if ((main_token_types[i] == TOKEN_KEYWORD_CHARSET) || (main_token_types[i] == TOKEN_KEYWORD_CHARACTER))
        {
          character_set_seen= 1;
          continue;
        }
        if (main_token_types[i] == TOKEN_KEYWORD_COLLATE)
        {
          collate_seen= 1;
          continue;
        }
        if (character_set_seen == 1)
        {
          if (main_token_types[i] == TOKEN_KEYWORD_SET)
          {
            continue;
          }
          character_set_seen= 0;
          continue;
        }
        if (collate_seen == 1)
        {
          collate_seen= 0;
          continue;
        }
      }
    }

    if (((function_seen == 1) || (procedure_seen == 1)) && (parameter_list_seen == 1))
    {
      if ((text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "COMMENT")
       || (text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "LANGUAGE")
       || (main_token_types[i] == TOKEN_KEYWORD_SQL)
       || (main_token_types[i] == TOKEN_KEYWORD_DETERMINISTIC)
       || (main_token_types[i] == TOKEN_KEYWORD_NOT)
       || (text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "CONTAINS")
       || (text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "NO")
       || (main_token_types[i] == TOKEN_KEYWORD_READS)
       || (text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "DATA")
       || (main_token_types[i] == TOKEN_KEYWORD_MODIFIES)
       || (text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "SECURITY")
       || (text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "DEFINER")
       || (text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper() == "INVOKER")
       || (main_token_types[i] == TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE)
       || (main_token_types[i] == TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE)
       || (main_token_types[i] == TOKEN_TYPE_LITERAL))
      {
        characteristic_seen= 1;
        continue;
      }
    }
    /* Todo: consider checking for ROLE too, but it is not a reserved word. */
    if ((main_token_types[i] == TOKEN_KEYWORD_DATABASE)
     || (main_token_types[i] == TOKEN_KEYWORD_INDEX)
     || (main_token_types[i] == TOKEN_KEYWORD_LOGFILE)
     || (main_token_types[i] == TOKEN_KEYWORD_SERVER)
     || (main_token_types[i] == TOKEN_KEYWORD_TABLE)
     || (main_token_types[i] == TOKEN_KEYWORD_TABLESPACE)
     || (main_token_types[i] == TOKEN_KEYWORD_VIEW))
    {
      if (function_seen + procedure_seen + trigger_seen + event_seen == 0)
      {
        return -1;
      }
    }
    if ((function_seen == 1) || (procedure_seen == 1))
    {
      if (parameter_list_seen == 0) continue;
      if ((main_token_types[i] == TOKEN_KEYWORD_IS)
       || (main_token_types[i] == TOKEN_KEYWORD_AS))
      {
        continue;
      }
      return i;
    }
  }
  return -1;
}


/*
  The special cases of FUNCTION, ROW, DO, END, BEGIN. We don't want to mark them as special unless
  we know they're really serving a non-identifier role in the statement, but they might be,
  because they're not reserved. This has to be right because later we might count BEGINs
  minus ENDs in order to figure out whether a compound statement has ended.
  FUNCTION is a keyword if: previous == DROP or CREATE [definer=...] or DROP (this is known in advance)
  ROW is a keyword if: previous == EACH
  DO is a keyword if: last statement-beginner keyword was WHILE
                      and next is a statement-beginner keyword or a label
                      (but actually this just checks whether we're within WHILE -- Todo: must fix that someday)
  END is a keyword if: previous == ; or BEGIN
  BEGIN is a keyword if: previous ==  ; or : or BEGIN or DO or ELSE or LOOP or ROW or THEN
                         or previous = ) and word before matching ( is PROCEDURE or FUNCTION or TRIGGER
                         and next is not :
                         or it's first word in main body or handler body, which is what causes most of the difficulties.
*/
void MainWindow::tokens_to_keywords_revert(int i_of_body, int i_of_function, int i_of_do, QString text, int start)
{
  if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) != 0) return;
  int i;                                                /* index of current token */
  int i_prev= -1;                                       /* index of last non-comment token */
  int i_of_while= -1;                                   /* index of last keyword = while */

  for (i= start; main_token_lengths[i] != 0; ++i)
  {
    /* If this is a comment then don't note its position i.e. i_prev is only for non-comment tokens */
    if ((main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
     || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_SLASH)
     || (main_token_types[i] == TOKEN_TYPE_COMMENT_WITH_MINUS))
    {
      continue;
    }
    if (i_prev != -1)
    {
      /* If this is ":" then the last item can't have been a keyword */
      if (QString::compare(text.mid(main_token_offsets[i], main_token_lengths[i]), ":") == 0)
      {
        if ((main_token_types[i_prev] >= TOKEN_KEYWORDS_START))
        {
          main_token_types[i_prev]= TOKEN_TYPE_OTHER;
        }
      }
      /* If this is FUNCTION then it's not a keyword unless previous was DROP or CREATE [definer=...] */
      if (main_token_types[i] == TOKEN_KEYWORD_FUNCTION)
      {
        if ((i == i_of_function) || (main_token_types[i_prev] == TOKEN_KEYWORD_DROP)) ;
        else main_token_types[i]= TOKEN_TYPE_OTHER;
      }
      /* If this is ROW then it's not a keyword unless previous was EACH as in FOR EACH ROW */
      if (main_token_types[i] == TOKEN_KEYWORD_ROW)
      {
        if (main_token_types[i_prev] == TOKEN_KEYWORD_EACH) ;
        else main_token_types[i]= TOKEN_TYPE_OTHER;
      }
      /* If this is DO then it's not a keyword unless it's after WHILE (condition) */
      if (main_token_types[i] == TOKEN_KEYWORD_DO)
      {
        if (i_of_while != -1) i_of_while= -1;
        else
        {
          if (i != i_of_do)
          {
            main_token_types[i]= TOKEN_TYPE_OTHER;
          }
        }
      }
      /* If this is END then it's not a keyword unless previous was ; or BEGIN */
      if (main_token_types[i] == TOKEN_KEYWORD_END)
      {
        if ((QString::compare(text.mid(main_token_offsets[i_prev], main_token_lengths[i_prev]), ";") == 0)
        || (main_token_types[i_prev] == TOKEN_KEYWORD_BEGIN)) ;
        else main_token_types[i]= TOKEN_TYPE_OTHER;
      }
      /* If this is BEGIN then it's not a keyword unless it's body start or prev = BEGIN|DO|ELSE|LOOP|ROW|THEN */
      if (main_token_types[i] == TOKEN_KEYWORD_BEGIN)
      {
        if ((i == i_of_body)
        || (QString::compare(text.mid(main_token_offsets[i_prev], main_token_lengths[i_prev]), ":") == 0)
        || (QString::compare(text.mid(main_token_offsets[i_prev], main_token_lengths[i_prev]), ";") == 0)
        || (main_token_types[i_prev] == TOKEN_KEYWORD_BEGIN)
        || (main_token_types[i_prev] == TOKEN_KEYWORD_DO)
        || (main_token_types[i_prev] == TOKEN_KEYWORD_ELSE)
        || (main_token_types[i_prev] == TOKEN_KEYWORD_LOOP)
        || (main_token_types[i_prev] == TOKEN_KEYWORD_ROW)
        || (main_token_types[i_prev] == TOKEN_KEYWORD_THEN)) ;
        else main_token_types[i]= TOKEN_TYPE_OTHER;
      }
    }
    if (main_token_types[i] == TOKEN_KEYWORD_WHILE) i_of_while= i;
    if ((QString::compare(text.mid(main_token_offsets[i], main_token_lengths[i]), "HANDLER", Qt::CaseInsensitive) == 0)
     && (main_token_types[next_token(i)] == TOKEN_KEYWORD_FOR))
    {
      /* DECLARE ... HANDLER FOR might be followed by BEGIN so we have to find where statement starts */
      int i_plus_1, i_plus_2, i_plus_3, i_plus_4, i_next;
      i= next_token(i);
      for (;;)
      {
        i_plus_1= next_token(i);
        i_plus_2= next_token(i_plus_1);
        i_plus_3= next_token(i_plus_2);
        i_plus_4= next_token(i_plus_3);
        if ((main_token_types[i_plus_1] == TOKEN_KEYWORD_SQLSTATE)
         && (QString::compare(text.mid(main_token_offsets[i_plus_2], main_token_lengths[i_plus_2]), "VALUE", Qt::CaseInsensitive) == 0))
        {
          if (main_token_types[i_plus_3] >= TOKEN_KEYWORDS_START) main_token_types[i_plus_3]= TOKEN_TYPE_OTHER;
          i_next= i_plus_4;
        }
        else if (main_token_types[i_plus_1] == TOKEN_KEYWORD_SQLSTATE)
        {
          if (main_token_types[i_plus_2] >= TOKEN_KEYWORDS_START) main_token_types[i_plus_2]= TOKEN_TYPE_OTHER;
          i_next= i_plus_3;
        }
        else if ((main_token_types[i_plus_1] == TOKEN_KEYWORD_NOT)
         && (QString::compare(text.mid(main_token_offsets[i_plus_2], main_token_lengths[i_plus_2]), "FOUND", Qt::CaseInsensitive) == 0))
        {
          i_next= i_plus_3;
        }
        else
        {
          if (main_token_types[i_plus_1] >= TOKEN_KEYWORDS_START) main_token_types[i_plus_1]= TOKEN_TYPE_OTHER;
          i_next= i_plus_2;
        }
        if (QString::compare(text.mid(main_token_offsets[i_next], main_token_lengths[i_next]), ",") == 0)
        {
          i= i_next;
          continue;
        }
        break;
      }
      /* now i_next == first_word_in_statement in DECLARE HANDLER, unless syntax is bad, I hope */
      i= i_next;
    }
    i_prev= i;
  }
}

/* returns next token after i, skipping comments, but do not go past end */
/* todo: maybe it could be merged with next_i() */
int MainWindow::next_token(int i)
{
  int i2;

  for (i2= i;;)
  {
    if (main_token_lengths[i2] == 0) break;
    ++i2;
    if ((main_token_types[i2] == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
    || (main_token_types[i2] == TOKEN_TYPE_COMMENT_WITH_SLASH)
    || (main_token_types[i2] == TOKEN_TYPE_COMMENT_WITH_MINUS))
    {
      continue;
    }
    break;
  }
  return i2;
}

/*
  Called by mouseMoveEvent for hovering in the statement widget.
  Called from deep within hparse_f_multiblock().
  Pass: offset in main_token lists
  Return: information string
*/
QString MainWindow::token_reftype(int i, bool is_hover, int token_type, char reftype_parameter)
{
#define MAX_REFTYPEWORD_LENGTH 60
struct reftypewords {
   char  chars[MAX_REFTYPEWORD_LENGTH];
   unsigned int reserved_flags;
   unsigned short int built_in_function_flags;
   unsigned short int token_keyword;
};

    /* reftype_values strings must correspond to the order of TOKEN_REFTYPE_ #defines */
    /* Todo: strings shouldn't be blank */
  const reftypewords reftype_values[]=
    {
    {"", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ANY},
    {"alias-of-column ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ALIAS_OF_COLUMN},
    {"alias-of-table ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ALIAS_OF_TABLE},
    {"attribute ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ATTRIBUTE},
    {"auto_increment ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_AUTO_INCREMENT},
    {"channel ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CHANNEL},
    {"character-set ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CHARACTER_SET},
    {"collation ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_COLLATION},
    {"column ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_COLUMN},
    {"column-or-user-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_COLUMN_OR_USER_VARIABLE},
    {"column-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_COLUMN_OR_VARIABLE},
    {"comment ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_COMMENT},
    {"condition-define ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CONDITION_DEFINE},
    {"condition-refer ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CONDITION_REFER},
    {"condition-or-cursor ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CONDITION_OR_CURSOR},
    {"constraint ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CONSTRAINT},
    {"cursor-define ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CURSOR_DEFINE},
    {"cursor-refer ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_CURSOR_REFER},
    {"database ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE}, /* or schema */
    {"database-or-constraint ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_CONSTRAINT},
    {"database-or-event ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_EVENT},
    {"database-or-function ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_FUNCTION},
    {"database-or-function-or-procedure ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_FUNCTION_OR_PROCEDURE},
    {"database-or-function-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_FUNCTION_OR_VARIABLE},
    {"database-or-package ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_PACKAGE},
    {"database-or-procedure ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_PROCEDURE},
    {"database-or-sequence ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_SEQUENCE},
    {"database-or-table ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE},
    {"database-or-table-or-row ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW},
    {"database-or-table-or-column ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN},
    {"database-or-table-or-column-or-function ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN_OR_FUNCTION},
    {"database-or-table-or-variable-or-function ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_VARIABLE_OR_FUNCTION},
    {"database-or-table-or-row-or-function-or-column ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW_OR_FUNCTION_OR_COLUMN},
    {"database-or-table-or-row-or-function-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW_OR_FUNCTION_OR_VARIABLE},
    {"database-or-table-or-column-or-function-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN_OR_FUNCTION_OR_VARIABLE},
    {"database-or-table-or-row-or-column-or-function-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW_OR_COLUMN_OR_FUNCTION_OR_VARIABLE},
    {"database-or-trigger ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_TRIGGER},
    {"database-or-view ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DATABASE_OR_VIEW},
    {"directory ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_DIRECTORY},
    {"engine ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ENGINE},
    {"event ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_EVENT},
    {"file ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_FILE},
    {"function ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_FUNCTION},
    {"function-or-procedure ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_FUNCTION_OR_PROCEDURE},
    {"function-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_FUNCTION_OR_VARIABLE},
    {"handler-alias ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_HANDLER_ALIAS},
    {"host ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_HOST},
    {"index ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_INDEX},
    {"introducer ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_INTRODUCER},
    {"key_cache ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_KEY_CACHE},
    {"label-define ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_LABEL_DEFINE},
    {"label-refer ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_LABEL_REFER},
    {"length ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_LENGTH},
    {"package ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PACKAGE},
    {"parameter-define ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PARAMETER_DEFINE},
    {"parameter-refer ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PARAMETER_REFER},
    {"parser ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PARSER},
    {"plugin ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PLUGIN},
    {"procedure ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PROCEDURE},
    /* plus {"", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_RESERVED_FUNCTION */
    {"partition ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PARTITION},
    {"partition-number ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PARTITION_NUMBER},
    {"password ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_PASSWORD},
    {"role ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ROLE},
    {"row ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ROW},
    {"row-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_ROW_OR_VARIABLE},
    {"savepoint ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_SAVEPOINT},
    {"scale ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_SCALE},
    {"sequence ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_SEQUENCE},
    {"server ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_SERVER},
    {"sqlstate ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_SQLSTATE},
    {"statement ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_STATEMENT},
    {"subpartition ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_SUBPARTITION},
    {"switch ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_SWITCH_NAME},
    {"table ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TABLE},
    {"table-or-column ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TABLE_OR_COLUMN},
    {"table-or-column-or-function ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TABLE_OR_COLUMN_OR_FUNCTION},
    {"table-or-column-or-function-or-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TABLE_OR_COLUMN_OR_FUNCTION_OR_VARIABLE},
    {"table-or-row ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TABLE_OR_ROW},
    {"tablespace ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TABLESPACE},
    {"transaction ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TRANSACTION},
    {"trigger ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_TRIGGER},
    {"user ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_USER},
    {"user-variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_USER_VARIABLE},
    {"variable ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_VARIABLE},         /* i.e. either USER_VARIABLE or DECLARED VARIABLE */
    {"variable-define ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_VARIABLE_DEFINE},
    {"variable-refer ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_VARIABLE_REFER},
    {"view ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_VIEW},
    {"with-table ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_WITH_TABLE},
    {"wrapper ", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_WRAPPER},
    {"", FLAG_VERSION_ALL, 0, TOKEN_REFTYPE_MAX}
  };

  QString s= "";
  int token_flag= main_token_flags[i];

  if (is_hover)
  {
    if ((token_flag & TOKEN_FLAG_IS_ERROR) != 0) s= "(error) ";
    if ((token_flag & TOKEN_FLAG_IS_FUNCTION) != 0) s= "(function) ";
  }
  if ((token_type >= TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE)
   && (token_type <= TOKEN_TYPE_LITERAL))
  {
    int array_subscript= reftype_parameter;
    s.append((char*)reftype_values[array_subscript].chars);
    s.append("literal");
  }
  else if ((token_type >= TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK)
   && (token_type <= TOKEN_TYPE_IDENTIFIER))
  {
    s.append("[");
    int array_subscript= reftype_parameter;
    s.append((char*)reftype_values[array_subscript].chars);
    s.append("identifier]");
  }
  else if ((token_type >= TOKEN_TYPE_COMMENT_WITH_SLASH)
   && (token_type <= TOKEN_TYPE_COMMENT_WITH_MINUS))
  {
    s.append("comment");
  }
  else if (token_type == TOKEN_TYPE_OPERATOR)
  {
    s.append("operator");
  }
  else if (token_type == TOKEN_TYPE_OTHER)
  {
    s.append("[identifier or keyword]");
  }
  else
  {
    if ((token_flag & TOKEN_FLAG_IS_RESERVED) != 0)
    {
      s.append("reserved ");
    }
    s.append("keyword");
  }
  return s;
}

#if (OCELOT_MYSQL_INCLUDE == 1)
/*
  Todo: disconnect old if already connected.
  TODO: LOTS OF ERROR CHECKS NEEDED IN THIS!
   QRegExp is unavailable in Qt 6. Todo: We have never tested the replacemnt QRegularExpression code.
*/
int MainWindow::connect_mysql(unsigned int connection_number)
{
  QString ldbms_return_string;
  ldbms_return_string= "";

  /* Find libmysqlclient. Prefer ld_run_path, within that prefer libmysqlclient.so.18.
    Generally libmysqlclient.so will have a symlink to libmariadb.so
    or to libmariadbclient.so. But not always. Not on Windows.
    And not on some MariaDB releases -- there were some renames and
    some bugs with missing symlinks.
    Also, if ocelot_dbms=mysql, the libmysqlclient searches come first,
    but if ocelot_dbms=mariadb, the libmariadb searches come first.
    So try multiple combinations. e.g. if libmysqlclient.so.18 didn't
    get loaded, try libmysqlclient without a version number.
  */
  for (int i= 1; i <= 12; ++i)
  {
    QString li_path;
    int li_lib= 0;
    if (i == 1) {if (connections_dbms[0] == DBMS_MARIADB) continue; li_path= ocelot_ld_run_path; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT18; }
    if (i == 2) {if (connections_dbms[0] == DBMS_MARIADB) continue; li_path= ocelot_ld_run_path; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT; }
    if (i == 3) {                                                   li_path= ocelot_ld_run_path; li_lib= WHICH_LIBRARY_LIBMARIADBCLIENT; }
    if (i == 4) {                                                   li_path= ocelot_ld_run_path; li_lib= WHICH_LIBRARY_LIBMARIADB; }
    if (i == 5) {if (connections_dbms[0] != DBMS_MARIADB) continue; li_path= ocelot_ld_run_path; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT18; }
    if (i == 6) {if (connections_dbms[0] != DBMS_MARIADB) continue; li_path= ocelot_ld_run_path; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT; }
    if (i == 7) {if (connections_dbms[0] == DBMS_MARIADB) continue; li_path= ""                ; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT18; }
    if (i == 8) {if (connections_dbms[0] == DBMS_MARIADB) continue; li_path= ""                ; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT; }
    if (i == 9) {                                                   li_path= ""                ; li_lib= WHICH_LIBRARY_LIBMARIADBCLIENT; }
    if (i == 10){                                                   li_path= ""                ; li_lib= WHICH_LIBRARY_LIBMARIADB; }
    if (i == 11){if (connections_dbms[0] != DBMS_MARIADB) continue; li_path= ""                ; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT18; }
    if (i == 12){if (connections_dbms[0] != DBMS_MARIADB) continue; li_path= ""                ; li_lib= WHICH_LIBRARY_LIBMYSQLCLIENT; }
    lmysql->ldbms_get_library(li_path, &is_libmysqlclient_loaded, &libmysqlclient_handle, &ldbms_return_string, li_lib);
    if (is_libmysqlclient_loaded == 1)
    {
      break;
    }
  }


  /* Todo: The following errors would be better if we put them in diagnostics the usual way. */

  if (is_libmysqlclient_loaded == -2)
  {
    /* Todo: QMessageBox should have a parent, use "= new" */
    QMessageBox msgbox;
    char error_message[2048];
    char t_ldbms_return_string[2048];
    strcpy(t_ldbms_return_string, ldbms_return_string.toUtf8());
    sprintf(error_message, er_strings[er_off + ER_LIBMYSQLCLIENT_DOES_NOT_HAVE], t_ldbms_return_string);
    msgbox.setText(error_message);
    msgbox.exec();
    //delete lmysql;
    return 1;
  }

  if (is_libmysqlclient_loaded == 0)
  {
    /* Todo: QMessageBox should have a parent, use "= new" */
    QMessageBox msgbox;
    char error_message[2048];
    char t_ldbms_return_string[2048];
    strcpy(t_ldbms_return_string, ldbms_return_string.toUtf8());
    sprintf(error_message, er_strings[er_off + ER_LIBMYSQLCLIENT_WAS_NOT_FOUND], t_ldbms_return_string);
    msgbox.setText(error_message);
    msgbox.exec();
    //delete lmysql;
    return 1;
  }

  if (is_mysql_library_init_done == false)
  {
    if (lmysql->ldbms_mysql_library_init(0, NULL, NULL))
    {
      /* Todo: QMessageBox should have a parent, use "= new" */
      QMessageBox msgbox;
      msgbox.setText(er_strings[er_off + ER_MYSQL_LIBRARY_INIT_FAILED]);
      msgbox.exec();
      return 1;
    }
    is_mysql_library_init_done= true;
  }
  /* Mysterious crash may happen with one particular MariaDB version. */
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
  {
    QString s;
    s= lmysql->ldbms_mysql_get_client_info();
    if (s.contains("10.1.7", Qt::CaseInsensitive) == true)
    {
      QMessageBox msgbox;
      msgbox.setText("Warning: Detected MariaDB 10.1.7 client library. This version has been known to cause problems.");
      msgbox.exec();
    }
  }
#endif
  /* I decided this line is unnecessary, mysql_init is done in options_and_connect() */
  //lmysql->ldbms_mysql_init(&mysql[connection_number]);
  if (the_connect(connection_number))
  {
    put_diagnostics_in_result(connection_number, DIAGNOSTIC_0);
    make_and_append_message_in_result(ER_FAILED_TO_CONNECT, 0, (char*)"");
    return 1;
  }
  make_and_put_message_in_result(ER_OK, 0, (char*)"");

  /*
    Initially ocelot_prompt == "mysql>" and ocelot_ca.prompt_is_default == true.
    It might have changed if getenv("MYSQL_PS1") returned something.
    It might have changed if --prompt = prompt-format was specified.
    We can override it with "mariadb>" if the client library comes from MariaDB.
    That is, we depend on mysql_get_client_info() not mysql_get_host_info().
    That is, we say "mariadb>" although mariadb's client would probably say "\N [\d]>".
    For example mysql_get_client_info() might return "10.0.4-MariaDB".
    We'll set ocelot_ca.prompt_is_default= false to ensure this only happens once.
    We are hoping that following statements don't override earlier PROMPT statements by user.
    TODO: This had to be abandoned because it didn't work properly with Qt4.
          Since I didn't know what the true problem was, or exactly which versions
          will work, I cancelled it. The todo is: revive it.
  */
  //{
  //  if (ocelot_ca.prompt_is_default == true)
  //  {
  //    QString s;
  //    s= lmysql->ldbms_mysql_get_client_info();
  //    if (s.contains("MariaDB", Qt::CaseInsensitive) == true)
  //    {
  //      ocelot_prompt= "mariadb>";
  //    }
  //    ocelot_ca.prompt_is_default= false;
  //  }
  //}

  statement_edit_widget->prompt_default= ocelot_prompt;
  statement_edit_widget->prompt_as_input_by_user= statement_edit_widget->prompt_default;

  /*
    Collect some variables in case they're needed for "prompt".
    Todo: handle errors better after mysql_ calls here.
    A possible error is: Error 1226 (42000) User ... has exceeded the 'max_queries_per_hour' resource
    A possible error is: Error 1820 (HY000) You must reset your password using ALTER USER statement before executing this statement.
    Not using the mysql_res global, since this is not for user to see.
  */
  int query_result= lmysql->ldbms_mysql_query(&mysql[connection_number], "select version(), database(), @@port, current_user(), connection_id()");
  if (query_result != 0 )
  {
    connect_mysql_error_box(er_strings[er_off + ER_MYSQL_QUERY_FAILED], connection_number);
    connect_init(connection_number);
    return 0;
  }
  MYSQL_RES *mysql_res_for_connect;
  MYSQL_ROW connect_row;
  QString s;
  int i;

  // unsigned long connect_lengths[1];
  mysql_res_for_connect= lmysql->ldbms_mysql_store_result(&mysql[connection_number]);
  if (mysql_res_for_connect == NULL)
  {
    connect_mysql_error_box(er_strings[er_off + ER_MYSQL_STORE_RESULT_FAILED], connection_number);
    connect_init(connection_number);
    return 0;
  }
  connect_row= lmysql->ldbms_mysql_fetch_row(mysql_res_for_connect);
  if (connect_row == NULL)
  {
    connect_mysql_error_box(er_strings[er_off + ER_MYSQL_FETCH_ROW_FAILED], connection_number);
    connect_init(connection_number);
    return 0;
  }
  /* lengths= lmysql->ldbms_mysql_fetch_lengths(mysql_res_for_connect); */
  statement_edit_widget->dbms_version= connect_row[0];
  statement_edit_widget->dbms_database= connect_row[1];
  statement_edit_widget->dbms_port= connect_row[2];
  s= connect_row[3];
  statement_edit_widget->dbms_current_user= s;
#if (QT_VERSION >= 0x60000)
  i= s.indexOf(QRegularExpression("@"), 0);
#else
  i= s.indexOf(QRegExp("@"), 0);
#endif
  if (i > 0) s= s.left(i);
  else s= "";
  statement_edit_widget->dbms_current_user_without_host= s;
  statement_edit_widget->dbms_connection_id= atoi(connect_row[4]);
  /* Todo: find out why this returns capitalized e.g. "Localhost" rather than "localhost" */
  s= lmysql->ldbms_mysql_get_host_info(&mysql[connection_number]);
#if (QT_VERSION >= 0x60000)
  i= s.indexOf(QRegularExpression(" "), 0);
#else
  i= s.indexOf(QRegExp(" "), 0);
#endif
  if (i > 0) s= s.left(i);
  statement_edit_widget->dbms_host= s;
  lmysql->ldbms_mysql_free_result(mysql_res_for_connect);
  get_sql_mode(TOKEN_KEYWORD_CONNECT, "", false, main_token_number);
  connect_init(connection_number);
  set_dbms_version_mask(statement_edit_widget->dbms_version, connection_number);
#if (OCELOT_EXPLORER == 1)
  if (connection_number == 0) initialize_widget_explorer_after_connect();
#endif
  return 0;
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

#if (OCELOT_MYSQL_INCLUDE == 1)
void MainWindow::connect_mysql_error_box(QString s1, unsigned int connection_number)
{
  QString s2;
  char i_mysql_error_and_state[1024];
  int i_mysql_errno_result= lmysql->ldbms_mysql_errno(&mysql[connection_number]);
  s1.append(tr(" Warning: Connection succeeded, but server refused to provide some non-essential information due to Error "));
  sprintf(i_mysql_error_and_state, "%d (%s) ", i_mysql_errno_result, lmysql->ldbms_mysql_sqlstate(&mysql[connection_number]));
  s1.append(i_mysql_error_and_state);
  s2= lmysql->ldbms_mysql_error(&mysql[connection_number]);
  s1.append(s2);
  /* Todo: QMessageBox should have a parent, use "= new" */
  QMessageBox msgbox;
  msgbox.setText(s1);
  msgbox.exec();
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

/*
 We call set_dbms_version_mask(ocelot_dbms) from MainWindow() after
 calling mysql_options_2(),in which case the pass should be the original
 default ("mysql") or something the user specified with --ocelot_dbms
 (probably "mysql" or "mariadb" but could contain version
 before or after and we don't check validity).
 We call set_dbms_version_mask(statement_edit_widget->dbms_version)
 from connect_mysql() after connection succeeds, in which case the
 pass would be what "select version()" returns, such as 10.2.0-MariaDB,
 or 8.0.11 (MySQL might not say 'mysql'). Assume Percona is like MySQL.
 Or we call from connect_tarantool() after connection succeeds.
 If there's a disconnect later, we don't reset to original flag values.
 If you must know the vendor, then maybe select @@version_comment
 is good, but I don't know if @@version_comment was in old versions.
 Warn: get_sql_mode() might change dbms_version_mask.
 If we don't see a known version number, we tend to assume it's a later version.
 Todo: a message like "Don't recognize MySQL/MariaDB version" would be nice.
 Todo: if command line had a version number, don't let version() override it.
 Warning: this may override setting of dbms_connections[0] done in connect_set_variable()
*/
void MainWindow::set_dbms_version_mask(QString version, int connection_number)
{
  if (version.contains("mariadb", Qt::CaseInsensitive) == true)
  {
    if (version.startsWith("10.") == true)
    {
      if (version.startsWith("10.0.") == true)
        dbms_version_mask= (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_0);
      else if (version.startsWith("10.1.") == true)
        dbms_version_mask= (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_0 | FLAG_VERSION_MARIADB_10_1);
      else if (version.startsWith("10.2.2") == true)
        dbms_version_mask= (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_0 | FLAG_VERSION_MARIADB_10_1 | FLAG_VERSION_MARIADB_10_2_2);
      else if (version.startsWith("10.2.3") == true)
        dbms_version_mask= (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_0 | FLAG_VERSION_MARIADB_10_1 | FLAG_VERSION_MARIADB_10_2_2 | FLAG_VERSION_MARIADB_10_2_3);
      else if (version.startsWith("10.3.") == true)
        dbms_version_mask= (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_0 | FLAG_VERSION_MARIADB_10_1 | FLAG_VERSION_MARIADB_10_2_2 | FLAG_VERSION_MARIADB_10_2_3 | FLAG_VERSION_MARIADB_10_3);
      else
        dbms_version_mask= (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_ALL);
    }
    else if (version.startsWith("11.") == true)
    {
      if (version.startsWith("11.0.") == true)
        dbms_version_mask= (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_ALL | FLAG_VERSION_MARIADB_11_0);
      else if (version.startsWith("11.1.") == true)
        dbms_version_mask= (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_ALL | FLAG_VERSION_MARIADB_11_0 | FLAG_VERSION_MARIADB_11_1);
      else if (version.startsWith("11.2.") == true)
        dbms_version_mask= (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_ALL | FLAG_VERSION_MARIADB_11_0 | FLAG_VERSION_MARIADB_11_1 | FLAG_VERSION_MARIADB_11_2);
      else /* 11.3 + 11.4 */
        dbms_version_mask= (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_ALL | FLAG_VERSION_MARIADB_11_ALL);
      }
    else
      /* 10.4 + 10.5 + 10.6 + 10.7 + 10.8 + 10.9 + 10.10 + 10.11 + 11.* all get the same value */
    {
      dbms_version_mask= FLAG_VERSION_MARIADB_ALL;
    }
  }
#ifdef DBMS_TARANTOOL
  else if (version.contains("tarantool", Qt::CaseInsensitive) == true)
  {
    {
      if (version.contains("2.2.") == true)
      {
        dbms_version_mask= (FLAG_VERSION_TARANTOOL | FLAG_VERSION_TARANTOOL_2_2);
      }
      else if (version.contains("2.3.") == true)
      {
        dbms_version_mask= (FLAG_VERSION_TARANTOOL | FLAG_VERSION_TARANTOOL_2_2 | FLAG_VERSION_TARANTOOL_2_3);
      }
      else if (version.contains("2.4.") == true)
      {
        dbms_version_mask= (FLAG_VERSION_TARANTOOL | FLAG_VERSION_TARANTOOL_2_2 | FLAG_VERSION_TARANTOOL_2_3 | FLAG_VERSION_TARANTOOL_2_4);
      }
      else if ((version.contains("2.7.") == true) || (version.contains("2.8.") == true) || (version.contains("2.9.") == true))
      {
        dbms_version_mask= (FLAG_VERSION_TARANTOOL | FLAG_VERSION_TARANTOOL_2_2 | FLAG_VERSION_TARANTOOL_2_3 | FLAG_VERSION_TARANTOOL_2_4 | FLAG_VERSION_TARANTOOL_2_7);
      }
      else if (version.contains("2.10.") == true)
      {
        dbms_version_mask= (FLAG_VERSION_TARANTOOL | FLAG_VERSION_TARANTOOL_2_2 | FLAG_VERSION_TARANTOOL_2_3 | FLAG_VERSION_TARANTOOL_2_4 | FLAG_VERSION_TARANTOOL_2_7 | FLAG_VERSION_TARANTOOL_2_10);
      }
      else if (version.contains("2.11.") == true)
      {
        dbms_version_mask= (FLAG_VERSION_TARANTOOL | FLAG_VERSION_TARANTOOL_2_2 | FLAG_VERSION_TARANTOOL_2_3 | FLAG_VERSION_TARANTOOL_2_4 | FLAG_VERSION_TARANTOOL_2_7 | FLAG_VERSION_TARANTOOL_2_10 | FLAG_VERSION_TARANTOOL_2_11);
      }
      else if (version.contains("-3.") == true)
      {
        dbms_version_mask= (FLAG_VERSION_TARANTOOL | FLAG_VERSION_TARANTOOL_2_2 | FLAG_VERSION_TARANTOOL_2_3 | FLAG_VERSION_TARANTOOL_2_4 | FLAG_VERSION_TARANTOOL_2_7 | FLAG_VERSION_TARANTOOL_2_10 | FLAG_VERSION_TARANTOOL_2_11 | FLAG_VERSION_TARANTOOL_3_0);
      }
      else
      {
        dbms_version_mask= FLAG_VERSION_TARANTOOL_ALL;
      }
    }
  }
#endif
  /* MySQL's version string might not contain 'mysql */
  else /* if (version.contains("mysql", Qt::CaseInsensitive) == true) */
  {
    if (version.contains("5.6") == true) /* including 5.5.6 since we don't differentiate 5.5 and 5.6 now */
    {
      dbms_version_mask= (FLAG_VERSION_MYSQL_5_5 | FLAG_VERSION_MYSQL_5_6);
    }
    else if ((version.contains("5.7") == true)
          && (version.contains("5.5.7") == false))
    {
      dbms_version_mask= (FLAG_VERSION_MYSQL_5_5 | FLAG_VERSION_MYSQL_5_6 | FLAG_VERSION_MYSQL_5_7);
    }
    else if (version.contains("8.0") == true)
    {
      dbms_version_mask= (FLAG_VERSION_MYSQL_5_5 | FLAG_VERSION_MYSQL_5_6 | FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MYSQL_8_0);
      if (version.contains("8.0.31") == true) dbms_version_mask= (dbms_version_mask | FLAG_VERSION_MYSQL_8_0_31);
    }
    else if (version.contains("mysql", Qt::CaseInsensitive) == true)
    {
      dbms_version_mask= FLAG_VERSION_MYSQL_ALL;
    }
    else dbms_version_mask= FLAG_VERSION_DEFAULT;
  }
  if (((dbms_version_mask&FLAG_VERSION_MYSQL_ALL) != 0)
   && ((dbms_version_mask&FLAG_VERSION_MARIADB_ALL) == 0))
  {
    connections_dbms[connection_number]= DBMS_MYSQL;
  }
  if (((dbms_version_mask&FLAG_VERSION_MARIADB_ALL) != 0)
   && ((dbms_version_mask&FLAG_VERSION_MYSQL_ALL) == 0))
  {
    connections_dbms[connection_number]= DBMS_MARIADB;
  }
}

/*
  Pass: i_start = where we are now, i_increment = +1 or -1
  Go forward | backward skipping comments
  Stop if end or start of all input (we pay no attention to statement
  start|end).
  Todo: this could be useful in other places where we currently
        are making temporary copies that don't contain comments.
  Warning: do not put next_i in a loop without checking that it is at end.
*/
int MainWindow::next_i(int i_start, int i_increment)
{
  int i= i_start;
  for (;;)
  {
    if ((i == 0) && (i_increment <= 0)) break;
    if ((main_token_lengths[i] == 0) && (i_increment >= 0)) break;
    i= i + i_increment;
    if ((main_token_types[i] != TOKEN_TYPE_COMMENT_WITH_SLASH)
      && (main_token_types[i] != TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
      && (main_token_types[i] != TOKEN_TYPE_COMMENT_WITH_MINUS))
     break;
  }
  return i;
}

/* Variant of next_i() where we pass token_lengths + types rather than assume main_token_lengths + types */
int MainWindow::next_i_v(int i_start, int i_increment, int token_types[], int token_lengths[])
{
  int i= i_start;
  for (;;)
  {
    if ((i == 0) && (i_increment <= 0)) break;
    if ((token_lengths[i] == 0) && (i_increment >= 0)) break;
    i= i + i_increment;
    if ((token_types[i] != TOKEN_TYPE_COMMENT_WITH_SLASH)
      && (token_types[i] != TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
      && (token_types[i] != TOKEN_TYPE_COMMENT_WITH_MINUS))
     break;
  }
  return i;
}


#if (OCELOT_MYSQL_INCLUDE == 1)
/*
  We use sql_mode to decide whether "..." is an identifier or a literal.
  So we try to get its value at connect time or if user says
  SET SESSION SQL_MODE ... or SET @@session.sql_mode
  This might fail if (ocelot_statement_syntax_checker.toInt() < 1
  but I'm not expecting people will set that and then expect recognizing.
  Todo: Handle the undocumented syntax SET @@sql_mode=ANSI.
        If MariaDB, we'd have to ensure that we're not in a block
        that has DECLARE ANSI. But it's clearly used by some people.
  Todo: track global value too so we can handle sql_mode=default.
  Todo: try to do this while parsing, before you can ask the server.
  Todo: check: did the server return a warning for this statement?
  Warning: We might call this from within hparse_f_multi_block().
  Warning: if we aren't connected yet, then dbms_version_mask is default e.g. MySQL-8.0 flag is on.
*/
bool MainWindow::get_sql_mode(int who_is_calling,
                              QString text,
                              bool is_in_hparse,
                              int start_token_number)
{
  QString sql_mode_string;
  bool sql_mode_string_seen= false;
  bool must_ask_server= false;
  QString token;
  bool default_is_session= true;
  bool immediate_is_session= true;
  QString var_name;
  bool old_hparse_sql_mode_ansi_quotes= hparse_sql_mode_ansi_quotes;
  if (who_is_calling == TOKEN_KEYWORD_SET)
  {
    int i;
    int t;
    for (i= start_token_number; main_token_lengths[i] != 0; ++i)
    {
      {
        QString token3= text.mid(main_token_offsets[i], main_token_lengths[i]);
        if ((token3 == ";")
         || (token3 == ocelot_delimiter_str)) break;
      }
      t= main_token_types[i];
      if ((t == TOKEN_KEYWORD_SESSION)
      || (t == TOKEN_KEYWORD_LOCAL))
      {
        default_is_session= true;
        continue;
      }
      if ((t == TOKEN_KEYWORD_GLOBAL)
        || (t == TOKEN_KEYWORD_PERSIST)
        || (t == TOKEN_KEYWORD_PERSIST_ONLY))
      {
        default_is_session= false;
        continue;
      }
      var_name= text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper();
      if ((connect_stripper(var_name, false) == "SQL_MODE")
       || (var_name == "@@SQL_MODE"))
      {
        int i_minus_1= next_i(i, -1);
        int i_minus_2= next_i(i_minus_1, -1);
        int i_plus_1= next_i(i, +1);
        int i_plus_2= next_i(i_plus_1, +1);
        int i_plus_3= next_i(i_plus_2, +1);
        if (var_name == "@@SQL_MODE") immediate_is_session= true;
        else
        {
          immediate_is_session= default_is_session;
          token= text.mid(main_token_offsets[i_minus_1], main_token_lengths[i_minus_1]);
          if (token == ".")
          {
            token= text.mid(main_token_offsets[i_minus_2], main_token_lengths[i_minus_2]).toUpper();
            if ((token == "@@SESSION")
             || (token == "@@LOCAL"))
            {
              immediate_is_session= true;
            }
            if ((token == "@@GLOBAL")
             || (token == "@@PERSIST")
             || (token == "@@PERSIST_ONLY"))
            {
              immediate_is_session= false;
            }
          }
          if (immediate_is_session == false) continue;
        }
        token= text.mid(main_token_offsets[i_plus_1], main_token_lengths[i_plus_1]);
        if ((token == "=") || (token == ":="))
        {
          bool is_simple_literal= false;
          /* is_simple_literal=true if e.g. set sql_mode='ansi' */
          t= main_token_types[i_plus_2];
          if ((t == TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE)
           || (t == TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE)
           || (t == TOKEN_TYPE_LITERAL))
          {
            is_simple_literal= true;
          }
          /* is_simple_literal=true if e.g. set sql_mode=ansi */
          if (is_simple_literal == false)
          {
            if ((t == TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK) /* same check as in hparse_f_is_identifier()? */
             || (t == TOKEN_TYPE_IDENTIFIER_WITH_DOUBLE_QUOTE)
             || (t == TOKEN_TYPE_IDENTIFIER)
             || (t >= TOKEN_TYPE_OTHER))
            {
               QString token4= text.mid(main_token_offsets[i_plus_2], main_token_lengths[i_plus_2]);
               if ((token4.left(1) != "@")
                && (main_token_reftypes[i_plus_2] != TOKEN_REFTYPE_VARIABLE_REFER))
                 is_simple_literal= true;
            }
          }
          /* is_simple_literal=false if not simple e.g. 'ansi,ansi' */
          if (is_simple_literal == true)
          {
            QString token3= text.mid(main_token_offsets[i_plus_3], main_token_lengths[i_plus_3]);
            if ((token3 != ",")
             && (token3 != ";")
             && (token3 != ocelot_delimiter_str))
            {
              is_simple_literal= false;
            }
          }
          if (is_simple_literal == false)
          {
            /* User has said SET SESSION sql_mode = not-literal which server can interpret */
            sql_mode_string_seen= false;
            must_ask_server= true;
          }
          else
          {
            /* User has said SET SESSION sql_mode = literal which we can interpret as client */
            sql_mode_string= text.mid(main_token_offsets[i_plus_2], main_token_lengths[i_plus_2]);
            sql_mode_string_seen= true;
            must_ask_server= false;
          }
        }
      }
    }
  }
  if ((who_is_calling == TOKEN_KEYWORD_CONNECT)
   || (must_ask_server == true))
  {
    if (is_in_hparse) return false;
    QString s= select_1_row("select @@session.sql_mode");
    if (s == "")
    {
      sql_mode_string= select_1_row_result_1;
      sql_mode_string_seen= true;
    }
  }
  if (sql_mode_string_seen == true)
  {
    bool is_ok_combo= false;
    if (sql_mode_string.contains("ANSI", Qt::CaseInsensitive) == true)
      is_ok_combo= true;
    if ((dbms_version_mask & FLAG_VERSION_MYSQL_8_0) == 0)
    {
      if ((sql_mode_string.contains("DB2", Qt::CaseInsensitive) == true)
       || (sql_mode_string.contains("MAXDB", Qt::CaseInsensitive) == true)
       || (sql_mode_string.contains("MSSQL", Qt::CaseInsensitive) == true)
       || (sql_mode_string.contains("ORACLE", Qt::CaseInsensitive) == true)
       || (sql_mode_string.contains("POSTGRESQL", Qt::CaseInsensitive) == true))
        is_ok_combo= true;
    }
    if (is_ok_combo)
    {
      if (is_in_hparse == false) sql_mode_ansi_quotes= true;
      hparse_sql_mode_ansi_quotes= true;
    }
    else
    {
      if (is_in_hparse)
      {
        /*
           We'll decide it's false if it contains some valid setting.
           We'll decide it's unknown (and return unchanged) otherwise.
           Obviously this is unreliable, but what else can I do?
        */
        sql_mode_string= sql_mode_string.toUpper();
        bool is_ok= false;
        if ((connect_stripper(sql_mode_string, false) == "")
           || (sql_mode_string.contains("ALLOW_INVALID_DATES"))
           || (sql_mode_string.contains("ERROR_FOR_DIVISION_BY_ZERO"))
           || (sql_mode_string.contains("HIGH_NOT_PRECEDENCE"))
           || (sql_mode_string.contains("IGNORE_SPACE"))
           || (sql_mode_string.contains("NO_AUTO_VALUE_ON_ZERO"))
           || (sql_mode_string.contains("NO_BACKSLASH_ESCAPES"))
           || (sql_mode_string.contains("NO_DIR_IN_CREATE"))
           || (sql_mode_string.contains("NO_ENGINE_SUBSTITUTION"))
           || (sql_mode_string.contains("NO_UNSIGNED_SUBTRACTION"))
           || (sql_mode_string.contains("NO_ZERO_DATE"))
           || (sql_mode_string.contains("NO_ZERO_IN_DATE"))
           || (sql_mode_string.contains("ONLY_FULL_GROUP_BY"))
           || (sql_mode_string.contains("PAD_CHAR_TO_FULL_LENGTH"))
           || (sql_mode_string.contains("PIPES_AS_CONCAT"))
           || (sql_mode_string.contains("REAL_AS_FLOAT"))
           || (sql_mode_string.contains("STRICT_ALL_TABLES"))
           || (sql_mode_string.contains("STRICT_TRANS_TABLES"))
           || (sql_mode_string.contains("TRADITIONAL")))
          is_ok= true;
        if ((dbms_version_mask & FLAG_VERSION_MYSQL_8_0) == 0)
        {
          if ((sql_mode_string.contains("MYSQL323"))
           || (sql_mode_string.contains("MYSQL40"))
           || (sql_mode_string.contains("NO_AUTO_CREATE_USER"))
           || (sql_mode_string.contains("NO_FIELD_OPTIONS"))
           || (sql_mode_string.contains("NO_KEY_OPTIONS"))
           || (sql_mode_string.contains("NO_TABLE_OPTIONS")))
            is_ok= true;
        }
        if ((dbms_version_mask & FLAG_VERSION_MARIADB_10_3) != 0)
        {
          if ((sql_mode_string.contains("EMPTY_STRING_IS_NULL"))
           || (sql_mode_string.contains("IGNORE_BAD_TABLE_OPTIONS"))
           || (sql_mode_string.contains("SIMULTANEOUS_ASSIGNMENT")))
            is_ok= true;
        }
        if ((dbms_version_mask & FLAG_VERSION_MYSQL_8_0) != 0)
        {
          if (sql_mode_string.contains("TIME_TRUNCATE_FRACTIONAL"))
            is_ok= true;
        }
        if (is_ok == false) return false; /* SET will fail so this has no effect */
      }
      if (is_in_hparse == false) sql_mode_ansi_quotes= false;
      hparse_sql_mode_ansi_quotes= false;
    }
    if ((sql_mode_string.contains("ORACLE", Qt::CaseInsensitive) == true)
     && ((hparse_dbms_mask & FLAG_VERSION_MARIADB_10_3) != 0))
    {
      if (is_in_hparse == false) dbms_version_mask |= FLAG_VERSION_PLSQL;
      hparse_dbms_mask |= FLAG_VERSION_PLSQL;
    }
    else
    {
      if (is_in_hparse == false) dbms_version_mask &= (~FLAG_VERSION_PLSQL);
      hparse_dbms_mask &= (~FLAG_VERSION_PLSQL);
    }
    if (sql_mode_string.contains("NO_BACKSLASH_ESCAPES", Qt::CaseInsensitive) == true) sql_mode_no_backslash_escapes= true;
    else sql_mode_no_backslash_escapes= false;
  }
  if (hparse_sql_mode_ansi_quotes == old_hparse_sql_mode_ansi_quotes) return false;
  else return true;
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

/* 20160915: moved hparse_* and tparse_* routines to a new file. */
#include "hparse.h"

#ifdef DBMS_TARANTOOL

/*
  Connect to tarantool server due to --ocelot_dbms='tarantool'
  or "create server id options (port=x);".
  Todo: disconnect old if already connected.
  TODO: LOTS OF ERROR CHECKS NEEDED IN THIS!
  Usually libtarantool.so and libtarantoolnet.so are in /usr/local/lib or LD_LIBRARY_PATH.
  todo: We no longer use libtarantoolnet.so, remove reference to it.
  After connecting:
    -- get session.id and version
    -- todo: if version is old we shouldn't try to use SQL
  ansi_quotes:
    With Tarantool/SQL "x" is a delimited identifier not a string
    literal. So we set hparse_sql_mode_ansi_quotes= true.
    If we mix Tarantool/SQL and MySQL/MariaDB, this is still required.
    So we guess that users are sane. I hope this becomes policy someday.
    With Tarantool/NoSQL "x" is always a string literal.
*/
int MainWindow::connect_tarantool(unsigned int connection_number,
                                  QString port_maybe,
                                  QString host_maybe,
                                  QString password_maybe,
                                  QString user_maybe)
{
  //(void) connection_number; /* suppress "unused parameter" warning */
  QString ldbms_return_string;
  ldbms_return_string= "";

  /* Mainly we want to be sure tarantool_tnt_reply.data == 0 if failure */
  /* tnt_reply_init() also does memset but it might not be available yet */
  memset(&tarantool_tnt_reply, 0, sizeof(struct tnt_reply));

  /* Find libtarantool. Prefer ld_run_path. */
  if (is_libtarantool_loaded != 1)
  {
    lmysql->ldbms_get_library(ocelot_ld_run_path, &is_libtarantool_loaded, &libtarantool_handle, &ldbms_return_string, WHICH_LIBRARY_LIBTARANTOOL);
  }
  if (is_libtarantool_loaded != 1)
  {
    lmysql->ldbms_get_library("", &is_libtarantool_loaded, &libtarantool_handle, &ldbms_return_string, WHICH_LIBRARY_LIBTARANTOOL);
  }
  /* Find libtarantoolnet. Prefer ld_run_path. */
  /* Now libtarantool.so has everything so this is removed. */
  //if (is_libtarantoolnet_loaded != 1)
  //{
  //  lmysql->ldbms_get_library(ocelot_ld_run_path, &is_libtarantoolnet_loaded, &libtarantoolnet_handle, &ldbms_return_string, WHICH_LIBRARY_LIBTARANTOOLNET);
  //}
  //if (is_libtarantoolnet_loaded != 1)
  //{
  //  lmysql->ldbms_get_library("", &is_libtarantoolnet_loaded, &libtarantoolnet_handle, &ldbms_return_string, WHICH_LIBRARY_LIBTARANTOOLNET);
  //}

  /* Todo: The following errors would be better if we put them in diagnostics the usual way. */

  if (is_libtarantool_loaded == -2)
  {
    /* Todo: QMessageBox should have a parent, use "= new" */
    QMessageBox msgbox;
    QString error_message;
    error_message= "Severe error: libtarantool does not have these names: ";
    error_message.append(ldbms_return_string);
    error_message.append(". Close ocelotgui, restart with a better libtarantool.so.");
    msgbox.setText(error_message);
    msgbox.exec();
    delete lmysql;
    return 1;
  }
  if (is_libtarantool_loaded == 0)
  {
    /* Todo: QMessageBox should have a parent, use "= new" */
    QMessageBox msgbox;
    QString error_message;
    error_message= "Error, libtarantool was not found or a loading error occurred. Message was: ";
    error_message.append(ldbms_return_string);
    msgbox.setText(error_message);
    msgbox.exec();
    delete lmysql;
    return 1;
  }
  /* Todo: this should have been done already; we must be calling from the wrong place. */
  copy_connect_strings_to_utf8();

  /* CONNECT. URI = port, host:port, or username:password@host:port */

  /* tnt[] is static global */
  tnt[connection_number]= lmysql->ldbms_tnt_net(NULL);
  if (ocelot_ca.opt_connect_timeout > 0)
  {
    struct timeval tvp;
    tvp.tv_sec= ocelot_ca.opt_connect_timeout;
    tvp.tv_usec= 0;
    lmysql->ldbms_tnt_set(tnt[connection_number], (int)TNT_OPT_TMOUT_CONNECT, (char*)&tvp);
  }
  {
    /* Todo:
       I was setting TNT_OPT_SEND_BUF and TNT_OPT_RECV_BUF to (char*)ocelot_ca.net_buffer_length in
       ocelotgui.h. I said third arg is char*, so casting was goofy. The greater problem was that
       the default on startup is 16384 which is MySQL's default, not Tarantool's. The true solution
       is to change the default if --ocelot_dbms=tarantool, perhaps. But 0 turns buffering off, and
       I think that is convenient for sending or receiving images.
       Warning: ocelot_ca.net_buffer_length is long.
    */
    lmysql->ldbms_tnt_set(tnt[connection_number], TNT_OPT_SEND_BUF, 0);
    lmysql->ldbms_tnt_set(tnt[connection_number], TNT_OPT_RECV_BUF, 0);
  }
  sql_mode_ansi_quotes= true;        /* see comment = ansi_quotes */
  hparse_sql_mode_ansi_quotes= true; /* probably not necessary */
  {
    char connection_string[1024];
    char connection_port[128];
    char connection_host[128];
    char connection_password[128];
    char connection_user[128];
    if (port_maybe != "DEFAULT") strcpy(connection_port, port_maybe.toUtf8());
    else sprintf(connection_port, "%d", ocelot_ca.port);
    if (host_maybe != "DEFAULT") strcpy(connection_host, host_maybe.toUtf8());
    else strcpy(connection_host,ocelot_ca.host_as_utf8);
    if (password_maybe != "DEFAULT") strcpy(connection_password, password_maybe.toUtf8());
    else strcpy(connection_password,ocelot_ca.password_as_utf8);
    if (user_maybe != "DEFAULT") strcpy(connection_user, user_maybe.toUtf8());
    else strcpy(connection_user, ocelot_ca.user_as_utf8);
    strcpy(connection_string, "");
    /* guest has no password
       after connect() succeeds user = guest,
       after authenticate() succeeds user = arg
    */
    if (strcmp(connection_user, "guest") != 0)
    {
      strcat(connection_string, connection_user);
      if (strcmp(connection_password, "") != 0)
      {
        strcat(connection_string, ":");
        strcat(connection_string, connection_password);
      }
      strcat(connection_string, "@");
    }
    strcat(connection_string, connection_host);
    strcat(connection_string, ":");
    strcat(connection_string, connection_port);
    lmysql->ldbms_tnt_set(tnt[connection_number], (int)TNT_OPT_URI, connection_string);
    if (lmysql->ldbms_tnt_connect(tnt[connection_number]) < 0) {
      tarantool_errno[connection_number]= 9999;
      strcpy(tarantool_errmsg, "Connection refused for ");
      strcat(tarantool_errmsg, connection_string);
      enum tnt_error j= lmysql->ldbms_tnt_error(tnt[connection_number]);
      if ((j >= 0) && (j < TNT_LAST))
      {
        strcat(tarantool_errmsg, " ");
        strcat(tarantool_errmsg, lmysql->ldbms_tnt_strerror(tnt[connection_number]));
      }
    }
    else
    {
      tarantool_errno[connection_number]= 0;
      strcpy(tarantool_errmsg, er_strings[er_off + ER_OK]);
    }
  }
  if (tarantool_errno[connection_number] != 0)
  {
    /* Kludge so put_diagnostics_in_result won't crash */
    connections_dbms[connection_number]= DBMS_TARANTOOL;
    put_diagnostics_in_result(connection_number, DIAGNOSTIC_0);
    if (connection_number == MYSQL_MAIN_CONNECTION)
    {
      make_and_append_message_in_result(ER_FAILED_TO_CONNECT_TO_TARANTOOL, 0, (char*)"");
    }
    else
    {
      make_and_append_message_in_result(ER_FAILED_TO_CONNECT_TO_TARANTOOL_FOR_SERVER, 0, (char*)"");
    }
    return 1;
  }
  make_and_put_message_in_result(ER_OK, 0, (char*)"");
  connect_init(connection_number);
  /* Todo: Consider saying select version(); instead of an internal query for box.info.version. */
  /* Todo: I gave up on memtx_use_mvcc_engine. Revive when I see how to make remote transactions work. */
  QString session_id, version;
  {
    char query_string[1024];
    sprintf(query_string, "return box.session.id()");
    session_id= tarantool_internal_query(query_string, connection_number);
    sprintf(query_string, "return box.info.version");
    version= tarantool_internal_query(query_string, connection_number);
    int index_of_hyphen= version.indexOf("-");
    if (index_of_hyphen > 0) version= version.left(index_of_hyphen);
    //tarantool_memtx_use_mvcc_engine= 0;
    //if (version >= "2.6")
    //{
    //  sprintf(query_string, "return box.cfg.memtx_use_mvcc_engine and 1 or 0");
    //  tarantool_memtx_use_mvcc_engine= tarantool_internal_query(query_string, connection_number).toInt();
    //}
  }
  /* Old Tarantool (before 2.1.2?) need box.sql.execute not box.execute */
  /* If box.execute() fails and box.sql.execute() fails, SQL is impossible. */
  if (connection_number == 0)
  {
    tarantool_execute_sql("select 5;", strlen("select 5;"), connection_number);
    if (tarantool_errno[0] != 0)
    {
      strcpy(tarantool_box_execute, "No SQL");
      /* Todo: how to clear the error? */
    }
  }

  if (connection_number == MYSQL_REMOTE_CONNECTION)
  {
    /* The caller should save the connection for the server id. */
    return 0;
  }

  /*
    Todo: This overrides any earlier PROMPT statements by user.
    Probably what we want is a flag: "if user did PROMPT, don't override it."
    Or we want PROMPT statement to change ocelot_prompt.
  */
  statement_edit_widget->prompt_default= ocelot_prompt;
  statement_edit_widget->prompt_as_input_by_user= statement_edit_widget->prompt_default;
  statement_edit_widget->dbms_version= version;
  statement_edit_widget->dbms_database= ocelot_database;
  statement_edit_widget->dbms_port= QString::number(ocelot_ca.port);
  statement_edit_widget->dbms_current_user= ocelot_user;
  statement_edit_widget->dbms_current_user_without_host= ocelot_user;
  statement_edit_widget->dbms_connection_id= session_id.toInt();
  statement_edit_widget->dbms_host= ocelot_host;
  //connect_init(connection_number);
  tarantool_initialize(connection_number);
  if (connection_number == 0)
  {
    set_dbms_version_mask("tarantool-" + version, connection_number);
#if (OCELOT_EXPLORER == 1)
    initialize_widget_explorer_after_connect();
#endif
  }
  return 0;
}
#endif

#ifdef DBMS_TARANTOOL
/*
  For some internal (not user-generated) requests
  returns tarantool_errno[connection_number]
  returns tarantool_errmsg[connection_number]
  if first word is "return" and no error, return a scalar
  the scalar must be MP_STR or MP_UINT or MP_INT, otherwise return = ""
  The preferred way is with tnt_eval but it will fail if user lacks privilege.
  The second-choice way is with tnt_execute but it might fail in a future Tarantool version.

*/
QString MainWindow::tarantool_internal_query(char *query,
                                            int connection_number)
{
  QString returned_string;
  struct tnt_stream *empty;
  empty= lmysql->ldbms_tnt_object(NULL);
  lmysql->ldbms_tnt_object_add_array(empty, 0);
  lmysql->ldbms_tnt_eval(tnt[connection_number], query, strlen(query), empty);
  tarantool_flush_and_save_reply(connection_number);
  if (tarantool_errno[connection_number] != 0)
  {
    empty= lmysql->ldbms_tnt_object(NULL);
    QString co= query;
    if (co.contains("''")) co= co.replace("'", "''");
    co= "select lua('" + co;
    if (strncmp(query, "return ", 7) != 0) co= co + " return 0";
    co= co + "');";
    QByteArray ba= co.toUtf8();
    char *tmp= ba.data();
    lmysql->ldbms_tnt_object_add_array(empty, 0);
    lmysql->ldbms_tnt_execute(tnt[connection_number], tmp, strlen(tmp), empty);
    tarantool_flush_and_save_reply(connection_number);
  }

  if ((tarantool_errno[connection_number] == 0)
   && (strncmp(query, "return ", 7) == 0))
  {
    uint32_t value_length;
    const char *value;
    char value_as_string[320]; /* must be big enough for any sprintf() result */
    char field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_p);
    /* if field_type != MP_ARRAY that's an error but we just return "" */
    if (field_type == MP_ARRAY)
    {
      /* The first item will be dd 00 00 01 i.e. "array of length = 1". Or, nowadays: 91,91. */
      long unsigned int result;
      result= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_p);
      if (result == 1)
        field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_p);
      if (field_type == MP_ARRAY)
      {
        result= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_p);
        if (result == 1)
          field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_p);
      }
    }
    if (field_type == MP_STR)
    {
      value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_p, &value_length);
      returned_string= QString::fromUtf8(value, value_length);
    }
    else if (field_type == MP_UINT)
    {
      uint64_t uint_value= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_p);
      long long unsigned int llu= uint_value;
      value_length= sprintf(value_as_string, "%llu", llu);
      returned_string= QString::fromUtf8(value_as_string);
    }
    else if (field_type == MP_INT)
    {
      int64_t int_value= lmysql->ldbms_mp_decode_int(&tarantool_tnt_reply_data_p);
      long long int lli= int_value;
      value_length= sprintf(value_as_string, "%lld", lli);
      returned_string= QString::fromUtf8(value_as_string);
    }
  }
  else returned_string= "";
  lmysql->ldbms_tnt_reply_free(&tarantool_tnt_reply);
  return returned_string;
}
#endif

#ifdef DBMS_TARANTOOL
/*
  Call tarantool_initialize() from connect_tarantool() if successful.
  The main task is to create a function that executes SQL statements or Lua requests.
  There might be multiple things to execute between START TRANSACTION and COMMIT|ROLLBACK
  because we defer in-transaction statements, then run them all within a single function.
  If there's only one statement, we don't call ocelot_sqle, we directly call box.execute or eval
  Luckily there won't be multiple results for any single SQL statement or Lua chunk.
  Input = a string containing [type][size];[sql-statement-or-Lua-chunk] repeated.
          type is 'S' = SQL or 'L' = Lua
          size is a string of an integer that ends with ;
          sql-statement is something you can pass to box.execute
          lua-chunk is something you can pass to dostring
  Output = a table or multiple tables
           results returned from box.execute or dostring, one for each statement
           If there was an error, then the result will be "Error: [number] [message]"
             (Error messages will be added to a big messages which we'll return once)
           If there was no return, then the result will be "nil"
           If there are multiple result sets, we will produce a tabbed widget later.
  Todo: version check. we pick it up during connect with "return box.info.version"
  Todo: query_return is unused.
        We should check it because if you can't create the functions, you can't do transactions.

  Example: 'S37;CREATE TABLE MJ (s1 INT PRIMARY KEY);S37;CREATE TABLE MJ (s1 INT PRIMARY KEY);'
  You could invoke ocelot_sqle with conn:eval([[return0 = ocelot_sqle(stuff)]])
  but I think conn:call() i.e. I am happier with tnt_request_call.
  Todo: I fear that query_return might have nothing even if there is an error.
  Todo: Global! So This assumes that all clients use box.execute() or all use box.sql.execute().
*/
void MainWindow::tarantool_initialize(int connection_number)
{
  if (strcmp(tarantool_box_execute, "No SQL") == 0) return;
  QString query_return;
  const char *error_string=
        "function ocelot_sqle_error (x)"
        "  local e = ''"
        "  if type(x) == 'string' then"
        "    e = 'Error: 0 ' .. x"
        "  else"
        "    if type(x) == 'cdata' then"
        "      e = 'Error: ' .. x:unpack().code .. ' ' .. x:unpack().message"
        "    else"
        "      e = 'Error: 0 unknown'"
        "    end"
        "  end"
        "  return e"
        "  end";
  query_return= tarantool_internal_query((char*)error_string, connection_number);

  const char *ex_string_1=
        "function ocelot_sqle (input_statements)"
        "  local i = 1"
        "  local statement_number = 1"
        "  local j, original_i, size_string, size_int, statement, status, r_type"
        "  local returns = {}"
        "  local e = ''"
        "  while true do"
        "    r_type = string.sub(input_statements, i, i)"
        "    if r_type == nil then break end"
        "    i = i + 1"
        "    original_i = i"
        "    i, j = string.find(input_statements, ';', i)"
        "    if i == nil then break end"
        "    size_string = string.sub(input_statements, original_i, i - 1)"
        "    size_int = string.format('%d', size_string)"
        "    statement = string.sub(input_statements, j + 1, j + size_int)"
        "    if r_type == 'S' then status, returns[statement_number] = pcall(";
  const char *ex_string_2=
        ", statement) end"
        "    if r_type == 'L' then status, returns[statement_number] = pcall(dostring, statement) end"
        "    if status == false then"
        "      status, e = pcall(ocelot_sqle_error, returns[statement_number])"
        "      if status == false then e = 'Error: 0 unknown' end"
        "      returns[statement_number] = e"
        "    end"
        "    if returns[statement_number] == nil then returns[statement_number] = 'nil' end"
        "    i = j + 1 + size_int"
        "    statement_number = statement_number + 1"
        "  end"
        "  return unpack(returns)"
        "  end";

  char ex_string_4[2048]; /* actual current size = 1150 but allow for slight increase */
  strcpy(ex_string_4, ex_string_1);
  strcat(ex_string_4, tarantool_box_execute);
  strcat(ex_string_4, ex_string_2);
  query_return= tarantool_internal_query((char*)ex_string_4, connection_number);
}
#endif

#ifdef DBMS_TARANTOOL
/*
  tnt_flush() sends a request to the server.
  after every tnt_flush, save reply.
  TODO: KLUDGE: (I wonder many times have I used that word.)
        When I entered [[return box.schema.space.create('T8');]] I got
        error = unsupported Lua type 'function' but the space was
        created. There are github.com/tarantool issues that mention
        this message. I don't understand them. So I'll cancel the error.
*/

void MainWindow::tarantool_flush_and_save_reply(unsigned int connection_number)
{
  lmysql->ldbms_tnt_flush(tnt[connection_number]);

  lmysql->ldbms_tnt_reply_init(&tarantool_tnt_reply);
  int read_result= tnt[connection_number]->read_reply(tnt[connection_number], &tarantool_tnt_reply);

  /*
    Because of a Tarantool bug "Result code is sometimes 0 when there is an error"
    I cannot trust reply.code, so decide it is an error if error message is set.
    Also I notice that reply.data == NULL, which probably is the cause of later trouble.
    Todo: But this is not a fix. Follow issue#4177 and change this when it is fixed. (Hmm. It is now fixed.)
    Todo: ocelotgui will crash if this kludge is not present. Make it more robust, eh?
  */
  if (tarantool_tnt_reply.code == 0)
  {
    if (tarantool_tnt_reply.error != NULL) tarantool_tnt_reply.code= 3;
  }

  tarantool_tnt_reply_data_p= tarantool_tnt_reply.data;

  /* Todo: check: should this be != 0 or should it be == -1? */
  if (read_result != 0)
  {
    tarantool_errno[connection_number]= 1;
    sprintf(tarantool_errmsg, "read_result=%d", read_result);
    return;
  }
  tarantool_errno[connection_number]= tarantool_tnt_reply.code;

  if (tarantool_tnt_reply.code != 0)
  {
    char *x1= (char*)tarantool_tnt_reply.error;
    char *x2= (char*)tarantool_errmsg;
    while (x1 < tarantool_tnt_reply.error_end) *(x2++)=*(x1++);
    *x2= '\0';
  }
  else strcpy(tarantool_errmsg, er_strings[er_off + ER_OK]);
  if (strcmp(tarantool_errmsg, "unsupported Lua type 'function'") == 0)
  {
    tarantool_errno[connection_number]= 0;
    strcpy(tarantool_errmsg, er_strings[er_off + ER_OK]);
  }
}

/*
  Return statement type = first keyword = TOKEN_KEYWORD_SELECT etc.
  Probably hparse has already found the facts in a better way but
  perhaps you haven't called hparse.
  Currently this is only being used to guess whether it's Lua.
*/
/*
  DESPERATION -- for tarantool_real_query() ...
  We are passing dbms_query + dbms_query_len, which might not be the
  same as a subset of main_token globals. We just need to know what
  are the first two tokens, we're looking for BEGIN, COMMIT, ROLLBACK
  but not ROLLBACK TO, LUA '...'. We have to skip comments, and we
  assume that there aren't more than 98 comments at statement start.
  If first word is not an SQL statement-start word, or LUA.
  turn on the Lua flag.
  ALSO: make_statement_ready_to_send() happened recently, and we could
        have used it to know the first words, would have been faster
  ALSO: hparse_f_multi_block() turned on TOKEN_FLAG_IS_LUA, and we
        could have used it to know if it's Lua, would have been faster
  TODO: return error if too many initial comments, or retry with more
  TODO: if we get WITH, we'd like to know if it's SELECT|INSERT|UPDATE
        (which requires going ahead many more words)
  Warn: only works for Tarantool at the moment, e.g.
        wouldn't recognize MySQL/MariaDB comments starting with #
  TODO: Now tarantool_real_query has alltext, you should use that!
*/
QString MainWindow::get_statement_type(QString q_dbms_query, int *statement_type)
{
  log("get_statement_type", 15);
  int token_offsets[100]; /* Surely a single assignable target can't have more */
  int token_lengths[100];
  tokenize(q_dbms_query.data(),
           q_dbms_query.size(),
           &token_lengths[0], &token_offsets[0], 100 - 1,
          (QChar*)"33333", 2, "", 1);
  int word_number= 0;
  QString word0= "", word1= "", word2= "";
  for (int i= 0; i < 100; ++i)
  {
    if (token_lengths[i] == 0) break;
    if ((q_dbms_query.mid(token_offsets[i], 2) == "/*")
     || (q_dbms_query.mid(token_offsets[i], 2) == "--"))
      continue;
    if (word_number == 0)
    {
      word0= q_dbms_query.mid(token_offsets[i], token_lengths[i]);
    }
    if (word_number == 1)
    {
      word1= q_dbms_query.mid(token_offsets[i], token_lengths[i]);
    }
    if (word_number == 2)
    {
      word2= q_dbms_query.mid(token_offsets[i], token_lengths[i]);
      break;
    }
    ++word_number;
  }
  *statement_type= get_statement_type_low(word0, word1, word2);
  return word1;
}

/* TODO: Get fussier about what you'll accept is (Tarantool) SQL. */
int MainWindow::get_statement_type_low(QString word0, QString word1, QString word2)
{
  word0= word0.toUpper();

  int statement_type= TOKEN_KEYWORD_DO_LUA;
  if (word0 == "ALTER")
  {
    if (QString::compare(word1, "TABLE", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_ALTER;
  }
  else if (word0 == "ANALYZE")
  {
    if ((word1 == ";") || (word1 == "")) statement_type= TOKEN_KEYWORD_ANALYZE;
    if (word1 > "")
    {
      QChar w1c1= word1.at(0);
      if ((w1c1.isLetter() == true)
       || (w1c1 == '\"'))
        statement_type= TOKEN_KEYWORD_ANALYZE;
    }
  }
  else if (word0 == "COMMIT")
  {
    if ((word1 == ";") || (word1 == "")) statement_type= TOKEN_KEYWORD_COMMIT;
  }
  else if (word0 == "CREATE")
  {
    if ((QString::compare(word1, "UNIQUE", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "INDEX", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "TABLE", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "TRIGGER", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "VIEW", Qt::CaseInsensitive) == 0))
      statement_type= TOKEN_KEYWORD_CREATE;
  }
  else if (word0 == "DELETE")
  {
    if (QString::compare(word1, "FROM", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_DELETE;
  }
  else if (word0 == "DROP")
  {
    if ((QString::compare(word1, "INDEX", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "TABLE", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "TRIGGER", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "VIEW", Qt::CaseInsensitive) == 0))
      statement_type= TOKEN_KEYWORD_DROP;
  }
  else if (word0 == "EXPLAIN") { statement_type= TOKEN_KEYWORD_EXPLAIN; }
  else if (word0 == "INSERT")
  {
    if ((QString::compare(word1, "INTO", Qt::CaseInsensitive) == 0)
     || (QString::compare(word1, "OR", Qt::CaseInsensitive) == 0))
      statement_type= TOKEN_KEYWORD_INSERT;
  }
  else if (word0 == "LUA") { statement_type= TOKEN_KEYWORD_LUA; }
  else if (word0 == "PRAGMA") { statement_type= TOKEN_KEYWORD_PRAGMA; }
  else if (word0 == "RELEASE")
  {
    if (QString::compare(word1, "SAVEPOINT", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_RELEASE;
  }
  else if (word0 == "REPLACE")
  {
    if (QString::compare(word1, "INTO", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_REPLACE;
  }
  else if (word0 == "ROLLBACK")
  {
    if (QString::compare(word1, "TO", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_ROLLBACK_IN_ROLLBACK_TO;
    else
    {
      if ((word1 == ";") || (word1 == "")) statement_type= TOKEN_KEYWORD_ROLLBACK;
    }
  }
  else if (word0 == "SAVEPOINT")
  {
    if (word1 > "")
    {
      QChar w1c1= word1.at(0);
      if ((w1c1.isLetter() == true)
       || (w1c1 == '\"'))
        statement_type= TOKEN_KEYWORD_SAVEPOINT;
    }
  }
  else if (word0 == "SELECT") { statement_type= TOKEN_KEYWORD_SELECT; }
  else if (word0 == "SET")
  {
    if (QString::compare(word1, "SESSION", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_SET;
  }
  else if (word0 == "START")
  {
    if (strcmp(tarantool_box_execute, "No SQL") != 0)
    {
      if (QString::compare(word1, "TRANSACTION", Qt::CaseInsensitive) == 0)
        statement_type= TOKEN_KEYWORD_START;
    }
  }
  else if (word0 == "TRUNCATE")
  {
    if (QString::compare(word1, "TABLE", Qt::CaseInsensitive) == 0)
      statement_type= TOKEN_KEYWORD_TRUNCATE;
  }
  else if (word0 == "UPDATE")
  {
    if (word1 > "")
    {
      QChar w1c1= word1.at(0);
      if ((w1c1.isLetter() == true)
       || (w1c1 == '\"'))
        statement_type= TOKEN_KEYWORD_UPDATE;
    }
  }
  else if (word0 == "VALUES")
  {
    if (word1 == "(") statement_type= TOKEN_KEYWORD_VALUES;
  }
  else if (word0 == "WITH")
  {
    if (QString::compare(word1, "RECURSIVE", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_WITH;
    if (QString::compare(word2, "AS", Qt::CaseInsensitive) == 0) statement_type= TOKEN_KEYWORD_WITH;
  }
  else { statement_type= TOKEN_KEYWORD_DO_LUA; }
  return statement_type;
}

/* An equivalent to mysql_real_query(). NB: this might be called from a non-main thread */
/*
   Todo: we shouldn't be calling tparse_f_program() yet again!
         AND WE DON'T NEED TO. NOW WE PASS ALLTEXT.
   Todo: I succeeded in making this work
           lua 'return box.space.t:select()';
         but:
           should use [[...]] or escapes
           should not depend later on looking at TOKEN_KEYWORD_LUA
   Because Tarantool-style transactions require us to send all requests
   as a single send, we have to combine them -- which is sad because we
   spent time earlier in splitting them apart. We use a QStringList.
   Todo: We depend on commit|rollback to end a transaction but they might
         be inside a Lua function.
*/
/*
  Re dbms_query and alltext
  We pass dbms_query = the string to execute, which might have been massaged by
  get_ready_to_send(). It might not be the first query in alltext.
  We pass alltext = the complete text, not massaged, which might contain multiple
  statements (and if dbms_query is not the first statement then passed_main_token_number > 0).
  Mainly we use it because it has already gone through the recognizer.
  Todo: don't parse again if you don't need to!
  Todo: use alltext rather than dbms_query sometimes!
  Todo: we could be using const a lot more often!
  Todo: You aren't actually using table_name or column_name QStrings!
        You need them in tarantool_scan_field_names!
*/
/*
      In here we should be setting the table name and the
      field names, if it is SELECT -- Tarantool doesn't tell us.
      Currently generated UPDATEs lack the right information,
      tarantool_scan_field_names generates the wrong table name and
      the wrong literal (seems to assume it's varchar) and doesn't have
      an equivalent for org_name + org_table. We could figure this out by looking
      again at the statement -- make sure it's SELECT etc.
      See inside this function where we calculate offset_of_space_name.
      Make sure main_token list is still valid, make sure it's SELECT (not missing WITH),
      calculate for both SQL table and NoSQL space, make sure it's not
      in a transaction so it will really produce a grid result.
      Put it in global or (somehow) add to the result set information.
      Tarantool has revised box.execute() but I still mostly follow the old way.
      ! You won't see TOKEN_REFTYPE_COLUMN if it is *
      ! dbms_query might be only the current query of a multi-query
        this is a shame because when you call action_execute_one_statement you have text
        see the comments REALL DUBIOUS twice in this function
      ! Do this for Lua too
*/
int MainWindow::tarantool_real_query(const char *dbms_query,
                                     unsigned long dbms_query_len,
                                     unsigned int connection_number,
                                     unsigned int passed_main_token_number,
                                     unsigned int passed_main_token_count_in_statement,
                                     const QString *alltext)
{
  log("tarantool_real_query start", 80);
  tarantool_errno[connection_number]= 10001;
  strcpy(tarantool_errmsg, "Unknown Tarantool Error");

  QString x_dbms_query;
  if (passed_main_token_number > 0)
  {
    x_dbms_query= *alltext;
  }
  else x_dbms_query= QString::fromUtf8(dbms_query, dbms_query_len);

  {
    unsigned int i;
    QString text= x_dbms_query;

    tarantool_table_name= ""; /* global within MainWindow */
    tarantool_column_name= ""; /* global within MainWindow */
    int parentheses_count= 0;
    int type;
    bool is_select_seen= false;
    bool is_comma= false;
    bool is_from_seen= false;
    for (i= passed_main_token_number; i < passed_main_token_count_in_statement; ++i)
    {
      if (main_token_lengths[i] == 0) break; /* This is impossible, is an assert better? */
      is_comma= false;
      type= main_token_types[i];
      if (main_token_types[i] == TOKEN_TYPE_OPERATOR)
      {
        QString o= text.mid(main_token_offsets[i], main_token_lengths[i]);
        if (o == "(") ++parentheses_count;
        if (o == ")") --parentheses_count;
        if (o == ",")
        {
          is_comma= true;
        }
      }
      if (parentheses_count != 0) continue;
      if (is_select_seen == false)
      {
        if (type == TOKEN_KEYWORD_WITH) continue;
        if ((type > TOKEN_KEYWORDS_START) && (type != TOKEN_KEYWORD_SELECT)) break;
        is_select_seen= true;
        continue;
      }
      if ((type == TOKEN_KEYWORD_FROM) || (is_comma == true))
      {
        /* Back up from "," or "from". Whatever precedes is either column or expression. */
        for (unsigned int j= i - 1; j > passed_main_token_number; --j)
        {
          int jtype= main_token_types[j];
          if ((type >= TOKEN_TYPE_COMMENT_WITH_SLASH) && (type <= TOKEN_TYPE_COMMENT_WITH_MINUS))
            continue;
          int jreftype= main_token_reftypes[j];
          if (jreftype == TOKEN_REFTYPE_ALIAS_OF_COLUMN)
          {
            --j;
            jtype= main_token_types[j];
            if (jtype == TOKEN_KEYWORD_AS)
            {
              --j;
            }
          }
          if (jreftype == TOKEN_REFTYPE_COLLATION)
          {
            --j;
            --j;
          }
          if (main_token_reftypes[j] == TOKEN_REFTYPE_COLUMN)
            tarantool_column_name= tarantool_column_name + ".!.!" + text.mid(main_token_offsets[j], main_token_lengths[j]);
          else
            tarantool_column_name= tarantool_column_name + ".!.!" + "";
          break;
        }
        if (type == TOKEN_KEYWORD_FROM) is_from_seen= true;
        continue;
      }
      if ((is_from_seen == true) && (main_token_reftypes[i] == TOKEN_REFTYPE_TABLE))
      {
        tarantool_table_name= text.mid(main_token_offsets[i], main_token_lengths[i]);
        break;
      }
    }
  }

  QString q_dbms_query= QString::fromUtf8(dbms_query, dbms_query_len);
  int statement_type;
  /* Todo: use x_dbms_query???? */
  QString word1= get_statement_type(q_dbms_query, &statement_type);
  int token_type= -1;
  //int result_row_count= 0; /* for everything except SELECT we ignore rows that are returned */

  {
    /* If it is LUA 'X'; we only want to pass X. */
    if (statement_type == TOKEN_KEYWORD_LUA) q_dbms_query= connect_stripper(word1, false);
    int statement_number= tarantool_statements_in_begin.size();

    if (statement_number > 0) q_dbms_query= q_dbms_query.append(" ");

    /* TEST!!!! If we survive removing these two lines, we can rethink SQL transactions. */
    /*          ... but we don't survive. */
    if ((tarantool_start_transaction_seen == false)
     && (statement_type != TOKEN_KEYWORD_START))
    {
      if ((statement_type != TOKEN_KEYWORD_LUA) && (statement_type != TOKEN_KEYWORD_DO_LUA))
      {
        /* SQL statement, not within transaction or start of transaction, direct box.execute call */
        tarantool_execute_sql(q_dbms_query.toUtf8(), q_dbms_query.toUtf8().length(), connection_number);
      }
      else
      {
        /* Lua chunk, not within transaction or start of transaction, direct eval */
        tarantool_execute_lua(q_dbms_query.toUtf8(), q_dbms_query.toUtf8().length(), connection_number);
      }
      return tarantool_errno[connection_number];
    }
  }
  if ((statement_type != TOKEN_KEYWORD_LUA) && (statement_type != TOKEN_KEYWORD_DO_LUA))
    tarantool_statements_in_begin.append(
                "S" +
                QString::number(q_dbms_query.toUtf8().length()) +
                ";" +
                q_dbms_query);
   else
    tarantool_statements_in_begin.append(
                "L" +
                QString::number(q_dbms_query.toUtf8().length()) +
                ";" +
                q_dbms_query);

  if (statement_type == TOKEN_KEYWORD_START)
  {
    tarantool_start_transaction_seen= true;
  }
  if ((statement_type == TOKEN_KEYWORD_COMMIT)
   || (statement_type == TOKEN_KEYWORD_ROLLBACK))
  {
    tarantool_start_transaction_seen= false;
  }
  if (tarantool_start_transaction_seen == true)
  {
    strcpy(tarantool_errmsg, er_strings[er_off + ER_8372]);
    tarantool_errno[connection_number]= ER_8372_INT;
    return tarantool_errno[connection_number];
  }
  if (hparse_f_is_nosql(q_dbms_query) == false)
  {
    QString s= "";
    QString s2;
    s2= "";
    while (tarantool_statements_in_begin.isEmpty() == false)
    {
      s= tarantool_statements_in_begin.at(0);
      s2.append(s);
      tarantool_statements_in_begin.removeAt(0);
    }
    /* Todo: reduce copying because some statements might be very long. */
    /* size of s2.toUtf8 not size of s2 is right but s2.size()*4 would work too */
    int dbms_query_len= s2.toUtf8().length();
    char *request_string= new char[dbms_query_len + 1];
    memcpy(request_string, s2.toUtf8(), dbms_query_len);
    struct tnt_stream *tuple= lmysql->ldbms_tnt_object(NULL);
    lmysql->ldbms_tnt_object_add_array(tuple, 1);
    lmysql->ldbms_tnt_object_add_str(tuple, request_string, dbms_query_len);
    lmysql->ldbms_tnt_call(tnt[connection_number], "ocelot_sqle", 11, tuple);
    tarantool_flush_and_save_reply(0);
    log("tarantool_real_query end", 80);
    return 0; /* Todo: in fact I suppose commit|rollback could fail, we should be passing it on */
  }
  /* If something is NoSQL, transactions don't work. */
  /* This section is rarely tested, I'm thinking of abandoning it. */
   /* It might be saved if I could push + pop main_tokens. */

  strcpy(tarantool_errmsg, "/* NOSQL */ is temporarily disabled");
  tarantool_errno[connection_number]= 8373;
  return tarantool_errno[connection_number];
  tarantool_select_nosql= true;
  //int hparse_statement_type=-1, clause_type=-1;
  //QString current_token, what_we_expect, what_we_got;

  //tparse_f_program(text); /* syntax check; get offset_of_identifier,statement_type, number_of_literals */
  if (hparse_errno > 0)
  {
    strcpy(tarantool_errmsg, hparse_errmsg);
    tarantool_errno[connection_number]= hparse_errno;
    return tarantool_errno[connection_number];
  }

  /* The number of literals in a statement must be what we'd insert etc. */
  int number_of_literals= 0;
  for (unsigned int i= passed_main_token_number; i < passed_main_token_number + passed_main_token_count_in_statement; ++i)
  {
    if (main_token_types[i] == TOKEN_TYPE_LITERAL)
    {
      ++number_of_literals;
    }
  }

  /* The first identifier in any of the statements must be the space name. */
  /* TODO: UNLESS hparse_statement_type == TOKEN_KEYWORD_SET! */
  /* TODO: This is another reason for having a table of reftypes, eh? */
  int offset_of_space_name= -1;
  for (unsigned int i= passed_main_token_number; i < passed_main_token_number + passed_main_token_count_in_statement; ++i)
  {
    if ((hparse_f_is_identifier(main_token_types[i]) == true)
     && (main_token_reftypes[i] == TOKEN_REFTYPE_TABLE))
    {
      offset_of_space_name= (int) i;
      break;
    }
  }

  /* todo: use x_dbms_query???? */
  QString text= q_dbms_query; /* REALLY DUBIOUS */

  int spaceno= -1;
  {
    int i= offset_of_space_name;
    QString space_name= text.mid(main_token_offsets[i], main_token_lengths[i]);
    spaceno= lmysql->ldbms_tnt_get_spaceno(tnt[connection_number], space_name.toUtf8(), main_token_lengths[i]);
    if (spaceno < 0)
    {
      /* Todo: figure out when this really needs to be called */
      lmysql->ldbms_tnt_reload_schema(tnt[connection_number]);
      spaceno= lmysql->ldbms_tnt_get_spaceno(tnt[connection_number], space_name.toUtf8(), main_token_lengths[i]);
      if (spaceno < 0)
      {
        QString s;
        s= "Could not find a space named ";
        s.append(space_name);
        tarantool_errno[connection_number]= 10003;
        strcpy(tarantool_errmsg, s.toUtf8());
        return tarantool_errno[connection_number];
      }
    }
  }

  /*
    The iterator type, if there is one, is the first comp-op
    in the statement. If there are more comp-ops, we've already
    checked that they're valid, during tparse_f_indexed_condition().
  */
  int iterator_type= TARANTOOL_BOX_INDEX_EQ;;
  for (unsigned int i= passed_main_token_number; i < passed_main_token_number + passed_main_token_count_in_statement; ++i)
  {
    if (main_token_types[i] == TOKEN_TYPE_OPERATOR)
    {
      QString token= text.mid(main_token_offsets[i], main_token_lengths[i]);
      if (token == "=") { iterator_type= TARANTOOL_BOX_INDEX_EQ; break; }
      if (token == "<") { iterator_type= TARANTOOL_BOX_INDEX_LT; break; }
      if (token == "<=") {iterator_type= TARANTOOL_BOX_INDEX_LE; break; }
      if (token == ">") { iterator_type= TARANTOOL_BOX_INDEX_GT; break; }
      if (token == ">=") { iterator_type= TARANTOOL_BOX_INDEX_GE; break; }
    }
  }

  /* DELETE + INSERT + REPLACE + (maybe?) SELECT require a tuple of values to insert or search */
  struct tnt_stream *tuple= NULL;
  //if (number_of_literals > 0)
  {
    tuple= lmysql->ldbms_tnt_object(NULL);
    lmysql->ldbms_tnt_object_add_array(tuple, number_of_literals);
    int number_of_adds= 0;
    for (unsigned int i= passed_main_token_number; i < passed_main_token_number + passed_main_token_count_in_statement; ++i)
    {
      token_type= main_token_types[i];
      if (token_type == TOKEN_TYPE_LITERAL)
      {
        /* Todo: figure out literal's exact type, and be sure. */
        assert(main_token_lengths[i] > 0);
        QString first_char= text.mid(main_token_offsets[i], 1);
        if (first_char == "'") token_type= TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE;
        else if (first_char < "#") token_type= TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE;
        else token_type= TOKEN_TYPE_LITERAL_WITH_DIGIT;
      }
      if ((token_type == TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE)
       || (token_type == TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE))
      {
        QString s;
        s= text.mid(main_token_offsets[i], main_token_lengths[i]);
        s= s.left(s.length() - 1);
        s= s.right(s.length() - 1);
        lmysql->ldbms_tnt_object_add_str(tuple, s.toUtf8(), s.length());
        ++number_of_adds;
      }
      if (token_type == TOKEN_TYPE_LITERAL_WITH_DIGIT)
      {
        /* todo: binary, float, double */
        QString s;
        s= text.mid(main_token_offsets[i], main_token_lengths[i]);
        lmysql->ldbms_tnt_object_add_int(tuple, s.toInt());
        ++number_of_adds;
      }
      if (token_type == TOKEN_KEYWORD_NULL)
      {
        lmysql->ldbms_tnt_object_add_nil(tuple);
        ++number_of_adds;
      }
    }
    assert(number_of_literals == number_of_adds);
    /* Todo: check whether we really need to say object_container_close. */
    lmysql->ldbms_tnt_object_container_close(tuple);
  }

  result_row_count= 0; /* for everything except SELECT we ignore rows that are returned */

  if (statement_type == TOKEN_KEYWORD_DELETE)
  {
    lmysql->ldbms_tnt_delete(tnt[connection_number], spaceno, 0, tuple);
    tarantool_flush_and_save_reply(connection_number);
    lmysql->ldbms_tnt_reply_free(&tarantool_tnt_reply);
    return tarantool_errno[connection_number];
  }

  if (statement_type == TOKEN_KEYWORD_INSERT)
  {
    if (lmysql->ldbms_tnt_insert(tnt[connection_number], spaceno, tuple) < 0)
    {
      tarantool_errno[connection_number]= 10007;
      strcpy(tarantool_errmsg, "Bug. tnt_insert() returned an error");
      return tarantool_errno[connection_number];
    }
    tarantool_flush_and_save_reply(connection_number);
    lmysql->ldbms_tnt_reply_free(&tarantool_tnt_reply);
    return tarantool_errno[connection_number];
  }

  if (statement_type == TOKEN_KEYWORD_REPLACE)
  {
    if (lmysql->ldbms_tnt_replace(tnt[connection_number], spaceno, tuple) < 0)
    {
      tarantool_errno[connection_number]= 10007;
      strcpy(tarantool_errmsg, "Bug. tnt_replace() returned an error");
      return tarantool_errno[connection_number];
    }
    tarantool_flush_and_save_reply(connection_number);
    lmysql->ldbms_tnt_reply_free(&tarantool_tnt_reply);
    return tarantool_errno[connection_number];
  }

  if (statement_type == TOKEN_KEYWORD_SELECT)
  {
    lmysql->ldbms_tnt_select(tnt[connection_number], spaceno, 0, UINT32_MAX, 0, iterator_type, tuple);
    tarantool_flush_and_save_reply(connection_number);
    if (tarantool_errno[connection_number] != 0) return tarantool_errno[connection_number];
    /* The return should be an array of arrays of scalars. */
    /* If there are no rows, then there are no fields, so we cannot put up a grid. */
    /* Todo: don't forget to free if there are zero rows. */
    {
      const char *tarantool_tnt_reply_data_copy= tarantool_tnt_reply_data_p; /* push */
//      unsigned long r= tarantool_num_rows(connection_number);
      tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy; /* pop */
//      if (r == 0)
//      {
//        strcpy(tarantool_errmsg, "Zero rows.");
//        tarantool_errno[connection_number]= 10027;
//      }
    }

    return tarantool_errno[connection_number];
  }

  return tarantool_errno[connection_number];
}

/*
  tarantool_tnt_reply_data_p has results from all statements in the transaction.
  It starts with a count of the number of statements, then something for each result.
  Signatures for SQL statements:
    signature_0 = 0x81, 0xa9, "row_count", n i.e. 1-item map as happens for most ddl + dml
    signature_1 = 0x82, 0xa8, "metadata" i.e. 2-item map as happens for select
    0xd9, "... error message ..." i.e. string as happens for errors (we check for any string signal)
  But tarantool_tnt_reply.error always has 0 because that is the result of "return ...".
  So, for each statement:
    If it is "row_count" then add diagnostic "ok, nn rows"
    If it is "metadata" then make a result-set addition, and add diagnostic "ok, nn rows"
    If it is error message then add diagnostic "error, " + error message
  If there is more than one result set, add tab.
  The final result is what determines whether you display tarantool_error or not.
  I don't think we can guarantee 1-to-1 correspondence between statements and results.
  Todo: you still need to check what NoSQL requests deliver.
  Todo: single statements might go directly, and that would be a different signature. ?? but it works.
  Todo: some simple memcmps would accomplish nearly the same effect. but signature check should be strict
  Todo: there might be more result sets and error messages, maybe restart from tarantool_result_set.data
  Todo: too much code repetition of "is it uint or int" followed by decode of uint or uint, for messages
  Todo: 0xd9 only should be interpreted as an error if it's preceded by start transaction
  If and only if you see a result set that is not at start, change tarantool_tnt_reply_data_p.
*/
/*
  For tnt_execute(query) of SQL, over the wire we have metadata and then data. The tarantool-c folks
  decided to split them so that struct tnt_reply has a data component and a metadata component,
  but not if tnt_call(box.execute(query)) or (I guess) tnt_eval('box.execute(query)').
  We try to handle both.
*/

int MainWindow::tarantool_get_result_set(int connection_number, int desired_result_set_number)
{
  long int number_of_results;
  const char *tarantool_tnt_reply_data_copy= tarantool_tnt_reply.data;
  if (tarantool_tnt_reply_data_copy == NULL) return 0; /* Actually this shouldn't happen, must be an error */

  if (tarantool_is_result_count(tarantool_tnt_reply_data_copy))
    number_of_results= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy);
  else
    number_of_results= 1;
  int this_result_set_number= 0;
  {
    for (int i= 0; i < number_of_results; ++i)
    {
      int tmp_result_type;
      tarantool_get_result_type(connection_number, tarantool_tnt_reply_data_copy, &tmp_result_type);
      if ((tmp_result_type == RESULT_TYPE_2)
       || (tmp_result_type == RESULT_TYPE_4)
       || (tmp_result_type == RESULT_TYPE_5))
      {
        if (this_result_set_number == desired_result_set_number)
        {
          tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy;
          return 1;
        }
        ++this_result_set_number;
      }
      lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);
    }
  }
  return 0;
}

QString MainWindow::tarantool_get_messages(int connection_number)
{
  QString messages= "";
  char field_type;
  long int number_of_results;
  /* todo: this might not be good enough, it assumes failed statements make 0, not guaranteed */
  /* !! IF IT ASSUMES WRONG, YOU COULD CRASH! */
  if (tarantool_tnt_reply.data == 0)
  {
    if (strcmp(tarantool_errmsg, "OK") != 0)
    {
      messages= er_strings[er_off + ER_ERROR];
      messages.append(". ");
    }
    messages.append(tarantool_errmsg);
    return messages;
  }
  const char *tarantool_tnt_reply_data_copy= tarantool_tnt_reply.data;

  if (tarantool_errno[connection_number] == 0)
  {
    messages= er_strings[er_off + ER_OK];
    messages.append(" ");
  }
  else
  {
    messages= er_strings[er_off + ER_ERROR];
    messages.append(". ");
    messages.append(tarantool_errmsg);
  }

  /* Don't look for messages if deferred because the search itself might cause an error. */
  /* Todo:  This line used to contain "connections_dbms[0]= DBMS_TARANTOOL", make sure that was an error. */
  if ((connections_dbms[0] == DBMS_TARANTOOL)
   && (tarantool_errno[connection_number] == ER_8372_INT))
    return messages;

  if (tarantool_is_result_count(tarantool_tnt_reply_data_copy))
    number_of_results= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy);
  else
    number_of_results= 1;

  {
    for (int i= 0; i < number_of_results; ++i)
    {
      int sig;
      tarantool_get_result_type(connection_number, tarantool_tnt_reply_data_copy, &sig);
      if (sig == RESULT_TYPE_6)
      {
        char value_as_string[16];
        const char *tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data_copy + 11;
        field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
        if (field_type == MP_UINT) /* anything other than MP_UINT would be a surprise */
        {
          uint64_t uint_value= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy_copy);
          long long unsigned int llu= uint_value;
          sprintf(value_as_string, "%llu", llu);
        }
        else if (field_type == MP_INT)
        {
          int64_t int_value= lmysql->ldbms_mp_decode_int(&tarantool_tnt_reply_data_copy_copy);
          long long int lli= int_value;
          sprintf(value_as_string, "%lld", lli);
        }
        messages= messages + " " + value_as_string + " rows affected";
      }
      if (sig == RESULT_TYPE_5)
      {
        messages.append(" ");
        messages.append(QString::number(tarantool_row_count[connection_number]));
        messages= messages + " rows selected";
      }
      if (sig == RESULT_TYPE_7)
      {
        const char *tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data_copy;
        const char *value;
        uint32_t value_length;
        value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy_copy, &value_length);
        char *error_string= new char[value_length + 1];
        memcpy(error_string, value, value_length);
        *(error_string + value_length)= '\0';
        messages= messages + " " + error_string;
        delete [] error_string;
      }
      lmysql->ldbms_mp_next(&tarantool_tnt_reply_data_copy);
    }
  }
  return messages;
}

/*
  Signature of result count = (array) followed by (array), as first bytes in what is returned
  Or: (array)(map) in which case the map is almost certainly "row_count"
  This happens for a transaction, in which case the number of results will always be > 1.
  This happens for a certain type of Lua request, in which case the number of results will always be 1.
  Do not be fooled by array+array from tnt_execute, which can be distinguished by checking if .metadata != 0
  If return == false, then assume the number of results is 1.
*/
bool MainWindow::tarantool_is_result_count(const char *tarantool_tnt_reply_data_copy)
{
  if (tarantool_tnt_reply_data_copy == NULL) return false; /* actually this should never happen, there is an error somewhere */
  if (tarantool_tnt_reply.metadata != 0) return false;
  const char *tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data_copy;
  char field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
  if (field_type != MP_ARRAY) return false;
  lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy_copy);
  field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
  if ((field_type == MP_ARRAY) || (field_type == MP_MAP)) return true;
  return false;
}


/* See comments preceding tarantool_get_result_set() */
/*
  Signatures for SQL statements:

    (map-2)(str-8)"metadata"(array)     RESULT_TYPE_5 i.e. 2-item map as happens for select

  Signatures for Lua requests:
    (array)(array) i.e. row+field count TOKEN_KEYWORD e.g. from "return box.space.T:select()"
    array signal, value e.g. from "return box.space.T:insert{1}"
    scalar value, e.g. from "return 5"   but this could conflict with RESULT_TYPE_7, rarely
    TODO: what happened to connection_number?
*/
const char * MainWindow::tarantool_get_result_type(
        int connection_number,
        const char *tarantool_tnt_reply_data_copy,
        int *result_type)
{
  const char *tarantool_tnt_reply_data_p_saved= tarantool_tnt_reply_data_p; /* push */
  long unsigned int result_row_count;
  tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy;
  tarantool_result_set_init(connection_number, &result_row_count, result_type);
  tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_p_saved; /* pop */
  return tarantool_tnt_reply_data_p_saved;

  /* EVERYTHING AFTER THIS IS CANCELLED */

  if ((tarantool_tnt_reply_data_p == NULL)
   || (tarantool_tnt_reply.data_end == NULL)
   || (tarantool_tnt_reply_data_copy == NULL))
  {
    *result_type= 0;
    return tarantool_tnt_reply_data_copy;
  }

  const char *tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data_copy;
  int array_size;
  char field_type;
  const char *value;
  uint32_t value_length;


  tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data_copy;
  field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
  if (field_type == MP_MAP)
  {
    array_size= lmysql->ldbms_mp_decode_map(&tarantool_tnt_reply_data_copy_copy);
    if (array_size == 2)
    {
      field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
      if (field_type == MP_STR)
      {
        value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy_copy, &value_length);
        if (value_length == 8)
        {
          if (memcmp(value, "metadata", 8) == 0)
          {
            field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
            if (field_type == MP_ARRAY)
            {
              *result_type= RESULT_TYPE_5;
              const char *x= tarantool_tnt_reply_data_copy;
              lmysql->ldbms_mp_decode_map(&x);
              lmysql->ldbms_mp_next(&x); /* skip "metadata" */
              lmysql->ldbms_mp_next(&x);
              lmysql->ldbms_mp_next(&x); /* skip "rows" so we're pointing to row count */
              return x;
            }
          }
        }
      }
    }
  }


  /* Still to come: (array)(value) */
  /* Still to come: value */
  *result_type= 0;
  return tarantool_tnt_reply_data_copy;
}

/*
  ? This might be superseded by above functions. ... Well, no it wasn't.
  We call this to get basic information about a Tarantool return;
  if it is a result set we get type + row count + return pointer to
  the first row.
  TODO: There might be multiple result sets, for example if there were
        multiple selects inside begin ... commit|rollback. We only look
        at the first. What we should be doing is: pass "selection number"
        and skip till we get to it. (Update: we seem to be doing that now)
  Todo: The calculation of data_length might be buggy.
  Todo: It might be nice to know what statement caused the result, although
        the signature of "select ..." won't look different from box.execute("select ...").
  Todo: return box.info().version returns 81 1 1 (fixmap, 1) which we do not recognize
  What is in tarantool_tnt_reply_data_p?
  LUA '"a"'         ... dd 0 0 0 1 a1 61
  LUA '15'          ... dd 0 0 0 1 f
  LUA 'm = 1'       ... dd 0 0 0 0
  LUA '...select()' ... dd 0 0 0 1 93 92  (93 is row count, 92 is field count)
  LUA '1,2,3'       ... dd 0 0 0 3 1  2  3
  SELECT is like LUA '...select()'
  SELECT / * NOSQL * /  dd 0 0 0 4 92 1 a5 68 65 (0 0 0 4 is row count)
  (dd is fixarray-32, 93 is fixarray)
  (the NOSQL option uses tarantool_tnt_select rather than eval)
  So return:
  0 == there is no result set because we don't understand ... error?
  1 == there is no result set because we start with fixarray-32 == 0
       or we get dd 0 0 0 1 c0 (nil)
  2 == array-32 == field count, then fields. so assume row_count == 1
  3 == array-32 == 1, array-x = row count, array-x == field count
  4 == array-32 == row count, then array-x == field count
  5 == same as 3, but first row is 0xa1 0x08 then column names. Or .metadata != 0
  6 == (map-1)(str-9)"row_count"(uint) i.e. 1-item map as happens for most ddl + dml
  7 == (str)"Error: ..." i.e. string as happens for errors in transactions
  7 == (str)"nil" etc. but we return 7 anyway just to get over this hump. It will be in the error line.
  Beware, though, because (array) at the start can be taken as #-of-results
*/

const char *MainWindow::tarantool_result_set_init(
        int connection_number,
        long unsigned int *result_row_count,
        int *result_set_type)
{
  log("tarantool_result_set_init start", 80);
  const char *tarantool_tnt_reply_data= tarantool_tnt_reply_data_p; /* not a push */
  char field_type;
  long unsigned int r= 0;
  //unsigned int data_length;

  if ((tarantool_tnt_reply.metadata != 0) && (tarantool_tnt_reply_data_p != 0))
  {
    if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_p) == MP_ARRAY)
    {
      /* We are looking at an array but it is column count not row count */
      r= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
      *result_set_type= RESULT_TYPE_5;
      goto return_point;
    }
  }

  if ((tarantool_tnt_reply_data_p == NULL)
   || (tarantool_tnt_reply.data_end == NULL))
    goto erret;
  {
    const char *tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data;
    int array_size;
    const char *value;
    uint32_t value_length;
    field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
    if (field_type == MP_MAP)
    {
      array_size= lmysql->ldbms_mp_decode_map(&tarantool_tnt_reply_data_copy_copy);
      if (array_size == 2)
      {
        value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy_copy, &value_length);
        if (value_length == 17)
        {
          if (memcmp(value, "autoincrement_ids", 17) == 0)
          {
            field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
            if (field_type != MP_ARRAY) goto erret;
            int autoincrement_id_count= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy_copy);
            for (int k= 0; k < autoincrement_id_count; ++k)
            {
                field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
                if (field_type == MP_UINT) lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy_copy);
                else if (field_type == MP_INT) lmysql->ldbms_mp_decode_int(&tarantool_tnt_reply_data_copy_copy);
                else goto erret;
            }
            array_size= 1; /* we have skipped autoincrement_ids so now we can proceed with field_count */
          }
        }
      }
      if (array_size == 1)
      {
        field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
        if (field_type == MP_STR)
        {
          value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy_copy, &value_length);
          if (value_length == 9)
          {
            if (memcmp(value, "row_count", 9) == 0)
            {
              field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
              if (field_type == MP_UINT)
              {
                *result_set_type= RESULT_TYPE_6;
                r= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data_copy_copy); /* unused? */
                goto return_point;
              }
            }
          }
        }
      }
    }
  }

  {
    const char *tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data;
    const char *value;
    uint32_t value_length;
    field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
    if (field_type == MP_STR)
    {
      *result_set_type= RESULT_TYPE_7; /* trying to get over the hump, so 7 even if it's not "Error:" */
      r= 0;
      goto return_point;
      value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy_copy, &value_length);
      if (value_length > 7)
      {
        if (memcmp(value, "Error: ", 7) == 0)
        {
          if (isdigit(*(value+7)))
          {
            *result_set_type= RESULT_TYPE_7;
            r= 0;
            goto return_point;
          }
        }
      }
    }
  }

  {
    const char *n;

    n= tarantool_result_set_init_select(&r, -1, -1);
    if (n != NULL)
    {
      tarantool_tnt_reply_data= n;
      *result_set_type= RESULT_TYPE_5; goto return_point;
    }
  }

  field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data);
  if (field_type != MP_ARRAY) goto erret;

  {
    const char *tarantool_tnt_reply_data_copy_copy= tarantool_tnt_reply_data;
    field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
    int array_size;
    if (field_type == MP_ARRAY)
    {
      array_size= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data_copy_copy);
      r= array_size;
      field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy_copy);
      if (field_type == MP_ARRAY)
      {
        *result_set_type= RESULT_TYPE_4;
        tarantool_tnt_reply_data= tarantool_tnt_reply_data_copy_copy;
        goto return_point;
      }
    }
  }

  r= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);

  if (r > 0) /* Check if it's nil or a series of nothing but nils */
  {
    long unsigned int q;
    for (q= 0; q < r; ++q)
    {
      if ((unsigned char)*(tarantool_tnt_reply_data + q) != 0xc0) break;
    }
    if (q == r)
    {
      *result_set_type= RESULT_TYPE_1;
      goto return_point;
    }
  }


  /* TEST: ANOTHER EL GRANDE KLUDGE */
  if ((r > 1) && (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data) == MP_NIL))
  {
    const char *tarantool_tnt_reply_data2= tarantool_tnt_reply_data;
    long r2;
    for (r2= r; r2 != 0; --r2)
    {
      if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data2) == MP_NIL)
      {
        ++tarantool_tnt_reply_data2;
        continue;
      }
      break;
    }
    if (r2 == 0)
    {
    }
    else if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data2) == MP_ARRAY)
    {
      r= 1;
      tarantool_tnt_reply_data= tarantool_tnt_reply_data2;
    }
  }
  if (r == 0)
  {
    *result_set_type= RESULT_TYPE_1; goto return_point;
  }
  if (r != 1)
  {
    tarantool_tnt_reply_data= tarantool_tnt_reply_data_p;
    *result_set_type= RESULT_TYPE_2; goto return_point;
  }

  field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data);
  if (field_type != MP_ARRAY)
  {
    tarantool_tnt_reply_data= tarantool_tnt_reply_data_p;
    *result_set_type= RESULT_TYPE_2; goto return_point;
  }
  r= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
  field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data);
  if (field_type != MP_ARRAY)
  {
    tarantool_tnt_reply_data= tarantool_tnt_reply_data_p;
    *result_set_type= RESULT_TYPE_2; goto return_point;
  }
  *result_set_type= RESULT_TYPE_3; goto return_point;

return_point:
  if (*result_set_type == RESULT_TYPE_0) *result_row_count= 0;
  else if (*result_set_type == RESULT_TYPE_2) *result_row_count= 1;
//  if (*result_set_type != 4)
//  {
//    lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
//  }
//  long unsigned int r;
  else
  {
//  r= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
    *result_row_count= r;
  }
  log("tarantool_result_set_init end 1", 80);
  return tarantool_tnt_reply_data;
erret:
  tarantool_errno[connection_number]= 10008;
  strcpy(tarantool_errmsg, "Error: did not understand received data. ");
  if (tarantool_tnt_reply_data_p == NULL)
    strcat(tarantool_errmsg, "tarantool_tnt_reply_data_p == NULL");
  else if (tarantool_tnt_reply.data_end == NULL)
    strcat(tarantool_errmsg, "tarantool_tnt_reply.data_end == NULL");
  else
  {
    int j= tarantool_tnt_reply.data_end - tarantool_tnt_reply_data_p;
    strcat(tarantool_errmsg, "First few bytes are: ");
    char tmp_hex[16];
    for (int i= 0; i < 10 && i < j; ++i)
    {
      sprintf(tmp_hex, "%x ", *(tarantool_tnt_reply_data_p + i) & 0xff);
      strcat(tarantool_errmsg, tmp_hex);
    }
    strcat(tarantool_errmsg, ".");
  }
  *result_row_count= 0;
  log("tarantool_result_set_init end 0", 80);
  return 0;
}

/* SELECT will have, for a result with 1 column named '5' with type 'integer' and 1 row:
   dd,00,00,01                          1-element array
   82                                   2-element map (for metadata + rows)
     a8,"metadata"                      string
     91                                 1-element array (for column count)
     82                                 2-element map (for name + type)
       a4,'name'                        string
       a1,'5'                           string
       a4,'type'                        string
       a7,'integer'                     string
     a4,"rows"                          string
     91                                 1-element array (for row count)
     91                                 1-element array (for field count)
     5                                  contents
  OR, if it was done via tnt_execute rather than tnt_call or tnt_eval
    [metadata]
    91                                  1-element array = number of fields
      82                                2-element map (there might be more elements if details are requested)
        0                               IPROTO_FIELD_NAME
        a1,'5'                          string
        1                               IPROTO_FIELD_TYPE
        a7,'integer'                    string
    [data]
    91                                  1-element array = number of rows
      91                                1-element array = number of fields
        a1,'5'                          contents

  Return: pointer to first row
  Re column_number: If it is >= 0, we return pointer to column name not pointer to first data row.
                    Then the caller can say
                    value= lmysql->ldbms_mp_decode_str(tarantool_tnt_reply_data, &value_length);
  TODO: Probably we shouldn't assume 'name' and 'type' are in order and alone
  TODO: We could skip some strings instead of decoding them.
        In fact I could skip the whole map with ldbms_mp_next().
*/
const char * MainWindow::tarantool_result_set_init_select(
        long unsigned int *result_row_count,
        int column_number,
        int what_to_return)         /* -1 if column_number=-1, 0 if we want name, 1 if we want type */
{

  char field_type; /* for return from lmysql->ldbms_mp_typeof */
  uint32_t array_size; /* for return from lmyswl->dbms_mp_decode_array */
  uint32_t value_length; /* for return from lmysql->ldbms_mp_decode_str */
  const char *value; /* for return from lmysql->ldbms_mp_decode_str */
  uint64_t row_count;
  uint32_t field_count;

  const char *tarantool_tnt_reply_data_copy= tarantool_tnt_reply_data_p; /* push */
  const char* new_tarantool_tnt_reply_data;

  const char **tarantool_tnt_reply_data= &tarantool_tnt_reply_data_p;

  if ((tarantool_tnt_reply.metadata != 0) && (tarantool_tnt_reply_data_p != 0))
  {
    const char *tarantool_tnt_reply_metadata_copy= tarantool_tnt_reply.metadata;

    field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_metadata_copy);
    if (field_type != MP_ARRAY) { goto x; }
    field_count= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_metadata_copy);
    for (unsigned int field_no= 0; field_no < field_count; ++field_no)
    {
      field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_metadata_copy);
      if (field_type != MP_MAP) { goto x; }
      unsigned int member_count= lmysql->ldbms_mp_decode_map(&tarantool_tnt_reply_metadata_copy);
      const char *name_value; /* actually it's name value or type value */
      uint32_t name_value_length;
      for (unsigned int j= 0; j < member_count; ++j)
      {
        if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_metadata_copy) != MP_UINT) { goto x; }
        int member_type= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_metadata_copy);
        if (member_type == what_to_return) /* = IPROTO_FIELD_NAME or IPROTO_FIELD_TYPE */
        {
          if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_metadata_copy) != MP_STR) { goto x; }
          name_value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_metadata_copy, &name_value_length);
        }
        else /* 2 == IPROTO_FIELD_COLL 3 = IPROTO_FIELD_IS_NULLABLE 4 = IPROTO_FIELD_IS_AUTOINCREMENT etc. */
        {
          /* todo: check: what is this line for? surely it's no problem if it's not a string */
          if (lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_metadata_copy) != MP_STR) { goto x; }
          value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_metadata_copy, &value_length);
        }
      }
      if (field_no == (unsigned) column_number)
      {
        *result_row_count= name_value_length;
        tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy; /* pop */
        return name_value;
      }
    }
    const char *tnt_reply_data_p= tarantool_tnt_reply_data_p; /* push */
    if (lmysql->ldbms_mp_typeof(*tnt_reply_data_p) != MP_ARRAY) goto x;
    long int row_count= lmysql->ldbms_mp_decode_array(&tnt_reply_data_p);
    *result_row_count= row_count;
    if (column_number != -1)
    {
      tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy; /* pop */
      return NULL;
    }
    /* and now we are pointing to the first row */
    new_tarantool_tnt_reply_data= tnt_reply_data_p;
    tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy; /* pop */
    return new_tarantool_tnt_reply_data;
  }

  /* Todo: be suspicious of this, I fear it could be true in many cases */
  if (tarantool_tnt_reply_data_p > tarantool_tnt_reply.data)
  {
    /* dd, 0, 0, 1 will be missing if this is part of a transaction return */
    ;
  }
  else
  {
    field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
    if (field_type != MP_ARRAY) {  goto x; }
    array_size= lmysql->ldbms_mp_decode_array(tarantool_tnt_reply_data);
    if (array_size != 1) { goto x; }
  }

  field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
  if (field_type != MP_MAP) { goto x; }
  array_size= lmysql->ldbms_mp_decode_map(tarantool_tnt_reply_data) * 2;
  if (array_size != 4) { goto x; }
  field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
  if (field_type != MP_STR) { goto x; }
  value= lmysql->ldbms_mp_decode_str(tarantool_tnt_reply_data, &value_length);
  if (value_length != 8) { goto x; }
  field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
  if (field_type != MP_ARRAY) { goto x; }
  field_count= lmysql->ldbms_mp_decode_array(tarantool_tnt_reply_data);
  for (unsigned int field_no= 0; field_no < field_count; ++field_no)
  {
    field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
    if (field_type != MP_MAP) {  goto x; }
    array_size= lmysql->ldbms_mp_decode_map(tarantool_tnt_reply_data);
    if (array_size != 2) { goto x; }
    field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
    if (field_type != MP_STR) { goto x; }
    value= lmysql->ldbms_mp_decode_str(tarantool_tnt_reply_data, &value_length);
    if (value_length != 4) { goto x; }
    field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
    if (field_type != MP_STR) { goto x; }
    value= lmysql->ldbms_mp_decode_str(tarantool_tnt_reply_data, &value_length);
    if ((int)field_no == column_number)
    {
      *result_row_count= value_length;
      tarantool_tnt_reply_data_p=tarantool_tnt_reply_data_copy; /* pop */
      return value;
    }
    /* value = column name */
    value= lmysql->ldbms_mp_decode_str(tarantool_tnt_reply_data, &value_length);
    if (value_length != 4) { goto x; }
    field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
    if (field_type != MP_STR) { goto x; }
    value= lmysql->ldbms_mp_decode_str(tarantool_tnt_reply_data, &value_length);
    /* value = type e.g. 'integer' */
  }
  field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
  if (field_type != MP_STR) { goto x; }
  value= lmysql->ldbms_mp_decode_str(tarantool_tnt_reply_data, &value_length);
  if (value_length != 4) { goto x; }
  field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);

  if (field_type != MP_ARRAY) { goto x; }
  row_count= lmysql->ldbms_mp_decode_array(tarantool_tnt_reply_data);
  /* and now we are pointing to the first row */
  *result_row_count= row_count;
  if (column_number != -1) return NULL;

    new_tarantool_tnt_reply_data= *tarantool_tnt_reply_data;
  tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy; /* pop */

  return new_tarantool_tnt_reply_data;
x:  *result_row_count= 0;
  tarantool_tnt_reply_data_p=tarantool_tnt_reply_data_copy; /* pop */
  return 0;
}

/*
  Given tarantool_tnt_reply, return number of rows from a SELECT.
  Used by result grid.
*/
long unsigned int MainWindow::tarantool_num_rows(unsigned int connection_number)
{
  long unsigned int r;
  int result_set_type;
  tarantool_result_set_init(connection_number, &r, &result_set_type);
  return r;
}

/*
  Warning: do not say "delete [] request_string;" early, there
  might be a hidden pointer to it.

  TODO: Remove the giant kludge here. Instead of skipping nulls till
        we can return the first thing that's not null, we should
        "return ocelot_return0,ocelot_return1,..." and if there are
        2 or more result sets, then handle them with tabs the same way
        we do for MySQL/MariaDB.
*/

/*
  Execute a single SQL statement by calling Tarantool tnt_execute().
  Until 2020-09-23 we used to call Tarantool tnt_call("box.execute", ...).
  That worked but it required one more privilege, and Tarantool supports tnt_execute since version 2.1 (April 2019).
  For multiple SQL statements we call ocelot_sqle instead.
  This should be faster on the server because it does not make a local copy of the result.
  Also we get tarantool_errno, which ocelot_sqle does not deliver (hmm, it does, as part of message).
  Called by: rehash_scan().
  Called by: tarantool_real_query() if we see that it is SQL and not start of | part of a transaction.
  Todo:
    tarantool_execute_sql() previously did:
        tarantool_select_nosql= false;
        result_row_count= r;
    I am not sure whether something is still expecting that.
  Todo: This does not expect ? placeholders because Tarantool-C doesn't have tnt_prepare at this moment.
        When it does, we want to add something like (for one string parameter):
          lmysql->ldbms_tnt_object_add_array(tuple, 1);
          lmysql->ldbms_tnt_object_add_str(tuple, str, str_len);
*/
int MainWindow::tarantool_execute_sql(
        const char *dbms_query,
        unsigned int dbms_query_len,
        int connection_number)
{
  struct tnt_stream *tuple= lmysql->ldbms_tnt_object(NULL);
  lmysql->ldbms_tnt_object_reset(tuple); /* Todo: check if this is necessary. Doc is a bit unclear. */
  //tarantool_tnt_reply.data= NULL;
  //tarantool_tnt_reply.metadata= NULL;
  //tarantool_tnt_reply.error= NULL;
  /* TEST!!!! Let's not check, for the moment. */
  if (strcmp(tarantool_box_execute, "No SQL") == 0)
  {
    tarantool_errno[connection_number]= 9998;
    strcpy(tarantool_errmsg, "(Warning) Tarantool server won't accept SQL, only Lua");
    return tarantool_errno[connection_number];
  }
  /* TEST!!!! I want tarantool_tnt_connect, but am I better off without? */
  lmysql->ldbms_tnt_object_add_array(tuple, 0);
  lmysql->ldbms_tnt_execute(tnt[connection_number], dbms_query, dbms_query_len, tuple);
  //lmysql->ldbms_tnt_object_add_array(tuple, 1);
  //lmysql->ldbms_tnt_object_add_str(tuple, dbms_query, dbms_query_len);
  //lmysql->ldbms_tnt_call(tnt[connection_number], tarantool_box_execute, strlen(tarantool_box_execute), tuple);
  tarantool_flush_and_save_reply(connection_number);
  if (tarantool_errno[connection_number] != 0) return tarantool_errno[connection_number];
  return 0;
}

int MainWindow::tarantool_execute_lua(
        const char *dbms_query,
        unsigned int dbms_query_len,
        int connection_number)
{
  struct tnt_stream *tuple= lmysql->ldbms_tnt_object(NULL);
  lmysql->ldbms_tnt_object_reset(tuple); /* Todo: check if this is necessary. Doc is a bit unclear. */
  lmysql->ldbms_tnt_object_add_array(tuple, 0);
  lmysql->ldbms_tnt_eval(tnt[connection_number], dbms_query, dbms_query_len, tuple);
  tarantool_flush_and_save_reply(connection_number);
  if (tarantool_errno[connection_number] != 0)  return tarantool_errno[connection_number];
  return 0;
}

/*
  Select everything in a space.
  See description of tnt_select in third_party.h.
*/
int MainWindow::tarantool_execute_lua_select(int connection_number, int space_number)
{
  struct tnt_stream *tuple= lmysql->ldbms_tnt_object(NULL);
  lmysql->ldbms_tnt_object_reset(tuple); /* Todo: check if this is necessary. Doc is a bit unclear. */
  //tarantool_tnt_reply.data= NULL;
  //tarantool_tnt_reply.metadata= NULL;
  //tarantool_tnt_reply.error= NULL;
  lmysql->ldbms_tnt_object_add_array(tuple, 0);
  lmysql->ldbms_tnt_select(
                 tnt[connection_number], /* struct tnt_stream * s */
                 space_number,           /* uint32_t space no */
                 0,                      /* uint32_t index no */
                 UINT32_MAX,             /* uint32_t limit */
                 0,                      /* uint32_t offset */
                 TNT_ITER_ALL,          /* uint8_t iterator */
                 tuple);                 /* struct tnt_stream * key */
  tarantool_flush_and_save_reply(connection_number);
  if (tarantool_errno[connection_number] != 0)  return tarantool_errno[connection_number];
  return 0;
}

/*
  For LUA 'x x x', how on earth do I know if it returns a result set?
  As far as I can tell, I must know this in advance because for eval()
  I have to say 'return ' somewhere. Somehow the regular tarantool client
  figures this out, but I don't know the official method if there is one.
  My guess is based on the Lua keyword list ...
  If first word = and break do else elseif end for function if in local or repeat return then until while
  (But not: true nil false not)
  then do not add "return "
  else If the second token is: "="
  then do not add "return "
  else add "return "
  ... Eventually we should parse Lua and then we can get rid of this.
      Todo: now we do parse Lua, so consider how to get rid of this.
  TODO: Nothing calls this, we can get rid of it.
*/
QString MainWindow::tarantool_add_return(QString s)
{
  log("tarantool_add_return start", 80);
  int token_offsets[100]; /* Surely a single assignable target can't have more */
  int token_lengths[100];
  tokenize(s.data(),
           s.size(),
           &token_lengths[0], &token_offsets[0], 100 - 1,
          (QChar*)"33333", 2, "", 1);
  QString word_1= s.mid(token_offsets[0], token_lengths[0]);
  if ((word_1 == "and") || (word_1 == "break") || (word_1 == "do")
   || (word_1 == "else") || (word_1 == "elseif") || (word_1 == "end")
   || (word_1 == "for") || (word_1 == "function") || (word_1 == "if")
   || (word_1 == "in") || (word_1 == "local") || (word_1 == "or")
   || (word_1 == "repeat") || (word_1 == "return") || (word_1 == "then")
   || (word_1 == "until") || (word_1 == "while"))
    return s;
  QString word_2;
  for (int i= 1; i < 100 - 1; ++i)
  {
    word_2= s.mid(token_offsets[i], token_lengths[i]);
    if ((word_2 == "") || (word_2 == "(")) break;
    if (word_2 == "=") return s;
  }
  log("tarantool_add_return end", 80);
  return "return " + s;
}

/*
  Given tarantool_tnt_reply, return number of fields from a SELECT. Used by result grid.
  Actually there are two counts: the count of main fields, and the count of sub-fields.
  Todo: what if there are arrays within arrays?
  Todo: shouldn't map fields be arranged so new map value = new field?
  Due to flattening, field_count is count of scalars not count of arrays and maps.
  For example, array[2] X Y array[3] A B C has 5 scalars.
  Todo: Check is it ok to pass connection_number==0 to tarantool_result_set_init
*/
unsigned int MainWindow::tarantool_num_fields()
{
  const char *tarantool_tnt_reply_data_copy= tarantool_tnt_reply_data_p; /* push */
  const char **tarantool_tnt_reply_data= &tarantool_tnt_reply_data_p;
  char field_name[TARANTOOL_MAX_FIELD_NAME_LENGTH];
  unsigned int max_field_count;

  field_name_list_all_rows.clear();
  field_name_list_all_rows_count.clear();
  field_name_list_all_rows_address.clear();
  field_type_list_all_rows.clear();

  /* See tarantool_num_rows for pretty well the same code as this */
  /* Todo: this is wrong, connection_number might not be 0 */
  int result_set_type;
  *tarantool_tnt_reply_data= tarantool_result_set_init(0, &result_row_count, &result_set_type);
  if ((result_set_type == RESULT_TYPE_0) || (result_set_type == RESULT_TYPE_1))
  {
//    result_row_count= 0;
    return 0;
  }
//  if (result_set_type == RESULT_TYPE_2) result_row_count= 1;
//  else
//  {
//    if (result_set_type != RESULT_TYPE_4)
//    {
//      lmysql->ldbms_mp_decode_array(tarantool_tnt_reply_data);
//    }
//    result_row_count= lmysql->ldbms_mp_decode_array(tarantool_tnt_reply_data);
//  }
  if (result_set_type == RESULT_TYPE_5)
  {
    /* We no longer need to do anything because we don't need to skip a header row */
    //int bytes;
    //int row_size_1;
    //QString fetch_row_result= tarantool_fetch_row(*tarantool_tnt_reply_data, &bytes, &row_size_1);
    //if (fetch_row_result != "OK") return fetch_row_result;
    //*(tarantool_tnt_reply_data)+= bytes;
//    --result_row_count;
  }

  strcpy(field_name, TARANTOOL_FIELD_NAME_BASE);
  strcat(field_name, "_");

  for (long unsigned int r= 0; r < result_row_count; ++r)
  {
    int return_value= tarantool_num_fields_recursive(tarantool_tnt_reply_data,
                                                     field_name, 0,
                                                     &field_name_list_all_rows,
                                                     &field_name_list_all_rows_count,
                                                     &field_name_list_all_rows_address,
                                                     0);
    if (return_value < 0) assert(0 != 0);
  }

  /* Todo: If it's possible to have a column with field_name_list_count == 0, eliminate it here. */

  /* Field names must be in order. Temporarily change $s so most common map names have precedence. */
  field_name_list_all_rows.sort();

  max_field_count= field_name_list_all_rows.count();

  tarantool_field_names_count= max_field_count; /* tarantool_field_names_count is global */

  tarantool_tnt_reply_data_p= tarantool_tnt_reply_data_copy; /* pop */

  return max_field_count;
}

/*
  tarantool_num_fields_recursive
  Called from: tarantool_scan_rows(), tarantool_num_fields(), tarantool_num_fields_recursive()
  Within a for-each-row loop, we call this with:
    Initial value of char **tarantool_tnt_reply_data is to start of row.
    Initial value of char *field_name is TARANTOOL_FIELD_NAME_BASE + "_" e.g. "f_"
    Initial value of field_number_within_array is 0 (maybe we should rename "i" in the loop)
    Initial value of QStringList field_name_list is clear (possibly clear() isn't necessary)
    Initial value of QList<int> field_name_list_count is clear
    Initial value of int field_name_upper is 0, it can be MP_MAP or (MP_ARRAY << 4) | MAP
  Inside this routine, we say:
    p_field_name_end points to after the last "_" in field_name.
    if (tarantool_tnt_reply_data is to a map or array)
      add (field number within array + 1) and "_" to field_name
      for each element in map or array
        recursive call!
    else i.e. if (tarantool_tnt_reply_data is to a scalar) skip
    add (array number + 1) to field_name
    if field name is not in field_name_list) add field_name to field_name_list
    Eventually we replace base name with defined field name, if there is one
  So this is a good place to check for maps (or arrays of maps):
    If (map) and (key type == string) and (key length not too great) and (value type is scalar)
    and (number of fields < too many) then the key will be a header.
    Todo: key type could be number, key length max could be less, number of fields could be more.
          the numbers plugged in here are arbitrary
    Todo: what if it is not the right result type?
    Todo: what if user prefers the old way (as if TARANTOOL_MAX_MAP_FIELDS == 0)?
    because the ambition is to have map keys as column headers where possible
    but we try to preserve the order of maps within an array
    So later we have to associate a key with a heading.
  Todo: we go through the rows and call this more than once, so speed up or call less often
        QHash or QMap or a tree or something that searches in a narrow range withthe same prefix
        or a binary search if it's the second loop after there's been a sort
  Todo: There might be a point to distinguishing MP_MAP size n from MP_ARRAY size n containing maps.
        In the former case you know it's all maps and maybe needn't worry about the order.
*/
/* If there are 64 or more fields, block creation of new headers from maps. Arbitrary. Must be divisible by 2. */
#define TARANTOOL_MAX_MAP_FIELDS 64
int MainWindow::tarantool_num_fields_recursive(const char **tarantool_tnt_reply_data,
                                               char *field_name,
                                               int field_number_within_array,
                                               QStringList *p_field_name_list,
                                               QList<int> *p_field_name_list_count,
                                               QList<char*> *p_field_name_list_address,
                                               int field_type_upper)
{
  bool is_scalar;
  int field_name_index;
  char field_type= lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data);
  if ((field_type == MP_NIL)
   || (field_type == MP_UINT)
   || (field_type == MP_INT)
   || (field_type == MP_STR)
   || (field_type == MP_BIN)
   || (field_type == MP_BOOL)
   || (field_type == MP_FLOAT)
   || (field_type == MP_DOUBLE)
   || (field_type == MP_EXT))
    is_scalar= true;
  else if ((field_type == MP_ARRAY) || (field_type == MP_MAP))
    is_scalar= false;
  else return -1;

  /* p_field_name_end, within field_name, = after last '_' or after TARANTOOL_FIELD_NAME_BASE */
  char *p_field_name_end;
  for (p_field_name_end= field_name + strlen(field_name);; --p_field_name_end)
  {
    if (*p_field_name_end == '_') break;
  }
  ++p_field_name_end;
  if (is_scalar == false)
  {
    uint32_t array_size;
    uint32_t field_type_to_pass;
    const char *tarantool_tnt_reply_data_before_decode= *tarantool_tnt_reply_data;
    if (field_type == MP_ARRAY)
    {
      field_type_to_pass= MP_ARRAY;
      array_size= lmysql->ldbms_mp_decode_array(tarantool_tnt_reply_data);
    }
    else
    {
      if (field_type_upper == MP_ARRAY) field_type_to_pass= (MP_ARRAY << 4) | MP_MAP;
      else field_type_to_pass= MP_MAP;
      array_size= lmysql->ldbms_mp_decode_map(tarantool_tnt_reply_data) * 2;
    }
    if (array_size == 0) *tarantool_tnt_reply_data= tarantool_tnt_reply_data_before_decode;
    if (array_size != 0)
    {
      sprintf(p_field_name_end, "%05d_", field_number_within_array + 1);
      for (uint32_t i= 0; i < array_size; ++i)
      {
        int return_value= tarantool_num_fields_recursive(tarantool_tnt_reply_data,
                                                         field_name,
                                                         i, p_field_name_list,
                                                         p_field_name_list_count,
                                                         p_field_name_list_address,
                                                         field_type_to_pass);
        if (return_value < 0) return return_value;
        i+= return_value; /* usually return_value == 0 but return_value == 1 iff we made a map field and skipped value */
      }
      p_field_name_end= field_name + strlen(field_name) - 1;
      while (*p_field_name_end != '_') --p_field_name_end;
      *(p_field_name_end - 1)= '\0';
      return 0;
    }
  }
  /* is_scalar == true or array size == 0 which we treat as null */
  if ((is_scalar == true)
   && ((field_type_upper == MP_MAP) || (field_type_upper == ((MP_ARRAY << 4) | MP_MAP)))
   && ((field_number_within_array % 2) == 0)
   && (lmysql->ldbms_mp_typeof(**tarantool_tnt_reply_data) == MP_STR))
  {
    const char *tarantool_tnt_reply_data_copy= *tarantool_tnt_reply_data;
    uint32_t key_length;
    const char *key;
    unsigned int field_name_length= strlen(field_name);
    key= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data_copy, &key_length);
    if ((key_length + field_name_length + 2) < TARANTOOL_MAX_FIELD_NAME_LENGTH)
    {
      int value_field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data_copy);
      if ((value_field_type != MP_ARRAY) && (value_field_type != MP_MAP))
      {
        char map_field_name[TARANTOOL_MAX_FIELD_NAME_LENGTH];
        /* Won't include map item number but will include array item number if we're in a map within an array */
        /* field_name_length -= 6; */
        memcpy(map_field_name, field_name, field_name_length);
        *(map_field_name + field_name_length - 1)= '_';
        memcpy(map_field_name + field_name_length, key, key_length);
        *(map_field_name + field_name_length + key_length)= '\0';
        int map_field_name_index= (*p_field_name_list).indexOf(map_field_name);
        if ((map_field_name_index != -1 || (*p_field_name_list).size() < TARANTOOL_MAX_MAP_FIELDS))
        {
          if (map_field_name_index == -1)
          {
            (*p_field_name_list).append(map_field_name);
            (*p_field_name_list_count).append(1);
            (*p_field_name_list_address).append((char*)tarantool_tnt_reply_data_copy);
          }
          else
          {
            (*p_field_name_list_count)[map_field_name_index]= (*p_field_name_list_count)[map_field_name_index] + 1;
            (*p_field_name_list_address)[map_field_name_index]= (char*)tarantool_tnt_reply_data_copy;
          }
          lmysql->ldbms_mp_next(tarantool_tnt_reply_data);
          lmysql->ldbms_mp_next(tarantool_tnt_reply_data);
          return 1;
        }
      }
    }
  }
  sprintf(p_field_name_end, "%05d", field_number_within_array + 1);
  field_name_index= (*p_field_name_list).indexOf(field_name);
  if (field_name_index == -1)
  {
    (*p_field_name_list).append(field_name);
    (*p_field_name_list_count).append(1);
    (*p_field_name_list_address).append((char*)*tarantool_tnt_reply_data);
  }
  else
  {
    (*p_field_name_list_count)[field_name_index]= (*p_field_name_list_count)[field_name_index] + 1;
    (*p_field_name_list_address)[field_name_index]= (char*)*tarantool_tnt_reply_data;
  }
  lmysql->ldbms_mp_next(tarantool_tnt_reply_data);
  return 0;
}

/* To "seek to row zero", start with the initial pointer and skip over the row count. */
/* Also skip field names if result_set_type == RESULT_TYPE_5. */
/* Todo: Check is it ok to pass connection_number==0 to tarantool_result_set_init */
/* TODO: Don't call this, it is useless. */
const char * MainWindow::tarantool_seek_0(int *returned_result_set_type)
{
  uint32_t row_count;
  const char *tarantool_tnt_reply_data;
  //tarantool_tnt_reply_data= tarantool_tnt_reply_data_p;

  long unsigned int tmp_row_count;
  int result_set_type;
  tarantool_tnt_reply_data= tarantool_result_set_init(0, &tmp_row_count, &result_set_type);
  row_count= tmp_row_count;
  if ((result_set_type == RESULT_TYPE_0) || (result_set_type == RESULT_TYPE_1))
  {
    assert(result_set_type > RESULT_TYPE_1);
  }
//  if (result_set_type == RESULT_TYPE_2) row_count= 1;
//  else
//  {
//    if (result_set_type != RESULT_TYPE_4)
//    {
//      lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
//    }
//    row_count= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
//  }
  if (result_set_type == RESULT_TYPE_5)
  {
    //int bytes;
    //int row_size_1;
    //QString fetch_row_result= tarantool_fetch_row(tarantool_tnt_reply_data, &bytes, &row_size_1);
    ////if (fetch_row_result != "OK") return fetch_row_result;
    //tarantool_tnt_reply_data+= bytes;
//    --row_count;
  }
#if defined(NDEBUG)
  if (row_count != result_row_count) {printf("assert(row_count == result_row_count);"); exit(1); }
#else
  assert(row_count == result_row_count);
#endif
  *returned_result_set_type= result_set_type;
  return tarantool_tnt_reply_data;
}

/*
  Originally this resembled mysql_fetch_row, till we realized we only want the total length.
  The traversal of fields must use the same system as in tarantool_scan_rows.
  The value of tarantool_tnt_reply_data increases, so at the end it points past row end.
  The calculation involves the actual amount that any non-missing field will take
  when sprintf'd to the row copy, but not the per-field overhead for all fields.
  todo: value_length is usually an unnecessary variable, just add to total_length
*/
QString MainWindow::tarantool_fetch_row(const char *tarantool_tnt_reply_data,
                                             int *bytes, int *tsize)
{
  const char *original_tarantool_tnt_reply_data= tarantool_tnt_reply_data;
  unsigned int total_length= 0;
  char field_type;
  field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data);
  if (field_type != MP_ARRAY) return "tarantool_fetch_row: field_type != MP_ARRAY";
  uint32_t field_count= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
  if (field_count == 0) return "tarantool_fetch_row: field_count == 0";

  for (uint32_t field_number= 0; field_number < field_count; ++field_number)
  {
    field_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data);
    assert(field_type <= MP_EXT);
    uint32_t value_length;
    const char *value;
    (void) value; /* suppress 'variable set but not used' warning */
    char value_as_string[320]; /* must be big enough for any sprintf() result */
    if (field_type == MP_NIL)
    {
      lmysql->ldbms_mp_decode_nil(&tarantool_tnt_reply_data);
      value_length= 0;
    }
    if (field_type == MP_UINT)
    {
      uint64_t uint_value= lmysql->ldbms_mp_decode_uint(&tarantool_tnt_reply_data);
      long long unsigned int llu= uint_value;
      value_length= sprintf(value_as_string, "%llu", llu);
    }
    if (field_type == MP_INT)
    {
      int64_t int_value= lmysql->ldbms_mp_decode_int(&tarantool_tnt_reply_data);
      long long int lli= int_value;
      value_length= sprintf(value_as_string, "%lld", lli);
    }
    if (field_type == MP_STR)
    {
      /* todo: allow for the library routine that only gets length */
      value= lmysql->ldbms_mp_decode_str(&tarantool_tnt_reply_data, &value_length);
    }
    if (field_type == MP_BIN)
    {
      /* todo: allow for the library routine that only gets length */
      value= lmysql->ldbms_mp_decode_bin(&tarantool_tnt_reply_data, &value_length);
    }
    if (field_type == MP_ARRAY)
    {
      uint32_t array_size;
      array_size= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
      field_count+= array_size;
      value_length= 0;
    }
    if (field_type == MP_MAP)
    {
      uint32_t array_size;
      array_size= lmysql->ldbms_mp_decode_map(&tarantool_tnt_reply_data) * 2;
      field_count+= array_size;
      value_length= 0;
    }
    if (field_type == MP_BOOL)
    {
      bool bool_value= lmysql->ldbms_mp_decode_bool(&tarantool_tnt_reply_data);
      if (bool_value == 0) {value_length= 5; strcpy(value_as_string, "FALSE"); }
      else                 {value_length= 4; strcpy(value_as_string, "TRUE"); }
    }
    if (field_type == MP_FLOAT)
    {
      float float_value= lmysql->ldbms_mp_decode_float(&tarantool_tnt_reply_data);
      value_length= sprintf(value_as_string, "%f", float_value);
    }
    if (field_type == MP_DOUBLE)
    {
      double double_value= lmysql->ldbms_mp_decode_double(&tarantool_tnt_reply_data);
      value_length= sprintf(value_as_string, "%E", double_value);
    }
    if (field_type == MP_EXT)
    {
      unsigned char ext_field_type;
      value_length= tarantool_fetch_row_ext(tarantool_tnt_reply_data, value_as_string, &ext_field_type);
      lmysql->ldbms_mp_next(&tarantool_tnt_reply_data);
    }

    total_length+= value_length;
  }
  *bytes=   tarantool_tnt_reply_data - original_tarantool_tnt_reply_data;
  if (*bytes <= 0) return "tarantool_fetch_row: *bytes <= 0";
  *tsize= total_length;
  return "OK";
}

/*
  called from tarantool_fetch_row() and from tarantool_scan_rows()
  MP_EXT requires a lot of special handling because it might be MP_DECIMAL or MP_UUID or MP_ERROR.
  We brought in the older msgpuck.h which doesn't have mp_decode_ext.
  Re possible errors:
      For all types, we return "EXT" and length = 3. It will be skipped because caller lmysql->ldbms_mp_next(&tarantool_tnt_reply_data);
      Error if: ext 16 and ext 32, which would not be possible for decimal, but might be allowed someday
      Error if: not equal to MP_DECIMAL = 1: MP_UNKNOWN_EXTENSION = 0, MP_UUID = 2, MP_ERROR = 3.
      We do not check for premature end of input (we rarely do), so really bad input could cause segmentation fault
  Re decimal:
      Beware negative scale which means add 0s at end.
  Re uuid:
      I assume that length = 16 and I do not check that the MP_EXT byte was d8.
      I produce a string that does not contain any "-"s.
  todo: we could distinguish non-decimal sub-types rather than return "EXT" for everything
  todo: for perfect lining up, we could keep track of maximum scale not just maximum length
*/
#define MP_DECIMAL 1
#define MP_UUID 2
#define MP_ERROR 3
#define MP_ERROR_STACK 0x00
#define MP_ERROR_TYPE 0
#define MP_ERROR_FILE 1
#define MP_ERROR_LINE 2
#define MP_ERROR_MESSAGE 3
#define MP_ERROR_ERRNO 4
#define MP_ERROR_CODE 5
#define MP_ERROR_FIELDS 6
#if (TARANTOOL_DATETIMES != 0)
#define MP_DATETIME 4
#endif

int MainWindow::tarantool_fetch_row_ext(const char *tarantool_tnt_reply_data,
                                            char *value_as_string,
                                            unsigned char *returned_ext_field_type)
{
  const char *next_tarantool_tnt_reply_data;
  unsigned char ext_field_type;
  next_tarantool_tnt_reply_data= tarantool_tnt_reply_data;
  lmysql->ldbms_mp_next(&next_tarantool_tnt_reply_data);
  unsigned char mp_ext_byte= *tarantool_tnt_reply_data;
  /* int l= 0; */
  if (mp_ext_byte == 0xd4) { /* l= 1; */ tarantool_tnt_reply_data+= 1; }
  else if (mp_ext_byte == 0xd5) { /* l= 2; */ tarantool_tnt_reply_data+= 1; }
  else if (mp_ext_byte == 0xd6) { /* l= 4; */ tarantool_tnt_reply_data+= 1; }
  else if (mp_ext_byte == 0xd7) { /* l= 8; */ tarantool_tnt_reply_data+= 1; }
  else if (mp_ext_byte == 0xd8) { /* l= 16; */ tarantool_tnt_reply_data+= 1; }
  else if (mp_ext_byte == 0xc7) { /* l= *(tarantool_tnt_reply_data + 1); */ tarantool_tnt_reply_data+= 2; }
  else {strcpy(value_as_string, "EXT"); return 3; }
  ext_field_type= *tarantool_tnt_reply_data;
  *returned_ext_field_type= *tarantool_tnt_reply_data;
  ++tarantool_tnt_reply_data;
  if (ext_field_type == MP_DECIMAL)
  {
    signed char scale= *tarantool_tnt_reply_data;
    ++tarantool_tnt_reply_data;
    if (scale == -48) /* i.e. 0xd0 = MessagePack for "int 8", only happens for big numbers e.g. 1e35 */
    {
      scale= *tarantool_tnt_reply_data;
      ++tarantool_tnt_reply_data;
    }
    unsigned char high_nibble, low_nibble;
    unsigned char decimal_output[64];
    unsigned char *decimal_output_pointer= &decimal_output[0];
    unsigned char sign= '+';
    while (tarantool_tnt_reply_data < next_tarantool_tnt_reply_data)
    {
      unsigned char ch= (unsigned char) *tarantool_tnt_reply_data;
      high_nibble= (ch >> 4);
      if ((high_nibble != 0) || (decimal_output_pointer != &decimal_output[0]))
      {
        *decimal_output_pointer= high_nibble + 0x30;
        ++decimal_output_pointer;
      }
      low_nibble= (ch & 0xf);
      if ((low_nibble == 10) || (low_nibble == 12) || (low_nibble == 14) || (low_nibble == 15)) sign= '+';
      else if ((low_nibble == 11) || (low_nibble == 13)) sign= '-';
      else
      {
        *decimal_output_pointer= low_nibble + 0x30;
        ++decimal_output_pointer;
      }
      ++tarantool_tnt_reply_data;
    }
    int decimal_output_length= decimal_output_pointer - &decimal_output[0];
    char *o= value_as_string;
    if (sign == '-') { *o= sign; ++o; }
    if ((scale == 0) && (decimal_output_length == 0))
    {
      *o= '0';
      ++o;
    }
    else if (scale == 0)
    {
      memcpy(o, decimal_output, decimal_output_length);
      o+= decimal_output_length;
    }
    else if (scale >= decimal_output_length)
    {
      *o= '0'; ++o; /* Actually I prefer '.1' not '0.1' but '0.1' is what Tarantool client produces */
      *o= '.'; ++o;
      memset(o, '0', scale - decimal_output_length);
      o+= scale - decimal_output_length;
      memcpy(o, decimal_output, decimal_output_length);
      o+= decimal_output_length;
    }
    else
    {
      if (scale < 0)
      {
        int additional_zeros= 0 - scale;
        memcpy(o, decimal_output, decimal_output_length);
        o+= decimal_output_length;
        memset(o, '0', additional_zeros);
        o+= additional_zeros;
      }
      else
      {
        memcpy(o, decimal_output, decimal_output_length - scale);
        o+= decimal_output_length - scale;
        *o= '.'; ++o;
        memcpy(o, decimal_output + (decimal_output_length - scale), scale);
        o+= scale;
      }
    }
    return o - value_as_string;
  }
  else if (ext_field_type == MP_UUID)
  {
    char *o= value_as_string;
    unsigned char ch, high_nibble, low_nibble;
    for (int i= 0; i < 16; ++i)
    {
      ch= (unsigned char) *tarantool_tnt_reply_data;
      if ((i == 4) || (i == 6) || (i == 8) || (i == 10)) *(o++)= '-';
      high_nibble= (ch >> 4);
      if (high_nibble < 10) high_nibble+= 0x30; else high_nibble+= 0x61 - 10;
      *(o++)= high_nibble;
      low_nibble= (ch &0xf);
      if (low_nibble < 10) low_nibble+= 0x30; else low_nibble+= 0x61 - 10;
      *(o++)= low_nibble;
      ++tarantool_tnt_reply_data;
    }
    return o - value_as_string;
  }
#if (TARANTOOL_DATETIMES != 0)
  else if (ext_field_type == MP_DATETIME)
  {
    int l= 0;
    if (mp_ext_byte == 0xd7) l= 8;
    else if (mp_ext_byte == 0xd8) l= 16;
    else return 0; /* error */
    int64_t seconds= *((int64_t*) tarantool_tnt_reply_data); /* # of seconds since 1970-01-01. can be negative. */
    tarantool_tnt_reply_data+= 8;
    int32_t nsecs= 0;
    int16_t tzoffset= 0;
    int16_t tzindex= 0;
    if (l == 16)
    {
      /* nsec (4 bytes), tzoffset (2 bytes), and tzindex (2 bytes) */
      nsecs= *((int32_t*) tarantool_tnt_reply_data); /* nanoseconds */
      tarantool_tnt_reply_data+= 4;
      tzoffset= *((int16_t*) tarantool_tnt_reply_data); /* offset in minutes as "+hh:mm". ignore if tzindex != 0 */
      tarantool_tnt_reply_data+= 2;
      tzindex= *((int16_t*) tarantool_tnt_reply_data); /* Olson timezone id */
      tarantool_tnt_reply_data+= 2;
      seconds+= tzoffset * 60; /* Despite Tarantool documentation, we don't ignore tzoffset even if tzindex != 0 */
    }
    /* fromSecsSinceEpoch was introduced in Qt 5.8 (2017) */
#if (QT_VERSION <= 0x050800)
    QDateTime dt= QDateTime::fromMSecsSinceEpoch(seconds * 1000);
#else
    QDateTime dt= QDateTime::fromSecsSinceEpoch(seconds, Qt::UTC);
#endif
    QString s= dt.toString("yyyy-MM-ddThh:mm:ss"); /* Tarantool quirk: character after date is 'T' not ' ' */
    if (s.left(1) == "-")
    {
      /* Tarantool quirk: the day before 0001-01-01 is 0000:12-31! Yuck! But we try to say what Tarantool client says. */
      int years_bc= s.left(5).toInt();
      QString s2;
      if (years_bc == -1) s2= "0000";
      else
      {
        char years_bc_as_string[32];
        sprintf(years_bc_as_string, "%04d", years_bc + 1);
        s2= years_bc_as_string;
      }
      s= s2 + s.right(s.length() - 5);
    }
    strcpy(value_as_string, s.toUtf8().data());
    if (l == 8)
    {
      strcat(value_as_string, "Z"); /* Tarantool quirk: if no tzoffset or tzindex, add 'Z' */
      return strlen(value_as_string); /* "return 20;" would be okay for AD dates */
    }
    int olength= strlen(value_as_string);  /* "olength= 19;" would be okay for AD dates */
    if (nsecs > 0) /* tarantool quirk: display nanoseconds with additional '0's sometimes not always */
    {
      char nsecs_string[32];
      int nsecs_length;
      sprintf(nsecs_string, ".%09d", nsecs); nsecs_length= 10;
      while (*(nsecs_string + nsecs_length - 1) == '0') { *(nsecs_string + nsecs_length - 1)= '\0'; --nsecs_length; }
      if ((nsecs_length == 9) || (nsecs_length == 6) || (nsecs_length == 3)) { strcat(nsecs_string, "0"); ++nsecs_length; }
      if ((nsecs_length == 8) || (nsecs_length == 5) || (nsecs_length == 2)) { strcat(nsecs_string, "00"); nsecs_length+= 2; }
      strcat(value_as_string + olength, nsecs_string);
      olength+= nsecs_length;
    }
    if (tzindex != 0)
    {
      unsigned int timezone_ids_offset= 0;
      unsigned int strings_offset= 0;
      char tzstring[MAX_TIMEZONE_NAME_LENGTH];
      for (;;)
      {
        unsigned int string_length= timezone_olson[timezone_ids_offset].timezone_string_length;
        short int timezone_id= timezone_olson[timezone_ids_offset].timezone_id;
        memcpy(tzstring, timezone_strings + strings_offset, string_length);
        tzstring[string_length]= '\0';
        if (timezone_id == tzindex)
        {
          if (string_length > 1) /* Tarantool quirk: add space before zone unless it's one-letter A-Z */
          {
            strcat(value_as_string + olength, " ");
            ++olength;
          }
          memcpy(value_as_string + olength, timezone_strings + strings_offset, string_length);
          olength+= string_length;
          value_as_string[olength]= '\0';
          break;
        }
        if (timezone_id == 0)
        {
          strcat(value_as_string + olength, "?");
          olength+= 1;
          break;
        }
        strings_offset+= string_length;
        ++timezone_ids_offset;
      }
    }
    else if (tzoffset != 0)
    {
      if (tzoffset > 0) strcat(value_as_string + olength, "+");
      else { strcat(value_as_string + olength, "-"); tzoffset= -tzoffset; }
      int hours= tzoffset / 60;
      int minutes= tzoffset % 60;
      /* Tarantool quirk: sometimes I'm sure I've seen ':' separating hours:minutes, but it's disappeared now. */
      sprintf(value_as_string + olength + 1, "%02d", hours);
      sprintf(value_as_string + olength + 1 + 2, "%02d", minutes);
      olength+= 5;
    }
    else
    {
      strcat(value_as_string, "Z");
      ++olength;
    }
    return olength;
  }
#endif
  else if (ext_field_type == MP_ERROR)
  {
    unsigned char mp_ext_error_byte= *(tarantool_tnt_reply_data++);
    if (mp_ext_error_byte == MP_ERROR_STACK) printf("*** MP_ERROR_STACK\n");

    unsigned char mp_ext_error_type= lmysql->ldbms_mp_typeof(*tarantool_tnt_reply_data);
    if (mp_ext_error_type == MP_ARRAY)
    {
      int mp_ext_array_size= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
      printf("  array size = %d\n", mp_ext_array_size);
      for (int i= 0; i < mp_ext_array_size; ++i)
      {
        unsigned char mp_ext_map_type= lmysql->ldbms_mp_decode_array(&tarantool_tnt_reply_data);
        if (mp_ext_map_type == MP_ERROR_TYPE)
        {
          printf("MP_ERROR_TYPE\n");
        }
        if (mp_ext_map_type == MP_ERROR_FILE)
        {
          printf("MP_ERROR_FILE\n");
        }
        if (mp_ext_map_type == MP_ERROR_LINE)
        {
          printf("MP_ERROR_LINE\n");
        }
        if (mp_ext_map_type == MP_ERROR_MESSAGE)
        {
          printf("MP_ERROR_MESSAGE\n");
        }
        if (mp_ext_map_type == MP_ERROR_ERRNO)
        {
          printf("MP_ERROR_ERRNO\n");
        }
        if (mp_ext_map_type == MP_ERROR_CODE)
        {
          printf("MP_ERROR_CODE\n");
        }
        if (mp_ext_map_type == MP_ERROR_FIELDS)
        {
          printf("MP_ERROR_FIELDS\n");
        }
        lmysql->ldbms_mp_next(&tarantool_tnt_reply_data);
      }
    }
    exit(0);
  }
  else
  {
    ; /* Not decimal or uuid or error. Some sort of error. */
  }
  strcpy(value_as_string, "EXT");
  return 3;
}

/*
  This is for result_set_type == RESULT_TYPE_5, where row#1 should actually
  be the header i.e. the field names. Ultimately it might be from the format.
  Skip the dd 00 00 00 01 and the row count.
  Skip the first field which is the a1 08 signature.
  For each header field
   replacing "f_n" section, i.e. as far as the second "_", if any.
   replacing "f_1..." with name#1..., "f_2..." with name#2..., etc.
  Todo: finding "f_n" is inefficient, memcmp etc. should be avoided.
  Todo: Check is it ok to pass connection_number==0 to tarantool_result_set_init
  THIS IS ALL GONE NOW.
*/
QString MainWindow::tarantool_fetch_header_row()
{
  uint32_t value_length;
  const char *value;

  int base_length= strlen(TARANTOOL_FIELD_NAME_BASE);
  char *flags= new char[tarantool_field_names_count];
  memset(flags, 0, tarantool_field_names_count);

  for (uint32_t field_number= 0; ;++field_number)
  {
    long unsigned int r;
    value= tarantool_result_set_init_select(&r, field_number, 0);
    if (value == NULL) break; /* no more columns? */
    if (r >= TARANTOOL_MAX_FIELD_NAME_LENGTH) goto error_return;
    value_length= r;
    char what_to_set_to[TARANTOOL_MAX_FIELD_NAME_LENGTH * 2];
    memcpy(what_to_set_to, value, value_length); /* This is what we set to */
    *(what_to_set_to + value_length)= '\0';
    char what_to_search_for[TARANTOOL_MAX_FIELD_NAME_LENGTH];
    memcpy(what_to_search_for, TARANTOOL_FIELD_NAME_BASE, base_length);
    //char field_number_as_char[16];
    sprintf(what_to_search_for, "%s_%u", TARANTOOL_FIELD_NAME_BASE, field_number + 1);
    int what_to_search_for_length= strlen(what_to_search_for);
    for (unsigned int j= 0; j < tarantool_field_names_count; ++j)
    {
      if (*(flags + j) > 0)
      {
        continue;
      }
      char tmp[TARANTOOL_MAX_FIELD_NAME_LENGTH * 2];
      QString s= field_name_list_all_rows.at(j);
      strcpy(tmp, s.toUtf8().data());
      char *what= &tmp[0];
      int memcmp_result= memcmp(what_to_search_for, what, what_to_search_for_length);
      if (memcmp_result < 0) break; /* what_to_search_for < what */
      if (memcmp_result > 0) continue; /* what to search for > what */

      char char_after_what= *(what + what_to_search_for_length);
      if ((char_after_what == 0) || (char_after_what == '_'))
      {
        *(flags + j)= 1;
        char new_name[TARANTOOL_MAX_FIELD_NAME_LENGTH * 2];
        memset(new_name, 0, TARANTOOL_MAX_FIELD_NAME_LENGTH);
        memcpy(new_name, value, value_length);
        memcpy(new_name + value_length, what + what_to_search_for_length, TARANTOOL_MAX_FIELD_NAME_LENGTH - what_to_search_for_length);
        *(new_name + TARANTOOL_MAX_FIELD_NAME_LENGTH)='\0';
        memcpy(what, new_name, TARANTOOL_MAX_FIELD_NAME_LENGTH);
      }
      field_name_list_all_rows[j]= QString::fromUtf8(what);
      value= tarantool_result_set_init_select(&r, field_number, 1);
      value_length= r;
      if (value == NULL) {;} /* I don't know whether we should care about null */
      /* Todo: Some field types here are wrong, and we don't have all possible types here. */
      if ((value_length == 7) && (memcmp(value, "integer", 7) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_INTEGER;
      if ((value_length == 6) && (memcmp(value, "string", 6) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_VAR_STRING;
      if ((value_length == 3) && (memcmp(value, "map", 3) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_MAP;
      if ((value_length == 5) && (memcmp(value, "array", 5) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_ARRAY;
      if ((value_length == 8) && (memcmp(value, "unsigned", 8) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_UNSIGNED;
      if ((value_length == 9) && (memcmp(value, "varbinary", 9) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_VARBINARY;
      if ((value_length == 7) && (memcmp(value, "boolean", 7) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_BOOLEAN;
      if ((value_length == 6) && (memcmp(value, "number", 6) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_DOUBLE;
      if ((value_length == 6) && (memcmp(value, "scalar", 6) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_SCALAR;
      if ((value_length == 6) && (memcmp(value, "double", 6) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_DOUBLE;
    }
  }
  delete []flags;
  return "OK";
error_return:
  delete []flags;
  return "Field name too long";
}


/*
  Given tarantool_tnt_reply, fill in field names + types + max widths.
  Return amount that we would need for allocating.
  Called from: scan_rows in result grid.
  Compare: what we do for first loop in scan_rows().
  Todo: Wonder: any advantage to having more precise field_value_flags since we know MP_UINT etc.?
  Todo: possible speed improvements
        field_name_list lookup via QHash, or via QMap, or binary search, or search only where prefix matches
        do not bother with tarantool_fetch_row, you could figure out allocation size in tarantool_num_fields (?)
        header-row heroism can end, you will just keep the main field name list until tarantool_scan_rows ends
*/
QString MainWindow::tarantool_scan_rows(unsigned int p_result_column_count,
               unsigned int p_result_row_count,
               MYSQL_RES *p_mysql_res,
               char **p_result_set_copy,
               char ***p_result_set_copy_rows,
               unsigned int **p_result_max_column_widths)
{
  (void) p_mysql_res; /* suppress "unused parameter" warning */
  unsigned long int v_r;
  //unsigned int i;
  int returned_result_set_type;
  const char *tarantool_tnt_reply_data_copy;

  /* Todo: all_rows_address could be done with new or malloc but we have early 'return' statements. */
  QList<char*> field_name_list_all_rows_address;
  for (int i= 0; i < field_name_list_all_rows.count(); ++i) field_name_list_all_rows_address.append(NULL);

  assert(p_result_column_count == tarantool_field_names_count); /* does this make sense? */

  ResultGrid *rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));

  /* TODO: The first loop is not necessary because we have data from tarantool_num_fields_recursive()? */
  /* TODO: Are you sure it's enough to use tarantool_field_names_count not p_result_column_count? */

  for (unsigned int i= 0; i < p_result_column_count; ++i) (*p_result_max_column_widths)[i]= 0;
  /*
    First loop: find how much to allocate. Allocate. Second loop: fill in with pointers within allocated area.
  */
  unsigned int total_size= 0;
  char *result_set_copy_pointer;
  tarantool_tnt_reply_data_copy= tarantool_seek_0(&returned_result_set_type); /* "seek to row 0" */
  for (v_r= 0; v_r < p_result_row_count; ++v_r)                                /* first loop */
  {
    int bytes;
    int row_size_1;
    QString fetch_row_result= tarantool_fetch_row(tarantool_tnt_reply_data_copy, &bytes, &row_size_1);
    if (fetch_row_result != "OK") return fetch_row_result;
    tarantool_tnt_reply_data_copy+= bytes;
    total_size+= row_size_1;
    /* per-field overhead includes overhead for missing fields; they are null */
    int row_size_2= tarantool_field_names_count * (sizeof(unsigned int) + sizeof(char) + TARANTOOL_MAX_FIELD_NAME_LENGTH);
    total_size+= row_size_2;
  }

  if (total_size > 2000000000) return ": total_size too big";
  *p_result_set_copy= new char[total_size];                                         /* allocate */
  *p_result_set_copy_rows= new char*[p_result_row_count];
  result_set_copy_pointer= *p_result_set_copy;
  tarantool_tnt_reply_data_copy= tarantool_seek_0(&returned_result_set_type); /* "seek to row 0" */
  const char **tarantool_tnt_reply_data= &tarantool_tnt_reply_data_copy;

  /*
    If we found a name when we went through all the rows during tarantool_num_fields,
    then surely we will find it when we look a a single row.
    Therefore this pass will not add to the field name list, but will set addresses.
    That is: For each field in list of current row, we will mark as non-null in list of all rows.
  */
  for (v_r= 0; v_r < p_result_row_count; ++v_r)                                 /* second loop */
  {
    (*p_result_set_copy_rows)[v_r]= result_set_copy_pointer;
    //char *tmp_copy_pointer= result_set_copy_pointer;
    /* Form a field name list the same way you did in tarantool_num_fields */
    /* Initialize all addresses */
    for (int i= 0; i < field_name_list_all_rows.count(); ++i) field_name_list_all_rows_address[i]= NULL;
    {
      char field_name[TARANTOOL_MAX_FIELD_NAME_LENGTH];
      strcpy(field_name, TARANTOOL_FIELD_NAME_BASE);
      strcat(field_name, "_");

      int return_value= tarantool_num_fields_recursive(tarantool_tnt_reply_data,
                                                       field_name, 0,
                                                       &field_name_list_all_rows,
                                                       &field_name_list_all_rows_count,
                                                       &field_name_list_all_rows_address,
                                                       0);

      if (return_value < 0) return "tarantool_scan_rows: return_value < 0";
      //tarantool_tnt_reply_data_copy_end= tarantool_tnt_reply_data_copy;
    }

    /*
      At this point, field_name_list_all_rows* stuff has:
      field_name = name still as base name + numbers e.g. e.g. f_00001_00001,
      address = NULL or something we can mp_decode.
    */

    for (int i= 0; i < field_name_list_all_rows.count(); ++i) /* second field loop */
    {
      unsigned char field_type;
      const char *all_rows_address= field_name_list_all_rows_address[i];

      if (all_rows_address == 0) field_type= MP_NIL;
      else field_type= lmysql->ldbms_mp_typeof(*all_rows_address);

      if (field_type > MP_EXT) return "tarantool_scan_rows: field_type > MP_EXT";

      if ((field_type == MP_NIL) || (field_type == MP_ARRAY) || (field_type == MP_MAP))
      {
        /* Assumption: if MP_ARRAY or MP_MAP, size = 0. */
        if (sizeof(NULL_STRING) - 1 > (*p_result_max_column_widths)[i]) (*p_result_max_column_widths)[i]= sizeof(NULL_STRING) - 1;
        if (all_rows_address != 0) lmysql->ldbms_mp_next(&all_rows_address);
        memset(result_set_copy_pointer, 0, sizeof(unsigned int));
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_NULL;
        result_set_copy_pointer+= sizeof(unsigned int) + sizeof(char);
        continue;
      }
      const char *value;
      uint32_t value_length;
      char value_as_string[TARANTOOL_MAX_FIELD_NAME_LENGTH * 2]; /* must be big enough for any sprintf() result */
      if (field_type == MP_UINT)
      {
        uint64_t uint_value= lmysql->ldbms_mp_decode_uint(&all_rows_address);
        long long unsigned int llu= uint_value;
        value_length= sprintf(value_as_string, "%llu", llu);
        value= value_as_string;
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_NUMBER;
      }
      else if (field_type == MP_INT)
      {
        int64_t int_value= lmysql->ldbms_mp_decode_int(&all_rows_address);
        long long int lli= int_value;
        value_length= sprintf(value_as_string, "%lld", lli);
        value= value_as_string;
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_NUMBER;
      }
      else if (field_type == MP_STR)
      {
        value= lmysql->ldbms_mp_decode_str(&all_rows_address, &value_length);
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_STRING;
      }
      else if (field_type == MP_BIN)
      {
        value= lmysql->ldbms_mp_decode_bin(&all_rows_address, &value_length);
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_STRING;
      }
      else if (field_type == MP_BOOL)
      {
        bool bool_value= lmysql->ldbms_mp_decode_bool(&all_rows_address);
        if (bool_value == 0) {value_length= 5; strcpy(value_as_string, "FALSE"); }
        else                 {value_length= 4; strcpy(value_as_string, "TRUE"); }
        value= value_as_string;
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_OTHER;
      }
      else if (field_type == MP_FLOAT)
      {
        float float_value= lmysql->ldbms_mp_decode_float(&all_rows_address);
        value_length= sprintf(value_as_string, "%f", float_value);
        value= value_as_string;
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_NUMBER;
      }
      else if (field_type == MP_DOUBLE)
      {
        double double_value= lmysql->ldbms_mp_decode_double(&all_rows_address);
        value_length= sprintf(value_as_string, "%E", double_value);
        value= value_as_string;
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_NUMBER;
      }
      else if (field_type == MP_EXT)
      {
        unsigned char ext_field_type;
        value_length= tarantool_fetch_row_ext(all_rows_address, value_as_string, &ext_field_type);
        value= value_as_string;
        lmysql->ldbms_mp_next(&all_rows_address);
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_NUMBER;
#if (TARANTOOL_DATETIMES != 0)
       /* This is to prevent right-justification of datetime display. */
       if (ext_field_type == MP_DATETIME) *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_STRING;
#endif
      }
      else
      {
        /* it probably would be proper to assert() here */
        value_length= 0;
        value= "";
      }
      //if (value_length > (*p_result_max_column_widths)[i]) (*p_result_max_column_widths)[i]= value_length;
      rg->set_max_column_width(value_length, value, (&(*p_result_max_column_widths)[i]));
      memcpy(result_set_copy_pointer, &value_length, sizeof(unsigned int));
      result_set_copy_pointer+= sizeof(unsigned int) + sizeof(char);
      memcpy(result_set_copy_pointer, value, value_length);
      result_set_copy_pointer+= value_length;
    }
    /* I think tarantool_tnt_reply_data_copy should be pointing to next row after tarantool_num_fields_recursive */
  }
  /* Now that names are sorted, we can shorten them e.g. f_0001_0007_0001_0001 becomes f_7_1_1. */
  for (int i= 0; i < field_name_list_all_rows.count(); ++i)
  {
    char tmp[TARANTOOL_MAX_FIELD_NAME_LENGTH];
    QString s= field_name_list_all_rows.at(i);
    strcpy(tmp, s.toUtf8().data());
    char *c= &tmp[0];
    for (unsigned int j= strlen(TARANTOOL_FIELD_NAME_BASE); *(c + j) != '\0'; ++j)
    {
      if ((*(c + j) == '0') && (*(c + j - 1) == '_'))
      {
        unsigned int k;
        for (k= j + 1; *(c + k) != '\0'; ++k) *(c + k - 1)= *(c + k);
        *(c + k - 1)= '\0';
        --j;
      }
    }
    unsigned int j= strlen(TARANTOOL_FIELD_NAME_BASE);
    if ((*(c + j) == '_') && (*(c + j + 1) == '1'))
    {
      unsigned int k;
      for (k= j + 2; *(c + k) != '\0'; ++k) *(c + k - 2)= *(c + k);
      *(c + k - 2)= '\0';
    }
    field_name_list_all_rows[i]= tmp;
  }
  for (int i= 0; i < field_name_list_all_rows.count(); ++i) field_type_list_all_rows.insert(i, OCELOT_DATA_TYPE_VAR_STRING);

  /* Replace result-set arbitrary names with names from format strings */
  /* Replace result-set guessed types with types from format strings */
  if (returned_result_set_type == RESULT_TYPE_5)
  {
    QString fetch_header_row_result= tarantool_fetch_header_row();
    if (fetch_header_row_result != "OK") return fetch_header_row_result;
  }

  return "OK";
}


/*
  Re is_for_display:
  MySQL tells us "org_name" and "org_table" with the result set, but Tarantool doesn't.
  If you're coming from action_execute_one_statement() which called
  execute_real_query()+tarantool_real_query() before calling fillup() which called here, then
  you know that tarantool_real_query() happened and left you a table name and column names,
  which it figured out from the query.

  Todo: check: in tarantool_scan_field_names(), should I use
        sizeof(TARANTOOL_FIELD_NAME_BASE) or strlen(TARANTOOL_FIELD_NAME_BASE)?
*/

QString MainWindow::tarantool_scan_field_names(
               const char *which_field,

        unsigned int p_result_column_count,
               char **p_result_field_names,
        bool is_for_display)
{
  char tmp_table_name[128*3]; /* I hope this is safe, I discourage long-table-name nonsense. */

  if (is_for_display == true) strcpy(tmp_table_name, tarantool_table_name.toUtf8());
  else strcpy(tmp_table_name, "");

  unsigned int i;
  unsigned int v_lengths;
  /*
    First loop: find how much to allocate. Allocate. Second loop: fill in with pointers within allocated area.
  */
  unsigned int total_size= 0;
  char *result_field_names_pointer;

  for (i= 0; i < p_result_column_count; ++i)                                /* first loop */
  {
    total_size+= sizeof(unsigned int);
    if (strcmp(which_field, "name") == 0) total_size+= field_name_list_all_rows.at(i).length();
    else if (strcmp(which_field, "org_name") == 0) total_size+= field_name_list_all_rows.at(i).length();
    else if (strcmp(which_field, "org_table") == 0) total_size+= strlen(tmp_table_name);
    else /* if (strcmp(which_field, "db") == 0) */ total_size+= sizeof(TARANTOOL_FIELD_NAME_BASE);
  }
  *p_result_field_names= new char[total_size];                               /* allocate */

  result_field_names_pointer= *p_result_field_names;
  for (i= 0; i < p_result_column_count; ++i)                                 /* second loop */
  {
    if (strcmp(which_field, "name") == 0) v_lengths= field_name_list_all_rows.at(i).length();
    else if (strcmp(which_field, "org_name") == 0) v_lengths= field_name_list_all_rows.at(i).length();
    else if (strcmp(which_field, "org_table") == 0) v_lengths= strlen(tmp_table_name);
    else /* if (strcmp(which_field, "db") == 0) */ v_lengths= sizeof(TARANTOOL_FIELD_NAME_BASE);
    memcpy(result_field_names_pointer, &v_lengths, sizeof(unsigned int));
    if (v_lengths >= TARANTOOL_MAX_FIELD_NAME_LENGTH) return "Field Name Too Long";
    result_field_names_pointer+= sizeof(unsigned int);
    char tmp_field_name[TARANTOOL_MAX_FIELD_NAME_LENGTH * 2];
    QString s= field_name_list_all_rows.at(i);
    strcpy(tmp_field_name, s.toUtf8().data());
    if (strcmp(which_field, "name") == 0) memcpy(result_field_names_pointer, tmp_field_name, v_lengths);
    else if (strcmp(which_field, "org_name") == 0) memcpy(result_field_names_pointer, tmp_field_name, v_lengths);
    else if (strcmp(which_field, "org_table") == 0) memcpy(result_field_names_pointer, tmp_table_name, v_lengths);
    else /* if (strcmp(which_field, "db") == 0) */ memcpy(result_field_names_pointer, TARANTOOL_FIELD_NAME_BASE, v_lengths);
    result_field_names_pointer+= v_lengths;
  }
  return "OK";
}

//void MainWindow::tarantool_close()
//{
//lmysql->ldbms_tnt_close(tnt);
//lmysql->ldbms_tnt_stream_free(tuple);
//lmysql->ldbms_tnt_stream_free(tnt);
//}

#endif

#ifdef DBMS_TARANTOOL
/*
  Handle CREATE [TEMPORARY] TABLE table-name SERVER server-name
   {LUA 'expression'} | {RETURN lua-expression};
  We want to exeute the lua-expression on the remote server created
  with CREATE SERVER. This is going to be complicated.
  The 'expression' must cause return a result set.
  Do a fillup.
  From the result set, we can figure out field names and types.
  So that tells us how to CREATE TABLE table-name (...) on main.
  Then we can INSERT INTO table-name VALUES (result-set values);
  Todo: There are other things we could do, e.g. SELECT from remote.
  Todo: It would be better to check for LUA|RETURN when parsing.
*/
int MainWindow::create_table_server(QString text,
                                         bool *is_create_table_server,
                                         unsigned int passed_main_token_number,
                                         unsigned int passed_main_token_count_in_statement)
{
  *is_create_table_server= false;
  /* Quick search -- if there is no SERVER id clause, get out now. */

  bool is_create= false;
  unsigned int i_of_table= 0;
  unsigned int i_of_server= 0;
  unsigned int i_of_server_id= 0;
  unsigned int i_of_literal= 0;
  unsigned int i_of_lua= 0;
  unsigned int i_of_return= 0;
  for (unsigned int i= passed_main_token_number; i < passed_main_token_number + passed_main_token_count_in_statement; ++i)
  {
    if ((main_token_types[i] >= TOKEN_TYPE_COMMENT_WITH_SLASH)
     && (main_token_types[i] <= TOKEN_TYPE_COMMENT_WITH_MINUS))
      continue;
    if (main_token_types[i] == TOKEN_KEYWORD_CREATE)
    {
      is_create= true;
    }
    if (is_create == false) break;
    if (main_token_types[i] == TOKEN_KEYWORD_TABLE)
    {
      i_of_table= i;
    }
    if ((main_token_types[i] == TOKEN_KEYWORD_SERVER)
     && (i_of_table > 0))
    {
      i_of_server= i;
    }
    if (i_of_server > 0)
    {
      if (main_token_reftypes[i] == TOKEN_REFTYPE_SERVER)
      {
        i_of_server_id= i;
      }
      if (main_token_types[i] == TOKEN_KEYWORD_LUA)
      {
        i_of_lua= i;
      }
      if (main_token_types[i] == TOKEN_KEYWORD_RETURN)
      {
        i_of_return= i;
      }
      if ((main_token_types[i] <= TOKEN_TYPE_LITERAL)
       && (main_token_types[i] >= TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE))
      {
        i_of_literal= i;
      }
    }
  }

  if (i_of_server == 0) return 0;

  *is_create_table_server= true;

  if (tarantool_server_name == "")
  {
    /* "CREATE TABLE ... SERVER fails, CREATE SERVER not done?" */
    make_and_put_message_in_result(ER_CREATE_SERVER, 0, (char*)"");
    return 1;
  }
  {
    QString s;
    if (i_of_server_id == 0) s= "";
    else s= text.mid(main_token_offsets[i_of_server_id], main_token_lengths[i_of_server_id]);
    if (QString::compare(s, tarantool_server_name, Qt::CaseSensitive) != 0)
    {
      /* "CREATE TABLE ... SERVER fails, server id <> CREATE SERVER id\n" */
    make_and_put_message_in_result(ER_CREATE_SERVER, 0, (char*)"");
    return 1;
    }
  }

  if ((i_of_literal == 0) && (i_of_lua != 0))
  {
    /* "CREATE TABLE ... SERVER fails, blank literal\n" */
    make_and_put_message_in_result(ER_EMPTY_LITERAL, 0, (char*)"");
    return 1;
  }

  /* Todo: There should be a separate error message for this ... */
  if (i_of_server_id == 0)
  {
    /* "CREATE TABLE ... SERVER fails, blank literal\n" */
    make_and_put_message_in_result(ER_EMPTY_LITERAL, 0, (char*)"");
    return 1;
  }

  /* Todo: There should be a separate error message for this ... */
  if ((i_of_lua == 0) && (i_of_return == 0))
  {
    /* "CREATE TABLE ... SERVER fails, blank literal\n" */
    make_and_put_message_in_result(ER_EMPTY_LITERAL, 0, (char*)"");
    return 1;
  }

  QString q;
  unsigned int new_passed_main_token_number;
  unsigned int new_passed_main_token_count_in_statement;
  if (i_of_lua == 0)
  {
    unsigned int m= passed_main_token_number + passed_main_token_count_in_statement;
    q= text.mid(main_token_offsets[i_of_return],
                main_token_offsets[m - 1] + main_token_lengths[m - 1] - main_token_offsets[i_of_return]);
    new_passed_main_token_number= i_of_server_id + 1;
    new_passed_main_token_count_in_statement= passed_main_token_count_in_statement - (i_of_return);
  }
  else
  {
    q= text.mid(main_token_offsets[i_of_lua],
                main_token_offsets[i_of_literal] + main_token_lengths[i_of_literal] - main_token_offsets[i_of_lua]);
    new_passed_main_token_number= i_of_lua;
    /* Todo: Check: why i_of_literal? */
    new_passed_main_token_count_in_statement= i_of_literal;
  }
  QString read_format_result= tarantool_read_format(q);
  int result;
  ResultGrid *rg= new ResultGrid(lmysql, this, false, 0);
  for (;;)
  {
    result=
    tarantool_real_query(q.toUtf8(),
                         q.toUtf8().size(),
                         MYSQL_REMOTE_CONNECTION,
                         new_passed_main_token_number,
                         new_passed_main_token_count_in_statement,
                         &q);
    if (result != 0)
    {
      put_diagnostics_in_result(MYSQL_REMOTE_CONNECTION, DIAGNOSTIC_0);
      break;
    }
    /* CREATE TABLE y4 SERVER id LUA 'box.space._space:select()'; crashed */
    {
      long unsigned int r;
      int result_set_type;
      tarantool_result_set_init(MYSQL_REMOTE_CONNECTION, &r, &result_set_type);
      if ((result_set_type) == RESULT_TYPE_0 || (result_set_type == RESULT_TYPE_1))
      {
        tarantool_errno[MYSQL_MAIN_CONNECTION]= 9999;
        result= 9999;
        strcpy(tarantool_errmsg, "No result set");
        put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
        break;
      }
      if (r == 0)
      {
        tarantool_errno[MYSQL_MAIN_CONNECTION]= 9999;
        result= 9999;
        strcpy(tarantool_errmsg, "Empty result set");
        put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
        break;
      }
    }

    /* TODO: I'd be much happier if we didn't fool with existing result copy (NOW THAT IS A BUG!!!) */
    /* TODO: Check for an error return from fillup(). */
    //rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(0));
    rg->fillup(mysql_res,
              //&tarantool_tnt_reply,
              connections_dbms[MYSQL_REMOTE_CONNECTION],
              //this,
              lmysql, ocelot_ca.client_side_functions,
              MYSQL_REMOTE_CONNECTION,
              false);
    /* TODO: Get field names and data types from fillup!! */
    QString create_table_statement=
    text.mid(main_token_offsets[passed_main_token_number],
             main_token_offsets[i_of_server] - main_token_offsets[passed_main_token_number]);
    /* Pass "CREATE TABLE table-name", fill in (field-names) + execute */
    result= rg->creates(create_table_statement, connections_dbms[MYSQL_MAIN_CONNECTION], read_format_result);
    if (result != 0)
    {
      put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
      break;
    }
    QString temporary_table_name=
            text.mid(main_token_offsets[i_of_table] + main_token_lengths[i_of_table],
                     main_token_offsets[i_of_server] - (main_token_offsets[i_of_table] + main_token_lengths[i_of_table]));
    /* INSERT INTO [temporary_table_name] VALUES (...); */
    result= rg->inserts(temporary_table_name);
    if (result != 0)
    {
      put_diagnostics_in_result(MYSQL_MAIN_CONNECTION, DIAGNOSTIC_0);
      break;
    }
    break;
  }
  /* Todo: Now destroy the temporary tables? (What temporary tables?) */
  delete rg;
  return result;
}
#endif

#ifdef DBMS_TARANTOOL
/*
  Pass: lua_request which might contain space_name.
  Read the _space tuple for space_name. Example:
  - [514,                                                                   -- id
     1,                                                                     -- owner
     'y1',                                                                  -- name
     'memtx',                                                               -- engine
     2,                                                                     -- field_count
     {'sql': 'CREATE TABLE y1 (f_1 VARCHAR(5) PRIMARY KEY,f_2 BIGINT )'},   -- flags
     [{'name': 'f_1', 'type': 'scalar'},                                    -- format
      {'name': 'f_2', 'type': 'scalar'}]]
  We care about the format field. It might be blank i.e. [].
  If it is not blank, we want to use the list of names.
  This is for create_table_server i.e. CREATE TABLE ... SERVER ... LUA '...';
  It only works if the Lua request looks like box.space.space-name:select().
  The list might not be complete.
  Compare tarantool_internal_query()
  Returns e.g. [1]id[2]owner[3]name[4]engine[5]field_count[6]flags[7]format
  Todo: the loop calls the server once per field! Fix this real soon, eh?
  Todo: someday use the types too.
  Todo: use for any SELECT from a single table, or box.space.space_name:select()
*/
QString MainWindow::tarantool_read_format(QString lua_request)
{
  QString read_format_result= "";
  QString word= "";
  /* e.g. from LUA 'box.space.t:select()' find 't' */
  /* Todo: this doesn't allow for whitespace */
  int word_start= lua_request.indexOf("box.space.", 0);
  if (word_start == -1) return "";
  word_start+= strlen("box.space.");
  int word_end= lua_request.indexOf(":", word_start);
  if (word_end == -1) return "";
  word= lua_request.mid(word_start, (word_end - word_start));
  for (int i= 1; i < 10; ++i)
  {
    char i_str[10];
    sprintf(i_str, "%d", i);
    QString request= "return box.space._space.index.name:select('"
                     + word
                     + "')[1][7]["
                     + i_str
                     + "].name";
    char tmp[1024];
    strcpy(tmp, request.toUtf8());
    QString result= tarantool_internal_query(tmp, MYSQL_REMOTE_CONNECTION);
    if (result == "") break;
    read_format_result= read_format_result + "[" + i_str + "]" + result;
  }
  return read_format_result;
}
#endif

/*
  log() may be useful for debugging if the program is acting strangely.
  * We do not use printf() ordinarily, but if level > ocelot_ca.log_level,  we printf(message).
    Thus level is a priority, ocelot_ca.log_level is a threshold, to increase the chance that a
    particular message will appear we increase level, to increase the chance that any message
    will appear we decrease ocelot_ca.log_level.
  * We also fflush(stdout) which is usually unnecessary (messages
    are printed with "\n") unless stdout has been redirected to a file.
  * ocelot_ca.log_level default value = 100, can be changed with --ocelot_log_level==N.
  * Re QElapsedTimer:
    We also printf(seconds-since-last-printf) based on a so-called nanoseconds count.
    Of course it's not really nanoseconds and sometimes it's based on ticks or milliseconds.
    So printf doesn't really say anything with %.9f especially since printf itself takes so much time.
    If this is never used, then #include #include <QElapsedTimer> can be removed from ocelotgui.h.
  Undocumented: if level == 1000, show part of statement_edit_widget html.
                see https://github.com/tarantool/doc/issues/1835
                Initially I tried toHtml() but it requires too much massaging
                Works better if connected because e.g. otherwise ansi_quotes might be wrong.
  Todo: consider using stderr or a named file.
  Todo: attach a timer or counter so printf occurs if dangers exist.
  Todo: consider using a bit mask instead of a greater-than comparison.
        or, a system with definitions, e.g. 10=trivial, 20=unusual,
        30=surprising, 200=pseudo-assertion
  Todo: consider making this a macro so invocation is easier.
*/
void MainWindow::log(const char *message, int level)
{
  if (ocelot_ca.log_level == 1000)
  {
    if (level == 1000)
    {
      QString indenter= QString(" ").repeated(ocelot_statement_format_statement_indent.toInt());
      QString s_in= statement_edit_widget->toPlainText();
      QString s_out= indenter + "<p style='font-family:monospace; white-space:pre;'>\n" + indenter;
      QTextCursor text_cursor= statement_edit_widget->textCursor();
      text_cursor.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor);
      QString last_color= "";
      int ii= 0;
      bool is_in_span= false;
      while(text_cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::MoveAnchor))
      {
        QTextCharFormat text_cursor_format = text_cursor.charFormat();
        QString this_color= text_cursor_format.foreground().color().name();
        this_color= rgb_to_color(this_color).toLower();
        QString m= s_in.mid(ii, 1);
        QChar c= m.at(0);
        if ((c.isPrint() == true) && (c.isSpace() == false))
        {
          if (this_color != last_color)
          {
            if (is_in_span == true) s_out.append("</span>");
            s_out.append("<span style=\"color:"); s_out.append(this_color); s_out.append("\">");
            last_color= this_color;
            is_in_span= true;
          }
        }
        s_out.append(m);
        if (c == QChar(10)) s_out.append(indenter);
        ++ii;
      }
      if (is_in_span == true) s_out.append("</span>");
      s_out.append("</p>");
      char *tmp= new char[s_out.size() * 3 + 1];
      strcpy(tmp, s_out.toUtf8());
      printf("\n.. raw:: html\n\n");
      printf("%s\n\n", tmp);
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
      fflush(stdout);
#endif
      delete []tmp;
      return;
    }
  }
  if (level == 1000) return;
  static QElapsedTimer* timer;
  static long int elapsed_nanoseconds= 0;
  if (level > ocelot_ca.log_level)
  {
    long int new_elapsed_nanoseconds;
    double seconds;
    if (elapsed_nanoseconds == 0)
    {
      timer= new QElapsedTimer(); /* Todo: this leaks. destroy it eventually. */
      timer->start();
    }
    new_elapsed_nanoseconds= timer->nsecsElapsed();
    seconds= new_elapsed_nanoseconds - elapsed_nanoseconds;
    seconds= seconds / 1000000000;
    printf("%s %.9f\n", message, seconds);
    elapsed_nanoseconds= new_elapsed_nanoseconds;
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
    fflush(stdout);
#endif
  }
}

/*
  Context Menu
  Usually caused by right-click on a widget but we do not try to
  assume that by intercepting a Qt::RightButton event, it might be Menu key.
  https://doc.qt.io/archives/qt-4.8/qcontextmenuevent.html
  * When we start we say
    statement_edit_widget->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(this, SIGNAL(customContextMenuRequested(const QPoint &)),
        statement_edit_widget, SLOT(menu_context(const QPoint &)));
    etc.
    For ResultGrid we do this in ocelotgui.h during client initiation, before making the cell pool,
    so that TextEditFrame will inherit the policy (and it does).
  * We don't want the default context menu. I tried to turn it off by calling
    setContextMenuPolicy(Qt::PreventContextMenu); in TextEditFrame::TextEditFrame(),
    and in MainWindow, but failed. However, I succeeded with the method I'm using now.
  * In ocelotgui.h we have public slots: menu_context().
  * TIP? itemAt(pos) might tell you where right click happened, else you might need special measures.
  * Todo: pass QContextMenuEvent::Reason too?
  * Todo: I wish we could just connect for MainWindow and inherit, but I couldn't get that to work.
          Now we're only setting policy and connecting for
          result grid, + history_edit_widget, + statement_edit_widget, + TextEditWidget
          and not debug or line or texteditframe|textedwidget.
  * Todo: mapToGlobal(pos) is nearly okay but the menu is slightly to the left of the cursor.
          And, since we get here for all widgets not just statement_edit_widget, it can be way off.
  * Todo: This is not really a custom or in-context menu, we just show the menu that we'd see if we
    clicked Menu|Edit. We re-use menu_edit rather than making a new QMenu. This seems to work
    but I've not seen a definite statement that it is supposed to work.
  * Todo: Meanwhile html_text_edit has a public slot menu_context_t which calls menu_context_t_2
    which calls here. Probably more jumps than needed, eh? Anyway, at the time we call, we
    know exactly which cell the cursor is on, and we know it's result grid not statement_edit_widget,
    so considerable improvement is possible for that.
*/
void MainWindow::menu_context(const QPoint &pos)
{
  QMenu* menu_edit= menu_spec_find_menu("menu_edit");
  if (menu_edit != NULL) menu_edit->exec(statement_edit_widget->mapToGlobal(pos));
}

/******************** typer start ***********************************************/
/*
  We want a list of data types as numbers, corresponding to a list of data types as strings.
  Used for conditional_setting_evaluate() comparisons of column_type.
  2023-09-21 I changed so OCELOT_DATA_TYPE_LONG corresponds to 'INTEGER'. MySQL/MariaDB LONG is crazy stuff:
    * The corresponding C type is not long but int
    * If you say CREATE TABLE t (s1 LONG); you get MEDIUMTEXT
    * See also https://jira.mariadb.org/browse/MDEV-16347
    ... Also I changed so OCELOT_DATA_TYPE_LONGLONG corresponds to 'BIGINT'.
    ... Also I changed so OCELOT_DATA_TYPE_SHORT corresponds to 'SMALLINT'.
    ... Also I changed so OCELOT_DATA_TYPE_INT24 corresponds to 'MEDIUMINT'.
*/
struct typer {
   unsigned int ocelot_data_type;
   unsigned int keyword_data_type;
};
static const typer typer_list[]=
{
    {OCELOT_DATA_TYPE_DECIMAL, TOKEN_KEYWORD_DECIMAL},
    {OCELOT_DATA_TYPE_TINY, TOKEN_KEYWORD_TINYINT},
    {OCELOT_DATA_TYPE_SHORT, TOKEN_KEYWORD_SMALLINT},
    {OCELOT_DATA_TYPE_LONG, TOKEN_KEYWORD_INTEGER},
    {OCELOT_DATA_TYPE_FLOAT, TOKEN_KEYWORD_FLOAT},
    {OCELOT_DATA_TYPE_DOUBLE, TOKEN_KEYWORD_DOUBLE},
    {OCELOT_DATA_TYPE_NULL, TOKEN_KEYWORD_NULL},
    {OCELOT_DATA_TYPE_TIMESTAMP, TOKEN_KEYWORD_TIMESTAMP},
    {OCELOT_DATA_TYPE_LONGLONG, TOKEN_KEYWORD_BIGINT},
    {OCELOT_DATA_TYPE_INT24, TOKEN_KEYWORD_MEDIUMINT},
    {OCELOT_DATA_TYPE_DATE, TOKEN_KEYWORD_DATE},
    {OCELOT_DATA_TYPE_TIME, TOKEN_KEYWORD_TIME},
    {OCELOT_DATA_TYPE_DATETIME, TOKEN_KEYWORD_DATETIME},
    {OCELOT_DATA_TYPE_YEAR, TOKEN_KEYWORD_YEAR},
    {OCELOT_DATA_TYPE_BIT, TOKEN_KEYWORD_BIT},
    {OCELOT_DATA_TYPE_JSON, TOKEN_KEYWORD_JSON},
    {OCELOT_DATA_TYPE_NEWDECIMAL, TOKEN_KEYWORD_DECIMAL},
    {OCELOT_DATA_TYPE_ENUM, TOKEN_KEYWORD_ENUM},
    {OCELOT_DATA_TYPE_SET, TOKEN_KEYWORD_SET},
    {OCELOT_DATA_TYPE_TINY_BLOB, TOKEN_KEYWORD_BLOB},
    {OCELOT_DATA_TYPE_MEDIUM_BLOB, TOKEN_KEYWORD_BLOB},
    {OCELOT_DATA_TYPE_LONG_BLOB, TOKEN_KEYWORD_BLOB},
    {OCELOT_DATA_TYPE_BLOB, TOKEN_KEYWORD_BLOB},
    {OCELOT_DATA_TYPE_VAR_STRING, TOKEN_KEYWORD_STRING},
    {OCELOT_DATA_TYPE_STRING, TOKEN_KEYWORD_STRING},
    {OCELOT_DATA_TYPE_GEOMETRY, TOKEN_KEYWORD_GEOMETRY},
    {OCELOT_DATA_TYPE_BINARY, TOKEN_KEYWORD_BINARY},
    {OCELOT_DATA_TYPE_VARBINARY, TOKEN_KEYWORD_VARBINARY},
    {OCELOT_DATA_TYPE_TEXT, TOKEN_KEYWORD_TEXT},
    {OCELOT_DATA_TYPE_SCALAR, TOKEN_KEYWORD_SCALAR},
    {OCELOT_DATA_TYPE_BOOLEAN, TOKEN_KEYWORD_BOOLEAN},
    {OCELOT_DATA_TYPE_MAP, TOKEN_KEYWORD_MAP},
    {OCELOT_DATA_TYPE_ARRAY, TOKEN_KEYWORD_ARRAY},
    {OCELOT_DATA_TYPE_INTEGER, TOKEN_KEYWORD_INTEGER},
    {OCELOT_DATA_TYPE_UNSIGNED, TOKEN_KEYWORD_UNSIGNED},
    {OCELOT_DATA_TYPE_NUMBER, TOKEN_KEYWORD_NUMBER},
    {0, 0}
};

/*
  Pass: string with a data type. Return: OCELOT_DATA_TYPE_xxx
  This works, but for now we use the slightly cheaper-looking
  if ((value_length == 7) && (memcmp(value, "integer", 7) == 0)) field_type_list_all_rows[field_number]= OCELOT_DATA_TYPE_LONG;
  etc. So for now it's commented out, it's "in reserve".
*/
//int MainWindow::typer_to_ocelot_data_type(char *s)
//{
//  char key2[MAX_KEYWORD_LENGTH + 1];
//  int keyword_index;
//  keyword_index= get_keyword_index(s, key2);
//  for (int i= 0; ; ++i)
//  {
//    if (typer_list[i].keyword_data_type == 0) break;
//    if (typer_list[i].keyword_data_type == (unsigned int)keyword_index)
//    {
//      printf("**** match! %d\n", typer_list[i].ocelot_data_type);
//      return typer_list[i].ocelot_data_type;
//    }
//  }
//  return OCELOT_DATA_TYPE_NULL;
//}

char * MainWindow::typer_to_keyword(unsigned int ocelot_type)
{
  for (int i= 0; ;++i)
  {
    if (typer_list[i].keyword_data_type == 0) break;
    if (typer_list[i].ocelot_data_type == ocelot_type)
    {
      int k= typer_list[i].keyword_data_type;
      return (char*)strvalues[k].chars;
    }
  }
  return (char*)strvalues[TOKEN_KEYWORD_NULL].chars;
}

/* Return true iff keyword identified one of the integer data types. Currently only used during parse. */
bool MainWindow::typer_is_int(int key)
{
  if ((key == TOKEN_KEYWORD_BIGINT)
   || (key == TOKEN_KEYWORD_BIT)
   || (key == TOKEN_KEYWORD_BOOL)
   || (key == TOKEN_KEYWORD_BOOLEAN)
   || (key == TOKEN_KEYWORD_INT)
   || (key == TOKEN_KEYWORD_INT1)
   || (key == TOKEN_KEYWORD_INT2)
   || (key == TOKEN_KEYWORD_INT3)
   || (key == TOKEN_KEYWORD_INT4)
   || (key == TOKEN_KEYWORD_INT8)
   || (key == TOKEN_KEYWORD_INTEGER)
   || (key == TOKEN_KEYWORD_MEDIUMINT)
   || (key == TOKEN_KEYWORD_SMALLINT)
   || (key == TOKEN_KEYWORD_TINYINT))
    return true;
  return false;
}

/******************** typer end ***********************************************/

#include "codeeditor.h"

/******************** completer_widget start ************************************/

/*
  The hint list box that appears (hopefully underneath the statement widget) if syntax error,
  which probably means that the user is typing and hasn't finished a word.
  This is somewhat like a popup but using "Qt::Popup" caused trouble. We don't want modal.
  Warning: We can call this without going via hparse_f_multi_block() and before calling dbms_version_mask()
  Re class = subclass of QTextEdit:
    Originally it was a subclass of QListWidget and that worked well enough with Ubuntu 18 + Qt 5.9,
    but worked very poorly with Fedora 32 + Qt 5.13, the size was too small and the reported size was false.
  Re timer:
    We hide the widget after ocelot_ca.completer_timeout, default = 10 (seconds). Todo: check what normal amount is.
    We should reset the timer (by stopping and starting it) if there is activity either in statement_edit_widget or completer_widget
    Todo: if user says SET ocelot_completer_timeout=0; interpret that as: disable the widget.
  Todo: some sort of in-context help if --i-am-a-dummy or menu = Help
        users are supposed to know that Tab will complete, down-arrow will navigate, timeout is 10 seconds,
  * Possible experiments with flags:
    Tried Qt::Dialog and Qt::Window, they cause trouble
    Try Qt::CustomizeWindowHint |  Qt::Tool | Qt::WindowDoesNotAcceptFocus | Qt::FramelessWindowHint
    setWindowFlags must follow setParent, otherwise hide() will not be totally reversed by show()
  * todo: maybe it should be initially hidden
  Unusually main_window will not be the parent, we call setParent(p->statement_edit_widget);.
  todo: references to main_window->statement_edit_widget are a bit convoluted since it is the parent.
  todo: there's no point in Completer_widget if we aren't recognizing, in that case make sure it's suppressed
  Re eventfilter_function:
    Checks for key_up or key_down events and calls key_up_or_down().
    Could check for MousePressEvent and hide completer_widget -- the idea is that for a tooltip | popup if one clicks
    outside the tooltip then the tooltip disappears. But there's no point checking within eventfilter function because
    if you click outside statement_edit_widget then it loses focus and then completer_widget gets hidden anyway,
    and if you click inside statement_edit_widget then eventfilter_function won't notice. The real solution would be to
    put a MousePressEvent function in codeeditor.
  Todo: Some inputs we don't handle well: right-click, select-all + copy, ctrl-+ ctrl--
*/

Completer_widget::Completer_widget() /* constructor */
{
  timer= NULL; main_window= NULL; current_row= associated_widget_type= 0; /* todo: move constructor() code to here */
}

/* call from constructor */
/* Todo: you could just put the constructor here, same as what you do with TextEditFrame::TextEditFrame */
/*
  Warning: QStringList QList etc. are "implicitly shared" classes https://doc.qt.io/qt-5/implicit-sharing.html
           I have only slight experience with this concept and might be initializing wrong.
           Supposedly the private area never shrinks; maybe I should try occasional delete + recreate of whole Completer_widget.
*/
void Completer_widget::construct(MainWindow *m)
{
  main_window= m;
  setParent(main_window->statement_edit_widget); /* This can change during initialize() */
  setWindowFlags(Qt::WindowStaysOnTopHint);
  timer= new QTimer(this);
  timer->setSingleShot(true);
  set_timer_interval();
  current_row= 0;
  string_list= QStringList();        /* Qt default constructors create empty lists but I worry anyway. */
  string_list_tooltips= QStringList();
  token_type_list= QList<int> ();
  setReadOnly(true);
  QObject::connect(timer, SIGNAL(timeout()), this, SLOT(timer_expired(void)));
}

/* todo: replace this with QStringList::join()? or do appends to QTextEdit so you're sure there are blocks? */
void Completer_widget::copy_string_list()
{
  QString s= "";
  for (int i= 0; i < string_list.size(); ++i)
  {
    s= s + string_list.at(i) + "\n";
  }
  setText(s);
}

void Completer_widget::set_timer_interval()
{
  timer->setInterval(ocelot_ca.completer_timeout * 1000);
}

/*
  Saying completer_widget->hide() ... completer_widget->show() used to be tricky ... the widget would disapper.
  Now that seems to be solved but let us leave these in as wrappers and not call hide() or show() directly.
*/
/* call when list widget size == 0 (due to clear, probably) (but also if you append and there are no candidates) */
/* call when statement edit widget loses focus, except when the focus is going to be completer_widget */
/* call after an interval, maybe there must be a timer */
void Completer_widget::hide_wrapper()
{
  timer->stop();
  hide();
  main_window->menu_set_enabled("action_edit_autocomplete", false);
}


/*
  call when adding something
  Todo: We decide here that we won't show if statement_edit_widget is empty.
        But we could show if it seemed worthwhile.
        And maybe there's a quicker way to know if it is empty.
  Todo: Merge with updater() if that is the only thing that calls show_wrapper().
*/
void Completer_widget::show_wrapper()
{
  if (main_window->statement_edit_widget->document()->isEmpty()) return;
  line_colors(associated_widget_type);
  show();
  timer_reset(); /* although timer->stop((); is maybe unnecessary */
  main_window->menu_set_enabled("action_edit_autocomplete", true);
}

/* Similar to something in codeeditor.h
   Todo: With explorer_widget and result_of_evaluate == true, changes to text_color and background_color go okay,
         but setFont() fails with the QFont that I get from get_font_from_style_sheet().
         So insert html? Or the answer might be hinted at in
         https://stackoverflow.com/questions/39531626/qtextedit-update-single-qtextcharformat
*/
void Completer_widget::line_colors(int associated_widget_type)
{
  QList<QTextEdit::ExtraSelection> extraSelections;
  QTextCursor tc= textCursor();
  tc.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor, 1);
  QColor line_color;
  for (int i= 0; i < count_wrapper(); ++i)
  {
    if (i != 0) tc.movePosition(QTextCursor::NextBlock, QTextCursor::MoveAnchor, 1);
    setTextCursor(tc);
    QTextEdit::ExtraSelection selection;
    int flags= 0;
    bool result_of_evaluate= false;
    QString cs_new_style_sheet;
    QTextCharFormat format_of_current_token;
    QString cs_new_tooltip;
    QString cs_new_cell_height;
    QString cs_new_cell_width;
    QString cs_new_text;
    int returned_cs_number;
    QString style_string= main_window->ocelot_explorer_style_string;
    QString string= string_list.at(i);
    if (associated_widget_type == EXPLORER_WIDGET)
    {
      /* Todo: Stripping lead+trail spaces does not remove a shortcut. Should we remove shortcuts? */
      string= string.trimmed();
      QByteArray string_utf8= string.toUtf8();
      result_of_evaluate= main_window->explorer_widget->conditional_setting_evaluate_till_true(
                                          1,           /* i.e. result set column number */
                                          1,       /* e.g. text_frame->ancestor_grid_result_row_number */
                                          string_utf8.data(),       /* e.g. text_frame->content_pointer */
                                          0,          /* e.g. FIELD_VALUE_FLAG_IS_NULL */
                                          string_utf8.size(), /* e.g. text_frame->content_length */
                                          TEXTEDITFRAME_CELL_TYPE_DETAIL,  /* e.g. text_frame->cell_type */
                                          &cs_new_tooltip,        /* return */
                                          &cs_new_style_sheet,    /* return */
                                          &cs_new_cell_height,    /* return */
                                          &cs_new_cell_width,     /* return */
                                          &returned_cs_number,
                                          &cs_new_text,           /* return */
                                          NULL);
      if (result_of_evaluate == true)
      {
        style_string= cs_new_style_sheet;
      }
    }
    if (associated_widget_type == STATEMENT_WIDGET)
    {
      int token_type= token_type_list.at(i);
      format_of_current_token= main_window->get_format_of_current_token(token_type, flags, "");
    }
    else /* EXPLORER_WIDGET -- but unfortunate, since statement choices allow customizing depending on type */
    {
      if (result_of_evaluate == true)
      {
        QString color= main_window->get_color_from_style_sheet(style_string);
        format_of_current_token.setForeground(QColor(color));
      }
      else
      {
        format_of_current_token.setForeground(QColor(main_window->qt_color(main_window->ocelot_explorer_text_color)));
      }
    }
    line_color= format_of_current_token.foreground().color();
    selection.format.setForeground(line_color);
    selection.format.setProperty(QTextFormat::FullWidthSelection, true);
    selection.cursor= textCursor();
    selection.cursor.clearSelection();
    extraSelections.append(selection);
    setExtraSelections(extraSelections);

    bool is_enabled= true;
    if (associated_widget_type == EXPLORER_WIDGET)
    {
      int i_of_cmi= i_of_cmi_of_text(string);
      if (i_of_cmi != -1)
      {
        QString e= main_window->explorer_widget->html_text_edit->explorer_context_menu->cmi[i_of_cmi].enabled;
        if (e == "no") is_enabled= false;
      }
    }
    if (is_enabled == false) line_color= Qt::lightGray;
    else
    {
      if (i != current_row)
      {
        if (associated_widget_type == STATEMENT_WIDGET)
          line_color= QColor(main_window->ocelot_statement_background_color);
        else /* EXPLORER_WIDGET */
        {
          if (result_of_evaluate == true)
          {
            line_color= main_window->get_background_color_from_style_sheet(style_string);
          }
          else
            line_color= QColor(main_window->ocelot_explorer_background_color);
        }
      }
      else
      {
        line_color= QColor(main_window->ocelot_statement_highlight_current_line_color).lighter(160);
      }
    }
    selection.format.setBackground(line_color);
    selection.format.setProperty(QTextFormat::FullWidthSelection, true);
    selection.cursor= textCursor();
    selection.cursor.clearSelection();
    extraSelections.append(selection);
    setExtraSelections(extraSelections);
  }
  tc.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor, 1);
  setTextCursor(tc);
}

/*
  Called from: line_colors() but probably interesting elsewhere
  We want to know whether an item the explorer context menu is matched with a cmi that has enabled = 'no'.
  Warning: the menu text can include the shortcut, which you don't want to compare.
*/
int Completer_widget::i_of_cmi_of_text(QString string)
{
  QString trimmed_string= string.trimmed();
  int cmi_count= main_window->explorer_widget->html_text_edit->explorer_context_menu->cmi_count;
  for (int i= 0; i < cmi_count; ++i)
  {
    QString t= main_window->explorer_widget->html_text_edit->explorer_context_menu->cmi[i].text;
    QString s= main_window->explorer_widget->html_text_edit->explorer_context_menu->cmi[i].shortcut;
    if ((s != "") && (trimmed_string.contains(s)))
    {
      int shortcut_length= s.length();
      trimmed_string= trimmed_string.left(trimmed_string.length() - shortcut_length);
      trimmed_string= trimmed_string.trimmed();
    }
    if (t == trimmed_string) return i;
  }
  return -1;
}

/*
  call when statement_edit_widget stylesheet change
  we could use something different from the statement_edit_widget style string, but I haven't seen a reason
  todo: check: I think explorer style sheet is also being set up outside the initialize
*/
void Completer_widget::initialize(int w)
{
  associated_widget_type= w; /* either STATEMENT_WIDGET or EXPLORER_WIDGET */
  if (associated_widget_type == STATEMENT_WIDGET)
  {
    setParent(main_window->statement_edit_widget);
    setWindowFlags(Qt::WindowStaysOnTopHint);
    setStyleSheet(main_window->ocelot_statement_style_string);
  }
  else /* EXPLORER_WIDGET */
  {
    if (main_window->ocelot_explorer_detached == "no") setParent(main_window);
    else setParent(main_window->explorer_widget);
    setWindowFlags(Qt::WindowStaysOnTopHint);
    setStyleSheet(main_window->ocelot_explorer_style_string);
  }
  /* TODO: WHAT SHOULD WE REALLY USE FOR EXPLORER? */
  size_and_position_change();
}

void Completer_widget::clear_wrapper()
{
  string_list.clear();
  string_list_tooltips.clear();
  token_type_list.clear();
  current_row= 0;
  hide_wrapper();
}

int Completer_widget::count_wrapper()
{
  return string_list.count();
}

/* todo: I suppose you'll need some error check although it's impossible that there are no selected items */
QString Completer_widget::get_selected_item(QString *tool_tip)
{
  *tool_tip= string_list_tooltips.at(current_row);
  return string_list.at(current_row);
}

/*
  Allow just enough size for Completer_widget, in the best possible location within statement_edit_widget.
  This is so that the list won't have a bunch of blank lines, and might have a vertical scroll bar.
  Re scroll bars:
    There might be a vertical scroll bar if number_of_choices i.e. lines > what we calculate will fit.
    There might be a horizontal scroll bar if number_of_choices i.e. characters-in-a-line > what we calculate will fit.
    If we expect a horizontal scroll bar, then we will add horizontal-scroll-bar-height to height.
  Re space at the bottom if there is a vertical scroll bar:
     See https://stackoverflow.com/questions/41827513/getting-rid-of-blank-area-at-the-bottom-of-a-qlistwidget
     The recommendation re setFixedSize type will fail.
     The recommendation re scrollPerPixel was tried and failed, e.g.
      ->setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);
     and anyway maybe that has an effect that's worse than the extra space.
*/

/*
  Get desired width and height of completer_widget based on width of its largest item and number of items.
  Possibly reduce so it won't be dominant.
  Get desired position based on where it will fit, and reduce more if there is trouble fitting within statement_edit_widget.

Usually this should mean there is no above/below switching and left moving, but frequent size change.

Separate resize should be unnecessary

This should be done in reaction to statement_edit_widget->resize too, but
-- beware, completer_widget might not exist yet
-- it would be good if we didn't recalculate for each pixel moved
-- so maybe don't respond, it will get figured out next time user types something
-- we could depend on our timer
-- if boundingRect() seems too slow, we could reduce by only sampling a few, but there might be horizontal overflow
-- todo: if list_widget hasn't changed since last time you called this, skip initial recalculation of width and height
*/

/*
   This should put completer_widget below the text cursor in statement_edit_widget, which is the parent.
   If it is too close to the right, shift to the left (even covering the prompt).
   If it is too close to the bottom, try the top.
   Todo: the minimum width/height calculations here are silliness for emergencies, we ordinarily calculate actual width + height.
*/

void Completer_widget::size_and_position_change()
{
  QFont f;
  if (associated_widget_type == STATEMENT_WIDGET)
    f= main_window->get_font_from_style_sheet(main_window->ocelot_statement_style_string);
  else /* EXPLORER_WIDGET */
    f= main_window->get_font_from_style_sheet(main_window->ocelot_explorer_style_string);
  QFontMetrics fm(f);
  QString s= "";
  copy_string_list();
  s= toPlainText();
  s= s.left(s.size() - 1); /* otherwise there's a blank at the end? */
  QRect r= fm.boundingRect(
            0, /* int x = x coordinate within original rect */
            0, /* int y = y coordinate within original rect */
            4000, /* int width = width, which is arbitrary big maximum */
            4000, /* int height = height, which is arbitrary big maximum */
            Qt::TextDontClip,
            s); /* QString & text= cell contents */
  int desired_width= r.width();
  int desired_height= r.height();
  int desired_height_of_one_line;
  if (count_wrapper() == 0) desired_height_of_one_line= desired_height;
  else desired_height_of_one_line= desired_height / count_wrapper();

  desired_width+= verticalScrollBar()->width();
  desired_width+= 2 * frameWidth() + 16; /* why + 16? I don't know. But it helps. */

  int maximum_width, maximum_height;
  if (associated_widget_type == STATEMENT_WIDGET)
  {
    maximum_width= main_window->statement_edit_widget->width();
    maximum_height= main_window->statement_edit_widget->height();
  }
  else
  {
    /* TODO: SHOULD BE CURRENT POSITION TILL END. AND THIS ASSUMES NO DETACHING! */
      maximum_width= main_window->width() - main_window->explorer_widget->width();
    maximum_height= main_window->height();
  }
  if (desired_width > maximum_width)
  {
    desired_height+= horizontalScrollBar()->height(); /* do this only if there will be a horizontal scroll bar */
  }

  desired_height+= 2 * frameWidth();
  desired_height+= count_wrapper() * 2; /* why * 2? I don't know. But it helps. */

  QRect r3;
  if (associated_widget_type == STATEMENT_WIDGET)
    r3= main_window->statement_edit_widget->cursorRect();
  else /* EXPLORER_WIDGET */
    r3= main_window->explorer_widget->html_text_edit->cursorRect();
  int desired_x;
  if (associated_widget_type == STATEMENT_WIDGET)
    desired_x= r3.x() + main_window->statement_edit_widget->prompt_width_calculate();
  else /* EXPLORER_WIDGET todo: can shift more than this if it wouldn't interfere with maximum width */
    desired_x= r3.x() + 24;
  int desired_y= r3.y() + r3.height();
  /* If there isn't enough width, try to shift completer_widget left. If still not enough, shift to x=0 and reduce width. */
  int space_after_x= maximum_width - (desired_x + desired_width);
  if (space_after_x < 0)
  {
    if (desired_width > maximum_width) desired_width= maximum_width;
    desired_x= maximum_width - desired_width;
  }
  /* If there isn't enough height, see if it would fit much better above. If not, reduce height. */
  int space_after_y= maximum_height - (desired_y + desired_height);
  if (space_after_y < 0)
  {
    if (r3.y() > (maximum_height - desired_y) + 100)
    {
      desired_y= r3.y() - desired_height;
      if (desired_y < 0)
      {
        desired_y= 0;
        desired_height= r3.y();
      }
    }
    else
    {
     while (desired_height > (maximum_height - desired_y))
     {
       /* Something initially comes up with size = 10, covering the prompt, if show_wrapper() activates while statement is empty */
       if (desired_height < 10) break;
       desired_height -= desired_height_of_one_line;
     }
     //desired_height= maximum_height - desired_y;
    }
    setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
  }
  else
  {
    /* If we know that it will fit, let's try reducing to eliminate that extra blank lne? Nope, doesn't work */
    setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
  }
  //setFixedSize(desired_width, desired_height);
  resize(desired_width, desired_height);
  if (associated_widget_type == STATEMENT_WIDGET)
    move(desired_x, desired_y);
  else /* EXPLORER_WIDGET */
    move(desired_x, desired_y);
}

/*
  Re final_letter:
    Symbols: 'D' database 'C' column 'T' table 'F' function 'P' procedure 't' trigger 'E' event 'I' index (from database)
             'K' keyword (not from database) or operator
    We use this for setToolTip() so the user can see the object type (reftype?) when hovering, but more importantly we use this
    to decide whether it's an identifier because in that case we might want to put ""s around it
    (depending on foreground color would be wrong because users can set the same color for multiple things).
    todo: maybe we should be setting with setStatusTip() or setWhatsThis instead of setToolTip()
  todo: Some junk remains because you aren't calling when looking at Lua. I guess when you just type 'i' there's no call?
  todo: You must be suspicious about removeWidget
  todo: at the time we call this, we also know reftype. and we could look ahead to see if "(" follows
  todo: I'm a bit uncertain why hparse_token can be "", maybe it's something during start
  todo: it's inefficient to add in and then take out what was just added in
  todo: we must pass type() but we don't need icon (or, we need icon)
  todo: don't sort string_list, but you could insert to string_list and string_list_tooltips in order
*/
void Completer_widget::append_wrapper(QString token, QString hparse_token, int token_type, int flags, QString final_letter)
{
  (void) flags; /* suppress "unused parameter" warning */
  QString s_hparse_token= hparse_token;
  if (s_hparse_token.left(1) == "\"") s_hparse_token= s_hparse_token.right(hparse_token.size() - 1);
  if (s_hparse_token.left(1) == "`") s_hparse_token= s_hparse_token.right(hparse_token.size() - 1);
  /* Do not add token if there is already a match in the list. todo: should be checking type + reftype too, somehow */
  if (string_list.contains(token, Qt::CaseInsensitive) == false)
  {
    string_list.append(token);
    string_list_tooltips.append(final_letter);
    token_type_list.append(token_type);
  }
  if (s_hparse_token > "")
  {
    int hps= s_hparse_token.size();
    for (int i= count_wrapper() - 1; i >= 0; --i)
    {
      QString s= string_list.at(i).left(hps);
      if (QString::compare(s_hparse_token, s, Qt::CaseInsensitive) != 0)
      {
        string_list.removeAt(i);
        string_list_tooltips.removeAt(i);
        token_type_list.removeAt(i);
      }
    }
  }
  set_current_row(current_row);
}

void Completer_widget::updater()
{
  if (count_wrapper() > 0)
  {
    size_and_position_change();
    show_wrapper();
  }
  else
  {
    hide_wrapper();
  }
}

/* todo: change ostrings.h so tooltip text can be in French */
/* todo: don't change the tooltip unless there's something different to say, but this checking might be inefficient */
/* todo: we seem to call set_current_row with new_current_row==0 a huge number of times, find out why. */
void Completer_widget::set_current_row(int new_current_row)
{
#if (OCELOT_EXPLORER == 1)
  if (associated_widget_type == EXPLORER_WIDGET)
  {
    setToolTip("Context menu. Click to execute explorer action");
    current_row= new_current_row;
    return;
  }
#endif
  if ((new_current_row != current_row) || (string_list_tooltips.count() < 3))
  {
   if (string_list_tooltips.count() > new_current_row)
    {
      QString s;
      if (string_list_tooltips.count() == 1) s= "Autocompletion hint.\n";
      else
      {
        s= "Autocompletion hints.\n";
        s= s + "Change selection with down-arrow key or mouse.\n";
        QString s3= ocelot_ca.shortcut_autocomplete;
        if (s3 == "default") s3= "tab key";
        s= s + "Choose selection with " + s3 + ".\n";
      }
      s= s + "Current selection is ";
      QString s2= string_list_tooltips.at(new_current_row);
      if      (s2 == "C") s= s + "a Column name.";
      else if (s2 == "D") s= s + "a Database name.";
      else if (s2 == "E") s= s + "an Event name.";
      else if (s2 == "F") s= s + "a Function name.";
      else if (s2 == "FP") s= s + "a Function or Procedure name";
      else if (s2 == "I") s= s + "an Index name.";
      else if (s2 == "i") s= s + "an identifier.";
      else if (s2 == "K") s= s + "a Keyword.";
      else if (s2 == "O") s= s + "an Operator.";
      else if (s2 == "P") s= s + "a Procedure name.";
      else if (s2 == "T") s= s + "A Table name.";
      else if (s2 == "t") s= s + "a Trigger name.";
      else if (s2 == "V") s= s + "a Variable. name.";
      else s= s + "a (" + s2 + ") token.";
      setToolTip(s);
    }
  }
  current_row= new_current_row;
}

/*
  Down arrow will go down in completer_widget without changing focus.
  Up arrow will go up in completer_widget without changing focus but if we're at top then it will go up in statement widget.
  Todo: this should be something we can change with "set ocelot_shortcut_..."
  Todo: how can we be sure this won't go to statement edit widgets' slot?
  In eventfilter_function check:
    if (key->key() == Qt::Key_Down) && (completer_widget->key_up_or_down(+1)) return true;
    if completer_widget is not hidden (and we are at end of input?)
      change what is selected -- go forward 1
      return true
*/
bool Completer_widget::key_up_or_down(int plus_or_minus_one)
{
  if (isHidden() == true) return false;
  timer_reset();
  if ((plus_or_minus_one == +1) && (current_row >= count_wrapper() - 1)) return true;
  if ((plus_or_minus_one == -1) && (current_row <= 0)) return false;
  set_current_row(current_row + plus_or_minus_one);
  line_colors(associated_widget_type);

  /* Todo: This works but is a ridiculous way to ensure cursor stays visible. */
  QTextCursor cursor= textCursor();
  int p= 0;
  for (int i= 0; i < current_row; ++i)
  {
    p+= string_list.at(i).size() + 1;
  }
  QString s= string_list.at(current_row);
  ensureCursorVisible();
  cursor.setPosition(p, QTextCursor::MoveAnchor);
  setTextCursor(cursor);
  return true;
}

/* If user clicks an item, it should become current_row. Compare key_up_or_down(). */
void Completer_widget::mousePressEvent(QMouseEvent *event)
{
  timer_reset();
  QTextCursor tc= cursorForPosition(event->pos());
  int tc_original_block_number= tc.blockNumber();
  set_current_row(tc_original_block_number);
  line_colors(associated_widget_type);
  tc.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor, 1);
  tc.movePosition(QTextCursor::NextBlock, QTextCursor::MoveAnchor, tc_original_block_number);
  setTextCursor(tc);
  if (associated_widget_type == STATEMENT_WIDGET)
    main_window->statement_edit_widget->setFocus();
  else /* EXPLORER_WIDGET */
    call_for_action();
}

/*
  If user double-clicks an item, that's equivalent to single-click followed by autocomplete key.
  When you double click, you get mousePressEvent first, so current_row is known by this time.
  Todo: It seems that, at least for explorer menu, mousePressEvent happens and we never reach here.
        But that might be a problem, it would mean that the second click is going up the line to explorer widget?
*/
void Completer_widget::mouseDoubleClickEvent(QMouseEvent *event)
{
  (void) event;
  main_window->statement_edit_widget->setFocus();
  main_window->menu_edit_autocomplete();
}

/* First this should do an implicit call of Completer_widget::Completer_widget() but don't assume it. */
C_widget::C_widget() /* constructor */
{
  ;
}

/* Probably focusInEvent will happen only when Context_menu calls Completer_widget. Else this is bad. */
void C_widget::focusInEvent(QFocusEvent *event)
{
  QTextEdit::focusInEvent(event);
  line_colors(EXPLORER_WIDGET); /* so that the first item in the list gets "emphasis" */
  main_window->menu_set_enabled("action_edit_autocomplete", true);
 /* So shortcut e.g. Key_Tab will work */
}

/* When Context_menu calls Completer_widget, hide it as soon as e.g. mouse click outside. */
void C_widget::focusOutEvent(QFocusEvent *event)
{
  QTextEdit::focusOutEvent(event);
#if (OCELOT_EXPLORER == 1)
  if (associated_widget_type == EXPLORER_WIDGET)
  {
    hide();
    main_window->menu_set_enabled("action_edit_autocomplete", false);
    initialize(STATEMENT_WIDGET);
  }
#endif
}

C_widget::~C_widget()
{
  ;
}


/*
  Ordinarily I expect keyPressEvent will be caught in eventfilter_function, and that seems to be the case
  when parent is statement_edit_widget, but not when parent is explorer_widget. So some duplication here.
  What about shortcut?
  Re Key_Escape: I think it's normal for QDialog and QMenu that Esc causes focus loss, so hide().
  Re Key_Tab: we should treat this like we treat Key_Enter, via shortcut_override, it won't get to here.
*/
void Completer_widget::keyPressEvent(QKeyEvent *event)
{
  QKeyEvent *key= event;
  if (main_window->keypress_shortcut_handler(key) == true)
  {
    call_for_action();
  } /* todo: this isn't seen */
  if (key->key() == Qt::Key_Down) key_up_or_down(+1);
  if (key->key() == Qt::Key_Up) key_up_or_down(-1);
  if ((key->key() == Qt::Key_Enter) || (key->key() == Qt::Key_Return)) call_for_action();
  if (key->key() == Qt::Key_Escape) hide();
  event->accept(); /* unless there's some reason we should let the key propagate upwards to an ultimate owner? */
}

/* called from mousePressEvent, keyPressEvent if Key_Enter */
void Completer_widget::call_for_action()
{
  main_window->explorer_widget->html_text_edit->explorer_context_menu->action(current_row, -1);
  hide();
}

void Completer_widget::timer_reset()
{
  timer->stop();
  timer->start();
}

/*
  ocelot_ca.completer_timeout has expired so we hide completer_widget, unless it has focus (because user clicked on its vertical scroll bar).
*/
void Completer_widget::timer_expired()
{
  if (hasFocus())
  {
    timer->start();
    return;
  }
  hide_wrapper();
}

/*
  Todo: generally (always?) autocomplete menu item is disabled when we're looking at explorer.
  Note: "if (qk == Qt::Key_Tab)" was here before but on some Qt versions caused an error =
        ambiguous overload of operand == (operand types are QKey::KeySequence and Qt::Key)
*/
bool Completer_widget::shortcut_override(QKeySequence qk)
{
  if ((hasFocus() == true) && (associated_widget_type == EXPLORER_WIDGET))
  {
    if (qk.toString() == "Tab")
    {
      call_for_action();
      return true;
    }
  }
  return false;
}

Completer_widget::~Completer_widget()
{
  ;
}

/******************** completer_widget end   ************************************/

/******************** Messagebox_flash start *************************************/

Messagebox_flash::Messagebox_flash() /* constructor */
{
  timer= NULL;
}

void Messagebox_flash::showEvent( QShowEvent * event)
{
  timer= new QTimer(this);
  timer->setSingleShot(true);
  timer->setInterval(1000);
  timer->start();
  QObject::connect(timer, SIGNAL(timeout()), this, SLOT(timer_expired(void)));
  QMessageBox::showEvent(event);
}

void Messagebox_flash::timer_expired()
{
  this->done(0); /* meaning = QDialog::done(int r) */
}

Messagebox_flash::~Messagebox_flash()
{
  ;
}

/******************** Messagebox_flash end *************************************/

/******************** Message_box start *************************************/
Message_box::Message_box(QString the_title, QString the_text, int minimum_width,
            QString prompter, QString button_1_text, QString button_2_text, MainWindow *parent): QDialog(parent)
{
  result= 1;
  this->setFont(parent->get_font_from_style_sheet(parent->ocelot_statement_style_string));
  QScrollArea *scroll_area= new QScrollArea(this);
  // scroll_area->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded); This is default anyway.
  //scroll_area->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded); This is default anyway.
  QWidget *widget= new QWidget(this);
  scroll_area->setWidget(widget);
  scroll_area->setWidgetResizable(true);
  QVBoxLayout *layout= new QVBoxLayout(widget);
  TextEditWidget2 *text_edit= new TextEditWidget2(the_text, this, minimum_width);
  text_edit->setReadOnly(true);
  layout->addWidget(text_edit);
  QVBoxLayout *prompter_and_buttons_layout= new QVBoxLayout(widget);
  QWidget *prompter_and_buttons_widget= new QWidget(this);
  if (prompter > "")
  {
    QLabel *prompter_label= new QLabel(prompter, this);
    prompter_and_buttons_layout->addWidget(prompter_label);
  }
  QHBoxLayout *buttons_layout= new QHBoxLayout(widget);
  QWidget *buttons_widget= new QWidget(this);
  QPushButton *push_button_1= new QPushButton(this);
  push_button_1->setText("&"+button_1_text);
  buttons_layout->addWidget(push_button_1);
  push_button_1->setAutoDefault(true);
  connect(push_button_1, SIGNAL(clicked()), this, SLOT(handle_button_1()));
  if (button_2_text > "")
  {
    QPushButton *push_button_2= new QPushButton(this);
    push_button_2->setText("&"+button_2_text);
    buttons_layout->addWidget(push_button_2);
    push_button_2->setAutoDefault(false);
    connect(push_button_2, SIGNAL(clicked()), this, SLOT(handle_button_2()));
  }
  buttons_widget->setLayout(buttons_layout);
  prompter_and_buttons_layout->addWidget(buttons_widget);
  prompter_and_buttons_widget->setLayout(prompter_and_buttons_layout);
  layout->addWidget(prompter_and_buttons_widget);
  widget->setLayout(layout);
  this->setMinimumWidth(minimum_width);
  this->setWindowTitle(the_title);
  QHBoxLayout *dialog_layout= new QHBoxLayout(this);
  this->setLayout(dialog_layout);
  this->layout()->addWidget(scroll_area);
}

/* private slots: */
void Message_box::handle_button_1()
{
  result= 1;
  /* Skipping garbage collect this time. */
  close();
}

void Message_box::handle_button_2()
{
  result= 2;
  /* Skipping garbage collect this time. */
  close();
}


/******************** Message_box end *************************************/

/******************** find_widget start   ************************************/
#if (OCELOT_FIND_WIDGET == 1)
/*
  Re close_button:
    If user clicks this, we hide (but we don't delete, and maybe we should. or delete components)
    This is like what an editor does.
  Re find_label:
    This and other text should be in ostrings.h so it can be French
  Re combo_box:
    QComboBox, editable.
    After each Ctrl+F, users see a blank that they can edit, or they can scroll down and pick a previous.
    This is like what an editor does but an editor's history is stored, ours is since-startup and limited to 5.
  Re up_button and down_button:
    These are for going to "next" or "previous"
    This is like what an editor does.
    We could have said down_button->setArrowType(Qt::DownArrow);
  Re case_button:
    Text is 'i' for Qt::CaseInsensitive or 's' for Qt::CaseSensitive. Default is 'i'.
    Click to toggle between 'i' and 's'. Search won't be repeated automatically but setting is in effect.
    I'm not sure this is a good way to do it.
    I've seen an icon used here, I think text might be clearer.
  Re searching:
    By default CaseInsensitive, but clicking case_button toggles to sensitive.
    We wrap, i.e. if at end when forward we go to start, if at start when backward we go from end
    This is like what an editor does but an editor goes from statement current pos, we go from start|end.
    Todo: options e.g. "matching )"
  Re highlighting what's found:
    Todo: I'd like to set color and maybe underline as in debug_highlight_line() instead of selecting.
          e.g. muted yellow, and straight underline
    highlight all? or highlight first from cursor? should the cursor move?
    Todo: put a box around the clause
  Re keyPressEvent:
    Maybe looking for Esc is a mistake, it should be a shortcut with default == QKeySequence::Cancel.
    See also keypress_shortcut_handler().
  Re relevant widget:
    We try to use last_focus_widget, i.e. what we saved in menu_activate() when one of the main widgets
    lost focus, regarding that as "current". Make sure cast is legitimate by checking the class name.
    codeEditor is subclass of QPlainTextEit, TextEditHistory and TextEditWidget and TextEditWidge2 are
    subclasses of QTextEdit, if it's anything else then assume statement_edit_widget not last_focus_widget.
    Todo: Show immediately after relevant widget, or in main menu
    If the relevant widget is grid, then we search only in a cell.
    I hoped we'd see more if --ocelot_html=1 but html_text_edit doesn't get seen by filter (?).
  Todo: signal(pressed) and signal(clicked) both seem to work, which should I prefer?
  Todo: in ababaabaab I see 3 occurrences of aba but an editor sees 2
  Todo: Save current focus, see https://forum.qt.io/topic/80019/find-which-widget-had-focus-when-menu-item-is-clicked/8
  Todo: Maybe say "explicit" before Find_widget(...) in ocelotgui.h
  Todo: Do I need to change so next|prev widget won't come to find_widget when it's activated?
  Todo: Maybe say action_close_button_clicked() instead of hide()
  Todo: Change keyboard_shortcut_handler(), you need to handle ^Q but not most other things
  Todo: bug: search for "bl" and see bl is highlighted in statement
             then backspace so the search is only for "b" and see bl is still highlighted in statement
  Todo: There is too much space between the statement widget and the find widget
  Todo: Maybe save space by only loading components when activate, and deleting them when close
  Todo: bug: if a word goes over one line in HTML display, find fails (if I recall right, we added a line feed)
*/

Find_widget::Find_widget(MainWindow *m) /* constructor */
{
  main_window= m;
  construct();
}


/* called from new Find_widget() which is called just before main_window->setLayout(main_layout) */
void Find_widget::construct()
{
  QStyle *style = qApp->style();
  layout= new QHBoxLayout(this);
  close_button= new QToolButton(this);
  close_button->setIcon(style->standardIcon(QStyle::SP_DialogCancelButton));
  close_button->setToolTip("Close");
  find_label= new QLabel(this);
  QFont f= this->font();
  QFontMetrics fm(f);
  QString s= "Find:";
  s= s.left(s.size() - 1); /* otherwise there's a blank at the end? */
  QRect r= fm.boundingRect(0, 0, 4000, 4000, Qt::TextDontClip, s);
  find_label->setFixedWidth(r.width());
  find_label->setText(s);
  combo_box= new QComboBox(this);
  combo_box->setEditable(true);
  combo_box->setMaxCount(5);
  combo_box->setToolTip("Text to find");
  down_button= new QToolButton(this);
  down_button->setIcon(style->standardIcon(QStyle::SP_ArrowDown));
  down_button->setToolTip("Find next match");
  up_button= new QToolButton(this);
  up_button->setIcon(style->standardIcon(QStyle::SP_ArrowUp));
  up_button->setToolTip("Find previous match");
  case_button= new QToolButton(this);
  case_button->setText("i");
  case_button->setToolTip("Case sensitive search");
  layout->addWidget(close_button);
  layout->addWidget(find_label);
  layout->addWidget(combo_box);
  layout->addWidget(down_button);
  layout->addWidget(up_button);
  layout->addWidget(case_button);
  setLayout(layout);
  connect(combo_box, SIGNAL(currentTextChanged(QString)), this, SLOT(action_combo_box_text_changed(QString)));
  connect(down_button, SIGNAL(clicked()), this, SLOT(action_down_button_clicked()));
  connect(up_button, SIGNAL(pressed()), this, SLOT(action_up_button_clicked()));
  connect(close_button, SIGNAL(pressed()), this, SLOT(action_close_button_clicked()));
  connect(case_button, SIGNAL(pressed()), this, SLOT(action_case_button_clicked()));
  hide();
}

void Find_widget::find_widget_activate()
{
  if (combo_box->currentIndex() > 0) combo_box->setCurrentIndex(0);
  QString s= combo_box->currentText();
  if (s != "")
  {
    combo_box->insertItem(0, s);
    combo_box->setCurrentIndex(0);
    combo_box->setItemText(0, ""); /* setCurrentText(""); didn't work on old Qt */
  }
  enable_or_disable();
  combo_box->setFocus();
  show();
}

void Find_widget::action_close_button_clicked()
{
  hide();
}

/* slot for signal connected with find_widget_activate */
void Find_widget::action_combo_box_text_changed(QString find_text)
{
  (void)find_text;
  enable_or_disable();
  action_find_widget_move(true, true);
}

void Find_widget::action_down_button_clicked()
{
  action_find_widget_move(false, true);
}

void Find_widget::action_up_button_clicked()
{
  action_find_widget_move(false, false);
}

void Find_widget::action_case_button_clicked()
{
  if (case_button->text() == "i") case_button->setText("s");
  else case_button->setText("i");
}

/* called from action_combo_box_text_change|down_arrow_clicked|up_arrow_clicked */
void Find_widget::action_find_widget_move(bool is_from_start, bool is_forward)
{
  QTextCursor c;
  QString s;
  QPlainTextEdit *p_plaintextedit= NULL;
  QTextEdit *p_textedit= NULL;
  const char *class_name= main_window->last_focus_widget->metaObject()->className();
  if (strcmp(class_name, "CodeEditor") == 0)
  {
    p_plaintextedit= (QPlainTextEdit *) main_window->last_focus_widget;
    c= p_plaintextedit->textCursor();
    s= p_plaintextedit->toPlainText();
  }
  else if ((strcmp(class_name, "TextEditHistory") == 0)
   || (strcmp(class_name, "TextEditWidget") == 0) /* Todo: This class no longer exists. */
   || (strcmp(class_name, "TextEditWidget2") == 0))
  {
    p_textedit= (QTextEdit *) main_window->last_focus_widget;
    c= p_textedit->textCursor();
    s= p_textedit->toPlainText();
  }
  else if (strcmp(class_name, "Result_qtextedit") == 0)
  {
    p_textedit= (Result_qtextedit *) main_window->last_focus_widget;
    c= p_textedit->textCursor();
    s= p_textedit->toPlainText();
  }
  else
  {
    c= main_window->statement_edit_widget->textCursor();
    s= main_window->statement_edit_widget->toPlainText();
  }
  Qt::CaseSensitivity case_sensitive;
  if (case_button->text() == "i") case_sensitive= Qt::CaseInsensitive;
  else case_sensitive= Qt::CaseSensitive;
  int position_from, position_to;
  if (is_from_start == true) position_from= 0;
  else position_from= c.position();
  QString find_text= combo_box->currentText();
  if (is_forward == true)
  {
    position_to= s.indexOf(find_text, position_from  - (find_text.size() - 1), case_sensitive);
    if (position_to == -1) position_to= s.indexOf(find_text, 0, case_sensitive);
  }
  else
  {
    position_to= s.lastIndexOf(find_text, position_from - (find_text.size() + 1), case_sensitive);
    if (position_to == -1) position_to= s.lastIndexOf(find_text, s.size() - 1, case_sensitive);
  }
  if (position_to != -1)
  {
    c.setPosition(position_to, QTextCursor::MoveAnchor);
    c.setPosition(position_to + find_text.size(), QTextCursor::KeepAnchor);
    if (p_plaintextedit != NULL) p_plaintextedit->setTextCursor(c);
    else if (p_textedit != NULL) p_textedit->setTextCursor(c);
    else main_window->statement_edit_widget->setTextCursor(c);
  }
}

void Find_widget::enable_or_disable()
{
  if (combo_box->currentText() != "")
  {
    up_button->setEnabled(true);
    down_button->setEnabled(true);
  }
  else
  {
    up_button->setEnabled(false);
    down_button->setEnabled(false);
  }
}

void Find_widget::keyPressEvent(QKeyEvent *event)
{
  if (event->key() == Qt::Key_Escape)
  {
    hide();
    return;
  }
  if (main_window->keypress_shortcut_handler(event) == true)
  {
    return;
  }
}

Find_widget::~Find_widget()
{
  ;
}

#endif
/******************** find_widget end   ************************************/


/******************** result_qtextedit start   ************************************/

void Result_qtextedit::menu_context_t(const QPoint & pos)
{
  menu_context_t_2(pos);
}

#if (OCELOT_EXPLORER == 1)
void Result_qtextedit::menu_context_t_explorer(const QPoint &pos)
{
  menu_context_t_2_explorer(pos);
}
#endif

Result_qtextedit::Result_qtextedit(ResultGrid *m) /* constructor */
{
  result_grid= m;
  construct();
}

/* Todo: don't forget to delete [] grid_columns somewhere */
/* It might not be necessary to delete anything made in Result_qtextedit::construct(), but try anyway. */
/* explorer_context_menu has its own destructor */
Result_qtextedit::~Result_qtextedit()
{
  if (qtextedit_result_changes != NULL)
  {
    delete qtextedit_result_changes;
    qtextedit_result_changes= NULL;
  }
}

/*
  Re setMouseTracking: we want mouseMoveEvent to work.
  Re setDocumentMargin: We want the table to start at left boundary, but it starts at 1 anyway.
  Re possible memory leaks:
    We allow ^Z i.e. we don't setUndoRedoEnabled(false) and that causes a leak danger.
    We might create resources, especially for images, and that too can cause a leak danger
    (See https://stackoverflow.com/questions/34735595/qtextdocument-how-to-remove-a-resource-from-cache).
    and although we could delete (or at least clear) QTextDocument, something might still be forgotten.
    So in display_garbage_collect() we delete result_qtextedit and create it again.
  Todo: why NoWrap? I'm going to some trouble to do my own wrapping!
  Todo: why not just make this part of constructor?
*/
void Result_qtextedit::construct()
{
  qtextedit_result_changes= NULL; /* to avoid bad "delete" in ~Result_qtextedit */
  explorer_context_menu= NULL;
  setMouseTracking(true);
  document()->setDocumentMargin(0);
  /* test!! Hey it works. But should be an option. */
  setAlignment(Qt::AlignTop | Qt::AlignLeft);
  setWordWrapMode(QTextOption::NoWrap);
  setFrameStyle(QFrame::NoFrame);
  /* Once this was in TextEditWidget */
  this->setContextMenuPolicy(Qt::CustomContextMenu);
#if (OCELOT_EXPLORER == 1)
  if (result_grid->result_grid_type == EXPLORER_WIDGET)
  {
    qtextedit_is_min_max_clicked= false;
    connect(this, SIGNAL(customContextMenuRequested(const QPoint &)),
        this, SLOT(menu_context_t_explorer(const QPoint &)));
  }
  else
#endif
  connect(this, SIGNAL(customContextMenuRequested(const QPoint &)),
      this, SLOT(menu_context_t(const QPoint &)));
  qtextedit_result_changes= new Result_changes(this); /* ~Result_qtextedit() should delete this */
//  show();
#if (OCELOT_EXPLORER == 1)
  if (result_grid->result_grid_type == EXPLORER_WIDGET)
    explorer_context_menu= new Context_menu(result_grid, this);
#endif
}

#ifdef OLD_STUFF
void TextEditFrame::style_sheet_setter(TextEditFrame *text_frame, TextEditWidget *text_edit)
{
  ResultGrid *rg= text_frame ->ancestor_result_grid_widget;
  MainWindow *mw= rg->copy_of_parent;
  QString new_tooltip= "";
  QString new_style_sheet= mw->ocelot_grid_style_string;
  QString new_cell_height= "";
  QString new_cell_width= "";
  QString new_text= "";
  int returned_cs_number= 0;
  bool result= rg->conditional_setting_evaluate_till_true(text_frame->ancestor_grid_column_number, text_frame->ancestor_grid_result_row_number, text_frame->content_pointer, text_frame->content_length, text_frame->cell_type, &new_tooltip, &new_style_sheet, &new_cell_height, &new_cell_width, &returned_cs_number, &new_text, NULL);
  if (result == true)
  {
    if (new_tooltip != "") text_edit->setToolTip(new_tooltip);
    QString old_style_sheet= text_edit->styleSheet();
    if (new_style_sheet != old_style_sheet)
    {
      text_edit->setStyleSheet(new_style_sheet);
    }
    if (text_frame->is_style_sheet_set_flag == false)
    {
      text_frame->setStyleSheet(rg->frame_color_setting); /* for drag line color */
      text_frame->is_style_sheet_set_flag= true;
    }
    return; /* !! Too early! We only have evaluated one condition! */
  }
  if (text_frame->is_style_sheet_set_flag == false)
  {
    text_frame->setStyleSheet(rg->frame_color_setting); /* for drag line color */
    if (text_frame->cell_type == TEXTEDITFRAME_CELL_TYPE_HEADER) text_edit->setStyleSheet(mw->ocelot_grid_header_style_string);
    else if (text_frame->cell_type == TEXTEDITFRAME_CELL_TYPE_DETAIL) text_edit->setStyleSheet(mw->ocelot_grid_style_string);
    else text_edit->setStyleSheet(mw->ocelot_extra_rule_1_style_string);
    text_frame->is_style_sheet_set_flag= true;
  }
}
#endif

/*
  Copy a column's contents to an HTML cell i.e. within <TD></TD> and return # of bytes copied.
  We call this for chars not images.
  Todo: Change < to &lt; > to &gt; & to &amp; but it seems unnecessary to change " to &quot;
  Todo: pass width, wrap if width exceeded by adding <BR>
  Todo: pass height, this is our maximum number of lines (else we cut off? else we add a scroll bar?)
        or: no, height is fixed number of pixels, in case user insisted on fixed height with SET
        but height can be 'any'
  Todo: pass font. Life is easier if it's fixed-font.
  Todo: call this for headers too (or are they different?) (must we pass #-of-lines?)
  Todo: pass flags:
        1 replace < and > and & with character entities
        2 wrap if width exceeded by adding <BR>
        4 this is a header, although I don't see what that would change
  Todo: Allow #-of-bytes * 5 when allocating for tmp because it might be all &&&&&s and <BR>s are needed
        (this might have to be regarded as a temporary solution) (we're allocating * 5 in display_html)
  Todo: replace \n with <br>, and allow <> if <br>
  We're replacing
    memcpy(tmp_pointer, pointer, v_length);
    tmp_pointer+= v_length;
  with
    tmp_pointer+= html_text_edit->copy_html_cell(tmp_pointer, pointer, v_length);
  Todo: Using max_width_of_a_char is not exact enough, we should call boundingRect()
  Todo: we're always passing the same font, we should be looking for a conditionally changed font
  Todo: BUG: in order to get wrapping right, I have to first do a select with ocelot_ca.html = 0.
  Todo: I think it's always TEXTEDITFRAME_CELL_TYPE_DETAIL now so you don't need to pass it and check it.
  Todo: BUG: width isn't being set for numeric columns, which is why column drag fails for numeric columns.
  Todo: For an image, we assume height < max_height_of_a_char*2 is default and ignore it. We should check.
  Todo: re ocelot_grid_html_settings:
        Specialize e.g. it could be 'italics' or '<i>' to recognize only italics.
        bug: If we put a <br> in order to increase height, it wrecks something between <i> and </i>.
        We should calculate width without the html markup, otherwise column can be too wide.
        When documenting, give example = select '<p style="color:red">' || 'x' || '</p>'; which is HTML 4.
        Or select '<p style="color:red">' || 'x' || '</p>' AS "<i>BIG HEADER IN ITALICS</i>";
*/
int Result_qtextedit::copy_html_cell(char *ocelot_grid_detail_numeric_column_start,
                                     char *ocelot_grid_detail_char_column_start,
                                     char *tmp_pointer,
                                     char *result_pointer, /* result_field_names_pointer or result_set_pointer */
                                     char result_set_value_flags, /* e.g. FIELD_VALUE_FLAG_IS_NULL */
                                     int v_length,
                                     int cell_type,
                                     int width_n,
                                     int height_n,
                                     QFont font,
                                     int max_width_of_a_char,
                                     int grid_column_no,
                                     long unsigned int tmp_result_row_number,
                                     char *ocelot_grid_detail_char_column_end,
                                     int *new_cell_height_as_int,
                                     unsigned int result_column_no)
{
  (void)ocelot_grid_detail_numeric_column_start;
  (void)font;
  bool is_chart= false;
#if (OCELOT_CHART_OR_QCHART == 1)
  QByteArray head(result_pointer, v_length);
  QString s_of_head(head);
  int chart_column_in_group= -1;
  char result_pointer_of_chart_header[2048]; /* TODO: this should be dynamic size */
  int v_length_of_chart_header;
  if (result_grid->chart_widget != NULL)
  {
    chart_column_in_group= result_grid->chart_widget->column_in_group(result_column_no);
    if (chart_column_in_group >= 0)
    {
      if (chart_column_in_group == 0)
      {
        result_grid->chart_widget->width_n_total= 0;
        result_grid->chart_widget->height_n_total= 0;
        if (cell_type == TEXTEDITFRAME_CELL_TYPE_HEADER)
        {
          result_grid->chart_widget->group_header= "";
          int lcig= result_grid->chart_widget->chart_last_column_in_group;
          result_grid->chart_widget->chart_header_widths[lcig]= 0;
        }
      }
      result_grid->chart_widget->width_n_total+= width_n;
      result_grid->chart_widget->height_n_total+= height_n;
      if (cell_type == TEXTEDITFRAME_CELL_TYPE_HEADER)
      {
        if (chart_column_in_group != 0) result_grid->chart_widget->group_header= result_grid->chart_widget->group_header + ",";
        result_grid->chart_widget->group_header= result_grid->chart_widget->group_header + s_of_head;
      }
      if (result_grid->chart_widget->chart_last_column_in_group == (int) result_column_no)
      {
        if (cell_type == TEXTEDITFRAME_CELL_TYPE_HEADER)
        {
          strcpy(result_pointer_of_chart_header, result_grid->chart_widget->group_header.toUtf8());
          v_length_of_chart_header= strlen(result_pointer_of_chart_header);
          result_pointer= result_pointer_of_chart_header;
          v_length= v_length_of_chart_header;
          QFontMetrics chart_fm= QFontMetrics(result_grid->chart_widget->chart_default_font);
          /* Why + 5? dunno. maybe it's something to do with QFontMetrics bearing with italics? */
          width_n= chart_fm.boundingRect(result_pointer_of_chart_header).width() + 5;
          result_grid->chart_widget->chart_header_widths[result_column_no]= width_n;
        }
        is_chart= true;
      }
      else return 0; /* i.e. tmp_pointer - original_tmp_pointer, because we output nothing */
    }
  }
#endif

  *new_cell_height_as_int= -1; /* default */
  char *original_tmp_pointer= tmp_pointer;
  bool is_image= false;
  /* Todo: Actually, maybe is_image(result_column_no) would be correct regardless of vertical value. */
  if (result_grid->copy_of_ocelot_vertical == 0)
  {
    if (result_grid->is_image(grid_column_no) == true)
    {
      is_image= true;
    }
  }
  else
  {
    if (result_grid->is_image(result_column_no) == true)
    {
      is_image= true;
    }
  }
  QByteArray f= qtextedit_result_changes->find(tmp_result_row_number, result_column_no);
  if (f.size() > 1)
  {
    is_image= true; /* image paste experiment */
    result_pointer= (char*) f.constData();  /* image paste experiment */
    v_length= f.size();  /* image paste experiment */
  }
  /* How can this be right if v_length and result_pointer get adjusted afterward? Well, VALUE='...' doesn't work. */
  /* Todo: This is supposed to be applicable to header too, no? */
  /* TEST!!! start: See whether we can change color, at least. HTML only! */
  QString new_tooltip= "";
  QString new_style_sheet;
#if (OCELOT_EXPLORER == 1)
  if (result_grid->result_grid_type == EXPLORER_WIDGET)
    new_style_sheet= result_grid->copy_of_parent->ocelot_explorer_style_string;
  else
#endif
    new_style_sheet= result_grid->copy_of_parent->ocelot_grid_style_string;
  QString new_cell_height= "";
  QString new_cell_width= "";
  QString new_text= "";
  int returned_cs_number= 0;
  bool result= result_grid->conditional_setting_evaluate_till_true(
       result_column_no, /* i.e. result set column number */
       tmp_result_row_number, /* text_edit_frames[text_edit_frames_index]->ancestor_grid_result_row_number, */
       result_pointer, /* result_field_names_pointer or result_set_pointer or image paste experiment */
       result_set_value_flags,
       v_length, /* text_edit_frames[text_edit_frames_index]->content_length, */
       TEXTEDITFRAME_CELL_TYPE_DETAIL, /* text_edit_frames[text_edit_frames_index]->cell_type, */
       &new_tooltip, &new_style_sheet, &new_cell_height, &new_cell_width, &returned_cs_number, &new_text, NULL);
//  char tmp_new_style_sheet[640];
//  strcpy(tmp_new_style_sheet, new_style_sheet.toUtf8());
  if ((result == true) && (new_cell_height != ""))
  {
    int nchi= result_grid->get_cell_width_or_height_as_int(new_cell_height, result_grid->max_height_of_a_char);
#if (OCELOT_EXPLORER == 1)
    if ((nchi == 0) && (result_grid->result_grid_type == EXPLORER_WIDGET))
    {
      *new_cell_height_as_int= 0;
    }
#endif
    if ((nchi > 0)
     && (QString::compare("default", new_cell_height, Qt::CaseInsensitive) != 0))
      *new_cell_height_as_int= nchi;
  }
  /*
    Although we pass ocelot_grid_detail_numeric_column_start and ocelot_grid_detail_char_column_start,
    we ignore them because we must add <width=...> in either case so what we really will want is
    <TD width=...> or <TD width=...; align="right">
  */
  /* TODO: SET THE RIGHT WIDTH IN THE FIRST PLACE! */
  unsigned int width_i= width_n; /* instead of result_grid->grid_column_widths[grid_column_no]; */

  /* If conditional setting is true and has a width setting clause, use that instead of normal value. */
  if ((result == true) && (new_cell_width != ""))
  {
    int new_cell_width_as_int= result_grid->get_cell_width_or_height_as_int(new_cell_width, result_grid->character_count_to_pixel_count(MIN_WIDTH_IN_CHARS));
    if (new_cell_width_as_int > 0) width_i= new_cell_width_as_int;
  }

  {
    width_i-= result_grid->setting_ocelot_grid_cell_border_size_as_int * 2;



//    width_i-= result_grid->setting_ocelot_grid_cell_drag_line_size_as_int;
    char bgcolor[64];
    if (((int) tmp_result_row_number == result_grid->focus_result_row_number) && ((int) grid_column_no == result_grid->focus_column_number - 1))
    {
      char color_name[32];
      strcpy(color_name, result_grid->copy_of_parent->ocelot_grid_focus_cell_background_color.toUtf8());
      sprintf(bgcolor, "bgcolor='%s'; ", color_name);
    }
    else bgcolor[0]= '\0';
    char tmp_td[128];

    if (memcmp(ocelot_grid_detail_char_column_start, "<TH", 3) == 0)
      sprintf(tmp_td, "<TH align='left'; width=%u>", width_i);
    else
    {
      if ((result_grid->result_field_flags[result_column_no] & NUM_FLAG) != 0)
        sprintf(tmp_td, "<TD %salign='right'; width=%u>", bgcolor, width_i);
      else
        sprintf(tmp_td, "<TD %swidth=%u>", bgcolor, width_i);
    }

    strcpy(tmp_pointer, tmp_td);
    tmp_pointer+= strlen(tmp_td);
  }
  if (result == true)
  {
    char tmp_div[32];
    sprintf(tmp_div, "<div class=\"E%d\">", returned_cs_number);
    memcpy(tmp_pointer, tmp_div, strlen(tmp_div));
    tmp_pointer+= strlen(tmp_div);
  }
  /* TEST!!! end */
  if ((cell_type == TEXTEDITFRAME_CELL_TYPE_DETAIL) && ((is_image == true) || (is_chart == true)))
  {
    char img_type[4];
    result_grid->set_img_type(result_pointer, v_length, img_type); /* so img_type = "" or "png" or "jpg" or "gif" */
#if (OCELOT_CHART_OR_QCHART == 1)
    if (is_chart == true) strcpy(img_type, "png");
#endif
    if (strcmp(img_type,"") != 0)
    {
      char *base64_tmp;
#if (OCELOT_CHART_OR_QCHART == 1)
      if (is_chart == true)
        base64_tmp= new char[CHART_MAX_BYTE_SIZE];
      else
#endif
      base64_tmp= new char[(v_length * 4) / 3 + 64];
#if (OCELOT_CHART_OR_QCHART == 1)
      if (is_chart == true)
      {
        width_i= 300; /* TMP!! TEST!! */
        result_grid->chart_widget->draw_group(tmp_result_row_number, result_column_no, width_i, base64_tmp);
      }
      else
#endif
      {
        QByteArray data= QByteArray::fromRawData(result_pointer, v_length);
        strcpy(base64_tmp, data.toBase64());
      }
      char img_start[64];
      unsigned int height_candidate= height_n;
      if (*new_cell_height_as_int != -1) height_candidate= *new_cell_height_as_int;
#if (OCELOT_CHART_OR_QCHART == 1)
      if ((height_candidate > result_grid->max_height_of_a_char * 2) || (is_chart == 1))
#else
      if (height_candidate > result_grid->max_height_of_a_char * 2)
#endif
        sprintf(img_start, "<img width=%u height=%u src=\"data:image/", width_i, height_candidate);
      else
        sprintf(img_start, "<img width=%u src=\"data:image/", width_i);
      /* IMAGE TEST!!!! What happens if I don't say what the width is? */
#if (OCELOT_CHART_OR_QCHART == 1)
      if ((grid_column_no > 0) || (is_chart == 1))
#else
      if (grid_column_no > 0)
#endif
      {
          sprintf(img_start, "<img src=\"data:image/");
      }
      /* TEST!!!! end */

      strcpy(tmp_pointer, img_start);
      tmp_pointer+= strlen(img_start);
      memcpy(tmp_pointer, img_type, 3);
      tmp_pointer+= 3;
      memcpy(tmp_pointer, ";base64,", 8);
      tmp_pointer+= 8;
      memcpy(tmp_pointer, base64_tmp, strlen(base64_tmp));
      tmp_pointer+= strlen(base64_tmp);
      memcpy(tmp_pointer, "\"/>", 3);
      tmp_pointer+= 3;
      {
        /* TEST!! */
        *tmp_pointer= '\0';
      }
      delete[] base64_tmp;
    }
    return tmp_pointer - original_tmp_pointer;
  }
  char c;
  QString s;
  int column_width_in_chars= (width_n / max_width_of_a_char); /* TEST!!!! */
  if (column_width_in_chars < 1) column_width_in_chars= 1;
  for (int i= 0, j= 0; i < v_length; ++i)
  {
    c= *result_pointer;
    ++result_pointer;
    /* todo: check here if flag & 2 */
    if ((c & 0xc0) != 0x80) /* 10xxxxxx is a continuation byte so don't count as another character */
    {
      if ((j != 0) && ((j % column_width_in_chars) == 0))
      {
        memcpy(tmp_pointer, "<br>", 4);
        tmp_pointer+= 4;
      }
      ++j;
    }
    {
      bool is_special_char= false;
      if (c == '\0') {memcpy(tmp_pointer, "&#0;", 4); tmp_pointer+= 4; is_special_char= true;}
      if (result_grid->copy_of_parent->ocelot_grid_html_effects != "yes")
      {
        if (c == '<') {memcpy(tmp_pointer, "&lt;", 4); tmp_pointer+= 4; is_special_char= true;}
        else if (c == '>') {memcpy(tmp_pointer, "&gt;", 4); tmp_pointer+= 4; is_special_char= true;}
        else if (c == '&') {memcpy(tmp_pointer, "&amp;", 5); tmp_pointer+= 5; is_special_char= true;}
      }
      if (is_special_char == false) {*tmp_pointer= c; ++tmp_pointer;}
    }
  }
  /* TODO: This looks like dead code since we have copied already and we won't increment tmp_pointer here */
  memcpy(tmp_pointer, result_pointer, v_length);

  if (result == true)
  {
    strcpy(tmp_pointer, "</div>");
    tmp_pointer+= strlen("</div>");
  }
  strcpy(tmp_pointer, ocelot_grid_detail_char_column_end);
  tmp_pointer+= strlen(ocelot_grid_detail_char_column_end);
  return tmp_pointer - original_tmp_pointer;
}

/*
  Copy in result grid cell. We get here via action_edit_copy(), not overriding QtextEdit::copy().
     If the cell has text then we did setText() and QTextEdit::copy() should work okay.
    The reason that we reimplement copy(), and call it from QKeySequence, is:
    for images we do not do setText(). So we (?) have to loadfromData again and
    put in the clipboard as a pixmap.
    This can be called via QKeySequence (default ^C), menu, or via right-click RightButton see menu_context.
    This gets the entire unclipped image because we're reloading from the source.
    Todo: check for nulls.
    Todo: decide whether we care about select() before copy().
          If it's an image, Copy is enabled even if there's no selection.
    Todo: With Qt4, when program ends, if there was a copy, we might see
          "QClipboard: Unable to receive an event from the clipboard manager in a reasonable time"
          which might be like https://bugreports.qt.io/browse/QTBUG-32853.
 */

/*
It's solved -- see TEST! stuff in cell_analyze(). You just need to transfer some of the code to here.
However, loadFromData as used by TextEditWidget::copy() might have some use too.
Also I'm not really sure it's good enough to copy the cell without selecting it.
*/

void Result_qtextedit::copy()
{
  //if (qtextedit_cell_content == U+FFFC) /* fffc = Unicode object replacement character */
  //{
  //  printf("FFFC\n");
  //  exit(0);
  //}

  QTextEdit::copy();
#ifdef OLD_STUFF
  void TextEditWidget::copy()
  {
    if ((text_edit_frame_of_cell->is_image_flag == true)
    &&  (text_edit_frame_of_cell->content_pointer != 0))
    {
      QPixmap p= QPixmap();
      if (p.loadFromData((const uchar*) text_edit_frame_of_cell->content_pointer,
                         text_edit_frame_of_cell->content_length,
                         0,
                         Qt::AutoColor) == false)
      {
        /* Not readable as an image. Maybe text. Maybe null. */
        QClipboard *p_clipboard= QApplication::clipboard();
        p_clipboard->setText(QString::fromUtf8(text_edit_frame_of_cell->content_pointer,
                             text_edit_frame_of_cell->content_length));
      }
      else
      {
        QClipboard *p_clipboard= QApplication::clipboard();
        p_clipboard->setPixmap(p);
      }
    }
    else QTextEdit::copy();
#endif
}

void Result_qtextedit::changeEvent(QEvent *event)
{
  event->ignore();
}


void Result_qtextedit::closeEvent(QCloseEvent *event)
{
  QTextEdit::closeEvent(event);
}

void Result_qtextedit::focusInEvent(QFocusEvent *event)
{
  if (result_grid->is_fancy() == false){ QTextEdit::focusInEvent(event); return; }
  result_grid->copy_of_parent->menu_activations(this, QEvent::FocusIn);
  QTextEdit::focusInEvent(event);
#ifdef OLD_STUFF
  /* from texteditwidget::focusInEvent() */
  TextEditFrame *t= text_edit_frame_of_cell;
  ResultGrid *r=  t->ancestor_result_grid_widget;
  MainWindow *m= r->copy_of_parent;
  m->menu_activations(this, QEvent::FocusIn);
  /* We probably don't need to say this. */
  QTextEdit::focusInEvent(event);
#endif
}

/* Add ' at start and end of a string. Change ' to '' within string. Compare connect_stripper(). */
/* mysql_hex_string() might be useful for some column types here */
QString Result_qtextedit::unstripper(QString value_to_unstrip)
{
  QString s;
  QString c;

  s= "'";
  for (int i= 0; i < value_to_unstrip.size(); ++i)
  {
    c= value_to_unstrip.mid(i, 1);
    s.append(c);
    if (c == "'") s.append(c);
  }
  s.append("'");
  return s;
}

/*
  Pass: row_number from display, probably qtextedit_grid_row_number
  Return: row_number from result set, usually a simple calculation
*/
int Result_qtextedit::result_row_number_from_grid_row_number(int grid_row_number)
{
#if (OCELOT_EXPLORER == 1)
  /* There might have been skipping and scrolling. Todo: what if for some reason nothing is found? */
  if (result_grid->result_grid_type == EXPLORER_WIDGET)
  {
    unsigned int local_grid_row_number= 0;
    unsigned int r;
    for (r= result_grid->explorer_first_result_row; r < result_grid->copy_of_parent->oei_count; ++r)
    {
      if (result_grid->copy_of_parent->oei[r].display_row_number != -1)
      {
        if ((unsigned int) grid_row_number == local_grid_row_number) break;
        ++local_grid_row_number;
      }
    }
    return r;
  }
#endif
  int result_row_number= grid_row_number + result_grid->grid_vertical_scroll_bar->value();
  if (result_grid->copy_of_ocelot_vertical == 1)
  {
    result_row_number= result_row_number / result_grid->result_column_count;
  }
  else
  {
    if (result_grid->ocelot_result_grid_column_names_copy == 1) --result_row_number;
  }

  return result_row_number;
}

/*
  Pass: row_number from result set
  Return: row_number on grid, or -1 if it's not on grid
          If it's before the first grid row, it's negative, that's okay.
          If it's after the last grid row i.e. max_display_rows in display_html(), that's okay.
*/
int Result_qtextedit::grid_row_number_from_result_row_number(int result_row_number)
{
  int grid_row_number;
  if (result_grid->copy_of_ocelot_vertical == 1)
  {
    grid_row_number= (result_row_number * result_grid->result_column_count) - result_grid->grid_vertical_scroll_bar->value();
  }
  else
  {
    grid_row_number= result_row_number - result_grid->result_column_count;
    if (grid_row_number >= 0)
    {
      if (result_grid->ocelot_result_grid_column_names_copy == 1) ++grid_row_number;
    }
  }
  return grid_row_number;
}

///*
//  Pass: column_number from display, probably qtextedit_grid_column_number
//  Return: column_number from result set, usually a simple calculation
//  Todo: I forget why grid_row_number starts at 1, find out. Apparently minimum column number is 0.
//  In the end we decided not to use this.
//*/
//int Result_qtextedit::result_column_number_from_grid_column_number(int grid_row_number, int grid_column_number)
//{
//  int result_column_number;
//  if (result_grid->copy_of_ocelot_vertical == 1)
//  {
//    --grid_row_number;
//    result_column_number= grid_row_number % result_grid->result_column_count;
//  }
//  else
//  {
//    result_column_number= grid_column_number;
//  }
//  return result_column_number;
//}


/* Taken from TextEditWidget::generate_update() */
/*
  If the user changes the contents of a cell, that indicates a desire to update the row.
  Make a statement: UPDATE table SET changed-columns WHERE short-columns.
  Re WHERE clause:
    Ideally there is a set of columns in the result set which
    appear in a unique not-null index, such as a primary-key index.
    But we don't check for that! We merely check for values which
    are shorter than 128 bytes (thus avoiding most BLOB searches).
    If we get 50 thousand hits, so be it, the user asked for it.
    Alternative: we could put a LIMIT on.
    Alternative: we could SELECT first, and then UPDATE.
    Alternative: we could UPDATE, then ROLLBACK to savepoint if too many.
    Alternative: we could select from information_schema.statistics.
  TODO: figure out what to do with the string -- is it a hint? does it go direct to statement?
        Perhaps: when the user clicks on a different row, or tries to leave: suggest it.
  TODO: If it's binary or blob, we should do the editing as 0x... rather than '...'.
  TODO: Trail spaces should not matter for char, should matter for binary.
  TODO: I am not distinguishing between NULL and 'NULL'
  TODO: If the SELECT originally had a search-condition X = literal, you could incorporate that
  TODO: If different columns come from different tables, update is impossible, do nothing
  TODO: I don't know why I see result_column_count rather than gridx_column_count here
  Re ^Z: It didn't work anyway and I set undoRedoEnabled=false.
*/
#define MAX_WHERE_CLAUSE_LITERAL_SIZE 128   /* arbitrary. maybe should be user-settable. */
void Result_qtextedit::generate_update()
{
  QString content_in_result_set;
  QString content_in_text_edit_widget;
  QString name_in_result_set;
  QString update_statement, where_clause;

  // already done. ResultGrid *result_grid= text_edit_frame_of_cell->ancestor_result_grid_widget;
  MainWindow *m= result_grid->copy_of_parent;
  /* Todo: look for text_edit_frame_of_cell->is_image_flag == true -- if so, byte array */

  /* Todo: This is row# within display. So it is offset. Translate to row# within result set. */
  int xrow;
  xrow= qtextedit_grid_row_number;
  ++xrow; /* possible bug: should this be done if there's no header row? */
  /* Go up the line to find first text_edit_frame for the row */
  /* Content has changed since the last keyPressEvent. */
  /* column number = text_edit_frame_of_cell->ancestor_grid_column_number */
  /* length = text_edit_frame_of_cell->content_length */
  /* field_value_flags = null, numeric, etc. */
  /* *content = text_edit_frame_of_cell->content_pointer, which should be 0 for null */
  update_statement= "";
  where_clause= "";
  char *name_pointer, *table_pointer, *db_pointer;
  unsigned int name_length, table_length, db_length;
  char *field_names_pointer, *org_tables_pointer, *dbs_pointer;
  field_names_pointer= result_grid->result_original_field_names;
  org_tables_pointer= result_grid->result_original_table_names;
  dbs_pointer= result_grid->result_original_database_names;
  unsigned int column_number;
  unsigned int tefi= 0; /* was: text_edit_frame_index_of_first_cell; */

  /* Row# in result set = Row# in display but offset by vertical scroll bar */
  int result_set_row_number= result_row_number_from_grid_row_number(qtextedit_grid_row_number);

  /* Given Row# point to result set row. We'll go through its columns in the loop. */
  char *result_set_copy_pointer;
  result_set_copy_pointer= result_grid->result_set_copy_rows[result_set_row_number];
  for (column_number= 0; column_number < result_grid->result_column_count; )
  {
    /* NB: Don't continue i.e. skip until you move result_set_copy_pointer forward. */
    //char *p= result_set_copy_pointer; /* so p is looking at v_length, flags, contents */
    unsigned int column_v_length;
    char field_value_flags;
    char *column_value;
    memcpy(&column_v_length, result_set_copy_pointer, sizeof(unsigned int));
    field_value_flags= *(result_set_copy_pointer + sizeof(unsigned int));
    column_value= result_set_copy_pointer + sizeof(unsigned int) + 1;
    result_set_copy_pointer+= sizeof(unsigned int) + 1 + column_v_length;
    /* Todo: You must skip if it's a header */
    //text_edit_frame= result_grid->text_edit_frames[tefi];
    //if (text_edit_frame->cell_type == TEXTEDITFRAME_CELL_TYPE_HEADER)
    //{
    //  ++tefi;
    //  continue;
    //}
    memcpy(&name_length, field_names_pointer, sizeof(unsigned int)); /* Checked */
    field_names_pointer+= sizeof(unsigned int);
    name_pointer= field_names_pointer;
    field_names_pointer+= name_length;
    memcpy(&table_length, org_tables_pointer, sizeof(unsigned int)); /* Checked */
    org_tables_pointer+= sizeof(unsigned int);
    table_pointer= org_tables_pointer;
    org_tables_pointer+= table_length;
    memcpy(&db_length, dbs_pointer, sizeof(unsigned int));            /* Not checked. Meaningless if Tarantool */
    dbs_pointer+= sizeof(unsigned int);
    db_pointer= dbs_pointer;
    dbs_pointer+= db_length;
    /* if in UNION or column-expression, or literal, skip it */
    if ((name_length == 0) || (table_length == 0) || (db_length == 0))
    {
      ++column_number;
      ++tefi;
      continue;
    }
    bool is_null= false;
    int l= 0;
    if ((field_value_flags & FIELD_VALUE_FLAG_IS_NULL) != 0) is_null= true; /* distinguish blank from null */
    else
    {
      l= column_v_length;
      content_in_result_set= QString::fromUtf8(column_value, l);
    }
    name_in_result_set= QString::fromUtf8(name_pointer, name_length);
    if (l <= MAX_WHERE_CLAUSE_LITERAL_SIZE)
    {
      if (where_clause == "") where_clause= " WHERE ";
      else where_clause.append(" AND ");
      where_clause.append(name_in_result_set);
      if (is_null == true) where_clause.append(" IS NULL"); /* or check content_field_value_flags */
      else
      {
        where_clause.append("=");
        QString s;
        //if (result_grid->result_field_types[column_number] <= OCELOT_DATA_TYPE_DOUBLE)
        if (field_value_flags == FIELD_VALUE_FLAG_IS_NUMBER)
          s= content_in_result_set;
        else s= unstripper(content_in_result_set);
        where_clause.append(s);
      }
    }
    if (true) /* was: if (text_edit_frame->is_retrieved_flag == true) */
    {
      bool contents_changed_flag= true;
      if ((field_value_flags & FIELD_VALUE_FLAG_IS_IMAGE) != 0)
      {
        /* Todo: I'm assuming we changed the pointers and came in via paste(). I could be wrong. */
        /* Todo: use p, I think it is the same as content_pointer */
        int content_length= column_v_length;
        char *content_pointer= column_value;
        content_in_text_edit_widget="X'";
        char tmp[3];
        for (int i= 0; i < content_length; ++i)
        {
          sprintf(tmp, "%02X", (unsigned char) *(content_pointer+i));
          content_in_text_edit_widget.append(tmp);
        }
        content_in_text_edit_widget.append("'");
        /* TODO: THIS IS JUST A GUESS! */
        contents_changed_flag= true;
      }
      else
      {
        /* Todo: I think this works because we don't change the pointers, but that will change. */
          QTextDocument *qt;
          qt= document();
          QTextBlock qtb;
          /* Todo: Mystery! Why "+ 2"? I calculate it should be "+ 1". */
          int qtb_number= (qtextedit_grid_row_number * (result_grid->result_column_count + 1)) + 2 + column_number;
          qtb= qt->findBlockByNumber(qtb_number);
        content_in_text_edit_widget= qtb.text();

        if ((is_null == true) && (content_in_text_edit_widget == NULL_STRING)) contents_changed_flag= false;
        else if (content_in_text_edit_widget == content_in_result_set) contents_changed_flag= false;
      }
      if (contents_changed_flag == true)
      {
        if (update_statement == "")
        {
          update_statement= "/* generated */ UPDATE ";
          if ((hparse_dbms_mask & FLAG_VERSION_TARANTOOL) == 0)
          {
            update_statement.append(QString::fromUtf8(db_pointer, db_length));
            update_statement.append(".");
          }
          update_statement.append(QString::fromUtf8(table_pointer, table_length));
          update_statement.append(" SET ");
        }
        else update_statement.append(",");
        update_statement.append(name_in_result_set);
        update_statement.append('=');
        //if ((result_grid->result_field_types[column_number] <= OCELOT_DATA_TYPE_DOUBLE)
        if ((field_value_flags == FIELD_VALUE_FLAG_IS_NUMBER)
        || (content_in_text_edit_widget == NULL_STRING)
        || ((field_value_flags & FIELD_VALUE_FLAG_IS_IMAGE) != 0))
          update_statement.append(content_in_text_edit_widget);
        else update_statement.append(unstripper(content_in_text_edit_widget));
      }
    }
    ++column_number;
    ++tefi;
  }
  /* We've got a string. If it's not blank, put it in the statement widget, overwriting. */
  /* It might be blank because user returned to the original values, if so wipe out. */
  CodeEditor *c= m->statement_edit_widget;
  if (update_statement != "")
  {
    update_statement.append(where_clause);
    update_statement.append(";");
    c->setPlainText(update_statement);
  }
  else
  {
    if (c->toPlainText().mid(0, 23) == "/* generated */ UPDATE ") c->setPlainText("");
  }
}

/*
  Todo: see what we do with main widgets when they lose focus
  Todo: I'm not even sure that we get here, maybe event filter catches focusOutEvent
        (Update: we do get here when showing explorer and right-clicking to get context menu)
  Todo: If we did a mousepress then the cursor is blinking. Figure out how to turn it off
*/
#ifdef OLDSTUFF
TextEditFrame *t= text_edit_frame_of_cell;
ResultGrid *r=  t->ancestor_result_grid_widget;
MainWindow *m= r->copy_of_parent;
m->menu_activations(this, QEvent::FocusOut);
/* We probably don't need to say this. */
QTextEdit::focusOutEvent(event);
#endif
void Result_qtextedit::focusOutEvent(QFocusEvent *event)
{
  if (result_grid->is_fancy() == false) { QTextEdit::focusOutEvent(event); return; }
  result_grid->copy_of_parent->menu_activations(this, QEvent::FocusOut);
}

/*
  User pressed a key on result grid. It might be for shortcut, it might be editing.
  It doesn't supply event-x() or event-y() so we depend on what we saved during mouseMoveEvent.
  Perhaps we could have used QCursor position instead and translated global to local.
  Mostly copied from void TextEditWidget::keyPressEvent(QKeyEvent *event)
  todo: call event->ignore() if cursor at end | between cells, or if event->key() == Qt::Key_Enter, etc.
        (or maybe I mean event->accept()? but that's default anyway)
  Todo: maybe there is a smarter way to detect if cell is for header? texteditframe_cell_type_header?
*/

void Result_qtextedit::keyPressEvent(QKeyEvent *event)
{
  if (result_grid->is_fancy() == false) { QTextEdit::keyPressEvent(event); return; }
  if (result_grid->result_grid_type == EXPLORER_WIDGET)
  {
    QKeyEvent *key= event;
//    if (key->key() == Qt::Key_Down) ...
    if ((key->key() == Qt::Key_Up) || (key->key() == Qt::Key_Down))
    {
      int frrn= result_grid->focus_result_row_number;            /* = result row of current focus */
      /* skip if frrn = 0 already? */
      int prev_visible= -1;
      int next_visible= -1;
      int fdrn= result_grid->copy_of_parent->oei[frrn].display_row_number;       /* = focus's display row number */
      for (unsigned int i= 0; i < result_grid->copy_of_parent->oei_count; ++i)     /* go through oei skipping invisibles */
      {
        int n= result_grid->copy_of_parent->oei[i].display_row_number;
        if (n != -1)
        {
          if (n == fdrn - 1) { prev_visible= i; }
          if (n == fdrn + 1) { next_visible= i; }
          if (n == fdrn) { ; }
        }
      }
      int gvsbv= result_grid->grid_vertical_scroll_bar_value;
      if (key->key() == Qt::Key_Up)
      {
        if (prev_visible == -1) return;
        fdrn= prev_visible;
        int fdrid= result_grid->explorer_first_result_row;
        if (fdrn < fdrid)
        {
          result_grid->focus_result_row_number= fdrn;
          result_grid->grid_vertical_scroll_bar->triggerAction(QAbstractSlider::SliderSingleStepSub);
          return; /* explorer_display_html should be done by vertical_scroll_bar_event() */
        }
      }
      else
      {
        if (next_visible == -1) return;
        fdrn= next_visible;
        int fdrid= result_grid->explorer_first_result_row;
        int fddid= result_grid->copy_of_parent->oei[fdrid].display_row_number;
        unsigned int last_row_in_display=  fddid + result_grid->html_max_grid_rows;
        unsigned int this_row_in_display=  result_grid->copy_of_parent->oei[fdrn].display_row_number;
        if (this_row_in_display == last_row_in_display)
        {
          int fdrn_new_value= result_grid->copy_of_parent->oei[fdrn].display_row_number;
          result_grid->focus_result_row_number= fdrn;
          result_grid->grid_vertical_scroll_bar->setValue(fdrn_new_value);
          return; /* explorer_display_html should be done by vertical_scroll_bar_event() */
        }
      }
      result_grid->focus_result_row_number= fdrn; /* we get here if we don't need to scroll */
      result_grid->explorer_display_html(gvsbv);
    }
//    /* assume accept() */
    return;
  }
  MainWindow *m= result_grid->copy_of_parent;

  /* TEXT!!!! TODO: I DO NOT KNOW WHAT THIS WAS FOR. MAYBE IT SHOULD BE RESTORED. */
  // if (m->keypress_shortcut_handler(event) == true)
  //{
  //  printf("**** keypress_shortcut_handler(true) returned true\n");
  //  copy();
  //  return;
  //}

  if (m->keypress_shortcut_handler(event) == true)
  {
    /* Todo: shortcut but not ignore. Am I supposed to accept? */
    return;
  }
  QString content_in_cell_before_keypress= qtextedit_cell_content;
  bool is_printable= true;
  if (qtextedit_at_end == true) {is_printable= false; }
  if (qtextedit_is_before_column == true) {is_printable= false; }
  if (qtextedit_is_before_row == true) {is_printable= false; }
  if (qtextedit_column_number == 0) {is_printable= false; }
  if (qtextedit_y < (int) (result_grid->setting_ocelot_grid_cell_border_size_as_int)) {is_printable= false; }
  if (result_grid->is_image(qtextedit_column_number) == true) {is_printable= false; }
  if (result_grid->copy_of_ocelot_result_grid_column_names == 1)
  {
    if (result_grid->copy_of_ocelot_vertical == 1)
    {
      if (((qtextedit_column_number - 1) % 2) == 0)
      {
        is_printable= false;
      }
    }
    else
    {
      if (qtextedit_grid_row_number == 0)
      {
        is_printable= false;
      }
    }
  }

  if (result_grid->copy_of_ocelot_result_grid_column_names == 1)
  {
    if (result_grid->copy_of_ocelot_vertical == 1)
    {
      if (((qtextedit_column_number - 1) % 2) == 0)
      {
        is_printable= false;
      }
    }
    else
    {
      if (qtextedit_grid_row_number == 0)
      {
        is_printable= false;
      }
    }
  }

  Qt::KeyboardModifiers modifiers= event->modifiers();
  if ((modifiers & Qt::ControlModifier) != 0) {is_printable= false; }
  if ((modifiers & Qt::ShiftModifier) != 0)  {; }
  if ((modifiers & Qt::AltModifier) != 0)  {is_printable= false; }
  if ((modifiers & Qt::MetaModifier) != 0)  {is_printable= false; }

  if (is_printable == false) return;

  QTextEdit::keyPressEvent(event);

  cell_analyze(qtextedit_x, qtextedit_y); /* keypress might cause cursor movement but still within column (?) */
  QString content_in_cell_after_keypress= qtextedit_cell_content;
  if (content_in_cell_before_keypress != content_in_cell_after_keypress)
  {
    generate_update();
  }
}

//void Result_qtextedit::key_up_or_down(QKeyEvent *event)
//{
//  ;
//}

/*
  Cell content = qtextedit_cell_content, unless it's an image.
  But we will need to somehow track and get rid of <br>s which will show p as \n.
*/
QString Result_qtextedit::to_plain_text()
{
  return "";
}

void Result_qtextedit::mouseDoubleClickEvent(QMouseEvent *event)
{
#if (OCELOT_EXPLORER == 1)
  if (result_grid->result_grid_type == EXPLORER_WIDGET)
  {
    cell_analyze(event->pos().x(), event->pos().y());
    /* Append to statement_edit_text! Compare completer_widget::mouseDoubleClickEvent */
    QString text= result_grid->copy_of_parent->statement_edit_widget->toPlainText();
    text= text + qtextedit_cell_content;
    result_grid->copy_of_parent->statement_edit_widget->setPlainText(text);
  }
#endif
  QTextEdit::mouseDoubleClickEvent(event);
}

void Result_qtextedit::mouseMoveEvent(QMouseEvent *event)
{
  if (result_grid->is_fancy() == false) { QTextEdit::mouseMoveEvent(event); return; }
  cell_analyze(event->pos().x(), event->pos().y());
  QString tip= "";
  //tip= tip + "block_count=" + QString::number(qtextedit_block_count);
  //tip= tip + " columns_per_row=" + QString::number(qtextedit_columns_per_row);
  tip= tip + " x=" + QString::number(qtextedit_x);
  tip= tip + " y=" + QString::number(qtextedit_y);
  //tip= tip + " Block=" + QString::number(qtextedit_block_number);
  tip= tip + " Grid_Row=" + QString::number(qtextedit_grid_row_number);
  tip= tip + " Result_row=" + QString::number(qtextedit_result_row_number);
  tip= tip + " Column  " + QString::number(qtextedit_column_number);
  if (qtextedit_is_before_column) tip= tip + " (is_before_column)";
  if (qtextedit_is_before_row) tip= tip + " (is_before_row)";
  tip= tip + " x_start= " + QString::number(qtextedit_x_start);
  tip= tip + " x_end= " + QString::number(qtextedit_x_end);
  tip= tip + " y_start= " + QString::number(qtextedit_y_start);
  tip= tip + " y_end= " + QString::number(qtextedit_y_end);
  //tip= tip + " content=" + qtextedit_cell_content; removed because big contents cause slowdown

#if (OCELOT_EXPLORER == 1)
  if ((result_grid->result_grid_type == EXPLORER_WIDGET)
   && (qtextedit_at_end == false))
  {
    /* Todo: probably this lookup method is duplicated somewhere, and is more complete somewhere. */
    QString row_type= result_grid->copy_of_parent->oei[qtextedit_result_row_number].object_type;
    if (row_type == "S") tip= "Schema";
    if (row_type == "T") tip= "Table";
    if (row_type == "V") tip= "View";
    if (row_type == "C") tip= "Column";
    if (row_type == "I") tip= "Index";
    if (row_type == "F") tip= "Function";
    if (row_type == "P") tip= "Procedure";
    if (row_type == "R") tip= "Trigger";
    tip= tip + ". Right-click to see context menu. ";
  }
#endif
  if (qtextedit_at_end == true) tip= tip + " (At End)"; /* If this is so, nothing else matters */

  setToolTip(tip);
  if (qtextedit_is_before_column) viewport()->setCursor(Qt::SizeHorCursor);
  else if (qtextedit_is_before_row) viewport()->setCursor(Qt::SizeVerCursor);
  else viewport()->unsetCursor();
  QTextEdit::mouseMoveEvent(event);
  return;
}

/*
  cell_analyze() -- get statistics about the cell that's at position x, y.
   Todo: Find out why there is 1 additional white pixel in the border.
         There should be no pixels before the left border because we called document()->setDocumentMargin(0);
         I've set spacing to 0 and padding to 0, but it doesn't seem to have an effect.
   Todo: Research whether detaching the grid widget might change something that you set here.
   grid_column_size_calc() adds + setting_ocelot_grid_cell_border_size_as_int * 2
   grid_column_size_calc() adds + setting_ocelot_grid_cell_drag_line_size_as_int
   Usually the desired column width is calculable based on what grid_column_size_calc() delivered.
   But this routine is for getting the actual width etc., which might be quite different.
*/
void Result_qtextedit::cell_analyze(int x, int y)
{
  qtextedit_block_count= document()->blockCount();

  qtextedit_block_number= qtextedit_grid_row_number= qtextedit_column_number= 0;
  qtextedit_is_before_column= qtextedit_is_before_row= false;

  qtextedit_columns_per_row= result_grid->gridx_column_count + 1; /* +1 because of thin image on the left */
  qtextedit_x= x;
  qtextedit_y= y;

  //if (qtextedit_block_count <= 1)
  //{
  //  /* There should be at least two blocks, counting the thin image */
  //  /* Todo: If it's not HTML or we returned that the result set is empty, this can happen. */
  //  printf("**** too small\n");
  //  exit(0);
  //}
  QTextCursor text_cursor_0= cursorForPosition(QPoint(x, y));
  if (text_cursor_0.atEnd() == true)
  {
    /* TODO: THIS CAN HAPPEN -- SO ELSEWHERE DO NOT DEPEND ON QTEXTEDIT_GRID_ROW_NUMBER ETC.  */
    qtextedit_at_end= true;
    return;
  }
  //if (text_cursor_0.blockNumber() == 0)
  //{
  //  printf("**** blockNumber == 0\n");
  //  exit(0);
  //}
  //if (text_cursor_0.blockNumber() > qtextedit_block_count)
  //{
  //  printf("text_cursor_0.blockNumber() > qtextedit_block_count\n");
  //  exit(0);
  //}
  qtextedit_at_end= false;

  QTextCursor text_cursor= cursorForPosition(QPoint(x, y));
  qtextedit_block_number= text_cursor.blockNumber() - 1;
  qtextedit_grid_row_number= qtextedit_block_number / qtextedit_columns_per_row;
  qtextedit_result_row_number= result_row_number_from_grid_row_number(qtextedit_grid_row_number);  qtextedit_column_number= qtextedit_block_number % qtextedit_columns_per_row;
  int border_size= result_grid->copy_of_parent->ocelot_grid_cell_border_size.toInt();
  qtextedit_is_before_column= false;
  qtextedit_is_before_row= false;
  QTextCursor text_cursor_2= cursorForPosition(QPoint(x + border_size * 2, y));
  int block_number_2= text_cursor_2.blockNumber() - 1;
  if (qtextedit_block_number != block_number_2) qtextedit_is_before_column= true;
  QTextCursor text_cursor_3= cursorForPosition(QPoint(x, y + border_size * 2));
  int block_number_3= text_cursor_3.blockNumber() - 1;
  if (qtextedit_block_number != block_number_3) qtextedit_is_before_row= true;
  for (qtextedit_x_start= x - 1; qtextedit_x_start > border_size * 2; --qtextedit_x_start)
  {
    QTextCursor text_cursor_4= cursorForPosition(QPoint(qtextedit_x_start, y));
    int block_number_4= text_cursor_4.blockNumber() - 1;
    if (qtextedit_block_number != block_number_4) break;
  }
  ++qtextedit_x_start;
  for (qtextedit_x_end= qtextedit_x_start; qtextedit_x_end > border_size * 2; ++qtextedit_x_end)
  {
    QTextCursor text_cursor_5= cursorForPosition(QPoint(qtextedit_x_end, y));
    int block_number_5= text_cursor_5.blockNumber() - 1;
    if (qtextedit_block_number != block_number_5) break;
  }
  --qtextedit_x_end;
  for (qtextedit_y_start= y - 1; qtextedit_y_start > border_size * 2; --qtextedit_y_start)
  {
    QTextCursor text_cursor_6= cursorForPosition(QPoint(x, qtextedit_y_start));
    int block_number_6= text_cursor_6.blockNumber() - 1;
    if (qtextedit_block_number != block_number_6) break;
  }
  ++qtextedit_y_start;
  for (qtextedit_y_end= qtextedit_y_start; qtextedit_y_end > border_size * 2; ++qtextedit_y_end)
  {
    QTextCursor text_cursor_7= cursorForPosition(QPoint(x, qtextedit_y_end));
    int block_number_7= text_cursor_7.blockNumber() - 1;
    if (qtextedit_block_number != block_number_7) break;
  }
  --qtextedit_y_end;
  QTextDocument *qt;
  qt= document();
  QTextBlock qtb;
  qtb= qt->findBlockByNumber(qtextedit_block_number + 1);
  qtextedit_cell_content= qtb.text();

#if (QT_VERSION >= 0x50000)
  /* See also https://stackoverflow.com/questions/18700945/qtextbrowser-how-to-identify-image-from-mouse-click-position */
  {
    QTextCursor qtc= cursorForPosition(QPoint(x, y));
    QTextCharFormat fmt = qtc.charFormat();
    if (fmt.isImageFormat() == true)
    {
      QTextImageFormat image_format = fmt.toImageFormat();
      QString image_format_name= image_format.name();
      //char tmp_image_format_name[65536];
      //strcpy(tmp_image_format_name, image_format_name.toUtf8());
      //printf("**** image_format_name=%s.\n", tmp_image_format_name);
      QVariant qv= qt->resource(QTextDocument::ImageResource, image_format_name);
      QImage qi= qv.value<QImage>();
      QClipboard *p_clipboard= QApplication::clipboard();
      p_clipboard->setImage(qi);
    }
  }
#endif
}

#ifdef OLD_STUFF
void TextEditFrame::mousePressEvent(QMouseEvent *event)
{
  if (event->button() == Qt::LeftButton)
  {
    left_mouse_button_was_pressed= 1;
  }
  /* We don't look for Qt::RightButton because we have menu_context in MainWIndow. */
}
#endif
/*
 Todo: We've calculated c.position(), we should be able to say what column we're in (or bar between columns).
       (requires blocknumber() and assume we do not wrap, or else see https://stackoverflow.com/questions/15814776/how-do-i-get-the-actual-visible-cursors-line-number
 Todo: button() has flags, it's possible that more than one button is being pressed.
 would eventClicked() be better?
 See also https://www.qtcentre.org/threads/45645-QTextEdit-cursorForPosition()-and-character-at-mouse-pointer
 Todo: I think dragging is only for left button. so add   if (!(event->buttons() & Qt::LeftButton))
 Re focus_result_row_number and focus_column_number:
   We recognize mousePressEvent as a focus change. To show it, we change the background color with bgcolor.
   This gets overridden if there is a conditional setting too. We do not change it if the result set loses
   focus. We don't change color if mousePressEvent is on the header or outside the table. Default color is
   "Wheat" as can be seen in the Settings menu.
   It's a mystery to me that color_change() caused cursor disappearance because QTextCursor confuses me.
   I see that color_change() calls display_html() so maybe this won't the be only cursor-loser situation.
   There's a workaround at the end of this routine
 Re cell_analyze: Usually we can depend on mouseMoveEvent doing this, but it won't get activated if there is
                  a context menu and we move out of it to Result_qtextedit. Same problem with mouseDoubleClick.
                  I don't know why the problem occurs, perhaps it involves an edit filter or a focus event.
 Todo: After I've said mousePressEvent, there's an endless calling of paintEvent although nothing happened.
       It doesn't hog CPU and disappears after the next statement, but presumably something went wrong.
       Todo: Here's a theory to check: it's merely because the cursor is blinking.
  Todo: See also menu_context_t_2_explorer() which I hope won't conflict with right-click causing mousePressEvent.
*/
void Result_qtextedit::mousePressEvent(QMouseEvent *event)
{
  if (result_grid->is_fancy() == false) { QTextEdit::mousePressEvent(event); return; }
  if (result_grid->result_grid_type == EXPLORER_WIDGET) cell_analyze(event->pos().x(), event->pos().y());
  result_grid->focus_result_row_number= result_row_number_from_grid_row_number(qtextedit_grid_row_number); /* so that background = Grid Focus Cell Background Color */
  result_grid->focus_column_number= qtextedit_column_number;

  qtextedit_is_in_drag_for_column= qtextedit_is_in_drag_for_row= false;
  if ((qtextedit_column_number > 0) && (qtextedit_is_before_column))
  {
    qtextedit_is_in_drag_for_column= true;
    qtextedit_drag_start_x= event->pos().x();
    qtextedit_column_number_at_drag_start_time= qtextedit_column_number;
  }
  if (qtextedit_is_before_row == true)
  {
    qtextedit_is_in_drag_for_row= true;
    qtextedit_drag_start_y= event->pos().y();
    qtextedit_grid_row_number_at_drag_start_time= qtextedit_grid_row_number;
    qtextedit_result_row_number_at_drag_start_time= qtextedit_result_row_number;
  }
  if ((qtextedit_is_in_drag_for_column == true) || (qtextedit_is_in_drag_for_row == true))
  {
    qtextedit_drag_start_time= QDateTime::currentMSecsSinceEpoch();
  }
#if (OCELOT_EXPLORER == 1)
  if ((result_grid->result_grid_type == EXPLORER_WIDGET)
   && (qtextedit_is_in_drag_for_column == false) && (qtextedit_is_in_drag_for_row == false)
   && (event->button() == Qt::LeftButton)
   && (qtextedit_column_number == 1)
   && (qtextedit_cell_content > ""))
  {
    qtextedit_is_min_max_clicked= true;
    /* TODO: find out why I have to say "return;" here! */
    return;
  }
#endif
  QTextEdit::mousePressEvent(event);
  result_grid->color_change();
  QTextCursor text_cursor_0= cursorForPosition(QPoint(qtextedit_x, qtextedit_y));
  text_cursor_0.movePosition(QTextCursor::NoMove);
  setTextCursor(text_cursor_0);

  return;
  //if (event->button() == Qt::LeftButton) printf("****    Qt::LeftButton\n");
  //if (event->button() == Qt::RightButton) printf("****    Qt::RightButton\n");
  QTextCursor c= cursorForPosition(event->pos());
  //int position= c.position();
  //QRect r= cursorRect(c);

  QString s= this->toPlainText();
  //char tmp_s[512];
  //strcpy(tmp_s, s.mid(position,3).toUtf8());
  //printf("****     characters = %s.\n", tmp_s);

  for (unsigned int i= 0; i < result_grid->gridx_column_count; ++i)
  {
    ; /* Here we try to find out what column number matches the cursor position */
//    printf("****     i=%d. field_number=%d\n", i, result_widget->result_columns[i].field_number);
//    printf("****     width_in_pixels=%d\n", result_widget->result_columns[i].width_in_pixels);
  }

  for (unsigned int i= 0; i < 110; ++i)
  {
    QPoint p= QPoint(i, event->pos().y());
    c= cursorForPosition(p);
    QString s= toPlainText();
    QString s2= s.mid(c.position(), 1);
    //char s2_tmp[64];
    //strcpy(s2_tmp, s2.toUtf8());
    //printf("****    i=%d, c.position()=%d, s2=%s.\n", i, c.position(), s2_tmp);
  }

  QTextEdit::mousePressEvent(event);
}

/*
  Dragging Theory.
  Todo: Put this comment in an obvious place.
  Dragging is:
    mousePressEvent (left button only?), on a boundary
    interval, mouseMoveEvent distance,
    mouseRelease.
  We can't allow dragging to the left that reduces column size to less than a minimum.
  We should change the tooltip and the cursor (https://doc.qt.io/qt-5/qcursor.html) to show dragging is happening.
  Todo: what if we lose focus, should drag flag go off?
  Todo: I removed the check of QApplication::startDragTime() because I thought it was too short. Revive?
  Todo: This isn't working for the header row, although I think the blame for that lies elsewhere.
  Todo: This is only working for row_number within display, it should be for row_number within result set.
        Probably the way to do this is by adding a different type of entry in Result_changes.
  Todo: it might look nicer to do this during movemouseMoveEvent() so change is continuous until release.
  Todo: Check for minimum width and minimum height.
  Todo: Bug: After you drag a column, the new width is still there for the next result set selected.
*/
void Result_qtextedit::mouseReleaseEvent(QMouseEvent *event)
{
  if (result_grid->is_fancy() == false) { QTextEdit::mouseReleaseEvent(event); return; }
#if (OCELOT_EXPLORER == 1)
  if (result_grid->result_grid_type == EXPLORER_WIDGET)
  {
    if (qtextedit_is_min_max_clicked == true)
    {
      qtextedit_is_min_max_clicked= false;
      result_grid->explorer_toggle(result_grid->focus_result_row_number);
    }
  }
#endif
  if ((qtextedit_is_in_drag_for_column == true) || (qtextedit_is_in_drag_for_row == true))
  {
    bool is_dragged= false;
//    if ((QDateTime::currentMSecsSinceEpoch() - qtextedit_drag_start_time) >= QApplication::startDragTime())
    {
      if ((qtextedit_is_in_drag_for_column == true)
       && (qtextedit_column_number_at_drag_start_time >= 1))
      {
        int moved_x= event->pos().x() - qtextedit_drag_start_x;
        if (abs(moved_x) >= QApplication::startDragDistance())
        { /* Drag relevant column right or left */
          if (result_grid->copy_of_ocelot_vertical == 0)
          {
            result_grid->grid_column_widths[qtextedit_column_number_at_drag_start_time - 1]+= moved_x;
          }
          else
          {
            if ((result_grid->copy_of_ocelot_result_grid_column_names == 1)
             && (qtextedit_column_number_at_drag_start_time == 1))
              result_grid->result_grid_vertical_width_of_header+= moved_x;
            else
              result_grid->result_grid_vertical_width_of_value+= moved_x;
          }
          is_dragged= true;
        }
      }
      if (qtextedit_is_in_drag_for_row == true)
      {
        int moved_y= event->pos().y() - qtextedit_drag_start_y;
        if (abs(moved_y) >= QApplication::startDragDistance())
        { /* Drag relevant row up or down */
          /* Todo: maybe it should be qtextedit_result_row_number_at_drag_start_time? No, dangerous. */
          result_grid->grid_row_heights[qtextedit_grid_row_number_at_drag_start_time]+= moved_y;
          is_dragged= true;
        }
      }
    }
    qtextedit_is_in_drag_for_column= qtextedit_is_in_drag_for_row= false;
    if (is_dragged == true) result_grid->display_html(result_grid->grid_vertical_scroll_bar->value(), 0); /* refresh */
  }
  QTextEdit::mouseReleaseEvent(event);
}
#ifdef OLD_STUFF
/*
  This is an event that happens if a result-set grid cell comes into view due to scrolling.
  It can happen multiple times, and it can happen before we're ready to do anything (mysteriously).
  But it's great for handling result sets that have many cells, because some actions are slow.
  For example, setStyleSheet takes 2+ seconds when there are hundreds of child widgets.
  Todo: only apply setStyleSheet if new cell or if style change
  Todo: check if anything that we're calling from paintEvent is causing another paintEvent
*/
void TextEditFrame::paintEvent(QPaintEvent *event)
{
  if (event == 0) return; /* this is just to avoid an "unused parameter" warning */
  if (ancestor_result_grid_widget->is_paintable == 1)
  {
    /*
      Sometimes spurious text_edit_frames show up as if ready to paint.
      Todo: find out if there's a known Qt bug that might explain this.
      It's possible that it no longer happens now that I'm saying "hide()" more often.
    */
    if (text_edit_frames_index >= ancestor_result_grid_widget->max_text_edit_frames_count)
    {
      printf("Trying to paint a texteditframe that isn't in the layout\n");
      printf("  text_edit_frames_index=%d\n", text_edit_frames_index);
      printf("  max_text_edit_frames_count=%d\n", ancestor_result_grid_widget->max_text_edit_frames_count);
    }
    else
    {
      TextEditWidget *text_edit= findChild<TextEditWidget *>();
      if (text_edit != 0)
      {
        style_sheet_setter(this, text_edit);
        if (is_retrieved_flag == false)
        {
          if (is_image_flag == false)
          {
            if (content_pointer == 0) /* or check content_field_value_flags */
            {
              text_edit->setText(QString::fromUtf8(NULL_STRING, sizeof(NULL_STRING) - 1));
            }
            else text_edit->setText(QString::fromUtf8(content_pointer, content_length));
          }
          is_retrieved_flag= true;
        }
      }
    }
  }
}

/*
 Finally we're ready to paint a cell inside a frame inside a grid row inside result widget.
 The final decision is: paint as text (default) or paint as image (if blob and if flag).
 If it's a non-blob or if the relevant blob flag is off: default paint.
 If it's a blob and ocelot_extra_rule_1_display_as == "image" is on:
   make a pixmap from the contents
   draw the pixmap
   todo: we're allowing resizing (miraculously) but there's no option for scrolling
   todo: consider: is there some better way to decide whether or not to display as image?
*/

void TextEditWidget::paintEvent(QPaintEvent *event)
if (text_edit_frame_of_cell->is_image_flag == false)
{
  QTextEdit::paintEvent(event);
  return;
}

if (text_edit_frame_of_cell->content_pointer == 0) /* or check content_field_value_flags */
{
  setText(QString::fromUtf8(NULL_STRING, sizeof(NULL_STRING) - 1));
  QTextEdit::paintEvent(event);
  return;
}

//QPixmap p= QPixmap(QSize(event->rect().width(), event->rect().height()));
QPixmap p= QPixmap();
if (p.loadFromData((const uchar*) text_edit_frame_of_cell->content_pointer,
                   text_edit_frame_of_cell->content_length,
                   0,
                   Qt::AutoColor) == false)
{
  /* Todo: check above. Haven't we alread esitablished that content_pointer != 0? */
  if (text_edit_frame_of_cell->content_pointer != 0)  /* or check content_field_value_flags */
  {
    setText(QString::fromUtf8(text_edit_frame_of_cell->content_pointer,
                              text_edit_frame_of_cell->content_length));
  }
  QTextEdit::paintEvent(event);
  return;
}
QPainter painter(this->viewport());

/*
  There were choices for QPixmap display. We could have said Qt::IgnoreAspectRatio (the default)
  or Qt::KeepAspectRatioByExpanding. We could have used this->viewport()->size().
  We could have shown a fragment with a scrollbar.
  We could have shown a portion without a scrollbar (one can see the rest by dragging)
  by leaving out the line with the "p.scaled()" function. Maybe users would want such choices?
  Anyway, the line here was wrong:
  p= p.scaled(event->rect().size(), Qt::KeepAspectRatio);
  because event->rect().size() is constantly changing.
  I'm not sure whether this->width(), this->height() might be a few
  pixels too large, but am not seeing noticeable harm.
*/
p= p.scaled(this->width(), this->height(), Qt::KeepAspectRatio);
painter.drawPixmap(0, 0, p);
//painter.drawPixmap(event->rect(), p);
return;
#endif
/* Todo: Find out why this is called repeatedly when visible, even if nothing's going on. */
void Result_qtextedit::paintEvent(QPaintEvent *event)
{
  QTextEdit::paintEvent(event);
}

/*
  Cut in result grid cell. We get here via action_edit_cut(), not overriding QtextEdit::cut().
  It was never in TextEditWidget.
*/
void Result_qtextedit::cut()
{
  QTextEdit::cut();
}

/*
  Select all in result grid cell. We get here via action_edit_select_all(), not overriding QtextEdit::selectAll().
  It was never in TextEditWidget.
*/
void Result_qtextedit::selectAll()
{
  QTextEdit::selectAll();
}

/*
  Currently zoomIn and zoomOut are handled via MainWindow::action_edit_zoominorout(int increment).
  See the comments there. So Result_qtextedit::zoomIn() Result_qtextedit::zoomOut() shouldn't happen.
*/
void Result_qtextedit::zoomIn()
{
  QTextEdit::zoomIn();
}
void Result_qtextedit::zoomOut()
{
  QTextEdit::zoomOut();
}

/*
  Undo in result grid cell. We get here via action_edit_undo(), not overriding QtextEdit::undo().
  But undoredoenabled is false so we probably will never get to here. It was never in TextEditWidget.
*/
void Result_qtextedit::undo()
{
  QTextEdit::undo();
}

/*
  Redo in result grid cell. We get here via action_edit_redo(), not overriding QtextEdit::redo().
  But undoredoenabled is false so we probably will never get to here. It was never in TextEditWidget.
*/
void Result_qtextedit::redo()
{
  QTextEdit::redo();
}

/*
  Paste to result grid cell. We get here via action_edit_paste(), not overriding QtextEdit::paste().
  Todo: call generate_update() i.e. generate an UPDATE statement.
  Re images:
    This is a Work in progress. So far, we detect that the clipboard has
    a pixmap, and if so we convert the pixmap to a byte array following
    https://doc.qt.io/qt-5/qpixmap.html#save-1, and we copy that to a
    permanent char[], and we save the bytes so that (I think)
    copy_html_cell() is seeing it and overwriting the old pixmap.
    An advantage is that scrolling and then coming back, we'll see the new image.
    But the job is only half done.
    Todo: allow undo, which would require saving the old pointers.
    Todo: generate an UPDATE statement.
    Todo: have an array of char[] not just one, and delete it when result set is closed.
          (right now there is only one and it leaks, look at the "new" instruction inside the function)
    Todo: check if is_retrieved_flag is necessary, and is all you need.
    Todo: maybe there should be another flag to indicate "a paste happened here".
    Todo: the same technique could be applied to non-images though may be unnecessary.
    Todo: make this a no-op if user is pasting an image to a non-image cell.
          (but if the old value is NULL we might change it to an image, I suppose)
    Todo: try removing "PNG" argument.
    Todo: need more error checks, including for "new".
    Todo: we're not falling through to QTextEdit::paste(). Is there any benefit in that?
          I think it was causing "QXcbClipboard: SelectionRequest too old", but should test.
    Todo: research: is there a way to get clipboard contents to char[] with fewer steps?
    Todo: image_as_char is a memory leaker.
    Some image code was copied from QTextEdit::paste().
    Todo: This works in image paste experiment, which is where I copy an image from Pinta,
          ^V in a result set, scroll, and see that row#2 column#2 is an image. Whoopee.
          Now get rid of the leak, allow for more than one paste, determine correct row # column,
          and display the change immediately without waiting for scroll. Still lots to do!
*/
void Result_qtextedit::paste()
{
  if (result_grid->is_fancy() == false) { QTextEdit::paste(); return; }
  QPixmap p;
  QClipboard *p_clipboard= QApplication::clipboard();
  p= p_clipboard->pixmap(QClipboard::Clipboard);
  if (p.isNull() == false)
  {
    /* It is a pixmap. See the comments preceding this function. */
    QByteArray image_as_byte_array;
    QBuffer buffer(&image_as_byte_array);
    buffer.open(QIODevice::WriteOnly);
    if (p.save(&buffer, "PNG"))
    {
      /* image paste experiment */
      qtextedit_result_changes->append(qtextedit_grid_row_number, qtextedit_column_number, &image_as_byte_array);
      return;
    }
  }
  QTextEdit::paste();
}

/* I don't know what cause Result_qtextedit::hideEvent(). Maybe ResultGrid::hideEvent()? */
/* Although I do have html_text_edit->hide() in display_batch() */
void Result_qtextedit::hideEvent(QHideEvent *event)
{
  QTextEdit::hideEvent(event);
}

void Result_qtextedit::resizeEvent(QResizeEvent *event)
{
  QTextEdit::resizeEvent(event);
}

/*
  Do not show html_text_edit if batch_text_edit is visible and is all that's supposed to be visible.
  Todo: Someday find out what causes this event while html_text_edit is hidden. Maybe parent tab show?
*/
void Result_qtextedit::showEvent(QShowEvent *event)
{
  QTextEdit::showEvent(event);
}

/*
   Todo: We know what is at pos but do nothing about it.
   Will this conflict with right-button keypress?
*/
void Result_qtextedit::menu_context_t_2(const QPoint & pos)
{
  result_grid->copy_of_parent->menu_context(pos);
}

#if (OCELOT_EXPLORER == 1)
/* Comments about Context_menu should be in ocelotgui.h before the words "class Context_menu: public QWidget" */
void Result_qtextedit::menu_context_t_2_explorer(const QPoint & pos)
{
  explorer_context_menu->menu_context_t_2_explorer(pos);
  return;
}

#endif

/******************** Result_qtextedit end   ************************************/

/******************** TextEditWidget2 start ************************************/

TextEditWidget2::TextEditWidget2(QString the_text, QWidget *parent, int minimum_width) :
        QTextEdit(the_text, parent) /* constructor */
{
  passed_minimum_width= minimum_width;
}

QSize TextEditWidget2::sizeHint() const
{
  QRect text_edit_rect;
  QFontMetrics fm= QFontMetrics(font());
  text_edit_rect= fm.boundingRect(
        0, /* int x = x coordinate within original rect */
        0, /* int y = y coordinate within original rect */
        passed_minimum_width, /* int width = r.width(), which we don't change */
        2000, /* int height = height, which is arbitrary big maximum */
        Qt::TextWordWrap + Qt::TextIncludeTrailingSpaces, /* int flags = (see comments before start of this routine) */
        toPlainText()); /* QString & text= cell contents */
  int n= text_edit_rect.height() + fm.lineSpacing();
  if (n > 500) n= 500;
  return QSize(passed_minimum_width, n);
}

TextEditWidget2::~TextEditWidget2()
{
}

/******************** TextEditWidget2 end ************************************/

/******************** Row_form_box start ************************************/

Row_form_box::Row_form_box(int column_count, QString *row_form_label,
             int *row_form_type,
             int *row_form_is_password, QString *row_form_data,
//             QString *row_form_width,
             QString row_form_title, QString row_form_message,
             MainWindow *parent): QDialog(parent) /* constructor */
{
  int i;
  this_row_form_box= this;
  copy_of_parent= parent;
  column_count_copy= column_count;
  row_form_is_password_copy= row_form_is_password;
  row_form_data_copy= row_form_data;
  main_layout= 0;
  label_for_message= 0;
  label= 0;
  line_edit= 0;
  text_edit= 0;
  combo_box_edit= 0;
  hbox_layout= 0;
  widget= 0;
  button_for_cancel= 0;
  button_for_ok= 0;
  hbox_layout_for_ok_and_cancel= 0;
  widget_for_ok_and_cancel= 0;
  scroll_area= 0;
  widget_with_main_layout= 0;
  upper_layout= 0;
  widget_for_size_hint= 0;

  label= new QLabel*[column_count];
  line_edit= new QLineEdit*[column_count];
  text_edit= new QTextEdit*[column_count];
  combo_box_edit= new QComboBox*[column_count];
  hbox_layout= new QHBoxLayout*[column_count];
  widget= new QWidget*[column_count];

  for (i= 0; i < column_count; ++i)
  {
    label[i]= 0;
    line_edit[i]= 0;
    text_edit[i]= 0;
    combo_box_edit[i]= 0;
    hbox_layout[i]= 0;
    widget[i]= 0;
  }
  is_ok= 0;
  int character_height, borders_height, component_height;

  parent->component_size_calc(&character_height, &borders_height);
  component_height= character_height + borders_height;
  /*
    Subsequently, for spacing between lines, I finally realized that it's not enough
    to do setSpacing + setContentsMargins for the QVBoxLayout, I have to do them
    for each QHBoxLayout as well.
  */
  main_layout= new QVBoxLayout();
  main_layout->setSpacing(0);
  main_layout->setContentsMargins(QMargins(0, 0, 0, 0));
  main_layout->setSizeConstraint(QLayout::SetFixedSize);  /* necessary, but I don't know why */
  label_for_message= new QLabel(row_form_message);
  main_layout->addWidget(label_for_message);
  for (i= 0; i < column_count; ++i)
  {
    hbox_layout[i]= new QHBoxLayout();
    //hbox_layout[i]->setSpacing(0);
    hbox_layout[i]->setContentsMargins(QMargins(2, 2, 2, 2));
    hbox_layout[i]->setSizeConstraint(QLayout::SetFixedSize);  /* if not this then width = rest of dialog box */
    label[i]= new QLabel();
    label[i]->setStyleSheet(parent->ocelot_grid_header_style_string);
    label[i]->setMinimumHeight(component_height);
    label[i]->setText(row_form_label[i]);
    hbox_layout[i]->addWidget(label[i]);

    if (row_form_is_password[i] == 1)
    {
      line_edit[i]= new QLineEdit();
      line_edit[i]->setStyleSheet(parent->ocelot_grid_style_string);
      line_edit[i]->insert(row_form_data[i]);
      line_edit[i]->setEchoMode(QLineEdit::Password); /* maybe PasswordEchoOnEdit would be better */
      line_edit[i]->setMaximumHeight(component_height);
      line_edit[i]->setMinimumHeight(component_height);
      line_edit[i]->setMinimumWidth(40); /* TEST!!!! */
      hbox_layout[i]->addWidget(line_edit[i]);
    }
    else if (row_form_is_password[i] == 0)
    {
      text_edit[i]= new QTextEdit();

      if ((row_form_type[i] & READONLY_FLAG) != 0)
      {
        text_edit[i]->setStyleSheet(parent->ocelot_grid_header_style_string);
        text_edit[i]->setReadOnly(true);
      }
      else
      {
        text_edit[i]->setStyleSheet(parent->ocelot_grid_style_string);
        text_edit[i]->setReadOnly(false);
      }
      text_edit[i]->setText(row_form_data[i]);
      text_edit[i]->setMaximumHeight(component_height);
      text_edit[i]->setMinimumHeight(component_height);
      text_edit[i]->setTabChangesFocus(true);
      /* The following line will work, but I'm undecided whether it's desirable. */
      //if ((row_form_type[i] & NUM_FLAG) != 0) text_edit[i]->setAlignment(Qt::AlignRight);
      hbox_layout[i]->addWidget(text_edit[i]);
    }
    else /* form_is_password[i] == 2 or 3 or 4 */
    {
      combo_box_edit[i]= new QComboBox();
      combo_box_edit[i]->setMaximumHeight(component_height);
      combo_box_edit[i]->setMinimumHeight(component_height);
      if (row_form_is_password[i] == 2) /* this is not used yet */
      {
        QStringList qs= parent->fake_statement(row_form_data[i]);
        for (int j= 0; j < qs.size(); ++j) combo_box_edit[i]->addItem(qs.at(j));
      }
      if (row_form_is_password[i] == 3)
      {
        combo_box_edit[i]->addItem("yes");
        combo_box_edit[i]->addItem("no");
        if (row_form_data[i] == "yes") combo_box_edit[i]->setCurrentIndex(0);
        else combo_box_edit[i]->setCurrentIndex(1);
      }
      if (row_form_is_password[i] == 4)
      {
        combo_box_edit[i]->addItem("append");
        combo_box_edit[i]->addItem("error");
        combo_box_edit[i]->addItem("replace");
        combo_box_edit[i]->setCurrentIndex(0);
      }
      hbox_layout[i]->addWidget(combo_box_edit[i]);
    }
    widget[i]= new QWidget();
    widget[i]->setLayout(hbox_layout[i]);
    main_layout->addWidget(widget[i]);
  }
  button_for_cancel= new QPushButton(menu_strings[menu_off + MENU_CANCEL], this);
  button_for_ok= new QPushButton(menu_strings[menu_off + MENU_OK], this);
  hbox_layout_for_ok_and_cancel= new QHBoxLayout();
  hbox_layout_for_ok_and_cancel->addWidget(button_for_cancel);
  hbox_layout_for_ok_and_cancel->addWidget(button_for_ok);
  widget_for_ok_and_cancel= new QWidget();
  widget_for_ok_and_cancel->setLayout(hbox_layout_for_ok_and_cancel);
  connect(button_for_ok, SIGNAL(clicked()), this, SLOT(handle_button_for_ok()));
  connect(button_for_cancel, SIGNAL(clicked()), this, SLOT(handle_button_for_cancel()));

  widget_with_main_layout= new QWidget();
  widget_with_main_layout->setLayout(main_layout);
  widget_with_main_layout->setMaximumHeight(200);
  scroll_area= new QScrollArea();
  scroll_area->setWidget(widget_with_main_layout);
  scroll_area->setWidgetResizable(true);

  upper_layout= new QVBoxLayout;
  upper_layout->addWidget(scroll_area);

  upper_layout->addWidget(widget_for_ok_and_cancel);

  /* Last-minute changes due to failure with Ubuntu 14.04 */
  /* Removing widget_for_size_hint */
  /* Removing QSize size_hint */
  /* Instead we'll use scroll bar always on */
  /* Todo: the height is a bit less than what we want if export/html. I added "+ 20" on 2021-10-20. */
  scroll_area->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
  scroll_area->show();
  width_for_size_hint= scroll_area->width() + 25;
  height_for_size_hint= scroll_area->height() + 20;


  //{
  //  widget_for_size_hint= new QDialog(this);
  //  widget_for_size_hint->setLayout(upper_layout);
  //  widget_for_size_hint->setWindowOpacity(0);                      /* perhaps unnecessary */
  //  widget_for_size_hint->show();
  //  width_for_size_hint= widget_for_size_hint->width()
  //                     + scroll_area->verticalScrollBar()->width()
  //                     + 5;
  //  height_for_size_hint= widget_for_size_hint->height();
  //  widget_for_size_hint->close();
  //}

  this->setLayout(upper_layout);
  this->setWindowTitle(row_form_title);
}

/*
  Row_form_box will have the wrong width if everything is default:
  about 20 pixels too short, as if it didn't expect a vertical scroll bar.
    I could make Qt do a better calculation by saying
    scroll_area->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
    but someday I'll want to use Row_form_box for purposes besides connect.
  Our solution is to make a not-to-be-really-used widget,
  widget_for_size_hint, with the same layout, and use its width,
  plus the width of the vertical scroll bar, plus 5 (5 is arbitrary).
  We delete widget_for_size_hint during garbage_collect, but hope deletion is automatic.
  Todo: setWindowOpacity(0) for widget_for_size_hint?
*/
QSize Row_form_box::sizeHint() const
{
  return QSize(width_for_size_hint, height_for_size_hint);
}

/* private slots: */
void Row_form_box::handle_button_for_ok()
{
  for (int i= 0; i < column_count_copy; ++i)
  {
    if (this_row_form_box->row_form_is_password_copy[i] == 1) this_row_form_box->row_form_data_copy[i]= line_edit[i]->text();
    else if (this_row_form_box->row_form_is_password_copy[i] == 0) this_row_form_box->row_form_data_copy[i]= text_edit[i]->toPlainText();
    else
    {
      this_row_form_box->row_form_data_copy[i]= combo_box_edit[i]->currentText();
    }
  }
  is_ok= 1;
  garbage_collect();
  close();
}

void Row_form_box::handle_button_for_cancel()
{
  garbage_collect();
  close();
}

/*
  I'm doing my own garbage collection. Maybe it's a bad idea but it's the way that I know.
  Objective: anything set up with "new", without a "this", must be deleted explicitly.
  Todo: fillup_garbage_collect+display_garbage_collect for result_grid aren't as well put together as this.
*/
void Row_form_box::garbage_collect ()
{
  int i;
  if (label != 0)
  {
    for (i= 0; i < column_count_copy; ++i) if (label[i] != 0) delete label[i];
    delete [] label;
  }
  if (line_edit != 0)
  {
    for (i= 0; i < column_count_copy; ++i) if (line_edit[i] != 0) delete line_edit[i];
    delete [] line_edit;
  }
  if (text_edit != 0)
  {
    for (i= 0; i < column_count_copy; ++i) if (text_edit[i] != 0) delete text_edit[i];
    delete [] text_edit;
  }
  if (combo_box_edit != 0)
  {
    for (i= 0; i < column_count_copy; ++i) if (combo_box_edit[i] != 0) delete combo_box_edit[i];
    delete [] combo_box_edit;
  }
  if (hbox_layout != 0)
  {
    for (i= 0; i < column_count_copy; ++i) if (hbox_layout[i] != 0) delete hbox_layout[i];
    delete [] hbox_layout;
  }
  if (widget != 0)
  {
    for (i= 0; i < column_count_copy; ++i) if (widget[i] != 0) delete widget[i];
    delete [] widget;
  }
  if (button_for_cancel != 0) delete button_for_cancel;
  if (button_for_ok != 0) delete button_for_ok;
  if (hbox_layout_for_ok_and_cancel != 0) delete hbox_layout_for_ok_and_cancel;
  if (widget_for_ok_and_cancel != 0) delete widget_for_ok_and_cancel;
  if (label_for_message != 0) delete label_for_message;
  if (main_layout != 0) delete main_layout;
  if (widget_with_main_layout != 0) delete widget_with_main_layout;
  if (upper_layout != 0) delete upper_layout;
  if (scroll_area != 0) delete scroll_area;
  if (widget_for_size_hint != 0) delete widget_for_size_hint;
}

/******************** Row_form_box end ************************************/

/******************** Small_dialog start************************************/

#if (OCELOT_EXPLORER == 1)
/*
  Input = title and label and default string. Output = what user entered.
  This is only called from explorer at the moment, but maybe is useful for more in future.
*/
Small_dialog::Small_dialog(QString passed_title, QString passed_label, QString passed_value) /* constructor */
{
  QLabel label;
  QHBoxLayout layout;
  setWindowTitle(passed_title);
  label.setText(passed_label);
  line_edit.setText(passed_value);
  layout.addWidget(&label);
  layout.addWidget(&line_edit);
  setLayout(&layout);
  installEventFilter(this);
}

bool Small_dialog::eventFilter(QObject *obj, QEvent *event)
{
(void)obj;
  if (event->type() == QEvent::KeyPress)
  {
    QKeyEvent *key= static_cast<QKeyEvent *>(event);
    if ((key->key() == Qt::Key_Enter) || (key->key() == Qt::Key_Return))
    {
      accept();
      return false;
    }
  }
  return false;
}

Small_dialog::~Small_dialog()
{
  ;
}
#endif //if (OCELOT_EXPLORER == 1)

/******************** Small_dialog end   ************************************/

/******************** Context_menu start   ************************************/

/* Comments about Context_menu should be in ocelotgui.h before the words "class Context_menu: public QWidget" */

#if (OCELOT_EXPLORER == 1)
Context_menu::Context_menu(ResultGrid *m, Result_qtextedit *passed_q)
{
  result_grid= m;
  q= passed_q;
  cmi_count= 0;
  construct();
}

void Context_menu::construct()
{
  bool is_seqscan_needed=false;
  if ((dbms_version_mask & FLAG_VERSION_TARANTOOL_3_0) != 0) is_seqscan_needed= true;
  add_action("CLIPBOARD=${object_name}", "*", "S,T,P,F,E,R", "", "", "Copy to clipboard");
  add_action("CLIPBOARD=${part_name}", "*", "C,I", "", "", "Copy to clipboard");
  add_action("ACTION=${object_name}", "*", "S,T,P,F,E,R", "", "", "Send to SQL editor");
  add_action("ACTION=${part_name}", "*", "C,I", "", "", "Send to SQL editor");
  add_action("USE ${schema_name};", "M", "S", "", "", "Set as default schema");
  add_action("FILTER=$schema_name", "M", "S", "", "", "Filter to this schema");
  add_action("select schema_name,"
           " (select count(*) from information_schema.tables where table_schema='${schema_name}') as table_count,"
           " (select count(*) from information_schema.routines where routine_schema='${schema_name}') as routine_count,"
           " (select count(*) from information_schema.triggers where trigger_schema='${schema_name}') as trigger_count,"
           " schema_comment"
           " from information_schema.schemata"
           " where schema_name='${schema_name}';", "*", "S", "", "", "Schema inspector");
  add_action("Show create schema ${schema_name};", "M", "S", "", "", "Create schema");
  add_action("Alter schema ${schema_name}"
           " character set=${part_name}"
           " collate=${part_type};", "M", "S", "", "", "Alter schema");
  add_action("Drop schema ${schema_name};", "M", "S", "", "", "Drop schema");
  add_action("SET ocelot_query = SHOW ERDIAGRAM OF ${schema_name};", "M", "S", "", "", "ER Diagram");
  if (is_seqscan_needed)
    add_action("Select * from seqscan ${object_name} limit 100;", "*", "T,V", "", "", "Select rows");
  else
    add_action("Select * from ${object_name} limit 100;", "*", "T,V", "", "", "Select rows");
  add_action("SET ocelot_query = SHOW FOREIGN KEYS OF ${object_name};", "*", "T", "", "", "Foreign Keys");
#ifdef OCELOT_IMPORT_EXPORT
  add_action("EXPORT_TEXT;", "*", "T,V", "", "", "Export dialog - Text");
  add_action("EXPORT_TABLE;", "*", "T,V", "", "", "Export dialog - Table");
  add_action("EXPORT_HTML;", "*", "T,V", "", "", "Export dialog - Html");
  add_action("IMPORT ${object_name} ${dialog_file};", "*", "T,V", "", "", "Import  - Text");
#endif
  add_action("Show create table ${object_name};", "M", "T", "", "", "Create table");
  add_action("Create table ${dialog_table} like ${object_name};", "M", "T", "", "", "Create table like");
  add_action("Drop table ${object_name};", "*", "T", "", "", "Drop table");
  add_action("Truncate table ${object_name};", "*", "T", "", "", "Truncate table");
  add_action("show create view ${object_name};", "M", "V", "", "", "Show create view");
  add_action("${unqualified_part_name};", "T", "V", "", "", "Show create view");
  add_action("Drop view ${object_name};",  "*", "V", "", "", "Drop view");
  add_action("select '${part_name}' as column_name,"
          "'${part_type}' as column_type,"
          "'${occurs_text}' as occurs_in_indexes;", "*", "C", "", "", "Show column");
  add_action("Alter table ${object_name} drop column ${part_name};", "M", "C", "", "", "Drop column");
  add_action("Show index from ${object_name};", "M", "I", "", "", "Show index");
  if (is_seqscan_needed)
    add_action("Select * from seqscan \"_vindex\" where \"name\" = '${part_name}';", "T", "I", "", "", "Show index");
  else
    add_action("Select * from \"_vindex\" where \"name\" = '${part_name}';", "T", "I", "", "", "Show index");
  add_action("Select * from information_schema.statistics where index_name = '${part_name}';", "M", "I", "", "", "Select index");
  if (is_seqscan_needed)
    add_action("select * from seqscan \"_vindex\" where \"id\" = (select \"id\" from \"_vspace\" where \"name\" = '${object_name}');", "T", "I", "", "", "Select index");
  else
    add_action("select * from \"_vindex\" where \"id\" = (select \"id\" from \"_vspace\" where \"name\" = '${object_name}');", "T", "I", "", "", "Select index");
  add_action("Drop index ${unqualified_part_name} on ${object_name};", "*", "I", "", "", "Drop index");
  add_action("Show create procedure ${object_name};", "*", "P", "", "", "Create procedure");
  add_action("Drop procedure ${object_name};", "*", "P", "", "", "Drop procedure");
  add_action("Drop function ${object_name};", "*", "F", "", "", "Drop function");
  add_action("Select * from information_schema.triggers where trigger_name = ${object_name}", "M", "R", "", "", "Show trigger");
  if (is_seqscan_needed)
    add_action("Select * from seqscan \"_trigger\" where \"name\" = '${object_name}';", "T", "R", "", "", "Show trigger");
  else
    add_action("Select * from \"_trigger\" where \"name\" = '${object_name}';", "T", "R", "", "", "Show trigger");
  add_action("Drop trigger ${object_name};", "*", "R", "", "", "Drop trigger");
  add_action("RESET;", "*", "*", "", "", "Reset");
  add_action("Refresh;", "*", "*", "", "", "Refresh");
}

/* Note: avoiding "warning: extended initializer lists only available with -std=c++11 or -std=gnu++11 ..." */
int Context_menu::add_action(QString action, QString applicable_dbmss, QString applicable_types,
                              QString enabled, QString shortcut, QString text)
{
  if (cmi_count >= MAX_CMI_COUNT) return -1; /* Fail. Increase MAX_CMI_COUNT if this happens. */
  cmi[cmi_count].action= action;
  cmi[cmi_count].applicable_dbmss= applicable_dbmss;
  cmi[cmi_count].applicable_types= applicable_types;
  cmi[cmi_count].enabled= enabled;
  cmi[cmi_count].shortcut= shortcut;
  cmi[cmi_count].text= text;
  cmi[cmi_count].is_visible= false;
  ++cmi_count;
  return 0;
}

/* This existed because cells for long names had \r or \n but apparently that doesn't happen any more. */
//QString Context_menu::strip_crlf(QByteArray result_row_value)
//{
//  QString s= QString::fromUtf8(result_row_value);
//  char tmp10[256];
//  strcpy(tmp10, s.toUtf8());
//  s.replace("\n", "");
//  s.replace("\r", "");
//  char tmp11[256];
//  strcpy(tmp11, s.toUtf8());
//  if (strcmp(tmp10, tmp11) != 0) printf("**** difference for %s.\n", tmp10);
//  return s;
//}

QString Context_menu::replacer(QString s)
{
  cm_object_type= QString::fromUtf8(result_grid->copy_of_parent->oei[q->qtextedit_result_row_number].object_type);
  QString schema_name= QString::fromUtf8(result_grid->copy_of_parent->oei[q->qtextedit_result_row_number].schema_name);
  QString object_name= QString::fromUtf8(result_grid->copy_of_parent->oei[q->qtextedit_result_row_number].object_name);
  QString part_name= QString::fromUtf8(result_grid->copy_of_parent->oei[q->qtextedit_result_row_number].part_name);
  QString part_type= QString::fromUtf8(result_grid->copy_of_parent->oei[q->qtextedit_result_row_number].part_type);

  //char flags= result_grid->copy_of_parent->oei[q->qtextedit_result_row_number].flags;
  /* Todo: Let delimiter be blank if it's not necessary. */
  QString delimiter= "\"";
  if (connections_dbms[0] == DBMS_TARANTOOL) ;
  else if (sql_mode_ansi_quotes == false) delimiter= "`";
  QString delimited_schema_name= delimiter + schema_name + delimiter;
  /* Todo: don't add schema qualifier if it's not necessary */
  QString schema_qualifier= "";
  if (connections_dbms[0] == DBMS_TARANTOOL) ;
  else schema_qualifier= delimited_schema_name + ".";
  if (cm_object_type == "S") cm_delimited_object_name= delimited_schema_name;
  else cm_delimited_object_name= schema_qualifier+ delimiter + object_name + delimiter;
  cm_cell= q->qtextedit_cell_content;
  QString table_qualifier= delimiter + object_name + delimiter + ".";
  QString delimited_part_name= table_qualifier+ delimiter + part_name + delimiter;
  QString unqualified_part_name= delimiter + part_name + delimiter;
  if (s.contains("${dialog_table}", Qt::CaseInsensitive) == true)
  {
    Small_dialog *sm= new Small_dialog("Enter new table name and type Enter", "New name", "");
    sm->exec();
    QString text= "Create table " + sm->line_edit.text().toUtf8() + " like " + cm_delimited_object_name + ";";
    QString dialog_result= sm->line_edit.text().toUtf8();
    delete sm;
    s.replace("${dialog_table}", dialog_result, Qt::CaseInsensitive);
  }
  if (s.contains("${dialog_file}", Qt::CaseInsensitive) == true)
  {
    Small_dialog *sm= new Small_dialog("Enter file name and type Enter", "New name", "");
    sm->exec();
    QString text= "Create table " + sm->line_edit.text().toUtf8() + " like " + cm_delimited_object_name + ";";
    QString dialog_result= sm->line_edit.text().toUtf8();
    delete sm;
    s.replace("${dialog_file}", dialog_result, Qt::CaseInsensitive);
  }
  if (s.contains("${occurs_text}", Qt::CaseInsensitive) == true)
  {
    int index_count= 0;
    for (unsigned int i= 0; i < result_grid->copy_of_parent->oei_count; ++i)
    {
      if (result_grid->copy_of_parent->oei[i].object_type == "I")
      {
        if ((result_grid->copy_of_parent->oei[i].object_name == object_name)
         && (result_grid->copy_of_parent->oei[i].part_type == part_name))
        {
          ++index_count;
        }
      }
    }
    QString occurs_text= QString::number(index_count) + " times";
    if (index_count == 1) occurs_text= "1 time";
    s.replace("${occurs_text}", occurs_text, Qt::CaseInsensitive);
  }
  s.replace("'${schema_name}'", "'" + schema_name + "'", Qt::CaseInsensitive);
  s.replace("${schema_name}", delimited_schema_name, Qt::CaseInsensitive);
  s.replace("'${object_name}'", "'" + object_name + "'", Qt::CaseInsensitive);
  s.replace("${object_name}", cm_delimited_object_name, Qt::CaseInsensitive);
  s.replace("'${part_name}'", "'" + part_name + "'", Qt::CaseInsensitive);
  s.replace("${unqualified_part_name}", unqualified_part_name, Qt::CaseInsensitive);
  s.replace("${part_name}", delimited_part_name, Qt::CaseInsensitive);
  s.replace("${part_type}", part_type, Qt::CaseInsensitive);
  s.replace("${cell}", cm_cell, Qt::CaseInsensitive);
  s.replace("${clipboard}", QApplication::clipboard()->text());
  s.replace("${action}", result_grid->copy_of_parent->statement_edit_widget->toPlainText());
  return s;
}

void Context_menu::menu_context_t_2_explorer(const QPoint & pos)
{
  (void)pos;
  if (q->qtextedit_at_end == true) return;
  result_grid->copy_of_parent->log("menu_context_t_2_explorer start", 90);
  if ((q->qtextedit_is_before_column == true) || (q->qtextedit_is_before_row == true)) return;

  q->result_grid->copy_of_parent->c_widget->initialize(EXPLORER_WIDGET);
  q->result_grid->copy_of_parent->c_widget->clear_wrapper();

  QString dbms= "M"; /* MariaDB/MySQL assumed */
  if (connections_dbms[0] == DBMS_TARANTOOL) dbms= "T";
  int cmi_count_visible= 0;
  int max_visible_text_length= 0;
  for (int i_of_cmi= 0; i_of_cmi < cmi_count; ++i_of_cmi)
  {
    replacer(""); /* so we get cm_object_type and cm_delimited_object_name */
    bool is_object_type_match= false;
    if ((cmi[i_of_cmi].applicable_types.contains(cm_object_type) == true)
     || (cmi[i_of_cmi].applicable_types.contains("*") == true))
      is_object_type_match= true;
    bool is_dbms_match= false;
    if ((cmi[i_of_cmi].applicable_dbmss.contains("*") == true)
     || (cmi[i_of_cmi].applicable_dbmss.contains(dbms) == true))
      is_dbms_match= true;
    if ((is_object_type_match == true) && (is_dbms_match == true))
    {
      cmi[i_of_cmi].is_visible= true;
      QString visible_text= replacer(cmi[i_of_cmi].text);
      if (visible_text.length() > max_visible_text_length) max_visible_text_length= visible_text.length();
      ++cmi_count_visible;
    }
    else cmi[i_of_cmi].is_visible= false;
  }

  /* Loop again so we can right-align shortcut, assuming fixed font */
  for (int i_of_cmi= 0; i_of_cmi < cmi_count; ++i_of_cmi)
  {
    QString spacer= " ";
    if (cmi[i_of_cmi].is_visible == true)
    {
      QString visible_text= replacer(cmi[i_of_cmi].text);
      visible_text= visible_text + spacer.repeated(max_visible_text_length - visible_text.length());
      visible_text= visible_text + " " + cmi[i_of_cmi].shortcut;
      q->result_grid->copy_of_parent->c_widget->append_wrapper(visible_text, "", TOKEN_TYPE_IDENTIFIER, TOKEN_FLAG_IS_NEW, "K");
    }
  }

  q->result_grid->copy_of_parent->c_widget->size_and_position_change();
  q->result_grid->copy_of_parent->c_widget->show();
  q->result_grid->copy_of_parent->c_widget->setFocus();
  result_grid->copy_of_parent->log("menu_context_t_2_explorer end", 90);
}

/* if due to mousepressevent: current_row >= 0, i_of_cmi == -1 */
/* if due to shortcutter: current_row == -1, i_of_cmi >= 0 */
void Context_menu::action(int current_row, int i_of_cmi)
{
  int i_of_cmi_visible= 0;
  if (current_row >= 0)
  {
    bool is_match= false;
    for (i_of_cmi= 0; i_of_cmi < cmi_count; ++i_of_cmi)
    {
      if (cmi[i_of_cmi].is_visible == false) continue;
      if (i_of_cmi_visible == current_row)
      {
        is_match= true;
        break;
      }
      if (i_of_cmi_visible != current_row)
      ++i_of_cmi_visible;
    }
    if (is_match == false)
    {
      /* ?? Unknown action. This must be an error, eh? */
      printf("Unknown action\n");
      return;
    }
  }
  if (i_of_cmi < 0) return; /* I think this is impossible beause if we pass i_of_cmi == -1 then we'll loop till current_row */
  if (cmi[i_of_cmi].enabled == "no")
  {
    return;
  }
  {
    QString s= cmi[i_of_cmi].action.trimmed();
    if (s.startsWith("CLIPBOARD=", Qt::CaseInsensitive) == true) /* probably "CLIPBOARD=${cell}" */
    {
      s= replacer(s);
      s= s.right(s.size()-10);
      QApplication::clipboard()->setText(s);
    }
    else if (s.startsWith("ACTION=", Qt::CaseInsensitive) == true) /* probably "ACTION=${cell}" */
    {
      s= replacer(s);
      s= s.right(s.size()-7);
      result_grid->copy_of_parent->statement_edit_widget->setPlainText(s);
    }
#ifdef OCELOT_IMPORT_EXPORT
    else if ((s == "EXPORT_TEXT;")
     || (s == "EXPORT_TABLE;")
     || (s == "EXPORT_HTML;"))
    {
      int keyword= 0;
      if (s == "EXPORT_TEXT;") keyword= TOKEN_KEYWORD_TEXT;
      if (s == "EXPORT_TABLE;") keyword= TOKEN_KEYWORD_TABLE;
      if (s == "EXPORT_HTML;") keyword= TOKEN_KEYWORD_HTML;
      struct export_settings copy_of_main_exports;
      copy_of_main_exports= main_exports;
      int function_result= result_grid->copy_of_parent->action_file_export_function(TOKEN_KEYWORD_EXPORT, keyword);
      if (function_result == 1) /* Todo: check that function_result != 1 if dialog-cancel or SET failure */
      {
        QString file_name= main_exports.file_name;
        QString text= "SELECT /* FOR EXPORT TO " + file_name + "*/ * FROM " + cm_delimited_object_name + ";";
        result_grid->copy_of_parent->statement_edit_widget->setPlainText(text);
        result_grid->copy_of_parent->action_execute(1);
        result_grid->copy_of_parent->history_file_stop("TEE");
      }
      main_exports= copy_of_main_exports;
    }
    else if (s.startsWith("IMPORT") == true)
    {
      s= replacer(s);
      int index_of_first_space= s.indexOf(" ");
      int index_of_second_space= s.lastIndexOf(" ");
      QString table_name= s.mid(index_of_first_space + 1, index_of_second_space - (index_of_first_space + 1));
      QString file_name= s.mid(index_of_second_space + 1, (s.size() - 1) - (index_of_second_space + 1));
      result_grid->copy_of_parent->read_file(TOKEN_KEYWORD_IMPORT, file_name, table_name);
    }
#endif
    else if (s == "RESET;")
    {
      result_grid->explorer_reset();
    }
    else if (s.startsWith("FILTER=", Qt::CaseInsensitive) == true) /* probably "FILTER=${schema_name}" */
      result_grid->explorer_filter(q->qtextedit_result_row_number);
    else
    {
      result_grid->copy_of_parent->statement_edit_widget->setPlainText(replacer(s));
      assert(result_grid->copy_of_parent->main_token_max_count >= (unsigned int) s.size());
      result_grid->copy_of_parent->action_execute(1);
    }
  }
}

/* With menus I'd be able to handle the switching with connect() and lambdas, thus:
   (in class Context_Menu private slots) void cmi_switcher(int cmi_index);
   (in Context_menu::add_qaction) int i= cmi_count; connect(cmi[cmi_count].action_pointer, &QAction::triggered,[this, i] { cmi_switcher(i); });
   (here) uncomment
   Currently I'm happy with looking at the exec() result but this method might be better for main menu bar
*/
//void Context_menu::cmi_switcher(int cmi_index)
//{
//  printf("**** cmi_switcher %d\n", cmi_index);
//}

void Context_menu::keyPressEvent(QKeyEvent *event)
{
  (void)event;
}

bool Context_menu::shortcutter(QKeySequence qk)
{
  for (int i_of_cmi= 0; i_of_cmi < cmi_count; ++i_of_cmi)
  {
    QString i_of_cmi_shortcut= cmi[i_of_cmi].shortcut;
    if (i_of_cmi_shortcut != "")
    {
      QKeySequence qk_of_shortcut= QKeySequence(i_of_cmi_shortcut);
      if (qk_of_shortcut == qk)
      {
        action(-1, i_of_cmi);
        return true;
      }
    }
  }
  return false;
}

/* todo: this isn't being called automatically, maybe because parent is QWidget (?) */
Context_menu::~Context_menu()
{
  ;
}
#endif //if (OCELOT_EXPLORER == 1)

/******************** Context_menu end   ************************************/


#ifdef OLD_STUFF
/*
  TextEditFrame
  This is one of the components of result_grid
*/
TextEditFrame::TextEditFrame(QWidget *parent, ResultGrid *result_grid_widget, unsigned int index) :
    QFrame(parent)
{
  setMouseTracking(true);
  left_mouse_button_was_pressed= 0;
  ancestor_result_grid_widget= result_grid_widget;
  text_edit_frames_index= index;
  is_style_sheet_set_flag= false;
  hide();
}

#endif



/*
  CONNECT
*/

/*
   MySQL options
   Any mysql/mariadb client should have a consistent way to see what
   options the user has put in a configuration file such as my.cnf, or added
   on the command line with phrases such as --port=x.
   MySQL's own clients can do it with an include of getopt.h and calls to my_long_options etc.
   but that would introduce some unwanted dependencies, so we do all the option retrievals directly.
   Todo: meld that with whatever a user might say in a CONNECT command line
         or maybe even a dialog box.
   Assume lmysql->ldbms_mysql_init() has not already happened.
   Qt gets to see argc+argv first, and Qt will process options that it recognizes
   such as -style, -session, -graphicssystem. See
   http://qt-project.org/doc/qt-4.8/qapplication.html#details.
   But when Qt is done, it should remove what it parsed.
   Todo: actually you should operate on a copy of argc + argv, rather than change the originals. QT docs say so.
         but that would contradict another todo, which is to blank the password if it's in an argv
   Most options are ignored but the ones which might be essential for connecting are not ignored.
   Example: if ~/.my.cnf has "port=3306" in [clients] group, and start happens with --host=127.0.0.1,
            then port=3306 and current_host=127.0.0.1 and that will get passed to the connect routine.
   Read: http://dev.mysql.com/doc/refman/5.6/en/connecting.html
         See also http://dev.mysql.com/doc/refman/5.6/en/mysql-command-options.html
 */

/*
  Connect -- get options

  Environment variables, then option files, then command-line arguments

  Except that you have to read the command-line arguments to know whether
  you should read the option files, see http://dev.mysql.com/doc/refman/5.7/en/option-file-options.html

  For environment variables:
  Follow http://dev.mysql.com/doc/refman/5.7/en/environment-variables.html
  * Watch: LD_RUN_PATH MYSQL_GROUP_SUFFIX MYSQL_HOST MYSQL_PS1 MYSQL_PWD MYSQL_TCP_PORT TZ USER
           MYSQL_UNIX_PORT

  For option files:
  Follow MySQL manual http://dev.mysql.com/doc/refman/5.7/en/option-files.html
  Don't follow MariaDB documentation https://mariadb.com/kb/en/mariadb/mariadb-documentation/getting-started/getting-installing-and-upgrading-mariadb/configuring-mariadb-with-mycnf/
  Todo: Find out whether MariaDB documentation is merely wrong, or represents a real incompatibility with MySQL.
  * Read these files:
  /etc/my.cnf
  /etc/mysql/my.cnf
  SYSCONFDIR/my.cnf       ?? i.e. [installation-directory]/etc/my.cnf but this should be changeable
  $MYSQL_HOME/my.cnf
  file specified with --defaults-extra-file
  $HOME/.my.cnf             MySQL manual says ~/.my.cnf which isn't necessarily the same thing, but I don't believe that
  $HOME/.mylogin.cnf        MySQL manual says ~/.mylogin.cnf which isn't necessarily the same thing, but I don't believe that
  ... There is no use of DATADIR, which is deprecated, and (I think) would only relate to server anyway.
  On Unix, "ignore configuration files that are world-writable" -- we use stat.h for this.
  * How to read ...
  for (;;)
    read line
    tokenize for the line
    If blank, or starts with '#', or starts with ';', ignore
    ignore everything following '#' (not necessarily at start of line)
    start only when you see [client] or [mysql] or [ocelot]
    stop when you see [something-else]
    expand escape sequences
    if you see opt_name = value:
      compare to important-opt-name but allow "unambiguous prefix" see http://dev.mysql.com/doc/refman/5.7/en/program-options.html
      if opt_name is important
        get value, strip '' or "", strip lead/trail
        assign: variable-name-corresponding-to-opt-name = value
    if you see !include /home/mydir/myopt.cnf or the like:
        open the file; subsequent read lines will be from there, but you have to return
        [ if you're already in an include, that's probably an error ]
    if you see !includedir /home/mydir or the like:
        each file in the directory might be an options file, ending in ".cnf"
  * Last specification takes precedence, so we're starting with
  (say) a variable named OPT which is blank, setting it to
  something when we see OPT = xxx, and setting it again when
  we see OPT = xxx again. Only PASSWORD is tricky, because it
  can be followed by blank to indicate password is necessary.

  For command-line:
  Follow http://dev.mysql.com/doc/refman/5.7/en/command-line-options.html
  * This is somewhat different from the tokenizing that's done for the
    command line, but it's still a matter of tokenizing
  * The trick is: you have to tokenize twice, before and after command-line stuff
  * Get rid of any arguments that you actually handle, Qt might want the rest
  * todo: recognize --print-defaults and --login-pathconf

  In the end, you have a bunch of variables with values.
  Todo: For each variable with a value, append to "CONNECT" client-statement,
  which eventually will be what you actually use (though password won't be repeated?).
  See connect_make_statement().

  Todo: mysql client handles bad format in my.cnf file thus:
        "error: Found option without preceding group in config file: /home/pgulutzan/.my.cnf at line: 1
         Fatal error in defaults handling. Program aborted"
        Maybe we should do the same?

  The above comments apply to Unix, Windows is a bit different.

  Todo: whenever you have a token0/token1/token2:
        find token1 in case it's one of the options we track
        set the value for that option
  Todo: if argv[i] is a password, you should wipe it out. Compare what mysql client does:
        "while (*argument) *argument++= 'x';"

  Todo: The environment variable LD_LIBRARY_PATH is also important, because it determines
        where libmysqlclient.so and the Qt libraries will be loaded from. Document that,
        and show it somewhere.
        The only complication I can think of is that, if I
        decide someday to support another DBMS, the MySQL
        stuff would still come in or have to be disabled.
*/

//#include <dirent.h>

void connect_set_variable(QString token0, QString token1, QString token2);
void connect_read_command_line(int argc, char *argv[]);
#if (OCELOT_MYSQL_INCLUDE == 1)
void connect_read_my_cnf(const char *file_name, int is_mylogin_cnf);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

//#include <pwd.h>
//#include <unistd.h>

/*
  Called from MainWindow, once, very early. So options get default values then may get user-set values.
  The name suggests that the mysql client uses some options this way, but in fact we call for non-mysql-client.
  Options are initialized in this order, with each step possibly overriding what was in the last step:
  (1) any static variables defined with "= constant" outside MainWindow
  (2) assignments in MainWindow() before calling this routine
  (3) assignments at the start of this routine
  (4) handling of anything set due to cmake . -DDEFAULT_OPTION=<string>, see CMakeLists.txt
  (5) later, in connect_mysql_options_2(), --command-line options and configuration-file options
  (6) getenv() comes up somewhere, and see the "Todo:" comment below.
*/
void MainWindow::connect_mysql_options_2(int argc, char *argv[])
{
  char *mysql_pwd;
  const char *home;
  char *ld_run_path;
  /*
    Todo: check: are there any default values to be set before looking at environment variables?
          I don't see documentation to that effect, so I'm just setting them to "" or 0.
          Except that port initially = MYSQL_PORT (probably 3306), and ocelot_delimiter_str initially = ";"
          and http://dev.mysql.com/doc/refman/5.6/en/connecting.html mentions a few others:
          host = 'localhost' (which means protocol=SOCKET if mysql client, but we ignore that)
          user = Unix login name on Linux, although on Windows it would be 'ODBC'
          and there seem to be some getenv() calls in other clients that I didn't take into account.
  */
  ocelot_ca.no_defaults= 0;
  ocelot_defaults_file= "";
  ocelot_defaults_extra_file= "";

  ocelot_host= "localhost";
  ocelot_database= "";
  ocelot_user= "";
  ocelot_password_was_specified= 0;
  /* ocelot_ca.port= MYSQL_PORT; */ /* already initialized */
  ocelot_unix_socket= "";
  ocelot_default_auth= "";
  ocelot_defaults_group_suffix= "";
  /* ocelot_ca.enable_cleartext_plugin= 0; */ /* already initialized */
  ocelot_history_hist_file_name= "/.mysql_history";
  ocelot_histignore= "";
  ocelot_init_command= "";
  ocelot_opt_bind= "";
  /* ocelot_ca.opt_can_handle_expired_passwords= 0; */ /* already initialized */
  /* ocelot_ca.opt_compress= 0; */ /* already initialized */
  ocelot_opt_connect_attr_delete= "";
  /* ocelot_ca.opt_connect_attr_reset= 0; */ /* already initialized */
  /* ocelot_ca.opt_connect_timeout= 0; */ /* ocelot_ca.opt_connect_timeout is initialized to 0 */
  /* ocelot_ca.opt_local_infile= 0; */ /* ocelot_ca.opt_local_infile is initialized to 0 */
  /* ocelot_ca.opt_named_pipe= 0; */ /* already initialized */
  /* ocelot_ca.opt_read_timeout= 0; */ /* already initialized */
  /* ocelot_ca.opt_reconnect= 0; */ /* ocelot_ca.opt_reconnect is initialized to 0 */
  ocelot_opt_ssl= "";
  ocelot_opt_ssl_ca= "";
  ocelot_opt_ssl_capath= "";
  ocelot_opt_ssl_cert= "";
  ocelot_opt_ssl_cipher= "";
  ocelot_opt_ssl_crl= "";
  ocelot_opt_ssl_crlpath= "";
  ocelot_opt_ssl_key= "";
  ocelot_opt_ssl_mode= "";
  /* ocelot_ca.opt_ssl_verify_server_cert= 0; */ /* already initialized */
  /* ocelot_ca.opt_use_result= 0; */ /* already initialized */
  /* ocelot_ca.opt_write_timeout= 0; */ /* already initialized */
  ocelot_plugin_dir= "";
  ocelot_read_default_file= "";
  ocelot_read_default_group= "";
  /* ocelot_ca.report_data_truncation= 0; */ /* already initialized */
  /* ocelot_ca.secure_auth= 1; secure_auth is 1 by default anyway */ /* =1 if mysql 5.6.7 */
  ocelot_server_public_key= "";
  ocelot_set_charset_dir= "";
  ocelot_set_charset_name= "utf8"; /* ocelot_default_character_set= "";  */
  ocelot_shared_memory_base_name= "";

  ocelot_protocol= ""; ocelot_ca.protocol_as_int= get_ocelot_protocol_as_int(ocelot_protocol);

  ocelot_delimiter_str= ";";
  /* ocelot_ca.history_includes_warnings= 0; is default anyway */
  /* ocelot_ca.sigint_ignore= 0; is default anyway */
  /* ocelot_ca.safe_updates= 0; */ /* ocelot_ca.safe_updates is initialized to 0 */
  /* ocelot_ca.select_limit= 0; */ /* ocelot_ca.select_limit is initialized to 0 */
  /* ocelot_ca.max_join_size= 0; */ /* ocelot_ca.max_join_size is initialized to 0 */
  /* ocelot_ca.silent= 0; */ /* ocelot_ca.silent is initialized to 0 */
  /* ocelot_ca.no_beep= 0; */ /* ocelot_ca.no_beep is initialized to 0 */
  /* ocelot_ca.wait= 0; *//* ocelot_ca.wait is initialized to 0 */

  ocelot_bind_address= "";
  ocelot_debug= "";
  ocelot_execute= "";
  ocelot_ld_run_path= "";
  ocelot_login_path= "";
  ocelot_dbms= "";
  ocelot_pager= "";
  //ocelot_prompt= "mysql>";                  /* Todo: change to "\N [\d]>"? */

  options_files_read= "";
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
  {
    struct passwd *pw;
    uid_t u;
    u= geteuid();
    pw= getpwuid(u);
    if (pw != NULL) ocelot_user= pw->pw_name;
  }
#endif
#ifdef DEFAULT_OPTION
  char *pseudo_argv[2];
  pseudo_argv[1]= (char*) DEFAULT_OPTION;
  connect_read_command_line(2, pseudo_argv);
#endif  // DEFAULT_OPTION
  connect_read_command_line(argc, argv);               /* We're doing this twice, the first time won't count. */
  /*
    ocelotgui.pro variables
    Looking at https://dev.mysql.com/doc/refman/5.6/en/source-configuration-options.html
    I gather that some items can be defined at cmake time. The possibly interesting ones
    that we could do in ocelotgui.pro are, for example:
    DEFINES += MYSQL_TCP_PORT=3306
    DEFINES += MYSQL_UNIX_ADDR="/tmp/mysql.sock"
    DEFINES += SYSCONFDIR="..."
    which in cmake terms is -DMYSQL_TCP_PORT=3306 -DMYSQL_UNIX_ADDR="/tmp/mysql.sock" etc.
    MySQL_UNIX_ADDR must go through stringification.
    Following shows how we'd do stringification, but then we don't do anything with it.
    Warning: The stringification might be adding extra "s.
    Warning: MYSQL_UNIX_ADDR has a definition in a mysql.h-related include file.
    Todo: pay attention to these settings.
  */
//#define xstr(a) str(a)
//#define str(a) #a
//#ifdef MYSQL_UNIX_ADDR
//  printf("Ignoring MYSQL_UNIX_ADDR=%s.\n", xstr(MYSQL_UNIX_ADDR));
//#endif

  /* Environment variables */

  if (getenv("HOME") != 0)
  {
    home= getenv("HOME");
  }
  else home= "";

  if (getenv("LD_RUN_PATH") != 0)
  {
    ld_run_path= getenv("LD_RUN_PATH");                  /* maybe used to find libmysqlclient */
    ocelot_ld_run_path= ld_run_path;
  }
  if (getenv("MYSQL_GROUP_SUFFIX") != 0)
  {
    char *tmp_ocelot_defaults_group_suffix;
    tmp_ocelot_defaults_group_suffix= getenv("MYSQL_GROUP_SUFFIX");
    ocelot_defaults_group_suffix= tmp_ocelot_defaults_group_suffix;
  }

  //getenv("MYSQL_HOME");                                /* skip, this is only for server */

  if (getenv("MYSQL_HISTFILE") != 0)
  {
    char *tmp_ocelot_histfile;
    tmp_ocelot_histfile= getenv("MYSQL_HISTFILE");
    ocelot_history_hist_file_name= tmp_ocelot_histfile;
  }
  else ocelot_history_hist_file_name= home + ocelot_history_hist_file_name;

  if (getenv("MYSQL_HISTIGNORE") != 0)
  {
    char *tmp_ocelot_histignore;
    tmp_ocelot_histignore= getenv("MYSQL_HISTIGNORE");
    ocelot_histignore= tmp_ocelot_histignore;
  }

  if (getenv("MYSQL_HOST") != 0)
  {
    char *tmp_ocelot_host;
    tmp_ocelot_host= getenv("MYSQL_HOST");
    ocelot_host= tmp_ocelot_host;
  }

  if (getenv("MYSQL_PS1") != 0)
  {
    char *tmp_ocelot_prompt;
    tmp_ocelot_prompt= getenv("MYSQL_PS1");
    ocelot_prompt= tmp_ocelot_prompt;
    ocelot_ca.prompt_is_default= false;
  }

  if (getenv("MYSQL_PWD") != 0)
  {
    mysql_pwd= getenv("MYSQL_PWD");
    ocelot_password= mysql_pwd;
    ocelot_password_was_specified= 1;
  }
  if (getenv("MYSQL_TCP_PORT") != 0) ocelot_ca.port= atoi(getenv("MYSQL_TCP_PORT"));         /* "" */
  //user= getenv("USER"); no, this is for Windows
  //tz= getenv("TZ");

  if (getenv("MYSQL_UNIX_PORT") != 0)
  {
    char *tmp_ocelot_unix_socket;
    tmp_ocelot_unix_socket= getenv("MYSQL_UNIX_PORT");
    ocelot_unix_socket= tmp_ocelot_unix_socket;
  }
  /*
    Options files i.e. Configuration files i.e. my_cnf files
    Don't read option files if ocelot_ca.no_defaults==1 (which is true if --no-defaults was specified on command line).
    For Tarantool, we look in the same places as for MariaDB.
    MariaDB's mysql client wouldn't read .mylogin.cnf, but we do.
    Todo: check: does MariaDB read mylogin.cnf even if ocelot_ca.no_defaults==1?
    Todo: put mycnf_file list somewhere where ocelotgui --help can see
  */
  if (QString::compare(ocelot_defaults_file, " ") > 0)
  {
    char tmp_my_cnf[1024];                         /* file name = $HOME/.my.cnf or $HOME/.mylogin.cnf or defaults_extra_file */
    strcpy(tmp_my_cnf, ocelot_defaults_file.toUtf8());
    connect_read_my_cnf(tmp_my_cnf, 0);
  }
  else
  {
    if (ocelot_ca.no_defaults == 0)
    {
      char my_cnf_file[10][1024];
      int i= 0;
      /* Internet mentions other my.cnf locations but I'm guessing they're for examples. */
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
      strcpy(my_cnf_file[i++], "/etc/my.cnf");
      strcpy(my_cnf_file[i++], "/etc/mysql/my.cnf");
      /* todo: think: is argv[0] what you want for SYSCONFDIR? not exact, but it's where the program is now. no, it might be a copy. */
      // connect_read_my_cnf("SYSCONFDIR/etc/my.cnf", 0) /* ?? i.e. [installation-directory]/etc/my.cnf but this should be changeable */
      /* skip $MYSQL_HOME/my.cnf, only server stuff should be in it */
      // connect_read_my_cnf("file specified with --defaults-extra-file", 0);
      if (QString::compare(ocelot_defaults_extra_file, " ") > 0)
      {
        strcpy(my_cnf_file[i++], ocelot_defaults_extra_file.toUtf8());
      }
      strcpy(my_cnf_file[i], home);
      strcat(my_cnf_file[i++], "/.my.cnf");
      if (getenv("MYSQL_TEST_LOGIN_FILE") != NULL)
      {
        strcpy(my_cnf_file[i++], getenv("MYSQL_TEST_LOGIN_FILE"));
      }
      else
      {
        strcpy(my_cnf_file[i], home);          /* $HOME/.mylogin.cnf */
        strcat(my_cnf_file[i++], "/.mylogin.cnf");
      }
#else
      /* Todo: %PROGRAMDATA%... (MySQL) */
      if ((hparse_dbms_mask & (FLAG_VERSION_MARIADB_ALL|FLAG_VERSION_TARANTOOL)) != 0)
      {
        if (getenv("SYSTEM") != 0)
        {
          strcpy(my_cnf_file[i], getenv("SYSTEM"));
          strcat(my_cnf_file[i++], "\\my.ini");
          strcpy(my_cnf_file[i], getenv("SYSTEM"));
          strcat(my_cnf_file[i++], "\\my.cnf");
        }
      }
      if (getenv("WINDIR") != 0)
      {
        strcpy(my_cnf_file[i], getenv("WINDIR")); /* e.g. c:\windows */
        strcat(my_cnf_file[i++], "\\my.ini");
        strcpy(my_cnf_file[i], getenv("WINDIR"));
        strcat(my_cnf_file[i++], "\\my.cnf");
      }
      strcpy(my_cnf_file[i++], "c:\\my.ini");
      strcpy(my_cnf_file[i++], "c:\\my.cnf");
      if ((hparse_dbms_mask & FLAG_VERSION_MYSQL_ALL) != 0)
      {
        /* Todo: This should be BASEDIR | INSTALLDIR. Close enough? */
        strcpy(my_cnf_file[i], QCoreApplication::applicationDirPath().toUtf8());
        strcat(my_cnf_file[i++], "\\my.ini");
        strcpy(my_cnf_file[i], QCoreApplication::applicationDirPath().toUtf8());
        strcat(my_cnf_file[i++], "\\my.cnf");
      }
      if ((hparse_dbms_mask & (FLAG_VERSION_MARIADB_ALL|FLAG_VERSION_TARANTOOL)) != 0)
      {
        if (getenv("MYSQL_HOME") != 0)
        {
          strcpy(my_cnf_file[i], getenv("MYSQL_HOME"));
          strcat(my_cnf_file[i++], "\\my.ini");
          strcpy(my_cnf_file[i], getenv("MYSQL_HOME"));
          strcat(my_cnf_file[i++], "\\my.cnf");
        }
      }
      if (QString::compare(ocelot_defaults_extra_file, " ") > 0)
      {
        strcpy(my_cnf_file[i++], ocelot_defaults_extra_file.toUtf8());
      }
      if (getenv("APPDATA") != 0)
      {
        strcpy(my_cnf_file[i], getenv("APPDATA"));
        strcat(my_cnf_file[i], "\\MYSQL");
        strcat(my_cnf_file[i++], "\\.mylogin.cnf");
      }
#endif
      for (int j= 0; j < i; ++j)
      {
        if (strstr(my_cnf_file[j], ".mylogin.cnf") != 0)
          connect_read_my_cnf(my_cnf_file[j], 1);
        else connect_read_my_cnf(my_cnf_file[j], 0);
      }
    }
  }
  connect_read_command_line(argc, argv);
  if (ocelot_ca.prompt_is_default == true)
  {
    ocelot_prompt= ocelot_dbms;
    ocelot_prompt.append(">");
  }

  //connect_make_statement();
}


/*
  Command line arguments i.e. argc + argv (or pseudo_argv if cmake .-DDEFAULT_OPTION=string)
  Some tokenizing has already been done.
  For example progname --a=b --c=d gives us argv[1]="--a=b" and argv[2]="--c=d".
  For example progname -a b -c d gives us argv[1]="-a" argv[2]="b" argv[3]="-c" argv[4]="d".
  If something is enclosed in single or double quotes, then it has already been stripped of quotes and lead/trail spaces.
  We do command line arguments TWICE! first time is just to find out what my.cnf files should be read, etc.
  second time is to override whatever happened during getenv and option-file processing
  todo: parse so -p x and --port=x etc. are known
  todo: check: is it okay still to abbreviate e.g. us rather than user?
  todo: strip the arguments so Qt doesn't see them, or maybe don't
  todo: you seem to be forgetting that Qt can also expect command-line options
  todo: all the .ToLower() stuff is probably unnecessary, it can probably be upper
*/
/*
  BUG: If user enters "--ocelot_xml = wombat" rather than "--ocelot_xml=wombat", we will interpret
       this as three entries, and the third entry is not preceded by - so we will interpret wombat as
       a database name. Of course the spaces shouldn't be there, but we should parse better.
*/
void MainWindow::connect_read_command_line(int argc, char *argv[])
{
  QString token0, token1, token2;
  QString s_argv;
  int i;

  for (i= 1; i < argc; ++i)
  {
    s_argv= argv[i];
    /* If there's no '-' then (I guess) this is the database name */
    if (s_argv.mid(0, 1) != "-")
    {
      token0= "database"; token1= "="; token2= s_argv;
    }
    /* If there is one '-' then token0=argv[i], maybe token1='=', maybe token2=argv[i+1 */
    /* Some items don't need spaces before argument, e.g. -D db_name is same as -Ddb_name */
    else if ((strlen(argv[i]) > 1) && (s_argv.mid(1, 1) != "-"))
    {
      bool is_token2_needed= false;
      token0= argv[i]; token1= ""; token2= "";
      if (token0.size() > 2)
      {
        token1= "=";
        token2= token0.right(token0.size() - 2);
        token0= token0.left(2);
      }
      if (token0 == "-?") token0= QString(strvalues[TOKEN_KEYWORD_HELP].chars).toLower();
      if (token0 == "-#") token0= QString(strvalues[TOKEN_KEYWORD_DEBUG].chars).toLower();
      if (token0 == "-A") token0= QString(strvalues[TOKEN_KEYWORD_NO_AUTO_REHASH].chars).toLower();
      if (token0 == "-B") token0= QString(strvalues[TOKEN_KEYWORD_BATCH].chars).toLower();
      if (token0 == "-b") token0= QString(strvalues[TOKEN_KEYWORD_NO_BEEP].chars).toLower();
      if (token0 == "-C") token0= QString(strvalues[TOKEN_KEYWORD_COMPRESS].chars).toLower();
      if (token0 == "-c") token0= QString(strvalues[TOKEN_KEYWORD_COMMENTS].chars).toLower();
      if (token0 == "-D") { token0= QString(strvalues[TOKEN_KEYWORD_DATABASE].chars).toLower(); is_token2_needed= true; }
      if (token0 == "-E") token0= QString(strvalues[TOKEN_KEYWORD_VERTICAL].chars).toLower();
      if (token0 == "-e") { token0= QString(strvalues[TOKEN_KEYWORD_EXECUTE].chars).toLower(); is_token2_needed= true; }
      if (token0 == "-f") token0= QString(strvalues[TOKEN_KEYWORD_FORCE].chars).toLower();
      if (token0 == "-G") token0= QString(strvalues[TOKEN_KEYWORD_NAMED_COMMANDS].chars).toLower();
      if (token0 == "-H") token0= QString(strvalues[TOKEN_KEYWORD_HTML].chars).toLower();
      if (token0 == "-h") { token0= QString(strvalues[TOKEN_KEYWORD_HOST].chars).toLower(); is_token2_needed= true; }
      if (token0 == "-i") token0= QString(strvalues[TOKEN_KEYWORD_IGNORE_SPACES].chars).toLower();
      if (token0 == "-j") token0= QString(strvalues[TOKEN_KEYWORD_SYSLOG].chars).toLower();
      if (token0 == "-L") token0= "skip_line_numbers";
      /* Somewhere I think I saw "l login-path" but it doesn't work with mysql client. */
      if (token0 == "-N") token0= "skip_column_names";
      if (token0 == "-n") token0= QString(strvalues[TOKEN_KEYWORD_UNBUFFERED].chars).toLower();
      if (token0 == "-o") token0= QString(strvalues[TOKEN_KEYWORD_ONE_DATABASE].chars).toLower();
      if (token0 == "-P") { token0= QString(strvalues[TOKEN_KEYWORD_PORT].chars).toLower(); is_token2_needed= true; }
      if (token0 == "-p") token0= QString(strvalues[TOKEN_KEYWORD_PASSWORD].chars).toLower();
      if (token0 == "-q") token0= QString(strvalues[TOKEN_KEYWORD_QUICK].chars).toLower();
      if (token0 == "-r") token0= QString(strvalues[TOKEN_KEYWORD_RAW].chars).toLower();
      if (token0 == "-S") { token0= QString(strvalues[TOKEN_KEYWORD_SOCKET].chars).toLower(); is_token2_needed= true; }
      if (token0 == "-s") token0= QString(strvalues[TOKEN_KEYWORD_SILENT].chars).toLower();
      if (token0 == "-T") token0= QString(strvalues[TOKEN_KEYWORD_DEBUG_INFO].chars).toLower();
      if (token0 == "-t") token0= QString(strvalues[TOKEN_KEYWORD_TABLE].chars).toLower();
      if (token0 == "-U") token0= QString(strvalues[TOKEN_KEYWORD_SAFE_UPDATES].chars).toLower();
      if (token0 == "-u") { token0= QString(strvalues[TOKEN_KEYWORD_USER].chars).toLower(); is_token2_needed= true; }
      if (token0 == "-V") token0= QString(strvalues[TOKEN_KEYWORD_VERSION].chars).toLower();
      if (token0 == "-v") token0= QString(strvalues[TOKEN_KEYWORD_VERBOSE].chars).toLower();
      if (token0 == "-W") token0= QString(strvalues[TOKEN_KEYWORD_PIPE].chars).toLower();
      if (token0 == "-w") token0= QString(strvalues[TOKEN_KEYWORD_WAIT].chars).toLower();
      if (token0 == "-X") token0= QString(strvalues[TOKEN_KEYWORD_XML].chars).toLower();
      if ((i < argc - 1) && (is_token2_needed == true) && (token2 == ""))
      {
        token1= "="; token2= argv[i + 1];
        ++i;
      }
    }
    /* If there are two '-'s then token0=argv[i] left, token1='=', token2=argv[i] right */
    else
    {
      QString equaller= "=";
      int equaller_index= s_argv.indexOf(equaller);
      int argv_length= strlen(argv[i]);
      if (equaller_index == -1)
      {
        token0= s_argv.mid(2, argv_length - 2);
        token1= "";
        token2= "";
        if (i < (argc - 1))
        {
          QString token_next= argv[i + 1];
          if (token_next.mid(0, 1) == "=")
          {
            ++i;
            if (token_next.size() == 1)
            {
              if (i < (argc - 1))
              {
                token2= argv[i + 1];
                ++i;
              }
            }
            else
            {
              token2= token_next.mid(1, token_next.size() - 1);
            }
          }
        }
      }
      else if ((equaller_index == (argv_length - 1)) && (argv_length > 3))
      {
        token0= s_argv.mid(2, argv_length - 3);
        token1= "=";
        token2= "";
        /* 2021-03-10 it turns out that password= --user=root should work (password is blank) */
        if ((i < (argc - 1)) && (argv[i + 1][0] != '-'))
        {
          token2= argv[i + 1];
          ++i;
        }
      }
      else
      {
        token0= s_argv.mid(2, equaller_index - 2);
        token1= "=";
        token2= s_argv.mid(equaller_index + 1, (argv_length - equaller_index) - 1);
      }
    }
    connect_set_variable(token0, token1, token2);
  }
}

/* todo: check if we've already looked at the file (this is possible if !include or !includedir happens)
         if so, skip */
/* todo: this might be okay for a Linux file that ends lines with \n, but what about Windows? */
/*
  Re groups:
    The MySQL mysql client looks for [client] and [mysql].
    The MariaDB mysql client looks for [client] and [mysql] and [client-server] and [mariadb-client].
    Re MariaDB-specific groups [client-server] and [client-mariadb]:
    The problem is that we don't know for sure we're connecting to a MariaB server until after we connect.
    For [client-server] I'm going to assume that anything in the group is probably valid for a MySQL server too.
    For [client-mariadb] we could depend on hints e.g. we actually opened mariadb.cnf file when asking for my.cnf,
    or we saw [client-server], or we saw the comment line "# The MariaDB configuration file", or the link is to
    a mariadb library,  but none of those things are certain proofs. Decision was: [client-mariadb] only matters
    when earlier we saw a setting ocelot_dbms=%mariadb% via cmake . -DDEFAULT_OPTION | command-line or on
    command line i.e. --ocelot_dbms=mariadb or earlier in .cnf file.
    Therefore ...
    We look for [client] and [mysql] and [client-server] always i.e. even if ocelot_dbms=tarantool.
    (There is no specific [tarantool] or [tarantool-client] group.)
    We also look for [client-mariadb] iff ocelot_dbms=mariadb has been specified.
    We allow cnf files to contain ocelot_dbms= and defaults_group_suffix= so anything after will depend on
    those settings, therefore the order of file reading matters, and therefore the print should say
    "(final settings)" which can be understood as "dbms or group suffix may have changed during my.cnf reading".
    The initial assumption is mysql but see CMakeLists.txt comment re
    cmake . -DDEFAULT_OPTION="--ocelot_dbms=mariadb".
    Groups can also have a suffix due to MYSQL_GROUP_SUFFIX or --defaults-group-suffix or .cnf.
    So if "ocelotgui" should be a group just say suffix is gui.
    We get a list of readable groups via my_cnf_groups_list() based on these comments.
    Todo: It would be faster to call my_cnf_groups_list() only at start or when we change dbms or suffix.
    Todo: mysql client sees [] as an ignorable group, we don't see it at all, though I guess it's undocumented.
*/
void MainWindow::connect_read_my_cnf(const char *file_name, int is_mylogin_cnf)
{
  log("connect_read_my_cnf", 15);
  //FILE *file;
  char line[2048];
  int token_offsets[100]; /* actually 10 is enough, currently */
  int token_lengths[100];
  int i;
  QString token0, token1, token2, token_for_value;
  QString group;                                         /* what was in the last [...] e.g. mysqld, client, mysql, ocelot */
  int token0_length, token1_length, token2_length;
  unsigned char output_buffer[65536];                    /* todo: should be dynamic size */

  group= "";                                             /* group identifier doesn't carry over from last .cnf file that we read */
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
  struct stat st;
  if (stat(file_name, &st) == 0)
  {
    if ((st.st_mode & S_IWOTH) == S_IWOTH)
    {
      printf("Ignoring world-writable configuration file %s.\n", file_name);
      return;
    }
  }
#endif
  QFile file(file_name);
  /* 2016-04-20 removed QIODevice::Text */
  bool open_result= file.open(QIODevice::ReadOnly);
  if (open_result == false)
  {
    return;                                              /* (if file doesn't exist, ok, no error */
  }
  //file= fopen(file_name, "r");                           /* Open specified file, read only */
  //if (file == NULL) return;                              /* (if file doesn't exist, ok, no error */
  /* Todo: Even if OCELOT_MYSQL_INCLUDE == 0) we should be able to read mylogin.cnf, find another way to get AES_decrypt */
#if (OCELOT_MYSQL_INCLUDE == 1)
  if (is_mylogin_cnf == 1)
  {
      /*
        todo: close file when return, including return for error
      */
      /*
        connect_readmylogin() is a variation of readmylogin.c
        AES_KEY and AES_BLOCK_SIZE are defined in ocelotgui.h
        If openSSL is not available, ignore it (mysql would always read because YaSSL is bundled).
        If .mylogin.cnf is not an encrypted file, ignore it (same as what mysql would do).
      */
      //int MainWindow::connect_readmylogin(QFile &file, unsigned char *output_buffer)
      {
        QString ldbms_return_string;

        ldbms_return_string= "";

        /* First find libcrypto.so */
        if (is_libcrypto_loaded != 1)
        {
          lmysql->ldbms_get_library(ocelot_ld_run_path, &is_libcrypto_loaded, &libcrypto_handle, &ldbms_return_string, WHICH_LIBRARY_LIBCRYPTO);
        }
        if (is_libcrypto_loaded != 1)
        {
          lmysql->ldbms_get_library("", &is_libcrypto_loaded, &libcrypto_handle, &ldbms_return_string, WHICH_LIBRARY_LIBCRYPTO);
        }
        if (is_libcrypto_loaded != 1)
        {
          file.close(); return; /* if decryption fails, ignore */
        }
        unsigned char cipher_chunk[4096];
        unsigned int cipher_chunk_length, output_length= 0, i;
        unsigned char key_in_file[20];
        unsigned char key_after_xor[AES_BLOCK_SIZE] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
        AES_KEY key_for_aes;

        if (file.seek(4) == false)
        //if (fseek(file, 4, SEEK_SET) != 0)
        {
          file.close(); return; /* if decryption fails, ignore */
        }
        if (file.read((char*)key_in_file, 20) != 20)
        //if (fread(key_in_file, 1, 20, file) != 20)
        {
          file.close(); return; /* if decryption fails, ignore */
        }

        for (i= 0; i < 20; ++i) *(key_after_xor + (i%16))^= *(key_in_file + i);
        lmysql->ldbms_AES_set_decrypt_key(key_after_xor, 128, &key_for_aes);

        while (file.read((char*)&cipher_chunk_length, 4) == 4)
        //while (fread(&cipher_chunk_length, 1, 4, file) == 4)
        {
          if (cipher_chunk_length > sizeof(cipher_chunk))
          {
            file.close(); return; /* if decryption fails, ignore */
          }
          if (file.read((char*)cipher_chunk, cipher_chunk_length) != cipher_chunk_length)
          //if (fread(cipher_chunk, 1, cipher_chunk_length, file) != cipher_chunk_length)
          {
            file.close(); return; /* if decryption fails, ignore */
          }
          for (i= 0; i < cipher_chunk_length; i+= AES_BLOCK_SIZE)
          {
            lmysql->ldbms_AES_decrypt(cipher_chunk+i, output_buffer+output_length, &key_for_aes);
            output_length+= AES_BLOCK_SIZE;
            while ((output_length > 0) && (*(output_buffer+(output_length-1)) < ' ') && (*(output_buffer+(output_length-1)) != '\n')) --output_length;
          }
        }
        *(output_buffer + output_length)= '\0';
        //return 0;
      }
  }
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  options_files_read.append(file_name); options_files_read.append(" ");
  char *fgets_result;
  int file_offset= 0;
  int line_offset= 0;
  for (;;)
  {
    if (is_mylogin_cnf == 0)
    {
      if (file.atEnd() == true) {fgets_result= NULL; }
      else
      {
        QByteArray qbline;
        qbline= file.readLine((sizeof line) - 1);
        int ii;
        for (ii= 0; ii < qbline.size(); ++ii) line[ii]= qbline[ii];
        line[ii]= '\0';
        //line= file.readLine(sizeof line);
        fgets_result=&line[0];
      }
      //fgets_result= fgets(line, sizeof line, file);
    }
    else
    {
      for (line_offset= 0; *(output_buffer + file_offset) != '\0'; ++line_offset, ++file_offset)
      {
        *(line + line_offset)= *(output_buffer + file_offset);
        if (*(line + line_offset) == '\n') { ++line_offset; ++file_offset; break; }
      }
      *(line + line_offset)= '\0';
      if (line_offset > 0) fgets_result= (char*) output_buffer;
      else fgets_result= NULL;
    }
    if (fgets_result == NULL) break;
    QString s= line;
    /* tokenize, ignore # comments or / * comments * /, treat '-' as part of token not operator */
    tokenize(s.data(),
             s.size(),
             &token_lengths[0], &token_offsets[0], 100 - 1,
            (QChar*)"33333", 2, "", 2);
    /* Ignore blank lines and lines that start with ';' */
    if (token_lengths[0] == 0) continue;
    if (QString::compare(s.mid(token_offsets[0], token_lengths[0]), ";", Qt::CaseInsensitive) == 0) continue;
    /* Possible meaningful lines are: [ group ], ! include x, ! includedir x, variable = value */
    token0_length= token_lengths[0];
    token0= s.mid(token_offsets[0], token0_length);
    token1_length= token_lengths[1];
    if (token1_length != 0) token1= s.mid(token_offsets[1], token1_length);
    else token1= "";
    if (token1_length == 0) token_lengths[2]= 0;
    token2_length= token_lengths[2];
    if (token2_length != 0)
    {
      int last_token;
      for (last_token= 3; token_lengths[last_token] != 0; ++last_token) ;
      token2_length= token_offsets[last_token - 1] + token_lengths[last_token - 1] - token_offsets[2];
      token2= s.mid(token_offsets[2], token2_length);
    }
    else token2= "";

    /* See if it's !include + file-name */
    /* todo: check for a sym link, or a directory. I don't know what we should do with such junk. */
    if ((QString::compare(token0, "!") == 0) && (QString::compare(token1, "include", Qt::CaseInsensitive) == 0))
    {
      char new_file_name[2048];
      strcpy(new_file_name,token2.toUtf8());
      *(new_file_name + token2_length)= 0;
      connect_read_my_cnf(new_file_name, 0);
    }
    ///* See if it's !includedir */
    //if ((QString::compare(token0, "!") == 0) && (QString::compare(token1, "includedir", Qt::CaseInsensitive) == 0))
    //{
    //  DIR *d;
    //  struct dirent *dir;
    //  char new_directory_name[2048];
    //  strcpy(new_directory_name,token2.toUtf8());
    //  *(new_directory_name + token2_length)= 0;
    //  d= opendir(new_directory_name);
    //  if (d)
    //  {
    //    while ((dir = readdir(d)) != NULL)
    //    {
    //      if ((strlen(dir->d_name)>4) && (strcmp(dir->d_name + strlen(dir->d_name) - 4, ".cnf") == 0))
    //      {
    //        char new_file_name[2048];
    //        strcpy(new_file_name, new_directory_name);
    //        strcat(new_file_name, "/");
    //        strcat(new_file_name, dir->d_name);
    //        connect_read_my_cnf(new_file_name, 0);
    //      }
    //    }
    //    closedir(d);
    //  }
    //}
    /* See if it's !includedir */
    /* Todo: there are no checks for looping; not sure what to do with hidden or symlink */
    if ((QString::compare(token0, "!") == 0) && (QString::compare(token1, "includedir", Qt::CaseInsensitive) == 0))
    {
      QDir dir(token2);
      dir.setFilter(QDir::Files | QDir::Hidden);
      QFileInfoList list= dir.entryInfoList();
      for (int i= 0; i < list.size(); ++i)
      {
        QFileInfo fileInfo= list.at(i);
#if defined(Q_OS_LINUX) || defined(Q_OS_FREEBSD)
        QString file_name= fileInfo.fileName();
        if (file_name.right(4) == ".cnf")
#endif
#ifdef Q_OS_WIN32
        QString file_name= fileInfo.fileName().toUpper();
        if ((file_name.right(4) == ".CNF") || (file_name.right(4) == ".INI"))
#endif
        {
          QString s= token2;
          s.append("/");
          s.append(fileInfo.fileName());
          char new_file_name[2048];
          strcpy(new_file_name, s.toUtf8());
          *(new_file_name + s.length())= '\0';
          connect_read_my_cnf(new_file_name, 0);
        }
      }
    }
    /* See if it's [ group ] */
    if ((QString::compare(token0, "[") == 0) && (QString::compare(token2,"]") == 0))
    {
      group= token1;
      continue;
    }
    if ((is_mylogin_cnf == 1) && (QString::compare(group, ocelot_login_path, Qt::CaseInsensitive) == 0))
    {
      /* it's in .mylogin.cnf and the group matches the specified login path */
    }
    else
    {
      /* Skip if it's not one of the groups that we care about, see comments preceding this function. */
      /* QStringList::contains() or QStringList::indexOf() would work but require newish Qt versions. */
      QStringList qs= my_cnf_groups_list();
      bool is_match= false;
      for (int i_in_group= 0; i_in_group < qs.size(); ++i_in_group)
      {
        if (QString::compare(group, qs.at(i_in_group), Qt::CaseInsensitive) == 0) is_match= true;
      }
      if (is_match == false) continue;
    }
    /* Remove ''s or ""s around the value, then strip lead or trail spaces. */
    token2= connect_stripper(token2, true);
    token2_length= token2.size();
    /* Convert escape sequences in the value \b backspace, \t tab, \n newline, \r carriage return, \\ \, \s space */
    token_for_value= "";
    for (i= 0; i < token2_length; ++i)
    {
      QString c, c2;
      c= token2.mid(i, 1);
      if ((c == "\\") && (i < token2_length))
      {
        c2= token2.mid(i + 1, 1);
        if (c2 == "b") { c2= "\x08"; token_for_value = token_for_value + c2; ++i; continue; }
        if (c2 == "t"){ c2= "\x09"; token_for_value = token_for_value + c2; ++i; continue; }
        if (c2 == "n"){ c2= "\x0a"; token_for_value = token_for_value + c2; ++i; continue; }
        if (c2 == "r") { c2= "\x0d"; token_for_value = token_for_value + c2; ++i; continue; }
        if (c2 == "\\") { c2= "\\"; token_for_value = token_for_value + c2; ++i; continue; }
        if (c2 == "s") { c2= "\x20"; token_for_value = token_for_value + c2; ++i; continue; }
      }
      token_for_value= token_for_value + c;
    }
    token2= token_for_value;
    connect_set_variable(token0, token1, token2);
  }
  file.close();
  //fclose(file);
}

/* Called by connect_read_my_cnf() + print_help(). See comments preceding connect_read_my_cnf(). */
QStringList MainWindow::my_cnf_groups_list()
{
  QStringList qs;
  qs.clear();
  qs.append("client");
  qs.append("mysql");
  qs.append("client-server");
  if (ocelot_dbms.contains("mariadb", Qt::CaseInsensitive) == true) qs.append("client-mariadb");
  qs.append("ocelot");
  if (ocelot_defaults_group_suffix > "")
  {
    int qs_size=qs.size();
    for (int i= 0; i < qs_size; ++i)
    {
      QString s= qs.at(i);
      qs.append(s + ocelot_defaults_group_suffix);
    }
  }
  return qs;
}

/*
  Remove ''s or ""s or ``s around a QString, then remove lead or trail spaces.
  Called for connect, and also for things like USE `test`.
  I didn't say remove lead or trail whitespace, so QString "trimmed()" is no good.
  Todo: This will also change 'xxx''yyy' to 'xxx'yyy', I'm not sure that's always good.
  todo: I'm not sure that `` (tildes) should be removed for my.cnf values, check that
        (we are depending on stripping of ``s when we call connect_stripper() with debuggee information status values)
  todo: I am fairly sure that I need to call this from other places too.
  Todo: strip_doublets_flag, i.e. change 'xxx''yyy' to xxx'yyy' etc., is currently only true
        for condition_1 and for command-line options. Maybe it should be more, maybe less.
*/
QString MainWindow::connect_stripper(QString value_to_strip, bool strip_doublets_flag)
{
  QString s;
  int s_length;
  char c_singlequote[2];
  char c_doublequote[2];
  char c_grave_accent[2]; /* Grave Accent is the Unicode term for `. MySQL calls it backtick. */

  s= value_to_strip;
  s_length= s.size();
  if (s_length > 1)
  {
    c_singlequote[0]= 0x27; c_singlequote[1]= 0;
    c_doublequote[0]= 0x22; c_doublequote[1]= 0;
    c_grave_accent[0]= 0x60; c_grave_accent[1]= 0;
    if (((s.mid(0, 1) == QString(c_singlequote)) && (s.mid(s_length - 1, 1) == QString(c_singlequote)))
    ||  ((s.mid(0, 1) == QString(c_doublequote)) && (s.mid(s_length - 1, 1) == QString(c_doublequote)))
    ||  ((s.mid(0, 1) == QString(c_grave_accent)) && (s.mid(s_length - 1, 1) == QString(c_grave_accent))))
    {
      QString strippable_char= s.mid(0, 1);                    /* strippable_char = " or ' or ` */
      s= s.mid(1, s_length - 2);
      while ((s.size() > 0) && (s.mid(0, 1) == " "))
      {
        s_length= s.size();
        s= s.mid(1, s_length - 1);
      }
      while ((s.size() > 0) && (s.mid(s.size() - 1, 1) == " "))
      {
        s_length= s.size();
        s= s.mid(0, s_length - 1);
      }
      if (strip_doublets_flag == true)
      {
        QString s2= "";
        for (int i= 0; i < s.size(); ++i)
        {
          QString c= s.mid(i, 1);
          s2.append(c);
          if ((c == strippable_char) && (i < (s.size() - 1)) && (c == s.mid(i + 1, 1))) ++i;
        }
        return s2;
      }
    }
  }
  return s;
}

/* Add ' at start and end of a string.
   Change ' to '' within string. Compare connect_stripper().
   with string literals inside single quotes. Need doublets.
   Todo: This is the same code as TextEditWidget::unstripper(),
         see whether you can reduce the duplication.
   Todo: Consider:
         if (co.contains("''")) co= co.replace("''", "'");
         Would surely be faster?
   Todo: We also have something in debug_debug_go for changing ' to '',
         maybe there's code duplication
   Todo: Maybe something in setup_generate_routine_entry_parameter
         has something similar too, maybe there's code duplication.
   Todo: debugger routines should call this when we generate statements
         but so far it's not happening
*/
QString MainWindow::connect_unstripper(QString value_to_unstrip)
{
  QString s;
  QString c;

  s= "'";
  for (int i= 0; i < value_to_unstrip.size(); ++i)
  {
    c= value_to_unstrip.mid(i, 1);
    s.append(c);
    if (c == "'") s.append(c);
  }
  s.append("'");
  return s;
}



/*
  Given token0=option-name [token1=equal-sign token2=value],
  see if option-name corresponds to one of your program-variables,
  and if so set program-variable = true or program-variable = value.
  For example, if token0="user", token1="=", token2="peter",
  then set ocelot_user = "peter".
  But that would be too simple, eh? So here are some complications:
  * unambiguous prefixes of option names are allowed until MySQL 5.7
    (this is true for options but not true for values)
    http://dev.mysql.com/doc/refman/5.6/en/program-options.html
  * '-' and '_' are interchangeable
    http://dev.mysql.com/doc/refman/5.6/en/command-line-options.html
  * if the target is numeric and ends with K etc., multiply by 1024 etc.
  option our variable name mysql variable name
  ------ ----------------- -------------------
  ho[st] ocelot_host       current_host
  us[er] ocelot_user       current_user
  database ocelot_database current_db
  so[cket] ocelot_unix_socket                opt_mysql_unix_port
  po[rt]   ocelot_ca.port     mysql opt_mysql_port
  comm[ents] ocelot_ca.comments preserve_comments
  ocelot_init_command opt_init_command
  ocelot_default_auth opt_default_auth
  no-defaults ocelot_ca.no_defaults
  defaults-extra-file ocelot_defaults_extra_file
  defaults-file ocelot_defaults_file
  delimiter ocelot_delimiter_str
  show-warnings ocelot_ca.history_includes_warnings
  connect_timeout ocelot_ca.opt_connect_timeout
  compress ocelot_ca.opt_compress
  secure_auth ocelot_ca.secure_auth
  local_infile ocelot_ca.opt_local_infile
  safe_updates or i_am_a_dummy ocelot_ca.safe_updates
  plugin_dir ocelot_plugin_dir
  select_limit ocelot_ca.select_limit
  max_join_size ocelot_ca.max_join_size
  silent ocelot_ca.silent
  no_beep ocelot_ca.no_beep
  wait ocelot_ca.wait
  default-character-set ocelot_default_character_set
*/
/*
  Re undocumented behaviour with option modifiers
  The rules in http://dev.mysql.com/doc/refman/5.7/en/option-modifiers.html
  "Program Option Modifiers" are weird already. To make it weirder, here's
  a partial description of undocumented behaviour of mysql client.
  For booleans:
  ! If first letter of value = '0' it's 0, if first letter of value = '1' it's 1
  ! --enable-disable-show-warnings is OK, the last prefix decides
  ! If enable|disable|skip was stated, and [= value] is stated, then
    If value = 0, then it reverses whatever enable|disable is in place so far
      Else [= value] clause is ignored
    Otherwise
      If value is blank or invalid, ignore the whole specification and warn
  For non-booleans:
  ! If we say --skip-port=5, then port = 0 i.e. override previous setting
  ! If we say --skip-delimiter=x then delimiter = ; i.e. return to default
  ! If we say --skip-socket=x then socket='0' i.e. override previous setting
  I try to follow some of this but not all.
*/
/*
  Re case sensitivity:
    * Effectively case sensitive for "skip_" etc. because we use strcmp()
    * Effectively case insensitive for keywords because get_keyword_index makes upper
    * For variables beginning "ocelot_" we may use strcasecmp rather than strcmp.
    * This is different from mysql which is usually case sensitive all the way
*/
void MainWindow::connect_set_variable(QString token0, QString token1, QString token2)
{
  unsigned int token0_length;
  char token0_as_utf8[80 + 1];
  unsigned short int is_enable;
  token0_length= token0.size();
  if (token0_length >= 64) return; /* no option name is ever longer than 80 bytes */
  strcpy(token0_as_utf8,token0.toUtf8());
  *(token0_as_utf8 + token0_length)= 0;
  for (int i= 0; token0_as_utf8[i] != '\0'; ++i)
  {
    if (token0_as_utf8[i] == '-') token0_as_utf8[i]= '_';
  }

  /* option modifiers: ignore loose, set enable=true if enable or false if disable|skip */
  is_enable= 1;
  bool is_enable_disable_skip_specified= false;
  for (;;)
  {
    if (strncmp(token0_as_utf8, "loose_", sizeof("loose_") - 1) == 0)
    {
      strcpy(token0_as_utf8, token0_as_utf8 + sizeof("loose_") - 1);
      continue;
    }
    if (strncmp(token0_as_utf8, "enable_", sizeof("enable_") - 1) == 0)
    {
      is_enable_disable_skip_specified= true;
      is_enable= 1;
      strcpy(token0_as_utf8, token0_as_utf8 + sizeof("enable_") - 1);
      continue;
    }
    if (strncmp(token0_as_utf8, "disable_", sizeof("disable_") - 1) == 0)
    {
      is_enable_disable_skip_specified= true;
      is_enable= 0;
      strcpy(token0_as_utf8, token0_as_utf8 + sizeof("disable_") - 1);
      continue;
    }
    if (strncmp(token0_as_utf8, "skip_", sizeof("skip_") - 1) == 0)
    {
      is_enable_disable_skip_specified= true;
      is_enable= 0;
      strcpy(token0_as_utf8, token0_as_utf8 + sizeof("skip_") - 1);
      continue;
    }
    break;
  }
  if ((is_enable_disable_skip_specified == false) && (token2 > ""))
  {
    QString token2_upper= token2.toUpper();
    if ((token2 == "ON") || (token2 == "TRUE") || (token2.left(1) == "1")) ;
    else if ((token2 == "OFF") || (token2 == "FALSE") || (token2.left(1) == "0")) is_enable= 0;
    else /* error */ is_enable= 0;
  }

  char key2[MAX_KEYWORD_LENGTH + 1];
  int keyword_index;
  keyword_index= get_keyword_index(token0_as_utf8, key2);
  /*
    Shortenings.
    These are obsolete, one should say --password= not -pas=, but we continue to accept them.
    Todo: put this inside "if keyword_index < 0" if you're sure there can be no ambiguity.
    Todo: let this be case insensitive like most other options, and compared with strvalues[] items.
    Todo: let i_am_a_dummy be part of the keyword list? */
  {
    if ((token0_length >= sizeof("pas") - 1) && (strncmp(token0_as_utf8, "password", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_PASSWORD;
    if ((token0_length >= sizeof("comm") - 1) && (strncmp(token0_as_utf8, "comments", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_COMMENTS;
    if ((token0_length >= sizeof("comp") - 1) && (strncmp(token0_as_utf8, "compress", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_COMPRESS;
    if ((token0_length >= sizeof("con") - 1) && (strncmp(token0_as_utf8, "connect_timeout", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_CONNECT_TIMEOUT;
    if ((token0_length >= sizeof("default_a") - 1) && (strncmp(token0_as_utf8, "default_auth", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_DEFAULT_AUTH;
    if ((token0_length >= sizeof("del") - 1) && (strncmp(token0_as_utf8, "delimiter", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_DELIMITER;
    if ((token0_length >= sizeof("ho") - 1) && (strncmp(token0_as_utf8, "host", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_HOST;
    if ((token0_length >= sizeof("i_") - 1) && (strncmp(token0_as_utf8, "i_am_a_dummy", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SAFE_UPDATES;
    if ((token0_length >= sizeof("loc") - 1) && (strncmp(token0_as_utf8, "local_infile", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_LOCAL_INFILE;
    if ((token0_length >= sizeof("max_j") - 1) && (strncmp(token0_as_utf8, "max_join_size", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_MAX_JOIN_SIZE;
    if ((token0_length >= sizeof("no_b") - 1) && (strncmp(token0_as_utf8, "no_beep", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_NO_BEEP;
    if ((token0_length >= sizeof("pas") - 1) && (strncmp(token0_as_utf8, "password", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_PASSWORD;
    if ((token0_length >= sizeof("pl") - 1) && (strncmp(token0_as_utf8, "plugin_dir", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_PLUGIN_DIR;
    if ((token0_length >= sizeof("po") - 1) && (strncmp(token0_as_utf8, "port", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_PORT;
    if ((token0_length >= sizeof("prot") - 1) && (strncmp(token0_as_utf8, "protocol", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_PROTOCOL;
    if ((token0_length >= sizeof("sa") - 1) && (strncmp(token0_as_utf8, "safe_updates", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SAFE_UPDATES;
    if ((token0_length >= sizeof("sec") -1 ) && (strncmp(token0_as_utf8, "secure_auth", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SECURE_AUTH;
    if ((token0_length >= sizeof("sel") - 1) && (strncmp(token0_as_utf8, "select_limit", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SELECT_LIMIT;
    if ((token0_length >= sizeof("sh") - 1) && (strncmp(token0_as_utf8, "show_warnings", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SHOW_WARNINGS;
    if ((token0_length >= sizeof("sil") - 1) && (strncmp(token0_as_utf8, "silent", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SILENT;
    if ((token0_length >= sizeof("so") - 1) && (strncmp(token0_as_utf8, "socket", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SOCKET;
    if ((token0_length >= sizeof("ssl_verify") - 1) && (strncmp(token0_as_utf8, "ssl_verify_server_cert", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_SSL_VERIFY_SERVER_CERT;
    if ((token0_length >= sizeof("us") - 1) && (strncmp(token0_as_utf8, "user", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_USER;
    if ((token0_length >= sizeof("wa") - 1) && (strncmp(token0_as_utf8, "wait", token0_length) == 0))
      keyword_index= TOKEN_KEYWORD_WAIT;
  }

  if (keyword_index == TOKEN_KEYWORD_ABORT_SOURCE_ON_ERROR) { ocelot_ca.abort_source_on_error= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_AUTO_REHASH) { ocelot_ca.auto_rehash= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_AUTO_VERTICAL_OUTPUT) { ocelot_ca.auto_vertical_output= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_BATCH)
  {
    ocelot_ca.batch= is_enable;
    ocelot_ca.silent= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_BINARY_MODE) { ocelot_ca.binary_mode= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_BIND) /* not available in mysql client */
  {
    ocelot_opt_bind= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_BIND_ADDRESS) { ocelot_bind_address= is_enable; return; }

  if (keyword_index == TOKEN_KEYWORD_CONNECT_EXPIRED_PASSWORD) /* not available in mysql client before version 5.7 */
  {
    ocelot_ca.opt_can_handle_expired_passwords= is_enable;
    return;
  }

  if (keyword_index == TOKEN_KEYWORD_CHARACTER_SETS_DIR)
  {
    ocelot_set_charset_dir= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_COLUMN_NAMES) {
    ocelot_ca.result_grid_column_names= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_COLUMN_TYPE_INFO) { ocelot_ca.column_type_info= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_COMMENTS)
  {
    ocelot_ca.comments= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_COMPRESS)
  {
    ocelot_ca.opt_compress= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_CONNECT_ATTR_DELETE) /* not available in mysql client */
  {
    ocelot_opt_connect_attr_delete= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_CONNECT_ATTR_RESET) /* not available in mysql client */
  {
    ocelot_ca.opt_connect_attr_reset= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_CONNECT_TIMEOUT)
  {
    ocelot_ca.opt_connect_timeout= to_long(token2);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_DATABASE)
  {
    ocelot_database= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_DEBUG) { ocelot_debug= token2; return; }
  if (keyword_index == TOKEN_KEYWORD_DEBUG_INFO) { ocelot_ca.debug_info= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_DEFAULT_AUTH)
  {
    ocelot_default_auth= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_DEFAULT_CHARACTER_SET)
  {
    ocelot_set_charset_name= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_DEFAULTS_EXTRA_FILE)
  {
    ocelot_defaults_extra_file= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_DEFAULTS_FILE)
  {
    ocelot_defaults_file= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_DEFAULTS_GROUP_SUFFIX)
  {
    ocelot_defaults_group_suffix= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_DELIMITER)
  {
    ocelot_delimiter_str= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_ENABLE_CLEARTEXT_PLUGIN)
  {
    ocelot_ca.enable_cleartext_plugin= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_EXECUTE) { ocelot_execute= token2; return; }
  if (keyword_index == TOKEN_KEYWORD_FORCE) { ocelot_ca.force= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_HELP) { ocelot_ca.help= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_HISTFILE) { ocelot_history_hist_file_name= token2; return; }
  if (keyword_index == TOKEN_KEYWORD_HISTIGNORE) { ocelot_histignore= token2; return; }
  if (keyword_index == TOKEN_KEYWORD_HOST)
  {
    ocelot_host= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_HTML) { ocelot_ca.html= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_SAFE_UPDATES) /* Actually this could be "i-am-a-dummy" */
  {
    ocelot_ca.safe_updates= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_IGNORE_SPACES) { ocelot_ca.ignore_spaces= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_LD_RUN_PATH) { ocelot_ld_run_path= token2; return; }
  if (keyword_index == TOKEN_KEYWORD_INIT_COMMAND)
  {
    ocelot_init_command= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_LINE_NUMBERS) { ocelot_ca.line_numbers= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_LOCAL_INFILE)
  {
    if (token2 > "") ocelot_ca.opt_local_infile= to_long(token2);
    else ocelot_ca.opt_local_infile= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_LOGIN_PATH) { ocelot_login_path= token2; return; }
  if (keyword_index == TOKEN_KEYWORD_MAX_ALLOWED_PACKET) { ocelot_ca.max_allowed_packet= to_long(token2); return; }
  if (keyword_index == TOKEN_KEYWORD_MAX_JOIN_SIZE)
  {
    ocelot_ca.max_join_size= to_long(token2);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_NAMED_COMMANDS) { ocelot_ca.named_commands= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_NET_BUFFER_LENGTH) { ocelot_ca.net_buffer_length= to_long(token2); return; }
  if (keyword_index == TOKEN_KEYWORD_NO_AUTO_REHASH) { ocelot_ca.auto_rehash= 0; return; }
  if (keyword_index == TOKEN_KEYWORD_NO_BEEP)
  {
    ocelot_ca.no_beep= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_NO_DEFAULTS) { ocelot_ca.no_defaults= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_NO_NAMED_COMMANDS) { ocelot_ca.named_commands= 0; return; }
  if (keyword_index == TOKEN_KEYWORD_NO_TEE) { history_file_stop("TEE"); return; }/* see comment=tee+hist */

  QString ccn;
  /* Changes to ocelot_* settings. But we don't check that they're in the [ocelot] group. */
  /* Todo: validity checks */

  if (keyword_index == TOKEN_KEYWORD_OCELOT_DBMS)
  {
    /* Warning: what we do here may be overridden after connection, by set_dbms_version_mask() */
    ocelot_dbms= token2;
    if (ocelot_dbms.contains("mysql", Qt::CaseInsensitive) == true)
    {
      connections_dbms[0]= DBMS_MYSQL;
    }
    else if (ocelot_dbms.contains("mariadb", Qt::CaseInsensitive) == true)
    {
      connections_dbms[0]= DBMS_MARIADB;
    }
#ifdef DBMS_TARANTOOL
    else if (ocelot_dbms.contains("tarantool", Qt::CaseInsensitive) == true)
    {
      connections_dbms[0]= DBMS_TARANTOOL;
    }
#endif
    else connections_dbms[0]= DBMS_MYSQL; /* default */
#if (OCELOT_MYSQL_INCLUDE == 0)
    connections_dbms[0]= DBMS_TARANTOOL; /* default if no MySQL */
#endif //#if (OCELOT_MYSQL_INCLUDE == 0)
    return;
  }
#ifdef OCELOT_IMPORT_EXPORT
  if (keyword_index == TOKEN_KEYWORD_OCELOT_EXPORT)
  {
    import_export_rule_set(token2);
    return;
  }
#endif
  if (keyword_index == TOKEN_KEYWORD_OCELOT_CLIENT_SIDE_FUNCTIONS) { ocelot_ca.client_side_functions= is_enable; return; }
  else
  {
    /* Anything that starts with "ocelot_" except "ocelot_dbms" "ocelot_client_side_functions" "ocelot_export" */
    if (xsettings_widget->ocelot_variable_set(keyword_index, token2) != ER_OVERFLOW)
    {
      /* It might not be ER_OK but we ignore errors here */
      return;
    }
  }
  if (keyword_index == TOKEN_KEYWORD_OCELOT_QUERY)
  {
    ocelot_query= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_ONE_DATABASE) { ocelot_ca.one_database= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_PAGER) { ocelot_pager= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_PASSWORD)
  {
    ocelot_password= token2;
    ocelot_password_was_specified= is_enable;
    if ((is_enable == 1) && (token1 != "=")) ocelot_password_was_specified= 2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_PIPE) /* Not sure about this. Windows. Same as protocol? */
  {
    ocelot_ca.opt_named_pipe= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_PLUGIN_DIR)
  {
    ocelot_plugin_dir= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_PORT)
  {
    ocelot_ca.port= to_long(token2);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_PRINT_DEFAULTS) {ocelot_ca.print_defaults= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_PROMPT) { ocelot_prompt= token2; ocelot_ca.prompt_is_default= false; return; }
  if (keyword_index == TOKEN_KEYWORD_PROTOCOL)
  {
    ocelot_protocol= token2; /* Todo: perhaps make sure it's tcp/socket/pipe/memory */
    ocelot_ca.protocol_as_int= get_ocelot_protocol_as_int(ocelot_protocol);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_QUICK) { ocelot_ca.quick= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_RAW) { ocelot_ca.raw= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_READ_DEFAULT_FILE) /* not available in mysql client */
  {
    ocelot_read_default_file= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_READ_DEFAULT_GROUP) /* not available in mysql client */
  {
    ocelot_read_default_group= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_READ_TIMEOUT) /* not available in mysql client */
  {
    ocelot_ca.opt_read_timeout= to_long(token2);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_RECONNECT)
  {
    ocelot_ca.opt_reconnect= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_REPORT_DATA_TRUNCATION)/* not available in mysql client */
  {
    ocelot_ca.report_data_truncation= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SAFE_UPDATES)
  {
    ocelot_ca.safe_updates= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SECURE_AUTH)
  {
    ocelot_ca.secure_auth= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SERVER_PUBLIC_KEY) /* not available in mysql client */
  {
    ocelot_server_public_key= token2;
    return;
  }
   if (keyword_index == TOKEN_KEYWORD_SELECT_LIMIT)
  {
    ocelot_ca.select_limit= to_long(token2);
    return;
  }

  if (keyword_index == TOKEN_KEYWORD_SHARED_MEMORY_BASE_NAME)
  {
    ocelot_shared_memory_base_name= token2;
    return;
    }
  if (keyword_index == TOKEN_KEYWORD_SHOW_WARNINGS)
  {
    ocelot_ca.history_includes_warnings= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SIGINT_IGNORE) { ocelot_ca.sigint_ignore= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_SILENT)
  {
    ocelot_ca.silent= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SOCKET)
  {
    ocelot_unix_socket= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL)
  {
    ocelot_opt_ssl= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_CA)
  {
    ocelot_opt_ssl_ca= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_CAPATH)
  {
    ocelot_opt_ssl_capath= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_CERT)
  {
    ocelot_opt_ssl_cert= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_CIPHER)
  {
    ocelot_opt_ssl_cipher= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_CRL)
  {
    ocelot_opt_ssl_crl= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_CRLPATH)
  {
    ocelot_opt_ssl_crlpath= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_KEY)
  {
    ocelot_opt_ssl_key= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_MODE)
  {
    ocelot_opt_ssl_mode= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SSL_VERIFY_SERVER_CERT)
  {
    ocelot_ca.opt_ssl_verify_server_cert= to_long(token2);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_SYSLOG) { ocelot_ca.syslog= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_TABLE) { ocelot_ca.table= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_TEE)
  {
    QString rr;
    history_file_start("TEE", token2, &rr); /* todo: check whether history_file_start returned 0 which is an error */ /* see comment=tee+hist */
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_UNBUFFERED) { ocelot_ca.unbuffered= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_USE_RESULT)/* not available in mysql client */
  {
    ocelot_ca.opt_use_result= to_long(token2);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_USER)
  {
    ocelot_user= token2;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_VERBOSE) { ocelot_ca.verbose= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_VERSION) { ocelot_ca.version= is_enable; return; }
  /* todo: check that this finds both --vertical and -E */ /* for vertical */
  if (keyword_index == TOKEN_KEYWORD_VERTICAL) { ocelot_ca.vertical= is_enable; return; }
  if (keyword_index == TOKEN_KEYWORD_WAIT)
  {
    ocelot_ca.wait= is_enable;
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_WRITE_TIMEOUT)
  {
    ocelot_ca.opt_write_timeout= to_long(token2);
    return;
  }
  if (keyword_index == TOKEN_KEYWORD_XML)
  {
    ocelot_ca.xml= is_enable;
    return;
  }
}


/*
  Given the options that have actually been set to non-default values,
  form a CONNECT statement.
  todo: something should call this for the sake of history, at least.
  todo: instead o x > "", use if (QString::compare(x, " ") > 0)
*/
void MainWindow::connect_make_statement()
{
  /* Todo: QMessageBox should have a parent, use "= new" */
  QMessageBox msgBox;
  QString statement_text;
  statement_text= "CONNECT";
  if (ocelot_defaults_file > "") statement_text= statement_text + " defaults_file=" + ocelot_defaults_file;
  if (ocelot_ca.no_defaults > 0) statement_text= statement_text + " no_defaults";
  if (ocelot_defaults_extra_file > "") statement_text= statement_text + " defaults_extra_file=" + ocelot_defaults_extra_file;
  if (ocelot_host > "") statement_text= statement_text + " host=" + ocelot_host;
  if (ocelot_user > "") statement_text= statement_text + " user=" + ocelot_user;
  if (ocelot_database > "") statement_text= statement_text + " database=" + ocelot_database;
  if (ocelot_ca.port > 0) statement_text= statement_text + " port=" + QString::number(ocelot_ca.port);
  if (ocelot_ca.comments > 0) statement_text= statement_text + " comments";
  if (ocelot_init_command > "") statement_text= statement_text + " init_command=" + ocelot_init_command;
  if (ocelot_default_auth > "") statement_text= statement_text + " default_auth=" + ocelot_default_auth;
  if (ocelot_protocol > "") statement_text= statement_text + " protocol=" + ocelot_protocol;
  if (ocelot_password_was_specified > 0) statement_text= statement_text + " password=" + ocelot_password;
  if (ocelot_unix_socket > "") statement_text= statement_text + " socket=" + ocelot_unix_socket;
  if (ocelot_delimiter_str > "") statement_text= statement_text + " delimiter=" + ocelot_delimiter_str;
  if (ocelot_ca.history_includes_warnings > 0) statement_text= statement_text + " show_warnings";
  if (ocelot_ca.opt_connect_timeout > 0) statement_text= statement_text + " connect_timeout=" + QString::number(ocelot_ca.opt_connect_timeout);
  if (ocelot_ca.opt_compress > 0) statement_text= statement_text + " compress";
  if (ocelot_ca.secure_auth > 0) statement_text= statement_text + " secure_auth";
  if (ocelot_ca.opt_local_infile > 0) statement_text= statement_text + " local_infile";
  if (ocelot_ca.safe_updates > 0) statement_text= statement_text + " safe_updates";
  if (ocelot_plugin_dir > "") statement_text= statement_text + " plugin_dir=" + ocelot_plugin_dir;
  if (ocelot_ca.select_limit > 0) statement_text= statement_text + " select_limit=" + QString::number(ocelot_ca.select_limit);
  if (ocelot_ca.max_join_size > 0) statement_text= statement_text + " max_join_size=" + QString::number(ocelot_ca.max_join_size);
  if (ocelot_ca.silent > 0) statement_text= statement_text + " silent";
  if (ocelot_ca.no_beep > 0) statement_text= statement_text + "no_beep";
  if (ocelot_ca.wait > 0) statement_text= statement_text + "wait";
  if (ocelot_set_charset_name > "") statement_text= statement_text + "default_character_set=" + ocelot_set_charset_name;
  if (ocelot_opt_ssl > "") statement_text= statement_text + "ssl=" + ocelot_opt_ssl;
  if (ocelot_opt_ssl_ca > "") statement_text= statement_text + "ssl_ca=" + ocelot_opt_ssl_ca;
  if (ocelot_opt_ssl_capath > "") statement_text= statement_text + "ssl_capath=" + ocelot_opt_ssl_capath;
  if (ocelot_opt_ssl_cert > "") statement_text= statement_text + "ssl_cert=" + ocelot_opt_ssl_cert;
  if (ocelot_opt_ssl_cipher > "") statement_text= statement_text + "ssl_cipher=" + ocelot_opt_ssl_cipher;
  if (ocelot_opt_ssl_crl > "") statement_text= statement_text + "ssl_crl=" + ocelot_opt_ssl_crl;
  if (ocelot_opt_ssl_crlpath > "") statement_text= statement_text + "ssl_crlpath=" + ocelot_opt_ssl_crlpath;
  if (ocelot_opt_ssl_key > "") statement_text= statement_text + "ssl_key=" + ocelot_opt_ssl_key;
  if (ocelot_opt_ssl_mode > "") statement_text= statement_text + "ssl_mode=" + ocelot_opt_ssl_mode;
  if (ocelot_ca.opt_ssl_verify_server_cert > 0) statement_text= statement_text + "ssl_verify_server_cert=" + ocelot_ca.opt_ssl_verify_server_cert;
  msgBox.setText(statement_text);
  msgBox.exec();
}

#define PROTOCOL_TCP 1
#define PROTOCOL_SOCKET 2
#define PROTOCOL_PIPE 3
#define PROTOCOL_MEMORY 4
unsigned int MainWindow::get_ocelot_protocol_as_int(QString ocelot_protocol)
{
  if (QString::compare(ocelot_protocol, "TCP", Qt::CaseInsensitive) == 0) return PROTOCOL_TCP;
  if (QString::compare(ocelot_protocol, "SOCKET", Qt::CaseInsensitive) == 0) return PROTOCOL_SOCKET;
  if (QString::compare(ocelot_protocol, "PIPE", Qt::CaseInsensitive) == 0) return PROTOCOL_PIPE;
  if (QString::compare(ocelot_protocol, "MEMORY", Qt::CaseInsensitive) == 0) return PROTOCOL_MEMORY;
  return 0;
}

#if (OCELOT_MYSQL_INCLUDE == 1)
/*
  Todo: this routine calls mysql_options() iff option value != 0,
  forgetting that 0 might be non-default, or a change from non-0.
  Also it doesn't check whether mysql_options() failed, but okay.
  Note: we don't pass ocelot_ca.opt_can_handle_expired_passwords because
  it does nothing (maybe due to an old libmysqlclient?), instead we
  pass client_can_handle_expired_passwords to mysql_real_connect().

  Re MySQL 5.7.11 and ssl_mode: mysql allows truncation e.g.
  --ssl_mode='PREF' but we don't it must be in full.
  We don't know in advance whether we'll be connecting with MySQL 5.7.11
  so we'll call only if we (not MariaDB|Tarantool) and (not default).
  Our default is '' but we'll also do nothing if 'preferred'.
  Check if mysql_options() returns != 0 indicating libmysqlclient
  doesn't recognize MYSQL_OPT_SSL_MODE, if so assume it didn't work.
  If it's VERIFY_IDENTITY, we don't try to use --ssl-verify-server-cert.
  It should mean we don't try to use --ssl, but we don't anyway.
*/
int options_and_connect(
    unsigned int connection_number,
    char *database_as_utf8)
{
  if (connected[connection_number] != 0)
  {
    connected[connection_number]= 0;
    lmysql->ldbms_mysql_close(&mysql[connection_number]);
  }
#ifdef _WIN32
  /* Actually this has no effect in my tests. Maybe just superstition. */
  /* But it's harmless. See https://bugs.mysql.com/bug.php?id=8059 */
  /* int padding= 42; */
  mysql_init(&mysql[connection_number]);
#else
  lmysql->ldbms_mysql_init(&mysql[connection_number]);
#endif
  int opt= 0;
  if (ocelot_ca.default_auth_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_23, ocelot_ca.default_auth_as_utf8);
  if (ocelot_ca.enable_cleartext_plugin != 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_36, (char *) &ocelot_ca.enable_cleartext_plugin);
  if (ocelot_ca.init_command_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_3, ocelot_ca.init_command_as_utf8);
  if (ocelot_ca.opt_bind_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_24, ocelot_ca.opt_bind_as_utf8);
  if (ocelot_ca.opt_compress > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_1, NULL);
  if (ocelot_ca.opt_connect_attr_delete_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_34, ocelot_ca.opt_connect_attr_delete_as_utf8);
  if (ocelot_ca.opt_connect_attr_reset != 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_32, (char*) &ocelot_ca.opt_connect_attr_reset);
  if (ocelot_ca.opt_connect_timeout != 0)
  {
    unsigned int timeout= ocelot_ca.opt_connect_timeout;
    lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_0, (char*) &timeout);
  }
  if (ocelot_ca.opt_local_infile > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_8, (char*) &ocelot_ca.opt_local_infile);
  if (ocelot_ca.opt_named_pipe > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_2, (char*) &ocelot_ca.opt_named_pipe);
  if (ocelot_ca.protocol_as_int > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_9, (char*)&ocelot_ca.protocol_as_int);
  if (ocelot_ca.opt_read_timeout > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_11, (char*)&ocelot_ca.opt_read_timeout);
  if (ocelot_ca.opt_reconnect > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_20, (char*)&ocelot_ca.opt_reconnect);

  if (ocelot_ca.opt_ssl_mode_as_utf8[0] != '\0')
  {
    for(int i= 0; ocelot_ca.opt_ssl_mode_as_utf8[i] != 0; ++i)
    {
      ocelot_ca.opt_ssl_mode_as_utf8[i] = toupper(ocelot_ca.opt_ssl_mode_as_utf8[i]);
    }
    if (strcmp(ocelot_ca.opt_ssl_mode_as_utf8, "DISABLED") == 0) opt= 1;
    if (strcmp(ocelot_ca.opt_ssl_mode_as_utf8, "PREFERRED") == 0) opt= 2;
    if (strcmp(ocelot_ca.opt_ssl_mode_as_utf8, "REQUIRED") == 0) opt= 3;
    if (strcmp(ocelot_ca.opt_ssl_mode_as_utf8, "VERIFY_CA") == 0) opt= 4;
    if (strcmp(ocelot_ca.opt_ssl_mode_as_utf8, "VERIFY_IDENTITY") == 0) opt= 5;
    if (opt != 0)
    {
      if (lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_42, (char*) &opt) != 0)
      {
        opt= 0;
      }
    }
  }

  /*
    If dlopen() failed for "myql_ssl_set" then ldbms_mysql_ssl_set is a no-op, which is not an error.
    For some options use mysql_ssl_set because it's in MySQL 5.5, for others use mysql_options.
    We treat "" as the same as NULL, and prefer to pass NULL.
    Instead of looking at ocelot_opt_ssl, we check whether anything is non-NULL.
  */
  {
    char *a= 0, *b= 0, *c= 0, *d= 0, *e= 0;
    if (ocelot_ca.opt_ssl_key_as_utf8[0] != '\0') a= ocelot_ca.opt_ssl_key_as_utf8;
    if (ocelot_ca.opt_ssl_cert_as_utf8[0] != '\0') b= ocelot_ca.opt_ssl_cert_as_utf8;
    if (ocelot_ca.opt_ssl_ca_as_utf8[0] != '\0') c= ocelot_ca.opt_ssl_ca_as_utf8;
    if (ocelot_ca.opt_ssl_capath_as_utf8[0] != '\0') d= ocelot_ca.opt_ssl_capath_as_utf8;
    if (ocelot_ca.opt_ssl_cipher_as_utf8[0] != '\0') e= ocelot_ca.opt_ssl_cipher_as_utf8;
    if ((a != 0) || (b != 0) || (c != 0) || (d != 0) || (e != 0))
    {
      lmysql->ldbms_mysql_ssl_set(&mysql[connection_number], a, b, c, d, e);
    }
  }
  if (ocelot_ca.opt_ssl_crl_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_30, ocelot_ca.opt_ssl_crl_as_utf8);
  if (ocelot_ca.opt_ssl_crlpath_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_31, ocelot_ca.opt_ssl_crlpath_as_utf8);
  if (opt != 5)
  {
    if (ocelot_ca.opt_ssl_verify_server_cert > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_21, (char*) &ocelot_ca.opt_ssl_verify_server_cert);
  }
  if (ocelot_ca.opt_write_timeout > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_12, (char*) &ocelot_ca.opt_write_timeout);
  if (ocelot_ca.plugin_dir_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_22, ocelot_ca.plugin_dir_as_utf8);
  if (ocelot_ca.read_default_file_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_4, ocelot_ca.read_default_file_as_utf8);
  if (ocelot_ca.read_default_group_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_5, ocelot_ca.read_default_group_as_utf8);
  if (ocelot_ca.report_data_truncation > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_19, (char*) &ocelot_ca.report_data_truncation);
  /* secure_auth causes trouble in MySQL 8 and hasn't been useful for years so do not pass it */
  //if (ocelot_ca.secure_auth > 0) lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_18, (char *) &ocelot_ca.secure_auth);
  if (ocelot_ca.server_public_key_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_35, ocelot_ca.server_public_key_as_utf8);
  if (ocelot_ca.set_charset_dir_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_6, ocelot_ca.set_charset_dir_as_utf8);
  if (ocelot_ca.set_charset_name_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_7, ocelot_ca.set_charset_name_as_utf8);
  if (ocelot_ca.shared_memory_base_name_as_utf8[0] != '\0') lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_10, ocelot_ca.shared_memory_base_name_as_utf8);
  if (ocelot_ca.safe_updates > 0)
  {
    char init_command[100]; /* todo: the size could be more dynamic here */
    sprintf(init_command,
        "SET sql_select_limit = %lu, sql_safe_updates = 1, max_join_size = %lu",
        ocelot_ca.select_limit, ocelot_ca.max_join_size);
    lmysql->ldbms_mysql_options(&mysql[connection_number], OCELOT_OPTION_3, init_command);
  }
  /* CLIENT_MULTI_RESULTS but not CLIENT_MULTI_STATEMENTS */
  unsigned long real_connect_flags= CLIENT_MULTI_RESULTS;

  if (ocelot_ca.opt_can_handle_expired_passwords != 0)
    real_connect_flags|= (1UL << 22); /* CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS */

  MYSQL *connect_result;
  char *socket_parameter= ocelot_ca.unix_socket_as_utf8;

  for (int connect_attempt= 0; connect_attempt < 6; ++connect_attempt)
  {
    connect_result= lmysql->ldbms_mysql_real_connect(&mysql[connection_number],
                                                     ocelot_ca.host_as_utf8,
                                                     ocelot_ca.user_as_utf8,
                                                     ocelot_ca.password_as_utf8,
                                                     database_as_utf8,
                                                     ocelot_ca.port,
                                                     socket_parameter,
                                                     real_connect_flags);
     if (connect_result != NULL) break;
     /* See ocelot.ca blog post = Connecting to MySQL or MariaDB with sockets on Linux */
     /* Todo: you should provide info somewhere how the connection was actually done. */
     if ((ocelot_ca.protocol_as_int != 0) && (ocelot_ca.protocol_as_int != PROTOCOL_SOCKET)) break;
#ifdef _WIN32
     break;
#endif
     if ((ocelot_ca.unix_socket_as_utf8 != 0) && (strcmp(ocelot_ca.unix_socket_as_utf8, "") != 0)) break;
     if ((ocelot_ca.host_as_utf8 != 0) && (strcmp(ocelot_ca.host_as_utf8,"") != 0) && (strcmp(ocelot_ca.host_as_utf8, "localhost") != 0)) break;
     if (lmysql->ldbms_mysql_errno(&mysql[connection_number]) != 2002) break; /* 2002 == CR_CONNECTION_ERROR */
     if (connect_attempt == 0) socket_parameter= (char *) "/tmp/mysql.sock";
     if (connect_attempt == 1) socket_parameter= (char *) "/var/lib/mysql/mysql.sock";
     if (connect_attempt == 2) socket_parameter= (char *) "/var/run/mysqld/mysqld.sock";
     if (connect_attempt == 3) socket_parameter= (char *) "/var/run/mysql/mysql.sock";
     if (connect_attempt == 4) socket_parameter= (char *) "/tmp/mysqld.sock";
   }

  if (connect_result == NULL)
  {
    /* connect failed. todo: better diagnostics? anyway, user can retry, a dialog box will come up. */
    return -1;					// Retryable
  }

  /*
    Tell the server: characters from the client are UTF8, characters going to the client are UTF8.
    This partially overrides --default_character_set, except there's no change to character_set_connection.
    Todo: Eventually UTF8MB4 will be preferable but check server version before trying that.
    Todo: We could have an option to receive in UTF16 which is what Qt would prefer.
    Todo: We should warn or disallow if user tries to change these.
    Todo: Think what we're going to do with file I/O, e.g. the user might expect it to be ujis.
    Todo: This makes the server do conversions. Eventually the client could do the conversions but that's lots of work.
    Todo: Worry that there might be some way to start Qt with different character-set assumptions.
    Todo: Worry that we haven't got a plan for _latin2 'string' etc. although we could get the server to translate for us
  */
  if (lmysql->ldbms_mysql_query(&mysql[connection_number], "set character_set_client = utf8")) printf("SET character_set_client failed\n");
  if (lmysql->ldbms_mysql_query(&mysql[connection_number], "set character_set_results = utf8")) printf("SET character_set_results failed\n");

  connected[connection_number]= 1;
  return 0;
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

/*
  Convert string to long.
  For numeric connect-related tokens, K means 1024, M means 1024**2, G means 1024**3.
  Actually the token might be unsigned int or unsigned long, but this will do.
*/
long MainWindow::to_long(QString token)
{
  QString kmg;
  QString token_without_kmg;
  long return_value;

  kmg= token.right(1).toUpper();
  if ((kmg == "K") || (kmg == "M") || (kmg == "G"))
  {
    token_without_kmg= token.left(token.size() - 1);
    return_value= token_without_kmg.toLong();
    if (kmg == "K") return_value *= 1024;
    if (kmg == "M") return_value *= 1024 * 1024;
    if (kmg == "G") return_value *= 1024 * 1024 * 1024;
  }
  else return_value= token.toLong();
  return return_value;

}

/*
  called from: copy_connect_strings_to_utf8(), to initialize before making new copies
  called from: action_file_exit(), to avoid valgrind complaints
*/
void MainWindow::delete_utf8_copies()
{
  if (ocelot_ca.host_as_utf8 != 0) { delete [] ocelot_ca.host_as_utf8; ocelot_ca.host_as_utf8= 0; }
  if (ocelot_ca.database_as_utf8 != 0) { delete [] ocelot_ca.database_as_utf8; ocelot_ca.database_as_utf8= 0; }
  if (ocelot_ca.user_as_utf8 != 0) { delete [] ocelot_ca.user_as_utf8; ocelot_ca.user_as_utf8= 0; }
  if (ocelot_ca.password_as_utf8 != 0) { delete [] ocelot_ca.password_as_utf8; ocelot_ca.password_as_utf8= 0; }
  if (ocelot_ca.default_auth_as_utf8 != 0) { delete [] ocelot_ca.default_auth_as_utf8; ocelot_ca.default_auth_as_utf8= 0; }
  if (ocelot_ca.default_auth_as_utf8 != 0) { delete [] ocelot_ca.default_auth_as_utf8; ocelot_ca.default_auth_as_utf8= 0; }
  if (ocelot_ca.default_auth_as_utf8 != 0) { delete [] ocelot_ca.default_auth_as_utf8; ocelot_ca.default_auth_as_utf8= 0; }
  if (ocelot_ca.opt_bind_as_utf8 != 0) { delete [] ocelot_ca.opt_bind_as_utf8; ocelot_ca.opt_bind_as_utf8= 0; }
  if (ocelot_ca.opt_connect_attr_delete_as_utf8 != 0) { delete [] ocelot_ca.opt_connect_attr_delete_as_utf8; ocelot_ca.opt_connect_attr_delete_as_utf8= 0; }
  if (ocelot_ca.opt_ssl_as_utf8 != 0) { delete [] ocelot_ca.opt_ssl_as_utf8; ocelot_ca.opt_ssl_as_utf8= 0; }
  if (ocelot_ca.opt_ssl_ca_as_utf8 != 0) { delete [] ocelot_ca.opt_ssl_ca_as_utf8; ocelot_ca.opt_ssl_ca_as_utf8= 0; }
  if (ocelot_ca.opt_ssl_capath_as_utf8 != 0) { delete [] ocelot_ca.opt_ssl_capath_as_utf8; ocelot_ca.opt_ssl_capath_as_utf8= 0; }
  if (ocelot_ca.opt_ssl_cert_as_utf8 != 0) { delete [] ocelot_ca.opt_ssl_cert_as_utf8; ocelot_ca.opt_ssl_cert_as_utf8= 0; }
  if (ocelot_ca.opt_ssl_cipher_as_utf8 != 0) { delete [] ocelot_ca.opt_ssl_cipher_as_utf8; ocelot_ca.opt_ssl_cipher_as_utf8= 0; }
  if (ocelot_ca.opt_ssl_crl_as_utf8 != 0) { delete [] ocelot_ca.opt_ssl_crl_as_utf8; ocelot_ca.opt_ssl_crl_as_utf8= 0; }
  if (ocelot_ca.opt_ssl_crlpath_as_utf8 != 0) { delete [] ocelot_ca.opt_ssl_crlpath_as_utf8; ocelot_ca.opt_ssl_crlpath_as_utf8= 0; }
  if (ocelot_ca.opt_ssl_key_as_utf8 != 0) { delete [] ocelot_ca.opt_ssl_key_as_utf8; ocelot_ca.opt_ssl_key_as_utf8= 0; }
  if (ocelot_ca.opt_ssl_mode_as_utf8 != 0) { delete [] ocelot_ca.opt_ssl_mode_as_utf8; ocelot_ca.opt_ssl_mode_as_utf8= 0; }
  if (ocelot_ca.plugin_dir_as_utf8 != 0) { delete [] ocelot_ca.plugin_dir_as_utf8; ocelot_ca.plugin_dir_as_utf8= 0; }
  if (ocelot_ca.read_default_group_as_utf8 != 0) { delete [] ocelot_ca.read_default_group_as_utf8; ocelot_ca.read_default_group_as_utf8= 0; }
  if (ocelot_ca.read_default_file_as_utf8 != 0) { delete [] ocelot_ca.read_default_file_as_utf8; ocelot_ca.read_default_file_as_utf8= 0; }
  if (ocelot_ca.server_public_key_as_utf8 != 0) { delete [] ocelot_ca.server_public_key_as_utf8; ocelot_ca.server_public_key_as_utf8= 0; }
  if (ocelot_ca.unix_socket_as_utf8 != 0) { delete [] ocelot_ca.unix_socket_as_utf8; ocelot_ca.unix_socket_as_utf8= 0; }
  if (ocelot_ca.set_charset_dir_as_utf8 != 0) { delete [] ocelot_ca.set_charset_dir_as_utf8; ocelot_ca.set_charset_dir_as_utf8= 0; }
  if (ocelot_ca.set_charset_name_as_utf8 != 0) { delete [] ocelot_ca.set_charset_name_as_utf8; ocelot_ca.set_charset_name_as_utf8= 0; }
  if (ocelot_ca.shared_memory_base_name_as_utf8 != 0) { delete [] ocelot_ca.shared_memory_base_name_as_utf8; ocelot_ca.shared_memory_base_name_as_utf8= 0; }
}

/* Todo: check every one of the "new ..." results for failure. */
void MainWindow::copy_connect_strings_to_utf8()
{
  delete_utf8_copies();
  /* See comment "UTF8 Conversion" */

  int tmp_host_len= ocelot_host.toUtf8().size();
  ocelot_ca.host_as_utf8= new char[tmp_host_len + 1];
  memcpy(ocelot_ca.host_as_utf8, ocelot_host.toUtf8().constData(), tmp_host_len + 1);

  int tmp_database_len= ocelot_database.toUtf8().size();
  ocelot_ca.database_as_utf8= new char[tmp_database_len + 1];
  memcpy(ocelot_ca.database_as_utf8, ocelot_database.toUtf8().constData(), tmp_database_len + 1);

  int tmp_user_len= ocelot_user.toUtf8().size();
  ocelot_ca.user_as_utf8= new char[tmp_user_len + 1];
  memcpy(ocelot_ca.user_as_utf8, ocelot_user.toUtf8().constData(), tmp_user_len + 1);

  int tmp_password_len= ocelot_password.toUtf8().size();
  ocelot_ca.password_as_utf8= new char[tmp_password_len + 1];
  memcpy(ocelot_ca.password_as_utf8, ocelot_password.toUtf8().constData(), tmp_password_len + 1);

  int tmp_default_auth_len= ocelot_default_auth.toUtf8().size();
  ocelot_ca.default_auth_as_utf8= new char[tmp_default_auth_len + 1];
  memcpy(ocelot_ca.default_auth_as_utf8, ocelot_default_auth.toUtf8().constData(), tmp_default_auth_len + 1);

  int tmp_init_command_len= ocelot_init_command.toUtf8().size();
  ocelot_ca.init_command_as_utf8= new char[tmp_init_command_len + 1];
  memcpy(ocelot_ca.init_command_as_utf8, ocelot_init_command.toUtf8().constData(), tmp_init_command_len + 1);

  int tmp_opt_bind_len= ocelot_opt_bind.toUtf8().size();
  ocelot_ca.opt_bind_as_utf8= new char[tmp_opt_bind_len + 1];
  memcpy(ocelot_ca.opt_bind_as_utf8, ocelot_opt_bind.toUtf8().constData(), tmp_opt_bind_len + 1);

  int tmp_opt_connect_attr_delete_len= ocelot_opt_connect_attr_delete.toUtf8().size();
  ocelot_ca.opt_connect_attr_delete_as_utf8= new char[tmp_opt_connect_attr_delete_len + 1];
  memcpy(ocelot_ca.opt_connect_attr_delete_as_utf8, ocelot_opt_connect_attr_delete.toUtf8().constData(), tmp_opt_connect_attr_delete_len + 1);

  int tmp_opt_ssl_len= ocelot_opt_ssl.toUtf8().size();
  ocelot_ca.opt_ssl_as_utf8= new char[tmp_opt_ssl_len + 1];
  memcpy(ocelot_ca.opt_ssl_as_utf8, ocelot_opt_ssl.toUtf8().constData(), tmp_opt_ssl_len + 1);

  int tmp_opt_ssl_ca_len= ocelot_opt_ssl_ca.toUtf8().size();
  ocelot_ca.opt_ssl_ca_as_utf8= new char[tmp_opt_ssl_ca_len + 1];
  memcpy(ocelot_ca.opt_ssl_ca_as_utf8, ocelot_opt_ssl_ca.toUtf8().constData(), tmp_opt_ssl_ca_len + 1);

  int tmp_opt_ssl_capath_len= ocelot_opt_ssl_capath.toUtf8().size();
  ocelot_ca.opt_ssl_capath_as_utf8= new char[tmp_opt_ssl_capath_len + 1];
  memcpy(ocelot_ca.opt_ssl_capath_as_utf8, ocelot_opt_ssl_capath.toUtf8().constData(), tmp_opt_ssl_capath_len + 1);

  int tmp_opt_ssl_cert_len= ocelot_opt_ssl_cert.toUtf8().size();
  ocelot_ca.opt_ssl_cert_as_utf8= new char[tmp_opt_ssl_cert_len + 1];
  memcpy(ocelot_ca.opt_ssl_cert_as_utf8, ocelot_opt_ssl_cert.toUtf8().constData(), tmp_opt_ssl_cert_len + 1);

  int tmp_opt_ssl_cipher_len= ocelot_opt_ssl_cipher.toUtf8().size();
  ocelot_ca.opt_ssl_cipher_as_utf8= new char[tmp_opt_ssl_cipher_len + 1];
  memcpy(ocelot_ca.opt_ssl_cipher_as_utf8, ocelot_opt_ssl_cipher.toUtf8().constData(), tmp_opt_ssl_cipher_len + 1);

  int tmp_opt_ssl_crl_len= ocelot_opt_ssl_crl.toUtf8().size();
  ocelot_ca.opt_ssl_crl_as_utf8= new char[tmp_opt_ssl_crl_len + 1];
  memcpy(ocelot_ca.opt_ssl_crl_as_utf8, ocelot_opt_ssl_crl.toUtf8().constData(), tmp_opt_ssl_crl_len + 1);

  int tmp_opt_ssl_crlpath_len= ocelot_opt_ssl_crlpath.toUtf8().size();
  ocelot_ca.opt_ssl_crlpath_as_utf8= new char[tmp_opt_ssl_crlpath_len + 1];
  memcpy(ocelot_ca.opt_ssl_crlpath_as_utf8, ocelot_opt_ssl_crlpath.toUtf8().constData(), tmp_opt_ssl_crlpath_len + 1);

  int tmp_opt_ssl_key_len= ocelot_opt_ssl_key.toUtf8().size();
  ocelot_ca.opt_ssl_key_as_utf8= new char[tmp_opt_ssl_key_len + 1];
  memcpy(ocelot_ca.opt_ssl_key_as_utf8, ocelot_opt_ssl_key.toUtf8().constData(), tmp_opt_ssl_key_len + 1);

  int tmp_opt_ssl_mode_len= ocelot_opt_ssl_mode.toUtf8().size();
  ocelot_ca.opt_ssl_mode_as_utf8= new char[tmp_opt_ssl_mode_len + 1];
  memcpy(ocelot_ca.opt_ssl_mode_as_utf8, ocelot_opt_ssl_mode.toUtf8().constData(), tmp_opt_ssl_mode_len + 1);

  int tmp_plugin_dir_len= ocelot_plugin_dir.toUtf8().size();
  ocelot_ca.plugin_dir_as_utf8= new char[tmp_plugin_dir_len + 1];
  memcpy(ocelot_ca.plugin_dir_as_utf8, ocelot_plugin_dir.toUtf8().constData(), tmp_plugin_dir_len + 1);

  int tmp_read_default_file_len= ocelot_read_default_file.toUtf8().size();
  ocelot_ca.read_default_file_as_utf8= new char[tmp_read_default_file_len + 1];
  memcpy(ocelot_ca.read_default_file_as_utf8, ocelot_read_default_file.toUtf8().constData(), tmp_read_default_file_len + 1);

  int tmp_read_default_group_len= ocelot_read_default_group.toUtf8().size();
  ocelot_ca.read_default_group_as_utf8= new char[tmp_read_default_group_len + 1];
  memcpy(ocelot_ca.read_default_group_as_utf8, ocelot_read_default_group.toUtf8().constData(), tmp_read_default_group_len + 1);

  int tmp_server_public_key_len= ocelot_server_public_key.toUtf8().size();
  ocelot_ca.server_public_key_as_utf8= new char[tmp_server_public_key_len + 1];
  memcpy(ocelot_ca.server_public_key_as_utf8, ocelot_server_public_key.toUtf8().constData(), tmp_server_public_key_len + 1);

  int tmp_unix_socket_len= ocelot_unix_socket.toUtf8().size();
  ocelot_ca.unix_socket_as_utf8= new char[tmp_unix_socket_len + 1];
  memcpy(ocelot_ca.unix_socket_as_utf8, ocelot_unix_socket.toUtf8().constData(), tmp_unix_socket_len + 1);

  int tmp_set_charset_dir_len= ocelot_set_charset_dir.toUtf8().size();
  ocelot_ca.set_charset_dir_as_utf8= new char[tmp_set_charset_dir_len + 1];
  memcpy(ocelot_ca.set_charset_dir_as_utf8, ocelot_set_charset_dir.toUtf8().constData(), tmp_set_charset_dir_len + 1);

  int tmp_set_charset_name_len= ocelot_set_charset_name.toUtf8().size();
  ocelot_ca.set_charset_name_as_utf8= new char[tmp_set_charset_name_len + 1];
  memcpy(ocelot_ca.set_charset_name_as_utf8, ocelot_set_charset_name.toUtf8().constData(), tmp_set_charset_name_len + 1);

  int tmp_shared_memory_base_name_len= ocelot_shared_memory_base_name.toUtf8().size();
  ocelot_ca.shared_memory_base_name_as_utf8= new char[tmp_shared_memory_base_name_len + 1];
  memcpy(ocelot_ca.shared_memory_base_name_as_utf8, ocelot_shared_memory_base_name.toUtf8().constData(), tmp_shared_memory_base_name_len + 1);
}

#if (OCELOT_MYSQL_INCLUDE == 1)
int MainWindow::the_connect(unsigned int connection_number)
{
  int x;

  /* options_and_connect() cannot use QStrings because it is not in MainWindow */
  copy_connect_strings_to_utf8();
  x= options_and_connect(connection_number, ocelot_ca.database_as_utf8);
  return x;
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

/*
  We should do this after any successful connection
  Todo: Check that we're not calling this twice. There are too many connect routines.
  Todo: I'm guessing that somewhere in the connection we specified a database option, or it isn't necessary.
        If I'm wrong then I guess rehash_scan() will fail which is no big deal.
  Todo: Everything that we enable when connection_number == 0 should be disabled when we disconnect.
*/
void MainWindow::connect_init(int connection_number)
{
  connections_is_connected[connection_number]= 1;
  if (connection_number == 0)
  {
    QMenu* menu_file_export= menu_spec_find_menu("menu_export");
    if (menu_file_export != NULL) menu_file_export->setEnabled(true);
    if (ocelot_ca.auto_rehash != 0)
    {
      char error_or_ok_message[ER_MAX_LENGTH];
      rehash_scan(error_or_ok_message, ""); /* Todo: should we display the error/ok message that rehash_scan() produces? */
    }
  }
}

/*
  For telling the user version info of ocelotgui itself,
  and of whatever it's connected to.
  Called by action_help_about(), print_version().
  qVersion() is Qt runtime, maybe != QT_VERSION_STR
  For action_help_about() we go further and try to say what we're connected
  to, but for --version, we aren't connecting so such info wouldn't be
  available.
*/
QString MainWindow::get_version()
{
  QString s;
  s = "\n\nocelotgui version ";
  s.append(ocelotgui_version);
#ifdef OCELOT_OS_LINUX
  s.append(", for Linux");
#endif
#ifdef OCELOT_OS_NONLINUX
#ifdef OCELOT_OS_FREEBSD
  s.append(", for FreeBSD");
#else
  s.append(", for Windows");
#endif
#endif
#if __x86_64__
  s.append(" (x86_64)");
#endif
  s.append(" using Qt version ");
  s.append(qVersion());
  s.append("\n");
  return s;
}

/* --version, or version in an option file, causes version display and exit */
void MainWindow::print_version()
{
  QString QStr= get_version();
  int tmp_len= QStr.toUtf8().size();
  char *tmp= new char[tmp_len + 1];
  memcpy(tmp, QStr.toUtf8().constData(), tmp_len + 1);
  printf("%s", tmp);
  delete []tmp;
  return;
}

/* --help, or help in an option file, causes help display and exit */
void MainWindow::print_help()
{
  char output_string[5120];

  print_version();
  printf("Copyright (c) 2024 by Peter Gulutzan and others\n");
  printf("\n");
  printf("Usage: ocelotgui [OPTIONS] [database]\n");
  printf("Options files that were actually read:\n");
  strcpy(output_string, options_files_read.toUtf8());
  printf("%s\n", output_string);
  {
    printf("Options files groups that ocelotgui looks for (changeable depending on user choices):");
    QStringList qs= my_cnf_groups_list();
    char tmp_group[256];
    for (int i= 0; i < qs.size(); ++i) {strcpy(tmp_group, qs.at(i).toUtf8()); printf(" %s", tmp_group); }
    printf("\n");
  }
  print_defaults();
}

/* --print_defaults */
void MainWindow::print_defaults()
{
  printf("Possible option values: same as possible option values for mysql client\n");
  printf("Option values after reading options files and command-line arguments:\n");
  printf("Option                            Value\n");
  printf("--------------------------------- ----------------------------------------\n");
  action_file_connect_once("Print");
}

#if (OCELOT_MYSQL_DEBUGGER == 1)

QStringList debug_routine_list_schemas;
QStringList debug_routine_list_names;
QStringList debug_routine_list_types;
QStringList debug_routine_list_sql_modes;
QStringList debug_routine_list_surrogates;
QStringList debug_routine_list_texts;
int debug_v_statement_number; /* the number for all routines */
QString debug_xxxmdbug_icc_core_surrogate_name;
#endif
QStringList c_variable_names;  /* (declared) in reverse order */
QStringList c_variable_tokens; /* (declared) in reverse order */
#if (OCELOT_MYSQL_DEBUGGER == 1)
QStringList debug_tmp_user_variables;
QString debug_v_g;
QString debug_xxxmdbug_debugger_name;
QString debug_xxxmdbug_debugger_version;
int debug_xxxmdbug_signal_errno;
QString debug_xxxmdbug_timestamp;
QString debug_xxxmdbug_setup_group_name;
#endif
int i_of_start_of_parameters, i_of_end_of_parameters;
#if (OCELOT_MYSQL_DEBUGGER == 1)
QStringList debug_label_list;
QString debug_xxxmdbug_default_schema;
int debug_track_statements;
int debug_track_user_variables;
int debug_track_declared_variables;
#endif
bool debug_ansi_quotes;
#if (OCELOT_MYSQL_DEBUGGER == 1)
QString debug_lf;
QString debug_plugins;
QString debug_session_sql_mode_original;
QString debug_session_sql_mode_after_last_change;
int debug_routine_list_size;
bool is_plsql;

/*
  When NEW_SETUP == 1, which is default since May 2018,
  we handle $setup from new code in ocelotgui.cpp due to the
  changes in MySQL 8.0. Except for debug_setup_go, all the new
  routines begin with "setup_".
  All setup_* functions, on error, should call debug_error() and return <> 0.
*/

#if (NEW_SETUP == 1)
/*
  We expect hparse to catch syntax errors so checks here are minimal.
*/
/* The 'track' switches exist so that one can reduce the amount of instrumenting,
   for space or speed reasons.
   @xxxmdbug_track_statements:            0=none, 1=base set, 2=+iterate/leave/set. default: 2.
   @xxxmdbug_track_user_variables:        0=none, 1=in same routine, 2=all (todo: allow 2). default=1.
   @xxxmdbug_track_declared_variables     0=none, 1=since last declare, 2=all. default: 2.
   Future switch: overwrite
   We are parsing these switches, but they are undocumented.
*/
/*
  Todo: New syntax: $SETUP ... [procedure|function|trigger|event] name.
                    and LIKE | = 'name'
  Todo: Are you sure $setup is starting at 0??
  Todo: Are you okay if there's a delimiter?
  Todo: I do case-insensitive comparisons. That's always okay for
        routine | declared variable | event, but not if
        @@lower_case_table_names == 0 and database | trigger | table.
*/
/*
  Todo: get_lock('xxxmdbug_lock') -- but in the past this has failed.
        Anyway conflict is unlikely unless two users get the same
        group name.
  Todo: I don't think locking is necessary. But check at the end, or
        even at $debug time, whether all routines are current.
        That is: did anyone change or drop a routine that's in the log?
                 or change our access rights to the surrogate routines?
        If so, $setup is probably invalid, return "failed".
  Todo: debug_privilege_check() should include whether we can read the
        information_schema.routines table for MySQL 8.0, but if we can't
        then that will be clear because setting up routine lists fails.
*/
void MainWindow::debug_setup_go(QString text)
{
  if (ocelot_statement_syntax_checker.toInt() < 1)
  {
    debug_error((char*)"Before running $setup you must say 'set ocelot_statement_syntax_checker=1;' or 'set ocelot_statement_syntax_checker=3;'");
    return;
  }
  if (hparse_errno != 0)
  {
    char copy_of_hparse_errmsg[1024];
    strcpy(copy_of_hparse_errmsg, "$setup cannot proceed due to syntax error: ");
    strcat(copy_of_hparse_errmsg, hparse_errmsg);
    debug_error((char*)copy_of_hparse_errmsg);
    return;
  }
  if (setup_initialize_variables()) return;
  /* parse the switches */
  debug_track_statements= 2;                        /* default */
  debug_track_user_variables= 1;                    /* default */
  debug_track_declared_variables= 2;                /* default */
  QString switch_name= "";
  bool is_switch= false;

  int last_token= main_token_number + main_token_count_in_statement;
  for (int i= main_token_number;
       ((i < last_token) && (main_token_lengths[i] != 0));
       ++i)
  {
    QString s= text.mid(main_token_offsets[i], main_token_lengths[i]);
    if (s == "-")
    {
      is_switch= true;
      continue;
    }
    if ((hparse_f_is_identifier(main_token_types[i]) == true) && (is_switch))
    {
      switch_name= s;
      continue;
    }
    if (is_switch)
    {
      if ((main_token_types[i] == TOKEN_TYPE_LITERAL_WITH_DIGIT)
       || (main_token_types[i] == TOKEN_TYPE_LITERAL))
      {
        QString p= switch_name.toUpper();
        int j= s.toInt();
        if (p == "TRACK_STATEMENTS") debug_track_statements= j;
        else if (p == "TRACK_USER_VARIABLES") debug_track_user_variables= j;
        else if (p == "TRACK_DECLARED_VARIABLES") debug_track_declared_variables= j;
        is_switch= false;
      }
    }
  }

  QString qstring_error_message;
  //QString command_string;
  /* Todo: use debug_error instead, provided debug_error gets rid of any problematic ''s */
  qstring_error_message= debug_privilege_check(TOKEN_KEYWORD_DEBUG_SETUP);
  if (qstring_error_message != "")
  {
    char command_string[512];
    strcpy(command_string, qstring_error_message.toUtf8());
    if (debug_error(command_string) != 0) return; /* setup wouldn't be able to operate so fail */
  }
  int r= setup_internal(text);
  if (r == 1)
  {
    setup_cleanup();
    /* I assume debug_error() has set up a good error message. */
    return;
  }
  /* Todo: Return how many routines you found. */

  /* Repetition of some code in put_diagnostics_in_result */
  char elapsed_time_string[50];
  {
    qint64 statement_end_time= QDateTime::currentMSecsSinceEpoch();
    qint64 elapsed_time= statement_end_time - statement_edit_widget->start_time;
    long int elapsed_time_as_long_int= (long int) elapsed_time;
    float elapsed_time_as_float= (float) elapsed_time_as_long_int / 1000;
    sprintf(elapsed_time_string, " (%.1f seconds)", elapsed_time_as_float);
  }
  QString s1= QString("OK ");
  s1.append(QString::number(debug_routine_list_size));
  s1.append(" surrogate routines. ");
  s1.append(elapsed_time_string);
  statement_edit_widget->result= s1;
  setup_cleanup();
  return;
}
#endif // if (NEW_SETUP == 1)


/*
  $setup should call this wrapper when it needs mysql_real_query(),
  so that if there is a failure it can find it, prefix it with the
  error_prefix string, put it in the result, and erturn 1.
  We also put it in the log what the query was, with a low number.
  Todo: Error strings should be in ostrings.h.
*/
int MainWindow::setup_mysql_real_query(char *statement,
                                             char *error_prefix)
{
  int statement_len= strlen(statement);
  if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], statement, statement_len))
  {
    QString e= error_prefix;
    char debuggee_state_error[STRING_LENGTH_512];
    strncpy(debuggee_state_error, lmysql->ldbms_mysql_error(&mysql[MYSQL_MAIN_CONNECTION]), STRING_LENGTH_512 - 1);
    e= e + debuggee_state_error;
    put_message_in_result(e);
    log(error_prefix, 60);
    log(statement, 60);
    return 1;
  }
  return 0;
}

/*
  Make the routine_list_* QStringlists from the $SETUP arguments.
  Todo: This won't work for names that contain 's.
  Exclude if:
  * Language <> 'SQL'
    That's mysql.proc.language, an approximation is external_language.
    This might be important if external languages become okay.
    But it won't help with MariaDB, PL/SQL doesn't seem to be flagged.
    In MySQL expect 'SQL', in MariaDB expect NULL.
  * % wildcard for schema, and system database
    That is, mysql, information_schema, performance_schema, xxxmdbug.
  * % wildcard for name, and name like 'xxxmdbug___%'
    Quis custodiet ipsos debuggeros?
*/
/*
  We use COLLATE utf8_general_ci clauses in some comparisons, to avoid
  incompatible-mix-of-collations errors due to a MySQL 8.0 change.
  In MySQL 8.0: routine_catalog and routine_schema are utf8_tolower_ci,
  routine_name is utf8_general_ci. In earlier versions and in
  MariaDB 10.3: they are all utf8_general_ci.
*/
/* Todo:
   Ignore routines whose surrogate names would be too long.
   Todo: put a notice in setup_log.
   IF LENGTH(mysql_proc_name)+LENGTH('xxxmdbugxxxP')>64 THEN ITERATE x1; END IF;
*/
/*
  Todo: DEBUG_TAB_WIDGET_MAX is a maximum caused by our desire not to
  have too many tabs when $debug happens. But you could try to fix that
  some other way, e.g. allow users to change the maximum, or dynamically
  shift tabs in and out from the front on a last-seen basis.
*/

int MainWindow::setup_routine_list(QString text)
{
  debug_routine_list_schemas.clear();
  debug_routine_list_names.clear();
  debug_routine_list_types.clear();
  debug_routine_list_sql_modes.clear();
  debug_routine_list_surrogates.clear();
  debug_routine_list_texts.clear();
  debug_tmp_user_variables.clear();
  debug_routine_list_size= 0;
  QString s;
  QString token;
  QString schema_name= debug_xxxmdbug_default_schema;
  QString routine_name= "";
  char select_statement[2048];
  int i;
  for (i= 0; main_token_lengths[i] != 0; ++i)
  {
    if (hparse_f_is_identifier(main_token_types[i]) == true)
    {
      token= text.mid(main_token_offsets[i], main_token_lengths[i]);
      if (main_token_reftypes[i] == TOKEN_REFTYPE_DATABASE)
      {
        schema_name= token.replace("_", "\\_");
      }
      else if (main_token_reftypes[i] == TOKEN_REFTYPE_SWITCH_NAME) {;}
      else
      {
        routine_name= token.replace("_", "\\_"); /* _ is a wildcard so escape it */
        s= "SELECT routine_schema,routine_name,routine_type,sql_mode " ;
        s= s + "FROM information_schema.routines WHERE ";
        s= s + "routine_schema COLLATE utf8_general_ci LIKE '" + connect_stripper(schema_name, false) + "' ";
        s= s + "AND routine_name LIKE '" + connect_stripper(routine_name, false) + "'";
        s= s + " AND (external_language IS NULL OR external_language='SQL')";
        if (schema_name.contains("%"))
        {
          s= s + " AND routine_schema COLLATE utf8_general_ci <> 'information_schema'"
               + " AND routine_schema COLLATE utf8_general_ci <> 'performance_schema'"
               + " AND routine_schema COLLATE utf8_general_ci <> 'mysql'"
               + " AND routine_schema COLLATE utf8_general_ci <> 'xxxmdbug'";
        }
        if (routine_name.contains("%"))
        {
          s= s + " AND routine_name NOT LIKE 'xxxmdbug___%'";
        }
        s= s + ";";
        strcpy(select_statement, s.toUtf8());
        MYSQL_RES *res= NULL;
        MYSQL_ROW row= NULL;
        if (setup_mysql_real_query(select_statement,
                                   (char*)"FAILED. Cannot make a list of routines. ") == 1)
          return 1;
        res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
        if (res == NULL)
        {
          debug_error((char*)"mysql_store_result -- FAILED. Cannot make a list of routines.");
          return 1;
        }
        int counter= 0;
        {
          for (;;)
          {
            row= lmysql->ldbms_mysql_fetch_row(res);
            if (row == NULL) break;
            /* TODO: connect_stripper()? */
            QString t_schema= QString::fromUtf8(row[0]);
            QString t_name= QString::fromUtf8(row[1]);
            QString t_type= QString::fromUtf8(row[2]);
            QString t_sql_mode= QString::fromUtf8(row[3]);
            int name_offset= setup_find(t_schema, t_name);
            if (name_offset >= 0)
            {
              if (debug_routine_list_types.at(name_offset) != t_type)
              {
                debug_error((char*)"Two routines have the same name but different types");
                if (res != NULL) lmysql->ldbms_mysql_free_result(res);
                return 1;
              }
              continue; /* ignore duplicates of the same type */
            }
            /* Todo: Check you don't make the name too long */
            debug_routine_list_schemas << t_schema;
            debug_routine_list_names << t_name;
            debug_routine_list_types << t_type;
            debug_routine_list_sql_modes << t_sql_mode;
            QString v_routine_identifier_of_surrogate;
            v_routine_identifier_of_surrogate= "xxxmdbug"
                    + debug_xxxmdbug_setup_group_name
                    + t_type.mid(0,1)
                    + connect_stripper(t_name, false);
            debug_routine_list_surrogates << v_routine_identifier_of_surrogate;
            ++counter;
          }
        }
        if (res != NULL) lmysql->ldbms_mysql_free_result(res);
        if (counter == 0)
        {
          char c_schema_name[256];
          strcpy(c_schema_name, schema_name.toUtf8());
          char c_routine_name[256];
          strcpy(c_routine_name, routine_name.toUtf8());
          char q[512];
          strcpy(q, "FAILED. Could not find routine ");
          strcat(q, c_schema_name);
          strcat(q, ".");
          strcat(q, c_routine_name);
          debug_error(q);
          return 1;
        }
        schema_name= debug_xxxmdbug_default_schema;
      }
    }
  }
  debug_routine_list_size= debug_routine_list_names.count();
  if (debug_routine_list_size > DEBUG_TAB_WIDGET_MAX)
  {
    char q[256];
    sprintf(q, "Error: Number of routines = %d. The maximum number of routines in a single $setup is %d", debug_routine_list_size, DEBUG_TAB_WIDGET_MAX);
    debug_error((char*)q);
    return 1;
  }
  return 0;
}

/*
  Pass: schema+name.
  Return: offset of schema+name (both must match) in QStringLists.
          or -1 if not found.
  This is an odd case where "return 1" does not mean "error".
  Todo: test with delimited names.
*/
int MainWindow::setup_find(QString t_schema, QString t_name)
{
  int i= 0;
  for (; i < debug_routine_list_schemas.count(); ++i)
  {
    if (QString::compare(debug_routine_list_names.at(i), t_name, Qt::CaseInsensitive) == 0)
    {
      if (QString::compare(debug_routine_list_schemas.at(i), t_schema, Qt::CaseInsensitive) == 0)
        return i;
    }
  }
  return -1;
}

/*
  Generate the surrogate for one routine, specified by routine_number.
  Todo: Make sure that any global checks/setups come before this.
*/
/*
   Todo: see if this is happening ...
   Reset tokens+variables+statements tables for each routine.
   One effect is that @user_variables are only tracked in routines where
   they are mentioned, and we might want to change that if a non-default
   setup switch value is used i.e. track_user_variables=2.
*/

int MainWindow::setup_generate(int routine_number)
{
  log("setup_generate", 15);
  debug_label_list.clear();
  if (debug_track_user_variables == 1) debug_tmp_user_variables.clear();
  QString s;
  bool pushed_sql_mode_ansi_quotes;
  bool pushed_hparse_sql_mode_ansi_quotes;
  QString routine_schema= debug_routine_list_schemas.at(routine_number);
  QString routine_name= debug_routine_list_names.at(routine_number);
  QString routine_type= debug_routine_list_types.at(routine_number);
  QString routine_sql_mode= debug_routine_list_sql_modes.at(routine_number);
  QString routine_surrogate= debug_routine_list_surrogates.at(routine_number);

  /* Todo: Put the names inside ``s. */
  /* Todo: check: what if there are nulls, will select_1_row() fail? */
  {
    char select_1_row_arg[1024];
    strcpy(select_1_row_arg, "SHOW CREATE ");
    strcat(select_1_row_arg, routine_type.toUtf8());
    strcat(select_1_row_arg, " `");
    strcat(select_1_row_arg, routine_schema.toUtf8());
    strcat(select_1_row_arg,"`.`");
    strcat(select_1_row_arg, routine_name.toUtf8());
    strcat(select_1_row_arg,"`;");
    s= select_1_row(select_1_row_arg);
    if (s != "")
    {
      strcat(select_1_row_arg, "-- FAILED so cannot generate surrogates");
      debug_error((char*)select_1_row_arg);
      return 1;
    }
  }
  /* Now select_1_row_result_3 has the procedure text. */
  /* Todo: this duplicates stuff in action_settings_statement_edit_widget_text_changed */
  debug_v_g= "";
  QString text;
  int i;
  QString mysql_proc_db= routine_schema;
  QString p_routine_identifier= routine_name;
  bool is_schema_seen= false;

  /* NB: after this push do not "return 1" without popping */
  main_token_push();
  pushed_sql_mode_ansi_quotes= sql_mode_ansi_quotes;
  pushed_hparse_sql_mode_ansi_quotes= hparse_sql_mode_ansi_quotes;

  if (routine_sql_mode.contains("ANSI_QUOTES",Qt::CaseInsensitive))
  {
    debug_ansi_quotes= true;
  }
  else
  {
    debug_ansi_quotes= false;
  }
  hparse_sql_mode_ansi_quotes= debug_ansi_quotes;

  /* Todo: There's no need to copy, we could use select_1_row_result_3 */
  text= select_1_row_result_3;
  /* SHOW CREATE doesn't show ; but maybe I can't depend on that. */
  if (text.right(1) != ";") text= text + ";";

  main_token_new(text.size());
  tokenize(text.data(),
           text.size(),
           main_token_lengths, main_token_offsets, main_token_max_count,
           (QChar*)"33333", 1, ocelot_delimiter_str, 1);
  tokens_to_keywords(text, 0, sql_mode_ansi_quotes);

  if (routine_sql_mode.contains("ORACLE",Qt::CaseInsensitive)) is_plsql= true;
  else is_plsql= false;

  /*
    Workaround for a bug in MariaDB 10.3 / PLSQL.
    If, before IS|AS|RETURN, you see (): remove () and try again.
  */
  if (is_plsql)
  {
    bool bug= false;
    int offset1;
    int offset2;
    int i;
    for (i= 0; main_token_lengths[i] != 0; ++i)
    {
      int token_type= main_token_types[i];
      if ((token_type == TOKEN_KEYWORD_IS)
       || (token_type == TOKEN_KEYWORD_AS)
       || (token_type == TOKEN_KEYWORD_BEGIN)
       || (token_type == TOKEN_KEYWORD_RETURN))
        break;
    }
    for (int j= 0; j < i; ++j)
    {
      offset1= main_token_offsets[j];
      offset2= main_token_offsets[j + 1];
      QString token1= text.mid(offset1, main_token_lengths[j]);
      QString token2= text.mid(offset2, main_token_lengths[j + 1]);
      if ((token1 == "(") && (token2 == ")")) bug= true;
    }
    if (bug)
    {
      QString text_before_parentheses= text.mid(0, offset1 - 1);
      QString text_after_parentheses= text.mid(offset2 - 1);
      text= text_before_parentheses + "  " + text_after_parentheses;
      tokenize(text.data(),
               text.size(),
               main_token_lengths, main_token_offsets, main_token_max_count,
               (QChar*)"33333", 1, ocelot_delimiter_str, 1);
      tokens_to_keywords(text, 0, sql_mode_ansi_quotes);
    }
  }

  hparse_f_multi_block(text); /* recognizer */
  /* Todo: We only check hparse_errno. hparse_errno_count maybe > 0. */
  if (hparse_errno != 0)
  {
    debug_error((char*)"ocelotgui failed to parse the routine body");
    goto pop_and_return_error;
  }
  /* Successful parse. Now we can start the fiddling. */
  i= 0;

  /* Copy CREATE DEFINER ... PROCEDURE|FUNCTION name, maybe add schema */
  for (; main_token_lengths[i] != 0; ++i)
  {
    QString d= text.mid(main_token_offsets[i], main_token_lengths[i]);
    if (main_token_reftypes[i] == TOKEN_REFTYPE_DATABASE) is_schema_seen= true;
    if ((main_token_reftypes[i] == TOKEN_REFTYPE_PROCEDURE)
     || (main_token_reftypes[i] == TOKEN_REFTYPE_FUNCTION))
    {
      if (is_schema_seen == false) debug_v_g= debug_v_g + routine_schema + ".";
      if (setup_append(routine_surrogate, text, i)) goto pop_and_return_error;
      break;
    }
    else if (setup_append(d, text, i)) goto pop_and_return_error;
  }
  ++i;
  /* Todo: error if main_token_lengths[i] == 0 */
  /* Todo: call find_start_of_body() to find where routine really starts? */
  /* TODO: Assumption is wrong,
     CREATE TRIGGER or CREATE EVENT do not have parameter lists. */
  /* Assume always there is (parameter list). Where does it end? */
  {
    int parentheses_count= 0;
    bool is_parenthesis_seen= false;
    QString token;
    int j;
    for (j= i; main_token_lengths[j] != 0; ++j)
    { 
      if (is_plsql)
      {
        if ((main_token_types[j] == TOKEN_KEYWORD_AS)
         || (main_token_types[j] == TOKEN_KEYWORD_IS))
          break;
      }
      if (main_token_types[j] == TOKEN_TYPE_OPERATOR)
      {
        token= text.mid(main_token_offsets[j], main_token_lengths[j]);
        if (token == "(")
        {
          if (is_parenthesis_seen == false) i_of_start_of_parameters= j + 1;
          ++parentheses_count;
          is_parenthesis_seen= true;
        }
        if (token == ")")
        {
          --parentheses_count;
          if (parentheses_count == 0) break;
        }
      }
    }
    i_of_end_of_parameters= j;
  }
  if (setup_insert_into_variables_user_variables(text, i_of_end_of_parameters) == 1) return 1;
  /* Skip past the parameter list. */
  /* In fact skip all the way till the first real statement appears. */
  {
    int i_of_statement;
    for (i_of_statement= i_of_end_of_parameters;
         (main_token_flags[i_of_statement] & TOKEN_FLAG_IS_START_STATEMENT) == 0;
         ++i_of_statement)
    {
      if (main_token_lengths[i_of_statement] == 0)
      {
        debug_error((char*)"found no statements"); /* pseudo-assertion */
        goto pop_and_return_error;
      }
    }

    int j= main_token_offsets[i];
    QString d= text.mid(j, main_token_offsets[i_of_statement] - j);
    if (setup_append(d, text, i)) goto pop_and_return_error;
    i= i_of_statement;
  }

  if (setup_generate_starter(mysql_proc_db,
                         p_routine_identifier,
                         routine_type,
                         text)) goto pop_and_return_error;
  if (setup_generate_statements(i,
                            text,
                            routine_number)) goto pop_and_return_error;
  setup_generate_ender();
  /* Now you have a new CREATE statement in debug_v_g for a surrogate. */
  debug_routine_list_texts << debug_v_g;
  main_token_pop();
  sql_mode_ansi_quotes= pushed_sql_mode_ansi_quotes;
  hparse_sql_mode_ansi_quotes= pushed_hparse_sql_mode_ansi_quotes;
  return 0;
pop_and_return_error:
  main_token_pop();
  sql_mode_ansi_quotes= pushed_sql_mode_ansi_quotes;
  hparse_sql_mode_ansi_quotes= pushed_hparse_sql_mode_ansi_quotes;
  return 1;
}

int MainWindow::setup_append(QString d, QString text, int i)
{
  debug_v_g.append(d);
  int j= main_token_offsets[i] + main_token_lengths[i];
  assert(main_token_offsets[i + 1] >= j);
  debug_v_g.append(text.mid(j, main_token_offsets[i + 1] - j));
  return 0;
}

/* called from generate_starter().
   Job: make a string from the variables table.
   For example: '2,a. int;13,b. int;'
   Todo: don't need to start at 0, could start after routine name.
   Todo: This should be useful when creating the variables table.
   Todo: Actually the variables table can include @variables!
         Data type will not be known.
   Todo: You have to get the WHOLE data type, but replace 's in ENUM
         or SET with ''s.
   Todo: No idea how to handle MariaDB 10's ROW TYPE OF.
*/
int MainWindow::setup_generate_routine_entry_parameter(QString text)
{
  int v_token_number_of_declare= 0;
  QString v_variable_identifier;
  QString v_data_type;
  int i;
  for (i= 0; main_token_lengths[i] != 0; ++i)
  {
    if (main_token_types[i] == TOKEN_KEYWORD_DECLARE)
    {
      v_token_number_of_declare= i - i_of_start_of_parameters;
    }
    if ((main_token_reftypes[i] == TOKEN_REFTYPE_VARIABLE_DEFINE)
     || (main_token_reftypes[i] == TOKEN_REFTYPE_PARAMETER_DEFINE))
    {
      if (setup_row_type(i) == TOKEN_KEYWORD_ROW) continue;
      v_variable_identifier= text.mid(main_token_offsets[i], main_token_lengths[i]);
      v_data_type= "";
      for (int j= i + 1; main_token_lengths[j] != 0; ++j)
      {
        /* Todo: Add error check: no data type, or unknown data type */
        if ((main_token_flags[j] & TOKEN_FLAG_IS_DATA_TYPE) != 0)
        {
          v_data_type= "";
          int parentheses_count= 0;
          for (int k= j; main_token_lengths[k] != 0; ++k)
          {
            QString s= text.mid(main_token_offsets[k], main_token_lengths[k]);
            if (s == "(") ++parentheses_count;
            if (s == ")")
            {
              --parentheses_count;
              if (parentheses_count < 0) break;
            }
            if (parentheses_count == 0)
            {
              if ((s == ";")
               || (s == ",")
               || (QString::compare(s, "DEFAULT", Qt::CaseInsensitive) == 0))
                break;
            }
            if (v_data_type != "") v_data_type= v_data_type + " ";
            if (s.mid(0,1) == "'") s= "'" + s + "'";
            v_data_type= v_data_type + s;
          }
          break;
        }
      }
      debug_v_g= debug_v_g
              + QString::number(v_token_number_of_declare)
              + "*"
              + setup_add_delimiters(v_variable_identifier)
              + "*"
              + v_data_type
              + ";";
    }
  }
  return 0;
}

int MainWindow::setup_generate_starter(QString mysql_proc_db,
                                        QString p_routine_identifier,
                                        QString mysql_proc_type,
                                        QString text)
{
  QString debug_v_generated_time= debug_xxxmdbug_timestamp;
  /* We will use the contents of xxxmdbug_comment to find surrogates, or to check version number. So do not change here! */
  if (is_plsql)
  {
    debug_v_g= debug_v_g + "xxxmdbug_5678 EXCEPTION;" + debug_lf;
  }
  else
  {
    debug_v_g= debug_v_g + debug_lf + "BEGIN ";
    debug_v_g= debug_v_g + debug_lf + "DECLARE ";
  }
  debug_v_g= debug_v_g + "xxxmdbug_comment VARCHAR(1000) DEFAULT";
  debug_v_g= debug_v_g + debug_lf + "'Surrogate routine for `" + mysql_proc_db + "`.`" + p_routine_identifier + "`";
  debug_v_g= debug_v_g + debug_lf + "Generated by " + debug_xxxmdbug_debugger_name + " Version " + debug_xxxmdbug_debugger_version;
  debug_v_g= debug_v_g + debug_lf + "Generated on " + debug_v_generated_time + "';";
  if (is_plsql)
  {
    debug_v_g= debug_v_g + debug_lf + "BEGIN " + debug_lf;
  }
  else
  /* Handling the signal number. If plsql this will be done at the end. */
  {
    debug_v_g= debug_v_g + debug_lf + "DECLARE EXIT HANDLER FOR " + QString::number(debug_xxxmdbug_signal_errno) + " BEGIN CALL xxxmdbug.routine_exit(); RESIGNAL; END;";
    debug_v_g= debug_v_g + debug_lf + "DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN CALL xxxmdbug.routine_exit(); RESIGNAL; END;";
  }
  /* "call routine_entry(variable-list,command-list)". includes "Insert Into Call stack". */
  debug_v_g= debug_v_g + debug_lf + "CALL xxxmdbug.routine_entry("
                  + "'`" + mysql_proc_db + "`',"
                  + "'`" + p_routine_identifier + "`',"
                  + "'" + mysql_proc_type + "',"
                  + "'" + debug_xxxmdbug_debugger_version + "',"
                  + "'" + debug_v_generated_time + "','";
  if (setup_generate_routine_entry_parameter(text)) return 1;
  debug_v_g= debug_v_g + "');" + debug_lf;
  /* TODO: routine_entry() should have another parameter for pre-set commands. */

  /* A breakpoint on line 0 is possible. There are no settable variables,
     but the user can see what the routine is, and can set breakpoints."
     breakpoint_check() always stops for line 0 right after 'debug' command. */
  debug_v_g= debug_v_g + debug_lf + "IF xxxmdbug.is_debuggee_and_is_attached()=1 THEN CALL xxxmdbug."
                  + debug_xxxmdbug_icc_core_surrogate_name
                  + "(0);"
                  + "END IF;" + debug_lf;
  return 0;
}

/*
   "Generate: ender": Called from generate(). Was: generate_ender().
   We call this for the last line of a routine.
   We also change call stack (without calling this) for special handling of RETURN.
   routine_exit() should cause "Delete From Call Stack" */
/* in plsql LEAVE x won't work if x is a label before a BEGIN,
   so we put a label at the end for which we can say GOTO */
void MainWindow::setup_generate_ender()
{
  if (is_plsql)
    debug_v_g= debug_v_g + "<<xxxmdbug_routine_exit>>";
  debug_v_g= debug_v_g
           + "\nCALL xxxmdbug.routine_exit();" + debug_lf;
  /* Handling the signal number. If sql/psm this was done at the start. */
  /* Todo: Don't generate "EXCEPTION " if EXCEPTION statement exists. */
  if (is_plsql)
  {
    debug_v_g= debug_v_g
           + "EXCEPTION "
           + "WHEN xxxmdbug_5678 THEN BEGIN RAISE xxxmdbug_5678; END;"
           + debug_lf;
  }
  debug_v_g= debug_v_g
          + "END;" + debug_lf;
}

/*
  Find statements and generate for them.
  Beware, sometimes flow-control statements start with labels.
  Actually I think start_statement flag is on if it's label_define.
  If i_end_of_parameters is at ")" then it won't be shown, but if it
  is at "AS" (as happens with plsql) then it will be shown so ++count.
  Todo: some of the parameters can be calculated from routine_number.
*/
int MainWindow::setup_generate_statements(int i,
                                           QString text,
                                           int routine_number)
{
  int v_statement_number_within_routine= 0;
  int v_line_number_of_start_of_first_token;
  int v_token_number_of_last_token;
  for (; main_token_lengths[i] != 0; ++i)
  {
    QString d= text.mid(main_token_offsets[i], main_token_lengths[i]);
    if ((main_token_flags[i] & TOKEN_FLAG_IS_START_STATEMENT)
     || (main_token_reftypes[i] == TOKEN_REFTYPE_LABEL_DEFINE))
    {
      ++debug_v_statement_number;
      ++v_statement_number_within_routine;
      if (main_token_reftypes[i] == TOKEN_REFTYPE_LABEL_DEFINE)
      {
        int j= main_token_offsets[i];
        ++i;
        for (; ; ++i)
        {
          if (main_token_flags[i] & TOKEN_FLAG_IS_START_STATEMENT) break;
        }
        QString s= text.mid(j, main_token_offsets[i] - j);
        debug_v_g.append(s);
      }
      {
        int j= main_token_offsets[i_of_end_of_parameters];
        int k= main_token_offsets[i];
        QString s= QString::number(i) + "*" + text.mid(j, k - j);
        v_line_number_of_start_of_first_token= s.count(debug_lf);
        int t= main_token_types[i_of_end_of_parameters];
        if ((t == TOKEN_KEYWORD_AS) || (t == TOKEN_KEYWORD_IS))
          ++v_line_number_of_start_of_first_token;
      }
      //v_character_number_of_start_of_first_token= main_token_offsets[i];
      for (int j= i + 1; ; ++j)
      {
        if ((main_token_flags[j] & TOKEN_FLAG_IS_START_STATEMENT)
         || (main_token_reftypes[i] == TOKEN_REFTYPE_LABEL_DEFINE)
         || (main_token_lengths[j] == 0))
        {
          v_token_number_of_last_token= j - 1;
          break;
        }
      }
      if (setup_generate_label(i, text, v_statement_number_within_routine)) return 1;

      if (main_token_flags[i] & TOKEN_FLAG_IS_DEBUGGABLE)
      {
        /* Todo: generate per-statement stuff, this is executable */
        /* We'll set is_leave_possible later. */
        if (setup_generate_statements_debuggable(i,
                                             v_line_number_of_start_of_first_token,
                                             v_statement_number_within_routine,
                                             text,
                                             v_token_number_of_last_token,
                                             routine_number)) return 1;
      }
      else
      {
        if (setup_generate_statement_text(i,
                                      text,
                                      v_token_number_of_last_token,
                                      routine_number)) return 1;
      }
      i= v_token_number_of_last_token;
    }
  }
  return 0;
}

/*
   Initialize some variables. Called from setup(), command(), and become_debuggee_connection().
   Start with some error checks.
   Any names that start with @xxxmdbug are reserved.
   Some of the variables set in this procedure are "constants".
   In debug_parse_statement() there is also some initialization,
   but $setup no longer calls that.
*/
/* For debugger purposes, the pipe prefix forms are:
   'xxxmdbug_' + @xxxmdbug_prefix_endxxx e.g. 'B '
   The 'R ' messages are status sendings which the debugger may or may not choose to receive (the debuggee may overwrite them).
   The @xxxmdbug_prefix_end_for_rxxx messages are responses to specific questions which the debugger is expecting.
*/
/* Todo: why not find out current sql_mode too? */
int MainWindow::setup_initialize_variables()
{
  debug_lf = "\n"; /* constant: Line Feed. add carriage return if desired */
  debug_xxxmdbug_debugger_name= "OCELOTGUI";
  debug_xxxmdbug_debugger_version= ocelotgui_version;
  debug_xxxmdbug_signal_errno= 5678;

  /* Todo: make this call along with other things you need server for. */
  /* Todo: watch out re group_concat_max_len */
  char query[]="SELECT current_timestamp(),database(),group_concat(plugin_name ORDER BY plugin_name), @@session.sql_mode FROM information_schema.plugins;";
  QString s= select_1_row(query);
  if (s != "")
  {
    char error_message[1024];
    strcpy(error_message, "Failed to execute: ");
    strcat(error_message, query);
    debug_error(error_message);
    return 1;
  }

  debug_xxxmdbug_timestamp= select_1_row_result_1;
  debug_xxxmdbug_default_schema= select_1_row_result_2;
  debug_plugins= select_1_row_result_3;
  debug_session_sql_mode_original= select_1_row_result_4;
  debug_session_sql_mode_after_last_change= debug_session_sql_mode_original;
  return 0;
}

/*
   routine_identifier_of_surrogate = xxxmdbug xxx type routine_identifier
   where xxx = set name = a 3-character value with character set { 0-9 A-Z },
   up to 36 * 36 * 36 = 46656 possibilities, and it goes up every time we call setup().
   where type = first letter of mysql.proc.type so 'P' for procedure and 'F' for function.
   This format is expected by debuggee_wait_loop().
   In get_set_setup_group_name() all we do is get the 3-character string, @xxxmdbug_setup_group_name
   Todo: explain what to do if set name reaches 'ZZZ'.
   Todo: Get group name again when you're ready to write.
         If it's not the same, debug_error("Concurrency error").
*/
int MainWindow::setup_get_setup_group_name()
{
  int vxxx_as_number;
  int v_digit1,v_digit2,v_digit3;
  QString v_max_name= "";
  QString v_max_name_in_setup_log= "";
  QString s;
  s= select_1_row("SELECT MAX(routine_name) FROM information_schema.routines WHERE routine_name LIKE 'xxxmdbug____%';");
  if (s != "")
  {
    debug_error((char*)"Failed to read information_schema.routines");
    return 1;
  }
  v_max_name= select_1_row_result_1.toUpper();
  s= select_1_row("SELECT MAX(surrogate_routine_identifier) FROM xxxmdbug.setup_log WHERE surrogate_routine_identifier LIKE 'xxxmdbug____%';");
  if (s != "")
  {
    debug_error((char*)"Failed to read xxxmdbug.setup_log");
    return 1;
  }
  v_max_name_in_setup_log= select_1_row_result_1.toUpper();
  if ((v_max_name_in_setup_log > v_max_name)
   || (v_max_name == ""))
    v_max_name= v_max_name_in_setup_log;
  if (v_max_name == "") debug_xxxmdbug_setup_group_name= "000";
  else
  {
    debug_xxxmdbug_setup_group_name= v_max_name.mid(strlen("xxxmdbug"), 3);
    if (debug_xxxmdbug_setup_group_name == "ZZZ")
    {
      debug_error((char*)"Too many sets of surrogates, cleanup necessary");
      return 1;
    }
    char digits[4];
    strcpy(digits, debug_xxxmdbug_setup_group_name.mid(0, 1).toUtf8());
    v_digit1= (int)digits[0];
    if (v_digit1 <= 57) v_digit1-= 48; else v_digit1 -= (65 - 10);
    strcpy(digits, debug_xxxmdbug_setup_group_name.mid(1, 1).toUtf8());
    v_digit2= (int)digits[0];
    if (v_digit2 <= 57) v_digit2-= 48; else v_digit2 -= (65 - 10);
    strcpy(digits, debug_xxxmdbug_setup_group_name.mid(2, 1).toUtf8());
    v_digit3= (int)digits[0];
    if (v_digit3 <= 57) v_digit3-= 48; else v_digit3 -= (65 - 10);
    vxxx_as_number= ((v_digit1 * 36 * 36) + (v_digit2 * 36) + v_digit3) + 1;
    v_digit3= vxxx_as_number % 36;
    v_digit2= ((vxxx_as_number - v_digit3)/36) %36;
    v_digit1= ((vxxx_as_number-(v_digit3+v_digit2*36))/(36*36)) %36;
    if (v_digit1 <= 9) v_digit1= v_digit1 + 48; else v_digit1= v_digit1 + (65-10);
    if (v_digit2 <= 9) v_digit2= v_digit2 + 48; else v_digit2= v_digit2 + (65-10);
    if (v_digit3 <= 9) v_digit3= v_digit3 + 48; else v_digit3= v_digit3 + (65-10);
    digits[0]= v_digit1;
    digits[1]= v_digit2;
    digits[2]= v_digit3;
    digits[3]= '\0';
    debug_xxxmdbug_setup_group_name= digits;
  }
  return 0;
}
#endif

/*
  Identifiers in routines might be "delimited" or `delimited` or bare.
  We usually want `delimited` for consistent comparisons.
  Todo: Convert to upper because, even if variable-name is delimited,
        it is not case sensitive? Well, let's cancel that for a while.
        If we don't send it as lower case, IT DOESN'T WORK.
  Todo: This doesn't handle names that have ` or " inside them.
  Todo: Test with @`var` etc.
*/
QString MainWindow::setup_add_delimiters(QString name)
{
  QString n= name;
  if (n.mid(0,1) == "@") return n;
  if ((debug_ansi_quotes) && (n.mid(0,1) == "\""))
  {
    n= connect_stripper(n, true);
    return "`" + n + "`";
  }
  if (n.mid(0,1) != "`")
  {
    n= "`" + n + "`";
  }
  return n;
}

#if (OCELOT_MYSQL_DEBUGGER == 1)
/* We finished with declared variables.
   Now user variables, that is, any token that starts with '@'.
   Here we dump names that start with '@' into a variables list.
   Later we select from the list and use the result as input for
   generate_icc_core().
   In the end the user sees these variables with command 'refresh user_variables'.
   If the user said call setup('-track_user_variables=0 ...') then we do nothing.
   todo: this is not handling already-delimited user variables correctly.
   todo: check: do we need to check for TOKEN_REFTYPE_COLUMN_OR_USER_VARIABLE?
   todo: I would much prefer to look for TOKEN_REFTYPE_USER_VARIABLE, but
         for some reason hparse isn't generating it. Have a look there.
   todo: BUG: (probably): setup_add_delimiters depends on debug_ansi_quotes which maybe we didn't set
*/
int MainWindow::setup_insert_into_variables_user_variables(QString text, int i_of_end_of_parameters)
{
  if (debug_track_user_variables > 0)
  {
    for (int i= i_of_end_of_parameters; main_token_lengths[i] != 0; ++i)
    {
      if (main_token_types[i] == TOKEN_TYPE_IDENTIFIER_WITH_AT)
      {
        QString v_value= text.mid(main_token_offsets[i], main_token_lengths[i]);
        if ((v_value.mid(0,1) == "@") && (v_value.mid(1,1) != "@"))
        {
          v_value= setup_add_delimiters(v_value);
          /* don't insert duplicates. */
          if (debug_tmp_user_variables.contains(v_value)) continue;
          debug_tmp_user_variables << v_value;
        }
      }
    }
  }
  debug_tmp_user_variables.sort(); /* I'm not sure this is necessary */
  return 0;
}


int MainWindow::setup_create_setup_log_table()
{
  char statement[]=
  "CREATE TABLE IF NOT EXISTS xxxmdbug.setup_log (\
   group_name VARCHAR(3) CHARACTER SET utf8,\
   user VARCHAR(80) CHARACTER SET utf8,\
   version_number_of_debugger CHAR(5) CHARACTER SET utf8,\
   timestamp_when_setup_procedure_was_run DATETIME,\
   arguments_passed_to_setup VARCHAR(8192) CHARACTER SET utf8,\
   routine_type VARCHAR(10) CHARACTER SET utf8, /* procedure|function. not event|trigger yet. */\
   schema_identifier VARCHAR(66) CHARACTER SET utf8,\
   original_routine_identifier VARCHAR(66) CHARACTER SET utf8,\
   surrogate_routine_identifier VARCHAR(66) CHARACTER SET utf8,\
   outcome VARCHAR(66) CHARACTER SET utf8, /* Made surrogate, Overwrote, or Failed */\
   invocations_of_routines_in_same_group INT,\
   invocations_of_routines_in_any_group INT,\
   comment_based_on_generate VARCHAR(66) CHARACTER SET utf8,\
   comment_based_on_readme VARCHAR(66) CHARACTER SET utf8) engine=myisam;\
  ";

  if (setup_mysql_real_query(statement,
                             (char*)"FAILED. Cannot create setup_log table.") == 1)
    return 1;
  return 0;
}

/* We need to use information_schema.routines and SHOW CREATE.
   todo: decide whether to use body or body_utf8 from mysql.proc.
         it's impossible in MySQL but still possible in MariaDB.
   todo: we could have an additional parameter for extra diagnostics from debug
   Todo: Although I don't trust get_lock any more, I suppose that we
         could lock an xxxmdbug table during this routine. */
int MainWindow::setup_internal(QString command_string)
{
  QString object_name_list= command_string;
  /* Make sure object_name_list is schema_identifier.routine_identifier
    or schema_identifier.% or %.%. Default is %.%.
    (Well, no it is not, the comments here are a bit obsolete.)
    TODO: re-examine whether default schema identifier should be current database or %.
    TODO: re-examine whether wildcarding should be (% and _) or with *."
    Output is a temporary list of schemas and objects. */
  {
    /* CALL xxxmdbug.privilege_checks(); */
    if (setup_create_setup_log_table() == 1) return 1;
    if (setup_get_setup_group_name()) return 1; /* returns @xxxmdbug_setup_group_name = 3-character string for new set name. */
    if (debug_track_user_variables > 0)
      debug_xxxmdbug_icc_core_surrogate_name=
          "xxxmdbug"
          + debug_xxxmdbug_setup_group_name
          + "P"
          + "icc_core";
    else
      debug_xxxmdbug_icc_core_surrogate_name= "icc_core";
  }
  if (setup_routine_list(command_string)) return 1;
  debug_v_statement_number= 0;
  for (int i= 0; i < debug_routine_list_names.count(); ++i)
  {
    if (setup_generate(i)) return 1;
    QString s_insert=
      QString("INSERT INTO xxxmdbug.setup_log VALUES (")
      +  "'" + debug_xxxmdbug_setup_group_name + "'," /* group_name */
      +  "'" + ocelot_user + "'," /* user. ?? maybe statement_edit_widget->dbms_current_user is better? */
      +  "'" + debug_xxxmdbug_debugger_version + "'," /* version_number_of_debugger */
      +  "'" + debug_xxxmdbug_timestamp + "'," /* timestamp_when_setup_procedure_was_run */
      +  "'" + object_name_list + "'," /* arguments_passed_to_setup */
      +  "'" + debug_routine_list_types.at(i) + "'," /* routine_type */
      +  "'" + debug_routine_list_schemas.at(i) + "'," /* schema_identifier */
      +  "'" + debug_routine_list_names.at(i) + "'," /* original_routine_identifier */
      +  "'" + debug_routine_list_surrogates.at(i) + "'," /* surrogate_routine_identifier */
      +  "'done'," /* outcome */ /* todo: something informative, eh? */
      +  "0," /* @xxxmdbug_invocations_of_routines_in_same_group,"*/ /* invocations_of_routines_in_same_group */
      +  "0," /* @xxxmdbug_invocations_of_routines_in_any_group,"*/ /* invocations_of_routines_in_any_group */
      + "NULL," /* comment_based_on_generate */
      + "'thanks. copyright. gpl');"; /* comment_based_on_readme */
    char s_utf8[2048]; /* Todo: this should be dynamically allocated */
    strcpy(s_utf8, s_insert.toUtf8());
    if (setup_mysql_real_query(s_utf8,
                               (char*)"FAILED. Cannot insert into xxxmdbug.setup_log. ") == 1)
      return 1;
  }

  if (debug_track_user_variables > 0)
  {
    if (setup_generate_icc_core() == 1) return 1;
  }

  if (setup_generate_icc_process_user_command_r_server_variables() == 1) return 1;

  /* This is blank: CALL xxxmdbug.view_and_trigger_and_event_check(); */
  /* This is blank: CALL xxxmdbug.checks_and_warnings(mysql_proc_db); */

  /*
    Now routine_lists_* has a bunch of CREATE PROCEDURE|FUNCTION,
    ready to be executed.
    TODO: If there were no @variables you can change calls to the
          generated icc_core back to the regular icc_core, it's a
          simple search-and-replace now.
  */
  if (setup_drop_routines() == 1) return 1;
  /* Create all the routines that are to be created. */
  /* If one of the creates fails, undo all previous creates. */
  /* Todo: change sql_mode before you call. Definer too? */
  for (int i= 0; i < debug_routine_list_surrogates.count(); ++i)
  {
    QString s;
    s= debug_routine_list_texts.at(i);
    {
      setup_set_session_sql_mode(debug_routine_list_sql_modes.at(i));
      int query_len= s.toUtf8().size();                  /* See comment "UTF8 Conversion" */
      char *query= new char[query_len + 1];
      memcpy(query, s.toUtf8().constData(), query_len + 1);
      if (setup_mysql_real_query(query,
                                 (char*)"FAILED. Cannot create a routine. ") == 1)
      {
        setup_drop_routines();
        delete []query;
        return 1;
      }
      delete []query;
    }
  }
  return 0;
}

/*
  Drop all routines in debug_routine_list_surrogates.
  We call this before we try to create those routines.
  Or we call this if any create fails.
  Todo: Think: why return if drop fails, instead of going to next?
*/
int MainWindow::setup_drop_routines()
{
  for (int i= 0; i < debug_routine_list_surrogates.count(); ++i)
  {
    QString s;
    s= "DROP "
            + debug_routine_list_types.at(i)
            + " IF EXISTS "
            + debug_routine_list_schemas.at(i)
            + "."
            + debug_routine_list_surrogates.at(i)
            + ";" + debug_lf;
    {
      int query_len= s.toUtf8().size();                  /* See comment "UTF8 Conversion" */
      char *query= new char[query_len + 1];
      memcpy(query, s.toUtf8().constData(), query_len + 1);

      if (setup_mysql_real_query(query,
                                 (char*)"FAILED. Cannot drop.") == 1)
      {
        delete []query;
        return 1;
      }
    }
  }
  return 0;
}

/*
  At the end of the $setup process, whether or not it succeeded:
  Possibly temporary tables were created, now drop them (no, gone now).
  Possibly some QStringLists were filled, now clear them.
  This is not a complete list, just the most likely to be big.
  Do not call before setup_initialize() where got debug_session_sql_mode.
*/
void MainWindow::setup_cleanup()
{
  debug_routine_list_schemas.clear();
  debug_routine_list_names.clear();
  debug_routine_list_types.clear();
  debug_routine_list_sql_modes.clear();
  debug_routine_list_surrogates.clear();
  debug_routine_list_texts.clear();
  debug_tmp_user_variables.clear();
  setup_set_session_sql_mode(debug_session_sql_mode_original);
}

/*
  Called from setup_internal() when we're about to create a routine.
  Called from setup_cleanup() when we want to restore the original.
  We execute SET SESSION_SQL_MODE=... so that, if sql_mode when the
  original routine was created is different from sql_mode now, we
  won't get in trouble because ""s were used for names, or due to
  pipes_as_concat, or in future something to do with sql_mode='oracle'.
  Actually we've probably changed ""s to ``s but that's not enough.
  Todo: Not much we can do about failure. But return an error if fail.
*/
int MainWindow::setup_set_session_sql_mode(QString s)
{
  if (s != debug_session_sql_mode_after_last_change)
  {
    char query[1024];
    strcpy(query, "SET SESSION SQL_MODE='");
    strcat(query, s.toUtf8());
    strcat(query, "';");
    if (setup_mysql_real_query(query,
                               (char*)"FAILED. Cannot change sql_mode.") == 1)
      return 1;
    debug_session_sql_mode_after_last_change= s;
  }
  return 0;
}

/* This generates the debuggee procedure that will handle the 'refresh server_variables'
   command. It is better to generate rather than have a fixed set of
   statements, because the server variables depend on the version and
   on what engines or plugins are installed. An example first line:
   SET v_ret=CONCAT(v_ret,'"@@ARIA_BLOCK_SIZE",','"',@@ARIA_BLOCK_SIZE,'";');
   todo: watch for v_ret overflow
   Perhaps performance_schema.session_variables won't exist,
   so we don't abort on failure.
   Todo: Nowadays MariaDB information_schema.server_variables has
         data-type and read-only columns, so most of this effort is not
         necessary! But we still need it because MySQL won't have them:
         https://dev.mysql.com/doc/refman/8.0/en/performance-schema-system-variable-tables.html
*/
/* Code from setup_generate_icc_process_user_command_set_server_variables
   has been added, it will use QString v_g_2 instead of QString v_g.
   This generates the debuggee procedure that will handle the 'set @@server_variable=...'
   command. An example first line:
   IF @token_value_2 = '@@ARIA_BLOCK_SIZE' THEN SET @@ARIA_BLOCK_SIZE=@xxxmdbug_token_value_4a; END IF;
   Wrong type or wrong value will cause a severe error, we handle it, but the warning list is cleared.*/
int MainWindow::setup_generate_icc_process_user_command_r_server_variables()
{
  QString mysql_proc_name;
  QString mysql_proc_db;
  QString mysql_proc_type;
  QString v_variable_name;
  QString v_g, v_g_2;
  QStringList c_variable_names; /* not the global with the same name */
  QStringList c_variable_types;
  {
    /* Skip if we did it before and server version + plugins unchanged */
    /* (Maybe 'settable' differs due to privileges, I don't care.) */
    QString s=
      QString("SELECT COUNT(*) ")
      + "FROM information_schema.routines "
      + "WHERE routine_name = 'icc_process_user_command_r_server_variables' "
      + "AND routine_schema COLLATE utf8_general_ci = 'xxxmdbug' "
      + "AND routine_definition LIKE '%" + statement_edit_widget->dbms_version + "%' "
      + "AND routine_definition LIKE '%" + debug_plugins + "%';";
    int query_len= s.toUtf8().size(); /* See comment "UTF8 Conversion" */
    char *query= new char[query_len + 1];
    memcpy(query, s.toUtf8().constData(), query_len + 1);
    QString s2= select_1_row(query);
    delete []query;
    if ((s2 == "") && (select_1_row_result_1.toInt() == 1)) return 0;
  }

  {
    /* Todo: Make sure big enough. Restore to original value. */
    int max_len= 100000;
    char query[256];
    sprintf(query, "SET SESSION GROUP_CONCAT_MAX_LEN=%d;", max_len);
    if (setup_mysql_real_query(query,
                               (char*)"FAILED. Cannot change group_concat_maxlen.") == 1)
      return 1;
  }
  c_variable_names.clear();
  c_variable_types.clear();
  {
    QString s;
    /* todo: maybe for MariaDB I should look first at information_schema */
    s= select_1_row("select group_concat('/*@@',variable_name) from performance_schema.session_variables;");
    if (s != "")
    {
      s= select_1_row("select group_concat('/*@@',variable_name) from information_schema.session_variables;");
      if (s != "")
      {
        debug_error((char*)"select from session_variables failed");
        return 1;
      }
    }
    int j, k;
    j= 0;
    for (int i= 0; ; ++i)
    {
      if (j == select_1_row_result_1.length()) break;
      k= select_1_row_result_1.indexOf("/*@@", j + 1);
      if (k == -1)
      {
        k= select_1_row_result_1.length();
        s= select_1_row_result_1.mid(j + 2, k - (j + 2));
      }
      else s= select_1_row_result_1.mid(j + 2, k - (j + 2 + 1));
      c_variable_names << s;
      j= k;
    }
  }

  if (c_variable_names.count()== 0) /* pseudo-assertion */
  {
    debug_error((char*)"c_variable_names.count() == 0");
    return 1;
  }
  c_variable_names.sort();

  /* Determine the types. Since we're calling from C, we
     have a way that doesn't involve trips to xxxmdbug.uvar.
     More exact too, but we throw away the exactness. */
  {
    MYSQL_RES *res= NULL;
    QString s= "SELECT ";
    for (int i= 0; i < c_variable_names.count(); ++i)
    {
      if (i != 0) s= s + QString(",");
      s= s + c_variable_names.at(i);
    }
    s= s + QString(";");
    int query_len= s.toUtf8().size(); /* See comment "UTF8 Conversion" */
    char *query= new char[query_len + 1];
    memcpy(query, s.toUtf8().constData(), query_len + 1);

    if (setup_mysql_real_query(query,
                               (char*)"FAILED. While selecting variable names.") == 1)
    {
      delete []query;
      return 1;
    }
    delete []query;
    res= lmysql->ldbms_mysql_store_result(&mysql[MYSQL_MAIN_CONNECTION]);
    if (res != NULL)
    {
      int num_fields= lmysql->ldbms_mysql_num_fields(res);
      assert(num_fields == c_variable_names.count());
      MYSQL_FIELD *fields;
      fields= lmysql->ldbms_mysql_fetch_fields(res);
      int t;
      QString v_data_type;
      for (int i= 0; i < num_fields; ++i)
      {
        t= fields[i].type;
        if ((t == OCELOT_DATA_TYPE_LONGLONG)
         || (t == MYSQL_TYPE_TINY)
         || (t == OCELOT_DATA_TYPE_SHORT)
         || (t == MYSQL_TYPE_LONG)
         || (t == OCELOT_DATA_TYPE_INT24))
         v_data_type= "BIGINT";
        else if ((t == MYSQL_TYPE_LONG_BLOB)
              || (t == MYSQL_TYPE_VAR_STRING)
              || (t == MYSQL_TYPE_TIMESTAMP)
              || (t == MYSQL_TYPE_SET)
              || (t == MYSQL_TYPE_ENUM)
              || (t == OCELOT_DATA_TYPE_STRING))
        {
          if (fields[i].charsetnr == 63) v_data_type= "LONGBLOB";
          else v_data_type= "LONGTEXT";
        }
        else if (t == OCELOT_DATA_TYPE_DECIMAL) v_data_type= "DECIMAL";
        else if ((t == MYSQL_TYPE_FLOAT)
              || (t == OCELOT_DATA_TYPE_DOUBLE))
                v_data_type= "DOUBLE";
        else v_data_type= "UNKNOWN";
        c_variable_types << v_data_type;
      }
    }
    if (res != NULL) lmysql->ldbms_mysql_free_result(res);
  }

  mysql_proc_name= "icc_process_user_command_r_user_variables"; /* todo: this is a lie. the original is for server_variables. */
  QString v_g_surrogate_routine_identifier= "icc_process_user_command_r_server_variables";
  QString v_g_2_surrogate_routine_identifier= "icc_process_user_command_set_server_variables";

  QString xxxmdbug_comment;
  {
    QString xxxmdbug_comment_string=
            debug_lf + "Routine for debugger tracking server variables"
            + debug_lf + "Generated by " + debug_xxxmdbug_debugger_name + " Version " + debug_xxxmdbug_debugger_version
            + debug_lf + "Generated on " + debug_xxxmdbug_timestamp
            + debug_lf + "Generated from " + statement_edit_widget->dbms_version
            + debug_lf + "Plugins: " + debug_plugins;
    xxxmdbug_comment=
          debug_lf
          + "DECLARE xxxmdbug_comment VARCHAR("
          + QString::number(xxxmdbug_comment_string.length() + 1)
          + ") DEFAULT '"
          + xxxmdbug_comment_string
          + "';" + debug_lf;
  }
  mysql_proc_db= "xxxmdbug";
  mysql_proc_type= "PROCEDURE";

  /* For ..._r_... Opening matches what is in generate(). */

  v_g = "CREATE "
          + mysql_proc_type
          + " "
          + mysql_proc_db
          + "."
          + v_g_surrogate_routine_identifier
          + "()" + debug_lf;
  //v_g_offset_of_begin= v_g.length() + debug_lf.length();
  v_g= v_g
          + "BEGIN"
          + xxxmdbug_comment
          + "DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8 DEFAULT '';" + debug_lf
          /* todo: try TEXT */
          + "DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" + debug_lf;

  /* For ..._set_... Opening matches what is in generate(). */
  v_g_2= v_g_2
          + "CREATE "
          + mysql_proc_type
          + " "
          + mysql_proc_db
          + "."
          + v_g_2_surrogate_routine_identifier
          + "()" + debug_lf;
  //v_g_2_offset_of_begin= v_g_2.length() + debug_lf.length();
  v_g_2= v_g_2
        + "BEGIN"
        + xxxmdbug_comment
        + "DECLARE EXIT HANDLER FOR SQLEXCEPTION CALL xxxmdbug.icc_change_statement_status('Fail');" + debug_lf
        + "SET @xxxmdbug_tmp_for_set = 'Fail';" + debug_lf;

  for (int i= 0; i < c_variable_names.count(); ++i)
  {
    /* Test whether one can assign to the variable. If an exception happens,
       it is almost certainly because the variable is read-only.
       ERROR 1238 (HY000): Variable 'warning_count' is a read only variable.
       In that case 'refresh server_variables' will show that is_settable = 0.
       Do not check @@timestamp because SET TIMESTAMP freezes the clock.
       Todo: actually a new column 'read only' would be smarter, here and for parameters. */
    //QString xxxmdbug_test_setting;
    v_variable_name= c_variable_names.at(i);
    int v_is_settable= 1;
    if (v_variable_name  != "@@TIMESTAMP")
    {
      char xxxmdbug_test_setting[256];
      strcpy(xxxmdbug_test_setting, "SET ");
      strcat(xxxmdbug_test_setting, v_variable_name.toUtf8());
      strcat(xxxmdbug_test_setting, "=");
      strcat(xxxmdbug_test_setting, v_variable_name.toUtf8());
      strcat(xxxmdbug_test_setting, ";");
      /* Not a call to setup_mysql_query because failure is okay. */
      if (lmysql->ldbms_mysql_real_query(&mysql[MYSQL_MAIN_CONNECTION], xxxmdbug_test_setting, strlen(xxxmdbug_test_setting)))
      {
        v_is_settable= 0;
      }
    }

    v_g= v_g +
            + "SET v_ret=CONCAT(v_ret,'\""
            + v_variable_name
            + "\",','\"',HEX(IFNULL(LEFT("
            + v_variable_name
            + ",66),'NULL')),'\","
            + QString::number(v_is_settable)
            + ",\""
            + c_variable_types.at(i)
            + "\";');" + debug_lf;

    if (v_is_settable != 0)
    {
      v_g_2= v_g_2
             + "IF @xxxmdbug_token_value_2 = '"
             + v_variable_name
             + "' THEN SET "
             + v_variable_name
             + "= @xxxmdbug_token_value_4a; SET @xxxmdbug_tmp_for_set = 'OK'; END IF;" + debug_lf;
    }
  }

  v_g= v_g
       + "SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_server_variables);\n"
       + "CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);" + debug_lf
       + "CALL xxxmdbug.icc_change_statement_status('OK');" + debug_lf
       + "END;" + debug_lf;

  v_g_2= v_g_2
           + "CALL xxxmdbug.icc_change_statement_status(@xxxmdbug_tmp_for_set);" + debug_lf
           + "END;" + debug_lf;

  /*
    When setup_internals() sees what you add here,
    it will actually execute the creates. That is:
    drop + create icc_process_user_command_r_server_variables
    drop + create icc_process_user_command_set_server_variables
    update xxxmdbug.routines
  */
  debug_routine_list_schemas << "xxxmdbug";
  debug_routine_list_names << "";
  debug_routine_list_types << "PROCEDURE";
  debug_routine_list_sql_modes << "";
  debug_routine_list_surrogates << v_g_surrogate_routine_identifier;
  debug_routine_list_texts << v_g;

  debug_routine_list_schemas << "xxxmdbug";
  debug_routine_list_names << "";
  debug_routine_list_types << "PROCEDURE";
  debug_routine_list_sql_modes << "";
  debug_routine_list_surrogates << v_g_2_surrogate_routine_identifier;
  debug_routine_list_texts << v_g_2;
  return 0;
}

/* This generates a variant icc_core that can handle 'refresh user_variables'..
   Any changes to icc_core() should be made here too.
   Comments are stripped so see the original icc_core() above.
   The tmp_user_variables list was populated with @user-variable-names while we were generating.
     Although it is easy to assign to a user variable or server variable by
     preparing and executing a SET statement, it is unreliable because we
     might be in a function rather than in a procedure. So, for 'set', we
     generate fixed SET statements for the user variables that we know of.
   Use the base icc_core if track_user_variables=0.
   Todo: probably this would be faster if it was smaller. */
int MainWindow::setup_generate_icc_core()
{
  QString v_g;
  /* we already know icc_core_surrogate_name */
  v_g= "CREATE PROCEDURE xxxmdbug."
          + debug_xxxmdbug_icc_core_surrogate_name
          + "(line_number INT) "
          + debug_lf;

/* part 1 -- as far as the first 'call xxxmdbug.process_user_command'."
   v_ret and v_prefix are part of the variant. */
/* todo: as far as I can tell, the initial label 'z:' is not needed */
  v_g= v_g
          + "z:BEGIN" + debug_lf
          + "DECLARE v_ret MEDIUMTEXT CHARACTER SET utf8;" + debug_lf
          + "DECLARE v_prefix VARCHAR(128) CHARACTER SET utf8;" + debug_lf
          + "DECLARE sleep_result INT;" + debug_lf
          + "DECLARE v_n INT;" + debug_lf
          + "DECLARE v_flags INT;"
          + "DECLARE v_table_is_temporary_and_to_be_cleared INT;" + debug_lf
          + "SET @xxxmdbug_token_value_1 = '';"
          + "SET @xxxmdbug_icc_count=@xxxmdbug_icc_count+1;" + debug_lf
          + "x1: LOOP" + debug_lf
          + "  CALL xxxmdbug.icc_get_user_command(0);" + debug_lf
          + "  IF @xxxmdbug_message <= 0x20 THEN LEAVE x1; END IF;" + debug_lf
          + "  IF @xxxmdbug_token_value_1 IN ('continue','exit','leave','next','execute','skip','step') THEN LEAVE x1; END IF;"
          + "  IF @xxxmdbug_token_value_2 = 'user_variables' THEN" + debug_lf
          + "    SET v_ret='';" + debug_lf;
/* part 1 end */
  for (int i= 0; i < debug_tmp_user_variables.count(); ++i)
  {
    QString v_variable_name= debug_tmp_user_variables.at(i);
    v_g= v_g
          + "SET @xxxmdbug_uvar="
          + v_variable_name
          + ";"
          + "SET @xxxmdbug_old_uvar="
          + "@xxxmdbug_old_"
          + v_variable_name.mid(1, v_variable_name.length() - 1)
          + ";";
    v_g= v_g
          + "CALL xxxmdbug.uvar(v_ret,'"
          + v_variable_name
          + "');" + debug_lf;
  }

  v_g= v_g + "SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_user_variables);" + debug_lf
                       + "CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);" + debug_lf
                       + "CALL xxxmdbug.icc_change_statement_status('OK');" + debug_lf
                       + "ELSE" + debug_lf
                       + "CALL xxxmdbug.icc_process_user_command();" + debug_lf
                       + "END IF;" + debug_lf;

  v_g= v_g + "IF @xxxmdbug_token_value_1 = 'set' AND LEFT(@xxxmdbug_token_value_2,1) = '@' AND LEFT(@xxxmdbug_token_value_2,2) <> '@@' THEN" + debug_lf
                       + "  SET @xxxmdbug_status_last_command = 'set';" + debug_lf
                       + "  SET @xxxmdbug_tmp_for_set='Fail';" + debug_lf;
  for (int i= 0; i < debug_tmp_user_variables.count(); ++i)
  {
    QString v_variable_name= debug_tmp_user_variables.at(i);
    v_g= v_g
                       + "  IF @xxxmdbug_token_value_2 = '"
                       +    v_variable_name
                       +    "' THEN CALL xxxmdbug.retype(); SET "
                       +    v_variable_name
                       +    "= @xxxmdbug_token_value_4a; SET @xxxmdbug_tmp_for_set='OK'; END IF;" + debug_lf;
  }
  v_g= v_g + "CALL xxxmdbug.icc_change_statement_status(@xxxmdbug_tmp_for_set);" + debug_lf;
  v_g= v_g + "END IF;" + debug_lf;
  /* part 2 */
  v_g= v_g
                       + "END LOOP;" + debug_lf
                       + "SET @xxxmdbug_status_line_number = line_number;" + debug_lf
                       + "CALL xxxmdbug.icc_breakpoint_check(line_number,@xxxmdbug_breakpoint_check_result);" + debug_lf
                       + "SET @xxxmdbug_status_breakpoint_check_result = @xxxmdbug_breakpoint_check_result;" + debug_lf
                       + "CALL xxxmdbug.icc_send_statement_status('icc_core');" + debug_lf
                       + "IF @xxxmdbug_breakpoint_check_result > 0 THEN" + debug_lf
                       + "x2: LOOP" + debug_lf
                       + "IF @xxxmdbug_token_value_1 IN ('continue','exit','leave','next','execute','skip','step') THEN" + debug_lf
                       + "LEAVE x2;" + debug_lf
                       + "END IF;" + debug_lf
                       + "CALL xxxmdbug.icc_get_user_command(1);" + debug_lf
                       + "IF @xxxmdbug_token_value_1 IN ('next','step') THEN CALL xxxmdbug.icc_process_user_command_step_or_next(); END IF;" + debug_lf
                       + "IF @xxxmdbug_token_value_1 IN ('continue','exit','leave','next','execute','skip','step') THEN" + debug_lf
                       + "LEAVE x2;" + debug_lf
                       + "END IF;" + debug_lf
                       + "IF @xxxmdbug_token_value_2 = 'user_variables' THEN" + debug_lf
                       + "SET v_ret='';" + debug_lf;
/* part2 end */
  for (int i= 0; i < debug_tmp_user_variables.count(); ++i)
  {
    QString v_variable_name= debug_tmp_user_variables.at(i);
    v_g= v_g
                        + "SET @xxxmdbug_uvar="
                        + v_variable_name
                        + ";"
                        + "SET @xxxmdbug_old_uvar=@xxxmdbug_old_"
                        + v_variable_name.mid(1,v_variable_name.length() - 1)
                        + ";"
                        + "CALL xxxmdbug.uvar(v_ret,'"
                        + v_variable_name
                        + "');" + debug_lf;
  }
  v_g= v_g
                        + "SET v_prefix = CONCAT('xxxmdbug_',@xxxmdbug_channel,@xxxmdbug_prefix_end_for_r_user_variables);" + debug_lf
                        + "CALL xxxmdbug.dbms_pipe_send(v_prefix,v_ret);" + debug_lf
                        + "CALL xxxmdbug.icc_change_statement_status('OK');" + debug_lf
                        + "ELSE "
                        + "CALL xxxmdbug.icc_process_user_command();" + debug_lf
                        + "END IF;" + debug_lf;
  v_g= v_g
                        + "IF @xxxmdbug_token_value_1 = 'set' AND LEFT(@xxxmdbug_token_value_2,1) = '@'  AND LEFT(@xxxmdbug_token_value_2,2) <> '@@' THEN" + debug_lf
                        + "SET @xxxmdbug_status_last_command = 'set';" + debug_lf
                        + "SET @xxxmdbug_tmp_for_set = 'Fail';" + debug_lf;
  for (int i= 0; i < debug_tmp_user_variables.count(); ++i)
  {
    QString v_variable_name= debug_tmp_user_variables.at(i);
    v_g= v_g
                        + "IF @xxxmdbug_token_value_2 = '"
                        + v_variable_name
                        + "' THEN CALL xxxmdbug.retype(); SET "
                        + v_variable_name
                        + "= @xxxmdbug_token_value_4a; SET @xxxmdbug_tmp_for_set = 'OK'; END IF;" + debug_lf;
  }
  v_g= v_g + "CALL xxxmdbug.icc_change_statement_status(@xxxmdbug_tmp_for_set);" + debug_lf;
  v_g= v_g + "END IF;" + debug_lf;
/* part 3 start */
  v_g= v_g + "CALL xxxmdbug.icc_send_statement_status('icc_core');\n"
                       + "END LOOP;" + debug_lf
                       + "CALL xxxmdbug.icc_send_statement_status('icc_core');\n"
                       + "END IF;" + debug_lf;
/* part 3 end */
/* part 4 */
/* Copy all user variables to old user variables. For example, if there is
   a user variable @a, this will generate \"SET @xxxmdbug_old_a=@a;\".
   Results should show up in user_variables.old_value column.
   Todo: check for too-long variable names.
   Todo: there has to be some way to clean up all the @xxxmdbug_old_ variables. */
  for (int i= 0; i < debug_tmp_user_variables.count(); ++i)
  {
    QString v_variable_name= debug_tmp_user_variables.at(i);
    v_g= v_g
            + "SET @xxxmdbug_old_"
            + v_variable_name.mid(1, v_variable_name.length() - 1)
            + "="
            + v_variable_name
            + ";" + debug_lf;
  }
  v_g= v_g + "END;" + debug_lf;

  debug_routine_list_schemas << "xxxmdbug";
  debug_routine_list_names << debug_xxxmdbug_icc_core_surrogate_name;
  debug_routine_list_types << "PROCEDURE";
  debug_routine_list_sql_modes << "";
  debug_routine_list_surrogates << debug_xxxmdbug_icc_core_surrogate_name;
  debug_routine_list_texts << v_g;

  return 0;
}

/* Todo: "    IF v_statement_type = 'debuggable' THEN" ... */
int MainWindow::setup_generate_statements_debuggable(int i_of_statement_start,
                                                      int v_line_number_of_start_of_first_token,
                                                      int v_statement_number_within_routine,
                                                      QString text,
                                                      int v_token_number_of_last_token,
                                                      int routine_number)
{
  /* starts "if statement is being debugged" */
  debug_v_g= debug_v_g + "IF xxxmdbug.is_debuggee_and_is_attached()=1 THEN " + debug_lf;
  /* inner_loop: generate 'xxxmdbug_inner_loop_x: LOOP' */
  QString inner_loop_label= "xxxmdbug_inner_loop_label_" + QString::number(v_statement_number_within_routine);
  if (is_plsql)
    debug_v_g= debug_v_g
            + "<<" + inner_loop_label + ">> "
            + "LOOP" + debug_lf;
  else
    debug_v_g= debug_v_g
            + inner_loop_label
            + ": LOOP" + debug_lf;
//  /* Save @@warning_count. */
//  int v_verb= i; /* == token_number_of_first_token?? */
//  /* TODO: Find out previous_statement_type */
  /* Find out if previous_statement_type was nothing | DECLARE HANDLER */
  QString v_previous_statement_type= "not declare_handler";
  bool handler_seen= false;
  for (int i= i_of_statement_start; i >= 0; --i)
  {
    if (main_token_flags[i] & TOKEN_FLAG_IS_START_STATEMENT)
    {
      if ((main_token_types[i] == TOKEN_KEYWORD_DECLARE)
       && (handler_seen == true))
        v_previous_statement_type= "declare_handler";
      break;
    }
    if (main_token_types[i] == TOKEN_KEYWORD_HANDLER) handler_seen= true;
  }
  int is_first_statement_in_a_declare_handler;
  if (v_previous_statement_type == "declare_handler")
    is_first_statement_in_a_declare_handler= 1;
  else
    is_first_statement_in_a_declare_handler= 0;
  debug_v_g= debug_v_g + debug_lf + "CALL xxxmdbug.icc_start("
           + QString::number(v_line_number_of_start_of_first_token)
           + ","
           + QString::number(is_first_statement_in_a_declare_handler)
           + ");"  + debug_lf;
  if (setup_determine_what_variables_are_in_scope(i_of_statement_start, text, false)) return 1; /* result=c_variables */

  for (int i= c_variable_names.count() - 1; i >= 0; --i)
  {
    QString v_variable_identifier= c_variable_names.at(i);
    QString v_token_number_of_declare= c_variable_tokens.at(i);
    //"          CALL xxxmdbug.overflow_check(debug_v_g);
    debug_v_g= debug_v_g + debug_lf
         + "CALL xxxmdbug.icc_copy_variable_to_table_row('"
         + v_variable_identifier
         + "',"
         + v_token_number_of_declare
         + ","
         + v_variable_identifier
         + ");" + debug_lf;
  }
  /* generate 'call icc_core' */
  debug_v_g= debug_v_g + "CALL xxxmdbug."
           + debug_xxxmdbug_icc_core_surrogate_name
           + "("
           + QString::number(v_line_number_of_start_of_first_token)
           + ");" + debug_lf;

  /* Generate: "if (exit) signal" */
  /* todo: consider doing the signal in icc_core or icc_process_user_command but maybe then it won't be handled. */
  debug_v_g= debug_v_g + "IF @xxxmdbug_token_value_1 = 'exit' THEN SIGNAL sqlstate '56780' SET mysql_errno = @xxxmdbug_signal_errno; END IF;";
  for (int i= c_variable_names.count() - 1; i >= 0; --i)
  {
    QString v_variable_identifier= c_variable_names.at(i);
    QString v_token_number_of_declare= c_variable_tokens.at(i);
    //"          CALL xxxmdbug.overflow_check(debug_v_g);
    debug_v_g= debug_v_g + debug_lf
         + "CALL xxxmdbug.icc_copy_table_row_to_variable('"
         + v_variable_identifier
         + "',"
         + v_token_number_of_declare
         + ","
         + v_variable_identifier
         + ");" + debug_lf;
  }
  /* inner_loop: 'SET' and 'EXECUTE' might change variables that we're watching.
     So if they happened, go back and copy the variables again.
     Todo: think: should this happen after non-debuggable statements too? */
  QString iterate;
  if (is_plsql) iterate= "CONTINUE ";
  else iterate= "ITERATE ";
  debug_v_g= debug_v_g + "IF @xxxmdbug_breakpoint_check_result>0 AND (@xxxmdbug_token_value_1 = 'set' OR @xxxmdbug_token_value_1 = 'execute') THEN "
             + iterate
             + inner_loop_label
             + "; END IF;" + debug_lf;
  /* Check @@warning_count. */
  debug_v_g= debug_v_g + debug_lf + "CALL xxxmdbug.icc_end();" + debug_lf;
  /* Generate: "if (leave) leave" i.e. leave outer loop */
  /* Sometimes LEAVE is illegal, see insert_into_statements comments.
     If so act as if 'leave' is 'skip'. */
  bool is_leave_possible;
  for (int j= i_of_statement_start - 1;; --j)
  {
    if (j <= i_of_end_of_parameters)
    {
      is_leave_possible= false;
      break;
    }
    if (main_token_types[j] == TOKEN_KEYWORD_END)
    {
      int k= main_token_pointers[j];
      if ((k >= j) || (k < 1))
      {
        is_leave_possible= false;  /* should be an assert */
        break;
      }
      j= main_token_pointers[j];
      continue;
    }
    if (main_token_flags[j] & TOKEN_FLAG_IS_START_STATEMENT)
    {
      bool is_begin_ok= true;
      if ((is_plsql) && (debug_label_list.count() != 1)) is_begin_ok= false;
      if (((main_token_types[j] == TOKEN_KEYWORD_BEGIN) && (is_begin_ok))
       || (main_token_types[j] == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT)
       || (main_token_types[j] == TOKEN_KEYWORD_LOOP)
       || (main_token_types[j] == TOKEN_KEYWORD_REPEAT)
       || (main_token_types[j] == TOKEN_KEYWORD_WHILE))
      {
        is_leave_possible= true;
        break;
      }
    }
    else
      if (main_token_types[j] == TOKEN_KEYWORD_HANDLER)
    {
      is_leave_possible= false;
      break;
    }
  }
  QString leave;
  if (is_plsql) leave= "EXIT ";
  else leave= "LEAVE ";
  if (is_leave_possible == true)
  {
    if (debug_label_list.count() == 0) /* pseudo-assert */
    {
      debug_error((char*)"debug_label_list.count() == 0");
      return 1;
    }
    debug_v_g= debug_v_g + debug_lf + "IF @xxxmdbug_token_value_1 = 'leave' THEN ";
    if ((is_plsql) && (debug_label_list.count() == 1))
    {
      debug_v_g= debug_v_g +"GOTO xxxmdbug_routine_exit";
    }
    else
    {
      debug_v_g= debug_v_g
             + "LEAVE "
             + debug_label_list.at(debug_label_list.count() - 1);
    }
    debug_v_g= debug_v_g
             + "; END IF;" + debug_lf;
  }
  else
  {
    debug_v_g= debug_v_g + debug_lf + "IF @xxxmdbug_token_value_1 = 'leave' THEN "
             + leave
             + inner_loop_label
             + "; END IF;" + debug_lf;
  }
  /* inner_loop: by leaving inner_loop before doing the instruction, we "skip over" it */
  debug_v_g= debug_v_g + "IF @xxxmdbug_token_value_1 = 'skip' THEN "
           + leave
           + inner_loop_label
           + "; END IF;" + debug_lf;
  /* If the original routine contained only one statement which was not compound and which
     did not end with ';', add ';'.
     Todo: Check: isn't this impossible? Didn't we add ";" earlier?
           I've assumed it's impossible, but statement ends with ";".
  */
  QString v_statement_end_character= ";";
  /* generate: handlers */
  /* removed. see notes before generate_handlers(). CALL xxxmdbug.generate_handlers(debug_v_g,v_line_number_of_start_of_first_token); */
//"  CALL xxxmdbug.overflow_check(debug_v_g);"
  /* todo: we got sql_mode earlier but we don't seem to be using it! */
  if (setup_generate_statement_text(i_of_statement_start, text, v_token_number_of_last_token, routine_number)) return 1;
  /* END the BEGIN that generate_handlers() generated */
  /* removed. see notes before generate_handlers(). SET debug_v_g = CONCAT(debug_v_g,@xxxmdbug_lf,'END;'); */

  /* generate something to insert if statement is 'prepare' or delete if statement is 'deallocate' */
  /* todo: think about the execution path if there is a user-written warning */
  int statement_type= main_token_types[i_of_statement_start];
  if ((statement_type == TOKEN_KEYWORD_PREPARE)
   || (statement_type == TOKEN_KEYWORD_DROP)
   || (statement_type == TOKEN_KEYWORD_DEALLOCATE))
  {
    QString v_value_of_second_token= "";
    QString v_value_of_third_token= "";
    QString v_value_of_fourth_token= "";
    for (int i= i_of_statement_start + 1; main_token_lengths[i] != 0; ++i)
    {
      if ((main_token_types[i] >= TOKEN_TYPE_COMMENT_WITH_SLASH)
       && (main_token_types[i] <= TOKEN_TYPE_COMMENT_WITH_MINUS))
        continue;
      QString n= text.mid(main_token_offsets[i], main_token_lengths[i]);
      if (v_value_of_second_token == "") v_value_of_second_token= n;
      else if (v_value_of_third_token == "") v_value_of_third_token= n;
      else
      {
        v_value_of_fourth_token= n;
        break;
      }
    }
    if (statement_type == TOKEN_KEYWORD_PREPARE)
    {
      /* I think v_value_of_fourth_token has ''s already, correctly */
      debug_v_g= debug_v_g + debug_lf + "CALL xxxmdbug.insert_into_prepared_statements('"
               + v_value_of_second_token
               + "',"
               + v_value_of_fourth_token
               + ");";
    }
    if (statement_type ==  TOKEN_KEYWORD_DROP)
    {
      /* A little-known alternative syntax for DEALLOCATE PREPARE is DROP PREPARE. */
      if (QString::compare(v_value_of_second_token, "PREPARE", Qt::CaseInsensitive) == 0)
      {
        statement_type= TOKEN_KEYWORD_DEALLOCATE;
      }
    }
    if (statement_type ==  TOKEN_KEYWORD_DEALLOCATE)
    {
      debug_v_g= debug_v_g + debug_lf + "CALL xxxmdbug.delete_from_prepared_statements('"
               + v_value_of_third_token
               + "');";
    }
  }
  /* generate 'update statements_executed' */
  debug_v_g= debug_v_g + debug_lf + "CALL xxxmdbug.update_statements_executed(0);";
  /* inner_loop: leave the loop after doing the original statement once */
  debug_v_g= debug_v_g + debug_lf
          + leave
          + inner_loop_label
          + ";" + debug_lf;
  /* inner loop: ends */
  debug_v_g= debug_v_g + "END LOOP;" + debug_lf;
  debug_v_g= debug_v_g + debug_lf + "ELSE"; /* terminates "if statement is being debugged" */
  /* "generate the statement text" for when we're not debugging */
//"      CALL xxxmdbug.overflow_check(debug_v_g);"
  if (setup_generate_statement_text_as_is(i_of_statement_start, text, v_token_number_of_last_token)) return 1;
  //"      SET debug_v_g = CONCAT(debug_v_g,v_statement_end_character);"
  debug_v_g= debug_v_g + debug_lf + "END IF;";
  return 0;
}

/* "Generate: label": Called from generate()
   Whenever you see WHILE or LOOP or BEGIN or REPEAT, make|copy a label and add to label list
   Whenever you see END (but not END IF or END CASE), remove last item in label list
   LEAVE will use the latest item in label list.
*/
int MainWindow::setup_generate_label(int i_of_start_of_statement, QString text, int v_statement_number)
{
  QString v_label;
  QString v_token_value_of_previous_token;
  int token_type;
  token_type= main_token_types[i_of_start_of_statement];
  if ((token_type == TOKEN_KEYWORD_BEGIN)
   || (token_type == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT)
   || (token_type == TOKEN_KEYWORD_LOOP)
   || (token_type == TOKEN_KEYWORD_REPEAT)
   || (token_type == TOKEN_KEYWORD_WHILE))
  {
    int j;
    for (j= i_of_start_of_statement - 1; j > i_of_end_of_parameters; --j)
    {
      token_type= main_token_types[j];
      if ((main_token_types[j] >= TOKEN_TYPE_COMMENT_WITH_SLASH)
       && (main_token_types[j] <= TOKEN_TYPE_COMMENT_WITH_MINUS))
        continue;
      v_token_value_of_previous_token= text.mid(main_token_offsets[j], main_token_lengths[j]);
      break;
    }
    if (v_token_value_of_previous_token == ":")
    {
      v_label= text.mid(main_token_offsets[j-1], main_token_lengths[j-1]);
    }
    else
    {
      v_label= " xxxmdbug_label_" + QString::number(v_statement_number);
      /* the ' ' is necessary if the while/loop/begin/repeat is not at start of line */
      if (is_plsql)
        debug_v_g= debug_v_g + " <<" + v_label + ">>";
      else
        debug_v_g= debug_v_g + " " + v_label + ":";
      debug_v_g= debug_v_g + debug_lf;
    }
    debug_label_list << v_label;
  }
  if (token_type == TOKEN_KEYWORD_END)
  {
    int j;
    for (j= i_of_start_of_statement + 1; main_token_lengths[j] != 0; ++j)
    {
      if ((main_token_types[j] >= TOKEN_TYPE_COMMENT_WITH_SLASH)
       && (main_token_types[j] <= TOKEN_TYPE_COMMENT_WITH_MINUS))
        continue;
      break;
    }
    if ((main_token_types[j] != TOKEN_KEYWORD_IF)
     && (main_token_types[j] != TOKEN_KEYWORD_CASE))
    {
      if (debug_label_list.count() == 0) /* pseudo-assert */
      {
        debug_error((char*)"label_list.count() == 0");
        return 1;
      }
      debug_label_list.removeAt(debug_label_list.count() - 1);
    }
  }
  return 0;
}
#endif //if (OCELOT_MYSQL_DEBUGGER == 1)

/* Todo: I'm excluding MariaDB variables defined as row type or
   within FOR var-name IN, since $debug can't handle them.
   It's probably fixable -- we don't absolutely have to have the
   data type (we get along without it for $user-variables); we
   should be able to recognize `row`.`scalar` names even if we
   have to lie to install_sql.cpp.
*/
int MainWindow::setup_row_type(int i_of_variable)
{
  for (int i= i_of_variable; main_token_lengths[i] != 0; ++i)
  {
    if ((main_token_flags[i] & TOKEN_FLAG_IS_DATA_TYPE) != 0)
    {
      if ((main_token_types[i] == TOKEN_KEYWORD_ROW)
       || (main_token_types[i] == TOKEN_KEYWORD_TYPE))
        return TOKEN_KEYWORD_ROW;
      return main_token_types[i];
    }
    if (main_token_types[i] == TOKEN_KEYWORD_IN) return TOKEN_KEYWORD_ROW;
    if ((main_token_flags[i] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
      break; /* reached next statement without seeing data type? impossible */
  }
  return 0;
}

/* Make c_variables = a list of in-scope variables. */
/* Use the same trick that was used for hparse_f_label */
/* token_number_of_declare starts at 1 after end of (parameter list)
   (or maybe it's 2 after start of parameter list?) */
/* Todo: Something can be in scope but shadowed. Look for duplicates! */
/* Todo: You're not handling identifiers that need delimiting */
/* Warning: Since search is from end to start, list is backwards.
   Therefore, when searching or copying, go in reverse order. */
/* Somewhere in some install_sql.cpp routine is an expectation that
   variables are inside ``s. So we add ``s if they're absent. */
/* Todo: Preserve the case of the original, not the reference (?).
   Todo: See what happens if it's in ""s or in ''s. */
/* Todo: We plan to change hparse_f_variables() so variable_refer
         points to variable_define. If that's done, this may be easier. */
/* Note: going backwards means for DEFINE x INT; we will see data_type INT before we see the name, good. */
int MainWindow::setup_determine_what_variables_are_in_scope(
            int i_of_statement_start,
            QString text,
            bool must_be_int)
{
  int data_type= -1;
  c_variable_names.clear();
  c_variable_tokens.clear();
  int v_token_number_of_declare= 0;
  bool is_identifier;
  for (int i= i_of_statement_start - 1; i >= 0; --i)
  {
    if (main_token_types[i] == TOKEN_KEYWORD_END)
    {
      int j= main_token_pointers[i];
      if ((j >= i) || (j < 1)) break; /* should be an assert */
      i= main_token_pointers[i];
      continue;
    }
    QString v_variable_identifier= "";
    if ((main_token_flags[i] & TOKEN_FLAG_IS_DATA_TYPE) != 0) data_type= main_token_types[i];
    is_identifier= false;
    if ((main_token_types[i] == TOKEN_TYPE_IDENTIFIER) /* same check as in hparse_f_is_identifier()? */
     || (main_token_types[i] == TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK)
     || (main_token_types[i] == TOKEN_TYPE_IDENTIFIER_WITH_DOUBLE_QUOTE))
    {
      if ((must_be_int == false) || (typer_is_int(data_type) == true))
        is_identifier= true;
    }
    if ((is_identifier)
     && (main_token_reftypes[i] == TOKEN_REFTYPE_VARIABLE_DEFINE))
    {
      v_variable_identifier= text.mid(main_token_offsets[i], main_token_lengths[i]);
      /* s = the var! */
      int k;
      for (k= i - 1; k >= 0; --k)
      {
        if ((main_token_flags[k] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
          break;
      }
      v_token_number_of_declare= k - i_of_start_of_parameters;
    }
    if ((is_identifier)
     && (i < i_of_end_of_parameters)
     && (main_token_reftypes[i] == TOKEN_REFTYPE_PARAMETER_DEFINE))
    {
      v_variable_identifier= text.mid(main_token_offsets[i], main_token_lengths[i]);
      v_token_number_of_declare= 0;
    }
    if (v_variable_identifier != "")
    {
      v_variable_identifier= setup_add_delimiters(v_variable_identifier);
      bool is_shadow= false;
      /* todo: variable_names.contains() would do this faster, I think. But it's in Qt 5.12+. */
      for (int m= 0; m < c_variable_names.count(); ++m)
      {
        if (QString::compare(c_variable_names.at(m), v_variable_identifier, Qt::CaseInsensitive) == 0)
        {
          is_shadow= true;
          break;
        }
      }
      if (is_shadow == false)
      {
        c_variable_names << v_variable_identifier;
        if (setup_row_type(i) == TOKEN_KEYWORD_ROW)
          c_variable_tokens << QString::number(-1);
        else
          c_variable_tokens << QString::number(v_token_number_of_declare);
      }
    }
  }
  for (int k= c_variable_tokens.count() - 1; k >= 0; --k)
  {
    int k2= c_variable_tokens.at(k).toInt();
    if (k2 == -1)
    {
      c_variable_names.removeAt(k);
      c_variable_tokens.removeAt(k);
    }
  }
  return 0;
}

#if (OCELOT_MYSQL_DEBUGGER == 1)
/*
  Generate the statement text, but replace routine names
  with surrogate routine names if they are in the $setup list,
  and being invoked.
  Beware: spaces after function names matter
  Todo: DO NOT necessarily replace with surrogate routine name. We might have put it in directly."
  Todo: check that argument count = parameter count."
  Todo: handle possible qualifier."
  Todo: handle possible delimiter."
  Todo: check that function name <> built-in name,
        in that case it's ignored (detectable at CREATE time).
  Todo: skip if CREATE? I forget why we substitute for CREATE.
  Todo: call this for flow-control statements, but they must end
        after the expression, e.g. WHILE (expr) DO ends with DO.
        (This also applies for DECLARE HANDLER.)
  Todo: call this for DECLARE because DEFAULT clauses can have (expr).
  Todo: I don't know how to handle PREPARE or EXECUTE IMMEDIATE yet,
        but if they have literal arguments there is hope.
  Todo: watch out for routine characteristic = ansi_quotes.
        (we've used debug_ansi_quotes elsewhere)
  Todo: Flow-control is not debuggable but might contain function calls.
  Warning: We're preserving comments because if they start with / * !
           they are not stripped, but we don't see inside them.
*/
int MainWindow::setup_generate_statement_text(int i_of_statement_start,
                                               QString text,
                                               int v_token_number_of_last_token,
                                               int routine_number
                                              )
{
  //bool statement_might_contain_routine_invocation= false;
  int statement_type= main_token_types[i_of_statement_start];

  /*
     special handling of RETURN -- remove the function name from the call stack before returning.
     we also do delete from call stack at the end of the routine, due to generate_ender.
     todo: more special handling of RETURN: we pointlessly generate
           CALL xxxmdbug.update_statements_executed(0);
           LEAVE xxxmdbug_inner_loop_label_2;
  */
  if (statement_type == TOKEN_KEYWORD_RETURN)
    debug_v_g= debug_v_g + "CALL xxxmdbug.routine_exit();" + debug_lf;
  /*
    TOKEN_KEYWORD_CREATE used to be in this list, but I removed it.
    Todo: Perhaps CREATE TABLE AS SELECT could be okay though.
    Currently it doesn't matter because we check everything.
  */
  //if ((statement_type == TOKEN_KEYWORD_CALL)
  // || (statement_type == TOKEN_KEYWORD_CASE)
  // || (statement_type == TOKEN_KEYWORD_DECLARE)
  // || (statement_type == TOKEN_KEYWORD_DELETE)
  // || (statement_type == TOKEN_KEYWORD_DO)
  // || (statement_type == TOKEN_KEYWORD_ELSEIF)
  // || (statement_type == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT)
  // || (statement_type == TOKEN_KEYWORD_IF)
  // || (statement_type == TOKEN_KEYWORD_INSERT)
  // || (statement_type == TOKEN_KEYWORD_REPLACE)
  // || (statement_type == TOKEN_KEYWORD_RETURN)
  // || (statement_type == TOKEN_KEYWORD_SELECT)
  // || (statement_type == TOKEN_KEYWORD_SET)
  // || (statement_type == TOKEN_KEYWORD_UNTIL)
  // || (statement_type == TOKEN_KEYWORD_WHILE))
  //  statement_might_contain_routine_invocation= true;
  for (int i= i_of_statement_start; main_token_lengths[i] != 0; ++i)
  {
    QString d= text.mid(main_token_offsets[i], main_token_lengths[i]);

    /*
      special handling of BEGIN NOT ATOMIC -- only output BEGIN
      looks like MariaDB has a bug with "label: BEGIN NOT ATOMIC"
    */
    if (statement_type == TOKEN_KEYWORD_BEGIN)
    {
      int m;
      for (m= i_of_statement_start; m <= v_token_number_of_last_token; ++m)
      {
        if (main_token_lengths[m] == 0) break; /* should be an assert? */
        if (main_token_types[m] == TOKEN_KEYWORD_ATOMIC)
        {

          if (setup_append(d, text, i)) return 1;
          return 0;
        }
      }
    }

    int reftype= main_token_reftypes[i];
    if ((reftype == TOKEN_REFTYPE_FUNCTION)
     || (reftype == TOKEN_REFTYPE_PROCEDURE)
     || (reftype == TOKEN_REFTYPE_FUNCTION_OR_PROCEDURE))
    {
      QString tmp_schema_name= "";
      if (i > 2)
      {
        QString d= text.mid(main_token_offsets[i-1], main_token_lengths[i-1]);
        if (d == ".")
        {
          if (main_token_reftypes[i-2] == TOKEN_REFTYPE_DATABASE)
          {
            tmp_schema_name= text.mid(main_token_offsets[i-2], main_token_lengths[i-2]);
          }
        }
      }
      if (tmp_schema_name == "")
      {
        if (routine_number >= debug_routine_list_schemas.count()) /* pseudo-assert */
        {
          debug_error((char*)"bad routine_number");
          return 1;
        }
        tmp_schema_name= debug_routine_list_schemas.at(routine_number);
      }

      QString c_routine_name= setup_add_delimiters(d);
      QString c_schema_name= setup_add_delimiters(tmp_schema_name);

      /* Todo: What about TOKEN_REFTYPE_FUNCTION_OR_VARIABLE? */
      /* Todo: Are you sure hparse is catching this? */
      /* Todo: you're failing to check whether it's 'P' or 'F' */
      for (int i= 0; i < debug_routine_list_names.count(); ++i)
      {
        QString d_routine_name= debug_routine_list_names.at(i);
        QString d_schema_name= debug_routine_list_schemas.at(i);
        d_routine_name= setup_add_delimiters(d_routine_name);
        d_schema_name= setup_add_delimiters(d_schema_name);
        if ((QString::compare(c_routine_name, d_routine_name, Qt::CaseInsensitive) == 0)
         && (QString::compare(c_schema_name, d_schema_name, Qt::CaseInsensitive) == 0))
        {
          d= debug_routine_list_surrogates.at(i);
        }
      }
    }
    /* Todo: Why are you dumping d but not schema? */
    if (setup_append(d, text, i)) return 1;
    if (i == v_token_number_of_last_token) break;
  }
  return 0;
}

/* Generate: "statement text" but without any changes or special handling.
   This is for "if (statement is being debugged) is false" */
/* Todo: an assert that v_token_number_of_last_token is reasonable. */
/* Todo: copy line feeds and indentation of the original */
int MainWindow::setup_generate_statement_text_as_is(int i_of_statement_start,
                                                     QString text,
                                                     int v_token_number_of_last_token)
{
  int i;
  QString d;
  debug_v_g= debug_v_g + debug_lf;
  i= v_token_number_of_last_token;
  d= text.mid(main_token_offsets[i_of_statement_start],
              (main_token_offsets[i] - main_token_offsets[i_of_statement_start]) + main_token_lengths[i]);
  if (setup_append(d, text, i)) return 1;
  return 0;
}
#endif //if (OCELOT_MYSQL_DEBUGGER == 1)

/*
  clf stands for create lua function. All its sub-functions begin with clf_.
  If input is CREATE LUA PROCEDURE or CREATE LUA FUNCTION,
  we generate a Lua function that would do the same thing.
  Called from execute_client_statement().
  It works only if syntax checking is on and sql mode is not Oracle.
  Re labels: see clf_label
  Re comments:
    We preserve them inside box.execute([[...]]). Outside, block comment is --[[]], -- comment is unchanged
    Beware: we do lots of iterating through the tokens, usually it should not be with ++ unless comments are skipped.
  Re semicolons: They're often unnecessary in Lua but we preserve them when we can.
  Re object names: If they're within ""s we strip the ""s and output after making pretty, else we output upper().
  Re variables:
    For "DECLARE x INT" the Lua name is X.
    When using in an SQL expression, we don't replace with "CAST(? AS data_type)", we do put Lua name in parameter list
    When using as target of SET, replace with lua_name = box.execute([[SELECT (expression);]])
  Re other kinds of DECLARE besides DECLARE variables:
    No support, we're working on it
  Re BEGIN:
        You can LEAVE from a BEGIN, or have an error that forces leave from begin.
        Option 1: a loop that you break from: while true do ... break; end
                  However, "break" won't work right if we're trying to exit from begin...while...end-while...end,
                  you'd only break out of the while, so you have to hve goto past-end anyway.
        Option 2: do...end (what we chose). it doesn't confuse (possibly a loop would be confusing)
                  but all Lua statements for getting out of the loop have to be goto past-end,
                  unless it's the last statement.
  Re conditions:
       For IF and UNTIL and WHILE, the condition checking is according to SQL logic,
       and might contain declared variables, so we pass the condition to a SELECT and see if it returns true.
        After WHILE etc. we will have a condition, which we will pass to SQL, but it isn't the statement end.
        There is a check here whether executing the SELECT causes an error, but that is okay because
        sql_execute() is supposed to return nil when there is an error, so the condition will not be true,
        so we will end up after the END, and conditions do get checked after END (I hope).
  Todo: add recursion for all flow-control statements so you can handle IF within IF
  Todo: For LEAVE or ITERATE, check that label exists and goto will work.
        Lua goto might fail if it is over a local declare.
        There is no check in hparse whether a target exists, I think.
        Unlike DB2, we won't allow ITERATE or LEAVE to jump out of a handler because each handler has its own function.
*/

int clfi; /* In clf() and its offspring, this is the index for main_token_xxx lists */
QString clf_parameter_list;
int clf_last_token; /* maybe a better name would be i_of_last_token */
QString clf_output_final;

int handler_count;
int *handler_starts;
int *handler_code_ends;
int *handler_scope_ends;
int *handler_begin_of_declares; /* to BEGIN or to label preceding BEGIN */
QString sql_execute_starter;
QString sql_execute_ender;

void MainWindow::clf(QString text)
{
  log("clf start", 90);
  clf_output_final= "";
  QString clf_output_main_function= "";
  clf_last_token= main_token_number + main_token_count_in_statement;
  //QString indent_string;

  /* Preliminary error checks. */
  if (((ocelot_statement_syntax_checker.toInt()) & (FLAG_FOR_HIGHLIGHTS | FLAG_FOR_ERRORS)) != (FLAG_FOR_HIGHLIGHTS | FLAG_FOR_ERRORS))
  {
    clf_output_final= "Sorry, we cannot handle this statement unless ocelot_statement_syntax_checker flags are on.";
    goto ret;
  }
  if ((hparse_errno != 0) || (hparse_errno_count != 0))
  {
    clf_output_final= "Sorry, we cannot handle this statement if the syntax checker thinks there is a problem.";
    goto ret;
  }
  if ((connections_dbms[0] == DBMS_MARIADB) && ((hparse_dbms_mask & FLAG_VERSION_PLSQL) != 0))
  {
    clf_output_final= "Sorry, we cannot handle procedures when sql_mode is for PL/SQL (e.g. oracle + mariadb) at this time.";
    goto ret;
  }
  if (ocelot_delimiter_str != ";")
  {
    clf_output_final= "Sorry, we cannot handle procedures when the delimiter is something other than ; (semicolon) at this time.";
    goto ret;
  }
  if ((connections_dbms[0] != DBMS_TARANTOOL) && (sql_mode_ansi_quotes == false))
  {
    clf_output_final= "Sorry, we do not handle procedures unless sql_mode = ansi_quotes is set, at this time.";
    goto ret;
  }
  /* Usually starter="sql_execute([[", sql_execute_ender="]]". But we might change to [=[ ... ]=] etc. */
  if (clf_make_sql_execute_starter_and_ender(text, &clf_output_final) == false) goto ret;

  /* CREATE PROCEDURE|FUNCTION name () --> function name () */
  for (clfi= main_token_number;
       /* Todo: check: how reliable is clf_last_token? */
       ((clfi < clf_last_token) && (main_token_lengths[clfi] != 0));
       ++clfi)
  {
    if ((main_token_reftypes[clfi] == TOKEN_REFTYPE_PROCEDURE)
       || (main_token_reftypes[clfi] == TOKEN_REFTYPE_FUNCTION))
    {
      clf_output_main_function= "function ";
      QString routine_name= clf_v(text, clfi, TOKEN_REFTYPE_PROCEDURE);
      clf_output_main_function= clf_output_main_function + routine_name;
      clf_output_main_function= clf_output_main_function + "(";
      break;
    }
  }
  {
    int parentheses_count= 0;
    int parameter_count= 0;
    while ((main_token_lengths[clfi] != 0) && (clfi < clf_last_token))
    {
      QString d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);
      if (d == "(") ++parentheses_count;
      if (d == ")")
      {
        --parentheses_count;
        if (parentheses_count == 0) break;
      }

      if ((main_token_types[clfi] == TOKEN_KEYWORD_INOUT) || (main_token_types[clfi] == TOKEN_KEYWORD_OUT))
      {
        clf_output_final= "Sorry, we do not support OUT or INOUT parameters at this time";
        goto ret;
      }

      if (main_token_reftypes[clfi] == TOKEN_REFTYPE_PARAMETER_DEFINE)
      {
        if (parameter_count > 0) clf_output_main_function= clf_output_main_function + ",";
        clf_output_main_function= clf_output_main_function + clf_v(text, clfi, TOKEN_REFTYPE_PARAMETER_DEFINE);
        ++parameter_count;
      }
      ++clfi;
    }
  }
  clf_output_main_function= clf_output_main_function + ")";
  clf_dump_whitespace(text, &clf_output_main_function);
  ++clfi;

  clf_make_sql_execute_function(&clf_output_main_function);

  /* clf_handler_list() creates handler_begin_of_declares[] etc. so after it you should not say goto ret. */
  if (clf_handler_list(text, main_token_number, clf_last_token, &clf_output_final) == false) goto ret;

  if (clf_block(text, 999999, &clf_output_main_function) == 1) clf_output_final= clf_output_main_function;
  else clf_output_final= clf_output_final + clf_output_main_function;

  if (handler_count > 0)
  {
    delete []handler_begin_of_declares;
    delete []handler_scope_ends;
    delete []handler_code_ends;
    delete []handler_starts;
  }
ret:
  /* Similar to how we display Help meessages. */
  Message_box *message_box;
  /* Don't use width=960 if screen width is smaller, e.g. on a VGA screen. */
#if (QT_VERSION >= 0x50000)
  QScreen *screen= QGuiApplication::primaryScreen();
  int desktop_width= screen->availableGeometry().width();
#else
  QDesktopWidget desktop;
  int desktop_width= desktop.availableGeometry().width();
#endif
  if (desktop_width > (960 + 50)) message_box= new Message_box("Result", clf_output_final, 960, "", er_strings[er_off + ER_OK], "", this);
  else message_box= new Message_box("Result", clf_output_final, desktop_width - 50, "", er_strings[er_off + ER_OK], "", this);
  message_box->exec();
  delete message_box;
  log("clf end", 90);
}

/* Beware recursion -- we aren't doing it yet, but when we do, if (clf_block()==1) then return 1; */
int MainWindow::clf_block(QString text, int i_of_end_of_handler, QString *clf_output)
{
  int token_type; /* warning: there is also a function named token_type() */
  int begin_count= 0;

  for (/* clfi= clfi */;
       ((clfi < clf_last_token) && (main_token_lengths[clfi] != 0));
       ++clfi)
  {
    if (clfi >= i_of_end_of_handler)
    {
      return 0;
    }

    token_type= main_token_types[clfi];
    QString d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);

    /* Dump whatever is between this token and last token, which presumably is whitespace */
    /* Similar calculation is in clfdw() but that is for inside the statement, this is outside */
    /* Todo: maybe call clf_dump_whitespace() instead. */
    if (clfi > 0)
    {
      QString d2= text.mid(main_token_offsets[clfi - 1] + main_token_lengths[clfi - 1],
                    main_token_offsets[clfi] - (main_token_offsets[clfi - 1] + main_token_lengths[clfi - 1]));
      *clf_output= *clf_output + d2;
    }

    /* Todo: don't you want to output the label, at least in a comment? */
    if (main_token_reftypes[clfi] == TOKEN_REFTYPE_LABEL_DEFINE)
    {
      /* Todo: If there are two labels in a row, return error (we could handle them but don't). */
      /*       But this isn't necessary at the moment because our syntax checker won't accept them anyway. */
      clfi= next_token(clfi); /* skip to the ":" */
      continue;
    }

    if (main_token_types[clfi] == TOKEN_TYPE_COMMENT_WITH_SLASH)
    {
      *clf_output= *clf_output + "--[[" + d + "]]";
      continue;
    }

    if (main_token_types[clfi] == TOKEN_TYPE_COMMENT_WITH_MINUS)
    {
      *clf_output= *clf_output + d;
      continue;
    }

    if (main_token_types[clfi] == TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE)
    {
      *clf_output= *clf_output + "--" + d;
      continue;
    }

    /*
      Since it's not a label or comment, we'll presume it's a statement start
      i.e. ((main_token_flags[clfi] & TOKEN_FLAG_IS_START_STATEMENT) == 0)
      or it might be an operator such as ";"
    */

    QString indent_string= clf_indent(clf_output);

    if (token_type == TOKEN_KEYWORD_BEGIN)
    {
      //Beware: BEGIN might be inside DECLARE ... HANDLER
      if (main_token_types[clfi] == TOKEN_KEYWORD_NOT) clfi= next_i(clfi, 2); /* Skip [NOT ATOMIC] */
      ++begin_count;
      *clf_output= *clf_output + "do "; /* alternative = while true do ... break end */
      continue;
    }

    if (token_type == TOKEN_KEYWORD_CASE)
    {
      *clf_output= "Sorry, we do not handle CASE statements at this time.";
      return 1;
    }

    if (token_type == TOKEN_KEYWORD_CLOSE)
    {
      /* Todo: We do not check if it is not open, maybe that is an error */
      clfi= next_i(clfi, 1); /* skip to cursor name */
      if (clf_check_reference(text, clfi, TOKEN_REFTYPE_CURSOR_DEFINE, clf_output) == false) return 1;
      int i_of_cursor_name= main_token_pointers[clfi];
      /* Following lines are similar to initialization done for TOKEN_KEYWORD_DECLARE. */
      QString cursor_name;
      cursor_name= clf_v(text, i_of_cursor_name, TOKEN_REFTYPE_CURSOR_DEFINE);
      *clf_output= *clf_output + "\n" + indent_string + cursor_name + "= {};";
      *clf_output= *clf_output + "\n" + indent_string + cursor_name + "_OFFSET = 0;";
      *clf_output= *clf_output + "\n" + indent_string + cursor_name + "_STATUS = 'not open';";
      /* As long as CLOSE doesn't cause a condition to change, we won't need to call clf_find_handler */
      clf_handler_end(clfi, clf_output);
      continue;
    }

    if (token_type == TOKEN_KEYWORD_DECLARE)
    {
      int i_of_declare= clfi;
      int i2= next_token(clfi); i2= next_token(i2);
      if (main_token_types[i2] == TOKEN_KEYWORD_HANDLER)
      {
        *clf_output= *clf_output + "local function " + clf_handler_name(i_of_declare) + "()";
        clfi= i2;
        /* If next is BEGIN/LOOP/etc. then handler end is past the next END, otherwise it is past next statement */
        /* Skip to statement start (past "FOR conditions") */
        int i3;
        for (i3= clfi;; ++i3) /* todo: error check! */
        {
          if ((main_token_flags[i3] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
          {
            clfi= i3 - 1;
            break;
          }
        }
        /* So for example, we're looking at FOUND. By continuing, we should be getting handler statement #1. */
        continue;
      }

      if (main_token_types[i2] == TOKEN_KEYWORD_CURSOR)
      {
        int i_of_cursor_name= next_i(i2, -1);
        QString cursor_name= clf_v(text, i_of_cursor_name, TOKEN_REFTYPE_CURSOR_DEFINE);
        *clf_output= *clf_output +               + "local " + cursor_name + " = {};\n";
        *clf_output= *clf_output + indent_string + "local " + cursor_name + "_OFFSET = 0;\n";
        *clf_output= *clf_output + indent_string + "local " + cursor_name + "_STATUS = 'not open';\n";
        continue;
      }
      if (main_token_types[next_i(i2, 1)] == TOKEN_KEYWORD_CONDITION)
      {
        *clf_output= "Sorry, DECLARE ... CONDITION is not supported at this time.\n";
        return 1;
      }
      /* It's not DECLARE ... CONDITION|CURSOR|HANDLER. So it must be DECLARE ... variable. */
      while ((clfi < clf_last_token) && (main_token_lengths[clfi] != 0))
      {
        QString d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);
        if (main_token_reftypes[clfi] == TOKEN_REFTYPE_VARIABLE_DEFINE)
        {
          QString variable_name= clf_v(text, clfi, TOKEN_REFTYPE_VARIABLE_DEFINE);
          *clf_output= *clf_output + "local ";
          *clf_output= *clf_output + variable_name;
          /* Look for DEFAULT clause. It might apply for multiple locals, e.g. DECLARE x,y,z INT DEFAULT 5; */
          int saved_clfi= clfi;
          while ((clfi < clf_last_token) && (main_token_lengths[clfi] != 0))
          {
            QString d2= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);
            if (d2 == ";") break;
            if (main_token_types[clfi] == TOKEN_KEYWORD_DEFAULT)
            {
              /* This looks much like SET. Whats between DEFAULT and ; is the expression to assign to variable. */
              clfi= next_i(clfi, 1);
              *clf_output= *clf_output + "; " + sql_execute_starter + "SELECT ";
              if (clfds(text, TOKEN_KEYWORD_DEFAULT, indent_string, "", clf_output) == false) return false;
              *clf_output= *clf_output + "; " + variable_name + " = sqlresult[1][1]";
              break;
            }
            ++clfi;
          }
          clfi= saved_clfi;

          *clf_output= *clf_output + ";";
        }
        if (d == ";") { break; }
        ++clfi;
      }
      clf_handler_end(clfi, clf_output); /* DECLARE statement ends handler? Foolish but possible. */
      continue;
    }

    if (token_type == TOKEN_KEYWORD_ELSE)
    {
      *clf_output= *clf_output + "else ";
      continue;
    }

    if (token_type == TOKEN_KEYWORD_ELSEIF)
    {
      *clf_output= "Sorry, we do not handle ELSEIF clauses at this time.";
      return 1;
    }

    if (token_type == TOKEN_KEYWORD_END)
    {
      QString label_1= clf_label(text, "_1");
      QString label_2= clf_label(text, "_2");
      *clf_output= *clf_output + label_1;
      /* Todo: END CASE? Not necessary as long as we don't support CASE */
      int i_of_start_of_statement= clfi;
      int i_of_begin= main_token_pointers[clfi]; /* to BEGIN or to label preceding BEGIN */
      clfi= next_token(clfi);
      int n= main_token_types[clfi];

      if (n == TOKEN_KEYWORD_IF)
      {
        *clf_output= *clf_output + "end;";
      }
      else if (n == TOKEN_KEYWORD_LOOP)
      {
        *clf_output= *clf_output + "end;";
      }
      else if (n == TOKEN_KEYWORD_REPEAT)
      {
        *clf_output= *clf_output + "end;";
      }
      else if (n == TOKEN_KEYWORD_WHILE)
      {
        *clf_output= *clf_output + "end;";
      }
      else /* Nothing after? Must be END of BEGIN ... END */
      {
        *clf_output= *clf_output + "end;";
        /* We add a label = "::end_n:"" so if there is an EXIT handler it knows where to goto */
        /* Even if there's no EXIT handler we might jump out of a BEGIN/END. Also you can LEAVE a BEGIN but it has a different label. */
        *clf_output= *clf_output + " ::end_" + QString::number(i_of_begin) + ":: ";
        --begin_count;
      }
//      clf_dump_whitespace(text, clf_output); /* This dumps as far as ";" but could get mixed up if delimiter wasn't ";". */
//      clfi= next_i(clfi, 1);
      *clf_output= *clf_output + label_2;

//      if (begin_count != 0)

      {
        if (clf_find_handler(text, clf_output, indent_string, i_of_start_of_statement + 1, token_type) == false) return false;
        clf_handler_end(clfi, clf_output);
      }
      continue;
    }

    if (token_type == TOKEN_KEYWORD_FETCH)
    {
      /* Todo: check if too many or too few columns */
      /* Todo: There is probably some resemblance to what we do with SET, see if you can merge code. */
      int i_of_start_of_statement= clfi;
      clfi= next_i(clfi, 1); /* skip to cursor name */
      if (clf_check_reference(text, clfi, TOKEN_REFTYPE_CURSOR_DEFINE, clf_output) == false) return 1;
      int i_of_cursor_name= main_token_pointers[clfi];
      QString cursor_name;
      cursor_name= clf_v(text, i_of_cursor_name, TOKEN_REFTYPE_CURSOR_DEFINE);
      /* If the cursor is not open, that's an error */
      *clf_output= *clf_output + "if " + cursor_name + "_STATUS ~= 'open' then sqlstate = '07000';";
      *clf_output= *clf_output + "\n" + indent_string + "else if " + cursor_name + "_OFFSET >= #" + cursor_name + " then sqlstate = '02000';";
      *clf_output= *clf_output + "\n" + indent_string + "else do";
      *clf_output= *clf_output + "\n" + indent_string + "   " + cursor_name + "_OFFSET = " + cursor_name + "_OFFSET + 1;";
      /* Some of the following lines are similar to initialization done for TOKEN_KEYWORD_DECLARE. */
      int column_number= 1;
      for (clfi= clfi + 1;; ++clfi)
      {
        if (main_token_types[clfi] == TOKEN_TYPE_OPERATOR) break; /* ";" ends FETCH, perhaps there is no INTO */
        if (hparse_f_is_identifier(main_token_types[clfi]) == true)
        {
          if (clf_check_reference(text, clfi, TOKEN_REFTYPE_VARIABLE_DEFINE, clf_output) == false) return 1;
          QString variable_name= clf_v(text, main_token_pointers[clfi], TOKEN_REFTYPE_VARIABLE_DEFINE);
          *clf_output= *clf_output + "\n" + indent_string + "    " + variable_name + " = " + cursor_name;
          *clf_output= *clf_output + "[";
          *clf_output= *clf_output + cursor_name + "_OFFSET][";
          *clf_output= *clf_output + QString::number(column_number);
          *clf_output= *clf_output + "];";
          ++column_number;
        }
      }
      *clf_output= *clf_output + "\n" + indent_string + "end; end; end;";
      if (clf_find_handler(text, clf_output, indent_string, i_of_start_of_statement, TOKEN_KEYWORD_FETCH) == false) return false;
      clf_handler_end(clfi, clf_output);
      continue;
    }

    if (token_type == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT)
    {
      *clf_output= "Sorry, we do not handle FOR statements at this time.";
      return 1;
    }

    if (token_type == TOKEN_KEYWORD_GET)
    {
      //I doubt that we can support GET DIAGNOSTICS
      /* Todo: If GET DIAGNOSTICS into an error message of a certain type, we might support it in Tarantool */
      /* Todo: error check: assignment to declared variable (though we should try to support it someday) */
      *clf_output= "Sorry, we do not handle GET statements at this time.";
      return 1;
    }

    if (token_type == TOKEN_KEYWORD_IF)
    {
    }

    if (token_type == TOKEN_KEYWORD_ITERATE)
    {
      *clf_output= *clf_output + "goto ";
      clfi= next_token(clfi);
      /* Todo: Check if label was defined. main_token_pointers[clfi] isn't pointing to it. */
      QString d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]).toUpper();
      *clf_output= *clf_output + d + "_1;";
      /* no need to call clf_find_handler() */
      clf_handler_end(clfi, clf_output);
      continue;
    }

    if (token_type == TOKEN_KEYWORD_LEAVE) /* See comment = Re labels */
    {
      *clf_output= *clf_output + "goto ";
      clfi= next_token(clfi);
      /* Todo: Check if label was defined. main_token_pointers[clfi] isn't pointing to it. */
      QString d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]).toUpper();
      *clf_output= *clf_output + d + "_2;";
      /* no need to call clf_find_handler() */
      clf_handler_end(clfi, clf_output);
      continue;
    }

    if (token_type == TOKEN_KEYWORD_LOOP)
    {
      *clf_output= *clf_output + "while true do ";
      continue;
    }

    if (token_type == TOKEN_KEYWORD_OPEN)
    {
     /* Todo: check if it is already open, maybe that is an error */
      clfi= next_i(clfi, 1); /* skip to cursor name */
      if (clf_check_reference(text, clfi, TOKEN_REFTYPE_CURSOR_DEFINE, clf_output) == false) return 1;
      int i_of_cursor_name= main_token_pointers[clfi];

      assert(main_token_reftypes[i_of_cursor_name] == TOKEN_REFTYPE_CURSOR_DEFINE);

      QString cursor_name = clf_v(text, i_of_cursor_name, TOKEN_REFTYPE_CURSOR_DEFINE);

      int saved_clfi= clfi;

      for (clfi= i_of_cursor_name;; ++clfi) /* skip past "CURSOR FOR", skipping comments */
      {
        clf_dump_whitespace(text, clf_output);
        if (main_token_types[clfi] == TOKEN_KEYWORD_FOR) break;
      }
      clfi= next_i(clfi, 1);

      *clf_output= *clf_output + cursor_name + " = ";

      QString indent_string_for_open= clf_indent(clf_output);
      *clf_output= *clf_output + sql_execute_starter;
      *clf_output= *clf_output + "\n" + indent_string_for_open;
      if (clfds(text, TOKEN_KEYWORD_OPEN, indent_string_for_open, "", clf_output) == false) return false;
      clfi= saved_clfi;

      *clf_output= *clf_output + "\n" + indent_string_for_open + "if string.sub(sqlstate,1,2) == '00' or string.sub(sqlstate,1,2) == '02' then";
      *clf_output= *clf_output + "\n" + indent_string + cursor_name + "_OFFSET = 0;";
      *clf_output= *clf_output + "\n" + indent_string + cursor_name + "_STATUS = 'open';";
      *clf_output= *clf_output + "\n" + indent_string + "end;\n";
      /* todo: clf_dump_whitespace? */
      clfi= next_i(clfi, 1); /* skip to ";" */
      /* clfds should have called clf_find_handler already */
      clf_handler_end(clfi, clf_output);
      continue;
    }

    if (token_type == TOKEN_KEYWORD_REPEAT)
    {
      *clf_output= *clf_output + "repeat ";
      continue;
    }

    if (token_type == TOKEN_KEYWORD_RESIGNAL)
    {
      *clf_output= "Sorry, we do not support RESIGNAL statements at this time.";
      return 1;
    }

    if (token_type == TOKEN_KEYWORD_RETURN)
    {
      clf_parameter_list= ""; /* todo: see whether this is necessary */
      if (clf_internal_select(TOKEN_KEYWORD_RETURN, text, clf_output) == false) return false;
      *clf_output= *clf_output + " return sqlresult[1][1];";
      continue;
    }

    if (token_type == TOKEN_KEYWORD_SELECT)
    {
      /* Todo: Maybe SELECT should display, currently it just finds the result set and then ignores it */
      /* SELECT INTO declared-variable won't work. Todo: We should support it the same way we do FETCH. */
      bool into_seen= false;
      for (int i= clfi; i < clf_last_token; ++i)
      {
        QString d= text.mid(main_token_offsets[i], main_token_lengths[i]);
        if (d == ";") break;
        if (main_token_types[i] == TOKEN_KEYWORD_INTO) { into_seen= true; continue; }
        if (into_seen == true)
        {
          /* If it's the end of the INTO clause, we've found no problems. */
          if (((main_token_flags[clfi] & TOKEN_FLAG_IS_START_CLAUSE) != 0)
           || (main_token_types[i] == TOKEN_KEYWORD_FROM))
            break;
          /* If it's a declared variable, i.e. not @variable (which should be TOKEN_REFTYPE_USER_VARIABLE), problem. */
          if ((main_token_reftypes[i] == TOKEN_REFTYPE_VARIABLE_REFER)
           || (main_token_reftypes[i] == TOKEN_REFTYPE_PARAMETER_REFER))
          {
            *clf_output= "Sorry, SELECT INTO declared-variable is not supported at this time.";
            return 1;
          }
        }
      }
    }

    if (token_type == TOKEN_KEYWORD_SET)
    {
      if (clf_set(text, indent_string, clf_output) == false) return 1;
      /* TODO: I wonder how many other statements hae 'continue' without calling clf_handler_end. */
      /* clfds should have called clf_find_handler already */
      clf_handler_end(clfi, clf_output);
      continue;
    }

    if (token_type == TOKEN_KEYWORD_SIGNAL)
    {
      int i_of_start_of_statement= clfi;
      clfi= next_i(clfi, 2);
      QString d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);
      clfi= next_i(clfi, 1);
      QString d2= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);
      if (d2 != ";")
      {
        *clf_output= "Sorry, the only SIGNAL statement that we support at this time is SIGNAL SQLSTATE sqlstate_value.";
        return 1;
      }
      *clf_output= *clf_output + "sqlstate = " + d + ";";
      if (clf_find_handler(text, clf_output, indent_string, i_of_start_of_statement, token_type) == false) return false;
      clf_handler_end(clfi, clf_output);
      continue;
    }

    if (token_type == TOKEN_KEYWORD_UNTIL)
    {
    }

    if (token_type == TOKEN_KEYWORD_UPDATE)
    {
      /* We don't allow assigning to declared variables in UPDATE. Todo: get inspired by how we do SET. */
      for (int i= clfi; i < clf_last_token; ++i)
      {
        if ((main_token_types[i] == TOKEN_KEYWORD_WHERE)
         || (main_token_types[i] == TOKEN_KEYWORD_ORDER)
         || (main_token_types[i] == TOKEN_KEYWORD_LIMIT))
          break;
        QString d= text.mid(main_token_offsets[i], main_token_lengths[i]);
        if (d == ";") break;
        int i2= next_i(i, -1);
        d= text.mid(main_token_offsets[i2], main_token_lengths[i2]);
        if ((main_token_types[i2] == TOKEN_KEYWORD_SET)
         || (d == ","))
        {
          if ((main_token_reftypes[i] == TOKEN_REFTYPE_PARAMETER_REFER)
           || (main_token_reftypes[i] == TOKEN_REFTYPE_VARIABLE_REFER))
          {
            int i3= next_i(i, +1);
            d= text.mid(main_token_offsets[i3], main_token_lengths[i3]);
            if (d == "=")
            {
              *clf_output= "Sorry, we do not handle assignments to variables in UPDATE statements at this time.";
              return 1;
              }
          }
        }
      }
    }

    if (token_type == TOKEN_KEYWORD_WHILE)
    {
    }

    /* todo: probably this "if" is unnecessary now, we want to check earlier */
    if ((main_token_flags[clfi] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
    {
      /*
        Usually our result is box.execute([=[statement]=]); but special things can happen, e.g.
        if it's RETURN we want sql_execute(); return sqlresult[1][1];
      */
      clf_parameter_list= ""; /* Todo: probably this is the wrong place to initialize */
      if (token_type == TOKEN_KEYWORD_IF) *clf_output= *clf_output + "if ";
      if (token_type == TOKEN_KEYWORD_UNTIL) *clf_output= *clf_output + "until ";
      if (token_type == TOKEN_KEYWORD_WHILE) *clf_output= *clf_output + "while ";
      if ((token_type == TOKEN_KEYWORD_IF)
       || (token_type == TOKEN_KEYWORD_UNTIL)
       || (token_type == TOKEN_KEYWORD_WHILE))
      {
        if (clf_internal_select(token_type, text, clf_output) == false) return false;
      }
      else
      {
        *clf_output= *clf_output + sql_execute_starter;
        *clf_output= *clf_output + "\n" + indent_string;
        if (clfds(text, token_type, indent_string, "", clf_output) == false) return false;
      }
      clf_handler_end(clfi, clf_output); /*Sometimes this useless because we're not at end of a statement. */
    }
  }

  /* Todo: make sure this is indented the same as the CREATE statement. */
  *clf_output= *clf_output + "\nend;";
  return 0;
}

/*
  An internal select is a query that we construct in order to get sql_execute to return one row with one value.
  We want it for conditions, e.g. WHILE 0 = 0 should cause sql_execute([[SELECT 0 = 0;]],{});
  Also we want it for statements that assign to declared variables. At first, that means SET statements.
  Usually our indenting is where the SQL statement begins, but in this case it's where the condition begins.
  Todo: use VALUES rather than SELECT?
  Todo: don't pass ; unless you're really sure there is no ; i.e. it is a WHILE/IF conditional, not SET or RETURN or UNTIL 
*/
bool MainWindow::clf_internal_select(int token_type, QString text, QString *clf_output)
{
  QString indent_string= clf_indent(clf_output);
  *clf_output= *clf_output + sql_execute_starter;
  *clf_output= *clf_output + "\n" + indent_string;
  *clf_output= *clf_output + "SELECT "; clfi= next_token(clfi);
  if (clfds(text, token_type, indent_string, ";", clf_output) == false) return false;
  return true;
}

/*
  Pass: i = token number of a reference to a variable, parameter, or cursor.
  Return: 0 = ok, 1 = bad and *clf_output has an error description
  Usually this probably means that the user typed in a nonexistent name.
  If we had parsed perfectly earlier, this check would not be necessary.
  Todo: No error if name begins with @ (MySQL/MariaDB)
  Todo: Check if offset too great. If so, status = 'not found' and clf_find_handler() (I forget what this means)
*/
bool MainWindow::clf_check_reference(QString text, int i, int reftype, QString *clf_output)
{
  bool is_ok= true;
  int j= main_token_pointers[i];
  if ((j == 0) || (j > clf_last_token)) is_ok= false; /* actually j > clf_last_token could be an assert */
  else if (reftype == TOKEN_REFTYPE_VARIABLE_DEFINE)
  {
    if ((main_token_reftypes[j] != reftype) && (main_token_reftypes[j] != TOKEN_REFTYPE_PARAMETER_DEFINE))
      is_ok= false;
  }
  else if (main_token_reftypes[j] != reftype) is_ok= false;
  if (is_ok == false)
  {
    QString d= text.mid(main_token_offsets[i], main_token_lengths[i]);
    QString type_name;
    if (reftype == TOKEN_REFTYPE_VARIABLE_DEFINE) type_name= " variable-or-parameter ";
    else if (reftype == TOKEN_REFTYPE_CURSOR_DEFINE) type_name= " cursor ";
    else type_name= "";
    *clf_output= "Sorry, cannot find the declaration of" + type_name + d;
  }
  return is_ok;
}

/* Todo: parameter #1 doesn't seem to be of statement, it should be of ;, so consider changing the name. */
void MainWindow::clf_handler_end(int i_of_statement, QString *clf_output)
{
  for (int i= 0; i < handler_count; ++i)
  {
    if (i_of_statement == handler_code_ends[i]) *clf_output= *clf_output + " end;";
  }
}

/*
  Dump statements
  Sometimes there are tokens that we must stop at:
    ";" always (todo: actually it should be delimiter)
    "DO" if it is WHILE ... DO (Todo: check: can DO ever appear in an expression?)
    "END" if it is UNTIL ... END (Todo: check: can END ever appear in an expression, other than CASE where it is ok?)
    "THEN" if it is IF ... THEN (THEN can appear in a CASE expression, that's why we have cases_count)
    "," if it is SET variable=expression , variable_expression
  The start of the statement has already been dumped.
*/
bool MainWindow::clfds(QString text, int token_type, QString indent_string, QString terminator, QString *clf_output)
{
  int parentheses_count= 0;
  int cases_count= 0;
  int i_of_start_of_statement= clfi;
  QString d;
  clf_parameter_list= "";
  /* Todo: you need to stop at last_token */
  while ((main_token_lengths[clfi] != 0) && (clfi < clf_last_token))
  while ((clfi < clf_last_token) && (main_token_lengths[clfi] != 0))
  {
    d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]).toUpper();
    if (d == "(") ++parentheses_count;
    if (d == ")") --parentheses_count;
    if (main_token_types[clfi] == TOKEN_KEYWORD_CASE_IN_CASE_EXPRESSION) ++cases_count;
    if (main_token_types[clfi] == TOKEN_KEYWORD_END_IN_CASE_EXPRESSION) --cases_count;
    int current_token_type= main_token_types[clfi];
    if ((parentheses_count == 0) && (cases_count == 0))
    {
      if ((token_type == TOKEN_KEYWORD_SET) && (d == ",")) break;
      if ((token_type == TOKEN_KEYWORD_WHILE) && (current_token_type == TOKEN_KEYWORD_DO)) break;
      if ((token_type == TOKEN_KEYWORD_IF) && (current_token_type == TOKEN_KEYWORD_THEN)) break;
      if (current_token_type == TOKEN_KEYWORD_END) { --clfi; break; }
    }
    if (d == ";") { *clf_output= *clf_output + d; break; }
    if (clfdw(text, clf_output) == false) return false;
    //if (text.mid(main_token_offsets[clfi], main_token_lengths[clfi]) == ";") break;
    ++clfi;
  }

  /* Todo: I still worry that we might get two ;;s at the end of the statement, write a test that ignores spaces. */
  if (terminator == ";")
  {
    if ((clf_output)->right(1) != ";")
      *clf_output= *clf_output + terminator; /* statement terminator is either "" or ";" */
  }

  *clf_output= *clf_output + "\n" + indent_string + sql_execute_ender;
  *clf_output= *clf_output + ",{" + clf_parameter_list + "}";
  clf_parameter_list= "";

  if (token_type == TOKEN_KEYWORD_RETURN) { *clf_output= *clf_output + ");"; return true; }
  if (token_type == TOKEN_KEYWORD_DEFAULT) { *clf_output= *clf_output + ")"; return true; }
  if (token_type == TOKEN_KEYWORD_IF) { *clf_output= *clf_output + ") == true and sqlresult[1][1] == true then "; return true; }
  if (token_type == TOKEN_KEYWORD_WHILE) { *clf_output= *clf_output + ") == true and sqlresult[1][1] == true do "; return true; }
  if (token_type == TOKEN_KEYWORD_SET) *clf_output= *clf_output + ")";
  else if (token_type == TOKEN_KEYWORD_UNTIL) *clf_output= *clf_output + ") == true and sqlresult[1][1] == true ";
  else *clf_output= *clf_output + ");";
  if (clf_find_handler(text, clf_output, indent_string, i_of_start_of_statement, token_type) == false) return false;
  return true;
}

/*
  Dump words
  What I'm really after is:
    For each until endword (we pass endwod = ";" or "DO" or "" ("" means we only do it once)
      Check: is this a variable name? If so, figure out the Lua equivalent.
      Dump
      Dump whatever is between this token and the next token
  Re variable-name:
    We depend on earlier success of hparse_f_variables().
    Lua variable name should be prefix + sql_variable_name (upper?) + token number
  Todo: call this from more places
*/
bool MainWindow::clfdw(QString text, QString *clf_output)
{
  QString d;

  d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);
  if ((main_token_reftypes[clfi] == TOKEN_REFTYPE_PARAMETER_REFER)
   || (main_token_reftypes[clfi] == TOKEN_REFTYPE_VARIABLE_REFER))
  {
    if (clf_check_reference(text, clfi, TOKEN_REFTYPE_VARIABLE_DEFINE, clf_output) == false) return false;
    int j= main_token_pointers[clfi];
    if ((main_token_reftypes[j] == TOKEN_REFTYPE_PARAMETER_DEFINE)
     || (main_token_reftypes[j] == TOKEN_REFTYPE_VARIABLE_DEFINE))
    {
      ;
    }

    /* Add ? to what we pass in box_execute(string...), add variable name to box.execute parameters */
    *clf_output= *clf_output + "?";
    if (clf_parameter_list != "") clf_parameter_list= clf_parameter_list + ", ";
    clf_parameter_list= clf_parameter_list + clf_v(text, main_token_pointers[clfi], TOKEN_REFTYPE_VARIABLE_DEFINE);

  }
  else *clf_output= *clf_output + d;

  clf_dump_whitespace(text, clf_output);
  return true;
}

/*
  Dump whatever is between this word and the next word, unless there is no next word.
  This is whitespace, it isn't important, but we try to preserve it if there are multiple spaces or line feeds.
*/
void MainWindow::clf_dump_whitespace(QString text, QString *clf_output)
{
  if (main_token_lengths[clfi + 1] == 0) return;
  if ((clfi + 1) >= clf_last_token) return;
  QString d= text.mid(main_token_offsets[clfi] + main_token_lengths[clfi],
              main_token_offsets[clfi + 1] - (main_token_offsets[clfi] + main_token_lengths[clfi]));
  *clf_output= *clf_output + d;
}

/*
  Labels
    If the BEGIN|LOOP|REPEAT|WHILE was preceded by "label:", return a Lua label "::LABEL_1::" or "::LABEL_2::".
    We call this when we see END, twice.
    The first time, suffix == "_1", this is for the label that comes before "end".
    The second time, suffix == "_2", this is for the label that comes after "end".
    For ITERATE label; we generate goto LABEL_1", to do the loop again.
    For LEAVE label; we generate "goto LABEL_2", to get out of a loop.
    We depend on main_token_pointers[] which should have been set up during parsing.
    Todo: There might be more than one e.g. user said label1: label2: BEGIN END -- so loop
    Another label type is "end_" + token-number + "::", which is formed for handlers and does not call here.
    The goto statements cause a reference to a label too.
*/
QString MainWindow::clf_label(QString text, QString suffix)
{
  int i= main_token_pointers[clfi];
  if (i == 0) return ""; /* actually this must be soms sort of error */
  if (main_token_reftypes[i] != TOKEN_REFTYPE_LABEL_DEFINE) return ""; /* there are no labels */
  return "::"
          + text.mid(main_token_offsets[i], main_token_lengths[i]).toUpper()
          + suffix
          + "::";
}

/*
  SET
  SET i = sql-expression [, j= sql_expression ...];
  must become
  S_i... = sql_execute([=[sql-expression]].row[1][1];
  S_j... = sql_execute([=[sql-expression]].row[1][1];
  It's complex because expression can contain specials e.g. SET i=(j=5), j= substr(k,1,1);
  Notice we do assignments sequentially.
  This is the only place where we can assign to a variable -- SELECT INTO is unknown.
  Todo: small bug: If it is SET i=1, j = 1; we fail to put out ";" at the end of the first SELECT
  Todo: Sometimes the expression is a literal that Lua can read, e.g. SET i = 1;
        In that case maybe we could say "I=1;" instead of "i=sql_execute([=[SELECT 1;]]" etc.
  Todo: This is not allowing for the chance that sql_execute might fail.
        It would be better to say: if sql_execute() then assign end
*/
bool MainWindow::clf_set(QString text, QString indent_string, QString *clf_output)
{
  QString d;
  QString variable_name;
  for (;;)
  {
    clfi= next_token(clfi); /* skip "SET" or "," */
    /* Surely this is a variable that we are assigning to. */
    if (clf_check_reference(text, clfi, TOKEN_REFTYPE_VARIABLE_DEFINE, clf_output) == false) return false;
    variable_name = clf_v(text, main_token_pointers[clfi], TOKEN_REFTYPE_VARIABLE_DEFINE);
    clfi= next_token(clfi); /* skip variable name */
    if (clf_internal_select(TOKEN_KEYWORD_SET, text, clf_output) == false) return false;
    *clf_output= *clf_output + variable_name + " = sqlresult[1][1];";
    /* repeat if it was ',' */
    d= text.mid(main_token_offsets[clfi], main_token_lengths[clfi]);
    if (d != ",") break;
    *clf_output= *clf_output + "\n" + indent_string;
  }
  return true;
}

/*
  Find out where we are in a line, so we know how many spaces to indent.
  The general aim is: keep the original indent.
  For example we should call this before sql_execute([=[\n, and use it so that the lines are
    sql_execute([=[
    sql-statement
    ]=])
  So another way to put it is: try to indent to wherever sql_execut([=[\n is.
  We should use the indent for all decoration/wrapping, such as "if sqlstate ... handler()".
  Figure out indent at start.
  Whenever you are adding your own decoration/wrapping, \n wrapping \n
  Whenever you are removing (as you do for OPEN/FETCH/CLOSE), keep original text, but in comments. + DECLARE?
  Usually we want the same indenting as in the original i.e. text, but see clf_internal_select().
*/
QString MainWindow::clf_indent(QString *clf_output)
{
  int j= (*clf_output).length();
  int i= j;
  const QChar *ti = (*clf_output).constData();
  for (; i > 0; --i)
  {
    if (*(ti + i) == '\n') break;
  }
  int indent_amount= (j - i) - 1;
  QString indent_string= " ";
  return indent_string.repeated(indent_amount);
}

/*
  After every SQL statement, we check: is there a handler?
  If BEGIN ... BEGIN ... DECLARE ... END statement, the DECLARE is not relevant, skip it.
  There might be multiple handlers that are relevant: exception, not found, specific SQLSTATE, specific number.
  By going backwards, we find the last handler first, which is fine, it's more immediate than handlers above it.
  There are two passes: sqlexception first, then not found. Todo: eventually there will be multiple passes.
  Todo: this can work after a full SQL statement, but not after a snippet as used in WHILE, SET, etc.
  Todo: we're not checking for NOT FOUND if it's TOKEN_KEYWORD_OPEN. Good, but what about other exclusions?
  Put this note somewhere:
    If we have
      BEGIN
        DECLARE HANDLER#1 ...
        non-handler stuff
        BEGIN
          DECLARE HANDLER#2 ...
          non-handler stuff
        END  -- END#1
      END    -- END#2
    The scope of HANDLER#1 is all the way to END#2. But I guess HANDLER#2 won't invoke HANDLER#1.
    Todo: If we have SQLEXCEPTION, SQLWARNING in a higher begin, SQLWARNING in a lower begin won't appear. Okay?
    Todo: allow handler within handler
    Todo: some of the checks here are maybe redundant since we check when making the list (clf_handler_list)
    Todo: Maybe you ought to store the conditions in a list when you make with clf_handler_list()
    Pass 1: specifics, pass 2: sqlexception, pass 3: not found, pass 4: sqlwarning. Avoiding repetition.
    After we dump the handlers, and even if there are no handlers, we still have "if sqlexception goto exit;"
    Yet another exceptional situation:
         If we're within a handler and it's a non-compound statement, we don't want the final
         "if sqlstate... goto" because that would try to jump out of the main begin/end.
         But if it's a compound statement, we do want to jump out because that will goto the end of
         the BEGIN that is inside the handler. That is: DECLARE HANDLER FOR non-compound = no goto,
         DECLARE HANDLER for BEGIN ... END -- goto.
*/
bool MainWindow::clf_find_handler(QString text, QString *clf_output, QString indent_string, int i_of_start_of_statement, int token_type)
{
  QString if_statements= ""; /* A string containing if_statements that we will add to clf_output at the end */
  QString goto_string= "";

  int i_of_begin= clf_find_begin(i_of_start_of_statement); /* = the BEGIN of the current block, if any */

  /* Check that it's not in any handler. We don't call handlers from handlers. Todo: allow, it should be legal. */
  for (int i= 0; i < handler_count; ++i)
  {
    if ((i_of_start_of_statement > handler_starts[i]) && (i_of_start_of_statement <= handler_code_ends[i]))
    {
      if ((i_of_begin != -1) && (i_of_begin >= handler_starts[i])) goto after_handler_calls;
      return true;
    }
  }

  /*
    We'll want to produce "if condition then goto after-end-of-block end" if
    we've just called an EXIT handler, or after we've called all handlers
    (in which case the condition is sqlexception).
    Since BEGIN...END causes a Lua do...end, the goto is unnecessary for the last statement in the block.
    Notice: we goto to get out of the block of the handled statement, not the handler statement
    (sometimes we invoke a handler that is in a higher level, rather than in our own block).
    Todo: reconsider: we wouldn't have to do this if BEGIN...END produced "while true...end", then we'd just dump "break".
  */
  if (i_of_begin != -1)
  {
    int i= i_of_start_of_statement + 1;
    for (;;++i)
    {
      if (i >= clf_last_token) break;
      if ((main_token_types[i] == TOKEN_KEYWORD_END) && (main_token_types[next_i(i, 1)] == TOKEN_TYPE_OPERATOR)) break;
      if ((main_token_flags[i] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
      {
        goto_string= " goto end_" + QString::number(i_of_begin) + ";";
        break;
      }
    }
  }

  for (int pass= 1; pass <= 4; ++pass)
  {
    for (int i= handler_count - 1; i >= 0; --i)
    {
      if (i_of_start_of_statement >= handler_code_ends[i] && (i_of_start_of_statement < handler_scope_ends[i]))
      {
        QString action_after_call= "";
        int j;
        /* In DECLARE ... HANDLER FOR we only care if we see EXIT. Skip to the FOR. */
        for (j= handler_starts[i];; ++j)
        {
          if (main_token_types[j] == TOKEN_KEYWORD_EXIT) action_after_call= goto_string;
          if (main_token_types[j] == TOKEN_KEYWORD_FOR) break;
        }
        bool is_right_pass= false;
        QString status_to_check= "";
        for (j= j + 1;; ++j)
        {
          if (main_token_types[j] == TOKEN_KEYWORD_SQLSTATE)
          {
            j= next_i(j, 1);
            if (main_token_types[j] == TOKEN_KEYWORD_VALUE) j= next_i(j, 1);
            assert(main_token_reftypes[j]== TOKEN_REFTYPE_SQLSTATE);
            QString d= text.mid(main_token_offsets[j], main_token_lengths[j]);
            if (if_statements.contains(d) == false)                                   /* not if duplicate */
            {
              if (status_to_check != "") status_to_check= status_to_check + " or ";   /* if more than one condition */
              status_to_check= status_to_check + "sqlstate == " + d;                  /* e.g. == '45000' */
              if (pass == 1) is_right_pass= true;
            }
          }
          else if (main_token_types[j] == TOKEN_KEYWORD_SQLEXCEPTION)
          {
            if (if_statements.contains("> '02'")== false)
            {
              if (status_to_check != "") status_to_check= status_to_check + " or ";
              status_to_check= status_to_check + "string.sub(sqlstate,1,2) > '02'";
              if (pass == 2) is_right_pass= true;
            }
          }
          else if (main_token_types[j] == TOKEN_KEYWORD_NOT)
          {
            j= next_i(j, 1);
            assert(main_token_types[j] == TOKEN_KEYWORD_FOUND);
            if (token_type == TOKEN_KEYWORD_OPEN) continue;
            if (if_statements.contains("== '02'")== false)
            {
              if (status_to_check != "") status_to_check= status_to_check + " or ";
              status_to_check= status_to_check + "string.sub(sqlstate,1,2) == '02'";
              if (pass == 3) is_right_pass= true;
            }
          }
          else if (main_token_types[j] == TOKEN_KEYWORD_SQLWARNING)
          {
           if (if_statements.contains("== '01'")== false)
           {
              if (status_to_check != "") status_to_check= status_to_check + " or ";
              status_to_check= status_to_check + "string.sub(sqlstate,1,2) == '01'";
              if (pass == 4) is_right_pass= true;
           }
          }
          else if (((main_token_flags[j] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
                || (main_token_types[j] >= TOKEN_KEYWORDS_START))
          {
            break; /* presumably at start of handler code */
          }
          // It might be "," or comment or label, that's fine, we skip
          // What if it is a number? I guess if it's numeric we compare with a number (no, might start with 00/01/02?) */
        }
        if (is_right_pass == false) continue;
        if_statements= if_statements + "\n" + indent_string +
                                       "if " + status_to_check + " then " + clf_handler_name(handler_starts[i]) +
                                       "();" +
                                       action_after_call +
                                       " end;";
      }
    }
  }
  *clf_output= *clf_output + if_statements;

after_handler_calls:
  if (goto_string > "")
    *clf_output= *clf_output + "\n" + indent_string +
                             "if string.sub(sqlstate,1,2) > '02' then " +
                             goto_string +
                             " end;";
  return true;
}

/*
  Pass: token number. Return: token_number of nearest earlier BEGIN for BEGIN/END enclosing this token.
  If there is an intervening BEGIN/END or flow-control/END, we can skip over it via main_token_pointers[]
  (this might skip back to the label of the BEGIN rather than to the BEGIN itself, but I think that is okay).
  If we fail to find a BEGIN, we return -1 (probably this means we have
      "CREATE PROCEDURE|FUNCTION ... non-compound-statement;" and we have backed up to the word CREATE).
  If we are at the second END in BEGIN BEGIN END END, we will end up pointing to the first BEGIN.
  If we go all the way back to main_token_number, we will end up returning -1 (presumably we were already at top level)
      (although maybe this never happens)
  Todo: it might be nice to have a standard way to find BEGIN that isn't as tedious as searching through main_token.
  Todo: surely we need to find BEGIN in other contexts, so look for duplications of this.
        You might find cases where we skip ENDs in a different way, without using main_token_pointers[].
        You might find cases where we go forward till END, and then use main_token_pointer[] once to go to BEGIN.
*/
int MainWindow::clf_find_begin(int i_of_token)
{
  int k= i_of_token;
  int minimum_token_number= (int) main_token_number;
  if (main_token_types[k] == TOKEN_KEYWORD_END) k= main_token_pointers[k];
  for (;; --k)
  {
    assert(k >= minimum_token_number);
    if (k == minimum_token_number) return -1; /* failed to find a BEGIN */
    if (main_token_types[k] == TOKEN_KEYWORD_BEGIN) break;
    if (main_token_types[k] == TOKEN_KEYWORD_END) k= main_token_pointers[k];
  }
  return k;
}

/*
  Make a list of handlers:
    handler_count, handler_starts[], handler_code_ends[], handler_scope_ends[] handler_begin_of_declares[]
  We set up the list when we start and delete it when we end.
  Later we'll search from bottom to top so that first we're in local scope, then in encompassing scope(s).
  For handler scope: go back to the BEGIN that precedes the DECLARE handler.
     We find it by looking for END, is main_token_pointer will be to BEGIN or to the label preceding BEGIN.
  Todo: Perhaps you should disallow combining specific and non-specific e.g. FOR SQLSTATE '80000', SQLWARNING
        because the conditions have different priorities and the standard disallows such combinations.
        However, perhaps you should leave it up to the user. Or maybe you should support warnings.
*/
bool MainWindow::clf_handler_list(QString text, int main_token_number, int clf_last_token, QString *clf_output)
{
  int handler_index;
  int i;
  handler_count= 0;
  for (i= main_token_number; i < clf_last_token; ++i)
  {
    if ((main_token_types[i] == TOKEN_KEYWORD_DECLARE)
     && (main_token_types[next_i(i, 2)] == TOKEN_KEYWORD_HANDLER))
      ++handler_count;
  }
  if (handler_count == 0) return true;
  handler_starts= new int[handler_count];
  handler_code_ends= new int[handler_count];
  handler_scope_ends= new int[handler_count];
  handler_begin_of_declares= new int[handler_count];
  handler_index= 0;

  for (i= main_token_number; i < clf_last_token; ++i)
  {
    if ((main_token_types[i] != TOKEN_KEYWORD_DECLARE)
     || (main_token_types[next_i(i, 2)] != TOKEN_KEYWORD_HANDLER))
      continue;
    int i_of_declare= i;
    assert(handler_index < handler_count);

    /* Todo: Saying "i_of_begin_of_declare= main_token_pointers[j];" failed. Maybe change h_parse someday? */
    /* We're assuming BEGIN ... DECLARE END; and ... is either blank or another handler or won't have BEGIN+END */
    int i_of_begin_of_declare= 0;
    int begin_count= 0;
    for (int k= i_of_declare - 1; k > main_token_number; --k)
    {
      if (main_token_types[k] == TOKEN_KEYWORD_END)
      {
        if (main_token_types[next_i(k, 1)] == TOKEN_TYPE_OPERATOR) --begin_count;
      }
      if (main_token_types[k] == TOKEN_KEYWORD_BEGIN)
      {
        ++begin_count;
        if (begin_count <= 0) continue;
        i_of_begin_of_declare= k;
        break;
      }
    }
    {
      int i= next_i(i_of_begin_of_declare, -2);
      if (main_token_reftypes[i] == TOKEN_REFTYPE_LABEL_DEFINE) i_of_begin_of_declare= i;
      /* hparse doesn't allow x:y:begin but if someday it does, stop it because we haven't tested */
      i= next_i(i_of_begin_of_declare, -2);
      if (main_token_reftypes[i] == TOKEN_REFTYPE_LABEL_DEFINE)
      {
        *clf_output= "Sorry, we do not allow multiple labels for the same BEGIN at this time.";
        return false;
      }
    }
    assert(i_of_begin_of_declare > main_token_number);
    handler_begin_of_declares[handler_index]= i_of_begin_of_declare;
    handler_scope_ends[handler_index]= 0;
    for (int j= i_of_begin_of_declare; j < clf_last_token; ++j)
    {
      if ((main_token_types[j] == TOKEN_KEYWORD_END) && (main_token_pointers[j] == i_of_begin_of_declare))
      {
        handler_scope_ends[handler_index]= j;
        break;
      }
    }

    assert(handler_scope_ends[handler_index] != 0);

    handler_starts[handler_index]= i_of_declare; /* Todo: should this be i_of_begin_of_declare? */

    /* If it is a flow-control statement, handler code ends at the END. Otherwise it ends at the ";". */
    int i_of_statement_after_declare= 0;
    for (int i= i_of_declare + 1; i < clf_last_token; ++i)
    {
      if ((main_token_flags[i] & TOKEN_FLAG_IS_START_STATEMENT) != 0)
      {
        i_of_statement_after_declare= i;
        break;
      }
    }
    assert(i_of_statement_after_declare != 0);
    assert(i_of_statement_after_declare < clf_last_token);
    int token= main_token_types[i_of_statement_after_declare];
    handler_code_ends[handler_index]= 0;
    /* Todo: Check whether you could simply check TOKEN_FLAG_IS_FLOW_CONTROL instead of the following. */
    if ((token == TOKEN_KEYWORD_BEGIN)
    || (token == TOKEN_KEYWORD_CASE)
    || (token == TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT) /* will only be true if MariaDB 10.3 */
    || (token == TOKEN_KEYWORD_IF)
    || (token == TOKEN_KEYWORD_LOOP)
    || (token == TOKEN_KEYWORD_REPEAT)
    || (token == TOKEN_KEYWORD_WHILE))
    {
      for (int k= i_of_statement_after_declare + 1; k < clf_last_token; ++k)
      {
        if ((main_token_types[k] == TOKEN_KEYWORD_END) && (main_token_pointers[k] == i_of_statement_after_declare))
        {
          /* Found an END that matches i_of_statement_after_declare. now skip to the terminating ";". */
          while (main_token_types[k] != TOKEN_TYPE_OPERATOR) ++k;
          handler_code_ends[handler_index]= k;
          break;
        }
      }
    }
    else
    {
      for (int k= i_of_statement_after_declare;; ++k)
      {
        QString d= text.mid(main_token_offsets[k], main_token_lengths[k]);
        if (d == ";")
        {
          handler_code_ends[handler_index]= k;
          break;
        }
      }
    }
    assert(handler_starts[handler_index] < handler_code_ends[handler_index]);
    assert(handler_code_ends[handler_index] <= handler_scope_ends[handler_index]);
    ++handler_index;
  }
  /* Check: do not allow duplicate conditions for the same BEGIN. Standard restriction. */
  /* Check: do not allow handlers within handlers. Hopefully temporary restriction. */
  for (int outer_handler= 0; outer_handler < handler_count; ++outer_handler)
  {
    int outer_condition;
    for (outer_condition= handler_starts[outer_handler]; main_token_types[outer_condition] != TOKEN_KEYWORD_FOR; ++outer_condition) {;}
    for (outer_condition= outer_condition + 1; (main_token_flags[outer_condition] & TOKEN_FLAG_IS_START_STATEMENT) == 0; ++outer_condition)
    {
      int outer_condition_value= main_token_types[outer_condition];
      if ((outer_condition_value == TOKEN_TYPE_OPERATOR)
       || (outer_condition_value == TOKEN_KEYWORD_SQLSTATE)
       ||(outer_condition_value == TOKEN_KEYWORD_VALUE))
        continue;
      if ((hparse_f_is_identifier(outer_condition_value) == true)
       || (outer_condition_value == TOKEN_TYPE_LITERAL_WITH_DIGIT))
      {
        *clf_output= "Sorry, the only handler conditions we allow at this time are sqlstate 'xxxxx', sqlexception, not found, and sqlwarning.";
        return false;
      }
      int condition_count= 0; /* If this becomes > 1, there is duplication in the same block. */
      for (int inner_handler= 0; inner_handler < handler_count; ++inner_handler)
      {
        if ((handler_starts[inner_handler] > handler_starts[outer_handler]) && (handler_code_ends[inner_handler] < handler_code_ends[outer_handler]))
        {
          *clf_output= "Sorry, we do not allow handlers within handlers at this time.";
          return false;
        }
        if (handler_begin_of_declares[inner_handler] != handler_begin_of_declares[outer_handler]) continue; /* not in the same BEGIN */
        int inner_condition;
        for (inner_condition= handler_starts[inner_handler]; main_token_types[inner_condition] != TOKEN_KEYWORD_FOR; ++inner_condition) {;}
        for (inner_condition= inner_condition + 1; (main_token_flags[inner_condition] & TOKEN_FLAG_IS_START_STATEMENT) == 0; ++inner_condition)
        {
          int inner_condition_value= main_token_types[inner_condition];
          if ((inner_condition_value == TOKEN_TYPE_OPERATOR)
           || (inner_condition_value == TOKEN_KEYWORD_SQLSTATE)
           || (inner_condition_value == TOKEN_KEYWORD_VALUE))continue;
          if (inner_condition_value == outer_condition_value)
          {
            QString d1= text.mid(main_token_offsets[inner_condition], main_token_lengths[inner_condition]);
            QString d2= text.mid(main_token_offsets[outer_condition], main_token_lengths[outer_condition]);
            if (QString::compare(d1, d2, Qt::CaseInsensitive) == 0) ++condition_count;
            if (condition_count > 1)
            {
              *clf_output= "Sorry, we don't allow duplicate handler conditions in the same scope.";
              return false;
            }
          }
        }
      }
    }
  }

  return true;
}

/*
  Return a name of a handler function for a specified TOKEN_KEYWORD_DECLARE token.
  We identify the handler by its number within the handler lists.
  Any name will do. A name like "handler_1" seems okay. Maybe a line number or a recent label would be better.
*/
QString MainWindow::clf_handler_name(int i_of_declare)
{
  for (int i= 0; i < handler_count; ++i)
  {
    if (handler_starts[i] == i_of_declare)
    {
      return "handler_" + QString::number(i);
    }
  }
  return "unknown_handler"; /* actually this must be an error */
}

/*
  Return: declared variable name or parameter name or cursor name
  Pass: i= clfi (if this is in the DECLARE) or main_token_pointers[clfi] (if this is a reference)
  Example: if i == 1 and [i] has x, return "X". Usually it's that simple but here are complexities.
  1. If it is a regular identifier, upper-case it.
     If it is a delimited identifier, strip the ""s and do not upper-case it.
  2. If any character might be illegal in a Lua name, replace it with "_" hex(unicode-value-of-character) "_"
  3. If it is a cursor, add "_CURSOR" (because cursors should have a different namespace).
  If any character was replaced, then there is a very slight chance that the name is not unique, for example
  user could have both "a_32_b" and "a b", and we could guarantee uniqueness by adding QString::number(i) i.e.
  token-number as a suffix, but we don't because (a) it really is a very slight chance (b) Lua will catch it.
  Todo: we could consider adding a suffix or a comment so it's clear what was data type + whether it was a parameter.
  i_type is TOKEN_REFTYPE_{VARIABLE|PARAMETER|CURSOR}_DEFINE
  Converting to upper case is best because (a) we're sure there's no conflict with a Lua reserved word,
  (b) we're sure there's no duplication of regular-identifier b and delimited-identifier "B", (c) this
  correctly reflects what SQL does with identifiers.
  Todo: watch out with connect_stripper, are we always checking ansi_quotes? And `...` quoting is okay?
*/
QString MainWindow::clf_v(const QString text, int i, int i_type)
{
  QString d1= text.mid(main_token_offsets[i], main_token_lengths[i]);
  if (d1.left(1) == "\"") d1= connect_stripper(d1, true);
  else d1= d1.toUpper();
  QString d2= "";
  QChar c;
  for (int i= 0; i < d1.length(); ++i)
  {
    c= d1.at(i);
    if (((c.isDigit()) && (i == 0))
     || ((c.isDigit() == false) && (c.isLetter() == false) && (c != '_')))
    {
      d2= d2 + "_" + QString::number(c.unicode()) + "_";
    }
    else d2= d2 + c;
  }
  if (i_type == TOKEN_REFTYPE_CURSOR_DEFINE) d2= d2 + "_CURSOR";
  return d2;
}

/*
  When we call sql_execute, the first parameter is a string literal with the SQL statement.
  Usually sql_execute_starter="sql_execute([[" and sql_execute_ender="]]".
  But if text contains [[ or ]] that could cause trouble. In that case we change to [=[ ... ]=]... etc.
  We go as high as 5 =s, that is, sql_execute([=====[ ... ]=====]). 5 is arbitrary, but we won't go forever.
*/
bool MainWindow::clf_make_sql_execute_starter_and_ender(QString text, QString *clf_output)
{
  QString starter_brackets;
  QString ender_brackets;
  QString equals= "=";
  int equals_count= 0;
  for (;;)
  {
    starter_brackets= "[" + equals.repeated(equals_count) + "[";
    ender_brackets= "]" + equals.repeated(equals_count) + "]";
    if ((text.contains(starter_brackets) == false)
     && (text.contains(ender_brackets) == false)) break;
    ++equals_count;
    if (equals_count > 5)
    {
      *clf_output= "Sorry, there are too many [[s and [=[s etc. in the input. The limit is [=====[.";
      return false;
    }
  }
  sql_execute_starter= "sql_execute(" + starter_brackets;
  sql_execute_ender= ender_brackets;
  return true;
}

/*
  sql_execute() takes a string containing an SQL statement and executes it.
  The code inside the sql_execute function is non-generic, that is, it works only with a particular SQL dialect.
  All the rest of the translation should be generic.
  Todo: parameters.
  Todo: true/false (for the sake of while/if/etc.) -- maybe we should return true or false or nil
  Usually we just want result[1][1] but I think returning it isn't necessary.
  Todo: at some point we might want to show an error message; m is cdata but tostring(m) will work.
  With MySQL/MariaDB we simply return the SQLSTATE that the DBMS returns.
  With Tarantool we make up an SQLSTATE = '00000' okay, '02000' not found, '45000' sqlexception.
*/
void MainWindow::clf_make_sql_execute_function(QString *clf_output)
{
  QString indent_string= clf_indent(clf_output); 
  *clf_output= *clf_output +
  "\n" + indent_string + "local sqlstate;"
  "\n" + indent_string + "local sqlresult = {};" +
  "\n" + indent_string + "local sqlmessage;";

  if (connections_dbms[0] == DBMS_TARANTOOL)
  {
    *clf_output= *clf_output +
    "\n" + indent_string + "local function sql_execute(statement, parameters)" +
    "\n" + indent_string + "    local s, r, m;" +
    "\n" + indent_string + "    s, r, m = pcall(box.execute,statement, parameters);" +
    "\n" + indent_string + "    sqlmessage = tostring(m);" +
    "\n" + indent_string + "    if r == nil and m ~= nil then sqlstate = '45000'; return false; end;" +
    "\n" + indent_string + "    if (s == false) then sqlstate = '45000'; return false; end;" +
    "\n" + indent_string + "    if (r.rows == nil) then sqlstate = '00000'; return nil; end;" +
    "\n" + indent_string + "    if (r.rows[1] == nil) then sqlstate = '02000'; return nil; end;" +
    "\n" + indent_string + "    sqlresult = r.rows;" +
    "\n" + indent_string + "    sqlstate = '00000';" +
    "\n" + indent_string + "    return true;" +
    "\n" + indent_string + "    end;"
    "\n";
  }
  else
  {
    *clf_output= *clf_output +
    "\n" + indent_string + "local function sql_execute(statement, parameters)" +
    "\n" + indent_string + "--[[" +
    "\n" + indent_string + "    THIS IS A STUB." +
    "\n" + indent_string + "    For MySQL/MariaDB, Peter Gulutzan has not written the sql_execute() code." +
    "\n" + indent_string + "    But it should be easy, fewer than 50 lines." +
    "\n" + indent_string + "    Using the C API, remembering to enclose within pcall():" +
    "\n" + indent_string + "    * Pass each parameter." +
    "\n" + indent_string + "     * Execute the statement (e.g. mysql_real_query)." +
    "\n" + indent_string + "     * If there was an error: set sqlstate and return false." +
    "\n" + indent_string + "   * If there was no result set:" +
    "\n" + indent_string + "       set sqlstate = '00000' and return nil." +
    "\n" + indent_string + "   * If there was a result set:" +
    "\n" + indent_string + "       If row count == 0, set sqlstate = '02000' and return nil." +
    "\n" + indent_string + "       Otherwise put it in sqlresult, set sqlstate = '00000', return true." +
    "\n" + indent_string + "   For an example of code that works with another DBMS, look at ocelotgui" +
    "\n" + indent_string + "   source code, function clf_make_sql_execute_function." +
    "\n" + indent_string + "]]" +
    "\n" + indent_string + "    sqlstate = '45000';" +
    "\n" + indent_string + "    return false;" +
    "\n" + indent_string + "    end;"
    "\n";
  }
}


/*
  Add matching in-scope variable names to completer_widget. Only relevant for MySQL/MariaDB compound statements.
  Todo: bool hparse_is_variable_allowed was set up because hparse_f_variables might eliminate -- but are false positives possible?
        anyway reftype will only mention variable if there was an exact match, so it is not very useful
  Todo: We could ask hparse_f_is_in_compound() though it's not really necessary.
  Todo: This was moved out of hparse.h because it depends on things that were defined after #include "hparse.h". Reorganize.
  Todo: setup_determine_what_variables_are_in_scope() returns a list that is in ``s and may be lower case.
        We simply strip the ``s and call upper() -- but what if the DECLARE actually had ``s or ""s?
  Warning: hparse_variable_must_be_int is semi-global, ensure it's false if caller is not via hparse routine.
*/
void MainWindow::hparse_f_variables_append(int hparse_i_of_statement, QString hparse_text_copy, unsigned char reftype)
{
  if ((reftype != 0) && (hparse_variable_is_allowed == true))
  {
    int declared_variables_count= 0;
    setup_determine_what_variables_are_in_scope(hparse_i_of_statement, hparse_text_copy, hparse_variable_must_be_int);
    declared_variables_count= c_variable_names.count();
    for (int i= 0; i < declared_variables_count; ++i)
    {
      QString token= c_variable_names.at(i);
      if (token.left(1) == "`") token= token.right(token.size() - 1);
      if (token.right(1) == "`") token= token.left(token.size() - 1);
      token= token.toUpper();
      completer_widget->append_wrapper(token, hparse_token, main_token_types[hparse_i], main_token_flags[hparse_i], "V");
    }
  }
}


/*
  SSL test
  --------
  This test was done with MariaDB 10.0.17 source, with files described in
  "Configuring MySQL to use SSL Connections"
  https://dev.mysql.com/doc/refman/5.0/en/using-ssl-connections.html
  1. export MARIADB=10.0.17
  2. Start server with
     mysqld ... --ssl-ca=$HOME/$MARIADB/mysql-test/std_data/cacert.pem --ssl-cert=$HOME/$MARIADB/mysql-test/std_data/server-cert.pem --ssl-key=$HOME/$MARIADB/mysql-test/std_data/server-key.pem
  3. Start client with
     ocelotgui ... --ssl-cert=$HOME/$MARIADB/mysql-test/std_data/client-cert.pem --ssl-key=$HOME/$MARIADB/mysql-test/std_data/client-key.pem
  4. SHOW STATUS LIKE 'Ssl_cipher';
  The result value was DHE-RSA-AES256-SHA. So we declared the test successful.
*/

/*
  Valgrind
  --------

  We get lots of complaints from valgrind about problems that seem to be in
  libraries, including gtk_ and g_ routines, so there is a suppression file.
  Even with the suppressions, some possibly-tolerable leakages are happening:
  * simply closing MainWindow, as opposed to ^Q, will not go via action_file_exit()
  * --version and --help end with exit(0)
  * dlopen() and mysql_real_connect() are leaving something behind

    This is what is in valgrind suppression file valgrind_suppressions.supp.
    Run valgrind with --suppressions=valgrind_suppressions.supp.
    Put the list in the source files somewhere.
    {
       <Addr4s>
       Memcheck:Addr4
       ...
       fun:FcConfig*
    }
    {
       <Conds>
       Memcheck:Cond
       ...
       fun:g_*
    }
    {
       <Params>
       Memcheck:Param
       ioctl(generic)
       ...
       fun:ioctl*
    }
    {
       <Leaks_g>
       Memcheck:Leak
       ...
       fun:g_*
    }
    {
       <Leaks_gtk>
       Memcheck:Leak
       ...
       fun:gtk_*
    }
    {
       <Leaks_pango>
       Memcheck:Leak
       ...
       fun:pango*
    }
    {
       <Leaks_gl>
       Memcheck:Leak
       ...
       fun:glXGetFBConfigs
    }
    {
       <Leaks_Fc>
       Memcheck:Leak
       ...
       fun:FcConfigParseAndLoad
    }
*/

#if (OCELOT_MYSQL_DEBUGGER == 1)
#include "install_sql.cpp"
#endif


/******************** ldbms start ***********************************************/

ldbms::ldbms() : QWidget()
{
#if (MINGW_MARIADB == 0)
  /* Probably-unnecessary initializations done to pacify cppcheck */
  dlopen_handle= 0;
  t__mysql_affected_rows= 0;
  t__mysql_close= NULL;
  t__mysql_data_seek= NULL;
  t__mysql_errno= 0;
  t__mysql_error= 0;
  t__mysql_fetch_fields= NULL;
  t__mysql_fetch_lengths= NULL;
  t__mysql_fetch_row= NULL;
  t__mysql_free_result= NULL;
  t__mysql_get_client_info= NULL;
  t__mysql_get_host_info= NULL;
  t__mysql_info= NULL;
  t__mysql_init= NULL;
  t__mysql_library_end= NULL;
  t__mysql_library_init= NULL;
  t__mysql_more_results= NULL;
  t__mysql_num_rows= NULL;
  t__mysql_options= NULL;
  t__mysql_ping= NULL;
  t__mysql_query= NULL;
  t__mysql_select_db= NULL;
  t__mysql_sqlstate= NULL;
  t__mysql_ssl_set= NULL;
  t__mysql_store_result= NULL;
  t__mysql_thread_end= NULL;
  t__mysql_warning_count= NULL;
  t__AES_set_decrypt_key= NULL;
  t__AES_decrypt= NULL;
  t__mp_decode_array= NULL;
  t__mp_decode_bin= NULL;
  t__mp_decode_bool= NULL;
  t__mp_decode_float= NULL;
  t__mp_decode_double= NULL;
  t__mp_decode_int= NULL;
  t__mp_decode_map= NULL;
  t__mp_decode_nil= NULL;
  t__mp_decode_uint= NULL;
  t__mp_decode_str= NULL;
  t__mp_decode_strl= NULL;
  t__mp_next= NULL;
  t__mp_typeof= NULL;
  t__tnt_auth= NULL;
  t__tnt_call= NULL;
  t__tnt_close= NULL;
  t__tnt_connect= NULL;
  t__tnt_delete= NULL;
  t__tnt_eval= NULL;
  t__tnt_flush= NULL;
  t__tnt_execute= NULL;
  t__tnt_get_indexno= NULL;
  t__tnt_get_spaceno= NULL;
  t__tnt_stream_free= NULL;
  t__tnt_insert= NULL;
  t__mysql_next_result= NULL;
  t__mysql_num_fields= NULL;
  t__mysql_real_connect= NULL;
  t__mysql_real_query= NULL;
  t__tnt_net= NULL;
  t__tnt_object= NULL;
  t__tnt_object_add_array= NULL;
  t__tnt_object_add_nil= NULL;
  t__tnt_object_add_int= NULL;
  t__tnt_object_add_str= NULL;
  t__tnt_object_add_bin= NULL;
  t__tnt_object_add_bool= NULL;
  t__tnt_object_add_float= NULL;
  t__tnt_object_add_double= NULL;
  t__tnt_object_container_close= NULL;
  t__tnt_object_format= NULL;
  t__tnt_object_reset= NULL;
  t__tnt_reload_schema= NULL;
  t__tnt_replace= NULL;
  t__tnt_reply= NULL;
  t__tnt_reply_init= NULL;
  t__tnt_reply_free= NULL;
  t__tnt_request_compile= NULL;
  t__tnt_request_eval= NULL;
  t__tnt_request_call= NULL;
  t__tnt_request_set_exprz= NULL;
  t__tnt_request_set_tuple= NULL;
  t__tnt_select= NULL;
  t__tnt_set= NULL;
  t__tnt_update= NULL;
  t__tnt_select= NULL;
  t__tnt_error= NULL;
  t__tnt_strerror= NULL;
#endif
  return;
}

#define WHICH_LIBRARY_LIBMYSQLCLIENT 0
#define WHICH_LIBRARY_LIBCRYPTO 1
#define WHICH_LIBRARY_LIBMYSQLCLIENT18 2
#ifdef DBMS_TARANTOOL
#define WHICH_LIBRARY_LIBTARANTOOL 3
//#define WHICH_LIBRARY_LIBTARANTOOLNET 4
#endif
#define WHICH_LIBRARY_LIBMARIADBCLIENT 5
#define WHICH_LIBRARY_LIBMARIADB 6

/* Todo: suppressed unused parameter warning if OCELOT_STATIC_LIBRARY==1 */
void ldbms::ldbms_get_library(QString ocelot_ld_run_path,
        int *is_library_loaded,           /* points to is_libXXX_loaded */
        void **library_handle,            /* points to libXXX_handle */
        QString *return_string,
        int which_library)                /* 0 = libmysqlclient. 1 = libcrypto, etc. */
{
#if (OCELOT_MYSQL_INCLUDE == 1)
#if (OCELOT_STATIC_LIBRARY==1)
    if ((which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) || (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) || (which_library == WHICH_LIBRARY_LIBMARIADBCLIENT) || (which_library == WHICH_LIBRARY_LIBMARIADB))
    {
      /* If we static-linked to .lib or .a we don't need to load. */
      /* OCELOT_STATIC_LIBRARY should be on for Windows but not (for now) Linux. */
      /* TODO: This should be controlled by ocelot_static_library = 1 */
      t__mysql_affected_rows= (tmysql_affected_rows) &mysql_affected_rows;
      t__mysql_close= (tmysql_close)  &mysql_close;
      t__mysql_data_seek= (tmysql_data_seek) &mysql_data_seek;
      t__mysql_errno= (tmysql_errno) &mysql_errno;
      t__mysql_error= (tmysql_error) &mysql_error;
      t__mysql_fetch_fields= (tmysql_fetch_fields) (&mysql_fetch_fields);
      t__mysql_fetch_lengths= (tmysql_fetch_lengths) &mysql_fetch_lengths;
      t__mysql_fetch_row= (tmysql_fetch_row) &mysql_fetch_row;
      t__mysql_free_result= (tmysql_free_result) &mysql_free_result;
#if (MINGW_MARIADB == 0)
      t__mysql_get_client_info= (tmysql_get_client_info) &mysql_get_client_info;
#endif
      t__mysql_get_host_info= (tmysql_get_host_info) &mysql_get_host_info;
      t__mysql_info= (tmysql_info) &mysql_info;
      t__mysql_init= (tmysql_init) (&mysql_init);
#if (MINGW_MARIADB == 0)
      t__mysql_library_end= (tmysql_library_end) &mysql_library_end;
#endif
      t__mysql_library_init= (tmysql_library_init) &mysql_library_init;
      t__mysql_more_results= (tmysql_more_results) &mysql_more_results;
      t__mysql_next_result= (tmysql_next_result) &mysql_next_result;
      t__mysql_num_fields= (tmysql_num_fields) &mysql_num_fields;
      t__mysql_num_rows= (tmysql_num_rows) &mysql_num_rows;
      t__mysql_options= (tmysql_options) &mysql_options;
      t__mysql_ping= (tmysql_ping) &mysql_ping;
      t__mysql_query= (tmysql_query) &mysql_query;
      t__mysql_real_connect= (tmysql_real_connect) (&mysql_real_connect);
      t__mysql_real_query= (tmysql_real_query) &mysql_real_query;
      t__mysql_select_db= (tmysql_select_db) &mysql_select_db;
      t__mysql_sqlstate= (tmysql_sqlstate) &mysql_sqlstate;
      t__mysql_ssl_set= (tmysql_ssl_set) &mysql_ssl_set;
      t__mysql_store_result= (tmysql_store_result) (&mysql_store_result);
      t__mysql_thread_end= (tmysql_thread_end) &mysql_thread_end;
      t__mysql_warning_count= (tmysql_warning_count) &mysql_warning_count;
      *is_library_loaded= 1;
      return;
    }
#endif
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

#if (OCELOT_THIRD_PARTY==1)
    /* If Tarantool we can use third_party.h we don't need to load. */
    /* OCELOT_THIRD_PARTY=1 should be on for Windows but maybe not for Linux. */
    /* TODO: This should be controlled by ocelot_third_party = 1 */
    if (which_library == WHICH_LIBRARY_LIBTARANTOOL)
    {
      t__mp_decode_array= (tmp_decode_array) &mp_decode_array;
      t__mp_decode_bin= (tmp_decode_bin) &mp_decode_bin;
      //t__mp_decode_binl= (tmp_decode_binl) ;
      t__mp_decode_bool= (tmp_decode_bool) &mp_decode_bool;
      t__mp_decode_float= (tmp_decode_float) &mp_decode_float;
      t__mp_decode_double= (tmp_decode_double) &mp_decode_double;
      t__mp_decode_int= (tmp_decode_int) &mp_decode_int;
      t__mp_decode_map= (tmp_decode_map) &mp_decode_map;
      t__mp_decode_nil= (tmp_decode_nil) &mp_decode_nil;
      t__mp_decode_uint= (tmp_decode_uint) &mp_decode_uint;
      t__mp_decode_str= (tmp_decode_str) &mp_decode_str;
      t__mp_decode_strl= (tmp_decode_strl) &mp_decode_strl;
      t__mp_next= (tmp_next) &mp_next;
      t__mp_typeof= (tmp_typeof) &mp_typeof;
      t__tnt_auth= (ttnt_auth) &tnt_auth;
      t__tnt_call= (ttnt_call) &tnt_call;
      t__tnt_close= (ttnt_close) &tnt_close;
      t__tnt_connect= (ttnt_connect) &tnt_connect;
      t__tnt_delete= (ttnt_delete) &tnt_delete;
      t__tnt_eval= (ttnt_eval) &tnt_eval;
      t__tnt_flush= (ttnt_flush) &tnt_flush;
      t__tnt_execute= (ttnt_execute) &tnt_execute;
      t__tnt_get_indexno= (ttnt_get_indexno) &tnt_get_indexno;
      t__tnt_get_spaceno= (ttnt_get_spaceno) &tnt_get_spaceno;
      t__tnt_stream_free= (ttnt_stream_free) &tnt_stream_free;
      t__tnt_insert= (ttnt_insert) &tnt_insert;
      t__tnt_net= (ttnt_net) &tnt_net;
      t__tnt_object= (ttnt_object) &tnt_object;
      t__tnt_object_add_array= (ttnt_object_add_array) &tnt_object_add_array;
      t__tnt_object_add_nil= (ttnt_object_add_nil) &tnt_object_add_nil;
      t__tnt_object_add_int= (ttnt_object_add_int) &tnt_object_add_int;
      t__tnt_object_add_str= (ttnt_object_add_str) &tnt_object_add_str;
      t__tnt_object_add_bin= (ttnt_object_add_bin) &tnt_object_add_bin;
      t__tnt_object_add_bool= (ttnt_object_add_bool) &tnt_object_add_bool;
      t__tnt_object_add_float= (ttnt_object_add_float) &tnt_object_add_float;
      t__tnt_object_add_double= (ttnt_object_add_double) &tnt_object_add_double;
      t__tnt_object_container_close= (ttnt_object_container_close) &tnt_object_container_close;
      t__tnt_object_format= (ttnt_object_format) &tnt_object_format;
      t__tnt_object_reset= (ttnt_object_reset) &tnt_object_reset;
      t__tnt_reload_schema= (ttnt_reload_schema) &tnt_reload_schema;
      t__tnt_replace= (ttnt_replace) &tnt_replace;
      t__tnt_reply= (ttnt_reply) &xtnt_reply;
      t__tnt_reply_free= (ttnt_reply_free) &tnt_reply_free;
      t__tnt_request_compile= (ttnt_request_compile) &tnt_request_compile;
      t__tnt_request_eval= (ttnt_request_eval) &tnt_request_eval;
      t__tnt_request_call= (ttnt_request_call) &tnt_request_call;
      t__tnt_request_set_exprz= (ttnt_request_set_exprz) &tnt_request_set_exprz;
      t__tnt_request_set_tuple= (ttnt_request_set_tuple) &tnt_request_set_tuple;
      t__tnt_reply_init= (ttnt_reply_init) &tnt_reply_init;
      t__tnt_select= (ttnt_select) &tnt_select;
      t__tnt_set= (ttnt_set) &tnt_set;
      t__tnt_update= (ttnt_update) &tnt_update;
      t__tnt_error= (ttnt_error) &xtnt_error;
      t__tnt_strerror= (ttnt_strerror) &tnt_strerror;
      *is_library_loaded= 1;
      return;
    }
#endif /* OCELOT_THIRD_PARTY==1 */

#ifdef OCELOT_OS_LINUX
    char *query;
    int query_len;
#endif
    QString error_string;

    /*
      What's with all the #ifdef OCELOT_OS_LINUX stuff?
      Originally I coded for QLibrary. For reasons I couldn't figure out,
      t__mysql_real_connect crashed. So I switched to dlopen().
      I suspect the ability to say RTLD_DEEPBIND | RTLD_NOW had something to do with it.
      WIthout RTLD_DEEPBIND it crashed though that might be an obsolete observation.
      But perhaps someday we'll want to revive QLibrary for other platforms.

      There is a description re finding libmysqlclient if one types Help | libmysqlclient.
    */

#ifdef OCELOT_OS_NONLINUX
  QLibrary lib;
#endif

    if (*is_library_loaded == 1)
    {
      /*
        Since this is called when we're re-connecting,
        I'd like to dclose() and dlopen() again in case library name has changed.
        But apparently dclose() is not reliable. So don't change library name, eh?
      */
      return;
    }
    if (*is_library_loaded == -2)
    {
      /* The last error was that we got the wrong library. Unrecoverable. */
      return;
    }
#ifdef OCELOT_OS_NONLINUX
#if (OCELOT_MYSQL_INCLUDE == 1)
    /* I don't know how Windows handles shared-library version numbers */
    if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) lib.setFileNameAndVersion("libmysql", 18);
    if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) lib.setFileName("libmysql");
    if (which_library == WHICH_LIBRARY_LIBCRYPTO) lib.setFileName("libeay32");
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
    if (which_library == WHICH_LIBRARY_LIBTARANTOOL) lib.setFileName("libtarantool");
    //if (which_library == WHICH_LIBRARY_LIBTARANTOOLNET) lib.setFileName("libtarantoolnet");
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
    if (which_library == WHICH_LIBRARY_LIBMARIADBCLIENT) lib.setFileName("libmariadbclient");
    if (which_library == WHICH_LIBRARY_LIBMARIADB) lib.setFileName("libmariadb");
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#endif
    /*
      Finding libmysqlclient
      I tried "qApp->addLibraryPath(ld_run_path);" but it failed.
      So first I'll try hard-coding lib() with strings from ld_run_path.
    */
    if (ocelot_ld_run_path != "")
    {
      QString ld_run_path_part;
      char *ld_run_path;
      int ld_run_path_len;
      int i= 0;
      int prev_i= 0;

      ld_run_path_len= ocelot_ld_run_path.toUtf8().size();         /* See comment "UTF8 Conversion" */
      ld_run_path= new char[ld_run_path_len + 1];
      memcpy(ld_run_path, ocelot_ld_run_path.toUtf8().constData(), ld_run_path_len + 1);
      ld_run_path[ld_run_path_len]= '\0';

      for (;;)
      {
        for (i= prev_i;; ++i)
        {
          if ((*(ld_run_path + i) == ';') || (*(ld_run_path + i) == '\0')) break;
        }
        ld_run_path_part= ld_run_path + prev_i;
        ld_run_path_part= ld_run_path_part.left(i - prev_i);
        ld_run_path_part= ld_run_path_part.trimmed();
        if (ld_run_path_part > "")
        {
#ifdef OCELOT_OS_LINUX
#if (OCELOT_MYSQL_INCLUDE == 1)
          if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) ld_run_path_part.append("/libmysqlclient.so.18");
          if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) ld_run_path_part.append("/libmysqlclient.so");
          if (which_library == WHICH_LIBRARY_LIBCRYPTO) ld_run_path_part.append("/libcrypto.so");
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
          if (which_library == WHICH_LIBRARY_LIBTARANTOOL) ld_run_path_part.append("/libtarantool.so");
          //if (which_library == WHICH_LIBRARY_LIBTARANTOOLNET) ld_run_path_part.append("/libtarantoolnet.so");
#endif
          query_len= ld_run_path_part.toUtf8().size();         /* See comment "UTF8 Conversion" */
          query= new char[query_len + 1];
          memcpy(query, ld_run_path_part.toUtf8().constData(), query_len + 1);
          query[query_len]= '\0';
          dlopen_handle= dlopen(query,  RTLD_DEEPBIND | RTLD_NOW);
          delete []query;
          if (dlopen_handle == 0) {*is_library_loaded= 0; error_string= dlerror(); }
          else *is_library_loaded= 1;
          *library_handle= dlopen_handle;
#endif //#ifdef OCELOT_OS_LINUX
#ifdef OCELOT_OS_NONLINUX
#if (OCELOT_MYSQL_INCLUDE == 1)
          if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) ld_run_path_part.append("/libmysqlclient");
          if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) ld_run_path_part.append("/libmysqlclient");
          if (which_library == WHICH_LIBRARY_LIBCRYPTO) ld_run_path_part.append("/libcrypto");
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
          if (which_library == WHICH_LIBRARY_LIBTARANTOOL) ld_run_path_part.append("/libtarantool");
          //if (which_library == WHICH_LIBRARY_LIBTARANTOOLNET) ld_run_path_part.append("/libtarantoolnet");
#endif
          lib.setFileName(ld_run_path_part);
          *is_library_loaded= lib.load();
          error_string= lib.errorString();
#endif //#ifdef OCELOT_OS_NONLINUX
          if (*is_library_loaded == 1) break;
        }
        if (*(ld_run_path + i) == '\0') break;
        prev_i= i + 1;
      }
      delete []ld_run_path;
    }

    /*
      If ld_run_path was passed, and we found nothing, return now. We want to check for libmysqlclient.so.18
      along run path first (regardless whether it's for libmysqlclient.so.18 or libmysqlclient.so)
    */
    if ((ocelot_ld_run_path != "") && (*is_library_loaded == 0)) return;

    /* If it wasn't found via LD_RUN_PATH, use defaults e.g. LD_LIBRARY_PATH */
    if (*is_library_loaded == 0)
    {
#ifdef OCELOT_OS_LINUX
#if (OCELOT_MYSQL_INCLUDE == 1)
      if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) dlopen_handle= dlopen("libmysqlclient.so.18",  RTLD_DEEPBIND | RTLD_NOW);
      if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) dlopen_handle= dlopen("libmysqlclient.so",  RTLD_DEEPBIND | RTLD_NOW);
      if (which_library == WHICH_LIBRARY_LIBCRYPTO) dlopen_handle= dlopen("libcrypto.so",  RTLD_DEEPBIND | RTLD_NOW);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
      if (which_library == WHICH_LIBRARY_LIBTARANTOOL) dlopen_handle= dlopen("libtarantool.so",  RTLD_DEEPBIND | RTLD_NOW);
      //if (which_library == WHICH_LIBRARY_LIBTARANTOOLNET) dlopen_handle= dlopen("libtarantoolnet.so",  RTLD_DEEPBIND | RTLD_NOW);
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
      if (which_library == WHICH_LIBRARY_LIBMARIADBCLIENT) dlopen_handle= dlopen("libmariadbclient.so",  RTLD_DEEPBIND | RTLD_NOW);
      if (which_library == WHICH_LIBRARY_LIBMARIADB) dlopen_handle= dlopen("libmariadb.so",  RTLD_DEEPBIND | RTLD_NOW);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
      if (dlopen_handle == 0) {*is_library_loaded= 0; error_string= dlerror(); }
      else *is_library_loaded= 1;
      *library_handle= dlopen_handle;
#endif //#ifdef OCELOT_OS_LINUX
#ifdef OCELOT_OS_NONLINUX
#if (OCELOT_MYSQL_INCLUDE == 1)
      if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) lib.setFileName("libmysql");
      if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) lib.setFileName("libmysql");
      if (which_library == WHICH_LIBRARY_LIBCRYPTO) lib.setFileName("libeay32");
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
      if (which_library == WHICH_LIBRARY_LIBTARANTOOL) lib.setFileName("libtarantool");
      //if (which_library == WHICH_LIBRARY_LIBTARANTOOLNET) lib.setFileName("libtarantoolnet");
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
      if (which_library == WHICH_LIBRARY_LIBMARIADBCLIENT) lib.setFileName("libmariadbclient");
      if (which_library == WHICH_LIBRARY_LIBMARIADB) lib.setFileName("libmariadb");
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
      *is_library_loaded= lib.load();
      error_string= lib.errorString();
#endif //#ifdef OCELOT_OS_NONLINUX
    }

    if (*is_library_loaded == 0)
    {
      *return_string= error_string;
      return;
    }
    if (*is_library_loaded == 1)
    {
      QString s= "";
#ifdef OCELOT_OS_LINUX
#if (OCELOT_MYSQL_INCLUDE == 1)
      if ((which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) || (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) || (which_library == WHICH_LIBRARY_LIBMARIADBCLIENT) || (which_library == WHICH_LIBRARY_LIBMARIADB))
      {
        t__mysql_affected_rows= (tmysql_affected_rows) dlsym(dlopen_handle, "mysql_affected_rows"); if (dlerror() != 0) s.append("mysql_affected_rows ");
        t__mysql_close= (tmysql_close) dlsym(dlopen_handle, "mysql_close"); if (dlerror() != 0) s.append("mysql_close ");
        t__mysql_data_seek= (tmysql_data_seek) dlsym(dlopen_handle, "mysql_data_seek"); if (dlerror() != 0) s.append("mysql_data_seek ");
        t__mysql_errno= (tmysql_errno) dlsym(dlopen_handle, "mysql_errno"); if (dlerror() != 0) s.append("mysql_errno ");
        t__mysql_error= (tmysql_error) dlsym(dlopen_handle, "mysql_error"); if (dlerror() != 0) s.append("mysql_errorinit ");
        t__mysql_fetch_fields= (tmysql_fetch_fields) dlsym(dlopen_handle, "mysql_fetch_fields"); if (dlerror() != 0) s.append("mysql_fetch_fields ");
        t__mysql_fetch_lengths= (tmysql_fetch_lengths) dlsym(dlopen_handle, "mysql_fetch_lengths"); if (dlerror() != 0) s.append("mysql_fetch_lengths ");
        t__mysql_fetch_row= (tmysql_fetch_row) dlsym(dlopen_handle, "mysql_fetch_row"); if (dlerror() != 0) s.append("mysql_fetch_rows ");
        t__mysql_free_result= (tmysql_free_result) dlsym(dlopen_handle, "mysql_free_result"); if (dlerror() != 0) s.append("mysql_free_result ");
        t__mysql_get_client_info= (tmysql_get_client_info) dlsym(dlopen_handle, "mysql_get_client_info"); if (dlerror() != 0) s.append("mysql_get_client_info ");
        t__mysql_get_host_info= (tmysql_get_host_info) dlsym(dlopen_handle, "mysql_get_host_info"); if (dlerror() != 0) s.append("mysql_get_host_info ");
        t__mysql_info= (tmysql_info) dlsym(dlopen_handle, "mysql_info"); if (dlerror() != 0) s.append("mysql_info ");
        t__mysql_init= (tmysql_init) dlsym(dlopen_handle, "mysql_init"); if (dlerror() != 0) s.append("mysql_init ");
        {
          t__mysql_library_end= (tmysql_library_end) dlsym(dlopen_handle, "mysql_library_end");
          if (dlerror() != 0)
          {
            t__mysql_library_end= (tmysql_library_end) dlsym(dlopen_handle, "mysql_server_end");
            if (dlerror() != 0) s.append("mysql_library_end ");
          }
        }
        {
          t__mysql_library_init= (tmysql_library_init) dlsym(dlopen_handle, "mysql_library_init");
          if (dlerror() != 0)
          {
            t__mysql_library_init= (tmysql_library_init) dlsym(dlopen_handle, "mysql_server_init");
            if (dlerror() != 0) s.append("mysql_library_init ");
          }
        }
        t__mysql_more_results= (tmysql_more_results) dlsym(dlopen_handle, "mysql_more_results"); if (dlerror() != 0) s.append("mysql_more_results ");
        t__mysql_next_result= (tmysql_next_result) dlsym(dlopen_handle, "mysql_next_result"); if (dlerror() != 0) s.append("mysql_next_result ");
        t__mysql_num_fields= (tmysql_num_fields) dlsym(dlopen_handle, "mysql_num_fields"); if (dlerror() != 0) s.append("mysql_num_fields ");
        t__mysql_num_rows= (tmysql_num_rows) dlsym(dlopen_handle, "mysql_num_rows"); if (dlerror() != 0) s.append("mysql_num_rows ");
        t__mysql_options= (tmysql_options) dlsym(dlopen_handle, "mysql_options"); if (dlerror() != 0) s.append("mysql_options ");
        t__mysql_ping= (tmysql_ping) dlsym(dlopen_handle, "mysql_ping"); if (dlerror() != 0) s.append("mysql_ping ");
        t__mysql_query= (tmysql_query) dlsym(dlopen_handle, "mysql_query"); if (dlerror() != 0) s.append("mysql_query ");
        t__mysql_real_connect= (tmysql_real_connect) dlsym(dlopen_handle, "mysql_real_connect"); if (dlerror() != 0) s.append("mysql_real_connect ");
        t__mysql_real_query= (tmysql_real_query) dlsym(dlopen_handle, "mysql_real_query"); if (dlerror() != 0) s.append("mysql_real_query ");
        t__mysql_select_db= (tmysql_select_db) dlsym(dlopen_handle, "mysql_select_db"); if (dlerror() != 0) s.append("mysql_select_db ");
        t__mysql_sqlstate= (tmysql_sqlstate) dlsym(dlopen_handle, "mysql_sqlstate"); if (dlerror() != 0) s.append("mysql_sqlstate ");
        t__mysql_ssl_set= (tmysql_ssl_set) dlsym(dlopen_handle, "mysql_ssl_set"); if (dlerror() != 0) t__mysql_ssl_set= NULL;
        t__mysql_store_result= (tmysql_store_result) dlsym(dlopen_handle, "mysql_store_result"); if (dlerror() != 0) s.append("mysql_store_result ");
        t__mysql_thread_end= (tmysql_thread_end) dlsym(dlopen_handle, "mysql_thread_end"); if (dlerror() != 0) s.append("mysql_thread_end ");
        t__mysql_warning_count= (tmysql_warning_count) dlsym(dlopen_handle, "mysql_warning_count"); if (dlerror() != 0) s.append("mysql_warning_count ");
      }
      if (which_library == WHICH_LIBRARY_LIBCRYPTO)
      {
        t__AES_set_decrypt_key= (tAES_set_decrypt_key) dlsym(dlopen_handle, "AES_set_decrypt_key"); if (dlerror() != 0) s.append("AES_set_decrypt_key ");
        t__AES_decrypt= (tAES_decrypt) dlsym(dlopen_handle, "AES_decrypt"); if (dlerror() != 0) s.append("AES_decrypt ");
      }
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
      if (which_library == WHICH_LIBRARY_LIBTARANTOOL)
      {
        t__mp_decode_array= (tmp_decode_array) dlsym(dlopen_handle, "mp_decode_array"); if (dlerror() != 0) s.append("mp_decode_array ");
        t__mp_decode_bin= (tmp_decode_bin) dlsym(dlopen_handle, "mp_decode_bin"); if (dlerror() != 0) s.append("mp_decode_bin ");
        //t__mp_decode_binl= (tmp_decode_binl) dlsym(dlopen_handle, "mp_decode_binl)"); if (dlerror() != 0) s.append("mp_decode_binl ");
        t__mp_decode_bool= (tmp_decode_bool) dlsym(dlopen_handle, "mp_decode_bool"); if (dlerror() != 0) s.append("mp_decode_bool ");
        t__mp_decode_float= (tmp_decode_float) dlsym(dlopen_handle, "mp_decode_float"); if (dlerror() != 0) s.append("mp_decode_float ");
        t__mp_decode_double= (tmp_decode_double) dlsym(dlopen_handle, "mp_decode_double"); if (dlerror() != 0) s.append("mp_decode_double ");
        t__mp_decode_int= (tmp_decode_int) dlsym(dlopen_handle, "mp_decode_int"); if (dlerror() != 0) s.append("mp_decode_int ");
        t__mp_decode_map= (tmp_decode_map) dlsym(dlopen_handle, "mp_decode_map"); if (dlerror() != 0) s.append("mp_decode_map ");
        t__mp_decode_nil= (tmp_decode_nil) dlsym(dlopen_handle, "mp_decode_nil"); if (dlerror() != 0) s.append("mp_decode_nil ");
        t__mp_decode_uint= (tmp_decode_uint) dlsym(dlopen_handle, "mp_decode_uint"); if (dlerror() != 0) s.append("mp_decode_uint ");
        t__mp_decode_str= (tmp_decode_str) dlsym(dlopen_handle, "mp_decode_str"); if (dlerror() != 0) s.append("mp_decode_str ");
        t__mp_decode_strl= (tmp_decode_strl) dlsym(dlopen_handle, "mp_decode_strl"); if (dlerror() != 0) s.append("mp_decode_strl ");
        t__mp_next= (tmp_next) dlsym(dlopen_handle, "mp_next"); if (dlerror() != 0) s.append("mp_next ");
        t__mp_typeof= (tmp_typeof) dlsym(dlopen_handle, "mp_typeof"); if (dlerror() != 0) s.append("mp_typeof ");
        t__tnt_auth= (ttnt_auth) dlsym(dlopen_handle, "tnt_auth"); if (dlerror() != 0) s.append("tnt_auth ");
        t__tnt_call= (ttnt_call) dlsym(dlopen_handle, "tnt_call"); if (dlerror() != 0) s.append("tnt_call ");
        t__tnt_close= (ttnt_close) dlsym(dlopen_handle, "tnt_close"); if (dlerror() != 0) s.append("tnt_close ");
        t__tnt_connect= (ttnt_connect) dlsym(dlopen_handle, "tnt_connect"); if (dlerror() != 0) s.append("tnt_connect ");
        t__tnt_delete= (ttnt_delete) dlsym(dlopen_handle, "tnt_delete"); if (dlerror() != 0) s.append("tnt_delete");
        t__tnt_eval= (ttnt_eval) dlsym(dlopen_handle, "tnt_eval"); if (dlerror() != 0) s.append("tnt_eval ");
        t__tnt_flush= (ttnt_flush) dlsym(dlopen_handle, "tnt_flush"); if (dlerror() != 0) s.append("tnt_flush ");
        t__tnt_execute= (ttnt_execute) dlsym(dlopen_handle, "tnt_execute"); if (dlerror() != 0) s.append("tnt_execute ");
        t__tnt_get_indexno= (ttnt_get_indexno) dlsym(dlopen_handle, "tnt_get_indexno"); if (dlerror() != 0) s.append("tnt_get_indexno ");
        t__tnt_get_spaceno= (ttnt_get_spaceno) dlsym(dlopen_handle, "tnt_get_spaceno"); if (dlerror() != 0) s.append("tnt_get_spaceno ");
        t__tnt_stream_free= (ttnt_stream_free) dlsym(dlopen_handle, "tnt_stream_free"); if (dlerror() != 0) s.append("tnt_stream_Free ");
        t__tnt_insert= (ttnt_insert) dlsym(dlopen_handle, "tnt_insert"); if (dlerror() != 0) s.append("tnt_insert ");
        t__tnt_net= (ttnt_net) dlsym(dlopen_handle, "tnt_net"); if (dlerror() != 0) s.append("tnt_net ");
        t__tnt_object= (ttnt_object) dlsym(dlopen_handle, "tnt_object"); if (dlerror() != 0) s.append("tnt_object ");
        t__tnt_object_add_array= (ttnt_object_add_array) dlsym(dlopen_handle, "tnt_object_add_array"); if (dlerror() != 0) s.append("tnt_object_add_array ");
        t__tnt_object_add_nil= (ttnt_object_add_nil) dlsym(dlopen_handle, "tnt_object_add_nil"); if (dlerror() != 0) s.append("tnt_object_add_nil ");
        t__tnt_object_add_int= (ttnt_object_add_int) dlsym(dlopen_handle, "tnt_object_add_int"); if (dlerror() != 0) s.append("tnt_object_add_int ");
        t__tnt_object_add_str= (ttnt_object_add_str) dlsym(dlopen_handle, "tnt_object_add_str"); if (dlerror() != 0) s.append("tnt_object_add_str ");
        t__tnt_object_add_bin= (ttnt_object_add_bin) dlsym(dlopen_handle, "tnt_object_add_bin"); if (dlerror() != 0) s.append("tnt_object_add_bin ");
        t__tnt_object_add_bool= (ttnt_object_add_bool) dlsym(dlopen_handle, "tnt_object_add_bool"); if (dlerror() != 0) s.append("tnt_object_add_bool ");
        t__tnt_object_add_float= (ttnt_object_add_float) dlsym(dlopen_handle, "tnt_object_add_float"); if (dlerror() != 0) s.append("tnt_object_add_float ");
        t__tnt_object_add_double= (ttnt_object_add_double) dlsym(dlopen_handle, "tnt_object_add_double"); if (dlerror() != 0) s.append("tnt_object_add_double ");
        t__tnt_object_container_close= (ttnt_object_container_close) dlsym(dlopen_handle, "tnt_object_container_close"); if (dlerror() != 0) s.append("tnt_object_container_close ");
        t__tnt_object_format= (ttnt_object_format) dlsym(dlopen_handle, "tnt_object_format"); if (dlerror() != 0) s.append("tnt_object_format ");
        t__tnt_object_reset= (ttnt_object_reset) dlsym(dlopen_handle, "tnt_object_reset"); if (dlerror() != 0) s.append("tnt_object_reset ");
        t__tnt_reload_schema= (ttnt_reload_schema) dlsym(dlopen_handle, "tnt_reload_schema"); if (dlerror() != 0) s.append("tnt_reload_schema ");
        t__tnt_replace= (ttnt_replace) dlsym(dlopen_handle, "tnt_replace"); if (dlerror() != 0) s.append("tnt_replace ");
        t__tnt_reply= (ttnt_reply) dlsym(dlopen_handle, "tnt_reply"); if (dlerror() != 0) s.append("tnt_reply ");
        t__tnt_reply_free= (ttnt_reply_free) dlsym(dlopen_handle, "tnt_reply_free"); if (dlerror() != 0) s.append("tnt_reply_free ");
        t__tnt_request_compile= (ttnt_request_compile) dlsym(dlopen_handle, "tnt_request_compile"); if (dlerror() != 0) s.append("tnt_request_compile ");
        t__tnt_request_eval= (ttnt_request_eval) dlsym(dlopen_handle, "tnt_request_eval"); if (dlerror() != 0) s.append("tnt_request_eval ");
        t__tnt_request_call= (ttnt_request_call) dlsym(dlopen_handle, "tnt_request_call"); if (dlerror() != 0) s.append("tnt_request_call ");
        t__tnt_request_set_exprz= (ttnt_request_set_exprz) dlsym(dlopen_handle, "tnt_request_set_exprz"); if (dlerror() != 0) s.append("tnt_request_set_exprz ");
        t__tnt_request_set_tuple= (ttnt_request_set_tuple) dlsym(dlopen_handle, "tnt_request_set_tuple"); if (dlerror() != 0) s.append("tnt_request_set_tuple ");
        t__tnt_reply_init= (ttnt_reply_init) dlsym(dlopen_handle, "tnt_reply_init"); if (dlerror() != 0) s.append("tnt_reply_init ");
        t__tnt_select= (ttnt_select) dlsym(dlopen_handle, "tnt_select"); if (dlerror() != 0) s.append("tnt_select ");
        t__tnt_set= (ttnt_set) dlsym(dlopen_handle, "tnt_set"); if (dlerror() != 0) s.append("tnt_set ");
        t__tnt_update= (ttnt_update) dlsym(dlopen_handle, "tnt_update"); if (dlerror() != 0) s.append("tnt_update ");
        t__tnt_error= (ttnt_error) dlsym(dlopen_handle, "tnt_error"); if (dlerror() != 0) s.append("tnt_error ");
        t__tnt_strerror= (ttnt_strerror) dlsym(dlopen_handle, "tnt_strerror"); if (dlerror() != 0) s.append("tnt_strerror ");
      }
#endif
#endif //#ifdef OCELOT_OS_LINUX
#ifdef OCELOT_OS_NONLINUX
#if (OCELOT_MYSQL_INCLUDE == 1)
      if ((which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) || (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) || (which_library == WHICH_LIBRARY_LIBMARIADBCLIENT) || (which_library == WHICH_LIBRARY_LIBMARIADB))
      {
        if ((t__mysql_affected_rows= (tmysql_affected_rows) lib.resolve("mysql_affected_rows")) == 0) s.append("mysql_affected_rows ");
        if ((t__mysql_close= (tmysql_close) lib.resolve("mysql_close")) == 0) s.append("mysql_close ");
        if ((t__mysql_data_seek= (tmysql_data_seek) lib.resolve("mysql_data_seek")) == 0) s.append("mysql_data_seek ");
        if ((t__mysql_errno= (tmysql_errno) lib.resolve("mysql_errno")) == 0) s.append("mysql_errno ");
        if ((t__mysql_error= (tmysql_error) lib.resolve("mysql_error")) == 0) s.append("mysql_error ");
        if ((t__mysql_fetch_fields= (tmysql_fetch_fields) lib.resolve("mysql_fetch_fields")) == 0) s.append("mysql_fetch_fields ");
        if ((t__mysql_fetch_lengths= (tmysql_fetch_lengths) lib.resolve("mysql_fetch_lengths")) == 0) s.append("mysql_fetch_lengths ");
        if ((t__mysql_fetch_row= (tmysql_fetch_row) lib.resolve("mysql_fetch_row")) == 0) s.append("mysql_fetch_row ");
        if ((t__mysql_free_result= (tmysql_free_result) lib.resolve("mysql_free_result")) == 0) s.append("mysql_free_result ");
#if (MINGW_MARIADB == 0)
        if ((t__mysql_get_client_info= (tmysql_get_client_info) lib.resolve("mysql_get_client_info")) == 0) s.append("mysql_get_client_info ");
#endif
        if ((t__mysql_get_host_info= (tmysql_get_host_info) lib.resolve("mysql_get_host_info")) == 0) s.append("mysql_get_host_info ");
        if ((t__mysql_info= (tmysql_info) lib.resolve("mysql_info")) == 0) s.append("mysql_info ");
        if ((t__mysql_init= (tmysql_init) lib.resolve("mysql_init")) == 0) s.append("mysql_init ");
#if (MINGW_MARIADB == 0)
        {
          t__mysql_library_end= (tmysql_library_end) lib.resolve("mysql_library_end");
          if (t__mysql_library_end == 0)
          {
            t__mysql_library_end= (tmysql_library_end) lib.resolve("mysql_server_end");
            if (t__mysql_library_end == 0) s.append("mysql_library_end ");
          }
        }
#endif
        {
          t__mysql_library_init= (tmysql_library_init) lib.resolve("mysql_library_init");
          if (t__mysql_library_init == 0)
          {
            t__mysql_library_init= (tmysql_library_init) lib.resolve("mysql_server_init");
            if (t__mysql_library_init == 0) s.append("mysql_library_init ");
          }
        }
        if ((t__mysql_more_results= (tmysql_more_results) lib.resolve("mysql_more_results")) == 0) s.append("mysql_more_results ");
        if ((t__mysql_next_result= (tmysql_next_result) lib.resolve("mysql_next_result")) == 0) s.append("mysql_next_result ");
        if ((t__mysql_num_fields= (tmysql_num_fields) lib.resolve("mysql_num_fields")) == 0) s.append("mysql_num_fields ");
        if ((t__mysql_num_rows= (tmysql_num_rows) lib.resolve("mysql_num_rows")) == 0) s.append("mysql_num_rows ");
        if ((t__mysql_options= (tmysql_options) lib.resolve("mysql_options")) == 0) s.append("mysql_options ");
        if ((t__mysql_ping= (tmysql_ping) lib.resolve("mysql_ping")) == 0) s.append("mysql_ping ");
        if ((t__mysql_query= (tmysql_query) lib.resolve("mysql_query")) == 0) s.append("mysql_query ");
        if ((t__mysql_real_connect= (tmysql_real_connect) lib.resolve("mysql_real_connect")) == 0) s.append("mysql_real_connect ");
        if ((t__mysql_real_query= (tmysql_real_query) lib.resolve("mysql_real_query")) == 0) s.append("mysql_real_query ");
        if ((t__mysql_select_db= (tmysql_select_db) lib.resolve("mysql_select_db")) == 0) s.append("mysql_select_db ");
        if ((t__mysql_sqlstate= (tmysql_sqlstate) lib.resolve("mysql_sqlstate")) == 0) s.append("mysql_sqlstate ");
        if ((t__mysql_ssl_set= (tmysql_ssl_set) lib.resolve("mysql_ssl_set")) == 0) t__mysql_ssl_set= NULL;
        if ((t__mysql_store_result= (tmysql_store_result) lib.resolve("mysql_store_result")) == 0) s.append("mysql_store_result ");
        if ((t__mysql_thread_end= (tmysql_thread_end) lib.resolve("mysql_thread_end")) == 0) s.append("mysql_thread_end ");
        if ((t__mysql_warning_count= (tmysql_warning_count) lib.resolve("mysql_warning_count")) == 0) s.append("mysql_warning_count ");
      }
      if (which_library == WHICH_LIBRARY_LIBCRYPTO)
      {
        if ((t__AES_set_decrypt_key= (tAES_set_decrypt_key) lib.resolve("AES_set_decrypt_key")) == 0) s.append("AES_set_decrypt_key ");
        if ((t__AES_decrypt= (tAES_decrypt) lib.resolve("AES_decrypt")) == 0) s.append("AES_decrypt ");
      }
#endif //if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
      if (which_library == WHICH_LIBRARY_LIBTARANTOOL)
      {
         /* With Windows don't look for the Tarantool library, its code is in third_party.h */
      }
#endif
#endif //#ifdef OCELOT_OS_NONLINUX
      if (s > "")
      {
        {
          /* Unrecoverable error -- one or more names not found. Return the names. */
          *return_string= s;
          *is_library_loaded= -2;
          return;
          }
      }
    }
  }

#if (OCELOT_MYSQL_INCLUDE == 1)
my_ulonglong ldbms::ldbms_mysql_affected_rows(MYSQL *mysql)
{
  return t__mysql_affected_rows(mysql);
}
void ldbms::ldbms_mysql_close(MYSQL *mysql)
{
  t__mysql_close(mysql);
}
void ldbms::ldbms_mysql_data_seek(MYSQL_RES *result, my_ulonglong offset)
{
  t__mysql_data_seek(result, offset);
}
unsigned int ldbms::ldbms_mysql_errno(MYSQL *mysql)
{
  return t__mysql_errno(mysql);
}
const char *ldbms::ldbms_mysql_error(MYSQL *mysql)
{
  return t__mysql_error(mysql);
}
MYSQL_FIELD *ldbms::ldbms_mysql_fetch_fields(MYSQL_RES *result)
{
  return t__mysql_fetch_fields(result);
}

unsigned long *ldbms::ldbms_mysql_fetch_lengths(MYSQL_RES *result)
{
  return t__mysql_fetch_lengths(result);
}

MYSQL_ROW ldbms::ldbms_mysql_fetch_row(MYSQL_RES *result)
{
  return t__mysql_fetch_row(result);
}

void ldbms::ldbms_mysql_free_result(MYSQL_RES *result)
{
  t__mysql_free_result(result);
}
#if (MINGW_MARIADB == 0)
const char *ldbms::ldbms_mysql_get_client_info(void)
{
  return t__mysql_get_client_info();
}
#endif
const char *ldbms::ldbms_mysql_get_host_info(MYSQL *mysql)
{
  return t__mysql_get_host_info(mysql);
}

const char *ldbms::ldbms_mysql_info(MYSQL *mysql)
{
  return t__mysql_info(mysql);
}

MYSQL *ldbms::ldbms_mysql_init(MYSQL *mysql)
{
  return t__mysql_init(mysql);
}
#if (MINGW_MARIADB == 0)
void ldbms::ldbms_mysql_library_end()
{
  t__mysql_library_end();
}
#endif
int ldbms::ldbms_mysql_library_init(int argc, char **argv, char **groups)
{
  return t__mysql_library_init(argc, argv, groups);
}

MY_BOOL ldbms::ldbms_mysql_more_results(MYSQL *mysql)
{
  return t__mysql_more_results(mysql);
}

int ldbms::ldbms_mysql_next_result(MYSQL *mysql)
{
  return t__mysql_next_result(mysql);
}

unsigned int ldbms::ldbms_mysql_num_fields(MYSQL_RES *result)
{
  return t__mysql_num_fields(result);
}

my_ulonglong ldbms::ldbms_mysql_num_rows(MYSQL_RES *result)
{
  return t__mysql_num_rows(result);
}

int ldbms::ldbms_mysql_options(MYSQL *mysql, enum ocelot_option option, const char *arg)
{
  return t__mysql_options(mysql, option, arg);
}

int ldbms::ldbms_mysql_ping(MYSQL *mysql)
{
  return t__mysql_ping(mysql);
}

int ldbms::ldbms_mysql_query(MYSQL *mysql, const char *stmt_str)
{
  return t__mysql_query(mysql, stmt_str);
}

MYSQL *ldbms::ldbms_mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag)
{
  return t__mysql_real_connect(mysql, host, user, passwd, db, port, unix_socket, client_flag);
}

/* This is not usually called from the main thread. Do not put a message box in this. */
int ldbms::ldbms_mysql_real_query(MYSQL *mysql, const char *stmt_str, unsigned long length)
{
  return t__mysql_real_query(mysql, stmt_str, length);
}

int ldbms::ldbms_mysql_select_db(MYSQL *mysql, const char *db)
{
  return t__mysql_select_db(mysql, db);
}

const char *ldbms::ldbms_mysql_sqlstate(MYSQL *mysql)
{
  return t__mysql_sqlstate(mysql);
}

bool ldbms::ldbms_mysql_ssl_set(MYSQL *mysql, const char *a, const char *b, const char *c, const char *d, const char *e)
{
  if (t__mysql_ssl_set == NULL) return 0;
  return t__mysql_ssl_set(mysql, a, b, c, d, e);
}

MYSQL_RES *ldbms::ldbms_mysql_store_result(MYSQL *mysql)
{
  return t__mysql_store_result(mysql);
}

void ldbms::ldbms_mysql_thread_end()
{
  t__mysql_thread_end();
}

unsigned int ldbms::ldbms_mysql_warning_count(MYSQL *mysql)
{
  return t__mysql_warning_count(mysql);
}

int ldbms::ldbms_AES_set_decrypt_key(unsigned char *a, int b, AES_KEY *c)
{
  return t__AES_set_decrypt_key(a, b, c);
}

void ldbms::ldbms_AES_decrypt(unsigned char *a, unsigned char *b, AES_KEY *c)
{
  t__AES_decrypt(a, b, c);
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

#ifdef DBMS_TARANTOOL
uint32_t ldbms::ldbms_mp_decode_array(const char **data)
{
  return t__mp_decode_array(data);
}
const char* ldbms::ldbms_mp_decode_bin(const char **data, uint32_t *len)
{
  return t__mp_decode_bin(data,len);
}
//uint32_t ldbms_mp_decode_binl(const char **data)
//{
//  return t__mp_decode_binl(data);
//}
bool ldbms::ldbms_mp_decode_bool(const char **data)
{
  return t__mp_decode_bool(data);
}
float ldbms::ldbms_mp_decode_float(const char **data)
{
  return t__mp_decode_float(data);
}
double ldbms::ldbms_mp_decode_double(const char **data)
{
  return t__mp_decode_double(data);
}
int64_t ldbms::ldbms_mp_decode_int(const char **data)
{
  return t__mp_decode_int(data);
}
uint32_t ldbms::ldbms_mp_decode_map(const char **data)
{
  return t__mp_decode_map(data);
}
void ldbms::ldbms_mp_decode_nil(const char **data)
{
  return t__mp_decode_nil(data);
}
uint64_t ldbms::ldbms_mp_decode_uint(const char **data)
{
  return t__mp_decode_uint(data);
}
const char* ldbms::ldbms_mp_decode_str(const char **data, uint32_t *len)
{
  return t__mp_decode_str(data,len);
}
uint32_t ldbms::ldbms_mp_decode_strl(const char **data)
{
  return t__mp_decode_strl(data);
}
void ldbms::ldbms_mp_next(const char **data)
{
  return t__mp_next(data);
}
enum mp_type ldbms::ldbms_mp_typeof(const char c)
{
  return t__mp_typeof(c);
}
ssize_t ldbms::ldbms_tnt_auth(struct tnt_stream *a, const char *b, int c, const char *d, int e)
{
  return t__tnt_auth(a,b,c,d,e);
}
ssize_t ldbms::ldbms_tnt_call(struct tnt_stream *a, const char *b, size_t c, struct tnt_stream *d)
{
  return t__tnt_call(a,b,c,d);
}
void ldbms::ldbms_tnt_close(struct tnt_stream *a)
{
  t__tnt_close(a);
}
int ldbms::ldbms_tnt_connect(struct tnt_stream *a)
{
  return t__tnt_connect(a);
}
size_t ldbms::ldbms_tnt_delete(struct tnt_stream *a, uint32_t b, uint32_t c, tnt_stream *d)
{
  return t__tnt_delete(a,b,c,d);
}
ssize_t ldbms::ldbms_tnt_eval(struct tnt_stream *a, const char *b, size_t c, struct tnt_stream *d)
{
  return t__tnt_eval(a,b,c,d);
}
ssize_t ldbms::ldbms_tnt_flush(struct tnt_stream *a)
{
  return t__tnt_flush(a);
}
ssize_t ldbms::ldbms_tnt_execute(struct tnt_stream *a, const char *b, size_t c, struct tnt_stream *d)
{
  return t__tnt_execute(a,b,c,d);
}
int ldbms::ldbms_tnt_get_indexno(struct tnt_stream *a, int b, const char *c, size_t d)
{
  return t__tnt_get_indexno(a,b,c,d);
}
int ldbms::ldbms_tnt_get_spaceno(struct tnt_stream *a, const char *b, size_t c)
{
  return t__tnt_get_spaceno(a,b,c);
}
void ldbms::ldbms_tnt_stream_free(struct tnt_stream *a)
{
  t__tnt_stream_free(a);
}
ssize_t ldbms::ldbms_tnt_insert(struct tnt_stream *a, uint32_t b, struct tnt_stream *c)
{
  return t__tnt_insert(a,b,c);
}
tnt_stream* ldbms::ldbms_tnt_net(tnt_stream *a)
{
  return t__tnt_net(a);
}
tnt_stream* ldbms::ldbms_tnt_object(tnt_stream *a)
{
  return t__tnt_object(a);
}
ssize_t ldbms::ldbms_tnt_object_add_array(tnt_stream *a, uint32_t b)
{
  return t__tnt_object_add_array(a,b);
}
ssize_t ldbms::ldbms_tnt_object_add_nil(tnt_stream *a)
{
  return t__tnt_object_add_nil(a);
}
ssize_t ldbms::ldbms_tnt_object_add_int(tnt_stream *a, int64_t b)
{
  return t__tnt_object_add_int(a,b);
}
ssize_t ldbms::ldbms_tnt_object_add_str(tnt_stream *a, const char *b, uint32_t c)
{
  return t__tnt_object_add_str(a,b,c);
}
ssize_t ldbms::ldbms_tnt_object_add_bin(tnt_stream *a, const char *b, uint32_t c)
{
  return t__tnt_object_add_bin(a,b,c);
}
ssize_t ldbms::ldbms_tnt_object_add_bool(tnt_stream *a, char b)
{
  return t__tnt_object_add_bool(a,b);
}
ssize_t ldbms::ldbms_tnt_object_add_float(tnt_stream *a, float b)
{
  return t__tnt_object_add_float(a,b);
}
ssize_t ldbms::ldbms_tnt_object_add_double(tnt_stream *a, double b)
{
  return t__tnt_object_add_double(a,b);
}
ssize_t ldbms::ldbms_tnt_object_container_close(tnt_stream *a)
{
  return t__tnt_object_container_close(a);
}
ssize_t ldbms::ldbms_tnt_object_format(struct tnt_stream *a, const char *b, int c)
{
  return t__tnt_object_format(a,b,c);
}
int ldbms::ldbms_tnt_object_reset(struct tnt_stream *a)
{
  return t__tnt_object_reset(a);
}
int ldbms::ldbms_tnt_reload_schema(struct tnt_stream *a)
{
  return t__tnt_reload_schema(a);
}
ssize_t ldbms::ldbms_tnt_replace(struct tnt_stream *a, uint32_t b, struct tnt_stream *c)
{
  return t__tnt_replace(a,b,c);
}
int ldbms::ldbms_ttnt_reply(struct tnt_reply *a, char *b, size_t c, size_t *d)
{
  return t__tnt_reply(a,b,c,d);
}
void ldbms::ldbms_tnt_reply_free(struct tnt_reply *a)
{
  t__tnt_reply_free(a);
}
int64_t ldbms::ldbms_tnt_request_compile(struct tnt_stream *a, struct tnt_request *b)
{
  return t__tnt_request_compile(a,b);
}
struct tnt_request* ldbms::ldbms_tnt_request_eval(struct tnt_request *a)
{
  return t__tnt_request_eval(a);
}
struct tnt_request* ldbms::ldbms_tnt_request_call(struct tnt_request *a)
{
  return t__tnt_request_call(a);
}
int ldbms::ldbms_tnt_request_set_exprz(struct tnt_request *a, const char *b)
{
  return t__tnt_request_set_exprz(a,b);
}
int ldbms::ldbms_tnt_request_set_tuple(struct tnt_request *a, struct tnt_stream *b)
{
  return t__tnt_request_set_tuple(a,b);
}
struct tnt_reply* ldbms::ldbms_tnt_reply_init(struct tnt_reply *a)
{
  return t__tnt_reply_init(a);
}
ssize_t ldbms::ldbms_tnt_select(struct tnt_stream *a, uint32_t b, uint32_t c, uint32_t d, uint32_t e, uint8_t f, struct tnt_stream *g)
{
  return t__tnt_select(a,b,c,d,e,f,g);
}
int ldbms::ldbms_tnt_set(struct tnt_stream *a, int b, char *c)
{
  return t__tnt_set(a,b,c);
}
ssize_t ldbms::ldbms_tnt_update(struct tnt_stream *a, uint32_t b, uint32_t c, struct tnt_stream *d, struct tnt_stream *e)
{
  return t__tnt_update(a,b,c,d,e);
}
enum tnt_error ldbms::ldbms_tnt_error(struct tnt_stream *a)
{
  return t__tnt_error(a);
}
char* ldbms::ldbms_tnt_strerror(struct tnt_stream *a)
{
  return t__tnt_strerror(a);
}
#endif

/******************** ldbms end ***********************************************/

/******************** Result_changes start ***********************************************/

Result_changes::Result_changes(Result_qtextedit *m)
{
  result_qtextedit= m;
  rows_and_columns_list= new QList<Rows_and_columns>;
}

void Result_changes::append(unsigned int row_number, unsigned int column_number, QByteArray *value)
{
  Rows_and_columns r;
  r.row_number= row_number;
  r.column_number= column_number;
  r.qba= *value;
  rows_and_columns_list->append(r);
}

QByteArray Result_changes::find(unsigned int row_number, unsigned int column_number)
{
  for (int i= rows_and_columns_list->size() - 1; i >= 0; --i)
  {
    Rows_and_columns r= rows_and_columns_list->at(i);
    if ((r.row_number == row_number)
      && (r.column_number == column_number))
    {
      return rows_and_columns_list->at(i).qba;
    }
  }
  return QByteArray(1, 0); /* Todo: I really would prefer to return with size 0 */
}

/* Todo: ? */
Result_changes::~Result_changes()
{
  delete rows_and_columns_list;
}

/******************** Result_changes end ***********************************************/

#if (OCELOT_QWT_INCLUDE == 1)
QMultiBarChart::QMultiBarChart(QChart*passed_qchart): QwtPlotMultiBarChart("Top")
{
  qchart= passed_qchart;
}
#endif //#if (OCELOT_QWT_INCLUDE == 1)

/******************** ResultGrid start ***********************************************/

ResultGrid::ResultGrid(
//        MYSQL_RES *mysql_res,
        ldbms *passed_lmysql,
        MainWindow *parent,
        bool is_displayable,
        int passed_result_grid_type) : QWidget(parent)
{
  result_grid_type= passed_result_grid_type;
  is_paintable= 0;

  /* todo: see if we can get rid of client and go direct to resultgrid */
  client= new QWidget(this);
  lmysql= passed_lmysql;

  copy_of_parent= parent;
#ifdef OLD_STUFF
  text_edit_widgets= 0;                                     /* all dynamic-sized items should be initially zero */
  text_edit_layouts= 0;
  text_edit_frames= 0;
#endif
  grid_column_widths= 0;                                    /* initializing for display_garbage_collect */
  result_max_column_widths= 0;
  grid_column_heights= 0;
  grid_column_dbms_sources= 0;
  result_field_types= 0;                                     /* initializing for fillup_garbage_collect */
  result_field_charsetnrs= 0;
  result_field_flags= 0;
  result_set_copy= 0;
  result_set_copy_rows= 0;
  result_field_names= 0;
  result_original_field_names= 0;
  result_original_table_names= 0;
  result_original_database_names= 0;
  gridx_field_names= 0;

  gridx_max_column_widths= 0;
  gridx_result_indexes= 0;
  gridx_flags= 0;
  gridx_field_types= 0;
  grid_vertical_scroll_bar= 0;
  grid_scroll_area= 0;
  /* grid_layout= 0; */
  hbox_layout= 0;
  //grid_row_layouts= 0;
  //grid_row_widgets= 0;
  grid_main_layout= 0;

  /* grid_main_widget= 0; */
  border_size= 1;                                          /* Todo: This actually has to depend on stylesheet */

  /* For some reason the next two lines were commented out. */
  result_row_count= 0;
  result_column_count= 0;
  grid_result_row_count= 0;
#ifdef OLD_STUFF
  max_text_edit_frames_count= 0;
#endif
#if (OCELOT_CHART_OR_QCHART == 1)
  chart_widget= NULL;
#endif
  if (is_displayable == false)
  {
    grid_main_layout= 0;
    html_text_edit= NULL;
    batch_text_edit= NULL;
    return;
  }

  result_grid_widget_max_height_in_lines= RESULT_GRID_WIDGET_INITIAL_HEIGHT;

  /* We might say "new ResultGrid(0)" merely so we'd have ResultGrid in the middle spot in the layout-> */
  /* Create the cell pool. */
  /*
    Make the cells. Each cell is one QTextEdit (subclassed as TextEditWidget)
    within one QHBoxLayout within one TextEditFrame.
    Each TexteditFrame i.e. text_edit_frames[n] will be added to the scroll area.
  */
  /* Todo: say "(this)" a lot so automatic garbage collect will work. */
  grid_scroll_area= new QScrollArea(this);

  grid_scroll_area->setWidget(client);
  grid_scroll_area->setWidgetResizable(true);              /* Without this, the QTextEdit widget heights won't change */

  vertical_scroll_bar_construct(); /* grid_vertical_scroll_bar= new QScrollBar(this); etc. */

  /* setContentsMargins overrides style settings, I suppose. */
  /* Will setSpacing(0) keep scroll bar beside scroll area? Apparently not. Useless. */
  /* We could add a label with a line like the one below. That would be a header. Useless? */
  /* hbox_layout->addWidget(new QLabel("La La La", this)); */
  hbox_layout= new QHBoxLayout(this);
  /*
    An earlier comment about this area said:
    "The following line would make the grid_vertical_scroll_bar appear right beside the
    grid_scroll_area, but the scroll bars on the QTextEdit widgets would disappear. No good.
    hbox_layout->setSizeConstraint(QLayout::SetFixedSize);
       ... but that would be a reasonable thing to do if total width of all columns is less than widget width."
    But now, I'm not seeing that the scroll bars on the QTextEdit
    widgets disappear. If this wasn't here, it would be tough to prevent width expansion when columns
    don't fill the line. Even as it is, the amount of desperate kludging is something to behold, eh?
    Todo: calculate the width more accurately.
    Todo: Now the bloody thing won't get shrink! Need to get the signal for resizing.
  */
  /*
    int xxsize= 0 ;
    for (int xxcol= 0 ; xxcol<result_column_count; ++xxcol) xxsize+=grid_column_widths[xxcol] + 10;
    if (xxsize > (ocelot_grid_max_desired_width_in_pixels-50)) xxsize=ocelot_grid_max_desired_width_in_pixels-50;
    grid_scroll_area->setMinimumWidth(xxsize);
  */
  hbox_layout->setContentsMargins(0, 0, 0, 0);
  hbox_layout->setSpacing(0);
  /* html_text_edit + batch_text_edit exist always except during temporary delete in display_garbage_collect() */
  html_text_edit= new Result_qtextedit(this);
  batch_text_edit= new QTextEdit(this);

  hbox_layout->addWidget(grid_scroll_area);
//  hbox_layout->addWidget(html_text_edit);
//  html_text_edit->show();

  hbox_layout->addWidget(grid_vertical_scroll_bar);
  grid_vertical_scroll_bar->show();
  /* hbox_layout->setSizeConstraint(QLayout::SetFixedSize); */
  /*
    Strange but true: when we said "new QHBoxLayout(this)" that meant this already has a layout,
    so I suppose there is no need to say "setLayout(hbox_layout)" here.
  */
  /* setLayout(hbox_layout); */
  /* Can't recall why "grid_vertical_scroll_bar_value= 0;" was here -- it meant that
     after fontchange the rows were back at the start */
  /* grid_vertical_scroll_bar_value= 0; */
  /* grid_vertical_scroll_bar= grid_scroll_area->verticalScrollBar(); */

  /* Typically scroll_bar_width = 13.
     If there was an option to change it, we'd have to use
     a different way to find its width.
     Todo: move this, it doesn't need recalculation
     Todo: some people on a forum said height is 3 pixels too small.
  */
  scroll_bar_width= html_text_edit->style()->pixelMetric(QStyle::PM_ScrollBarExtent);
  scroll_bar_height= html_text_edit->style()->pixelMetric(QStyle::PM_ScrollBarExtent);

  /* This won't be correct until after resizeEvent() and after a real display of the resultgrid widget */
  result_grid_height_after_last_resize= -1;
  result_grid_width_after_last_resize= -1;

  /*
    Just a note for the archives ...
    Originally I had "grid_main_layout= new QVBoxLayout(client);" here.
    I didn't realize that caused the equivalent of client->setLayout(), apparently.
    So the later pseudo-assertion (checking if client->layout() != 0) happened. Don't need that.
  */
  grid_main_layout= new QVBoxLayout();
  grid_main_layout->setContentsMargins(QMargins(0, 0, 0, 0));   /* this overrides style settings, I suppose */

  grid_main_layout->setSpacing(0);                          /* ?? premature? */

  /* We used to say this but override it in some display functions */
  //grid_main_layout->setSizeConstraint(QLayout::SetFixedSize);  /* This ensures the grid columns have no spaces between them */
  grid_main_layout->setSizeConstraint(QLayout::SetMaximumSize);

//  grid_main_layout->addWidget(html_text_edit); /* Huh? This can't be right. */

  client->setLayout(grid_main_layout);

  /* 2018-10-08 Maybe this will finally fix the bug where initial cell height was too small? */
  // result_grid_font= this->font();
#if (OCELOT_EXPLORER == 1)
  if (result_grid_type == EXPLORER_WIDGET)
    result_grid_font= parent->get_font_from_style_sheet(parent->ocelot_explorer_style_string);
  else
#endif
    result_grid_font= parent->get_font_from_style_sheet(parent->ocelot_grid_style_string);

  settings_change_calc();

  set_grid_max_column_height_in_pixels((parent->height() / 3) - 11);
#ifdef OLD_STUFF
  set_frame_color_setting();
#endif

  copy_of_ocelot_batch= copy_of_ocelot_html= copy_of_ocelot_raw= copy_of_ocelot_xml= 0;
}

/*
  Return true if what's at pointer has an image signature.
  We only do this for Tarantool, we set data type = OCELOT_DATA_TYPE_BLOB
  if the length is > 100 (arbitrary) and if the signature for .jpg or
  .png or .gif is at the start (not a reliable check but a false hit won't do a
  lot of harm). See wikipedia article = List of file signatures.
  We don't actually care except for extra_rule_1.
  We could do this check for MySQL/MariaDB too, but for them we simply
  look at the data type.
  Todo: check for other signatures, e.g. bmp.
*/
bool ResultGrid::is_image_format(int length, char* pointer)
{
  unsigned char *p= (unsigned char*) pointer;
  if (length <= 100) return false;
  if ((*p == 0x89) && (*(p+1) == 0x50) && (*(p+2) == 0x4e))
    return true;
  if ((*p == 0xff) && (*(p+1) == 0xd8) && (*(p+2) == 0xff))
    return true;
  if ((memcmp(p,"GIF87a",6) == 0) || (memcmp(p,"GIF89a",6) == 0))
    return true;
  return false;
}

/*
  Return false if the display doesn't have a table that we can do fancy things with.
  Else Result_qtextedit overriding functions e.g. mouseMoveEvent() will get confused.
  Todo: Maybe part of this is unnecessary, display_batch uses batch_text_edit not html_text_edit.
*/
bool ResultGrid::is_fancy()
{
#if (OCELOT_EXPLORER == 1)
  if (result_grid_type == EXPLORER_WIDGET) return true;
#endif
  if ((result_row_count == 0) || (result_column_count == 0)) return false;
  if (html_text_edit == NULL) return false;
  if ((copy_of_ocelot_batch != 0)
   || (copy_of_ocelot_xml != 0)
   || (copy_of_ocelot_raw != 0))
    return false;
  return true;
}

/* Todo: not everything that calls fillup() calls fillup_garbage_collect() later, i.e. leak */
/* We call fillup() whenever there is a new result set to put up on the result grid widget. */
QString ResultGrid::fillup(MYSQL_RES *mysql_res,
            //struct tnt_reply *tarantool_tnt_reply,
            int connections_dbms,
            //MainWindow *parent,
            ldbms *passed_lmysql,
            int ocelot_client_side_functions,
            unsigned int connection_number,
            bool is_for_display)
{
  /* TODO: put the copy_res_to_result stuff in a subsidiary private procedure. */
  lmysql= passed_lmysql;
  ocelot_client_side_functions_copy= ocelot_client_side_functions;

  grid_mysql_res= mysql_res;
#ifdef DBMS_TARANTOOL
  if (connections_dbms == DBMS_TARANTOOL)
  {
    result_row_count= copy_of_parent->tarantool_num_rows(connection_number);
    if (result_row_count == 0)
    {
      /* Tarantool has no columns if there are no rows. */
      /* Todo: this is no longer true, if type = 5 */
      result_column_count= 0; /* solves the crash? */
      return "OK";
    }
    result_column_count= copy_of_parent->tarantool_num_fields();
  }
  else
#endif
  {
#if (OCELOT_MYSQL_INCLUDE == 1)
    result_column_count= lmysql->ldbms_mysql_num_fields(grid_mysql_res);
    result_row_count= lmysql->ldbms_mysql_num_rows(grid_mysql_res);                /* this will be the height of the grid */
    mysql_fields= lmysql->ldbms_mysql_fetch_fields(grid_mysql_res);
#else
    ;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  }
  result_max_column_widths= new unsigned int[result_column_count];
  result_field_types= new unsigned short int[result_column_count];
  result_field_charsetnrs= new unsigned int[result_column_count];
  result_field_flags= new unsigned int[result_column_count];

#ifdef DBMS_TARANTOOL
  if (connections_dbms == DBMS_TARANTOOL)
  {
    QString result= copy_of_parent->tarantool_scan_rows(result_column_count, result_row_count,
              grid_mysql_res,
              &result_set_copy, &result_set_copy_rows,
              &result_max_column_widths);
    if (result != "OK")
    {
      fillup_garbage_collect(false);
      return result;
    }
  }
  else
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
    scan_rows(result_column_count, result_row_count,
              grid_mysql_res,
              &result_set_copy, &result_set_copy_rows,
              &result_max_column_widths);
#else
    {;}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
  if (connections_dbms == DBMS_TARANTOOL)
  {
    QString r;
    r= copy_of_parent->tarantool_scan_field_names("name", result_column_count, &result_field_names, is_for_display);
    if (r != "OK") return r;
    /* Next three scan_field_names calls are only needed if user will edit the result set */
    copy_of_parent->tarantool_scan_field_names("org_name", result_column_count, &result_original_field_names, is_for_display);
    copy_of_parent->tarantool_scan_field_names("org_table", result_column_count, &result_original_table_names, is_for_display);
    copy_of_parent->tarantool_scan_field_names("db", result_column_count, &result_original_database_names, is_for_display);
  }
  else
#endif
  {
#if (OCELOT_MYSQL_INCLUDE == 1)
    scan_field_names("name", result_column_count, &result_field_names);
    /* Next three scan_field_names calls are only needed if user will edit the result set */
    scan_field_names("org_name", result_column_count, &result_original_field_names);
    scan_field_names("org_table", result_column_count, &result_original_table_names);
    scan_field_names("db", result_column_count, &result_original_database_names);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  }
#ifdef DBMS_TARANTOOL
  /* Scan entire result set to determine if NUM_FLAG should go on. */
  /* TODO: maybe this is unnecessary now that we are checking numericness for each cell? */
  if (connections_dbms == DBMS_TARANTOOL)
  {
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      //result_field_types[i]= OCELOT_DATA_TYPE_VAR_STRING; replaced on 2021-01-03
      result_field_types[i]= copy_of_parent->field_type_list_all_rows[i];
      result_field_charsetnrs[i]= 83; /* utf8, utf8_bin */
      result_field_flags[i]= 0; /* todo: decide if it's numeric */
    }
    long unsigned int tmp_xrow;
    char *pointer= result_set_copy_rows[0];
    unsigned int v_length;
    for (tmp_xrow= 0; tmp_xrow < result_row_count; ++tmp_xrow)
    {
      for (unsigned int i= 0; i < result_column_count; ++i)
      {
        memcpy(&v_length, pointer, sizeof(unsigned int));
        char tmp_flag= *(pointer + sizeof(unsigned int));
        result_field_flags[i]|= tmp_flag;
        if (tmp_flag == FIELD_VALUE_FLAG_IS_STRING)
        {
          if (is_image_format(v_length, pointer + sizeof(unsigned int) + sizeof(char)))
          {
            result_field_flags[i]|= FIELD_VALUE_FLAG_IS_IMAGE;
          }
        }
        pointer+= v_length + sizeof(unsigned int) + sizeof(char);
      }
    }
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      if ((result_field_flags[i] & (FIELD_VALUE_FLAG_IS_NUMBER | FIELD_VALUE_FLAG_IS_STRING)) == FIELD_VALUE_FLAG_IS_NUMBER)
        result_field_flags[i]= NUM_FLAG;
      else
      {
        if ((result_field_flags[i] & FIELD_VALUE_FLAG_IS_IMAGE) != 0)
        {
          result_field_types[i]= OCELOT_DATA_TYPE_BLOB;
          result_field_charsetnrs[i]= 63;
        }
        result_field_flags[i]= 0;
      }
    }
  }
  else
#endif

  {
#if (OCELOT_MYSQL_INCLUDE == 1)
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      result_field_types[i]= mysql_fields[i].type;
      result_field_charsetnrs[i]= mysql_fields[i].charsetnr;
      result_field_flags[i]= mysql_fields[i].flags;
    }
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  }

#if (OCELOT_PLUGIN == 1)
  if (copy_of_parent->plugin_widget_list.size() > 0)
  {
    //ocelot_plugin_pass.query is usually already known at this stage, if fillup was called due to the query
    ocelot_plugin_pass.result_set_copy= result_set_copy;
    ocelot_plugin_pass.result_row_count= result_row_count;
    ocelot_plugin_pass.result_column_count= result_column_count;
    /* int return_code= */ copy_of_parent->plugin_widget_list_caller(PLUGIN_FILLUP, "");
    //if (return_code ==  PLUGIN_RETURN_OK_AND_REPLACED)
    //  text= QString::fromUtf8(ocelot_plugin_pass.replacer_buffer, ocelot_plugin_pass.replacer_buffer_length);
    // ! we'd need to re-allocate result_set_copy_rows!
  }
#endif

  if (copy_of_parent->conditional_settings.count() > 0)
  {
    /* Todo: filter conditional_settings so for some frames we won't need to check every time */
  }

  /*
    At this point, we have:
      result_column_count, result_row_count
      result_set_copy, result_set_copy_rows,
      result_field_names,
      result_original_field_names, result_original_table_names, result_original_database_names,
      result_max_column_widths
      mysql_fields (which we should not use, but we do)
    From now on there should be no need to call mysql_ functions again for this result set.
    if is_for_display was true, we're ready to call display() now
  */
  copy_of_connections_dbms= connections_dbms; /* Todo: check: will I ever need this? */
  return "OK";
}

/* Called just before calling fillup() first time, or fillup_in_client() */
void MainWindow::fillup_prepare()
{
  ResultGrid *rg;
  for (int i_r= 0; i_r < ocelot_ca.grid_actual_tabs; ++i_r)
  {
    rg= qobject_cast<ResultGrid*>(result_grid_tab_widget->widget(i_r));
    rg->is_paintable= 0;
    rg->fillup_garbage_collect(false);
    rg->display_garbage_collect(false);
  }
}

/*
  Take a SELECT and make a result set entirely in the client i.e. ocelotgui makes it rather than calling the server.
  Input = SELECT ... UNION ALL SELECT ... e.g. SELECT 'a' [AS column_name],5 [AS column_name] UNION ALL 'b',6.
  Very strict! No other keywords, UTF-8 only. Limited token count. All rows must have same characteristics.
  Warning: might be callable from routines that have already called main_token_push()?
  Useful for: SET ocelot_query = a query that will return a small result set e.g. called by SELECT * FROM menus;
              ("SET ocelot_query =" is optional wording at this point)
  Useful for: plugin that wants to create its own result set. Easiest way to do that is SELECT ... UNION ALL SELECT ...
  Todo: check whether this is duplicating rehash_scan()
*/
QString ResultGrid::fillup_in_client(QString query, int *token_lengths, int *token_offsets)
{
  copy_of_parent->log("fillup_in_client start", 15);
  QString return_value= "OK"; /* if all is well this will stay "OK" */
  char *result_field_names_pointer;
  int result_field_names_size;
//  int query_len= query.size(); /* or toUtf8().size()? */
//  int  *token_offsets;
//  int  *token_lengths;
//  int desired_count;
//  desired_count= query_len + 1; /* usually far more than necessary */
//  token_offsets= new int[desired_count];
//  token_lengths= new int[desired_count];
//  token_lengths[0]= 0;
//  copy_of_parent->tokenize(query.data(),
//           query_len,
//           &token_lengths[0], &token_offsets[0], desired_count- 1,
//          (QChar*)"33333", 2, "", 1);

  QStringList column_name_list;
  QStringList values_list;
  QList<int> types_list;
  result_column_count= 0; /* this will be the number of literals in row zero */
  result_row_count= 0;
  unsigned int rolling_column_count= 0;
  int first_token= 0;
  if (query.mid(token_offsets[0], token_lengths[0]).toUpper() == "SET")
  {
    first_token= 3;
  }
  for (int j= first_token;; ++j)
  {
    QString token= query.mid(token_offsets[j], token_lengths[j]);
    /* possible tokens: SELECT, UNION, ALL, comma, semicolon, 'literal', literal, identifier */
    QString token_upper= token.toUpper();
    if ((token_upper == "UNION") || (token == ";") || (token_lengths[j] == 0))  /* end of row? */
    {
      if (result_row_count == 1)
      {
        result_column_count= rolling_column_count;
      }
      else
      {
        if (rolling_column_count != result_column_count)
        {
          return_value= "Error: row#1 has " + QString::number(result_column_count) + " columns, "
                        + "row#" + QString::number(result_row_count) + " has " + QString::number(rolling_column_count) + " columns";
          break;
        }
      }
      if ((token == ";") || (token_lengths[j] == 0)) break; /* end of query? */
      continue;
    }
    if (token_upper == "ALL") continue; /* ignorable, we assume all UNIONs are UNION ALL */
    if (token_upper == ",") continue; /* ignorable? */
    if (token_upper == "SELECT") /* start of row */
    {
      ++result_row_count;
      rolling_column_count= 0;
      continue;
    }
    ++rolling_column_count; /* well, it must be a literal */
    int type;
    if (token.left(1) == "'") type= OCELOT_DATA_TYPE_TEXT;
    else type= OCELOT_DATA_TYPE_NUMBER;
    if (result_row_count == 1)
    {
      types_list.append(type);
    }
    else
    {
      int row_1_type= types_list.at(rolling_column_count - 1);
      if (type != row_1_type)
      {
        return_value= "Error. row#1 column#" + QString::number(rolling_column_count) + " and "
                      + "row#" + QString::number(result_row_count) + " have different types";
        break;
      }
    }
    token= copy_of_parent->connect_stripper(token, true);
    values_list.append(token);
    /* If next after value is "AS" then pick up the name that follows, and if result_row_count == 1 save that or value */
    QString token_after_value= query.mid(token_offsets[j + 1], token_lengths[j + 1]);
    token_after_value= token_after_value.toUpper();
    QString column_name;
    if (token_after_value == "AS")
    {
      j+= 2;
      column_name= query.mid(token_offsets[j], token_lengths[j]);
      column_name= copy_of_parent->connect_stripper(column_name, true);
    }
    else column_name= token;
    if (result_row_count == 1) column_name_list.append(column_name);
    continue;
  }
  if (return_value != "OK") goto returner;
  /* So now the column names are in column_name_list, the values are in values_list, and no errors were seen */
  result_max_column_widths= new unsigned int[result_column_count];
  result_field_types= new unsigned short int[result_column_count];
  result_field_charsetnrs= new unsigned int[result_column_count];
  result_field_flags= new unsigned int[result_column_count];
  for (unsigned int i= 0; i < result_column_count; ++i)
  {
    //result_field_types[i]= OCELOT_DATA_TYPE_VAR_STRING; replaced on 2021-01-03
    if (types_list[i] == OCELOT_DATA_TYPE_TEXT)
    {
      result_field_types[i]= OCELOT_DATA_TYPE_TEXT;
      result_field_flags[i]= 0;
    }
    else /* if (== OCELOT_DATA_TYPE_NUMBER) */
    {
      result_field_types[i]= OCELOT_DATA_TYPE_NUMBER;
      result_field_flags[i]= NUM_FLAG;
    }
    result_field_charsetnrs[i]= 83; /* utf8, utf8_bin */
  }
  gridx_column_count= result_column_count;
  gridx_field_types= new short unsigned int[gridx_column_count];
  for (unsigned int i= 0; i < result_column_count; ++i)
  {
    gridx_field_types[i]= result_field_types[i];
  }
  grid_column_widths= new unsigned int[gridx_column_count];
  copy_of_ocelot_batch= copy_of_ocelot_xml= copy_of_ocelot_raw= ocelot_vertical_copy= 0;
  ocelot_result_grid_column_names_copy= 0;
  result_field_names_size= 0;
  for (unsigned int i= 0; i < result_column_count; ++i)
  {
    result_field_names_size+= sizeof(unsigned int);
    result_field_names_size+= column_name_list.at(i).toUtf8().size();
  }
  result_field_names= new char[result_field_names_size];
  result_field_names_pointer= &result_field_names[0];
  unsigned int v_length;
  for (unsigned int i= 0; i < result_column_count; ++i)
  {
    char field_name[256];
    strcpy(field_name, column_name_list.at(i).toUtf8());
    v_length= strlen(field_name);
    memcpy(result_field_names_pointer, &v_length, sizeof(unsigned int));
    result_field_names_pointer+= sizeof(unsigned int);
    memcpy(result_field_names_pointer, field_name, v_length);
    result_field_names_pointer+= v_length;
  }
  return_value= client_scan_rows(result_column_count, result_row_count,
            /* NULL grid_mysql_res , */
            &result_set_copy, &result_set_copy_rows,
            &result_max_column_widths, query.toUtf8().size(), values_list, types_list);
returner:
//  delete [] token_lengths;
//  delete [] token_offsets;
  copy_of_parent->log("fillup_in_client end", 15);
  return return_value;
}

/* This is the equivalent of scan_rows() for MySQL/MariaDB and tarantool_scan_rows() for Tarantool */
QString ResultGrid::client_scan_rows(unsigned int p_result_column_count, unsigned int p_result_row_count,
     /* MYSQL_RES *p_mysql_res, */
     char **p_result_set_copy,
     char ***p_result_set_copy_rows,
     unsigned int **p_result_max_column_widths, int query_size, QStringList values_list, QList<int> types_list)
{
  for (unsigned int i= 0; i < p_result_column_count; ++i) (*p_result_max_column_widths)[i]= 0;
  char *result_set_copy_pointer;
  /* total_size= (#-of-rows)*(#-of-columns-per-row)*5+total-lengths, but allow more as it's easy to calculate */
  unsigned long int total_size= (p_result_row_count * p_result_column_count * 5) + query_size;

  *p_result_set_copy= new char[total_size];                                              /* allocate */
  *p_result_set_copy_rows= new char*[p_result_row_count];
  result_set_copy_pointer= *p_result_set_copy;

  for (long unsigned int v_r= 0; v_r < result_row_count; ++v_r)
  {
    (*p_result_set_copy_rows)[v_r]= result_set_copy_pointer;
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      QString value= values_list.at(v_r * p_result_column_count + i);
      int v_length= value.toUtf8().size();
      set_max_column_width(v_length, value.toUtf8(), (&(*p_result_max_column_widths)[i]));
      memcpy(result_set_copy_pointer, &v_length, sizeof(unsigned int));
      if (types_list.at(i) == OCELOT_DATA_TYPE_TEXT)
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_STRING;
      else
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_NUMBER;
      result_set_copy_pointer+= sizeof(unsigned int) + sizeof(char);
      memcpy(result_set_copy_pointer, value.toUtf8(), v_length);
      result_set_copy_pointer+= v_length;
    }
  }
  return "OK";
}


void ResultGrid::switch_to_batch_text_edit()
{
  if (html_text_edit->isVisible() == true) html_text_edit->hide();
  if (batch_text_edit->isVisible() == false) batch_text_edit->show();
  if (grid_main_layout->indexOf(html_text_edit) != -1) grid_main_layout->removeWidget(html_text_edit);
  if (grid_main_layout->indexOf(batch_text_edit) == -1) grid_main_layout->addWidget(batch_text_edit);
}

void ResultGrid::switch_to_html_text_edit()
{
  if (batch_text_edit->isVisible() == true) batch_text_edit->hide();
  if (html_text_edit->isVisible() == false) html_text_edit->show();
  if (grid_main_layout->indexOf(batch_text_edit) != -1) grid_main_layout->removeWidget(batch_text_edit);
  if (grid_main_layout->indexOf(html_text_edit) == -1) grid_main_layout->addWidget(html_text_edit);
}

/*
  For display with xml or batch or raw, i.e. not the usual (html). Just dump.
  Todo: Check: ocelot_ca.html!=0 and ocelot_ca.raw != 0 and ocelot_ca.vertical != 0.
*/
void ResultGrid::display_batch()
{
  switch_to_batch_text_edit(); /* so grid_main_layout has batch_text_edit and not html_text_edit */
  char ocelot_grid_table_start[896];
  char ocelot_grid_header_row_start[32];
  char ocelot_grid_header_row_end[32];
  char ocelot_grid_header_numeric_column_start[32];
  char ocelot_grid_header_numeric_column_end[32];
  char ocelot_grid_header_char_column_start[32];
  char ocelot_grid_header_char_column_end[32];
  char ocelot_grid_detail_row_start[32];
  char ocelot_grid_detail_row_end[32];
  char ocelot_grid_detail_numeric_column_start[32];
  char ocelot_grid_detail_numeric_column_end[32];
  char ocelot_grid_detail_char_column_start[320];
  char ocelot_grid_detail_char_column_end[32];
  char ocelot_grid_table_end[320];

  /* Todo: this should be done permanently, on persistent variables. */
  if (copy_of_ocelot_html != 0)
  {
    char html_border_color[32];
    char html_color[32];
    char html_background_color[32];
    char html_header_background_color[32];
    char html_font_family[32];
    char html_font_size[32];
    char html_font_style[32];
    char html_font_weight[32];
    char html_outer_color[32];
    int html_border_size;
    strcpy(html_border_color, copy_of_parent->ocelot_grid_cell_border_color.toUtf8());
    strcpy(html_color, copy_of_parent->ocelot_grid_text_color.toUtf8());
    strcpy(html_background_color, copy_of_parent->ocelot_grid_background_color.toUtf8());
    strcpy(html_header_background_color, copy_of_parent->ocelot_grid_header_background_color.toUtf8());
    strcpy(html_font_family, copy_of_parent->ocelot_grid_font_family.toUtf8());
    strcpy(html_font_size, copy_of_parent->ocelot_grid_font_size.toUtf8());
    strcpy(html_font_style, copy_of_parent->ocelot_grid_font_style.toUtf8());
    strcpy(html_font_weight, copy_of_parent->ocelot_grid_font_weight.toUtf8());
    strcpy(html_outer_color, copy_of_parent->ocelot_grid_outer_color.toUtf8());
    html_border_size= copy_of_parent->ocelot_grid_cell_border_size.toInt();
    sprintf(ocelot_grid_table_start, "<head><style type=text/css>"
            " th {"
            "border-color: %s; "
            "border-style: solid; "
            "padding-left: 1px; "
            "padding-right: 1px; "
            "color: %s; "
            "background-color: %s; "
            "font-family: %s; "
            "font-size: %spx; "
            "font-style: %s; "
            "font-weight: %s}"
            " td {"
            "border-color: %s; "
            "border-style: solid; "
            "padding-left: 1px; "
            "padding-right: 1px; "
            "color: %s; "
            "background-color: %s; "
            "font-family: %s; "
            "font-size: %spx; "
            "font-style: %s; "
            "font-weight: %s}"
            "</style></head><BODY><TABLE BORDER=%d>",
            html_border_color,
            html_color,
            html_header_background_color,
            html_font_family,
            html_font_size,
            html_font_style,
            html_font_weight,
            html_border_color,
            html_color,
            html_background_color,
            html_font_family,
            html_font_size,
            html_font_style,
            html_font_weight,
            html_border_size);
    strcpy(ocelot_grid_header_row_start, "<TR>");
    strcpy(ocelot_grid_header_row_end, "</TR>");
    strcpy(ocelot_grid_header_numeric_column_start, "<TH>");
    strcpy(ocelot_grid_header_numeric_column_end, "</TH>");
    strcpy(ocelot_grid_header_char_column_start, "<TH>");
    strcpy(ocelot_grid_header_char_column_end, "</TH>");
    strcpy(ocelot_grid_detail_row_start, "<TR>");
    strcpy(ocelot_grid_detail_row_end, "</TR>");
    strcpy(ocelot_grid_detail_numeric_column_start, "<TD align=\"right\">");
    strcpy(ocelot_grid_detail_numeric_column_end,"</TD>");
    strcpy(ocelot_grid_detail_char_column_start, "<TD>");
    strcpy(ocelot_grid_detail_char_column_end , "</TD>");
    strcpy(ocelot_grid_table_end, "</TABLE></BODY></HTML>");
  }
  else if (copy_of_ocelot_batch != 0)
  {
    strcpy(ocelot_grid_table_start, "");
    strcpy(ocelot_grid_header_row_start, "");
    strcpy(ocelot_grid_header_row_end, "\n");
    strcpy(ocelot_grid_header_numeric_column_start, "");
    strcpy(ocelot_grid_header_numeric_column_end, "\t");
    strcpy(ocelot_grid_header_char_column_start, "");
    strcpy(ocelot_grid_header_char_column_end, "\t");
    strcpy(ocelot_grid_detail_row_start, "");
    strcpy(ocelot_grid_detail_row_end, "\n");
    strcpy(ocelot_grid_detail_numeric_column_start, "");
    strcpy(ocelot_grid_detail_numeric_column_end, "\t");
    strcpy(ocelot_grid_detail_char_column_start, "");
    strcpy(ocelot_grid_detail_char_column_end , "\t");
    strcpy(ocelot_grid_table_end, "");
  }
  else /* copy_of_ocelot_xml != 0 */
  {
    strcpy(ocelot_grid_table_start, "<?xml version=\"1.0\"?>"
                                    "<resultset statement=\"");
    strcat(ocelot_grid_table_start, copy_of_parent->query_utf16_copy.toUtf8());
    strcat(ocelot_grid_table_start, "\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">");
    strcpy(ocelot_grid_header_row_start, "<row>");
    strcpy(ocelot_grid_header_row_end, "</row>");
    strcpy(ocelot_grid_header_numeric_column_start, "<field name=\"");
    strcpy(ocelot_grid_header_numeric_column_end, "</field>");
    strcpy(ocelot_grid_header_char_column_start, "<field name=\"");
    strcpy(ocelot_grid_header_char_column_end, "</field>");
    strcpy(ocelot_grid_detail_row_start, "<row>");
    strcpy(ocelot_grid_detail_row_end, "</row>");
    strcpy(ocelot_grid_detail_numeric_column_start, "<field name=\"");
    strcpy(ocelot_grid_detail_numeric_column_end, "</field>");
    strcpy(ocelot_grid_detail_char_column_start, "<field name=\"");
    strcpy(ocelot_grid_detail_char_column_end , "</field>");
    strcpy(ocelot_grid_table_end, "</resultset>");
  }
//  hide(); /* todo: I'm not sure whether this has a point while the kludges exist */
  //batch_text_edit->clear(); /* I'm sure this has a point while the kludges exist */

  grid_vertical_scroll_bar->setVisible(false);

  if ((result_row_count == 0) || (result_column_count == 0))
  {
    batch_text_edit->clear();
    batch_text_edit->insertPlainText("row_count == 0 or column_count == 0");
//    this->show();
//    client->show();
    return;
  }

  if (copy_of_ocelot_html == 0)
    batch_text_edit->setStyleSheet(copy_of_parent->ocelot_grid_style_string);
  /* Todo: next four lines could be done during the initial setup (well, not any more, because of the kludges) */
  batch_text_edit->setReadOnly(true);
  batch_text_edit->setAlignment(Qt::AlignTop | Qt::AlignLeft);
  batch_text_edit->setWordWrapMode(QTextOption::NoWrap);
  batch_text_edit->setFrameStyle(QFrame::NoFrame);
  long unsigned int tmp_xrow;
  char *pointer= result_set_copy_rows[0];
  unsigned int v_length, f_length;
  char *result_field_names_pointer;

  /*
    Todo: Adjust calculation for numeric columns, for escapes, for hex.
          It ought to be possible to do a single non-looping calculation.
 */
  unsigned int tmp_size= sizeof(char);

  if ((ocelot_result_grid_column_names_copy == 1)
   && (copy_of_ocelot_xml == 0))
  {
    tmp_size+= strlen(ocelot_grid_header_row_start);
    result_field_names_pointer= &result_field_names[0];
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      tmp_size+= strlen(ocelot_grid_header_char_column_start);
      memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
      tmp_size+= v_length;
      result_field_names_pointer+= v_length + sizeof(unsigned int);
      tmp_size+= strlen(ocelot_grid_header_char_column_end);
    }
    tmp_size+= strlen(ocelot_grid_header_row_end);
  }

  tmp_size+= strlen(ocelot_grid_table_start);
  for (tmp_xrow= 0; tmp_xrow < result_row_count; ++tmp_xrow)
  {
    result_field_names_pointer= &result_field_names[0];
    tmp_size+= strlen(ocelot_grid_detail_row_start);
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      if ((result_field_flags[i] & NUM_FLAG) != 0)
        tmp_size+= strlen(ocelot_grid_detail_numeric_column_start);
      else
        tmp_size+= strlen(ocelot_grid_detail_char_column_start);
      if (copy_of_ocelot_xml != 0)
      {
        memcpy(&f_length, result_field_names_pointer, sizeof(unsigned int));
        tmp_size+= f_length + 2;
        result_field_names_pointer+= f_length + sizeof(unsigned int);
      }
      memcpy(&v_length, pointer, sizeof(unsigned int));
      pointer+= sizeof(unsigned int) + sizeof(char);
      /* Todo: we only need v_length*1 unless it's img or hex or escaped */
      tmp_size+= v_length * 2;
      tmp_size+= strlen(ocelot_grid_detail_char_column_end);
      pointer+= v_length;
    }
    tmp_size+= strlen(ocelot_grid_detail_row_end);
  }
  tmp_size+= strlen(ocelot_grid_table_end);
  char *tmp;

  tmp= new char[tmp_size];
  char *tmp_pointer= &tmp[0];

  strcpy(tmp_pointer, ocelot_grid_table_start);
  tmp_pointer+= strlen(ocelot_grid_table_start);

  if ((ocelot_result_grid_column_names_copy == 1)
   && (copy_of_ocelot_xml == 0))
  {
    char *result_field_names_pointer;
    result_field_names_pointer= &result_field_names[0];
    strcpy(tmp_pointer, ocelot_grid_header_row_start);
    tmp_pointer+= strlen(ocelot_grid_header_row_start);
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      strcpy(tmp_pointer, ocelot_grid_header_char_column_start);
      tmp_pointer+= strlen(ocelot_grid_header_char_column_start);
      memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
      result_field_names_pointer+= sizeof(unsigned int);
      memcpy(tmp_pointer, result_field_names_pointer, v_length);
      tmp_pointer+= v_length;
      strcpy(tmp_pointer, ocelot_grid_header_char_column_end);
      tmp_pointer+= strlen(ocelot_grid_header_char_column_end);
      result_field_names_pointer+= v_length;
    }
    strcpy(tmp_pointer, ocelot_grid_header_row_end);
    tmp_pointer+= strlen(ocelot_grid_header_row_end);
  }
  pointer= result_set_copy_rows[0];
  for (tmp_xrow= 0; tmp_xrow < result_row_count; ++tmp_xrow)
  {
    result_field_names_pointer= &result_field_names[0];
    strcpy(tmp_pointer, ocelot_grid_detail_row_start);
    tmp_pointer+= strlen(ocelot_grid_detail_row_start);
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      if ((result_field_flags[i] & NUM_FLAG) != 0)
      {
        strcpy(tmp_pointer, ocelot_grid_detail_numeric_column_start);
        tmp_pointer+= strlen(ocelot_grid_detail_numeric_column_start);
      }
      else
      {
        strcpy(tmp_pointer, ocelot_grid_detail_char_column_start);
        tmp_pointer+= strlen(ocelot_grid_detail_char_column_start);
      }
      if (copy_of_ocelot_xml != 0)
      {
        memcpy(&f_length, result_field_names_pointer, sizeof(unsigned int));
        result_field_names_pointer+= sizeof(unsigned int);
        memcpy(tmp_pointer, result_field_names_pointer, f_length);
        tmp_pointer+= f_length;
        result_field_names_pointer+= f_length;
        strcpy(tmp_pointer, "\">");
        tmp_pointer+= 2;
      }
      memcpy(&v_length, pointer, sizeof(unsigned int));
      pointer+= sizeof(unsigned int) + sizeof(char);
      bool is_image_written= false;
      if ((copy_of_ocelot_html != 0) && (is_image(i) == true))
      {
        char img_type[4];
        set_img_type(pointer, v_length, img_type); /* so img_type = "" or "png" or "jpg" or "gif" */
        if (strcmp(img_type,"") != 0)
        {
          char *base64_tmp;
          base64_tmp= new char[(v_length * 4) / 3 + 16];
          QByteArray data= QByteArray::fromRawData(pointer, v_length);
          strcpy(base64_tmp, data.toBase64());
          memcpy(tmp_pointer, "<img src=\"data:image/", 21);
          tmp_pointer+= 21;
          memcpy(tmp_pointer, img_type, 3);
          tmp_pointer+= 3;
          memcpy(tmp_pointer, ";base64,", 8);
          tmp_pointer+= 8;
          memcpy(tmp_pointer, base64_tmp, strlen(base64_tmp));
          tmp_pointer+= strlen(base64_tmp);
          memcpy(tmp_pointer, "\"/>", 3);
          tmp_pointer+= 3;
          delete [] base64_tmp;
          is_image_written= true;
        }
      }
      if (is_image_written == false)
      {
        memcpy(tmp_pointer, pointer, v_length);
        tmp_pointer+= v_length;
      }
      strcpy(tmp_pointer, ocelot_grid_detail_char_column_end);
      tmp_pointer+= strlen(ocelot_grid_detail_char_column_end);
      pointer+= v_length;
    }
    strcpy(tmp_pointer, ocelot_grid_detail_row_end);
    tmp_pointer+= strlen(ocelot_grid_detail_row_end);
  }
  strcpy(tmp_pointer, ocelot_grid_table_end);
  tmp_pointer+= strlen(ocelot_grid_table_end);
  *tmp_pointer= '\0';

  /* Todo: This must be wrong. Surely ocelot_ca.html is off if we're doing display_batch. */
  if ((copy_of_ocelot_html != 0) && (copy_of_ocelot_raw == 0))
  {
    batch_text_edit->setHtml(tmp);
  }
  else
  {
    batch_text_edit->insertPlainText(tmp);
  }
  batch_text_edit->moveCursor(QTextCursor::Start);
  batch_text_edit->ensureCursorVisible();

//  show();
//  client->show();
  delete [] tmp;
  return;
}


/*
  display(due_to)
  ---------------
  After fillup() we can do layout and fill cells or just print out, depending on user options.
  If due_to = 0, this is immediately after fillup().
  If due_to = 1, this is coming from a change_result_display choice
  If due_to = 2, this is for resize_or_font_change
  Todo: We get here twice because right after fillup() we call display(), but then
        resize_or_font_change() calls display() again.
        This is invisible because resize_or_font_change calls
        something first (?), but it's a silly waste of time.
        However, maybe it only happens for the first time I select.
  Todo: Bug:
        (start program with ocelot_ca.batch == ocelot_ca.html == 0)
        select * from information_schema.tables limit 10;
        SET ocelot_html = 1;
        select * from information_schema.tables limit 10;
        SET ocelot_html = 0;
        select * from information_schema.tables limit 10;
        the display is obscured, that is why in display() I say
        html_text_edit->hide();
        but why do I need it, if I've removed it from layout?
  Todo: Allow switch from one output to another. This does require
        having fillup() completely separate from display(), that part is now done.
        setSizeConstraint and setVerticalScrollBarPolicy should be
        reset if we change to non-batch display.
  Re copy_of items
    The idea is that copy_of variables will store what was there when we called with 0 or 1,
    therefore when we call with 2 the value will be what we had when we called with 0 or 1
    rather than something that might have been set later.
    Todo: ocelot_vertical_copy is a pointless duplication of copy_of_ocelot_vertical?
    Todo: ocelot_result_grid_column_names_copy is a pointless duplication of copy_of_ocelot_result_grid_column_names?
  Re display_html
    We should set the copy_of items even if we will call display_html etc., because we might change
    how result_display_html() works. But there are other items that we set at the start that,
    I think, we don't need to set since display_html() won't use them.
*/
void ResultGrid::display(int due_to,
             unsigned short ocelot_vertical,
             unsigned short int ocelot_batch,
             unsigned short int ocelot_html,
             unsigned short int ocelot_raw,
             unsigned short int ocelot_xml,
             unsigned short ocelot_result_grid_column_names,
             unsigned short int ocelot_bar,
             unsigned short int ocelot_line,
             unsigned short int ocelot_pie)
{
  (void)due_to;
#ifdef OLD_STUFF
  /* Some child widgets e.g. text_edit_frames[n] must not be visible because they'd receive paint events too soon. */
  hide();
#endif
//  if ((due_to == 0) || (due_to == 1))
  {
    display_garbage_collect(false);
    copy_result_to_gridx();
    /* Todo: no more grid_result_row_count, and copy_result_to_gridx already
       said what gridx_row_count is. */
    if (ocelot_vertical == 0) grid_result_row_count= gridx_row_count + 1;
    else grid_result_row_count= result_row_count * result_column_count;
    if (ocelot_vertical == 0)
    {
      gridx_row_count= grid_result_row_count + 1;
    }
    if (ocelot_vertical != 0)
    {
      gridx_row_count= result_row_count * result_column_count;
      gridx_column_count= 1;
      if (ocelot_result_grid_column_names != 0) ++gridx_column_count;
    }
    grid_column_widths= new unsigned int[gridx_column_count];
    grid_column_heights= new unsigned int[gridx_column_count];
    grid_column_dbms_sources= new unsigned char[gridx_column_count];
    copy_of_ocelot_vertical= ocelot_vertical;
    copy_of_ocelot_result_grid_column_names= ocelot_result_grid_column_names;
    copy_of_ocelot_batch= ocelot_batch;
    copy_of_ocelot_html= ocelot_html;
    copy_of_ocelot_raw= ocelot_raw;
    copy_of_ocelot_xml= ocelot_xml;
    ocelot_vertical_copy= ocelot_vertical;
    ocelot_result_grid_column_names_copy= ocelot_result_grid_column_names;
  }
  vertical_scroll_bar_initialize();

  if ((copy_of_ocelot_batch != 0)
   || (copy_of_ocelot_xml != 0)
   || (copy_of_ocelot_raw != 0))
  {
    display_batch();
  }
  else
  /* Since it's not ocelot_batch or ocelot_xml it must be ocelot_html */
  {
//#if (OCELOT_CHART == 1)
//    if ((ocelot_bar == 1) || (ocelot_line == 1) || (ocelot_pie == 1))
//    {
//      /* we're hoping display_garbage_collect() deleted chart_widget earlier */
//      int chart_type;
//      if (ocelot_bar == 1) chart_type= TOKEN_KEYWORD_BAR;
//      if (ocelot_line == 1) chart_type= TOKEN_KEYWORD_LINE;
//      if (ocelot_pie == 1) chart_type= TOKEN_KEYWORD_PIE;
//      chart_widget= new Chart(this, copy_of_parent, chart_type);
//    }
//#endif
#if (OCELOT_CHART_OR_QCHART == 1)
    /* TODO: I guess this is obsolete now so get rid of it */
    if ((ocelot_bar == 1) || (ocelot_line == 1) || (ocelot_pie == 1))
    {
      /* we're hoping display_garbage_collect() deleted chart_widget earlier */
      int chart_type;
      if (ocelot_bar == 1) chart_type= TOKEN_KEYWORD_BAR;
      if (ocelot_line == 1) chart_type= TOKEN_KEYWORD_LINE;
      if (ocelot_pie == 1) chart_type= TOKEN_KEYWORD_PIE;
 #if (OCELOT_CHART == 1)
      chart_widget= new Chart(this, copy_of_parent, chart_type);
 #else
      chart_widget= new QChart(this, copy_of_parent, chart_type);
 #endif
    }
    else evaluate_for_chart(false);
#endif
    grid_vertical_scroll_bar_value= -1; /* todo: check: is this alread in vertical_scroll_bar_initialize? */
    focus_result_row_number= focus_column_number= -1; /* i.e. no cell is in focus */
    prepare_for_display_html();
    display_html(0, 0);
  }
  return;

#ifdef OLD_STUFF

  grid_main_layout->setSizeConstraint(QLayout::SetFixedSize);  /* This ensures the grid columns have no spaces between them */
//  html_text_edit->hide();

  long unsigned int xrow;
  unsigned int xcol;
  MainWindow *parent= copy_of_parent;
  int connections_dbms= copy_of_connections_dbms;

  is_paintable= 0;

  ocelot_grid_text_color= parent->ocelot_grid_text_color;
  ocelot_grid_background_color= parent->ocelot_grid_background_color;
  /* setting_ocelot_grid_cell_drag_line_size_as_int= parent->ocelot_grid_cell_drag_line_size.toInt(); */
  /* ocelot_grid_cell_drag_line_color= parent->ocelot_grid_cell_drag_line_color; */

  //  grid_scroll_area= new QScrollArea(this);                                    /* Todo: see why parent can't be client */

  //  grid_scroll_area->verticalScrollBar()->setMaximum(gridx_row_count);
  //  grid_scroll_area->verticalScrollBar()->setSingleStep(1);
  //  grid_scroll_area->verticalScrollBar()->setPageStep(gridx_row_count / 10);    /* Todo; check if this could become 0 */
  grid_vertical_scroll_bar_value= -1;

  {
    unsigned int minimum_number_of_cells;
    minimum_number_of_cells= result_grid_widget_max_height_in_lines * gridx_column_count;
    pools_resize(row_pool_size, result_grid_widget_max_height_in_lines, cell_pool_size, minimum_number_of_cells);
    if (row_pool_size < result_grid_widget_max_height_in_lines) row_pool_size= result_grid_widget_max_height_in_lines;
    if (cell_pool_size < minimum_number_of_cells) cell_pool_size= minimum_number_of_cells;
  }
  /*
    Calculate desired width and height based on parent width and height.
     Desired max width in chars = width when created - width of scroll bar.
     Max height in lines = height when created - (height of scroll bar + height of header) / 4. minimum = 1.
     Todo: We're dividing height-when-created by 3 because we assume statement+history widgets are there, maybe they're not.
     Todo: max height could be greater if row count < 4, or maybe it should be user-settable.
     Todo: grid_vertical_scroll_bar->width() failed so I just guessed that I should subtract 3 char widths.
  */

  /* Todo: since grid_column_size_calc() recalculates max_height_of_a_char, don't bother with this. */

  QFont *pointer_to_font;
  pointer_to_font= &result_grid_font;
  QFontMetrics mm= QFontMetrics(*pointer_to_font);
  /* Todo: figure out why this says parent->width() rather than this->width() -- maybe "this" has no width yet? */
  ocelot_grid_max_desired_width_in_pixels= (parent->width() - (mm.boundingRect('W').width() * MIN_WIDTH_IN_CHARS));
  {
    /*
      Try to ensure we can fit at least header (if there is a header) plus one row.
      So there's a maximum number of lines per row.
      We assume (border height + horizontal scroll bar height) < 11 (todo: calculate them).
      We assume result grid height = height of main window / 3 (todo: calculate it).
    */
    int result_grid_height= (parent->height() / 3) - 11;
    int line_height= mm.lineSpacing();
    if ((copy_of_ocelot_result_grid_column_names == 1) && (copy_of_ocelot_vertical == 0))
        result_grid_height-= line_height;
    ocelot_grid_max_column_height_in_lines= result_grid_height / line_height;
    if (ocelot_grid_max_column_height_in_lines < 1) ocelot_grid_max_column_height_in_lines= 1;
  }

  //setting_ocelot_grid_cell_drag_line_size_as_int= copy_of_parent->ocelot_grid_cell_drag_line_size.toInt();
//  ocelot_grid_cell_drag_line_color= copy_of_parent->ocelot_grid_cell_drag_line_color;
  //setting_ocelot_grid_cell_border_size_as_int= copy_of_parent->ocelot_grid_cell_border_size.toInt();

  /*
    Making changes for all in the cell pool.
    Todo: This should only be done for new cells, or if something has changed e.g. font, drag line size.
          That's actually a bug, because the drag line color doesn't change immediately.
    todo: why the whole pool rather than just result-row_count + 1?
  */
  QFont *pointer_to_font_2;
  pointer_to_font_2= &result_grid_font;
  QFontMetrics fm= QFontMetrics(*pointer_to_font_2);
  /* Todo: see whether this loop could be shifted somewhere so it's not repeated for every fillup */
  for (xrow= 0; (xrow < gridx_row_count) && (xrow < result_grid_widget_max_height_in_lines); ++xrow)
  {
    for (unsigned int column_number= 0; column_number < gridx_column_count; ++column_number)
    {
      int ki= xrow * gridx_column_count + column_number;
      text_edit_widgets[ki]->setMinimumWidth(fm.boundingRect("W").width() * MIN_WIDTH_IN_CHARS);
      /* This line was replaced in December 2015 */
      //text_edit_widgets[ki]->setMinimumHeight(fm.height() * 2);
      text_edit_widgets[ki]->setMinimumHeight(fm.lineSpacing());
      text_edit_layouts[ki]->setContentsMargins(QMargins(0, 0, setting_ocelot_grid_cell_drag_line_size_as_int, setting_ocelot_grid_cell_drag_line_size_as_int));
      /*
        Change the color of the frame. Be specific that it's TextEditFrame, because you don't want the
        children e.g. the QTextEdit to inherit the color. TextEditFrame is a custom widget and therefore
        setStyleSheet is troublesome for most settings, but background-color should be okay, see
        http://stackoverflow.com/questions/7276330/qt-stylesheet-for-custom-widget.
      */

      //text_edit_frames[ki]->setStyleSheet(frame_color_setting);

      /* Todo: remove this line and test whether anything goes wrong. */
      text_edit_frames[ki]->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);   /* This doesn't seem to do anything */

      /* Todo: I'm not sure exactly where the following three lines should go. Consider moving them. */
      /*       I'm not sure they have any effect. I don't know why drag line and scroll bar width aren't added. */
      /* border_size and minimum_width and minimum_height are used by mouseMoveEvent */
      text_edit_frames[ki]->border_size= 10 + border_size;    /* Todo: should just be border_size!! */
      text_edit_frames[ki]->minimum_width= fm.boundingRect("W").width() * MIN_WIDTH_IN_CHARS + border_size;
      /* I used to say "fm.height() * 2 + border_size", but don't know why. That seems like too much. */
      text_edit_frames[ki]->minimum_height= fm.lineSpacing() + border_size * 2 + setting_ocelot_grid_cell_drag_line_size_as_int;
    }
  }

  /*
    For each cell:
      Set cell type = detail or header, depending on is_vertical + whether it's first row
      If header: indicate where header text is.
    Todo: this is just assuming top line is header, which is wrong now.
  */
  char *field_names_pointer;
  for (xrow= 0; (xrow < grid_result_row_count) && (xrow < result_grid_widget_max_height_in_lines); ++xrow)
  {
    field_names_pointer= gridx_field_names; /* unnecessary reset if copy_of_ocelot_vertical = 0 */
    for (unsigned int column_number= 0; column_number < gridx_column_count; ++column_number)
    {
      int ki= xrow * gridx_column_count + column_number;
      bool is_header= false;
      if (copy_of_ocelot_vertical != 0)
      {
        if (copy_of_ocelot_result_grid_column_names != 0)
        {
          if (column_number == 0) is_header= true;
        }
      }
      if ((copy_of_ocelot_vertical == 0) && (xrow == 0)) is_header= true;
      if (is_header == true)
      {
        memcpy(&(text_edit_frames[ki]->content_length), field_names_pointer, sizeof(unsigned int));
        field_names_pointer+= sizeof(unsigned int);
        text_edit_frames[ki]->content_pointer= field_names_pointer;
        field_names_pointer+= text_edit_frames[ki]->content_length;
        text_edit_frames[ki]->content_field_value_flags= 0;
        text_edit_frames[ki]->is_retrieved_flag= false;
        text_edit_frames[ki]->ancestor_grid_column_number= column_number;
        text_edit_frames[ki]->ancestor_grid_result_row_number= -1;          /* probably unnecessary */
        if (text_edit_frames[ki]->cell_type != TEXTEDITFRAME_CELL_TYPE_HEADER)
        {
          text_edit_frames[ki]->cell_type= TEXTEDITFRAME_CELL_TYPE_HEADER;
          text_edit_frames[ki]->is_style_sheet_set_flag= false;
        }
        text_edit_frames[ki]->is_image_flag= false;
        set_height(ki, text_edit_frames[ki]->width());
      }
      else
      {
        if (is_extra_rule_1(column_number) == true)
        {
          if (text_edit_frames[ki]->cell_type != TEXTEDITFRAME_CELL_TYPE_DETAIL_EXTRA_RULE_1)
          {
            text_edit_frames[ki]->cell_type= TEXTEDITFRAME_CELL_TYPE_DETAIL_EXTRA_RULE_1;
            text_edit_frames[ki]->is_style_sheet_set_flag= false;
          }
        }
        else
        {
          if (text_edit_frames[ki]->cell_type != TEXTEDITFRAME_CELL_TYPE_DETAIL)
          {
            text_edit_frames[ki]->cell_type= TEXTEDITFRAME_CELL_TYPE_DETAIL;
            text_edit_frames[ki]->is_style_sheet_set_flag= false;
          }
        }
      }
    }
  }
  //if (copy_of_ocelot_vertical != 0)
  //  grid_column_size_calc(setting_ocelot_grid_cell_border_size_as_int,
  //                      setting_ocelot_grid_cell_drag_line_size_as_int,
  //                      0); /* get grid_column_widths[] and grid_column_heights[] */

  if (copy_of_ocelot_vertical != 0)
  {
    /* TODO: Make sure considerations for horizontal are all considered for vertical. */
    /* We'll have to figure out the alignment etc. each time we get ready to display */
    unsigned int grid_row_number, text_edit_frame_index;
    for (grid_row_number= 0, text_edit_frame_index= 0;
         grid_row_number < result_grid_widget_max_height_in_lines;
         ++grid_row_number)
    {
      if (grid_row_number >= gridx_row_count) break;
      for (unsigned int mi= 0; mi < gridx_column_count; ++mi)
      {
        /* todo: test whether we really need to show always */
        text_edit_frames[text_edit_frame_index]->show();
        grid_row_layouts[grid_row_number]->addWidget(text_edit_frames[text_edit_frame_index], 0, Qt::AlignTop | Qt::AlignLeft);
        ++text_edit_frame_index;
      }
    }
    /* How many text_edit_frame widgets are we actually using? This assumes number-of-columns-per-row is fixed. */
    max_text_edit_frames_count= text_edit_frame_index;
  }
  else max_text_edit_frames_count= (grid_result_row_count) * gridx_column_count;

  /*
    grid detail rows
    While we're passing through, we also get max column lengths (in characters).
    Todo: Take into account: whether there were any nulls.
    Moved fill_detail_widgets() down from here 2020-06-25
    ... No, instead we call it twice.
    Todo: Do only what's necessary here! Don't repeat all fill_detail_widgets()!
    Todo: Decide whether is_paintable should stay on a while longer!
  */
  fill_detail_widgets(0, connections_dbms);                                        /* details */

  grid_vertical_scroll_bar_value= 0;

  /*
    We'll use the automatic scroll bar for small result sets,
    we'll use our own scroll bar for large ones.
    setValue() will cause eventfilter to call vertical_scroll_bar_event().
    But grid_vertical_scroll_bar_value == 0 so nothing will happen except slider movement.
    This section was changed on 2016-04-01.
  */
  if (grid_result_row_count <= result_grid_widget_max_height_in_lines)
  {
    grid_scroll_area->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    grid_vertical_scroll_bar->setVisible(false);
    grid_scroll_area->verticalScrollBar()->setValue(0);
  }
  else
  {
    grid_scroll_area->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    grid_vertical_scroll_bar->setVisible(true);
    grid_vertical_scroll_bar->setValue(0);
  }

  is_paintable= 1;
  if (copy_of_ocelot_vertical == 0)
  grid_column_size_calc(setting_ocelot_grid_cell_border_size_as_int,
                        setting_ocelot_grid_cell_drag_line_size_as_int,
                        ocelot_result_grid_column_names_copy,
                        connections_dbms); /* get grid_column_widths[] and grid_column_heights[] */

  /*
    grid_actual_grid_height_in_rows = # of rows that are actually showable at a time,
    = lesser of (grid_max_grid_height_in_lines/grid_max_row_height_in_lines, # of rows in result set + 1)
  */
  //grid_actual_grid_height_in_rows= gridx_row_count;
  //if (grid_actual_grid_height_in_rows > gridx_row_count + 1) grid_actual_grid_height_in_rows= gridx_row_count + 1;

  /* Put the QTextEdit widgets in a layout. Remember grid row 0 is for the header.
    Horizontal (default):
      Each row is [column_count] cells within one QHBoxLayout (grid_row_layout) within one widget.
    Vertical (if --vertical or \G):
      Each row is 2 cells within one QHBoxLayout (grid_row_layout) within one widget.
    grid_row_layout->setSizeConstraint(QLayout::SetMaximumSize) prevents gaps from forming during shrink.
    There's a "border", actually the visible part of TextEditFrame, on the cell's right.
    Drag it left to shrink the cell, drag it right to expand the cell.
    We do not resize cells on the left or right of the to-be-dragged cell, so expanding causes total row width to expand,
    possibly going beyond the original desired maximum width, possibly causing a horizontal scroll bar to appear.
    grid_row_layout->setSpacing(0) means the only thing separating cells is the "border".
  */
  if (copy_of_ocelot_vertical == 0)
  {
    for (long unsigned int xrow= 0; (xrow < grid_result_row_count) && (xrow < result_grid_widget_max_height_in_lines); ++xrow)
    {
      for (xcol= 0; xcol < gridx_column_count; ++xcol)
      {
        TextEditWidget *cell_text_edit_widget= text_edit_widgets[xrow * gridx_column_count + xcol];
        if ((xrow > 0) && (dbms_get_field_flag(xcol, connections_dbms) & NUM_FLAG)) text_align(cell_text_edit_widget, Qt::AlignRight);
        else text_align(cell_text_edit_widget, Qt::AlignLeft);
        if (text_edit_frames[xrow * gridx_column_count + xcol]->cell_type != TEXTEDITFRAME_CELL_TYPE_HEADER)
        {
          if (is_image(xcol) == true)
          {
            text_edit_frames[xrow * gridx_column_count + xcol]->is_image_flag= true;
          }
          else text_edit_frames[xrow * gridx_column_count + xcol]->is_image_flag= false;
        }
        /* Height border size = 1 due to setStyleSheet earlier; right border size is passed */
        if (xrow == 0)
        {
          int header_height= max_height_of_a_char
                           + setting_ocelot_grid_cell_border_size_as_int * 2
                           + setting_ocelot_grid_cell_drag_line_size_as_int;
          frame_resize(xrow * gridx_column_count + xcol, xcol, grid_column_widths[xcol], header_height);
        }
        else
        {
          frame_resize(xrow * gridx_column_count + xcol,  xcol, grid_column_widths[xcol], grid_column_heights[xcol]);
        }
        /* todo: test whether we really need to show always */
        text_edit_frames[xrow * gridx_column_count + xcol]->show();
        grid_row_layouts[xrow]->addWidget(text_edit_frames[xrow * gridx_column_count + xcol], 0, Qt::AlignTop | Qt::AlignLeft);
      }
    }
  }
  /* Moved fill_detail_widgets() down to here 2020-06-25 */
  fill_detail_widgets(0, connections_dbms);
  //  grid_main_layout->setSizeConstraint(QLayout::SetFixedSize);  /* This ensures the grid columns have no spaces between them */

  for (long unsigned int xrow= 0; (xrow < grid_result_row_count) && (xrow < result_grid_widget_max_height_in_lines); ++xrow)
  {
//    grid_row_widgets[xrow]->setLayout(grid_row_layouts[xrow]);
    grid_main_layout->addWidget(grid_row_widgets[xrow], 0, Qt::AlignTop | Qt::AlignLeft);
  }

//  client->setLayout(grid_main_layout);

  /* This doesn't work. Done too early? */
  /* client->setStyleSheet(copy_of_parent->ocelot_grid_style_string); */
  /*
    Before client->show(), client->height()=30 and height()=30.
    After client->show(), client->height()=something big e.g. 1098 and height()=30.
    But client = the grid itself rather than the result grid widget?
    Without client->show(), grid becomes blank after a font change.
    TODO: now grid becomes blank after a font change anyway! So I have to say show().
  */

  client->show();

  show();

//  grid_scroll_area->setWidget(client);
//  grid_scroll_area->setWidgetResizable(true);              /* Without this, the QTextEdit widget heights won't change */

  /* area->horizontalScrollBar()->setSingleStep(client->width() / 24); */ /* single-stepping seems pointless */
#endif
}

#ifdef OLD_STUFF
/*
  frame_resize() == Setting text_edit_frames[n] size.
  Called from: display() if vertical == 0 (initial),
               set_alignment_and_height() if vertical != 0 (always),
  Re scroll bar: we make most of the initial size calculations with the
                 assumption that scroll bar will be off, as it usually
                 will be, and since otherwise grid_column_size_calc()
                 becomes tremendously complicated. Here, if you know
                 the contents will fit, turn off the scroll bar.
  I think the width is of the frame; we want the width of the widget.
  Re: setVerticalScrollBarPolicy(). set_height() calls it too,
      so I think we only need to call it when we pull on a drag line.
*/
void frame_resize(int ki, int grid_col, int width, int height)
{
  (void) (grid_col);
  //unsigned int text_edit_width= width -
  //        (setting_ocelot_grid_cell_drag_line_size_as_int
  //         + setting_ocelot_grid_cell_border_size_as_int * 2);
  //unsigned int text_edit_height= height -
  //        (setting_ocelot_grid_cell_drag_line_size_as_int
  //         + setting_ocelot_grid_cell_border_size_as_int * 2);
  //unsigned int number_of_characters_per_line= text_edit_width / setting_max_width_of_a_char;
  //unsigned int number_of_lines= text_edit_height / max_height_of_a_char;
  //unsigned int number_of_characters_in_cell= number_of_characters_per_line
  //                                      * number_of_lines;
  /* TEST!! Remove temporarily! It's in set_height() now! */
  //if (number_of_characters_in_cell < gridx_max_column_widths[grid_col])
  //  text_edit_widgets[ki]->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
  //else
  //  text_edit_widgets[ki]->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
  text_edit_frames[ki]->setFixedSize(width, height);
  /* Todo: test if following 2 lines are redundant since setFixedSize does the job. */
  //text_edit_frames[ki]->setMaximumHeight(height);
  //text_edit_frames[ki]->setMinimumHeight(height);
}
#endif

#ifdef OLD_STUFF
/*
  Called from: TextEditFrame::mouseMoveEvent() if right drag line moved, so probable width change
  The call to get_column_height_in_pixels() is just so that vertical scroll bar might go on|off.
*/
void frame_resize_for_drag_right(int ki, int grid_col, int width, int height)
{
  get_column_height_in_pixels(ki, width, height);
  frame_resize(ki, grid_col, width, height);
}

/*
  Called from: TextEditFrame::mouseMoveEvent() if bottom drag line moved, so probable height change
  Unlike set_height(), we might not stop at the usual maximum height because we know the widget fits on the screen.
  If vertical is on, passed xrow will be 0 but pay no attention.
  todo: This is called for all visible rows -- but why? Why not just the row that the frame is in?
  todo: This changes grid_row_widgets so maybe other columns in the row will be truncated without a scroll bar.
  todo: It should be possible to change header height too but that is only working if vertical is on.
  todo: Change is not persistent, if you scroll the result set so row disappears, then come back, it's original height.
*/
void frame_resize_for_drag_bottom(long int xrow, int ki, int grid_col, int width, int height)
{
  (void) (grid_col);
  get_column_height_in_pixels(ki, width, height);
  if (copy_of_ocelot_vertical == 0) grid_row_widgets[xrow]->setFixedHeight(height);
  text_edit_frames[ki]->setFixedHeight(height);
}
#endif

/*
  The border color must differ from all background colors because mouseMoveEvent() finds column boundaries
  by looking for color changes.
  Todo: Make the difference smaller by adding or subtracting 1 at a time from final hex digit.
*/
QString ResultGrid::get_border_color()
{
  QString tmp_border_color= copy_of_parent->ocelot_grid_cell_border_color;
  int i= 1;
  while ((tmp_border_color == copy_of_parent->ocelot_grid_background_color)
      || (tmp_border_color == copy_of_parent->ocelot_grid_header_background_color))
  {
    tmp_border_color= tmp_border_color.left(tmp_border_color.size() - 1)
                    + QString::number(i);
    ++i;
  }
  return tmp_border_color;
}

/*
  Let's see whether we can output a thin image at the start of every row.
  Suppose that the header and every row has a 1x1 black-and-white 73-byte .png changed to base64.
  Warning: make sure you don't end with \0.
  This was working okay with "if (h < 0 h= 1;" and "width=0" but sometimes the result was blank or too high.
  Todo: We account for this when allocating tmp size but should record exact calculated size.
  Todo: If it works, we can use it to force height iff it's greater.
  Todo: instead of h= 5 we should say h= minimum height, whatever that is. Maybe FONT_SIZE_MIN.
*/
int ResultGrid::thin_image(char *tmp_pointer, const char *th_or_td, int height)
{
  char output_string[256];
  int h= height;
  if (h < 0) h= 5;
  sprintf(output_string, "<%s width=0><img width=0 height=%d src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQAAAAA3bvkkAAAAEElEQVR4nGJgAQAAAP//AwAABgAFV7+r1AAAAABJRU5ErkJggg==\"/></%s>",
          th_or_td, h, th_or_td);
  if (h < 10) strcat(output_string, " "); /* We can overwrite so must be sure that size is always the same */
  if (h < 100) strcat(output_string, " ");
  if (h < 1000) strcat(output_string, " ");
  memcpy(tmp_pointer, output_string, strlen(output_string));
  return strlen(output_string);
}

/*
  For --batch, avoid normal grid display. Result won't go to history.
  For --html, avoid normal grid display.
              Result will go to history.
              For --html --raw, result is dumped so user sees the markup.
              --html overrides --batch, i.e. we look at html first
              images are done as data URIs if png|jpg|gif
  We say setReadOnly() so edit won't generate update statement.
  We pay attention to --column-names and (sometimes) --raw, as well.
  Todo: BUG: If you reconnect with file|connect, and use a different
        setting for batch or html or raw, display is garbage.
  Todo: SET ocelot_batch = x; should be possible.
        It would not change the current result grid.
  Todo: going directly to a file should be possible too
  Todo: check what happens if row data contains "\n"
  Todo: pay attention to --vertical
  Todo: Do what you do for other displays, e.g. check for null
  Todo: look for --raw, currently we're just assuming it's true
        + we don't need to multiply size by 2 if --raw is off (?)
        Escape ' " \ nul tab newline =  \' \" \\ \0 \t \n
  Todo: we can also support --xml, I don't know whether
        it overrides --batch or whether it complements it somehow.
        also csv and msgpack and json
        also "--like-mysql-client"
        or SET ocelot_grid_format = {'fancy'|'html'|'xml'|'csv'|etc.}
  Todo: Setting should be possible with the syntax that's used for
        INTO OUTFILE
  Todo: I was getting
        QTextOdfWriter: unsupported paragraph alignment;  QFlags(0x20)
        if ^A (select all), ^C (Copy) on a large output.
        Specifying "...Qt::AlignLeft" solved it.
        But it might be nice to write a bug report for the Qt folks.
  Todo: it would take less memory and possibly display quicker if
        I only output when necessary, i.e. when user scrolls
  Todo: check: does it do any good to hide() first?
  Todo: callback to a local Lua function prior to display, for each row
  Todo: allow row update. and, if there's a change in one mode, show
        the changed row when modes are switched
  Todo: xml statement="" and field name="" contents lack escaping.
  Todo: "<" wrecks the cell, we need character entities
  Todo: If you remove "html_text_edit->setWordWrapMode(QTextOption::NoWrap);"
        the effect is interesting, it might be a desirable option.
*/
/*
  Eventually ...
                                                    csv     --html    --batch  --xml
    ocelot_grid_table_start                                 </TABLE>           $statement
    ocelot_grid_header_row_start                            <TR>
    ocelot_grid_header_row_end                      \n      </TR>      \n
    ocelot_grid_header_numeric_column_start                 <TH>
    ocelot_grid_header_numeric_column_end           ,       </TH>      tab
    ocelot_grid_header_char_column_start            "       <TH>
    ocelot_grid_header_char_column_end              ",      </TH>      tab
    ocelot_grid_detail_row_start                                               <row>
    ocelot_grid_detail_row_end                                                 </row>
    ocelot_grid_detail_numeric_column_start                 <TD>[<div ...>]
    ocelot_grid_detail_numeric_column_end           ,       </TD>[</div>]
    ocelot_grid_detail_char_column_start            "       <TD>               <field name="$field">
    ocelot_grid_detail_char_column_end              ",      </TD>              </field>
    ocelot_grid_table_end                                   </TABLE>
    ... up to 9 characters + \0
*/
/*
  Todo: the html style sheet
  For html, instead of html_text_edit->setStyleSheet(), we want to
  put css specifications in the html header. Example:
  <HTML><head><style type=text/css>table, th, td {border-color: black; border-style: solid; color: red; background-color: blue}</style></HEAD><BODY><TABLE BORDER=5>.
  Although copy_of_parent->ocelot_grid_style_string) has all the
  necessary information, it's the wrong format. Use:
  color = copy_of_parent->ocelot_grid_text_color;
  background-color = copy_of_parent->ocelot_grid_background_color;
  copy_of_parent->ocelot_grid_focus_cell_background_color; (no) (this is unimplemented anyway)
  copy_of_parent->ocelot_grid_header_background_color;

  font-family = copy_of_parent->ocelot_grid_font_family;
  font-size = copy_of_parent->ocelot_grid_font_size;
  font-style = copy_of_parent->ocelot_grid_font_style;
  font-weight = copy_of_parent->ocelot_grid_font_weight;

  border-color = copy_of_parent->ocelot_grid_cell_border_color;
  copy_of_parent->ocelot_grid_cell_drag_line_color; (no)
  copy_of_parent->ocelot_grid_cell_border_size;
  copy_of_parent->ocelot_grid_cell_drag_line_size;
  Todo: I think hide() is unnecessary because the caller has already done it.
  Re  new_grid_vertical_scroll_bar_value: compare fill_detail_widgets() usage.
  We cannot let html_border_color be the same as any background color.
  We must say border-style: solid; otherwise we get two-tone when border_size > 1
     (someday look up: is default = groove? ridge? inset? outset?)
*/

/*
  Re ocelot_grid_table_start size: Each condition_div adds about 150 characters to ocelot_grid_table_start,
  which has about 400 characters for other things.
  Therefore if we have 10 conditions we need at least 150 * 10 + 400 == 2000.
  Double that. And say you can't increase OCELOT_MAX_CONDITIONS to more than 10.
*/


/* shared */
char ocelot_grid_table_start[4000]; /* See comment above re ocelot_grid_table_start size */
char ocelot_grid_header_row_start[32];
char ocelot_grid_header_row_end[32];
char ocelot_grid_header_numeric_column_start[32];
char ocelot_grid_header_numeric_column_end[32];
char ocelot_grid_header_char_column_start[32];
char ocelot_grid_header_char_column_end[32];
char ocelot_grid_detail_row_start[32];
char ocelot_grid_detail_row_end[32];
char ocelot_grid_detail_numeric_column_start[320];
char ocelot_grid_detail_numeric_column_end[32];
char ocelot_grid_detail_char_column_start[320];
char ocelot_grid_detail_char_column_end[32];
char ocelot_grid_table_end[320];

void ResultGrid::prepare_for_display_html()
{
    /* I'm not sure where this should go. It's really only good for size-change */
    /* Maybe this doesn't work anyway */
    /* Todo: since grid_column_size_calc() recalculates max_height_of_a_char, don't bother with this. */
    MainWindow *parent= copy_of_parent;
    QFont *pointer_to_font;
    pointer_to_font= &result_grid_font;
    QFontMetrics mm= QFontMetrics(*pointer_to_font);
    /* Todo: figure out why this says parent->width() rather than this->width() -- maybe "this" has no width yet? */
    ocelot_grid_max_desired_width_in_pixels= (parent->width() - (mm.boundingRect('W').width() * MIN_WIDTH_IN_CHARS));
    {
      /*
        Try to ensure we can fit at least header (if there is a header) plus one row.
        So there's a maximum number of lines per row.
        We assume (border height + horizontal scroll bar height) < 11 (todo: calculate them).
        We assume result grid height = height of main window / 3 (todo: calculate it).
      */
      int result_grid_height= (parent->height() / 3) - 11;
      int line_height= mm.lineSpacing();
      if ((copy_of_ocelot_result_grid_column_names == 1) && (copy_of_ocelot_vertical == 0))
          result_grid_height-= line_height;
      ocelot_grid_max_column_height_in_lines= result_grid_height / line_height;
      if (ocelot_grid_max_column_height_in_lines < 1) ocelot_grid_max_column_height_in_lines= 1;
    }
    /* This is so we know desired column widths for deciding whether to wrap in HTML cells */
    /* Todo: Check harder. Some things might not be initialized yet for this call. */
    /* Todo: We're not ready yet for ocelot_ca.vertical != 0 */
    //if (copy_of_ocelot_html != 0)
#if (OCELOT_EXPLORER == 1)
    if ((result_row_count != 0) && (result_column_count != 0) && (result_grid_type != EXPLORER_WIDGET))
#else
    if ((result_row_count != 0) && (result_column_count != 0))
#endif
    {
      //if (copy_of_ocelot_vertical == 0)
      grid_column_size_calc(setting_ocelot_grid_cell_border_size_as_int,
                            setting_ocelot_grid_cell_drag_line_size_as_int,
                            ocelot_result_grid_column_names_copy,
                            copy_of_connections_dbms); /* get grid_column_widths[] and grid_column_heights[] */
    }
    /* Todo: this should be done permanently, on persistent variables. */
    //if (copy_of_ocelot_html != 0)
    {
      char html_border_color[32];
      char html_color[32];
      char html_background_color[32];
      char html_header_background_color[32];
      char html_font_family[32];
      char html_font_size[32];
      char html_font_style[32];
      char html_font_weight[32];
      char html_outer_color[32];
      int html_border_size;

      QString tmp_border_color= get_border_color();
      strcpy(html_border_color, tmp_border_color.toUtf8());
      strcpy(html_header_background_color, copy_of_parent->ocelot_grid_header_background_color.toUtf8());
      strcpy(html_outer_color, copy_of_parent->ocelot_grid_outer_color.toUtf8());
      html_border_size= copy_of_parent->ocelot_grid_cell_border_size.toInt();
      if (result_grid_type == EXPLORER_WIDGET)
      {
        strcpy(html_color, copy_of_parent->ocelot_explorer_text_color.toUtf8());
        strcpy(html_background_color, copy_of_parent->ocelot_explorer_background_color.toUtf8());
        strcpy(html_font_family, copy_of_parent->ocelot_explorer_font_family.toUtf8());
        strcpy(html_font_size, copy_of_parent->ocelot_explorer_font_size.toUtf8());
        strcpy(html_font_style, copy_of_parent->ocelot_explorer_font_style.toUtf8());
        strcpy(html_font_weight, copy_of_parent->ocelot_explorer_font_weight.toUtf8());
      }
      else
      {
        strcpy(html_color, copy_of_parent->ocelot_grid_text_color.toUtf8());
        strcpy(html_background_color, copy_of_parent->ocelot_grid_background_color.toUtf8());
        strcpy(html_font_family, copy_of_parent->ocelot_grid_font_family.toUtf8());
        strcpy(html_font_size, copy_of_parent->ocelot_grid_font_size.toUtf8());
        strcpy(html_font_style, copy_of_parent->ocelot_grid_font_style.toUtf8());
        strcpy(html_font_weight, copy_of_parent->ocelot_grid_font_weight.toUtf8());
      }
      QByteArray all_condition_divs;
      char condition_div[512];
      all_condition_divs.clear(); /* probably unnecessary */
      /* Produce a "<div ...>" for each conditional setting (HTML only!) See whether we can change color at least */
      for (int condition_number= 0; condition_number < copy_of_parent->conditional_settings.count(); ++condition_number)
      {
        QString new_tooltip= "";

        QString new_style_sheet, old_style_sheet;
#if (OCELOT_EXPLORER == 1)
        if (result_grid_type == EXPLORER_WIDGET)
          new_style_sheet= old_style_sheet= copy_of_parent->ocelot_explorer_style_string;
        else
#endif
          new_style_sheet= old_style_sheet= copy_of_parent->ocelot_grid_style_string;
        QString new_cell_height= "";
        QString new_cell_width= "";
        QString new_action= "";
        QString new_enabled= "";
        QString new_shortcut= "";
        QString new_text= "";
        bool result= conditional_setting_evaluate(
             condition_number, /* cs_number */
             0, /* doesn't matter */
             0, /* doesn't matter */
             0, /* doesn't matter */
             0, /* doesn't matter */
             0, /* doesn't matter */
             TEXTEDITFRAME_CELL_TYPE_DETAIL, /* text_edit_frames[text_edit_frames_index]->cell_type, */
             old_style_sheet,          /* old_style_sheet */
             true,        /* is_always_true */
             &new_tooltip, &new_style_sheet, &new_cell_height, &new_cell_width,
             &new_action, &new_enabled, &new_shortcut, &new_text, NULL);
        if (result == true) /* unnecessary, we passed always_true */
        {
          sprintf(condition_div, " .E%d {", condition_number);        /* so <div> label is E0, E1, etc. */
          strcat(condition_div, new_style_sheet.toUtf8());
          strcat(condition_div, "} ");
        }
        else condition_div[0]= '\0';
        all_condition_divs.append(condition_div);
      }
      sprintf(ocelot_grid_table_start,"<HTML><HEAD><style type=text/css>"
              " %s "                                                /* all_condition_divs */
              " table {border-style: solid; background-color: %s; border-color: %s} "    /* html_border_color */
              " body {"
              "background-color: purple; "
              "color: %s; "                                         /* html_color */
              "font-family: '%s'; "                                 /* html_font_family */
              "font-size: %spt; "                                   /* html_font_size */
              "font-style: %s; "                                    /* html_font_style */
              "font-weight: %s}"                                    /* html_font_weight */
              " th {"
              "background-color: %s; "                              /* html_header_background_color */
              "}"
              " td {"
              "background-color: %s; "                              /* html_background_color */
              "}"
              "</style></HEAD><BODY bgcolor=%s><TABLE BORDER=%d blue>", /* html_border_size */
              all_condition_divs.data(),
              html_border_color, /* table{background-color:...} will look like cell border color */
              html_border_color, /* table{border-color:...} will look like cell border color */
              html_color,        /* body {color} will be color of text in th and td */
              html_font_family,             /* body {font-family} */
              html_font_size,               /* body {font-size} */
              html_font_style,              /* body {font-style} */
              html_font_weight,             /* body {font-weight} */
              html_header_background_color, /* th {background-color} */
              html_background_color,        /* td {background-color} */
              html_outer_color,         /* body bgcolor */
              html_border_size);            /* table border size */
      strcpy(ocelot_grid_header_row_start, "<TR bgcolor=blue>");
      strcpy(ocelot_grid_header_row_end, "</TR>");
      strcpy(ocelot_grid_header_numeric_column_start, "<TH>");
      strcpy(ocelot_grid_header_numeric_column_end, "</TH>");
      strcpy(ocelot_grid_header_char_column_start, "<TH>");
      strcpy(ocelot_grid_header_char_column_end, "</TH>");
      strcpy(ocelot_grid_detail_row_start, "<TR>");
      strcpy(ocelot_grid_detail_row_end, "</TR>");
      strcpy(ocelot_grid_detail_numeric_column_start, "<TD align=\"right\">");
      strcpy(ocelot_grid_detail_numeric_column_end,"</TD>");
      /* TEST!!!! */
      strcpy(ocelot_grid_detail_char_column_start, "<TD width=    >");
      strcpy(ocelot_grid_detail_char_column_end , "</TD>");
      strcpy(ocelot_grid_table_end, "</TABLE></BODY></HTML>");
    }
//TEST!!    hide(); /* todo: I'm not sure whether this has a point while the kludges exist */
    //html_text_edit->clear(); /* I'm sure this has a point while the kludges exist */
    /*
      Kludge #1: if I don't delete html_text_edit and create it again, then after
      ocelot_ca.html=1; big select; ocelot_ca.html=0; big select; ocelot_ca.html=1;big select;
      the horizontal scroll bar won't work.
      KLudge #2: without the show() and hide()s here, if I said
      SET ocelot_html=0; SELECT * FROM "_space"; SET ocelot_html=1; SELECT * FROM "_space";
      the vertical scroll bar was absent. I wish I knew why doing this can fix it.
      Kludge #3: with something other than SetMaximumSize later, this wil cause too-small window:
      SET ocelot_html=0; SELECT 5; SET ocelot_html=1; SELECT * FROM "_space";
      Kludge #4: If we don't break off early when row count or column count = 0, we will crash.
      But by doing so, we fail to add html or xml markup and we don't allow for message translation.
      I don't bother to say html_text_edit_hide() so this->show() makes it visible, momentarily.
      I think html_text_edit won't have trouble with paint events because it is an ordinary QTextEdit.
    */
    /*** Removed due to tests */
    //delete html_text_edit;
    //html_text_edit= new Result_qtextedit(this);
}

/*
  Called from display_html(). Return expected # of pixels in a column of a row.
              For a string: height of a line for the column's font, * #-of-<br>s
              For an image: getting QPixMap is slow but we'll only call this while display
                            (todo: someday calculate height from header, see comments before
                             set_max_column_width)
              ... but there might be an override due to a height specifier, which might be conditional
              ... see grid_row_heights[]
            + border-size * 2
            + 1 (mysteriously)
            + 1 (mysteriously, and the same + 1 that we used to calculate row_height elsewhere)
  Todo: Look for conditional settings.
  Todo: call this for header too, if it's decided that header can be multi-line.
  Todo: Should also look for grid heights[]
  Todo: Possibly boundingRect() would be more accurate, especially if someday word wrap is allowed.
*/
int ResultGrid::column_height(unsigned int grid_row, int column_no, int v_length, char *value)
{
  (void)grid_row;
  char img_type[4];
  set_img_type(value, v_length, img_type); /* so img_type = "" or "png" or "jpg" or "gif" */
  if (img_type[0] != '\0')
  {
    QPixmap p= QPixmap();
    if (p.loadFromData((const uchar*) value,
                       v_length,
                       0,
                       Qt::AutoColor) == true)
    {
      /* Readable as an image. Not text. Not null. */
      return p.height();
    }
  }
  int column_width_in_chars= (grid_column_widths[column_no] / setting_max_width_of_a_char);
  int lines_in_cell;
  if (column_width_in_chars == 0) lines_in_cell= 1;
  else lines_in_cell= (v_length + (column_width_in_chars - 1)) / column_width_in_chars;
  if (lines_in_cell == 0) lines_in_cell= 1;
  int this_column_height= (lines_in_cell * max_height_of_a_char) + (setting_ocelot_grid_cell_border_size_as_int * 2) + 1 + 1;
  if (this_column_height < (int) grid_row_heights[column_no]) this_column_height= grid_row_heights[column_no];
  return this_column_height;
}

/*
  Re max_display_height: The results of cell_analyze() as for-the-moment are visible in tooltip
  show minimum y = 3 and first row's height is 1 or 2 more than later rows'
  height e.g. it's 23 if others are 21, which partly we can attribute to grid border size. So you see "- 4".
  Todo: maybe that's not always so, so do the size calculation as in cell_analyze() if you can.
  Re row_height: Again it's tooltip that shows I must have "+ 1 + 1" but I have no idea why.
                 I do the same in the column_height() function.
  Todo: eventually row_height + max_display_rows won't need to be calculated at this stage.
  Todo: result_grid_height_after_last_resize can change in ways that might not be anticipated.
  We know that it is wrong for the first display. Todo: check what happens if it's minimized.
*/
void ResultGrid::get_row_height_and_max_display_height_and_max_grid_rows(int *row_height, int *max_display_height, int *max_grid_rows)
{
  *row_height= max_height_of_a_char + setting_ocelot_grid_cell_border_size_as_int * 2 + 1 + 1;
  *max_display_height= result_grid_height_after_last_resize;
  int wx= scroll_bar_width * 2; /* todo: should add width of the leftmost (sizer thin image) column, actually */
  for (int i= 0; i < (int) gridx_column_count; ++i) wx+= grid_column_widths[i]
                                              + setting_ocelot_grid_cell_border_size_as_int * 2
                                            + 1;
  if (wx >= (int) result_grid_width_after_last_resize)
      *max_display_height-= scroll_bar_height;
  (*max_display_height)-= 4;
  if (*max_display_height < *row_height * 2) *max_display_height= *row_height * 2;
  *max_grid_rows= *max_display_height / *row_height;
  if ((ocelot_vertical_copy == 1) && (ocelot_result_grid_column_names_copy == 1))
  {
    --(*max_grid_rows);
  }
  if (*max_grid_rows <= 0) *max_grid_rows= 1;
}

/*
  Display by producing an HTML table and calling setHtml() for it.
  The per-row loop adds to the table and its height is greater than what's available on the widget.
  For every cell (i.e. column instance in a row) we call copy_html_cell which might check for conditionals.
  Todo: If we're producing for export, the height calculation shouldn't apply and dumping should be continuous.
  Todo: Ensure this isn't called for some irrelevant vertical scroll bar event.
        It seems that we're calling display_html multiple times, not once per select, find out why.
  Todo: We're calculating char[] size in advance and using strcpy() or memcpy().
        It would be lots simpler and safer to use a QString or QByteArray, but might be slower.
  Todo: Bug but can't repeat: After (?) detach grid widget, set ocelot_grid_background_color conditionally,
        select * from information_schema, then scroll down (?) then scroll up to the top, only header is seen.
  Re result_grid_height_after_last_resize:
    It might be better to calculate height from Result_qtextedit::resizeEvent, it would probably be
    two pixels smaller than what comes out of ResultGrid::resizeEvent, but we don't change because there
    might be non-HTML stuff that depends on it. For some reason we might be calling display_html more than
    once, but we won't waste too much time if it's -1.
  Todo: Some of the size calculations produce values that we don't end up using, because we found that the
    setHtml() method is more reliable in odd situations. Eliminate what is no longer being used.
*/
void ResultGrid::display_html(int new_grid_vertical_scroll_bar_value, int situation)
{
#if (OCELOT_EXPLORER == 1)
  if (result_grid_type == EXPLORER_WIDGET)
  {
    explorer_display_html(new_grid_vertical_scroll_bar_value);
    return;
  }
#endif
  if ((result_row_count == 0) || (result_column_count == 0))
  {
    if (situation != TOKEN_KEYWORD_OCELOT_EXPORT)
    {
      switch_to_batch_text_edit();
      batch_text_edit->clear(); /* Todo: This is to avoid repeating the message. Possibly that's a bug. */
      batch_text_edit->insertPlainText("row_count == 0 or column_count == 0");
//      this->show();
//      client->show();
    }
    return;
  }
  if (situation != TOKEN_KEYWORD_OCELOT_EXPORT)
  {
    if (result_grid_height_after_last_resize < 0) return;
  }
  switch_to_html_text_edit(); /* so grid_main_layout has html_text_edit and not batch_text_edit */

  if (situation != TOKEN_KEYWORD_OCELOT_EXPORT)
  {
    if (copy_of_ocelot_vertical == 1) { display_html_html_vertical(new_grid_vertical_scroll_bar_value); return; }
  }
  int row_height, max_display_height, max_grid_rows;
  get_row_height_and_max_display_height_and_max_grid_rows(&row_height, &max_display_height, &max_grid_rows);
  int over_height;
  {
    /* over_height = what html_row_height() will overestimate = documentMargin + borders + something unknown */
    /* (this seems to be wrong by 1, normally, but oh well ...) */
    char one_row[]=   "<TR><TD>1</TD></TR>";
    char two_row[]=   "<TR><TD>1</TD></TR><TR><TD>1</TD></TR>";
    int height_1= html_row_height(one_row, one_row + strlen(one_row), 0);
    int height_2= html_row_height(two_row, two_row + strlen(two_row), 0);
    over_height= height_1 - (height_2 - height_1);
  }
  is_paintable= 0;
  /* TODO: IS THIS NECESSARY? IS IT IN THE RIGHT PLACE? */
//  html_text_edit->show();

  /* I SUSPECT THAT IF I HIDE CLIENT THEN SCROLLBAR WON'T WORK CORRECTLY WITH SLIDER */
  /* TODO: WHY WERE THESE THINGS HERE? */
//  this->show();
//  client->show();
//  client->hide();
//  this->hide();

//  grid_vertical_scroll_bar->setVisible(false); /* let it stay visible for tests */
//  grid_main_layout->addWidget(html_text_edit);

  long unsigned int tmp_result_row_number;
  char *result_set_pointer= result_set_copy_rows[new_grid_vertical_scroll_bar_value];
  unsigned int v_length /*, f_length */;
  char *result_field_names_pointer;

  /*
    For every column value we add size of possible overhead in <th> or <td> or <div>.
    Todo: It ought to be possible to do a single non-looping calculation.
 */
  unsigned int tmp_size= sizeof(char);

  unsigned int max_column_heights_total= 0;
  /* <TD></TD> might be replaced by <TD><div class="xx"></div></TD> which is 22 bytes */
  unsigned int extra_for_div= 0;
  if (copy_of_parent->conditional_settings.count() > 0) extra_for_div= 22;

  unsigned int grid_row= 0;
  int local_ocelot_result_grid_column_names_copy;
  unsigned short local_copy_of_ocelot_xml;
  bool local_is_including_thin_image;
  if (situation == TOKEN_KEYWORD_OCELOT_EXPORT)
  {
    local_ocelot_result_grid_column_names_copy= main_exports.column_names;
    html_max_grid_rows= main_exports.max_row_count;
    local_copy_of_ocelot_xml= 0;
    local_is_including_thin_image= false;
  }
  else
  {
    local_ocelot_result_grid_column_names_copy= ocelot_result_grid_column_names_copy;
    html_max_grid_rows= max_grid_rows;
    local_copy_of_ocelot_xml= copy_of_ocelot_xml;
    local_is_including_thin_image= true;
  }
  if ((local_ocelot_result_grid_column_names_copy == 1)
   && (local_copy_of_ocelot_xml == 0))
  {
    /* todo: do a max_column_height calculation as you do for detail rows */
    tmp_size+= strlen(ocelot_grid_header_row_start);
    result_field_names_pointer= &result_field_names[0];
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      tmp_size+= strlen(ocelot_grid_header_char_column_start) + extra_for_div;
      memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
      tmp_size+= v_length;
      result_field_names_pointer+= v_length + sizeof(unsigned int);
      tmp_size+= strlen(ocelot_grid_header_char_column_end);
    }
    tmp_size+= strlen(ocelot_grid_header_row_end);
    max_column_heights_total= row_height;
    ++grid_row;
  }
  tmp_size+= strlen(ocelot_grid_table_start);
  //for (tmp_result_row_number= 0; tmp_result_row_number < result_row_count; ++tmp_result_row_number)
  for (tmp_result_row_number= new_grid_vertical_scroll_bar_value;
       (tmp_result_row_number < result_row_count) && (grid_row < (unsigned int) html_max_grid_rows);
       ++tmp_result_row_number, ++grid_row)
  {
#if (OCELOT_CHART_OR_QCHART == 1)
       /* todo: check: is this pointless? I imagine chart size is always the same, eh? */
      if (chart_widget != NULL)
      {
        chart_widget->chart_row_setup(tmp_result_row_number);
      }
#endif
    result_field_names_pointer= &result_field_names[0];
    tmp_size+= strlen(ocelot_grid_detail_row_start);
    int max_column_height= 0;
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      if ((result_field_flags[i] & NUM_FLAG) != 0)
        tmp_size+= strlen(ocelot_grid_detail_numeric_column_start) + extra_for_div;
      else
        tmp_size+= strlen(ocelot_grid_detail_char_column_start) + extra_for_div;
      tmp_size+= 12; /* for "width=xxxxx;" */
      memcpy(&v_length, result_set_pointer, sizeof(unsigned int));
      result_set_pointer+= sizeof(unsigned int) + sizeof(char);
      int this_column_height= column_height(grid_row, i, v_length, result_set_pointer);
      if (this_column_height > max_column_height) max_column_height= this_column_height;
      tmp_size+= v_length;
      tmp_size+= strlen(ocelot_grid_detail_char_column_end);
      result_set_pointer+= v_length;
    }
    tmp_size+= strlen(ocelot_grid_detail_row_end);
    max_column_heights_total+= max_column_height;
    if (situation == TOKEN_KEYWORD_OCELOT_EXPORT)
    {
      if ((max_column_heights_total) >= (unsigned int) max_display_height)
      {
        /* Too many rows. There's no good justification for "+ 1" but it's harmless to display too few. */
        max_grid_rows= grid_row;
        if (max_grid_rows <= 0) max_grid_rows= 1;
        if ((max_grid_rows == 1) && (copy_of_ocelot_result_grid_column_names == 1)) max_grid_rows= 2;
        break;
      }
    }
#if (OCELOT_CHART_OR_QCHART == 1)
     /* todo: check: it's header so is this pointless? we call chart_row_setup for detail too */
    if (chart_widget != NULL)
    {
      break; /* there's only 1 row per display */
    }
#endif
  }
  tmp_size+= strlen(ocelot_grid_table_end);
  char *tmp;
  /* *5 in case (a) we change & to &amp; (b) we add <br> (c) we use hex digits (d) we forgot something. */
  tmp_size= tmp_size * 5;
  /* +200 because thin_image */

  tmp_size+= 1000000; /* image paste experiment */
#if (OCELOT_CHART == 1)
  if (chart_widget != NULL)
  {
    tmp_size+= chart_widget->chart_alloc_byte_size; /* yet more? */
  }
#endif
  tmp= new char[tmp_size];

  int total_html_row_height= setting_ocelot_grid_cell_border_size_as_int * 2;

  char *tmp_pointer_before_thin_image_call; /* For the first column. Includes height which may need changing. */
  char *tmp_pointer= &tmp[0];

  int new_cell_height; /* If this becomes positive, we have to rewrite at tmp_pointer_before_thin_image_call */

  strcpy(tmp_pointer, ocelot_grid_table_start);
  tmp_pointer+= strlen(ocelot_grid_table_start);
  if (local_ocelot_result_grid_column_names_copy == 1)
  {
    char *result_field_names_pointer;
    result_field_names_pointer= &result_field_names[0];
    char *tmp_pointer_of_row_start= tmp_pointer;
    strcpy(tmp_pointer, ocelot_grid_header_row_start);
    tmp_pointer+= strlen(ocelot_grid_header_row_start);
    tmp_pointer_before_thin_image_call= tmp_pointer;
    if (local_is_including_thin_image) tmp_pointer+= thin_image(tmp_pointer, (const char*) "TH", 1);
    for (unsigned int result_column_no= 0; result_column_no < result_column_count; ++result_column_no)
    {
      memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
      result_field_names_pointer+= sizeof(unsigned int);
      //memcpy(tmp_pointer, result_field_names_pointer, v_length);
      //tmp_pointer+= v_length;
      tmp_pointer+= html_text_edit->copy_html_cell(ocelot_grid_header_char_column_start,
                                                    ocelot_grid_header_char_column_start,
                                                    tmp_pointer,
                                                    result_field_names_pointer,
                                                    FIELD_VALUE_FLAG_IS_STRING,
                                                    v_length,
                                                    TEXTEDITFRAME_CELL_TYPE_HEADER,
                                                    grid_column_widths[result_column_no],
                                                    max_height_of_a_char, /* todo: see if this is set */
                                                    result_grid_font,
                                                    setting_max_width_of_a_char,
                                                    result_column_no,
                                                    0, /* tmp_result_row_number */
                                                    ocelot_grid_header_char_column_end,
                                                    &new_cell_height,
                                                    result_column_no);
      result_field_names_pointer+= v_length;
    }
    strcpy(tmp_pointer, ocelot_grid_header_row_end);
    tmp_pointer+= strlen(ocelot_grid_header_row_end);
    /* Following is unnecessary if export */
    total_html_row_height+= html_row_height(tmp_pointer_of_row_start, tmp_pointer, over_height);
  }
  result_set_pointer= result_set_copy_rows[new_grid_vertical_scroll_bar_value];
  //unsigned int grid_row;
  for (tmp_result_row_number= new_grid_vertical_scroll_bar_value, grid_row= 1;
       (tmp_result_row_number < result_row_count) && (grid_row < (unsigned int) html_max_grid_rows);
       ++tmp_result_row_number, ++grid_row)
//  for (tmp_result_row_number= 0; tmp_result_row_number < result_row_count; ++tmp_result_row_number)
  {
#if (OCELOT_CHART_OR_QCHART == 1)
     /* todo: we're calling this but only display 1 row so we ignore when grid_row > 0 */
    if (chart_widget != NULL)
    {
      chart_widget->chart_row_setup(tmp_result_row_number);
    }
#endif
    char *tmp_pointer_of_row_start= tmp_pointer;
    result_field_names_pointer= &result_field_names[0];
    strcpy(tmp_pointer, ocelot_grid_detail_row_start);
    tmp_pointer+= strlen(ocelot_grid_detail_row_start);
    tmp_pointer_before_thin_image_call= tmp_pointer;
    if (local_is_including_thin_image) tmp_pointer+= thin_image(tmp_pointer, (const char*) "TD", grid_row_heights[grid_row]);
    for (unsigned int result_column_no= 0; result_column_no < result_column_count; ++result_column_no)
    {
      memcpy(&v_length, result_set_pointer, sizeof(unsigned int));
      char result_set_value_flags= *(result_set_pointer + sizeof(unsigned int));
      result_set_pointer+= sizeof(unsigned int) + sizeof(char);
      /* more "HTML only" stuff */
      tmp_pointer+= html_text_edit->copy_html_cell(ocelot_grid_detail_numeric_column_start,
                                                    ocelot_grid_detail_char_column_start,
                                                    tmp_pointer,
                                                    result_set_pointer,
                                                    result_set_value_flags,
                                                    v_length,
                                                    TEXTEDITFRAME_CELL_TYPE_DETAIL,
                                                    grid_column_widths[result_column_no],
                                                    grid_row_heights[grid_row],
                                                    result_grid_font,
                                                    setting_max_width_of_a_char,
                                                    result_column_no,
                                                    tmp_result_row_number,
                                                    ocelot_grid_detail_char_column_end,
                                                    &new_cell_height,
                                                    result_column_no);
      result_set_pointer+= v_length;
      if (new_cell_height > 0)
      {
        thin_image(tmp_pointer_before_thin_image_call, (const char*) "TD", new_cell_height); /* overwrite */
      }
    }
    strcpy(tmp_pointer, ocelot_grid_detail_row_end);
    tmp_pointer+= strlen(ocelot_grid_detail_row_end);
    if (situation != TOKEN_KEYWORD_OCELOT_EXPORT)
    {
      total_html_row_height+= html_row_height(tmp_pointer_of_row_start, tmp_pointer, over_height);
      if ((total_html_row_height >= max_display_height + 1) && (grid_row > 1))
      {
        tmp_pointer= tmp_pointer_of_row_start; /* We've gone too far. Back up and stop output. */
        break;
      }
    }
#if (OCELOT_CHART_OR_QCHART == 1)
    if (chart_widget != NULL)
    {
     break; /* there's only 1 row per display */
    }
#endif
  }
  strcpy(tmp_pointer, ocelot_grid_table_end);
  tmp_pointer+= strlen(ocelot_grid_table_end);
  *tmp_pointer= '\0';
#if (OCELOT_PLUGIN == 1)
  /* Todo: replacer will cause crash because we will delete tmp soon, I guess the solution is to copy it */
  if (copy_of_parent->plugin_widget_list.size() > 0)
  {
    ocelot_plugin_pass.display= tmp;
    int return_code= copy_of_parent->plugin_widget_list_caller(PLUGIN_DISPLAY_HTML, "");
    if (return_code ==  PLUGIN_RETURN_OK_AND_REPLACED)
      tmp= ocelot_plugin_pass.replacer_buffer; /* We don't look at replacer_buffer_length, result must be null-terminated */
  }
#endif

  if (situation == TOKEN_KEYWORD_OCELOT_EXPORT)
  {
    copy_of_parent->history_file_write("TEE", tmp, false);
  }
  else
  {
    html_text_edit->setHtml(tmp);
    html_text_edit->moveCursor(QTextCursor::Start);
    html_text_edit->ensureCursorVisible();
  }
  /* Beware, saying show() causes resize_or_font_change which calls display_html */
  {
//TEST!!    html_text_edit->show();
//TEST!!    show();
//TEST!!    client->show();
  }
  delete [] tmp;
  is_paintable= 1;
  return;
}

/*
  Pass the bytes of an HTML row, inside a <div>.
  Return the row height.
  So html_display() can stop looping when #-of-pixels >= size-of-widget, instead of using row count,
  instead of repeating when there are too many rows (that could turn out to be slow).
  But otherwise we have to track: # of <br>s, conditional change of font or height, image height
  We calculate header height with this too.
  Maybe it's not hard to decide if it would be a row with trouble:
    If (there is more than one row) (not export)
      If (row contains <img other than the initial <img) which would be due to image)
      Or (row contains <br> though in theory we could then calculate number of <br>s per column
         (i.e. each additional <br> adds qfontmetric lineSpacing() or (linespacing()-1) for the first row
      Or (row contains <TD width=0><img width=0 height=N and N is a non-default value
         (which would be due to conditional height change)
      ... Otherwise it's an ordinary row so the height is the default height
  If all rows are not ordinary, this could double the rendering time since display_html()
    in the end will show all rows. However, speed isn't looking bad enough that speeding up is a priority now.
  Once this is working, it should be impossible to overflow so "go to repeat_loop" is not necessary
  Todo: We are calculating strlen(ocelot_grid_table_start|end) frequently, might as well store it
  Todo: We are not checking whether there is only one row -- if so, calculation is unnecessary
  Note: over_height is calculated early in display_html(), it is: QTextDocument.documentMargin() * 2
        which we don't need because when outputting we say setDocumentMargin(0); table border size
        because when we change cell border size we change table border size too and thus it is
        setting_ocelot_grid_cell_border_size_as_int * 2; and ... something else, one or two pixels.
        Todo: We could probably calculate over_height just once, when there is a fnt change
  Note: The "+ 32" in the new statement is arbitrary, probably "+ 1" would be safe.
*/
int ResultGrid::html_row_height(char *tmp_pointer_of_row_start, char *tmp_pointer, int over_height)
{
  QTextDocument text_document;
  int ocelot_grid_table_start_length= strlen(ocelot_grid_table_start);
  int ocelot_grid_table_end_length= strlen(ocelot_grid_table_end);
  int tmp_row_length= tmp_pointer - tmp_pointer_of_row_start;
  char *tmp_row= new char[ocelot_grid_table_start_length + tmp_row_length + ocelot_grid_table_end_length + 32];
  memcpy(tmp_row, ocelot_grid_table_start, ocelot_grid_table_start_length);
  char *tmp_row_pointer= tmp_row + ocelot_grid_table_start_length;
  memcpy(tmp_row_pointer, tmp_pointer_of_row_start, tmp_row_length);
  tmp_row_pointer+= tmp_row_length;
  strcpy(tmp_row_pointer, ocelot_grid_table_end);
  text_document.setHtml(tmp_row);
  int height= text_document.size().height() - over_height;
  delete [] tmp_row;
  return height;
}

/*
  When is_vertical == 1 we have one line per column: [optional column heading] column value.
  Todo: This is only when copy_of_ocelot_html != 0. But size calculation for xml is similar.
  Todo: We're missing recent improvements in display_html(), e.g. re column_height().
*/
void ResultGrid::display_html_html_vertical(int new_grid_vertical_scroll_bar_value)
{
  int row_height, max_display_height, max_grid_rows;
  get_row_height_and_max_display_height_and_max_grid_rows(&row_height, &max_display_height, &max_grid_rows);

  int new_cell_height; /* TODO: WE HAVE TO DO SOMETHING WITH THIS! */

  is_paintable= 0;

//  html_text_edit->show();

  long unsigned int result_row_number;
  char *result_set_pointer= result_set_copy_rows[new_grid_vertical_scroll_bar_value];
  unsigned int v_length, f_length;
  char *result_field_names_pointer;

  /*
    For every column value we add size of possible overhead in <th> or <td> or <div>.
    Todo: It ought to be possible to do a single non-looping calculation.
 */
  unsigned int tmp_size= sizeof(char);

  /* <TD></TD> might be replaced by <TD><div class="xx"></div></TD> which is 22 bytes */
  unsigned int extra_for_div= 0;
  /* We removed a check if copy_of_ocelot_html == 1 here */
  if (copy_of_parent->conditional_settings.count() > 0) extra_for_div= 22;
  if (ocelot_result_grid_column_names_copy == 1)
  {
    tmp_size+= strlen(ocelot_grid_header_row_start);
    result_field_names_pointer= &result_field_names[0];
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      tmp_size+= strlen(ocelot_grid_header_char_column_start) + extra_for_div;
      memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
      tmp_size+= v_length;
      result_field_names_pointer+= v_length + sizeof(unsigned int);
      tmp_size+= strlen(ocelot_grid_header_char_column_end);
    }
    tmp_size+= strlen(ocelot_grid_header_row_end);
  }
  tmp_size+= strlen(ocelot_grid_table_start);

  //for (result_row_number= 0; result_row_number < result_row_count; ++result_row_number)
  unsigned int grid_row;
  for (result_row_number= new_grid_vertical_scroll_bar_value, grid_row= 1;
       (result_row_number < result_row_count) && (grid_row < (unsigned int) max_grid_rows);
       ++result_row_number, ++grid_row)
  {
    result_field_names_pointer= &result_field_names[0];
    tmp_size+= strlen(ocelot_grid_detail_row_start);
    for (unsigned int result_column_no= 0; result_column_no < result_column_count; ++result_column_no)
    {
      if ((result_field_flags[result_column_no] & NUM_FLAG) != 0)
        tmp_size+= strlen(ocelot_grid_detail_numeric_column_start) + extra_for_div;
      else
        tmp_size+= strlen(ocelot_grid_detail_char_column_start) + extra_for_div;
      tmp_size+= 12; /* for "width=xxxxx;" */
//      if (copy_of_ocelot_xml != 0)
      {
        memcpy(&f_length, result_field_names_pointer, sizeof(unsigned int));
        tmp_size+= f_length + 2;
        result_field_names_pointer+= f_length + sizeof(unsigned int);
      }
      memcpy(&v_length, result_set_pointer, sizeof(unsigned int));

      result_set_pointer+= sizeof(unsigned int) + sizeof(char);
      tmp_size+= v_length;
      tmp_size+= strlen(ocelot_grid_detail_char_column_end);
      result_set_pointer+= v_length;
    }
    tmp_size+= strlen(ocelot_grid_detail_row_end);
  }
  tmp_size+= strlen(ocelot_grid_table_end);
  char *tmp;

  /* TEST!!!! * temporarily 50 */
  /* *5 in case (a) we change & to &amp; (b) we add <br> (c) we use hex digits (d) we forgot something. */
  tmp_size= tmp_size * 50;

  /* +200 because thin_image */

  tmp_size+= 1000000; /* image paste experiment */


  tmp= new char[tmp_size];
  char *tmp_pointer= &tmp[0];
  char *tmp_pointer_before_thin_image_call; /* For the first column. Includes height which may need changing. */


  strcpy(tmp_pointer, ocelot_grid_table_start);
  tmp_pointer+= strlen(ocelot_grid_table_start);

  result_set_pointer= result_set_copy_rows[new_grid_vertical_scroll_bar_value];
  //unsigned int grid_row;
  for (result_row_number= new_grid_vertical_scroll_bar_value, grid_row= 0;
       (result_row_number < result_row_count) && (grid_row < (unsigned int) max_grid_rows);
       ++result_row_number, grid_row+= result_column_count)
//  for (result_row_number= 0; result_row_number < result_row_count; ++result_row_number)
  {
    result_field_names_pointer= &result_field_names[0];

    for (unsigned int result_column_no= 0; result_column_no < result_column_count; ++result_column_no)
    {
//      if (copy_of_ocelot_xml != 0)
      strcpy(tmp_pointer, ocelot_grid_detail_row_start);
      tmp_pointer+= strlen(ocelot_grid_detail_row_start);
      tmp_pointer_before_thin_image_call= tmp_pointer;
      tmp_pointer+= thin_image(tmp_pointer, (const char*) "TD", grid_row_heights[grid_row + result_column_no]);

      /* EL KLUDGEO -- until we have a better calculation of grid_column_widths[] when vertical */
//      if (grid_column_widths[i] < 20) grid_column_widths[i]= 200;
      if (ocelot_result_grid_column_names_copy == 1)
      {
        memcpy(&f_length, result_field_names_pointer, sizeof(unsigned int));
        result_field_names_pointer+= sizeof(unsigned int);
        tmp_pointer+= html_text_edit->copy_html_cell(ocelot_grid_header_char_column_start,
                                                      ocelot_grid_header_char_column_start,
                                                      tmp_pointer,
                                                      result_field_names_pointer,
                                                      FIELD_VALUE_FLAG_IS_STRING,
                                                      f_length,
                                                      TEXTEDITFRAME_CELL_TYPE_HEADER,
                                                      result_grid_vertical_width_of_header,
                                                      max_height_of_a_char, /* todo: see if this is set */
                                                      result_grid_font,
                                                      setting_max_width_of_a_char,
                                                      0, /* grid_column_no */
                                                      result_row_number,
                                                      ocelot_grid_header_char_column_end,
                                                      &new_cell_height,
                                                      result_column_no);

        result_field_names_pointer+= f_length;
      }
      memcpy(&v_length, result_set_pointer, sizeof(unsigned int));
      char result_set_value_flags= *(result_set_pointer + sizeof(unsigned int));
      result_set_pointer+= sizeof(unsigned int) + sizeof(char);
      /* more "HTML only" stuff */
      tmp_pointer+= html_text_edit->copy_html_cell(ocelot_grid_detail_numeric_column_start,
                                                    ocelot_grid_detail_char_column_start,
                                                    tmp_pointer,
                                                    result_set_pointer,
                                                    result_set_value_flags,
                                                    v_length,
                                                    TEXTEDITFRAME_CELL_TYPE_DETAIL,
                                                    result_grid_vertical_width_of_value,
                                                    grid_row_heights[grid_row + result_column_no],
                                                    result_grid_font,
                                                    setting_max_width_of_a_char,
                                                    0 + ocelot_result_grid_column_names_copy, /* grid_column_no */
                                                    result_row_number,
                                                    ocelot_grid_detail_char_column_end,
                                                    &new_cell_height,
                                                    result_column_no);
      result_set_pointer+= v_length;
      if (new_cell_height > 0)
      {
        thin_image(tmp_pointer_before_thin_image_call, (const char*) "TD", new_cell_height); /* overwrite */
      }
      strcpy(tmp_pointer, ocelot_grid_detail_row_end);
      tmp_pointer+= strlen(ocelot_grid_detail_row_end);
    }
  }
  strcpy(tmp_pointer, ocelot_grid_table_end);
  tmp_pointer+= strlen(ocelot_grid_table_end);
  *tmp_pointer= '\0';

  /* removed "copy_of_ocelot_html != 0" here */
  if (copy_of_ocelot_raw == 0)
  {
    html_text_edit->setHtml(tmp);
  }
  else
  {
    html_text_edit->insertPlainText(tmp);
  }
  html_text_edit->moveCursor(QTextCursor::Start);
  html_text_edit->ensureCursorVisible();
//  html_text_edit->show();
//  show();
//  client->show();
  delete [] tmp;
  is_paintable= 1;
  return;
}

#if (OCELOT_EXPLORER == 1)
/* See comments before MainWindow::initialize_widget_explorer(). */
/* Todo:
   Items like gridx_field_types might not need to be set up every time.
   The output will contain this, which I think is odd: </TR><TR><TD width=    ><TD width=148>C</TD>
   Todo: wrong pixmap size!
   Todo: There's another way to set up an image, see image().
   Todo: need to restore what's in parent!
   Todo: how to know where user clicks?
         void Result_qtextedit::mouseMoveEvent(QMouseEvent *event) sees where we are if it's a regular rg
         but nothing happens when I'm hovering over a display_html_object rg
         because (result_grid->is_fancy() == false)
         we changed so it is always true but I think that is too much
   Todo: You should also be watching for
         ResultGrid* r;
         for (int i_r= 0; i_r < ocelot_ca.grid_actual_tabs; ++i_r)
         ... because font change happens for this bozo too
         ... I think we should start at -1 in such loops, and if it's -1 there's an always-existent explorer widget
    Todo: we sould be watching for
          int MainWindow::result_grid_add_tab()
          r->installEventFilter(this); * must catch fontChange, show, etc. *
          r->grid_vertical_scroll_bar->installEventFilter(this);
    Todo: use of pixmap() function this might have State = Off. And the width + height is odd.
*/

/*
  The symbols for min|max aka collapse|expand.
   U+25BC Black Down-Pointing Triangle means "It has been expanded".
    So clicking it means: change it to right-pointing and collapse.
   U+25B6 Black Right-Pointing Triangle means "It can be expanded".
    So clicking it means: change it to down-pointing and expand.
  We had some choices e.g. White instead of Black, Pointer instead of Triangle, ""|"".
  Perhaps instead of a QByteArray we could have used a literal.
*/
//#define EXPLORER_MIN ""
//#define EXPLORER_MAX ""
//unsigned int explorer_first_result_row;
//#define EXPLORER_COLUMN_COUNT 3
//#define EXPLORER_FLAG_MIN 1/* = 1 if minimized */
//#define EXPLORER_FLAG_FILTERED 2 /* = 2 if filtered */
//#define EXPLORER_FLAG_NOT_FILTERED 4 /* = 4 if not filtered i.e. this alone is not filtered, all others are */
//#define EXPLORER_FIXED_NAME_WIDTH 20 /* arbitrary, big names take more lines */
/*
  Re scroll bars:
    We have a separate vertical scroll bar, it is always present although if it is was possible to have
    only one row then it would look odd. We ordinarily have no need for a horizontal scroll bar because
    with width="default" we allot enough. So we say ScrollBarAlwaysOff here. But, oddly, if we say
    width='200' or something else too small, a horizontal scroll bar appears anyway, which is fine.
  Todo: maybe this should be early in ResultGrid constructor, "if (this == main_window->explorer_widget)"
  Todo: There are "new" assignments in this, probably we don't eliminate them when closing the explorer.
  Todo: This could be called from ResultGrid() if result_grid_type == EXPLORER_WIDGET
*/
void ResultGrid::explorer_initialize() /* default explorer widget settings, most of which will never change */
{
  batch_text_edit->hide(); /* shouldn't be needed. see switch_to_html */
  hide();
  gridx_column_count= result_column_count= EXPLORER_COLUMN_COUNT;
  /* Todo: if following things already exist, delete them, else there's a small leak. */
  gridx_field_types= new short unsigned int[gridx_column_count];
  result_field_types= new unsigned short int[result_column_count];
  result_field_flags= new unsigned int[result_column_count];
  for (int i= 0; i < EXPLORER_COLUMN_COUNT; ++i)
  {
    gridx_field_types[i]= result_field_types[i]= OCELOT_DATA_TYPE_TEXT;
    result_field_flags[i]= 0;
  }
  //if (grid_column_widths != 0) { delete [] grid_column_widths; grid_column_widths= 0; }
  grid_column_widths= new unsigned int[gridx_column_count];
  /* grid_column_widths[] will be settled during explorer_display_html */
  /* The following line is so is_fancy() will return true. Todo: If we replace with non-grid, should be 0. */
  //  result_row_count= rehash_result_column_count; result_column_count= 4;
  copy_of_ocelot_batch= copy_of_ocelot_xml= copy_of_ocelot_raw= ocelot_vertical_copy= 0;
  ocelot_result_grid_column_names_copy= 0;

  int result_field_names_size= strlen("MIN") + strlen("OBJECT_TYPE") + strlen("OBJECT_NAME")
                           + sizeof(unsigned int) * EXPLORER_COLUMN_COUNT;
  result_field_names= new char[result_field_names_size];
  char *result_field_names_pointer= &result_field_names[0];
  unsigned int v_length;
  char field_name[256];
  for (unsigned int i= 0; i < result_column_count; ++i)
  {
    if (i == 0) {v_length= 3; strcpy(field_name, "MIN"); }
    if (i == 1) {v_length= 11; strcpy(field_name, "OBJECT_TYPE"); }
    if (i == 2) {v_length= 11; strcpy(field_name, "OBJECT_NAME"); }
    memcpy(result_field_names_pointer, &v_length, sizeof(unsigned int));
    result_field_names_pointer+= sizeof(unsigned int);
    memcpy(result_field_names_pointer, field_name, v_length);
    result_field_names_pointer+= v_length;
  }

  grid_scroll_area->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
  grid_scroll_area->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
}

/* The explorer_display_html() stuff that must be called once.
  Todo: Loop 1 only needs to be done once, we're repeating it for every refresh.
  result_row_count is the maximum for the vertical scroll bar
  explorer_widget->result_row_count = main_window->oei_count minus what won't be displayed
  Re per-column loop:
    Mostly this loop is same as the one in explorer_display_html().
    If it's a "C" or "I" in a minimized "T" or "V", or if it's anything except "S" in a minimized "S",
    or if it's false for conditional settings, it will be skipped.
    The constant calling to copy_html_cell() is totally wasted time if there are no conditional settings.
    We don't care what any of the results are, except whether cell height becomes 0.
    We're assuming type = detail not header, that may be wrong but I doubt it affects whether to skip.
  Todo: We're trying to ensure that grid_column_widths[0], grid_column_widths[1] are small by not
        calling get_column_width_in_pixels which won't give < MIN_WIDTH_IN_CHARS and is affected
        by vertical scroll bar width -- which shouldn't affect us provided that we don't allow resize
        or drag. Are we sure resize or drag can't happen? The other way to do it might be
        if (result_grid_type == EXPLORER_WIDGET) return min_width;" in get_column_width_in_pixels().
        Should you be adding setting_ocelot_grid_cell_border_size_as_int? Is that already done somewhere?
   Todo: if USE, or if visible='yes' and USE has already happened, emphasize current by making it bold.
         Is there a SET instruction that can do this?
*/
void ResultGrid::explorer_display()
{
  switch_to_html_text_edit(); /* When should this really be done? And how often? */
  explorer_display_part();
  /* TODO: result_row_count might be 0 if there is filtering, in that case clear screen and return */
  /* vertical_scroll_bar_initialize() has to be done after we know result_row_count */
  vertical_scroll_bar_initialize();
  prepare_for_display_html();
  display_html(0, 0);  /* effectively: explorer_display_html(0) */
}

void ResultGrid::explorer_display_part()
{
  unsigned int r_of_s= 0;                            /* so when we se anything but "S" we can find its "S" */
  unsigned int r_of_t= 0;                            /* so when we see "C" or "I" we can find its "T"  or "V" */
  int new_cell_height;
  result_row_count= 0; /* this will be less than oei_count if some rows are skipped e.g. due to minimize */
  QFontMetrics result_grid_font_metrics= QFontMetrics(result_grid_font);

  if (copy_of_parent->ocelot_explorer_width == "default")
    explorer_max_name_width_in_chars= EXPLORER_FIXED_NAME_WIDTH;
  else
  {
    int width_of_one_char= result_grid_font_metrics.boundingRect("W").width();
    int width_of_widget= copy_of_parent->ocelot_explorer_width.toInt();
    width_of_widget-= (style()->pixelMetric(QStyle::PM_ScrollBarExtent) + 2);
    width_of_widget-= (width_of_one_char * 7); /* size of preceding columns + extra */
    width_of_widget-= setting_ocelot_grid_cell_border_size_as_int * 6; /* assuming 3 columns */
    explorer_max_name_width_in_chars= width_of_widget / width_of_one_char;
    if (explorer_max_name_width_in_chars < EXPLORER_FIXED_NAME_WIDTH) explorer_max_name_width_in_chars= EXPLORER_FIXED_NAME_WIDTH;
  }

  unsigned int tmp_result_row_number;

  unsigned int object_name_size, max_object_name_size= 0;
  for (tmp_result_row_number= 0; tmp_result_row_number < copy_of_parent->oei_count; ++tmp_result_row_number)
  {
    bool is_row_skippable= false;
    QString object_type= copy_of_parent->oei[tmp_result_row_number].object_type;
    if (object_type == "S") r_of_s= tmp_result_row_number;
    if ((object_type == "T") || (object_type == "V")) r_of_t= tmp_result_row_number;
    if ((copy_of_parent->oei[r_of_s].flags&EXPLORER_FLAG_FILTERED) != 0) is_row_skippable= true;
    if (object_type != "S")
    {
      if ((copy_of_parent->oei[r_of_s].flags&EXPLORER_FLAG_MIN) != 0) is_row_skippable= true;
      if ((object_type == "C") || (object_type == "I"))
      {
        if ((copy_of_parent->oei[r_of_t].flags&EXPLORER_FLAG_MIN) != 0) is_row_skippable= true;
        if (copy_of_parent->oei[r_of_t].display_row_number == -1) is_row_skippable= true;
      }
      if (is_row_skippable == false)
      {
        for (unsigned int result_column_no= 0; result_column_no < EXPLORER_COLUMN_COUNT; ++result_column_no)
        {
          QByteArray s;
          if (result_column_no == 0)
          {
            if ((object_type == "S") || (object_type == "T") || (object_type == "V"))
            {
              if ((copy_of_parent->oei[tmp_result_row_number].flags&EXPLORER_FLAG_MIN) == 0) s= EXPLORER_MIN;
              else s= EXPLORER_MAX;
            }
            else s= "";
          }
        if (result_column_no == 1) s= object_type.toUtf8();
          if (result_column_no == 2)
          {
            s= copy_of_parent->oei[tmp_result_row_number].object_name;
            if ((copy_of_parent->oei[tmp_result_row_number].object_type == "C")
             || (copy_of_parent->oei[tmp_result_row_number].object_type == "I"))
              s= copy_of_parent->oei[tmp_result_row_number].part_name;
          }
          char tmp[2048];
          char *tmp_pointer= &tmp[0];
          tmp_pointer+= html_text_edit->copy_html_cell(ocelot_grid_detail_numeric_column_start,
                                                     ocelot_grid_detail_char_column_start,
                                                     tmp_pointer,
                                                     s.data() /* result_set_pointer */,
                                                     0 /* result_set_value_flags */,
                                                     s.size() /* v_length */,
                                                     TEXTEDITFRAME_CELL_TYPE_DETAIL,
                                                     /* !! WHY RESULT_COLUMN_NO? */
                                                     30 /* grid_column_widths[result_column_no] */,
                                                     30 /* grid_row_heights[grid_row] */,
                                                     result_grid_font,
                                                     setting_max_width_of_a_char,
                                                     result_column_no,
                                                     tmp_result_row_number,
                                                     ocelot_grid_detail_char_column_end,
                                                     &new_cell_height,
                                                     result_column_no);
          if (new_cell_height == 0) {is_row_skippable= true; continue; }
        }
      }
    }
    if (is_row_skippable == true)
    {
      /* Skip row, user said SET ocelot_grid_cell_height=0 ..., or upper object is minimized, or filter */
      copy_of_parent->oei[tmp_result_row_number].display_row_number= -1;
      continue;
    }
    object_name_size= copy_of_parent->oei[tmp_result_row_number].object_name.size();
    if (max_object_name_size < object_name_size) max_object_name_size= object_name_size;
    copy_of_parent->oei[tmp_result_row_number].display_row_number= result_row_count;
    ++result_row_count;
    if (max_object_name_size > explorer_max_name_width_in_chars) max_object_name_size= explorer_max_name_width_in_chars;
    if (max_object_name_size > 128) max_object_name_size= 128;
    char tmp_string_1[128 * 4 + 1]; /* if 128-char name, all 4-byte chars, 0-terminated */
    /* Todo: Following lines should restrict column#1/#2 widths to one char width but I get two char widths. */
    grid_column_widths[0]= grid_column_widths[1]= result_grid_font_metrics.boundingRect("W").width();
    unsigned int i;
    for (i= 0; i < max_object_name_size; ++i) {tmp_string_1[i]= 'W';} tmp_string_1[i]= '\0';
    grid_column_widths[2]= get_column_width_in_pixels(tmp_string_1, false, false);
  }
}

/* todo: should this function be private? */
/*
  Re calculations of width and height:
  To prevent jumping around with width during vertical scroll, html_text_edit has a consistent width.
  This width is based on max_object_name_size.
  They are never more than explorer_max_name_width_in_chars which by default is EXPLORER_FIXED_NAME_WIDTH.
  First pass is: for all rows, to get max_object_name_size.
                 ... but we don't consider items that are filtered or suppressed due to EXPLORER_MIN
  Second pass is: for rows until it would overflow widget height: output and decide height.
  Each row's height should be in grid_row_heights[]. Total html_text_edit height may vary.
  Todo: Ordinarily there is no such thing as 1-char width, we always expand to 3, I forget why.
        I'm ignoring that for explorer but if it's due to drag I really must make sure user can't drag.
  Todo: I appear to be assuming that characters will be single-width. Maybe calculate max in pixels?
        There's some sort of calculation based on "if character needs 3 bytes" somewhere, I think.
  Changed plan:
    Width and height are determined by Settings.
    If setting is "default", width is some fixed amount -- percentage of main widget?
    Width of each column can still be determined from content. Or what the hell, depend on horizontal scrollbar.
    Or: Note what the widest one is, and get its width.
  Re nulls:
    The default query that we set up in initialize_widget_explorer() selects ''s not nulls,
    e.g. "select 'D',database(),null,null\n". Since we don't expect nulls, we don't keep flags in oei[]
    and result_field_flags[] and result_value_flags are always 0. Therefore to check for not applicable, use
    set ocelot_explorer_background_color='yellow' where value = ''; (doesn't work yet)
    If in future we have a situation where that's not so, we'll have to add flag fields in the struct.
  Todo: Re start of loop: what you really should be doing is finding the oei[] with the right grid row
*/

void ResultGrid::explorer_display_html(int new_grid_vertical_scroll_bar_value) /* = 0 or what user clicked */
{
  unsigned int grid_row;
  if (copy_of_parent->oei_count == 0) return; /* unnecessary? screen should be cleared? */

  int new_cell_height; /* TODO: WE HAVE TO DO SOMETHING WITH THIS! */

  unsigned int tmp_result_row_number;

  /* We don't really have a result set but maybe we can fool the functions that we call. */

  // TODO! OBVIOUSLY YOU MUST RESTORE ORIGINAL VALUES WHEN YOU'RE DONE HERE!
  //copy_of_parent->ocelot_extra_rule_1_condition= "data_type LIKE '%BINARY'";
  //copy_of_parent->ocelot_extra_rule_1_display_as= "image";

  is_paintable= 0; /* todo: decide the exact spot where you should be setting this */

  /* explorer_first_result_row = result row whose grid row matches new_grid_vertical_scroll_bar_value */
  for (explorer_first_result_row= 0; explorer_first_result_row < copy_of_parent->oei_count; ++explorer_first_result_row)
  {
    if (copy_of_parent->oei[explorer_first_result_row].display_row_number == new_grid_vertical_scroll_bar_value) break;
  }
  /* TODO: What should happen if you didn't find it? Probably it's a bad error but just go back to start? */

  {
    /* as in grid_column_size_calc */
    /* todo: with result_grid_font max_height_of_a_char default = 26, that's unexpectedly large */
    /* Todo: This will crash if you have more than 1000 items, maybe pass a fixed height */
    QFont *pointer_to_font;
   pointer_to_font= &result_grid_font;
    QFontMetrics mm= QFontMetrics(*pointer_to_font);
    max_height_of_a_char= abs(mm.leading()) + abs(mm.ascent()) + abs(mm.descent());
  }
  int cell_height_as_int= get_cell_width_or_height_as_int(copy_of_parent->ocelot_grid_cell_height, max_height_of_a_char);
  unsigned int total_object_name_size= 0;
  /* Loop 2: Calculate how many rows will be in the current display and approximately how big they are. */
  /* TODO: MINIMUM = 1! */
  html_max_grid_rows= 0;
  {
    unsigned int object_name_size;
    unsigned int total_grid_row_heights= 0;
    total_grid_row_heights= 12; /* Perhaps = # of pixels before first row and after last row i.e. margin? */
    for (tmp_result_row_number= explorer_first_result_row;
         tmp_result_row_number < copy_of_parent->oei_count;
         ++tmp_result_row_number)
    {
      if (copy_of_parent->oei[tmp_result_row_number].display_row_number != -1) /* i.e. not skippable */
      {
        object_name_size= copy_of_parent->oei[tmp_result_row_number].object_name.size();
        if ((copy_of_parent->oei[tmp_result_row_number].object_type == "C")
         || (copy_of_parent->oei[tmp_result_row_number].object_type == "I"))
          object_name_size= copy_of_parent->oei[tmp_result_row_number].part_name.size();
        total_object_name_size+= object_name_size;
        unsigned int row_height= cell_height_as_int;
        if (object_name_size > explorer_max_name_width_in_chars) row_height+= cell_height_as_int;
        row_height+= setting_ocelot_grid_cell_border_size_as_int * 2; /* Maybe this sort of makes sense */
        /* Todo: I removed the following because I think it was due to a bug. But should I add any pixels? */
//        row_height+= 9; /* This surely does not make sense but apparently corresponds with reality */
        if ((total_grid_row_heights + row_height) >= (unsigned int) this->height())
        {
          if (html_max_grid_rows > 0) break; /* minimum number of rows to display is 1 */
        }
        grid_row_heights[html_max_grid_rows]= row_height;
        total_grid_row_heights+= row_height;
        ++html_max_grid_rows;
      }
    }
  }
  /* "* 5" is because each character might cause multiple bytes due to UTF-8 or HTML escaping */
  /* "* 500" is a very vague guess about the per-row overhead thinking about width, div, color extras */
  /* "500" is a very vague guess about the per-display overhead */
  /* todo: fix so you've got a better estimate, or do a dummy pass first, or use byte array not char */
  /* todo: is 500 taking into account thin image? */
  int tmp_size= html_max_grid_rows * 5
               + total_object_name_size * 5
               + html_max_grid_rows * 500
               + 500;
  char *tmp;

  tmp= new char[tmp_size];

  char *tmp_pointer_before_thin_image_call; /* For the first column. Includes height which may need changing. */
  QTextDocument text_document; /* will be used for height calculation */
  text_document.setDocumentMargin(0); /* Default margin is 4 so if I don't do this html_text_edit_width will be off. */
  int html_text_edit_height, html_text_edit_width; /* result of height calculation */

repeat_loop: /* go back to here and redo with smaller html_max_grid_rows if result won't fit well in widget */
  char *tmp_pointer= &tmp[0];
  strcpy(tmp_pointer, ocelot_grid_table_start);
  tmp_pointer+= strlen(ocelot_grid_table_start);

  //Result_qtextedit *html_text_edit;
  //html_text_edit= new Result_qtextedit(this);

  for (tmp_result_row_number= explorer_first_result_row, grid_row= 0;
       (tmp_result_row_number < copy_of_parent->oei_count) && (grid_row < html_max_grid_rows);
       ++tmp_result_row_number)
  {
    if (copy_of_parent->oei[tmp_result_row_number].display_row_number != -1) /* i.e. not skippable */
    {
      strcpy(tmp_pointer, ocelot_grid_detail_row_start);
      tmp_pointer+= strlen(ocelot_grid_detail_row_start);
      tmp_pointer_before_thin_image_call= tmp_pointer;
      tmp_pointer+= thin_image(tmp_pointer, (const char*) "TD", grid_row_heights[grid_row]);

      for (unsigned int result_column_no= 0; result_column_no < EXPLORER_COLUMN_COUNT; ++result_column_no)
      {
        QByteArray s;
        QString object_type= copy_of_parent->oei[tmp_result_row_number].object_type;
        if (result_column_no == 0)
        {
          if ((object_type == "S") || (object_type == "T") || (object_type == "V"))
          {
            if ((copy_of_parent->oei[tmp_result_row_number].flags&EXPLORER_FLAG_MIN) == 0) s= EXPLORER_MIN;
            else s= EXPLORER_MAX;
          }
          else s= "";
        }
        if (result_column_no == 1) s= object_type.toUtf8();
        if (result_column_no == 2)
        {
          s= copy_of_parent->oei[tmp_result_row_number].object_name;
          if ((copy_of_parent->oei[tmp_result_row_number].object_type == "C")
           || (copy_of_parent->oei[tmp_result_row_number].object_type == "I"))
            s= copy_of_parent->oei[tmp_result_row_number].part_name;
        }
        //strcpy(tmp_pointer, s.data());
        //tmp_pointer+= s.size();
        /* HERE IS THE SECTION THAT WE NEED TO WORK ON!!! */
        /* todo: check is i supposed to be base-0 or base-1? */
        /* todo: is result_set_value_flags possible is_image() or NUM_FLAG? Um, I guess not */
        /* todo: what if new_cell_height becomes positive? */
        if (result_column_no == 0)
          tmp_pointer+= html_text_edit->copy_html_cell(ocelot_grid_header_numeric_column_start,
                                                       ocelot_grid_header_char_column_start,
                                                       tmp_pointer,
                                                       s.data() /* result_set_pointer */,
                                                       0 /* result_set_value_flags */,
                                                       s.size() /* v_length */,
                                                       TEXTEDITFRAME_CELL_TYPE_HEADER,
                                                       grid_column_widths[result_column_no],
                                                       grid_row_heights[grid_row],
                                                       result_grid_font,
                                                       setting_max_width_of_a_char,
                                                       result_column_no,
                                                       tmp_result_row_number,
                                                       ocelot_grid_header_char_column_end,
                                                       &new_cell_height,
                                                       result_column_no);
        else
          tmp_pointer+= html_text_edit->copy_html_cell(ocelot_grid_detail_numeric_column_start,
                                                       ocelot_grid_detail_char_column_start,
                                                       tmp_pointer,
                                                       s.data() /* result_set_pointer */,
                                                       0 /* result_set_value_flags */,
                                                       s.size() /* v_length */,
                                                       TEXTEDITFRAME_CELL_TYPE_DETAIL,
                                                       /* !! WHY RESULT_COLUMN_NO? */
                                                       grid_column_widths[result_column_no],
                                                       grid_row_heights[grid_row],
                                                       result_grid_font,
                                                       setting_max_width_of_a_char,
                                                       result_column_no,
                                                       tmp_result_row_number,
                                                       ocelot_grid_detail_char_column_end,
                                                       &new_cell_height,
                                                       result_column_no);
        //strcpy(tmp_pointer, ocelot_grid_detail_char_column_end);
        //tmp_pointer+= strlen(ocelot_grid_detail_char_column_end);
      }
      if (new_cell_height > 0) /* todo: apparently this never happens, find out why */
      {
        thin_image(tmp_pointer_before_thin_image_call, (const char*) "TD", new_cell_height); /* overwrite */
      }
      strcpy(tmp_pointer, ocelot_grid_detail_row_end);
      tmp_pointer+= strlen(ocelot_grid_detail_row_end);
      ++grid_row;
    }
  }
  strcpy(tmp_pointer, ocelot_grid_table_end);
  tmp_pointer+= strlen(ocelot_grid_table_end);
  *tmp_pointer= '\0'; /* todo: how are you going to escape \0 in a column? */

  /*
    Now adjust the width and height of the widget.
    NB: Settings | explorer widget will eventually have width + height, which may be "default".
    It seems that setting for the client widget doesn't matter.
    Ordinarily we'd like html_text_edit to fill the width and we should reduce width if it's unnecessary.
    As for height, since we might want a horizontal scroll bar, it should be just below html_text_edit.
     Alternative Method -- results tend to be the same but there might be a speed difference ...
       d.adjustSize();
       QAbstractTextDocumentLayout *l = d.documentLayout();
       QRectF qr= l->frameBoundingRect(d.rootFrame());
       int h= qr.height(); int w= qr.width();
     Re repeating:
       Maybe it would be possible to calculate row sizes only once, but I failed to get it right.
       So we see how big html_text_edit becomes, and if it is larger than the widget size,
       we remove a row and repeat. This happens too often, probably initial calculation is wrong.
     Todo: You only need this for one row, you can figure out height later by multiplying.
           Hmm, no that might not be quite right because a row can require two lines.
     Todo: Because of the scroll bars, this isn't exactly right.
     Todo: Although setting minimum and maximum seems to work, sizeHint might be better.
     Todo: This doesn't settle how we should only do the necessary number, we pump out the whole list.
     Warning: ResultGrid and Result_qtextedit have methods for resizeEvent.
     Todo: Actually width only needs to be done initially, when font changes, or for detach resize.
     See also: https://stackoverflow.com/questions/32467079/update-qtextdocuments-size
  */
  text_document.setHtml(tmp);
  html_text_edit_height= text_document.size().height();
  /* When calculating widget width we assume there is always a vertical scroll bar */
  /* I don't know why "+ 2" but it won't do significant damage. Maybe "+ 3" would be even better. */
  if (copy_of_parent->ocelot_explorer_width == "default")
  {
    html_text_edit_width= text_document.size().width() + style()->pixelMetric(QStyle::PM_ScrollBarExtent) + 2;
    /* Extra width if detached so space for context menu, whose parent is explorer_widget if detached. */
    if (copy_of_parent->ocelot_explorer_detached == "yes") html_text_edit_width+= 300;
  }
  else html_text_edit_width= copy_of_parent->ocelot_explorer_width.toInt();

  if ((html_text_edit_height > this->height()) && (html_max_grid_rows > 1))
  {
    --html_max_grid_rows;
    goto repeat_loop;
  }
  html_text_edit->setHtml(tmp);
  html_text_edit->moveCursor(QTextCursor::Start);
  html_text_edit->ensureCursorVisible();

  html_text_edit->setMinimumWidth(html_text_edit_width);
  html_text_edit->setMaximumWidth(html_text_edit_width);
  this->setMaximumWidth(html_text_edit_width);
  html_text_edit->setMinimumHeight(html_text_edit_height);

  delete [] tmp;
  is_paintable= 1;

  return;
}

/*
  User clicked the explorer min|max column, so toggle between min and max.
  Find what the underlying table name is within the grid.
  Mark it as the opposite of what it was before.
  Do explorer_display_html again.
  We don't depend on gridx row number directly because entries before this might have been skipped,
  but we can store gridx row number in oei during explorer_display_html().
  Alternative: comparing object name (assuming object is a table) should work.
  TODO: THIS IS WRONG IF WE SCROLLED. IT SHOULD BE display_row_number - first_row_number. HERE AND EVERYUWHERE!
  TODO: THIS LOSES SCROLL BAR VALUE.
  Todo: Actually I think we can be sure we're looking at a "S" or "T" or "V"
        so the initial check should be unnecessary.
  Todo: The only thing in explorer_display() that we care about is display_row_number, so splitting something
        out of explorer_display() will be a good idea.
  WHAT YOU REALLY HAVE TO DO IS:
    for each item
      change display_row_number
    setMaximum on the vertical scroll bar, it will be +- column_count
  Todo: In vertical_scroll_bar_initialize() we use grid_result_row_count, which tends to be 0.
        That wrecked toggle(). But why didn't it wreck other functions?
*/
void ResultGrid::explorer_toggle(int focus_result_row_number)
{
  QString object_type= copy_of_parent->oei[focus_result_row_number].object_type;
  if ((object_type == "S") || (object_type == "T") || (object_type == "V"))
  {
    if ((copy_of_parent->oei[focus_result_row_number].flags&EXPLORER_FLAG_MIN) == 0) copy_of_parent->oei[focus_result_row_number].flags |= EXPLORER_FLAG_MIN;
    else copy_of_parent->oei[focus_result_row_number].flags &= (~EXPLORER_FLAG_MIN);
    explorer_display_part();
    display_html(grid_vertical_scroll_bar->value(), 0);
    if (result_row_count <= 1) grid_vertical_scroll_bar->hide();
    else
    {
      grid_vertical_scroll_bar->setMaximum(result_row_count - 1);
      grid_vertical_scroll_bar->show();
    }
    //
    //explorer_display();
  }
}

/*
  Filter so only this S (and its components) are visible
    set all other "S" so their display_row_number is -1
  Then you inevitably are at 0 row of the vertical scroll bar
  Currently we only do this for "S"
  We call this for "not filtered" too, i.e. we are in effect toggling the filtered flag
*/
void ResultGrid::explorer_filter(int focus_result_row_number)
{
  /* ? of course we are point to an "S" so this should be unnecessary */
  QString object_type= copy_of_parent->oei[focus_result_row_number].object_type;
  char is_not_filtered= (copy_of_parent->oei[focus_result_row_number].flags&EXPLORER_FLAG_NOT_FILTERED);

  if (object_type == "S")
  {
    for (unsigned int i= 0; i < copy_of_parent->oei_count; ++i)
    {
      if (copy_of_parent->oei[i].object_type != "S") continue;
      if (is_not_filtered != 0)
      {
        copy_of_parent->oei[i].flags &= (~EXPLORER_FLAG_FILTERED);
        copy_of_parent->oei[i].flags &= (~EXPLORER_FLAG_NOT_FILTERED);
      }
      else
      {
        if (i == (unsigned int) focus_result_row_number)
        {
          copy_of_parent->oei[i].flags &= (~EXPLORER_FLAG_FILTERED);
          copy_of_parent->oei[i].flags |= EXPLORER_FLAG_NOT_FILTERED;
        }
        else
        {
          copy_of_parent->oei[i].flags |= EXPLORER_FLAG_FILTERED;
        }
      }
    }
    explorer_display_part();
    display_html(0, 0);
    if (result_row_count <= 1) grid_vertical_scroll_bar->hide();
    else
    {
      grid_vertical_scroll_bar->setMaximum(result_row_count - 1);
      grid_vertical_scroll_bar->show();
    }
    //
    //explorer_display();
  }
}

/*
  Turn off all filtering, and set all min = yes. This is the original condition.
*/
void ResultGrid::explorer_reset()
{
  for (unsigned int i= 0; i < copy_of_parent->oei_count; ++i)
  {
    copy_of_parent->oei[i].flags= EXPLORER_FLAG_MIN;
  }
  explorer_display_part();
  display_html(0, 0);
  if (result_row_count <= 1) grid_vertical_scroll_bar->hide();
  else
  {
    grid_vertical_scroll_bar->setMaximum(result_row_count - 1);
    grid_vertical_scroll_bar->show();
  }
}

/*
  Get width and height of one row in explorer.
  Call this after rehash because there must be at least one row.
  This should only be needed once, provided we don't allow dragging or rows with multiple lines.
  (Or: allow rows with multiple lines but keep a record of heights.)
  So this is done with a dummy oei, eh?
  Warning: height of two rows is not necessarily (height of one row * 2)
  Warning: explorer_display_html should not resize and show
*/
void ResultGrid::explorer_row_size()
{
  /* 2: call explorer_display_html for one */
  /* 3: set w and h */
  /* 4: adjust the widget, although this will depend on whether there are scroll bars */
  /*    well, the widget size won't change, although the html_text_edit_size might */
  ;
}

#endif

#ifdef DBMS_TARANTOOL
/* Given column name e.g. f_15_1 return number e.g. 15 */
int ResultGrid::column_number(char *column_name, int *off)
{
  char tmp[10]= "";
  int tmp_offset= 0;
  int i= 0;
  for (;; ++i)
  {
    if (*(column_name + i) == '_') break;
    if (*(column_name + i) == '\0') return 0;
  }
  ++i;
  for (;; ++i)
  {
    if (*(column_name + i) == '_') break;
    if (*(column_name + i) == '\0') break;
    tmp[tmp_offset++]= *(column_name + i);
  }
  tmp[tmp_offset]= '\0';
  *off= i;
  return atoi(tmp);
}
#endif

#ifdef DBMS_TARANTOOL
/*
  Make a create statement for a CREATE TABLE ... SERVER table.
  We've done
) so we've done tarantool_scan_field_names()
  so we have result_field_names and result_column_count.
  If Lua statement was 'box.space.X:select()" we may have X's field names,
  in read_format_result.
  If the main connection is also Tarantool, then we make a primary key
  on the first one or two columns -- todo: these might not be the right
  columns, and I'm hoping Tarantool won't always have this requirement.
  Todo: max_column_widths might be unreliable if multibyte character.
  Todo: the assumption that when num_flag != 0 it's "INTEGER" is not always going to be best.
*/
int ResultGrid::creates(QString create_table_statement, int connections_dbms_0, QString read_format_result)
{
  QString tmp;
  QString first_columns= "";
  char *result_field_names_pointer;
  char column_name[512 + 1];
  unsigned int v_length;

  tmp= create_table_statement;
  tmp.append("(");
  result_field_names_pointer= &result_field_names[0];
  for (unsigned int i= 0; i < result_column_count; ++i)
  {
    memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
    result_field_names_pointer+= sizeof(unsigned int);
    memcpy(column_name, result_field_names_pointer, v_length);
    column_name[v_length]= '\0';
    if (i != 0) tmp.append(",");
    char tmp_column_name_number[10];
    int off= 0;
    int c= column_number(column_name, &off);
    sprintf(tmp_column_name_number, "[%d]", c);
    int word_start, word_end;
    QString word= "";
    word_start= read_format_result.indexOf(tmp_column_name_number, 0);
    if (word_start != -1)
    {
      word_start+= strlen(tmp_column_name_number);
      word_end= read_format_result.indexOf("[", word_start);
      if (word_end == -1) word_end= read_format_result.size();
      word= read_format_result.mid(word_start, (word_end - word_start));
    }
    if (word != "")
    {
      char tmp_column_name[512];
      strcpy(tmp_column_name, word.toUtf8());
      strcat(tmp_column_name, column_name + off);
      strcpy(column_name, tmp_column_name);
    }
    tmp.append(column_name);
    if (i == 0) first_columns.append(column_name);
    if (i == 1) {first_columns.append(","); first_columns.append(column_name); }
    if ((result_field_flags[i] & NUM_FLAG) != 0)
    {
      tmp.append(" INTEGER ");
    }
    else
    {
      tmp.append(" VARCHAR(");
      tmp.append(QString::number(result_max_column_widths[i]));
      tmp.append(") ");
    }
    result_field_names_pointer+= v_length;
  }
  if (connections_dbms_0 == DBMS_TARANTOOL)
  {
    tmp.append(", PRIMARY KEY (");
    tmp.append(first_columns);
    tmp.append(")");
  }
  tmp.append(")");
  int result= copy_of_parent->execute_real_query(tmp, 0, &tmp); /* MYSQL_MAIN_CONNECTION */
  if (result != 0) return result;
  return result;
}
#endif

#ifdef DBMS_TARANTOOL
/* Make some insert statements for a remote subquery temporary table */
/*
  KLUDGE ALERT: A column in the first row might be non-numeric
  (field name) even though the field is numeric.
  This is supposed to be fixed soon. Meanwhile we put '' around it.
  What we're saying is "if it doesn't start with a digit then put
  quotes around it", which is close to absurd.
*/
int ResultGrid::inserts(QString temporary_table_name)
{
  long unsigned int tmp_xrow;
  char *pointer= result_set_copy_rows[0];
  unsigned int v_length;
  QString tmp;
  QString s;
  char ctmp[1024];

  /* pointer= result_set_copy_rows[0]; */
  for (tmp_xrow= 0; tmp_xrow < result_row_count; ++tmp_xrow)
  {
    tmp= "INSERT INTO ";
    tmp.append(temporary_table_name);
    tmp.append(" VALUES (");
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      if (i > 0) tmp.append(",");
      memcpy(&v_length, pointer, sizeof(unsigned int));
      char tmp_flag= *(pointer + sizeof(unsigned int));
      pointer+= sizeof(unsigned int) + sizeof(char);
      if (tmp_flag == FIELD_VALUE_FLAG_IS_NULL)
      {
        tmp.append("NULL");
      }
      else if ((v_length > 0) && (*pointer >= '0') && (*pointer <= '9'))
      {
        memcpy(ctmp, pointer, v_length);
        ctmp[v_length]= '\0';
        tmp.append(ctmp);
      }
      else
      {
        tmp.append("'");
        memcpy(ctmp, pointer, v_length);
        ctmp[v_length]= '\0';
        tmp.append(ctmp);
        tmp.append("'");
      }
      pointer+= v_length;
    }
    tmp.append(");");
    int result= copy_of_parent->execute_real_query(tmp, 0, &tmp); /* MYSQL_MAIN_CONNECTION */
    if (result != 0) return result;
  }
  return 0;
}
#endif

/*
  Copy the result_ lists to gridx_lists.
  Originally the idea behind this was that we'd optionally add columns
  that weren't in the result set, like "row count" and (for vertical)
  "header". That's becoming obsolete now, because we change the result
  set copy if ocelot_client_side_functions_copy <> 0. So, perhaps,
  someday we will get rid of this step.
  The values are for a single detail row or single header row.
   gridx_field_names
   gridx_original_field_names
   gridx_original_table_names
   gridx_original_database_names
   gridx_max_column_widths
   gridx_flags                         header | refer to result _ lists
   gridx_field_types
   gridx_result_indexes                use as index for result_ lists
   gridx_column_count, gridx_row_count
   Todo: We rely on a bunch of gridx_* items. They should be in a single struct.
*/
void ResultGrid::copy_result_to_gridx()
{
  unsigned int i, j;
  unsigned int v_lengths;
  char *result_field_names_pointer;
  char *gridx_field_names_pointer;

  /* todo: shouldn't this be only in display_garbage_collect()? */
  if (gridx_field_names != 0) { delete [] gridx_field_names; gridx_field_names= 0; }
  if (gridx_max_column_widths != 0) { delete [] gridx_max_column_widths; gridx_max_column_widths= 0; }
  if (gridx_result_indexes != 0) { delete [] gridx_result_indexes; gridx_result_indexes= 0; }
  if (gridx_flags != 0) { delete [] gridx_flags; gridx_flags= 0; }
  if (gridx_field_types != 0) { delete [] gridx_field_types; gridx_field_types= 0; }

  gridx_column_count= result_column_count;
  gridx_row_count= result_row_count;
  /* result_set_copy, result_set_copy_rows are left alone */
  /*
    First loop: find how much to allocate. Allocate. Second loop: fill in with pointers within allocated area.
  */

  result_field_names_pointer= &result_field_names[0];
  unsigned int total_size= 0;
  for (i= 0; i < result_column_count; ++i)
  {
    memcpy(&v_lengths, result_field_names_pointer, sizeof(unsigned int));
    total_size+= v_lengths + sizeof(unsigned int);
    result_field_names_pointer+= v_lengths + sizeof(unsigned int);
  }
  gridx_field_names= new char[total_size];                                  /* allocate */

  result_field_names_pointer= &result_field_names[0];
  gridx_field_names_pointer= &gridx_field_names[0];
  for (i= 0; i < result_column_count; ++i)
  {
    memcpy(&v_lengths, result_field_names_pointer, sizeof(unsigned int));
    memcpy(gridx_field_names_pointer, &v_lengths, sizeof(unsigned int));
    result_field_names_pointer+= sizeof(unsigned int);
    gridx_field_names_pointer+= sizeof(unsigned int);
    memcpy(gridx_field_names_pointer, result_field_names_pointer, v_lengths);
    result_field_names_pointer+= v_lengths;
    gridx_field_names_pointer+= v_lengths;
  }
  gridx_max_column_widths= new unsigned int[gridx_column_count];
  gridx_result_indexes= new unsigned int[gridx_column_count];
  gridx_flags= new unsigned char[gridx_column_count];
  gridx_field_types= new short unsigned int[gridx_column_count];
  j= 0;
  for (i= 0; i < result_column_count; ++i)
  {
    gridx_max_column_widths[j]= result_max_column_widths[i];
    gridx_result_indexes[j]= i;
    gridx_flags[j]= 0;
    gridx_field_types[j]= result_field_types[i];
    /* todo: following depends on MySQL quirks, should be done earlier */
    if ((result_field_charsetnrs[i] == 63) && (gridx_field_types[j] == OCELOT_DATA_TYPE_VAR_STRING)) gridx_field_types[j]= OCELOT_DATA_TYPE_VARBINARY;
    if ((result_field_charsetnrs[i] == 63) && (gridx_field_types[j] == OCELOT_DATA_TYPE_STRING)) gridx_field_types[j]= OCELOT_DATA_TYPE_BINARY;
    if ((result_field_charsetnrs[i] != 63) && (is_blob(gridx_field_types[j]))) gridx_field_types[j]= OCELOT_DATA_TYPE_TEXT;
    ++j;
  }

  //result_field_names,
  //result_original_field_names, result_original_table_names, result_original_database_names,
}

bool ResultGrid::is_blob(int field_type)
{
  if ((field_type == OCELOT_DATA_TYPE_TINY_BLOB)
   || (field_type == OCELOT_DATA_TYPE_MEDIUM_BLOB)
   || (field_type == OCELOT_DATA_TYPE_LONG_BLOB)
   || (field_type == OCELOT_DATA_TYPE_BLOB))
    return true;
  return false;
}

/*
  Return true if extra_rule_1 is applicable for this column
*/
bool ResultGrid::is_extra_rule_1(int col)
{
  QString condition= copy_of_parent->ocelot_extra_rule_1_condition;
  if (condition == "data_type LIKE '%BLOB'")
  {
    if (is_blob(gridx_field_types[col])) /* e.g. gridx_field_types[col] == OCELOT_DATA_TYPE_BLOB */
    {
      return true;
    }
  }
  if (condition == "data_type LIKE '%BINARY'")
  {
    if ((gridx_field_types[col] == OCELOT_DATA_TYPE_BINARY) || (gridx_field_types[col] == OCELOT_DATA_TYPE_VARBINARY))
    {
      return true;
    }
  }
  return false;
}

/*
  Return true if this column should be displayed as an image,
  that is, the image flag should be turned on.
*/
bool ResultGrid::is_image(int col)
{
  QString display_as;
  display_as= copy_of_parent->ocelot_extra_rule_1_display_as;
  if (display_as == "image")
  {
    if (is_extra_rule_1(col) == true)
    {
      return true;
    }
  }
  return false;
}

/*
  Called from copy_to_history
  Given: UTF8 string, utf8 string length in bytes, column width in characters
  Return: QString, truncated or padded to match column_width
  This doesn't allow for Asian double-width characters
  (there's a Posix function for that but it might be bad on Windows).
  This does allow for Latin and Cyrillic, with or without accents.
  For calculating taking account of font and pixels, see
  grid_column_size_calc().
  Todo: What if there's a picture? Should BLOBs be shown as hex?
  Todo: Test with vertical.
  Todo: If there's a newline, column boundaries are smashed.
  Todo: convert to QString, fiddle, convert back ... not a fast way, eh?
*/
QByteArray ResultGrid::history_padder(char *str, int length,
                       int column_width, char field_value_flags)
{
  QString s= QString::fromUtf8(str, length);
  int space_count= column_width - s.length();
  if (space_count <= 0) s= s.left(column_width);
  else
  {
    QString spaces= " ";
    if (field_value_flags == FIELD_VALUE_FLAG_IS_NUMBER)
      s= spaces.repeated(space_count) + s;
    else
      s= s + spaces.repeated(space_count);
  }
  QByteArray pcv= s.toUtf8();
  return pcv;
}

/*
  Move a limited part of a result set to history.
  We want to show what it looks like, but dumping the whole thing might waste time and space,
  so it's throttled by an ocelot_history variable that can be set to a small values:
  ocelot_history_max_row_count, default "0".
  This is called after preparing a result set in fillup(), and
  depends on fillup() results including max_column widths.
  Example output:
  +------+------+------------+
  | s1   | s2   | The Rain I |
  +------+------+------------+
  |    1 | A    |          0 |
  | NULL | NULL |          0 |
  +------+------+------------+
  The output is the same as what mysql client would display --
    left margin = 1, right margin = 1, left justify if number,
    content length = maximum actual length -- except that mysql
    client has minimum content length = 4 if column is nullable,
    and we don't bother with that, it looks like a flaw.
  Defined limits on column width and on number of columns are arbitrary.
  If changing this, remember to test ^P and ^N which depend on markup.
  Todo: this could be adapted for an alternate way to display the result grid.
  Warning: because history display is html we can show wrong for "<", so
           later history_markup_append() will change to character entities.
  Warning: making the copy bigger would slow down the way the Previous and Next keys work.
  Re file_name: this is NULL if we're really going to history, it's a filename if we're going to export.
  Remaining challenges with copy_to_history:
  * Names and max widths should depend on result_row stuff not gridx_max stuff
  * We should try to keep track of statements so we don't spend too much time going backwards.
  * The "8192" for vertical output is arbitrary. Max should be calculated.
  * Displaying an image as if it's a bunch of characters is a waste of time.
  Re "if (OCELOT_IMPORT_EXPORT == 1)":
    This is for TEXT stuff e.g. CSV. See comments before export_defaults().
    Todo: our size calculation is unsafe, we must add sizes of terminated_by enclosed_by etc.
*/
//#define HISTORY_COLUMN_MARGIN 1
//#define HISTORY_MAX_COLUMN_WIDTH 65535
//#define HISTORY_MAX_COLUMN_COUNT 65535
//#define HISTORY_MAX_VERTICAL_COLUMN_WIDTH 8192
QString ResultGrid::copy_to_history(long int ocelot_history_max_row_count,
                        unsigned short int is_vertical,
                        int connections_dbms,
                        char *file_name)
{
  long unsigned max_row_count= ocelot_history_max_row_count;

  if (max_row_count == 0) return "";

  /* Tarantool won't have picked up column headers if there are no rows */
  if ((result_row_count == 0) && (connections_dbms == DBMS_TARANTOOL))
    return "";

#if (OCELOT_IMPORT_EXPORT == 1)
  QByteArray escapers("");
  escapers.resize(16); /* last-minute fix. actually initial max size is 4 but allowing more should be harmless */
  char escape_char= main_exports.columns_escaped_by[0];
  char null_string[64]; /* todo: should be variable length, in theory this could overflow but usually it's \N */
  char *pointer_to_null_string;
  int length_of_null_string;
  int margin;
  if (file_name != NULL)
  {
    max_row_count= main_exports.max_row_count;
    int e= 0;
    if (main_exports.columns_enclosed_by.size() > 0) escapers[e++]= main_exports.columns_enclosed_by[0];
    if (main_exports.columns_escaped_by.size() > 0) escapers[e++]= main_exports.columns_escaped_by[0];
    if (main_exports.columns_terminated_by.size() > 0) escapers[e++]= main_exports.columns_terminated_by[0];
    if (main_exports.lines_terminated_by.size() > 0) escapers[e++]= main_exports.lines_terminated_by[0];
    if (QString::compare(main_exports.if_null, "DEFAULT", Qt::CaseInsensitive) == 0)
    {
      if (main_exports.columns_escaped_by.size() == 0)
      {
        strcpy(null_string, "NULL");
        length_of_null_string= 4;
      }
      else
      {
        null_string[0]= escapers[0];
        null_string[1]= 'N';
        null_string[2]= '\0';
        length_of_null_string= 2;
      }
    }
    else
    {
      length_of_null_string= main_exports.if_null.size();
      for (int i= 0; i < length_of_null_string; ++i) null_string[i]= main_exports.if_null[i];
      null_string[length_of_null_string]= '\0';
    }
    pointer_to_null_string= null_string;
    margin= main_exports.margin;
  }
  else
  {
    length_of_null_string= strlen(NULL_STRING);
    pointer_to_null_string= (char *) NULL_STRING;
    margin= HISTORY_COLUMN_MARGIN;
  }
#endif

  unsigned int col;
  long unsigned int r;
  unsigned int length;
  unsigned int history_result_column_count;
  unsigned int *history_max_column_widths;
  unsigned long history_result_row_count;
  char *history_line= NULL;
  char *divider_line= NULL;
  char *pointer_to_history_line;
  unsigned int history_line_width;
  QString s;

  s= "";

  history_max_column_widths= 0;
  history_line= 0;

  /* TODO: See whether gridx_column_count was necessary */
  //if (gridx_column_count > HISTORY_MAX_COLUMN_COUNT) history_result_column_count= HISTORY_MAX_COLUMN_COUNT;
  //else history_result_column_count= gridx_column_count;
  if (result_column_count > HISTORY_MAX_COLUMN_COUNT) history_result_column_count= HISTORY_MAX_COLUMN_COUNT;
  else history_result_column_count= result_column_count;

  history_max_column_widths= new unsigned int[history_result_column_count];
  history_line_width= 2; /* sizeof('|') | sizeof('\n') */

  unsigned short column_names_copy= ocelot_result_grid_column_names_copy;
#if (OCELOT_IMPORT_EXPORT == 1)
  if (file_name != NULL) column_names_copy= main_exports.column_names;
#endif
  unsigned int column_width;
  {
    char *pointer_to_field_names= result_field_names;
    unsigned int column_length;
    for (col= 0; col < history_result_column_count; ++col)
    {
      if (column_names_copy == 1)
      {
        memcpy(&column_length, pointer_to_field_names, sizeof(unsigned int));
        pointer_to_field_names+= sizeof(unsigned int);
        pointer_to_field_names+= column_length;
        column_width= column_length;
      }
      else column_width= 0;
      if (column_width < gridx_max_column_widths[col]) column_width= gridx_max_column_widths[col];
      if (column_width > HISTORY_MAX_COLUMN_WIDTH) column_width= HISTORY_MAX_COLUMN_WIDTH;
      history_max_column_widths[col]= column_width;
      history_line_width+= column_width + 1 + margin * 2;
    }
  }
  if (result_row_count > (unsigned long) max_row_count) history_result_row_count= max_row_count;
  else history_result_row_count= result_row_count;

  if (is_vertical == 1)
  {
    unsigned int longest_column_name_length= 0;
    unsigned int column_length;
    if (column_names_copy == 1)
    {
      char *pointer_to_field_names= result_field_names;
      for (col= 0; col < history_result_column_count; ++col)
      {
        memcpy(&column_length, pointer_to_field_names, sizeof(unsigned int));
        if (column_length > longest_column_name_length)
          longest_column_name_length= column_length;
        pointer_to_field_names+= sizeof(unsigned int);
        pointer_to_field_names+= column_length;
      }
    }
    history_line= new char[HISTORY_MAX_VERTICAL_COLUMN_WIDTH + 256];
    for (r= 0; r < history_result_row_count; ++r)
    {
      sprintf(history_line, "*************************** %lu. row ***************************\n", r + 1);
      s.append(history_line);
      char *row_pointer;
      unsigned int column_length;
      char flag;
      char *pointer_to_source;
      row_pointer= result_set_copy_rows[r];
      char *pointer_to_field_names= result_field_names;
      for (col= 0; col < history_result_column_count; ++col)
      {
        pointer_to_history_line= history_line;
        memcpy(&column_length, pointer_to_field_names, sizeof(unsigned int));
        pointer_to_field_names+= sizeof(unsigned int);
        if (longest_column_name_length > column_length)
        {
          memset(pointer_to_history_line, ' ', longest_column_name_length - column_length);
          pointer_to_history_line+= longest_column_name_length - column_length;
        }
        memcpy(pointer_to_history_line, pointer_to_field_names, column_length);
        pointer_to_field_names+= column_length;
        pointer_to_history_line+= column_length;
        *(pointer_to_history_line++)= ':';
        *(pointer_to_history_line++)= ' ';
        memcpy(&column_length, row_pointer, sizeof(unsigned int));
        flag= *(row_pointer + sizeof(unsigned int));
        row_pointer+= sizeof(unsigned int) + sizeof(char);
        if ((flag & FIELD_VALUE_FLAG_IS_NULL) != 0)
        {
          length= length_of_null_string;
          pointer_to_source= pointer_to_null_string;
        }
        else
        {
          length= column_length;
          pointer_to_source= row_pointer;
        }
        if (length > HISTORY_MAX_VERTICAL_COLUMN_WIDTH) length= HISTORY_MAX_VERTICAL_COLUMN_WIDTH;
        memcpy(pointer_to_history_line, pointer_to_source, length);
        row_pointer+= column_length;
        pointer_to_history_line+= length;
        *(pointer_to_history_line)= '\n'; *(pointer_to_history_line + 1)= '\0';
        s.append(history_line);
      }
    }
    return s;
  }
  /* Assume detail line but not divider line might contain 4-byte chars */
  history_line= new char[(history_line_width*4) + 2];
  divider_line= new char[history_line_width + 2];

  {
    char *pointer_to_divider_line;
    pointer_to_divider_line= divider_line;
    *(pointer_to_divider_line++)= '+';
    for (col= 0; col < history_result_column_count; ++col)
    {
      memset(pointer_to_divider_line, '-',
             history_max_column_widths[col] + margin * 2);
      pointer_to_divider_line+=
             history_max_column_widths[col] + margin * 2;
      *(pointer_to_divider_line++)= '+';
    }
    /* Todo: Consider: maybe if file_name != NULL divider_line should end with main_exports.lines_terminated_by? */
    *(pointer_to_divider_line)= '\n'; *(pointer_to_divider_line + 1)= '\0';
  }
  if (column_names_copy == 1)
  {
    char *pointer_to_field_names= result_field_names;
    unsigned int column_length;
#if (OCELOT_IMPORT_EXPORT == 1)
  if (file_name != NULL)
  {
    if (main_exports.divider == true) copy_of_parent->history_file_write("TEE", divider_line, false);
  }
  else
    s.append(divider_line);
#else
  s.append(divider_line);
#endif
    pointer_to_history_line= history_line;
    *(pointer_to_history_line++)= '|';
    QByteArray pcv; /* padded column value */
    for (col= 0; col < history_result_column_count; ++col)
    {
      memset(pointer_to_history_line, ' ', margin);
      pointer_to_history_line+= margin;
      memcpy(&column_length, pointer_to_field_names, sizeof(unsigned int));
      pointer_to_field_names+= sizeof(unsigned int);
      pcv= history_padder(pointer_to_field_names, column_length,
                     history_max_column_widths[col], 0);
      memcpy(pointer_to_history_line, pcv, pcv.size());
      pointer_to_field_names+= column_length;
      pointer_to_history_line+= pcv.size();
      memset(pointer_to_history_line, ' ', margin);
      pointer_to_history_line+= margin;
      *(pointer_to_history_line++)= '|';
    }
    *(pointer_to_history_line)= '\n'; *(pointer_to_history_line + 1)= '\0';
#if (OCELOT_IMPORT_EXPORT == 1)
    if (file_name != NULL)
      copy_of_parent->history_file_write("TEE", history_line, false);
    else
#endif
    s.append(history_line);
  }
  pointer_to_history_line= history_line;
#if (OCELOT_IMPORT_EXPORT == 1)
  if (file_name != NULL)
  {
    if (main_exports.divider == true) copy_of_parent->history_file_write("TEE", divider_line, false);
  }
  else
    s.append(divider_line);
#else
  s.append(divider_line);
#endif
  for (r= 0; r < history_result_row_count; ++r)
  {
    char *row_pointer;
    unsigned int column_length;
    char field_value_flags;
    char *pointer_to_source;
    pointer_to_history_line= history_line;
    row_pointer= result_set_copy_rows[r];
#if (OCELOT_IMPORT_EXPORT == 1)
    if (file_name != NULL)
    {
      strcpy(pointer_to_history_line, main_exports.lines_starting_by.constData());
      pointer_to_history_line+= main_exports.lines_starting_by.size();
    }
    else
#endif
    *(pointer_to_history_line++)= '|';
    QByteArray pcv; /* padded column value */
    for (col= 0; col < history_result_column_count; ++col)
    {
      memcpy(&column_length, row_pointer, sizeof(unsigned int));
      field_value_flags= *(row_pointer + sizeof(unsigned int));
      row_pointer+= sizeof(unsigned int) + sizeof(char);
#if (OCELOT_IMPORT_EXPORT == 1)
      bool is_to_be_enclosed= true;
      if ((main_exports.columns_optionally == true) && ((field_value_flags & FIELD_VALUE_FLAG_IS_STRING) == 0))
        is_to_be_enclosed= false;
      if ((field_value_flags & FIELD_VALUE_FLAG_IS_NULL) != 0)
        is_to_be_enclosed= false;
#endif
      if ((field_value_flags & FIELD_VALUE_FLAG_IS_NULL) != 0)
      {
        length= length_of_null_string;
        pointer_to_source= pointer_to_null_string;
      }
      else
      {
        length= column_length;
        pointer_to_source= row_pointer;
      }
      memset(pointer_to_history_line, ' ', margin);
      pointer_to_history_line+= margin;
#if (OCELOT_IMPORT_EXPORT == 1)
      if ((file_name != NULL) && (main_exports.pad == false))
        pcv= QByteArray(pointer_to_source, length);
      else
        pcv= history_padder(pointer_to_source, length,
                     history_max_column_widths[col], field_value_flags);
#endif
#if (OCELOT_IMPORT_EXPORT == 1)
      if ((file_name != NULL) && (is_to_be_enclosed == true))
      {
        strcpy(pointer_to_history_line, main_exports.columns_enclosed_by.constData());
        pointer_to_history_line+= main_exports.columns_enclosed_by.size();
      }
#endif
      if ((file_name != NULL) && ((field_value_flags & FIELD_VALUE_FLAG_IS_NULL) == 0))
      {
        for (int j= 0; j< pcv.size(); ++j)
        {
          char c= pcv[j];
          /* Warning: if we allowed non-ASCII characters we'd have to allow for multi-byte here. */
          if ((c == main_exports.replace_string.at(0)) && (main_exports.replace_string.length() > 0))
          {
            if (main_exports.with_string.length() > 0) *(pointer_to_history_line++)= main_exports.with_string.at(0);
            if (main_exports.with_string.length() > 1) *(pointer_to_history_line++)= main_exports.with_string.at(1);
          }
          else
          {
            if (c == 0x00)
            {
              if (main_exports.columns_escaped_by.size() > 0) *(pointer_to_history_line++)= escape_char;
              *(pointer_to_history_line++)= '0';
            }
            else if (escapers.contains(c))
            {
              if (main_exports.columns_escaped_by.size() > 0) *(pointer_to_history_line++)= escape_char;
              *(pointer_to_history_line++)= c;
            }
            else *(pointer_to_history_line++)= c;
          }
        }
      }
      else
      {
        memcpy(pointer_to_history_line, pcv, pcv.size());
        pointer_to_history_line+= pcv.size();
      }
      memset(pointer_to_history_line, ' ', margin);
      pointer_to_history_line+= margin;
#if (OCELOT_IMPORT_EXPORT == 1)
      if (file_name != NULL)
      {
        if (is_to_be_enclosed == true)
        {
          strcpy(pointer_to_history_line, main_exports.columns_enclosed_by.constData());
          pointer_to_history_line+= main_exports.columns_enclosed_by.size();
        }
        if ((col < (history_result_column_count - 1)) || (main_exports.last == true))
        {
          strcpy(pointer_to_history_line, main_exports.columns_terminated_by.constData());
          pointer_to_history_line+= main_exports.columns_terminated_by.size();
        }
      }
      else
#endif
      *(pointer_to_history_line++)= '|';
      row_pointer+= column_length;
    }
    /* Todo: Probably something is obsolete here, I think TOKEN_KEYWORD_DEFAULT is no longer a possibility. */
#if (OCELOT_IMPORT_EXPORT == 1)
    if ((file_name != NULL) && (main_exports.type != TOKEN_KEYWORD_DEFAULT))
    {
      strcpy(pointer_to_history_line, main_exports.lines_terminated_by.constData());
    }
    else
#endif
    {
      *(pointer_to_history_line)= '\n'; *(pointer_to_history_line + 1)= '\0'; }
#if (OCELOT_IMPORT_EXPORT == 1)
    if ((file_name != NULL) && (main_exports.type != TOKEN_KEYWORD_DEFAULT))
    {
      copy_of_parent->history_file_write("TEE", history_line, false);
    }
    else
#endif
    {
      s.append(history_line);
    }
  }
#if (OCELOT_IMPORT_EXPORT == 1)
  if (file_name != NULL)
  {
    if (main_exports.divider == true) copy_of_parent->history_file_write("TEE", divider_line, false);
  }
  else
    s.append(divider_line);
#else
  s.append(divider_line);
#endif
  if (history_line != 0) delete [] history_line;
  if (divider_line != 0) delete [] divider_line;
  if (history_max_column_widths != 0) delete [] history_max_column_widths;
  return s;
}

/* Called from ocelot_column_size_calc() or copy_html_cell() */
/* Todo: if it's "default" I'm not sure what to do. */
int ResultGrid::get_cell_width_or_height_as_int(QString cell_width_or_height_as_qstring, int min)
{
  int cell_width_or_height_as_int;
  cell_width_or_height_as_int= cell_width_or_height_as_qstring.toInt();
  //if (cell_width_or_height_as_int > 0)
  {
    if (cell_width_or_height_as_int > 1000) cell_width_or_height_as_int= 1000; /* arbitrary maximum */
#if (OCELOT_EXPLORER == 1)
    if ((result_grid_type == EXPLORER_WIDGET)
     && (cell_width_or_height_as_int == 0)
     && (QString::compare(cell_width_or_height_as_qstring, "default", Qt::CaseInsensitive) != 0))
     {
      return cell_width_or_height_as_int;
     }
#endif
    if (cell_width_or_height_as_int < min) cell_width_or_height_as_int= min; /* arbitrary minimum */
  }
  return cell_width_or_height_as_int;
}


/*
  Thoughts about ocelot_ca.vertical
  ------------------------------

  This is a row with headings-at-top.
  +-------+---------+-----------+
  |  A    |   B     |   C       |
  +-------+---------+-----------+
  | 1111  | 2222    | 3333      |
  +-------+---------+-----------+
  This is the same row with headings-at-left.
  +-------+---------------------+
  | A     |  1111               |
  | B     |  2222               |
  | C     |  3333               |
  +-------+---------------------+
  Headings-at-top is default.
  Headings-at-left is what you get with \G.
  There could also be a menu item to "pivot".
  ? Should the right edge be ragged if headings-at-left?

  Other headings settings:
    Headings suppressed
    Heading width maximum (lines)
    Heading height maximum (lines)

  ? Re-use text_edit_frames[].

  But, for this test, all we'll do is
  put up one row.
  Todo: expandable widgets (drag lines again?)
  Todo: stretch factors?
  Todo: scroll bar
  Todo: sometimes you don't want width(), you want frameGeometry().width()
*/

/*
  Re grid_row_heights
  The height can be "default",
  or changed by SET ocelot_grid_cell_height=n;
  or changed by SET ocelot_grid_cell_height=n WHERE condition;
  or changed by dragging.
  We've said grid_rows_heights[1000] but in fact it should just be the max number of rows in the display.
  Todo: reset whenever there is scrolling so any changes due to dragging are negated.
        (to preserve changes due to dragging we'd have to have an item for every row in the result set).
  Flaw: we have no way to change the height after we output the columns, do we?
*/

/*
  grid_column_size_calc()
  Given column lengths in characters, calculate widths+heights in pixels.
  We aren't using defined width -- we went through the rows earlier and
  know what the maximum actual width is for each column.
  So let's give each column exactly what it needs, and perform a
  "squeeze" (reducing big columns) until the rows will fit, or until
  there's nothing more that can be squeezed. The text_edit_frame will
  be wider+higher than the text_edit_widget because it also has the
  drag line and the border.
  In order to support drag lines and variable-height columns, we have to
  calculate cell sizes ourselves. There were surprise difficulties:
  * Qt will decide there isn't enough space in a cell even if the
    total character-widths and/or character-heights would fit; the
    only solution that I found was to turn off the horizontal and
    vertical scrolls "Qt::ScrollBarAlwaysOff)", and turn the vertical
    scroll bar back on "Qt::ScrollBarAsNeeded)" only when our own
  * Qt has a left margin setting which I didn't know about, see the line
    text_edit_widgets[i_cp]->document()->setDocumentMargin(0);
  * There are bugs for some Qt versions and platforms.
     Mono fonts seem to be more susceptible. Perhaps outline-versus-bitmap is a hint too.
     Courier New is particularly awful, and we don't seem to be the only ones who've noticed, see
     https://bitbucket.org/equalsraf/vim-qt/issues/59/undercurl-underline-or-even-underscore-not
     Incomprehensibly, sometimes leading and descent can be negative.
     See also https://bugreports.qt.io/browse/QTBUG-15974 (didn't help).
  Todo: For italic|oblique we double the width, but for some fonts
        e.g. Ubuntu mono it's not necessary. Discourage italic|oblique.
  Todo: There has to be some maximum size, perhaps a user setting.
  Todo: If contents are not plaintext, HTML can cause chaos. We allow
        HTML because its effects might be what users want to see, for
        example "select '<i>HELLO</i>';" really shows in italics. But
        our calculator won't detect markup that changes character sizes.
  Todo: The calculator won't detect line feeds or other control
        characters, which change height. But I'm not worried about
        <cr>, it should only cause an elider.
  Todo: Allow expansion if ctrl-+.
  Todo: All calculations are for text. Images work, but that's luck.
  Todo: Maximum line width and maximum lines per row aren't user settable.
  Todo: We calculate column width based on the width of 'W'. For fixed
        fonts this is of course correct since all characters have the
        same width. But for non-fixed fonts, if the column is numeric,
        we know that there is no wide character like 'W' so we can
        calculate a smaller maximum character width, but beware of 'NULL'.
        And for non-fixed fonts, maybe some obscure non-Latin characters
        are wider than 'W'.
  Todo: Depending on font() may be wrong because font() is only what
        was requested not what is actual, so things might be more reliable
        if we used fontInfo() then created a font based on that and then
        used QFontMetrics.
  Todo: Allow different cells to have different fonts.
  Todo: Sometimes we recalculate after font change, but not always.
        Therefore sometimes font change will cause an existing grid
        to look ugly, and users can only fix it by redoing the query.
  Todo: see if some non-fixed-font characters are wider than "W".
  Todo: Our minimum width is the header width, or, when the header width
        is short|unstated, the width of one character + the width of a
        vertical scroll bar (which we assume is always the same).
        Maybe there should be a user-settable minimum column width.
        Or there should be a minimum for the sake of elide.
  Todo: Header height calculation should differ from ordinary-row height
        calculation, but shouldn't be done in a different place.
  Todo: Japanese kanji, size 40, Ubuntu mono, needed another pixel,
        has no top margin i.e. it hugs the top border.
  Todo: if you ever do Windows or Mac OS, you'll have to revisit this.
  Re ocelot_grid_cell_width:
    This is undocumented but one can say SET ocelot_grid_cell_width='number' (otherwise it's 'default').
    If it's in a sensible range, all cells should have that width except ones with longer column names.
    If it's 'max' we don't squeeze.
    Similar for ocelot_grid_cell_height.
  Todo: Maybe instead of max_desired_width_in_pixels we should be looking at result_grid_width_after_last_resize
*/
void ResultGrid::grid_column_size_calc(int setting_ocelot_grid_cell_border_size_as_int,
                           int setting_ocelot_grid_cell_drag_line_size_as_int,
                           unsigned short int is_using_column_names,
                           int connections_dbms)
{
  unsigned int i;
  unsigned int sum_tmp_column_lengths;
  unsigned int sum_amount_reduced;
  unsigned int necessary_reduction;
  unsigned int amount_being_reduced;
  unsigned int max_reduction;
  QFont *pointer_to_font;
  int cell_width_as_int;
  pointer_to_font= &result_grid_font;

  /* 2020-07-01 Some calculations here were replaced by settings_change_calc() */

  QFontMetrics mm= QFontMetrics(*pointer_to_font);

  /* max_height_of_a_char= mm.lineSpacing(); didn't work */
  max_height_of_a_char= abs(mm.leading()) + abs(mm.ascent()) + abs(mm.descent());


  cell_width_as_int= get_cell_width_or_height_as_int(copy_of_parent->ocelot_grid_cell_width, character_count_to_pixel_count(MIN_WIDTH_IN_CHARS));
  if ((cell_width_as_int > 0)
   && (QString::compare("default", copy_of_parent->ocelot_grid_cell_width, Qt::CaseInsensitive) != 0))
  {
    for (i= 0; i < gridx_column_count; ++i) grid_column_widths[i]= cell_width_as_int;
    /* Todo: This does nothing about about vertical */
  }
  else
  {

    sum_tmp_column_lengths= 0;

    /*
      The first approximation
      Take it that grid_column_widths[i] = max actual column width.
      If this is good enough, then grid_row_heights[i] = 1 char
      and column width = grid_column_widths[i] chars.
    */
    for (i= 0; i < gridx_column_count; ++i)
    {
      if ((is_using_column_names != 0) && (i < result_column_count))
      {
        /* probably this->mysql_fields[i].name_length */
        grid_column_widths[i]= 0;
        char tmp[1024];
        unsigned int l= dbms_get_field_name_length(i, connections_dbms);
        strncpy(tmp, dbms_get_field_name(i, connections_dbms).toUtf8(), l);
        set_max_column_width(l, tmp, &grid_column_widths[i]);
        //grid_column_widths[i]= dbms_get_field_name_length(i, connections_dbms);
      }
      else grid_column_widths[i]= 1;
      /*
        For some reason -- I never figured it out -- if column width < MIN_WIDTH_IN_CHARS
        and there is a drag line, the drag line disappears.
        If vertical != 0 I compensate for too-short contents a different way.
      */
      if ((grid_column_widths[i] < MIN_WIDTH_IN_CHARS) && (setting_ocelot_grid_cell_drag_line_size_as_int > 0))
        grid_column_widths[i]= MIN_WIDTH_IN_CHARS;
      if (grid_column_widths[i] < gridx_max_column_widths[i]) grid_column_widths[i]= gridx_max_column_widths[i]; /* fields[i].length */
      grid_column_widths[i]= grid_column_widths[i] * setting_max_width_of_a_char
                             + setting_bearing
                             + setting_ocelot_grid_cell_border_size_as_int * 2;
      sum_tmp_column_lengths+= grid_column_widths[i];
    }

    /*
      The Squeeze
      This cuts the widths of the really long columns, it might loop several times.
      This is a strong attempt to reduce to the user-settable maximum, but if we have to override it, we do.
      Cannot squeeze to less than header length
    */
    sum_amount_reduced= 1;

    if (copy_of_parent->ocelot_grid_cell_width != "max")
    {
      while ((sum_tmp_column_lengths > ocelot_grid_max_desired_width_in_pixels) && (sum_amount_reduced > 0))
      {
        necessary_reduction= sum_tmp_column_lengths - ocelot_grid_max_desired_width_in_pixels;
        necessary_reduction-= necessary_reduction % setting_max_width_of_a_char;
        sum_amount_reduced= 0;
        for (i= 0; i < gridx_column_count; ++i)
        {
          unsigned int min_width;
          QString s_header= dbms_get_field_name(i, connections_dbms);
          min_width= get_column_width_in_pixels(s_header, true, false);
          if (grid_column_widths[i] <= min_width) continue;
          max_reduction= grid_column_widths[i] - min_width;
          max_reduction-= max_reduction % setting_max_width_of_a_char;
          if (grid_column_widths[i] >= (sum_tmp_column_lengths / gridx_column_count))
          {
            amount_being_reduced= grid_column_widths[i] / 2;
            amount_being_reduced-= amount_being_reduced % setting_max_width_of_a_char;
            if (amount_being_reduced > necessary_reduction) amount_being_reduced= necessary_reduction;
            if (amount_being_reduced > max_reduction) amount_being_reduced= max_reduction;
            grid_column_widths[i]= grid_column_widths[i] - amount_being_reduced;
            sum_amount_reduced+= amount_being_reduced;
            necessary_reduction-= amount_being_reduced;
            sum_tmp_column_lengths-= amount_being_reduced;
          }
          if (necessary_reduction <= setting_max_width_of_a_char) break; /* todo: consider making this "< 10" */
        }
      }
    }
  }
  grid_actual_row_height_in_lines= 1;
#ifdef OLD_STUFF
  /*
    Each column's height = (gridx_max_column_widths[i] i.e. actual max) / grid_column_widths[i] rounded up.
    If that's greater than the user-defined maximum, reduce to user-defined maximum
    The QTextEdit will get a vertical scroll bar if there's an overflow,
  */

  for (i= 0; i < gridx_column_count; ++i)
  {
    grid_column_heights[i]= (gridx_max_column_widths[i] * setting_max_width_of_a_char) / grid_column_widths[i]; /* mysql_fields[i].length */
    if ((grid_column_heights[i] * grid_column_widths[i]) < (gridx_max_column_widths[i] * setting_max_width_of_a_char))
    {
      ++grid_column_heights[i];
    }
    if (grid_column_heights[i] == 0) ++grid_column_heights[i];
    if (grid_column_heights[i] > ocelot_grid_max_column_height_in_lines) grid_column_heights[i]= ocelot_grid_max_column_height_in_lines;
    if (grid_column_heights[i] > grid_actual_row_height_in_lines) grid_actual_row_height_in_lines= grid_column_heights[i];
  }

  /* Warning: header_height is also calculated like this but in a different place. */
  for (i= 0; i < gridx_column_count; ++i)
  {
    grid_column_heights[i]= (grid_column_heights[i] * max_height_of_a_char)
                            + setting_ocelot_grid_cell_border_size_as_int * 2
                            + setting_ocelot_grid_cell_drag_line_size_as_int;
  }
#endif
  /* TODO: This is supposed to be only for # of rows in the grid */
  int cell_height_as_int;
  cell_height_as_int= get_cell_width_or_height_as_int(copy_of_parent->ocelot_grid_cell_height, max_height_of_a_char);
  if (cell_height_as_int > 0)
  {
    for (i= 0; i < 1000; ++i) grid_row_heights[i]= cell_height_as_int;
    /* Todo: This does nothing about vertical */
  }

  grid_column_size_calc_vertical(is_using_column_names, connections_dbms);
}

/*
  The variant of grid_column_size_calc() that we use if ocelot_ca.vertical == 1.
  We should have called grid_column_size_calc() earlier and we won't change what that produced.
  But we now need, for HTML at least, only two widths:
  header_width = based on width of longest field name, can be 0 if is_using_column_names == 0
  value_width = based on width of longest column value
  Squeezing will be simpler, I hope.
  I no longer care about border_size or drag_line_size.
  Set result_grid_vertical_width_of_header, result_grid_vertical_width_of_value.
*/
void ResultGrid::grid_column_size_calc_vertical(
                           unsigned short int is_using_column_names,
                           int connections_dbms)
{
  unsigned int i;
  unsigned int sum_tmp_column_lengths;
  sum_tmp_column_lengths= 0;
  result_grid_vertical_width_of_header= 0;
  if (is_using_column_names != 0)
  {
    for (i= 0; i < result_column_count; ++i)
    {
      /* probably this->mysql_fields[i].name_length */
      unsigned int width_of_field_name_i= 0;
      char tmp[1024]; /* todo: should be max_field_name_size but I'm not positive that's been checked yet */
      unsigned int l= dbms_get_field_name_length(i, connections_dbms);
      strncpy(tmp, dbms_get_field_name(i, connections_dbms).toUtf8(), l);
      set_max_column_width(l, tmp, &width_of_field_name_i);
      if (width_of_field_name_i > (unsigned int) result_grid_vertical_width_of_header) result_grid_vertical_width_of_header= width_of_field_name_i;
    }
  }
  result_grid_vertical_width_of_value= 0;
  for (i= 0; i < result_column_count; ++i)
  {
    int width_of_field_value_i= 0;
    if (result_max_column_widths[i] < MIN_WIDTH_IN_CHARS) width_of_field_value_i= MIN_WIDTH_IN_CHARS;
    else width_of_field_value_i= gridx_max_column_widths[i];
    if (width_of_field_value_i > result_grid_vertical_width_of_value) result_grid_vertical_width_of_value= width_of_field_value_i;
  }
  result_grid_vertical_width_of_header= character_count_to_pixel_count(result_grid_vertical_width_of_header);
  result_grid_vertical_width_of_value= character_count_to_pixel_count(result_grid_vertical_width_of_value);
  sum_tmp_column_lengths= result_grid_vertical_width_of_header + result_grid_vertical_width_of_value;
  if (sum_tmp_column_lengths > ocelot_grid_max_desired_width_in_pixels)
  {
    result_grid_vertical_width_of_header= (result_grid_vertical_width_of_header * ocelot_grid_max_desired_width_in_pixels) / sum_tmp_column_lengths;
    result_grid_vertical_width_of_value= (result_grid_vertical_width_of_value * ocelot_grid_max_desired_width_in_pixels) / sum_tmp_column_lengths ;
  }
  if (result_grid_vertical_width_of_header < character_count_to_pixel_count(MIN_WIDTH_IN_CHARS))
    result_grid_vertical_width_of_header= character_count_to_pixel_count(MIN_WIDTH_IN_CHARS);
  if (result_grid_vertical_width_of_value < character_count_to_pixel_count(MIN_WIDTH_IN_CHARS))
    result_grid_vertical_width_of_value= character_count_to_pixel_count(MIN_WIDTH_IN_CHARS);
}

#if (OCELOT_MYSQL_INCLUDE == 1)
/*
  Make a copy of mysql_res.
    It's insane that I have to make a copy of what was in mysql_res, = result_set_copy.
    But things get complicated if there are multiple result sets i.e. if mysql_more_results is true.
    Also, after the copy, we're less (or not at all?) dependent on calls to MySQL functions.
  For each column, we have: (unsigned int) length, (char) unused or null flag, (char[n]) contents.
  We want max actual length too.
*/
void ResultGrid::scan_rows(unsigned int p_result_column_count,
               unsigned int p_result_row_count,
               MYSQL_RES *p_mysql_res,
               char **p_result_set_copy,
               char ***p_result_set_copy_rows,
               unsigned int **p_result_max_column_widths)
{
  unsigned long int v_r;
  unsigned int i;
  MYSQL_ROW v_row;
  unsigned long *v_lengths;
//  unsigned int ki;

  for (i= 0; i < p_result_column_count; ++i) (*p_result_max_column_widths)[i]= 0;

  /*
    First loop: find how much to allocate. Allocate. Second loop: fill in with pointers within allocated area.
  */
  unsigned int total_size= 0;
  char *result_set_copy_pointer;
  lmysql->ldbms_mysql_data_seek(p_mysql_res, 0);
  for (v_r= 0; v_r < p_result_row_count; ++v_r)                                /* first loop */
  {
    v_row= lmysql->ldbms_mysql_fetch_row(p_mysql_res);
    v_lengths= lmysql->ldbms_mysql_fetch_lengths(p_mysql_res);
    for (i= 0; i < p_result_column_count; ++i)
    {
//      ki= (v_r + 1) * result_column_count + i;
      if ((v_row == 0) || (v_row[i] == 0))
      {
        total_size+= sizeof(unsigned int) + sizeof(char);
        //total_size+= sizeof(NULL_STRING) - 1;
      }
      else
      {
        if ((ocelot_client_side_functions_copy == 1)
         && (v_lengths[i] == sizeof("row_number() over ()") - 1)
         && (strncasecmp(v_row[i], "row_number() over ()", v_lengths[i]) == 0))
        {
          total_size+= sizeof(unsigned int) + sizeof(char);
          char tmp[24];
          sprintf(tmp, "%lu", v_r + 1);
          total_size+= strlen(tmp);
        }
        else
        {
          total_size+= sizeof(unsigned int) + sizeof(char);
          total_size+= v_lengths[i];
        }
      }
    }
  }
  *p_result_set_copy= new char[total_size];                                              /* allocate */
  *p_result_set_copy_rows= new char*[p_result_row_count];
  result_set_copy_pointer= *p_result_set_copy;
  lmysql->ldbms_mysql_data_seek(p_mysql_res, 0);

  for (v_r= 0; v_r < p_result_row_count; ++v_r)                                 /* second loop */
  {
    (*p_result_set_copy_rows)[v_r]= result_set_copy_pointer;
    v_row= lmysql->ldbms_mysql_fetch_row(p_mysql_res);
    v_lengths= lmysql->ldbms_mysql_fetch_lengths(p_mysql_res);
    for (i= 0; i < p_result_column_count; ++i)
    {
      if ((v_row == 0) || (v_row[i] == 0))
      {
        if (sizeof(NULL_STRING) - 1 > (*p_result_max_column_widths)[i]) (*p_result_max_column_widths)[i]= sizeof(NULL_STRING) - 1;
        memset(result_set_copy_pointer, 0, sizeof(unsigned int));
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_NULL;
        result_set_copy_pointer+= sizeof(unsigned int) + sizeof(char);
      }
      else
      {

        if ((ocelot_client_side_functions_copy == 1)
         && (v_lengths[i] == sizeof("row_number() over ()") - 1)
         && (strncasecmp(v_row[i], "row_number() over ()", v_lengths[i]) == 0))
        {
          char tmp[24];
          sprintf(tmp, "%lu", v_r + 1);
          unsigned int v_length= strlen(tmp);
          //if (v_length > (*p_result_max_column_widths)[i]) (*p_result_max_column_widths)[i]= v_length;
          set_max_column_width(v_length, tmp, (&(*p_result_max_column_widths)[i]));
          memcpy(result_set_copy_pointer, &v_length, sizeof(unsigned int));
          *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_ZERO;
          result_set_copy_pointer+= sizeof(unsigned int) + sizeof(char);
          memcpy(result_set_copy_pointer, tmp, v_length);
          result_set_copy_pointer+= v_length;
        }
        else
        {
          //if (v_lengths[i] > (*p_result_max_column_widths)[i]) (*p_result_max_column_widths)[i]= v_lengths[i];
          set_max_column_width(v_lengths[i], v_row[i], (&(*p_result_max_column_widths)[i]));
          memcpy(result_set_copy_pointer, &v_lengths[i], sizeof(unsigned int));
          *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_ZERO;
          result_set_copy_pointer+= sizeof(unsigned int) + sizeof(char);
          memcpy(result_set_copy_pointer, v_row[i], v_lengths[i]);
          result_set_copy_pointer+= v_lengths[i];
        }
      }
    }
  }
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

/*
  Pass: pointer to + length of a field in the result set, plus char[4] img_type.
  Do: put in img_type: "" or "png" or "jpg" or "gif".
*/
void ResultGrid::set_img_type(const char *pointer, unsigned int v_length, char *img_type)
{
  img_type[0]= '\0';
  if (v_length > 4)
  {
    if (strncmp(pointer,"\x89PNG",4) == 0) strcpy(img_type, "png");
    else if (strncmp(pointer,"\xFF\xD8",2) == 0) strcpy(img_type, "jpg");
    else if (strncmp(pointer,"GIF",3) == 0) strcpy(img_type, "gif");
    /* to: try BMP? check with loadFromData()? */
  }
}

/*
  How many UTF-8 characters are there, maximum?
  This is more important for a width calculation than length in bytes.
  The following doesn't do a great job -- I wanted to get it right for
  Latin special characters and Greek or Cyrillic or other alphabets --
  so it misses combining characters and it mishandles Chinese|Japanese
  characters which sometimes are wide. Essentially the algorithm is:
  count all the ASCII and continuation bytes, don't count leading bytes.
  Don't bother if the length can't be greater than the current maximum.
  Re images:
    We're assuming that anything starting with png|jpg|gif header is png_jpg_gif (which might be wrong).
    We're assuming that any png_jpg_gif should be displayed as an image (which might be wrong).
    We're assuming that a 50-character width is better than v_length (which is arbitrary).
    We're assuming that it's not wide enough then Qt will widen it.
    Todo: one better way would be to let the user specify a number other than 50.
    Todo: one better way would be to figure out the width and height in pixels from the image's header.
     https://stackoverflow.com/questions/16724849/how-do-i-extract-the-width-and-height-of-a-png-from-looking-at-the-header-in-obj
     https://stackoverflow.com/questions/18264357/how-to-get-the-width-height-of-jpeg-file-without-using-library
     https://stackoverflow.com/questions/41670780/how-to-get-the-gif-image-size-dimensions-from-byte-array-in-as3/41672182
  Todo: we're not doing this if vertical!
  Todo: The "++i;" in this code exists so that 3-byte UTF-8 will
        result in double-wide, which seems okay for Japanese kanji.
        But it's ridiculous! Surely many 3-byte UTF-8 characters
        (U+0800 and beyond) are not double-wide, surely some
        2-byte UTF-8 characters are double-wide. For details see
        http://unicode.org/reports/tr11/, http://www.unicode.org/Public/5.2.0/ucd/EastAsianWidth.txt,
        http://stackoverflow.com/questions/3634627/how-to-know-the-preferred-display-width-in-columns-of-unicode-characters
*/
void ResultGrid::set_max_column_width(unsigned int v_length,
                         const char *result_set_copy_pointer,
                         unsigned int *p_result_max_column_width)
{
  if (v_length <= *p_result_max_column_width) return;
  unsigned int j= v_length;
  char img_type[4];
  set_img_type(result_set_copy_pointer, v_length, img_type); /* so img_type = "" or "png" or "jpg" or "gif" */
  if (img_type[0] != '\0') j= 50;
  else
  {
    for (unsigned int i= 0; i < v_length; ++i)
    {
      if (( *(result_set_copy_pointer + i)   & 0xc0) == 0x80)
      {
        --j;
        ++i;
      }
    }
  }
  if (j > *p_result_max_column_width) *p_result_max_column_width= j;
}

#if (OCELOT_MYSQL_INCLUDE == 1)
/*
  Using the same technique as in scan_rows, make a copy of field names.

  Todo: This (length,data,length,data,length,data...) is a bad way to
  store because we have to scan X entries in order to find field X name.
  This would be better: (pointer,pointer,pointer,...data,data,data...).

  MYSQL_FIELD has: name, org_name, org_table, db. We only need name for result set
  display, but we need the others if user edits the result set (see TextEditWidget::keyPressEvent).
  Todo: we could try going through the token list to find this out, but it's tough
  to watch for AS clauses + UNIONs + expressions + which-field-is-which-table, and
  I'm not sure what would occur when the SELECT is inside a stored procedure.
*/
void ResultGrid::scan_field_names(
               const char *which_field,
               unsigned int p_result_column_count,
               char **p_result_field_names)
{
  unsigned int i;
  unsigned int v_lengths;

  /*
    First loop: find how much to allocate. Allocate. Second loop: fill in with pointers within allocated area.
  */
  unsigned int total_size= 0;
  char *result_field_names_pointer;

  for (i= 0; i < p_result_column_count; ++i)                                /* first loop */
  {
      total_size+= sizeof(unsigned int);
      if (strcmp(which_field, "name") == 0) total_size+= mysql_fields[i].name_length;
      else if (strcmp(which_field, "org_name") == 0) total_size+= mysql_fields[i].org_name_length;
      else if (strcmp(which_field, "org_table") == 0) total_size+= mysql_fields[i].org_table_length;
      else /* if (strcmp(which_field, "db") == 0) */ total_size+= mysql_fields[i].db_length;
  }
  *p_result_field_names= new char[total_size];                               /* allocate */

  result_field_names_pointer= *p_result_field_names;
  for (i= 0; i < p_result_column_count; ++i)                                 /* second loop */
  {
    if (strcmp(which_field, "name") == 0) v_lengths= mysql_fields[i].name_length;
    else if (strcmp(which_field, "org_name") == 0) v_lengths= mysql_fields[i].org_name_length;
    else if (strcmp(which_field, "org_table") == 0) v_lengths= mysql_fields[i].org_table_length;
    else /* if (strcmp(which_field, "db") == 0) */ v_lengths= mysql_fields[i].db_length;
    memcpy(result_field_names_pointer, &v_lengths, sizeof(unsigned int));
    result_field_names_pointer+= sizeof(unsigned int);
    if (strcmp(which_field, "name") == 0) memcpy(result_field_names_pointer, mysql_fields[i].name, v_lengths);
    else if (strcmp(which_field, "org_name") == 0) memcpy(result_field_names_pointer, mysql_fields[i].org_name, v_lengths);
    else if (strcmp(which_field, "org_table") == 0) memcpy(result_field_names_pointer, mysql_fields[i].org_table, v_lengths);
    else /* if (strcmp(which_field, "db") == 0) */ memcpy(result_field_names_pointer, mysql_fields[i].db, v_lengths);
    result_field_names_pointer+= v_lengths;
  }
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

#ifdef OLD_STUFF
/*
   Set alignment and height of a cell.
   Todo: There's a terrible amount of duplication:
   We only call this if vertical != 0.
   We call at start and every time we scroll.
   We allow width to vary but we don't allow it to be more than half of result grid width.
   Todo: pass flags so I don't have to check so many field types
   Todo: the name is bad, now we set width here too
*/
int ResultGrid::set_alignment_and_height(int text_edit_frames_index, unsigned int grid_row, int field_type,
                              bool is_header, int maximum_width)
{
  TextEditWidget *cell_text_edit_widget= text_edit_widgets[text_edit_frames_index];
  /* Todo: probably MySQL should be done the same way as Tarantool, no need to check field_type */
  /* Todo: maybe it would be better to check content_field_value_flags & FIELD_VALUE_FLAG_IS_NUMBER */
  if ((field_type <= OCELOT_DATA_TYPE_DOUBLE)
   || (field_type == OCELOT_DATA_TYPE_NEWDECIMAL)
   || (field_type == OCELOT_DATA_TYPE_LONGLONG)
   || (field_type == OCELOT_DATA_TYPE_INT24))
    text_align(cell_text_edit_widget, Qt::AlignRight);
  else text_align(cell_text_edit_widget, Qt::AlignLeft);
  QString s;
  if (text_edit_frames[text_edit_frames_index]->content_pointer == 0) /* or check content_field_value_flags */
  {
    s= QString::fromUtf8(NULL_STRING, sizeof(NULL_STRING) - 1);
  }
  else s= QString::fromUtf8(text_edit_frames[text_edit_frames_index]->content_pointer, text_edit_frames[text_edit_frames_index]->content_length);
  int width= get_column_width_in_pixels(s, is_header, text_edit_frames[text_edit_frames_index]->is_image_flag);

  /* Test: will we override? */
  QString new_tooltip= "";
  QString new_style_sheet= copy_of_parent->ocelot_grid_style_string;
  QString new_cell_height= "";
  QString new_cell_width= "";
  QString new_text= "";
  int returned_cs_number= 0;
  bool result= conditional_setting_evaluate_till_true(
       text_edit_frames[text_edit_frames_index]->ancestor_grid_column_number,
       text_edit_frames[text_edit_frames_index]->ancestor_grid_result_row_number,
       text_edit_frames[text_edit_frames_index]->content_pointer,
       text_edit_frames[text_edit_frames_index]->content_length,
       text_edit_frames[text_edit_frames_index]->cell_type,
       &new_tooltip, &new_style_sheet, &new_cell_height, &new_cell_width, &returned_cs_number, &new_text, NULL);
  if (result == true)
  {
    if (new_cell_width.toInt() > 0)
    {
      width= new_cell_width.toInt();
    }
  }

  if (width > maximum_width) width= maximum_width;

  text_edit_frames[text_edit_frames_index]->setFixedWidth(width);

  /* Height border size = 1 due to setStyleSheet earlier; right border size is passed */
//  if (xrow == 0)
//  {
//    int header_height= max_height_of_a_char
//                     + setting_ocelot_grid_cell_border_size_as_int * 2
//                     + setting_ocelot_grid_cell_drag_line_size_as_int;
//    if (setting_ocelot_grid_cell_drag_line_size_as_int > 0) header_height+= max_height_of_a_char;
//    text_edit_frames[xrow * gridx_column_count + col]->setFixedSize(grid_column_widths[col], header_height);
//    text_edit_frames[xrow * gridx_column_count + col]->setMaximumHeight(header_height);
//    text_edit_frames[xrow * gridx_column_count + col]->setMinimumHeight(header_height);
//  }
//  else
  {
    //int this_width;
    //if (grid_col == 0)
    //{
    //  /* Todo: this should be based on QFontMetrics, 20 is so arbitrary */
    //  this_width= (20) * (text_edit_frames[ki]->content_length + 1);
    //}
    //else
    //this_width= grid_column_widths[grid_col];
    //frame_resize(text_edit_frames_index, grid_col, this_width, grid_column_heights[grid_col]);

    if ((result == true) && (new_cell_height > ""))
    {
      text_edit_frames[text_edit_frames_index]->setFixedHeight(new_cell_height.toInt());
      grid_row_widgets[grid_row]->setFixedHeight(new_cell_height.toInt());
    }
    else
    {
      int h= set_height(text_edit_frames_index, width);
      grid_row_widgets[grid_row]->setFixedHeight(h);
    }
  }

  return width;
}
#endif

#ifdef OLD_STUFF
/*
  Set height of a cell.
  Before we display we proportionally allocate column widths, they stay the same.
  But column height varies with text length and \n, Asian long characters, html.
  We use a Qt routine which effectively handles "given text and width, return height".
  If height > maximum i.e. grid_max_column_height_in_pixels:
    Set to maximum and turn on vertical scrollbar i.e. Qt::ScrollBarAlwaysOn.
    So clicking resultgrid vertical scroll bar goes up/down per row,
    but finer movement can be done on a cell's vertical scroll bar.
    See frame_resize() for how it can be done.
  I think height < minimum i.e. line height is impossible since we start with line height.
  We don't change text_edit_widgets[], it seems to adjust automatically.
  We change grid_row_widgets[] later, to the height of the highest text_edit_frame.
  text_edit_frame[] is QFrame.
  Re: With font size > 32, select "id", "owner", "name" from "_space" limit 1;
      has not enough height by 1 or 2 pixels, if family = Chandas | Jamrul | Khmer OS | Umpush.
      And has missing drag lines if Abyssinica SIL | Carlito | DejaVu Math Tex Gyre.
      The hight problem happens because height within result grid is too high.
      It disappears if you detach grid widget and make result grid larger.
  Re italic|oblique: As the Qt manual says, boundingRect() can ignore a font's
     leftBearing and rightBearing, so it might calculate that there are N characters on a
     line but at display time there are N-minus-1 characters on a line. Therefore, add "W"
     for every line that height indicates, and repeat. Todo: any better ideas?
  Re width. What we pass is text_edit_frames[...]->width()) not text_edit_widgets[...].width().
     So what we can actually fit is passed frame width - (border width * 2 + drag line width).
  Todo: see set_alignment_and_height, we probably don't need both functions.
  Todo: flags could include Qt::TextWordWrap QT::TextDontClip etc. if we specified thus.
  Todo: are you sure you know the width? Maybe you should be using max column widths?
        (or maybe not, because there can be dragging)
  TODO: We should use a similar trick for column width when we make the initial calculation.
        If it's a header, then width calculation should be based on the trick. But for rows,
        it would take too long. Unless we based on a sampling.
  Todo: Find out why "text_edit_frames[ki]->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);" did nothing
  Todo: Should is_paintable still be off?
  Todo: Test: what if string length exceeds the maximum?
  Todo: Test: Kanji with large font. Seems okay now.
  Todo: Notice assumption that setting_ocelot_grid_cell_border_size_as_int is current. Is that correct?
        No. When we change border_size and drag_line_size, we do not immediately adjust
        as we do for changes in size or font
        (Border and drag line are taken into account correctly for the next time we select)
  TODO: SELECT '<font color="red" size="+10">Big Red Text</font>' AS x;
        won't see the size change (probably same problem with <big> etc.).
        because Qt font metrics are based on result_grid_font only.
        "Red" is okay. Turning off HTML can be done with <pre> but maybe there's a better way.
  Todo: Beware images i.e. is_image_flag == true.
  Todo: This is good for headers too because
        () scrollbar might still be on for the cell, we don't clear until we get here
        () if it contains \n then we want it to have a scroll bar, but its maximum is 1 line
        We say max heading height is 1 line, that's arbitrary.
        Bug: I can make the scroll bar appear, but cannot scroll unless I drag.
             Or, if header width > 3, I can scroll.
  Todo: The "for (int i= 0; i < 2; ++i)" loop for italics might not be necessary.
  Todo: Rules differ for vertical != 0.
*/
int ResultGrid::get_column_height_in_pixels(unsigned int text_edit_frames_index, int width, int copy_of_grid_max_column_height_in_pixels)
{
  unsigned int height;
  QFontMetrics result_grid_font_metrics= QFontMetrics(result_grid_font);
  if (text_edit_frames[text_edit_frames_index]->is_image_flag)
  {
    height= 2000; /* arbitrary big maximum */
  }
  else
  {
    QRect r;
    r= text_edit_frames[text_edit_frames_index]->rect();
    QString s;

    if (text_edit_frames[text_edit_frames_index]->content_pointer == 0) /* or check content_field_value_flags */
    {
      s= QString::fromUtf8(NULL_STRING, sizeof(NULL_STRING) - 1);
    }
    else s= QString::fromUtf8(text_edit_frames[text_edit_frames_index]->content_pointer, text_edit_frames[text_edit_frames_index]->content_length);
    int text_edit_widget_width= width - (setting_ocelot_grid_cell_border_size_as_int * 2 + setting_ocelot_grid_cell_drag_line_size_as_int);
    QRect r2;
    /* Saying i < 1 instead of i < 2 disables the kludge for italic. Maybe we won't need it. */
    for (int i= 0; i < 2; ++i)
    {
      r2= result_grid_font_metrics.boundingRect(
          0, /* int x = x coordinate within original rect */
          0, /* int y = y coordinate within original rect */
          text_edit_widget_width, /* int width = r.width(), which we don't change */
          2000, /* int height = height, which is arbitrary big maximum */
          Qt::TextWrapAnywhere + Qt::TextIncludeTrailingSpaces, /* int flags = (see comments before start of this routine) */
          s); /* QString & text= cell contents */
      if (result_grid_font.style() == QFont::StyleNormal) break;
      int n= r2.height() / result_grid_font_metrics.lineSpacing();
      s= s + QString("W").repeated(n);
    }

    height= r2.height() + setting_ocelot_grid_cell_border_size_as_int * 2 + setting_ocelot_grid_cell_drag_line_size_as_int;
  }
  unsigned int max_column_height_in_pixels;
  if ((text_edit_frames[text_edit_frames_index]->cell_type == TEXTEDITFRAME_CELL_TYPE_HEADER)
   && (ocelot_vertical_copy == 0))
  {
    max_column_height_in_pixels= result_grid_font_metrics.lineSpacing();
  }
  else
  {
    max_column_height_in_pixels= copy_of_grid_max_column_height_in_pixels;
  }
  if (height > max_column_height_in_pixels)
  {
    height= max_column_height_in_pixels;
    text_edit_widgets[text_edit_frames_index]->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
  }
  else
    text_edit_widgets[text_edit_frames_index]->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
  return height;
}
#endif

#ifdef OLD_STUFF
/*
  Todo: possible better names: set_column_height_in_pixels, set_cell_height_in_points
*/
int ResultGrid::set_height(unsigned int text_edit_frames_index, int width)
{
  int height= get_column_height_in_pixels(text_edit_frames_index,
                                          width,
                                          grid_max_column_height_in_pixels);

  text_edit_frames[text_edit_frames_index]->setFixedHeight(height);
  //text_edit_widgets[text_edit_frames_index]->setFixedHeight(height);

  //TextEditWidget *text_edit= text_edit_frames[text_edit_frames_index]->findChild<TextEditWidget *>();
  //text_edit_widgets[text_edit_frames_index]->setFixedHeight(nn - 20);
  return height;
}
#endif

/*
  Get column width in pixels.
  Use boundingRect() as you did for set_height() but this time column width isn't fixed.
  I plan to use this for header width calculation.
  The question is: how many pixels do we need to fit this string in a cell,
  given current result_grid_font and border and drag line?
  We do not check maximum size here.
  Re images: They have no characters so there's no point getting a font and checking width that way.
             I could make a QPixMap and call loadFromData() then ask width() but fear that's slow.
             So for them I just return an arbitrary big value and assume they will be clipped
             depending on result grid size.
  Todo: See if it's okay to use this for detail rows.
        Answers would be better but I worry that it would be slow.
  Todo: What you really need is:
        Use the trick for set_max_column_width().
        Divide by width("W") which should be okay because later you'll multiply by width("W").
        Or: max_column_widths should be in pixels.
            The thing that's stopping me is I'm not sure whether we recalculate for font changes.
        Or: for a particular UTF8 character, decide if it's double-width by calling width().
*/
int ResultGrid::get_column_width_in_pixels(QString s, bool is_header, bool is_image_flag)
{
  if (is_image_flag) return 2000; /* arbitrary big maximum */
  QFontMetrics result_grid_font_metrics= QFontMetrics(result_grid_font);
  QRect r2= result_grid_font_metrics.boundingRect(
                                   0, /* int x = x coordinate within original rect */
                                   0, /* int y = y coordinate within original rect */
                                   2000, /* int width = width, which we can change */
                                   2000, /* int height = height, which is arbitrary big maximum */
                                   Qt::TextWrapAnywhere + Qt::TextIncludeTrailingSpaces, /* int flags = (see comments before start of this routine) */
                                   s); /* QString & text= cell contents */
  unsigned int min_width= r2.width();
  /* Kludge alert. It's a mystery, but above min-width calculation sometimes isn't enough.
     However, increasing it should be okay if this is a detail cell and vertical != 0. */
  int really_minimal= character_count_to_pixel_count(1);
  if ((ocelot_vertical_copy != 0) && (is_header == false) && (min_width < (unsigned int) character_count_to_pixel_count(MIN_WIDTH_IN_CHARS)))
    really_minimal= character_count_to_pixel_count(MIN_WIDTH_IN_CHARS);

  if (min_width < really_minimal + scroll_bar_width + 1)
  {
    min_width= really_minimal + scroll_bar_width + 1;
  }

  min_width+= setting_ocelot_grid_cell_border_size_as_int * 2
              + setting_ocelot_grid_cell_drag_line_size_as_int;
  return min_width;
}


#ifdef OLD_STUFF
/*
  Put lengths and pointers in text_edit_frames.
  Set a flag to say "not retrieved yet", that happens at paint time.
  Todo: make a copy if there are multiple result sets.
  Todo: this points directly to a mysql_res row, ignoring the earlier clever ideas in dbms_get_field_value().
*/
/* The big problem is that setVerticalSpacing(0) goes awry if I use hide(). */
/* Todo: Think whether there's a chance that, while somebody scroll to the end,
   the hide() comes too late, i.e. a paint might occur for an invalid row.
   Maybe show() should be delayed until after hide(), or painting should be prevented for a while. */

void ResultGrid::fill_detail_widgets(int new_grid_vertical_scroll_bar_value, int connections_dbms)
{
  unsigned int i;
  unsigned int text_edit_frames_index;
  unsigned int grid_row;
  int first_row;
  char *row_pointer;

  first_row= new_grid_vertical_scroll_bar_value;

  if (ocelot_vertical_copy != 0)
  {
    unsigned int result_column_number; /* i.e. column number in result set, not column number in grid */
    first_row= new_grid_vertical_scroll_bar_value / result_column_count;
    result_column_number= new_grid_vertical_scroll_bar_value % result_column_count;
    unsigned int new_content_length= 0;
    row_pointer= result_set_copy_rows[first_row];
    for (unsigned int j= 0; ; ++j)
    {
      memcpy(&new_content_length, row_pointer, sizeof(unsigned int));
      row_pointer+= sizeof(unsigned int) + sizeof(char);
      if (j >= result_column_number) break;
      row_pointer+= new_content_length;
    }

    /* now row_pointer -> result column, and each subsequent result column is a grid row */
    //grid_row= first_row;

    grid_row= 0;
    result_row_number= first_row;

    for (;;)
    {
      unsigned int v_lengths= 0;

      text_edit_frames_index= grid_row * gridx_column_count;
      unsigned int o_text_edit_frames_index= text_edit_frames_index;

      /* result_column_number is still known */
      //if (ocelot_client_side_functions_copy != 0)                         /* include row#? */
      //{
      //  text_edit_frames[text_edit_frames_index]->content_length= 0;
      //  text_edit_frames[text_edit_frames_index]->content_field_value_flags= 0;
      //  text_edit_frames[text_edit_frames_index]->content_pointer= 0;
      //  text_edit_frames[text_edit_frames_index]->is_retrieved_flag= false;
      //  text_edit_frames[text_edit_frames_index]->ancestor_grid_column_number= result_column_number;
      //  text_edit_frames[text_edit_frames_index]->ancestor_grid_result_row_number= result_row_number;
      //  text_edit_frames[text_edit_frames_index]->is_image_flag= false;
      //  ++text_edit_frames_index;
      //}
      if (ocelot_result_grid_column_names_copy != 0)               /* include column header? */
      {
        char *result_field_names_pointer= &result_field_names[0];
        for (unsigned int mi= 0; ; ++mi)
        {
          memcpy(&v_lengths, result_field_names_pointer, sizeof(unsigned int));
          result_field_names_pointer+= sizeof(unsigned int);
          if (mi >= result_column_number) break;
          result_field_names_pointer+= v_lengths;
        }
        text_edit_frames[text_edit_frames_index]->content_length= v_lengths;
        text_edit_frames[text_edit_frames_index]->content_pointer= result_field_names_pointer;
        text_edit_frames[text_edit_frames_index]->content_field_value_flags= 0;
        text_edit_frames[text_edit_frames_index]->is_retrieved_flag= false;
        text_edit_frames[text_edit_frames_index]->ancestor_grid_column_number= result_column_number;
        text_edit_frames[text_edit_frames_index]->ancestor_grid_result_row_number= result_row_number;
        text_edit_frames[text_edit_frames_index]->is_image_flag= false;
        ++text_edit_frames_index;
      }
      text_edit_frames[text_edit_frames_index]->content_length= new_content_length; /* include value. */
      char field_value_flags= *(row_pointer - 1);
      text_edit_frames[text_edit_frames_index]->content_field_value_flags= field_value_flags;
      if (field_value_flags == FIELD_VALUE_FLAG_IS_NULL)
      {
        text_edit_frames[text_edit_frames_index]->content_pointer= 0;
      }
      else text_edit_frames[text_edit_frames_index]->content_pointer= row_pointer;
      text_edit_frames[text_edit_frames_index]->is_retrieved_flag= false;
      text_edit_frames[text_edit_frames_index]->ancestor_grid_column_number= result_column_number;
      text_edit_frames[text_edit_frames_index]->ancestor_grid_result_row_number= result_row_number;
      if (is_extra_rule_1(result_column_number) == true)
      {
        if (text_edit_frames[text_edit_frames_index]->cell_type == TEXTEDITFRAME_CELL_TYPE_DETAIL)
        {
          text_edit_frames[text_edit_frames_index]->cell_type= TEXTEDITFRAME_CELL_TYPE_DETAIL_EXTRA_RULE_1;
          text_edit_frames[text_edit_frames_index]->is_style_sheet_set_flag= false;
        }
      }
      else
      {
        if (text_edit_frames[text_edit_frames_index]->cell_type == TEXTEDITFRAME_CELL_TYPE_DETAIL_EXTRA_RULE_1)
        {
          text_edit_frames[text_edit_frames_index]->cell_type= TEXTEDITFRAME_CELL_TYPE_DETAIL;
          text_edit_frames[text_edit_frames_index]->is_style_sheet_set_flag= false;
        }
      }
      if (is_image(result_column_number) == true)
      {
        text_edit_frames[text_edit_frames_index]->is_image_flag= true;
      }
      else text_edit_frames[text_edit_frames_index]->is_image_flag= false;

      int column_number_within_gridx= 0;

      if (ocelot_result_grid_column_names_copy != 0) gridx_max_column_widths[column_number_within_gridx++]= v_lengths;

      if (*(row_pointer - 1) == FIELD_VALUE_FLAG_IS_NULL)
      {
        gridx_max_column_widths[column_number_within_gridx]= sizeof(NULL_STRING) - 1;
      }
      else gridx_max_column_widths[column_number_within_gridx]= new_content_length;
      grid_column_size_calc(setting_ocelot_grid_cell_border_size_as_int,
                            setting_ocelot_grid_cell_drag_line_size_as_int,
                            0,
                            connections_dbms); /* get grid_column_widths[] and grid_column_heights[] */
      column_number_within_gridx= 0;
      //if (ocelot_client_side_functions_copy != 0)
      //{
      //  set_alignment_and_height(o_text_edit_frames_index + column_number_within_gridx,
      //                           column_number_within_gridx, -- but nowadays we pass grid_row not this
      //                           OCELOT_DATA_TYPE_SHORT);
      //  text_edit_frames[o_text_edit_frames_index + column_number_within_gridx]->show();
      //  ++column_number_within_gridx;
      //}
      int maximum_width= ocelot_grid_max_desired_width_in_pixels / 2;
      if (ocelot_result_grid_column_names_copy != 0)
      {
        int w= set_alignment_and_height(o_text_edit_frames_index + column_number_within_gridx,
                                 grid_row,
                                 OCELOT_DATA_TYPE_STRING,
                                 true, maximum_width);
        /* todo: shouldn't maximum width allow for spacing between cells? */
        maximum_width= ocelot_grid_max_desired_width_in_pixels - w;
        text_edit_frames[o_text_edit_frames_index + column_number_within_gridx]->show();
        ++column_number_within_gridx;
      }
      set_alignment_and_height(o_text_edit_frames_index + column_number_within_gridx,
                               grid_row,
                               result_field_types[result_column_number],
                               false, maximum_width);

      text_edit_frames[o_text_edit_frames_index + column_number_within_gridx]->show();
      ++result_column_number;
      ++grid_row;
      if (result_column_number == result_column_count)
      {
        ++result_row_number;
        result_column_number= 0;
      }
      if (result_row_number >= result_row_count) break;
      if (grid_row >= result_grid_widget_max_height_in_lines) break;
      row_pointer+= new_content_length;
      memcpy(&new_content_length, row_pointer, sizeof(unsigned int));
      row_pointer+= sizeof(unsigned int) + sizeof(unsigned char);
    }
    //for (text_edit_frames_index= text_edit_frames_index + 1; text_edit_frames_index < max_text_edit_frames_count; ++text_edit_frames_index) text_edit_frames[text_edit_frames_index]->hide();
  }

  else /* if ocelot_vertical_copy == 0 */
  {
    if (ocelot_result_grid_column_names_copy != 0)
    {
      int h= get_column_height_in_pixels(0, 5000, grid_max_column_height_in_pixels);
      grid_row_widgets[0]->setFixedHeight(h);
    }
    for (result_row_number= first_row, grid_row= 1;
         (result_row_number < result_row_count) && (grid_row < result_grid_widget_max_height_in_lines);
         ++result_row_number, ++grid_row)
    {
      row_pointer= result_set_copy_rows[result_row_number];
//      lengths= lmysql->ldbms_mysql_fetch_lengths(grid_mysql_res);
      for (i= 0; i < gridx_column_count; ++i)
      {
        text_edit_frames_index= grid_row * gridx_column_count + i;
        if (gridx_flags[i] == 1)        /* row number? */
        {
          text_edit_frames[text_edit_frames_index]->content_length= 0;
          text_edit_frames[text_edit_frames_index]->content_pointer= 0;
          text_edit_frames[text_edit_frames_index]->content_field_value_flags= FIELD_VALUE_FLAG_IS_NUMBER;
        }
        else
        {
          memcpy(&(text_edit_frames[text_edit_frames_index]->content_length), row_pointer, sizeof(unsigned int));
          row_pointer+= sizeof(unsigned int) + sizeof(char);
          char field_value_flags= *(row_pointer - 1);
          text_edit_frames[text_edit_frames_index]->content_field_value_flags= field_value_flags;
          if (field_value_flags == FIELD_VALUE_FLAG_IS_NULL)
          {
            text_edit_frames[text_edit_frames_index]->content_pointer= 0;
          }
          else text_edit_frames[text_edit_frames_index]->content_pointer= row_pointer;
          row_pointer+= text_edit_frames[text_edit_frames_index]->content_length;
        }
        set_height(text_edit_frames_index, text_edit_frames[text_edit_frames_index]->width());
        text_edit_frames[text_edit_frames_index]->is_retrieved_flag= false;
        text_edit_frames[text_edit_frames_index]->ancestor_grid_column_number= i;
        text_edit_frames[text_edit_frames_index]->ancestor_grid_result_row_number= result_row_number;
        text_edit_frames[text_edit_frames_index]->show();
      }
      /* Make row height = height of highest cell ... remember to do it differently if vertical != 0! */
      int highest_height= 0;
      for (i= 0; i < gridx_column_count; ++i)
      {
        text_edit_frames_index= grid_row * gridx_column_count + i;
        if (highest_height < text_edit_frames[text_edit_frames_index]->height())
          highest_height= text_edit_frames[text_edit_frames_index]->height();
      }
      grid_row_widgets[grid_row]->setFixedHeight(highest_height);
    }
  }
  /* todo: maybe what we really want is to hide as far as # of used rows, which may be < max */
  for (grid_row= grid_row; grid_row < result_grid_widget_max_height_in_lines; ++grid_row) /* so if scroll bar goes past end we won't see these */
  {
    for (i= 0; i < gridx_column_count; ++i)
    {
      text_edit_frames_index= grid_row * gridx_column_count + i;
      text_edit_frames[text_edit_frames_index]->hide();
    }
  }
}
#endif

/*
  We don't know exactly the maximum number of lines that will fit
  on a grid widget, but we can guess based on the height of the
  grid widget divided by the height of one line in a text edit widget.
  This affects: the size of the row pool (it must be >= the number
  of lines), the decision what kind of vertical scroll bar to use,
  and the number of detail widgets that we will fill with data.
  Two things can affect the calculation:
  (1) Height of result_grid_table_widget[i] can change, at start,
      or due to squeezing by statement + history widgets, or due
      to user action if the widget is detached. resizeEvent() sees that.
      If the number of lines increases, resize + display again.
  (2) Height of the text edit widget can change, set_all_style_sheets()
      sees that. For either increase or decrease, resize + display again.
  We're making the over-cautious assumption that it will be necessary to assign
  1 texteditframe for 1 line. In fact a texteditframe is always bigger than a line.
  We try to avoid recalculating just because user shifts by a few pixels.
  display_html() should not show() because that would cause a call to here, we'd loop
  Todo: what about copy_of_ocelot_raw?
*/
void ResultGrid::resize_or_font_change(int height_of_grid_widget, bool is_resize)
{
#if (OCELOT_CHART_OR_QCHART == 1)
  if (chart_widget != NULL)
  {
    prepare_for_display_html();
    display_html(grid_vertical_scroll_bar->value(), 0);
    return;
  }
#endif

  if (html_text_edit == NULL) return; /* ?? this should be impossible */
  set_grid_max_column_height_in_pixels(this->height());
  /* Todo: the following set of conditions was always true, check what the real intent was */
//  if ((copy_of_ocelot_batch != 0)
//   || (copy_of_ocelot_html != 0)
//   || (copy_of_ocelot_html == 0)
//   || (copy_of_ocelot_xml != 0))
  {
    if ((copy_of_ocelot_batch != 0) || (copy_of_ocelot_xml != 0))
      html_text_edit->setStyleSheet(copy_of_parent->ocelot_grid_style_string);
    else
    {
//      if (is_resize == false)
      if (is_fancy() == true)
      {
        /* Todo: this shouldn't be 0, it should be current scrollbar value */
        prepare_for_display_html();
        display_html(grid_vertical_scroll_bar->value(), 0);
      }
    }
    return;
  }
//  QFont tmp_font= this->font();
  QFontMetrics mm= QFontMetrics(this->font());
  unsigned int height_of_line= mm.lineSpacing();
  unsigned int max_height_in_lines= height_of_grid_widget / height_of_line;
  if ((max_height_in_lines * height_of_line) < (unsigned int) height_of_grid_widget) ++ max_height_in_lines;
  if ((is_resize == false)
   || (max_height_in_lines > result_grid_widget_max_height_in_lines))
  {
    result_grid_widget_max_height_in_lines= max_height_in_lines;
    if (result_set_copy != 0)  /* see fillup_garbage_collect() comment */
    {
      display(2, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      this->show(); /* Todo: I think this is not necessary */
    }
  }
}

/*
  We want to redo the display but are confident that font and size are not changing.
  So far the only times we call are for: mousePressEvent (which changes focus background color).
*/
void ResultGrid::color_change()
{
  display_html(grid_vertical_scroll_bar->value(), 0);
}

/*
  Set grid_max_column_height which is a permanently-available calculated maximum in pixels.
  We call this from from resize_or_font_change(), which should mean
  (a) we know that result grid size is current,
  (b) we know that result_grid_font may not be current but will be used in later paint jobs.
  We also call this when creating, but in that case result grid size is not really known
  and result_grid_font is still the parent's font.
  The rule should simply be that no single row + header row (which is one line)
  can exceed the size of the result grid, until we have a user-specified maximum.
  We use this in set_height(), where the idea is that you can't make a column higher
  than the maximum, so the cell will need a vertical scroll bar.
  Todo: In display, we set int result_grid_height= (parent->height() / 3) - 11;
        then   ocelot_grid_max_column_height_in_lines= result_grid_height / line_height;
        This supersedes those calculations so we can stop using them.
  Todo: Decide: Do we mean maximum for text_edit_widget or do we mean maximum for text_edit_frame?
  Todo: ocelot_grid_max_column_height_in_lines could be user-settable but overridable.
  Todo: It should be impossible to resize result grid to < 11 or < line size * 2, eh?
  Todo: Initially we call with result_grid_height == 0 but that is temporary.
  Todo: Make sure we call this whenever we change result_grid_font. Put the change in this function?
*/
void ResultGrid::set_grid_max_column_height_in_pixels(int result_grid_height)
{
  QFontMetrics mm= QFontMetrics(result_grid_font);
  int height_of_line= mm.lineSpacing();
  int new_height= result_grid_height - (height_of_line * 2);
  if (new_height < height_of_line) new_height= height_of_line;
  grid_max_column_height_in_pixels= new_height;
}


/*
  Resize of grid widget. This could be called from eventfilter instead.
  Warning: changes in statement widget can cause this to be invoked.
  Warning: result_grid_height is not stable or useful until after there's been a display.
*/
void ResultGrid::resizeEvent(QResizeEvent *event)
{
  result_grid_height_after_last_resize= event->size().height();
  result_grid_width_after_last_resize= event->size().width();
  if (result_grid_height_after_last_resize != event->oldSize().height())
  {
    resize_or_font_change(result_grid_height_after_last_resize, true);
  }
}


/*
  Called from eventfilter
  "    if (event->type() == QEvent::FontChange) return (result_grid_table_widget->fontchange_event());"
  Todo: happens but I guess it's not important, set_all_style_sheets() gets called for font change.
*/
int ResultGrid::fontchange_event()
{
//  QFont tmp_font=this->font();
//  put_widgets_in_layouts(&tmp_font);
  return 1;
}


/*
  Called from eventfilter
  "    if (event->type() == QEvent::Show) return (result_grid_table_widget->show_event());"
  This is the more appropriate place to decide about the vertical scroll bar because now height is known.
  Todo: catch QEvent::Resize() too!! (maybe this is obsolete, we have void resizeEvent() above.
*/
bool ResultGrid::show_event()
{
//  vertical_bar_show_as_needed();

  return false;           /* We want the show to happen so pass it on */
}


/*
  Called from eventfilter if and only if result_row_count > result_grid_widget_max_height_in_lines
  There is also an automatic show-as-needed scroll bar, which will come on if scrolling is inevitable for a smaller result set.
  But vertical_scroll_bar_event() is only for the non-automatic vertical scroll bar.
  Initially grid_vertical_scroll_bar_value == -1, it's checked so that we don't paint the initial display twice.
  Todo: Nothing happens if I click and hold, I have to click and release and hold.
  Some possible event types: 17 Show, 78 UpdateLater, 12 Paint, 5 MouseMove, 129 HoverMove, 110 ToolTip,
                             3 MouseButtonRelease, 18 Hide, 11 Leave, 25 WindowDeactivate, 128 HoverLeave
                             78 PolishRequest (todo: find out what this means)
                             But if we call display_html() we miss 1 Timer, 2 MouseButtonPress
  Todo: I don't see why is_fancy is needed since I guess is only around for html.
*/

bool ResultGrid::vertical_scroll_bar_event(QEvent *event, int connections_dbms)
{
  (void)connections_dbms;
  int new_value;
  /* It's impossible to get here if the scroll bar is hidden, but it happens. Well, maybe only for "turning it off" events. */
  if (grid_vertical_scroll_bar->isVisible() == false)
  {
    return false;
  }
  if (event->type() == QEvent::Show)
  {
    return false;
  }
  new_value= grid_vertical_scroll_bar->value();
  if (new_value != grid_vertical_scroll_bar_value)
  {
    /* Todo: See whether is_paintable is important for batch etc. */
    /* Eventually display_html() will replace everything */
//    if (grid_vertical_scroll_bar_value == -1) return false;
    if ((is_paintable != 1) || (grid_vertical_scroll_bar_value == -1))
    {
      grid_vertical_scroll_bar_value= new_value;
      return false;
    }
    if (is_fancy() == true) /* was: if (copy_of_ocelot_html == 1) */
    {
      display_html(new_value, 0);
      this->update();      /* not sure if we need to update both this and client, but it should be harmless*/
      client->update();
      grid_vertical_scroll_bar->update();
    }
    else
    {
#ifdef OLD_STUFF
      fill_detail_widgets(new_value, connections_dbms);
#endif
      this->update();      /* not sure if we need to update both this and client, but it should be harmless*/
      client->update();
    }
    grid_vertical_scroll_bar_value= new_value;
    /* TEST!!!! */
    return false;
  }
  return false;
}

/*
  Call when making the vertical bar scroll bar, which always happens when we make a ResultGrid.
  We'll call r->grid_vertical_scroll_bar->installEventFilter(this); from MainWindow.
  Todo: Anything special for destruct?
*/
void ResultGrid::vertical_scroll_bar_construct()
{
  grid_vertical_scroll_bar= new QScrollBar(this);
  grid_vertical_scroll_bar->setSingleStep(1);
  grid_vertical_scroll_bar->setPageStep(1);
  grid_vertical_scroll_bar->setMinimum(0);
  grid_vertical_scroll_bar->setMouseTracking(true);
}

/*
  Call when there is a new result set to display.
  We don't want setValue(0) to cause display_html() yet so we set grid_vertical_scroll_bar_value= -1;
*/
void ResultGrid::vertical_scroll_bar_initialize()
{
  if ((copy_of_ocelot_batch != 0)
   || (copy_of_ocelot_xml != 0)
   || (copy_of_ocelot_raw != 0))
  {
    grid_vertical_scroll_bar->hide();
    return;
  }
  grid_vertical_scroll_bar_value= -1;
  if (ocelot_vertical_copy == 0)
  {
    grid_vertical_scroll_bar->setMaximum(result_row_count - 1);
    if (result_row_count <= 1) grid_vertical_scroll_bar->hide();
    else grid_vertical_scroll_bar->show();
  }
  else
  {
    grid_vertical_scroll_bar->setMaximum(grid_result_row_count - 1);
    if (grid_result_row_count <= 1) grid_vertical_scroll_bar->hide();
    else grid_vertical_scroll_bar->show();
  }
  grid_vertical_scroll_bar->setValue(0);
}

#ifdef OLD_STUFF
/*
  If a result grid text_edit_widget is a number + not header, call with alignment_flag == Qt::AlighRight.
  Otherwise call with alignment_flag == Qt::AlignLeft.
  Do not assume it's left-aligned otherwise; there's a pool.
  Beware: if you only setAlignment, you lose wrapping, as a side effect of setDefaultTextOption (?)
  Todo: take into account whether it's a right-to-left character set like Arabic or Hebrew.
  Todo: check whether it's actually necessary to setAlignment for text_edit_widget too.
  Todo: check what happens to wrapping if it's a number, I read somewhere that's a problem.
  Todo: some other types e.g. BLOBs might also need special handling.
  Todo: user-settable option rather than WrapAnywhere.
  Todo: check that the effect is immediate, not deferred to the next time resultgrid comes up.
  ? For some reason this used to be:
    void text_align(QTextEdit *cell_text_edit_widget, enum Qt::AlignmentFlag alignment_flag)
*/
void ResultGrid::text_align(TextEditWidget *cell_text_edit_widget, enum Qt::AlignmentFlag alignment_flag)
{
  enum Qt::AlignmentFlag a;
  /* Following should only be needed for Tarantool/NoSQL or Tarantool/SQL scalar */
  /* But maybe we should do it for all Tarantool and for MySQL/MariaDB, it probably works */
  /* Override what was passed, we will depend on the cell's field_value_flags */
  if ((dbms_version_mask & FLAG_VERSION_TARANTOOL) != 0)
  {
    char field_value_flags= cell_text_edit_widget->text_edit_frame_of_cell->content_field_value_flags;
    if (field_value_flags == FIELD_VALUE_FLAG_IS_NUMBER) a= Qt::AlignRight;
    else a= Qt::AlignLeft;
  }
  else a= alignment_flag;
  QTextOption to;
  to.setAlignment(a);
  to.setWrapMode(QTextOption::WrapAnywhere);
  cell_text_edit_widget->document()->setDefaultTextOption(to);
  cell_text_edit_widget->setAlignment(a);
}
#endif

/*
  We'll do our own garbage collecting for non-Qt items.
  fillup_garbage_collect for anything made with "new " in fillup() or fillup() subsidiaries.
  display_garbage_collect for anything made with "new " in display() or display() subsidiaries.
  Todo: make sure Qt items have parents where possible so that "delete result_grid_table_widget"
        takes care of them.
  Why we clear() text_edit_widgets:
    If the text is big blobs, and you start with default i.e. ocelot_display_blob_as_image = false,
    then you switch to ocelot_display_blob_as_image = true,
    it is much slower then if you start with ocelot_display_blob_as_image = true.
    Clearing alleviates the problem.
    It would be faster to use max_table_edit_widgets_count not cell_pool_size but that crashes.
    Perhaps it would be better to clear only if current size > (some minimum)?
  Warning: we check if (result_set_copy == 0) to ensure there's a result.
*/
void ResultGrid::fillup_garbage_collect(bool is_final)
{
#if (OCELOT_EXPLORER == 1)
  if (is_final == false) assert(result_grid_type != EXPLORER_WIDGET);
#endif
  if (result_field_types != 0) { delete [] result_field_types; result_field_types= 0; }
  if (result_field_charsetnrs != 0) { delete [] result_field_charsetnrs; result_field_charsetnrs= 0; }
  if (result_field_flags != 0) { delete [] result_field_flags; result_field_flags= 0; }
  if (result_set_copy != 0) { delete [] result_set_copy; result_set_copy= 0; }
  if (result_set_copy_rows != 0) { delete [] result_set_copy_rows; result_set_copy_rows= 0; }
  if (result_field_names != 0) { delete [] result_field_names; result_field_names= 0; }
  if (result_original_field_names != 0) { delete [] result_original_field_names; result_original_field_names= 0; }
  if (result_original_table_names != 0) { delete [] result_original_table_names; result_original_table_names= 0; }
  if (result_original_database_names != 0) { delete [] result_original_database_names; result_original_database_names= 0; }
  if (result_max_column_widths != 0) { delete [] result_max_column_widths; result_max_column_widths= 0; }
}

void ResultGrid::display_garbage_collect(bool is_final)
{
#if (OCELOT_EXPLORER == 1)
  if (is_final == false) assert(result_grid_type != EXPLORER_WIDGET);
#endif
#if (OCELOT_CHART_OR_QCHART == 1)
  if (chart_widget != NULL) {
      delete chart_widget; chart_widget= NULL; }
#endif
  if (grid_column_widths != 0) { delete [] grid_column_widths; grid_column_widths= 0; }
  if (grid_column_heights != 0) { delete [] grid_column_heights; grid_column_heights= 0; }
  if (grid_column_dbms_sources != 0) { delete [] grid_column_dbms_sources; grid_column_dbms_sources= 0; }
  if (gridx_field_names != 0) { delete [] gridx_field_names; gridx_field_names= 0; }
  if (gridx_max_column_widths != 0) { delete [] gridx_max_column_widths; gridx_max_column_widths= 0; }
  if (gridx_result_indexes != 0) { delete [] gridx_result_indexes; gridx_result_indexes= 0; }
  if (gridx_flags != 0) { delete [] gridx_flags; gridx_flags= 0; }
  if (gridx_field_types != 0) { delete [] gridx_field_types; gridx_field_types= 0; }
  if (html_text_edit != NULL) delete html_text_edit;
  if (is_final == false) html_text_edit= new Result_qtextedit(this);
  if (batch_text_edit != NULL) delete batch_text_edit;
  if (is_final == false) batch_text_edit= new QTextEdit(this);
}

#ifdef OLD_STUFF
void ResultGrid::set_frame_color_setting()
{
  setting_ocelot_grid_cell_drag_line_size_as_int= copy_of_parent->ocelot_grid_cell_drag_line_size.toInt();
  ocelot_grid_cell_drag_line_color= copy_of_parent->ocelot_grid_cell_drag_line_color;
  frame_color_setting= "TextEditFrame{background-color: ";
  frame_color_setting.append(ocelot_grid_cell_drag_line_color);
  //frame_color_setting.append(";border: 0px");              /* TEST !! */
  frame_color_setting.append("}");
}
#endif

/*
  Setting the parent should affect the children.
  But we don't want all text_edit_frames and text_edit_widgets to change because that is slow.
  Let us set a flag which causes change at paint time. with setStyleSheet(copy_of_parent->ocelot_grid_header_style_string);
  This gets called just after we change colors + fonts with the dialog box, so we know
  the new style string, and to get its font we used to create a temporary QTextEdit,
  but nowadays we get font with a function that figures it out from the style sheet syntax.
*/
void ResultGrid::set_all_style_sheets(QString new_ocelot_grid_style_string,
                          QString new_ocelot_grid_cell_drag_line_size,
                          int caller,
                          bool is_result_grid_font_changed)
{
  (void)(new_ocelot_grid_cell_drag_line_size);
  if ((copy_of_ocelot_batch != 0)
#ifdef OLD_STUFF
   || (copy_of_ocelot_html != 0)
#endif
   || (copy_of_ocelot_xml != 0))
  {
    resize_or_font_change(this->height(), false);
    return;
  }
  result_grid_font= copy_of_parent->get_font_from_style_sheet(new_ocelot_grid_style_string);

  //unsigned int i_h;

  //setting_ocelot_grid_cell_drag_line_size_as_int= new_ocelot_grid_cell_drag_line_size.toInt();
  setting_ocelot_grid_cell_drag_line_size_as_int= 0;
  settings_change_calc();
#ifdef OLD_STUFF
  set_frame_color_setting();
  for (i_h= 0; i_h < cell_pool_size; ++i_h)
  {
    text_edit_frames[i_h]->is_style_sheet_set_flag= false;
    //text_edit_widgets[ki]->setMinimumWidth(fm.width("W") * MIN_WIDTH_IN_CHARS);
    //text_edit_widgets[ki]->setMinimumHeight(fm.height() * 2);
    /* todo: skip following line if setting_ocelot_grid_cell_drag_line_size_as_int did not change */
    text_edit_layouts[i_h]->setContentsMargins(QMargins(0, 0, setting_ocelot_grid_cell_drag_line_size_as_int, setting_ocelot_grid_cell_drag_line_size_as_int));
  }
#endif
  /* todo: is "caller" redundant? if it's 0, then font change is false? */
  /* todo: this shouldn't be just is_result_grid_font_changed, it should be any changed. */
  if ((caller == 1) && (is_result_grid_font_changed))
  {
    resize_or_font_change(this->height(), false);
  }
}

/*
  settings_change_calc()
  called from set_all_style_sheets()
  Calculate setting_max_width_of_a_char and setting_min_width_of_a_column.
  We should call this during initialization or settings change (of font or drag line or border).
  Assume settings apply for all grid columns so don't need to call for every column.
  width() is deprecated in Qt 5.13.
  Assume we know result_grid_font, setting_ocelot_grid_cell_border_size_as_int,
    setting_ocelot_grid_cell_drag_line_size_as_int, scroll_bar_width.
  The maximum width is based on boundingRect() since width() is deprecated in Qt 5.13.
  Choosing "W" is good enough for western alphabets, some Asian characters may be wider
  but in that case we will end up with a higher column see set_height().
  Assume there might be a vertical scroll bar, although perhaps it isn't possible if
  there is no drag line and no column could overflow the maximum number of lines.
  Do not increase if result_grid_fonts.italic()=true, that should be taken care of now.
  Return true if the results mean that repaint should occur (but I guess we ignore that now).
  Re bearing:
    width of 1 char * 3) - (width of 3 chars) = amount we'll add to column width
    abs(result_grid_font_metrics.leftBearing('W')) + abs(result_grid_font_metrics.rightBearing('W'))
    gives a similar result but for some reason it can be off, I trust boundingRect more.
    We no longer use horizontalAdvance.
    I'm no sure whether letterSpacing ever matters.
*/
void ResultGrid::settings_change_calc()
{
  setting_ocelot_grid_cell_drag_line_size_as_int= 0; /* This should always be 0, we'll soon get rid of it */
  setting_ocelot_grid_cell_width_as_int= copy_of_parent->ocelot_grid_cell_width.toInt();
  setting_ocelot_grid_cell_border_size_as_int= copy_of_parent->ocelot_grid_cell_border_size.toInt();

  QFontMetrics result_grid_font_metrics= QFontMetrics(result_grid_font);
  QRect r2_1= result_grid_font_metrics.boundingRect(
                                   0, /* int x = x coordinate within original rect */
                                   0, /* int y = y coordinate within original rect */
                                   2000, /* int width = r.width(), which we don't change */
                                   2000, /* int height = height, which is arbitrary big maximum */
                                   0, /* int flags = (see comments before start of this routine) */
                                   "W"); /* QString & text= cell contents */
  int setting_max_width_of_1_char_times_3= r2_1.width() * 3;
  QRect r2_3= result_grid_font_metrics.boundingRect(
                                   0, /* int x = x coordinate within original rect */
                                   0, /* int y = y coordinate within original rect */
                                   2000, /* int width = r.width(), which we don't change */
                                   2000, /* int height = height, which is arbitrary big maximum */
                                   0, /* int flags = (see comments before start of this routine) */
                                   "WWW"); /* QString & text= cell contents */
  int setting_max_width_of_3_chars= r2_3.width();
  setting_bearing= ((setting_max_width_of_1_char_times_3) - setting_max_width_of_3_chars) / 3;
  setting_max_width_of_a_char= (setting_max_width_of_3_chars - setting_bearing) / 3;
  if (setting_bearing > 0) ++setting_bearing;
  setting_min_width_of_a_column= character_count_to_pixel_count(1)
                         + scroll_bar_width + 1
                         + setting_ocelot_grid_cell_border_size_as_int * 2;
  return;

  /* The following calculations used to exist in grid_column_size_calc(). Are they obsolete? */
  //pointer_to_font= &result_grid_font;

  /* Calculate with rounding up because of inter-character spacing. */
  //QFontMetrics mm= QFontMetrics(*pointer_to_font);
  //setting_max_width_of_a_char= mm.width("WWWW") / 4;
  //if ((max_width_of_a_char * 4) < (unsigned int) mm.width("WWWW")) ++setting_max_width_of_a_char;

  /*
     For italic|oblique I sometimes need zero extra pixels, but I
     sometimes need an incredible number of extra pixels.
     abs(qfm.rightBearing('W')) + abs(qfm.leftBearing('W')) is not enough
     Todo: try again to reduce, meanwhile document: don't use italics.
  */
  //if (pointer_to_font->italic() == true)
  //{
  //  setting_max_width_of_a_char*= 2;
  //}

  /* (pointer_to_font->fixedPitch() always == false, I don't know why */
  //if (mm.width("WWWWWWWWWW") != mm.width("I- 1a!~:wX"))
  //{
  //  ++setting_max_width_of_a_char;
  //}
}

/*
  Call this whenever you want to calculate the width of a column.
*/
int ResultGrid::character_count_to_pixel_count(int character_count)
{
  return (character_count * setting_max_width_of_a_char) + setting_bearing;
}

///*
//  If (row height * result_row_count) > ResultGrid widget height) we need a vertical scroll bar.
//  Todo: I'm not sure whether this is adequate if there's a horizontal scroll bar.
//  Todo: I'm not sure whether this is adequate if there's a widget header.
//  Todo: I'm not sure whether the calculation should involve result_row_count  + 1 (to include the header).
//  Todo: Call this not only when show, but also if font change, column/row size change, resize.
//  Todo: Look for a bug! I noticed that vertical scroll bar was missing after a font change. Didn't repeat.
//*/
//void vertical_bar_show_as_needed()
//{
//  int h;
//
//  h= 0;
//  if (result_row_count > 1) h+= grid_height_of_highest_column_in_pixels * result_row_count;
//  if (h > height()) grid_vertical_scroll_bar->show();
//  else  grid_vertical_scroll_bar->hide();
//}

//unsigned int dbms_get_field_length(unsigned int column_number)
//{
//  QString s;
//  unsigned int dbms_field_number;
//
//  dbms_field_number= grid_column_dbms_field_numbers[column_number];
//  /* The defined length is mysql_fields[dbms_field_number].length. We prefer actual max length which usually is shorter. */
//  return gridx_max_column_widths[dbms_field_number];
//}


unsigned int ResultGrid::dbms_get_field_flag(unsigned int column_number, int connections_dbms)
{
  (void) connections_dbms; /* suppress "unused parameter" warning */
  return result_field_flags[column_number];
}

QString ResultGrid::dbms_get_field_name(unsigned int column_number, int connections_dbms)
{
  (void) connections_dbms; /* suppress "unused parameter" warning */
  char *result_field_names_pointer;
  unsigned int v_lengths;
  result_field_names_pointer= &result_field_names[0];
  for (unsigned int i= 0; i < column_number; ++i)
  {
    memcpy(&v_lengths, result_field_names_pointer, sizeof(unsigned int));
    result_field_names_pointer+= v_lengths + sizeof(unsigned int);
  }
  memcpy(&v_lengths, result_field_names_pointer, sizeof(unsigned int));
  result_field_names_pointer+= sizeof(unsigned int);
  return result_field_names_pointer;
}


unsigned int ResultGrid::dbms_get_field_name_length(unsigned int column_number, int connections_dbms)
{
  (void) connections_dbms; /* suppress "unused parameter" warning */
  char *result_field_names_pointer;
  unsigned int v_lengths;
  result_field_names_pointer= &result_field_names[0];
  for (unsigned int i= 0; i < column_number; ++i)
  {
    memcpy(&v_lengths, result_field_names_pointer, sizeof(unsigned int));
    result_field_names_pointer+= v_lengths + sizeof(unsigned int);
  }
  memcpy(&v_lengths, result_field_names_pointer, sizeof(unsigned int));
  return v_lengths;
}


//QString ResultGrid::dbms_get_field_value(int row_number, unsigned int column_number)
//{
//  QString s;
//  unsigned int dbms_field_number;
//
//  if (grid_column_dbms_sources[column_number] == DBMS_SOURCE_IS_MYSQL_FIELD)
//  {
//    dbms_field_number= grid_column_dbms_field_numbers[column_number];
//    return row[dbms_field_number];
//  }
//  if (grid_column_dbms_sources[column_number] == DBMS_SOURCE_IS_ROW_NUMBER)
//  {
//    s= QString::number(row_number);
//    return s;
//  }
//  return ""; /* to avoid "control reaches end of non-void function" warning */
//}

/*
  Deleting ResultGrid
  This probably will never be called explicitly, but if MainWindow parent is deleted when
  the program ends, we'll get here.
  Todo: check if above comment is still true now if we remove tabs
*/
ResultGrid::~ResultGrid()
{
  fillup_garbage_collect(true);
  display_garbage_collect(true);
}


/*
  If opd2 is inside 'quotes', then string comparison. Else int comparison.
  todo: when to exclude images?
  todo: it's variable when we'll see nulls
  todo: your idea of row number seems wrong, you're getting the display's row not the result set's row
  todo: remove this, it's all in ResultGrid now
*/
bool ResultGrid::comparer(
        QString opd1,
        QString opd2,
        QString opr,                /* = or >= or > or <= or < or <> or == or != or IS NULL or LIKE */
        char field_value_flags)     /* FIELD_VALUE_FLAG_IS_NULL FIELD_VALUE_FLAG_IS_IMAGE etc. */
{
  if ((field_value_flags & FIELD_VALUE_FLAG_IS_NULL) != 0)
  {
    return (opr == "IS");
  }
  if (opd2.mid(0, 1) == "'")
  {
    QString opd1_str= opd1.toUpper();
    QString opd2_str= opd2.mid(1, opd2.size() - 2).toUpper();
    if ((opr == "=") || (opr == "==")) return (opd1_str == opd2_str);
    if (opr == ">=") return (opd1_str >= opd2_str);
    if (opr == ">") return (opd1_str > opd2_str);
    if (opr == "<=") return (opd1_str <= opd2_str);
    if (opr == "<") return (opd1_str < opd2_str);
    if ((opr == "<>") || (opr == "!=")) return (opd1_str != opd2_str);
#if (QT_VERSION >= 0x50000)
    if (opr == "REGEXP")
    {
      QRegularExpression re(opd2_str);
      QRegularExpressionMatch match= re.match(opd1_str);
      return match.hasMatch();
    }
#endif
    return false;
  }
  else
  {
    int opd1_int= opd1.toInt();
    int opd2_int= opd2.toInt();
    if ((opr == "=") || (opr == "==")) return (opd1_int == opd2_int);
    if (opr == ">=") return (opd1_int >= opd2_int);
    if (opr == ">") return (opd1_int > opd2_int);
    if (opr == "<=") return (opd1_int <= opd2_int);
    if (opr == "<") return (opd1_int < opd2_int);
    if ((opr == "<>") || (opr == "!=")) return (opd1_int != opd2_int);
    return false;
  }
  return false;
}


/*
  Usually use the style sheet default or style sheet from SET statements, which may be conditional.
  Note: If there are conditions then we aren't checking is_style_sheet_set_flag,
        we are checking whether background color is different after evaluating the condition.
        This seems to avoid earlier bugs but it's checking conditions more often than necessary.
        Maybe speed up by doing something clever with is_retrieved_flag.
        Maybe speed up by making canonical version with fixed lengths so there's no need to call tokenize.
  Row number should mean result row number, same as grid row number unless scroll bar value > 0.
  Column number should mean result column number, same as grid column number unless vertical=1.
  Todo: We clear conditional_settings before inserting, so temporarily there can't be more than one.
  Todo: Call SELECT * FROM "_vindex"; then call it again. Second time, there are calls to setStyleSheet(). Why?
  Todo: You are splitting into separate statements if there are carriage returns, as is typical with SET.
         It's somewhere in get_next_statement_in_string().
  Todo: Allow viewing conditional statements
  Todo: Allow clearing all conditional statements
  Todo: Allow setup of conditional statements in Settings menu
  Todo: SET ocelot_grid_background_color='blue', ocelot_grid_color='red' WHERE row = 5 AND column_name REGEX 'x';
  Todo: More comparands e.g. COLUMN_TYPE = 'binary'.
  Todo: font-family might have [foundry] in brackets, it should be in ''s, though I didn't notice a problem
  Todo: I see that we're calling this frequently unnecessarily, maybe due to internal requests.
*/
//#define MAX_CONDITIONAL_STATEMENT_TOKENS 100 /* todo: this is a duplicate of what's defined in MainWindow */
bool ResultGrid::conditional_setting_evaluate(int cs_number,
                                  int cs_column_number,           /* e.g. text_frame->ancestor_grid_column_number */
                                  int cs_result_row_number,       /* e.g. text_frame->ancestor_grid_result_row_number */
                                  char *cs_content_pointer,       /* e.g. text_frame->content_pointer */
                                  char cs_content_flags,
                                  unsigned int cs_content_length, /* e.g. text_frame->content_length */
                                  unsigned short int cs_cell_type,  /* e.g. text_frame->cell_type */
                                  QString old_style_sheet,
                                  bool is_always_true,
                                  QString *cs_new_tooltip,        /* return */
                                  QString *cs_new_style_sheet,    /* return */
                                  QString *cs_new_cell_height,    /* return */
                                  QString *cs_new_cell_width,     /* return */
                                  QString *cs_new_action,         /* return */
                                  QString *cs_new_enabled,        /* return */
                                  QString *cs_new_shortcut,       /* return */
                                  QString *cs_new_text,           /* return */
                                  ResultGrid* upper_rg)
{
  copy_of_parent->log("conditional_setting_evaluate", 15);
  if (cs_cell_type != TEXTEDITFRAME_CELL_TYPE_DETAIL) return false; /* Temporary till we handle headers */
  ResultGrid *rg= this;
  if (upper_rg != NULL)
  {
    rg= upper_rg; /* because I don't understand how "this" works */
  }

  MainWindow *mw= rg->copy_of_parent;
  if (mw->conditional_settings.count() <= cs_number) return false; /* unnecessary */
  {
    int token_offsets[MAX_CONDITIONAL_STATEMENT_TOKENS];
    int token_lengths[MAX_CONDITIONAL_STATEMENT_TOKENS];
    int i= cs_number;
    {
      QString text= mw->conditional_settings.at(i);
      mw->tokenize(text.data(),
               text.size(),
               &token_lengths[0], &token_offsets[0], MAX_CONDITIONAL_STATEMENT_TOKENS - 1,
              (QChar*)"33333", 2, "", 1);
      int token_index= 4; /* We're sure that WHERE comes after SET ocelot_grid_background|text_color='...' */
      while ((token_lengths[token_index] != 5) || (text.mid(token_offsets[token_index], 5) != "WHERE")) ++token_index;
      bool result;
      if (is_always_true == true)
      {
        result= true;
      }
      else
      {
        result= false;
        QString next_clause_start= "WHERE";
        bool is_skippable= false;
        for (;;)
        {
          if ((next_clause_start == "AND") && (result == false)) is_skippable= true;
          else if ((next_clause_start == "OR") && (result == true)) is_skippable= true;
          else is_skippable= false;
          QString target= text.mid(token_offsets[token_index + 1], token_lengths[token_index + 1]);
          QString opr= text.mid(token_offsets[token_index + 2], token_lengths[token_index + 2]);
          QString value= text.mid(token_offsets[token_index + 3], token_lengths[token_index + 3]);
          next_clause_start= text.mid(token_offsets[token_index + 4], token_lengths[token_index + 4]);
          if (is_skippable == false)
          {
            if (target == "COLUMN_NAME")
            {
              char *result_field_names_pointer= &rg->result_field_names[0];
              unsigned int v_length;
              for (unsigned int i= 0; i < rg->result_column_count; ++i)
              {
                memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
                result_field_names_pointer+= sizeof(unsigned int);
                if (i == (unsigned int) cs_column_number)
                {
                  QString s= QString(QByteArray(result_field_names_pointer, v_length));
                  result= comparer(s, value, opr, 0);
                  break;
                }
                result_field_names_pointer+= v_length;
              }
            }
            if (target == "COLUMN_NUMBER")
            {
              result= comparer(QString::number(cs_column_number + 1), value, opr, 0);
            }
            if (target == "COLUMN_TYPE")
            {
              int a= cs_column_number;
              char *b= mw->typer_to_keyword(rg->result_field_types[a]);
              result= comparer(b, value, opr, 0);
            }
            if (target == "ROW_NUMBER")
            {
              int crn= cs_result_row_number;
              if (ocelot_result_grid_column_names_copy == 1) ++crn;
              result= comparer(QString::number(crn), value, opr, 0);
            }
            if (target == "VALUE")
            {
              {
                QString s= QString(QByteArray(cs_content_pointer, cs_content_length));
                /* passing text_frame->content_field_value_flags didn't seem to be working consistently */
                /* but *(text_frame->content_pointer + text_frame->content_length) causes crashing */
                result= comparer(s, value, opr, cs_content_flags);
              }
            }
          }
          if (next_clause_start == ";") break;
          token_index= token_index + 4; /* it's AND | OR, continue, but next condition might be skippable */
          continue;
        }
      }
      QString new_style_sheet= old_style_sheet;
      if (result == true)
      {
        for (int target_index= 1;; target_index+= 4)
        {
          int k;
          QString setting_value= text.mid(token_offsets[target_index + 2], token_lengths[target_index + 2]);
          if (setting_value.mid(0, 1) == "'") setting_value= setting_value.mid(1, setting_value.size() - 2);
          QString setting= text.mid(token_offsets[target_index], token_lengths[target_index]);
          if (setting.contains("_BACKGROUND_COLOR")) k= new_style_sheet.indexOf("background-color:") + 17;
          else if (setting.contains("_TEXT_COLOR")) k= new_style_sheet.indexOf("color:") + 6;
          else if (setting.contains("_FONT_SIZE"))
          {
            k= new_style_sheet.indexOf("font-size:") + 10;
            setting_value= setting_value + "pt";
          }
//          else if (setting == "OCELOT_GRID_FOCUS_CELL_BACKGROUND_COLOR") /* Todo: Don't do this */
//          {
//            k= new_style_sheet.indexOf("border:") + 7;
//            k= new_style_sheet.indexOf(" ", k) + 1;
//            k= new_style_sheet.indexOf(" ", k) + 1;
//          }
          else if (setting.contains("_FONT_STYLE")) k= new_style_sheet.indexOf("font-style:") + 11;
          else if (setting.contains("_FONT_WEIGHT")) k= new_style_sheet.indexOf("font-weight:") + 12;
          else if (setting.contains("_FONT_FAMILY")) k= new_style_sheet.indexOf("font-family:") + 12;
//          else if (setting.contains("_BORDER_SIZE")) /* now we only use ocelot_grid_cell_border_size */
//          {
//            k= new_style_sheet.indexOf("border:") + 7;
//            setting_value= setting_value + "px";
//          }
          else if (setting.contains("_TOOLTIP"))
          {
            *cs_new_tooltip= setting_value; /* caller can say setTooltip */
            continue;
          }
          else if (setting == "OCELOT_GRID_CELL_HEIGHT")
          {
            *cs_new_cell_height= setting_value; /* caller can change */
            continue;
          }
          else if (setting == "OCELOT_GRID_CELL_WIDTH")
          {
            *cs_new_cell_width= setting_value; /* caller can change */
            continue;
          }

          else if (setting == "OCELOT_EXPLORER_ACTION")
          {
            *cs_new_action= setting_value; /* caller can change */
            continue;
          }
          else if (setting == "OCELOT_EXPLORER_ENABLED")
          {
            *cs_new_enabled= setting_value; /* caller can change */
            continue;
          }
          else if (setting == "OCELOT_EXPLORER_SHORTCUT")
          {
            *cs_new_shortcut= setting_value; /* caller can change */
            continue;
          }
          else if (setting == "OCELOT_EXPLORER_TEXT")
          {
            *cs_new_text= setting_value; /* caller can change */
            continue;
          }
#if (OCELOT_CHART_OR_QCHART == 1)
          else if (setting == "OCELOT_GRID_CHART")
          {
            *cs_new_text= setting_value; /* caller can change */
            continue;
          }
#endif
          else break;
          int l;
//          if (setting == "OCELOT_GRID_BORDER_SIZE") l= new_style_sheet.indexOf(" ", k + 1);
//          else
            l= new_style_sheet.indexOf(";", k + 1);
          if (l == -1) l= new_style_sheet.size();
          new_style_sheet.replace(k, l - k, setting_value);
        }
        *cs_new_style_sheet= new_style_sheet; /* caller can say setstylesheet */
        return true; /* We only have evaluated one condition! But caller might call again. */
      }
      else
      {
        ;
      }
    }
  }
  return false;
}

/* Evaluate conditional settings until one is true (return true), or none are true (return false) */
/* If not HTML we could continue after true and pass result style string to the next iteration. But, no. */
bool ResultGrid::conditional_setting_evaluate_till_true(
                                  int cs_column_number,           /* i.e. result set column number */
                                  int cs_result_row_number,       /* e.g. text_frame->ancestor_grid_result_row_number */
                                  char *cs_content_pointer,       /* e.g. text_frame->content_pointer */
                                  char cs_content_flags,          /* e.g. FIELD_VALUE_FLAG_IS_NULL */
                                  unsigned int cs_content_length, /* e.g. text_frame->content_length */
                                  unsigned short int cs_cell_type,  /* e.g. text_frame->cell_type */
                                  QString *cs_new_tooltip,        /* return */
                                  QString *cs_new_style_sheet,    /* return */
                                  QString *cs_new_cell_height,    /* return */
                                  QString *cs_new_cell_width,     /* return */
                                  int *returned_cs_number,
                                  QString *cs_new_text,           /* return */
                                  ResultGrid *upper_rg)           /* NULL unless we call from Chart */
{
  ResultGrid *rg= this;
  if (upper_rg != NULL) rg= upper_rg; /* because I don't understand how "this" works */
  MainWindow *mw= rg->copy_of_parent;
  QString old_style_sheet;
#if (OCELOT_EXPLORER == 1)
  if (result_grid_type == EXPLORER_WIDGET)
    old_style_sheet= mw->ocelot_explorer_style_string;
  else
#endif
    old_style_sheet= mw->ocelot_grid_style_string;
  bool result;
  for (int i= 0; i < mw->conditional_settings.count(); ++i)
  {
    QString cs_new_action, cs_new_enabled, cs_new_shortcut;
    result= conditional_setting_evaluate(i,
    cs_column_number,           /* e.g. text_frame->ancestor_grid_column_number */
    cs_result_row_number,              /* e.g. text_frame->ancestor_grid_result_row_number */
    cs_content_pointer,       /* e.g. text_frame->content_pointer */
    cs_content_flags,
    cs_content_length, /* e.g. text_frame->content_length */
    cs_cell_type,  /* e.g. text_frame->cell_type */
    old_style_sheet,
    false,
    cs_new_tooltip,        /* return */
    cs_new_style_sheet,    /* return */
    cs_new_cell_height,    /* return */
    cs_new_cell_width,     /* return */
    &cs_new_action,
    &cs_new_enabled,
    &cs_new_shortcut,
    cs_new_text,
    upper_rg);
    if (result == true)
    {
      *returned_cs_number= i;
      return true;
    }
  }
  *returned_cs_number= -1;
  return false;
}

#if (OCELOT_CHART_OR_QCHART == 1)
bool ResultGrid::evaluate_for_chart(bool is_mainwindow_calling)
{
  bool is_chartable= false;
  if (copy_of_parent->ocelot_grid_chart > "") is_chartable= true;
  else
  {
    for (int i= 0; i < copy_of_parent->conditional_settings.count(); ++i)
    {
      if (copy_of_parent->conditional_settings.at(i).left(22) == "SET OCELOT_GRID_CHART ")
      {
        is_chartable= true;
        break;
      }
    }
  }
  if (is_mainwindow_calling) return is_chartable; /* to help decide whether is_repeated_needed should become true */
  if (is_chartable == true)
  {
    int chart_type= TOKEN_KEYWORD_BAR; /* todo: we won't need to pass chart_type */
#if (OCELOT_CHART == 1)
    chart_widget= new Chart(this, copy_of_parent, chart_type);
#else
    chart_widget= new QChart(this, copy_of_parent, chart_type);
#endif
    if (chart_widget->chart_chartable_columns_count == 0)
    {
      delete chart_widget; chart_widget= NULL;
      is_chartable= false;
    }
  }
  return is_chartable;
}
#endif

/******************** ResultGrid end ***********************************************/

/******************** ERDiagram start ***********************************************/

#if (OCELOT_ERDIAGRAM == 1)

/* Put general comments about ERDiagram in ocelotgui.h after words THE ERDIAGRAM WIDGET. */

/* Todo: maybe merge this with ERDiagram ... but no I guess it has to be within scroll area */ /* constructor */
erd::erd(ERDiagram *parent_erdiagram, MainWindow *parent_mainwindow, QString passed_schema_name, QString passed_query)
    : QWidget(parent_erdiagram)
{
  erd_relations= NULL; /* because in ~erd() we don't want delete if e.g. we created nothing for empty schema */
  erd_tables= NULL;
  resize(100, 100); /* initial, there will be another resize after we find erd_table sizes */
  erd_erdiagram= parent_erdiagram;
  erd_mainwindow= parent_mainwindow;
  erd_schema_name= passed_schema_name;
  erd_query= passed_query;
  erd_mainwindow->tokenize(erd_query.data(),
           erd_query.size(),
           &erd_token_lengths[0], &erd_token_offsets[0], 1000 - 1,
          (QChar*)"33333", 2, "", 1);
  default_settings_erd();
  default_settings_erdiagram();
  setMouseTracking(true); /* maybe */
}

/*
  Set default fonts and colours based on grid settings.
  Also set table rectangles for use by draw_table() during paintEvent.
*/
void erd::default_settings_erd()
{
  {
    QPalette p= QPalette();
    p.setColor(QPalette::Window, erd_mainwindow->ocelot_grid_background_color);
    setAutoFillBackground(true); /* is this necessary, or is it default? */
    setPalette(p);
  }
  set_color_palette();
  erd_default_font= erd_mainwindow->get_font_from_style_sheet(erd_mainwindow->ocelot_grid_style_string);
  setFont(erd_default_font); /* might be overridden by a grid conditional */
  QFontMetrics fm= QFontMetrics(erd_default_font);
  erd_default_text_color= erd_mainwindow->qt_color(erd_mainwindow->ocelot_grid_text_color);
  erd_default_header_background_color= erd_mainwindow->qt_color(erd_mainwindow->ocelot_grid_header_background_color);
  erd_default_detail_background_color= erd_mainwindow->qt_color(erd_mainwindow->ocelot_grid_background_color);
  erd_default_container_pen_width= erd_mainwindow->ocelot_grid_cell_border_size.toInt();
  if (erd_default_container_pen_width < 1) erd_default_container_pen_width= 1;
  erd_default_container_pen.setColor(erd_mainwindow->qt_color(erd_mainwindow->ocelot_grid_cell_border_color));
  erd_default_container_pen.setWidth(erd_default_container_pen_width);
  erd_default_header_brush.setStyle(Qt::SolidPattern);
  erd_default_header_brush.setColor(erd_default_header_background_color);
  erd_default_detail_brush.setStyle(Qt::SolidPattern);
  erd_default_detail_brush.setColor(erd_default_detail_background_color);
  erd_default_text_pen.setColor(erd_default_text_color);
  erd_default_mark_length= erd_default_container_pen_width * MARK_MULTIPLIER;
  int w_width= fm.boundingRect("W").width();
  erd_default_mark_length= w_width * erd_default_container_pen_width;
  erd_default_space_between_rects= erd_default_mark_length * 3 + w_width;
}

void erd::default_settings_erdiagram()
{
  /* A bit of "parsing" if non-default options. We haven't called tokens_to_keywords. */
  erd_is_lines_in_background= false;
  erd_is_primary= false;
  for (int i_of_token= 0;; ++i_of_token)
  {
    if (erd_token_lengths[i_of_token] == 0) break;
    QString token= erd_query.mid(erd_token_offsets[i_of_token], erd_token_lengths[i_of_token]);
    if (token == "(") break;
    if (QString::compare(token, "BACKGROUND", Qt::CaseInsensitive) == 0) erd_is_lines_in_background= true;
    if (QString::compare(token, "PRIMARY", Qt::CaseInsensitive) == 0) erd_is_primary= true;
  }

  /* Fill erd_tables[]. table_items must be set up based on count of tables. Destroy when done. */
  fill_tables();

  /* Following allocation is much more than necessary. erd_relations_count will be all we really need. */
  erd_relations= new relation_items[erd_mainwindow->oei_fk_count];
  erd_relations_count= 0;

  for (unsigned int i= 0; i < erd_mainwindow->oei_fk_count; ++i)
  {
    if (QString::compare(erd_mainwindow->oei_fk[i].schema_name, erd_schema_name, Qt::CaseInsensitive) != 0) continue;
    if (erd_mainwindow->oei_fk[i].ordinal_position != "1") continue;
    if (erd_mainwindow->oei_fk[i].referenced_table_name > "")
    {
      int i_of_referenced_table= -1;
      int i_of_referencing_table= -1;
      for (int j= 0; j < erd_tables_count; ++j)
      {
        unsigned int k= erd_tables[j].i_of_oei;
        QString t= erd_mainwindow->oei[k].object_name;
        if (t == erd_mainwindow->oei_fk[i].referenced_table_name)
        {
          i_of_referenced_table= j;
          break;
        }
      }
      for (int j= 0; j < erd_tables_count; ++j)
      {
        unsigned int k= erd_tables[j].i_of_oei;
        QString t= erd_mainwindow->oei[k].object_name;
        if (t == erd_mainwindow->oei_fk[i].table_name)
        {
          i_of_referencing_table= j;
          break;
        }
      }

      if ((i_of_referenced_table != -1) && (i_of_referencing_table != -1))
      {
        erd_relations[erd_relations_count].i_of_explorer_items_fk= i;
        erd_relations[erd_relations_count].done= false;
        erd_relations[erd_relations_count].i_of_referenced_table= i_of_referenced_table;
        erd_relations[erd_relations_count++].i_of_referencing_table= i_of_referencing_table;
      }
    }
  }

  /*
     Todo: Try doing each "cluster" separately, i.e. when you've gone through all related to #1, do for #2
           (that's an alternative if sorting doesn't look nice)
     Todo: maybe -1 isn't possible, if it isn't then don't bother to check for it
     Todo: if I add "if (erd_tables[t].references_count >= N) continue;" where N is between 1 and 5, I get
           interestingly-different results which aren't much worse. So maybe allow users to specify N?
  */
  /* Now references_count is really an indicator of "priority" = count*max + t */
  for (int i= 0; i < erd_relations_count; ++i)
  {
    int t= erd_relations[i].i_of_referenced_table;
    if (t != -1) erd_tables[t].references_count+= 1;
    t= erd_relations[i].i_of_referencing_table;
    if (t != -1) erd_tables[t].references_count+= 1;
  }
  /* Put each related table in an available rect */
  for (int i= 0; i < erd_tables_count; ++i)
  {
    if (erd_tables[i].is_fixed == false)
      erd_tables[i].erd_rect= QRect(-1, -1, erd_tables[i].erd_rect.width(), erd_tables[i].erd_rect.height());
  }
  QRect last_rect= QRect(erd_midpoint, erd_midpoint, 1, 1);
  /* Following is temporary, just trying to get relative positions established, so only looking at x,y. */
  /* Declare each rect to be deep in a big area */
  /* Eventually there will be recursion! */
  /* Initially every rect has x,y = -1, -1. */
  {
    int last_most_references= 999999;
    for (;;)
    {
      int most_references= 0;
      for (int i= 0; i < erd_tables_count; ++i)
      {
        if ((erd_tables[i].references_count > most_references)
         && (erd_tables[i].references_count <= last_most_references))
        {
          most_references= erd_tables[i].references_count;
        }
      }
      if (most_references == 0) break;
      for (int i= 0; i < erd_relations_count; ++i)
      {
        if (erd_relations[i].done == false)
        {
          if ((erd_tables[erd_relations[i].i_of_referencing_table].references_count == most_references)
           || (erd_tables[erd_relations[i].i_of_referenced_table].references_count == most_references))
          {
            {
              int t1= erd_relations[i].i_of_referencing_table;
              int t2= erd_relations[i].i_of_referenced_table;
              int t_main;
              if ((erd_tables[t1].erd_rect.y() == -1) || (erd_tables[t2].erd_rect.y() == -1))
              {
                if ((erd_tables[t1].erd_rect.y() != -1) && (erd_tables[t2].erd_rect.y() == -1)) t_main= t2;
                else if ((erd_tables[t1].erd_rect.y() == -1) && (erd_tables[t2].erd_rect.y() != -1)) t_main= t1;
                else if (erd_tables[t1].references_count > erd_tables[t2].references_count) t_main= t1;
                else t_main= t2;
                if (erd_tables[t_main].is_fixed == true)
                {
                  last_rect= erd_tables[t_main].erd_rect;
                }
                else last_rect= place_table_and_connected_tables(last_rect, t_main); /* recursive */
              }
            }
            erd_relations[i].done= true;
          }
        }
      }
      last_most_references= most_references - 1;
    }
  }
  bend_count_main();
//  /* Get the limits of the whole set of rects in existing area */
  int lowest_x= erd_midpoint; int lowest_y= erd_midpoint; int highest_x= erd_midpoint; int highest_y= erd_midpoint;
  for (int i= 0; i < erd_tables_count; ++i)
  {
    if (erd_tables[i].erd_rect.x() != -1)
    {
      if (erd_tables[i].erd_rect.x() < lowest_x) lowest_x= erd_tables[i].erd_rect.x();
      if (erd_tables[i].erd_rect.x() > highest_x) highest_x= erd_tables[i].erd_rect.x();
    }
    if (erd_tables[i].erd_rect.y() != -1)
    {
      if (erd_tables[i].erd_rect.y() < lowest_y) lowest_y= erd_tables[i].erd_rect.y();
      if (erd_tables[i].erd_rect.y() > highest_y) highest_y= erd_tables[i].erd_rect.y();
    }
  }
//  /* For tables with no relations, try to fill gaps in existing area */
//  /* Todo: if you fail once, you always will, so do some skipping */
//  /* Todo: start by finding and counting available gaps */
//  /* Todo: don't try anything special, just next_available_rect() */
//  for (int i= 0; i < erd_tables_count; ++i)
//  {
//      if (erd_tables[i].erd_rect.y() == -1)
//    {
//      bool is_breaker= false;
//      for (int a_x= lowest_x; a_x <= highest_x; ++a_x)
//      {
//        if (is_breaker == true) break;
//        for (int a_y= lowest_y; a_y <= highest_y; ++a_y)
//        {
//          if (is_breaker == true) break;
//          if (is_available_rect(a_x, a_y) == true)
//          {
//            erd_tables[i].erd_rect= QRect(a_x, a_y, erd_tables[i].erd_rect.width(), erd_tables[i].erd_rect.height());
//            is_breaker= true;
//          }
//        }
//      }
//    }
//  }

  for (int i= 0; i < erd_tables_count; ++i)
  {
    if (erd_tables[i].erd_rect.y() == -1)
    {
      last_rect= QRect(erd_midpoint, erd_midpoint, 1, 1);
      QRect new_rect= next_available_rect_3(last_rect, erd_tables[i].erd_rect, i);
      erd_tables[i].erd_rect= new_rect;
      last_rect= erd_tables[i].erd_rect;
    }
  }
/* Get the limits of the whole set of rects in existing area */
/* Todo: Now this is in the wrong place, and duplicated. */
  lowest_x= erd_midpoint; lowest_y= erd_midpoint; highest_x= erd_midpoint; highest_y= erd_midpoint;
  for (int i= 0; i < erd_tables_count; ++i)
  {
    if (erd_tables[i].erd_rect.x() != -1)
    {
      if (erd_tables[i].erd_rect.x() < lowest_x) lowest_x= erd_tables[i].erd_rect.x();
      if (erd_tables[i].erd_rect.x() > highest_x) highest_x= erd_tables[i].erd_rect.x();
    }
    if (erd_tables[i].erd_rect.y() != -1)
    {
      if (erd_tables[i].erd_rect.y() < lowest_y) lowest_y= erd_tables[i].erd_rect.y();
      if (erd_tables[i].erd_rect.y() > highest_y) highest_y= erd_tables[i].erd_rect.y();
    }
  }
  /* Subtract the lowest x and the lowest y from all rects. */
  {
    for (int i= 0; i < erd_tables_count; ++i)
    {
      QRect new_rect=
              QRect(erd_tables[i].erd_rect.x() - lowest_x, erd_tables[i].erd_rect.y() - lowest_y,
                    erd_tables[i].erd_rect.width(), erd_tables[i].erd_rect.height());
      erd_tables[i].erd_rect= new_rect;
    }
  }
#ifdef PACKED
  set_table_rects(highest_x - lowest_x, highest_y - lowest_y); /* sizes and positions */
#else
  set_table_rects();
#endif
  set_lines();

  /* resize to affect scroll area. might resize the widget. */
  /* todo: we should allow for is width of a line mark if line is at edge but simply saying "+ n" won't do */
  {
    int x_plus_w= 0;
    int y_plus_h= 0;
    for (int i= 0; i < erd_tables_count; ++i)
    {
      int x_plus_w_candidate= erd_tables[i].erd_rect.x() + erd_tables[i].erd_rect.width();
      if (x_plus_w_candidate > x_plus_w) x_plus_w= x_plus_w_candidate;
      int y_plus_h_candidate= erd_tables[i].erd_rect.y() + erd_tables[i].erd_rect.height();
      if (y_plus_h_candidate > y_plus_h) y_plus_h= y_plus_h_candidate;
    }
    resize(x_plus_w + erd_default_container_pen_width, y_plus_h + erd_default_container_pen_width);
  }
}

/*
  We want lines to have different colors so we rotate among the basic colors.
  But exclude RGB values which are close to background RGB, +- 64 (64 is arbitrary but silver=grey).
  Todo: would it be smarter to use one of Qt's 20 predefined color constants?
  Todo: I think the sizing [16][16] is some sort of mistake.
  Todo: Maybe if you just compared total(red+green+blue) to total(red+green+blue) it would work too.
*/
void erd::set_color_palette()
{
  const char *palette[]= {
    "#000000", /* black */
    "#FFFFFF", /* white */
    "#FF0000", /* red */
    "#00FF00", /* lime */
    "#0000FF", /* blue */
    "#FFFF00", /* yellow */
    "#00FFFF", /* cyan | aqua */
    "#FF00FF", /* magenta | fuchsia */
    "#C0C0C0", /* silver */
    "#808080", /* gray */
    "#800000", /* maroon */
    "#808000", /* olive */
    "#008000", /* green */
    "#800080", /* purple */
    "#008080", /* teal */
    "#000080", /* navy */ };
  QColor bcolor, ccolor;
  char color_utf8[80];
  strcpy(color_utf8, erd_mainwindow->ocelot_grid_background_color.toUtf8());
  bcolor= QColor(color_utf8);
  erd_color_palette_count= 0;
  for (int i= 0; i < 16; ++i)
  {
    ccolor= QColor(palette[i]);
    if ((ccolor.red() >= bcolor.red() - 64) && (ccolor.red() <= bcolor.red() + 64))
    {
      if ((ccolor.blue() >= bcolor.blue() - 64) && (ccolor.blue() <= bcolor.blue() + 64))
      {
        if ((ccolor.green() >= bcolor.green() - 64) && (ccolor.green() <= bcolor.green() + 64))
        {
          continue; /* too close */
        }
      }
    }
    strcpy(erd_color_palette[erd_color_palette_count++], palette[i]);
  }
}

/*
  Place table t in next available rect, relative to "last"
  First we place t
  Then we place whatever is directly connected to t, thus circling it if there multiple connections
  Then we go RECURSIVE! for whatever is directly connected to t
  Todo: "100" is rather arbitrary, eh? Saying "= new" could be better but could be slow due to the recursions.
        The later comparison "offset < 50" is similarly arbitrary.
*/
QRect erd::place_table_and_connected_tables(QRect last_rect, int t)
{
//  unsigned int k= erd_tables[t].i_of_oei;
//QString object_name= erd_mainwindow->oei[k].object_name;
  int new_t_list[100];
  int new_t_count= 0;

  QRect new_last_rect;
  if (erd_tables[t].erd_rect.y() != -1) new_last_rect= erd_tables[t].erd_rect;
  else
  {
    new_last_rect= next_available_rect(last_rect, erd_tables[t].erd_rect, t);
    erd_tables[t].erd_rect= new_last_rect;
  }
  int new_t;
  for (int i= 0; i < erd_relations_count; ++i)
  {
    if (erd_relations[i].i_of_referenced_table == t) new_t= erd_relations[i].i_of_referencing_table;
    else if (erd_relations[i].i_of_referencing_table == t) new_t= erd_relations[i].i_of_referenced_table;
    else continue;
    if (erd_tables[new_t].erd_rect.y() != -1) continue; /* already done this one */
    new_t_list[new_t_count]= new_t;
    ++new_t_count;
  }
  /* Bubble sort so preference is the next one with most connections. Not a good bubble sort. */
  for (int i= 0; i < new_t_count - 1; ++i)
  {
    for (int j= 0; j < new_t_count - 1; ++j)
    {
      int t1= new_t_list[j];
      int t2= new_t_list[j + 1];
      if (erd_tables[t1].references_count < erd_tables[t2].references_count)
      {
        new_t_list[j + 1]= t1;
        new_t_list[j]= t2;
      }
    }
  }
  /* The immediately-adjacent connections. Todo: assert if somehow next_available_rect() fails? */
  for (int i= 0; i < new_t_count; ++i)
  {
    int new_t= new_t_list[i];
    QRect close_last_rect= next_available_rect(new_last_rect, erd_tables[new_t].erd_rect, t);
    erd_tables[new_t].erd_rect= close_last_rect;
  }

  /* The adjacent of the adjacent connections */
  QRect close_last_rect= new_last_rect;
  for (int i= 0; i < new_t_count; ++i)
  {
    new_t= new_t_list[i];
    place_table_and_connected_tables(close_last_rect, new_t);
    close_last_rect= erd_tables[new_t].erd_rect;
  }
  return new_last_rect;
}

/*
  We try 4 points E W N S, then 4 points NE NW SE SW immediately beside x,y and then greater distances.
  I compared with the different method in next_available_rect_3, for sakila this method looked nicer.
  The number 50 is arbitrary, I just can't believe we'd go that far away from centre unless it's a bug.
*/
QRect erd::next_available_rect(QRect last_rect, QRect this_rect, int t)
{
  int x= 0;
  int y= 0;
  int directions[4];
  if ((t%4) == 0) {directions[0]= 1; directions[1]= 2; directions[2]= 3; directions[3]= 4; }
  if ((t%4) == 1) {directions[0]= 2; directions[1]= 3; directions[2]= 4; directions[3]= 1; }
  if ((t%4) == 2) {directions[0]= 3; directions[1]= 4; directions[2]= 1; directions[3]= 2; }
  if ((t%4) == 3) {directions[0]= 4; directions[1]= 1; directions[2]= 2; directions[3]= 3; }
  int offset;
  for (offset= 1; offset < 50; ++offset)
  {
    for (int k= 0; k < 4; ++k)
    {
      if (directions[k] == 1) {x= last_rect.x() + offset; y= last_rect.y(); }
      if (directions[k] == 2) {x= last_rect.x(); y= last_rect.y() + offset; }
      if (directions[k] == 3) {x= last_rect.x() - offset; y= last_rect.y(); }
      if (directions[k] == 4) {x= last_rect.x(); y= last_rect.y() - offset; }
      if (is_available_rect(x, y)) goto returner;
    }
    for (int k= 0; k < 4; ++k)
    {
      if (directions[k] == 1) {x= last_rect.x() + offset; y= last_rect.y() + offset; }
      if (directions[k] == 2) {x= last_rect.x() + offset; y= last_rect.y() - offset; }
      if (directions[k] == 3) {x= last_rect.x() - offset; y= last_rect.y() + offset; }
      if (directions[k] == 4) {x= last_rect.x() - offset; y= last_rect.y() - offset; }
      if (is_available_rect(x, y)) goto returner;
    }
  }
  printf("**** 50 misses!\n"); exit(0);  /* sort of an assert */
returner:
  return QRect(x, y, this_rect.width(), this_rect.height());
}

/*
  This will I hope be an improvement over next_available_rect().
  Check out the distances for up to 3 positions left / right / up / down from last_rect; pick the closest.
  We say a distance is a line between rects, so diagonal (e.g. x+1, y+1) will beat a vertical (e.g. x+0, y+2).
  Todo: Think -- can something 3 away ever be better than something 2 away? If not, we can go loop 2 at a time.
  Todo: Often two distances will be equal, in that case we need a more even-distributing way than picking the latest.
  Todo: Maybe we should save the last value of n and pass it again, if we're in a loop with the same last_rect.
  Todo: is_available_rect() is slow, and this compounds the slowness, think of something when there are many tables.
  TODO: Perhaps RESLIP could be a different number?
  Todo: Since this is used with midpoint, worry that rects will be plunked in the middle of relation lines.
*/
QRect erd::next_available_rect_3(QRect last_rect, QRect this_rect, int t)
{
  QList<QRect> array_of_rects;
  array_of_rects.clear(); /* unnecessary? */
  int x, y;
#define RESLIP 2
  for (int n= 0; n < RESLIP * 10; n+= RESLIP) /* "< x" is arbitrary but I can't believe anything is separated by more */
  {
    for (x= -(n + RESLIP); x < (n + RESLIP); ++x)
    {
      for (y= -(n + RESLIP); y < (n + RESLIP); ++y)
      {
        if (is_available_rect(last_rect.x() + x, last_rect.y() + y))
          array_of_rects << QRect(last_rect.x() + x, last_rect.y() + y, 1, 1);
      }
    }
    if (array_of_rects.size() > 0) break;
    /* Now you'll have to repeat with bigger x,y which is why n goes up */
  }
  qreal min_distance= 1000000;
  int i_of_min_distance;
  for (int i= 0; i < array_of_rects.size(); ++i)
  {
    QLineF qlf= QLineF(last_rect.x(), last_rect.y(), array_of_rects[i].x(), array_of_rects[i].y());
    qreal curr_distance= qlf.length();
    if (curr_distance > min_distance) continue;
    if ((curr_distance == min_distance) && (i%2==t%2)) continue;
    i_of_min_distance= i;
    min_distance= curr_distance;
  }
  return QRect(array_of_rects[i_of_min_distance].x(), array_of_rects[i_of_min_distance].y(),
              this_rect.width(), this_rect.height());
}

/*
  Variant of next_available_rect() which is not tried initially but might be tried for a shift.
  The only offset is +1. All 8 directions are going to be tried.
  Failure is possible, in which case we return a rect at -1,-1.
*/
QRect erd::next_available_rect_2(QRect last_rect, QRect this_rect, int i_direction)
{
  int x= 0;
  int y= 0;
  if (i_direction == 0) {x= last_rect.x() + 1; y= last_rect.y(); }
  if (i_direction == 1) {x= last_rect.x(); y= last_rect.y() + 1; }
  if (i_direction == 2) {x= last_rect.x() - 1; y= last_rect.y(); }
  if (i_direction == 3) {x= last_rect.x(); y= last_rect.y() - 1; }
  if (i_direction == 4) {x= last_rect.x() + 1; y= last_rect.y() + 1; }
  if (i_direction == 5) {x= last_rect.x() + 1; y= last_rect.y() - 1; }
  if (i_direction == 6) {x= last_rect.x() - 1; y= last_rect.y() + 1; }
  if (i_direction == 7) {x= last_rect.x() - 1; y= last_rect.y() - 1; }
  if (is_available_rect(x, y)) return QRect(x, y, this_rect.width(), this_rect.height());
  return QRect(-1, -1, 0, 0);
}

/* Todo: If schema has 10000 rows and we call this 10000 times, this could get slow. But a bit-list experiment failed. */
bool erd::is_available_rect(int x, int y)
{
  if ((x < 0) || (y < 0)) return false; /* impossible */
  for (int i= 0; i < erd_tables_count; ++i)
  {
    if ((erd_tables[i].erd_rect.x() == x) && (erd_tables[i].erd_rect.y() == y))
      return false;
  }
  return true;
}

/*
  Fill erd_tables[].
  Ordinarily we take all tables in the schema, but if query contains "(table-list)" we take that.
  Re "I": If part_name = PRIMARY that means primary-key index (a MySQL/MariaDB convention).
          So if we see it, and user asked to show only primary columns, this is the acceptable column name.
  Todo: Return error if oei_count == 0. Return error if erd_tables_count == 0.
  Warning: oei also has non-table items
  Todo: there's probably a better way to skip stuff from other schemas, this is slow
        e.g. if it's sorted by schema, you can stop when you've done one schema and you see "S"
        ... or a linked list
*/
void erd::fill_tables()
{
  QString required_schema_name= erd_schema_name;
  erd_tables_count= 0;

  int i_of_query_table= erd_query.indexOf("(");
  for (unsigned int r= 0; r < erd_mainwindow->oei_count; ++r)
  {
    if ((erd_mainwindow->oei[r].object_type == "T")
     && (QString::compare(erd_mainwindow->oei[r].schema_name, required_schema_name, Qt::CaseInsensitive) == 0))
      ++erd_tables_count;
  }

  erd_midpoint= erd_tables_count + 1;

  erd_tables= new table_items[erd_tables_count];
  for (int i= 0; i < erd_tables_count; ++i) erd_tables[i].is_fixed= false;
  int table_number= 0;
  bool is_in_table= false;
  for (unsigned int r= 0; r < erd_mainwindow->oei_count; ++r)
  {
    if (QString::compare(erd_mainwindow->oei[r].schema_name, required_schema_name, Qt::CaseInsensitive) == 0)
    {
      bool is_eligible_if_table= true;
      int fixed_x= 0;
      int fixed_y= 0;
      if ((i_of_query_table != -1)
       && (erd_mainwindow->oei[r].object_type == "T"))
      {
        int i_result= i_of_table_in_query_table(erd_mainwindow->oei[r].object_name, &fixed_x, &fixed_y);
        if (i_result == -1) is_eligible_if_table= false;
      }
      if ((erd_mainwindow->oei[r].object_type == "T") && (is_eligible_if_table == true))
      {
        if ((i_of_query_table != -1) && (fixed_x != erd_midpoint) && (fixed_y != erd_midpoint))
        {
          erd_tables[table_number].xpos= fixed_x + erd_midpoint;
          erd_tables[table_number].ypos= fixed_y + erd_midpoint;
          erd_tables[table_number].erd_rect.setX(fixed_x + erd_midpoint);
          erd_tables[table_number].erd_rect.setY(fixed_y + erd_midpoint);
          erd_tables[table_number].is_fixed= true;
        }
        else erd_tables[table_number].is_fixed= false; /* unnecessary? I set all to false earlier */
        erd_tables[table_number].columns_count= 0;
        erd_tables[table_number++].i_of_oei= r;
        is_in_table= true;
      }
      else if (is_in_table == true)
      {
        if (erd_mainwindow->oei[r].object_type == "C")
        {
          if (erd_is_primary == false)
          {
            ++erd_tables[table_number - 1].columns_count;
            if (erd_tables[table_number - 1].columns_count >= MAX_COLUMN_NAMES) is_in_table= false;
          }
        }
        else if (erd_mainwindow->oei[r].object_type == "I")
        {
          if ((erd_is_primary == true) && (erd_mainwindow->oei[r].part_name == "PRIMARY"))
            ++erd_tables[table_number - 1].columns_count;
        }
        else is_in_table= false; /* F P E t R S */
      }
    }
  }
  erd_tables_count= table_number; /* might be smaller than what we allocated if some tables not eligible */

  for (int i= 0; i < erd_tables_count; ++i)
  {
//    unsigned int r2= erd_tables[i].i_of_oei;
//    QString content=  erd_mainwindow->oei[r2].object_name;
    erd_tables[i].references_count= 0;
  }
}

/*
  Return # of table_name within query table if user supplied optional (query-table) e.g. 1 if second in list.
  Todo: maybe find out at start whether there is a "(" in erd_query.
*/
int erd::i_of_table_in_query_table(QString oei_table_name, int *x, int *y)
{
  int i_of_token;
  for (i_of_token= 0;; ++i_of_token)
  {
    if (erd_token_lengths[i_of_token] == 0) return -1; /* there is no "(" so there is no (table list) */
    QString token= erd_query.mid(erd_token_offsets[i_of_token], erd_token_lengths[i_of_token]);
    if (token == "(") break;
  }
  int i_of_table= 0;
  QString table_name= "";
  QString last_token= "";
  int specified_x= erd_midpoint;
  int specified_y= erd_midpoint;
  ++i_of_token;
  for (;; ++i_of_token)
  {
    if (erd_token_lengths[i_of_token] == 0) break; /* actually we shouldn't see this if there is a ")" */
    QString token= erd_query.mid(erd_token_offsets[i_of_token], erd_token_lengths[i_of_token]);
    if ((token == ")") || (token == ","))
    {
      /* We have reached the end of a table_name [x y] specification */
      if (QString::compare(oei_table_name, table_name, Qt::CaseInsensitive) == 0)
      {
        *x= specified_x;
        *y= specified_y;
        return i_of_table;
      }
      ++i_of_table;
      if (token == ")") break;
      specified_x= specified_y= erd_midpoint;
      continue;
    }
    bool is_numeric;
    int num= token.toInt(&is_numeric);
    if ((is_numeric == false) && (token != "-")) table_name= erd_mainwindow->connect_stripper(token, true);
    if (is_numeric == true)
    {
      if (specified_x == erd_midpoint) {specified_x= num; if (last_token == "-") specified_x= -specified_x; }
      else {specified_y= num; if (last_token == "-") specified_y= -specified_y; }
    }
    last_token= token;
  }
  *x= *y= erd_midpoint;
  return -1; /* name is not in table list */
}

/*
  Pass erd_type == ERD_BAR1 | ERD_BAR2 | ERD_CROWS_FOOT | ERD_CIRCLE
  The pen should still be what we said for setPen during draw_line(), which is not erd_default_container_pen.
  Note: if you have Qt 5.8+ you can say center() instead of multiplying by 0.5
  Todo: For ERD_BAR2: Consider whether drawLines() would do the job as well
  Todo: Return length?
*/
QPointF erd::draw_mark(QPainter *painter, int erd_type, QPointF main_line_point)
{
  QLineF mark_line;
  QPointF mark_line_p2;

  mark_line.setP1(main_line_point);
  mark_line.setAngle(erd_main_line_angle);
  mark_line.setLength(erd_default_mark_length);

  if ((erd_type == ERD_BAR1) || (erd_type == ERD_BAR2) || (erd_type == ERD_CROWS_FOOT))
  {
    /* Extend main line with mark line. */
    /* The line continues for erd_default_mark_length which (?) was subtracted before the call */
    /* ?? This might not get us to exactly the same as P2() */
    painter->drawLine(mark_line);
  }
  mark_line_p2= mark_line.p2(); /* We will return this value eventually so don't change it */
  QPointF mark_line_50_point= (mark_line.p1() + mark_line.p2()) * 0.5;

  /* ERD_BAR1 -- Draw line through the main line at 90 degrees */
  if (erd_type == ERD_BAR1)
  {
    QLineF bar_line;
    bar_line.setP1(mark_line_50_point);
    bar_line.setAngle(erd_main_line_angle + 90);
    bar_line.setLength(erd_default_mark_length / 2);
    painter->drawLine(bar_line);
    bar_line.setP1(mark_line_50_point);
    bar_line.setAngle(erd_main_line_angle - 90);
    bar_line.setLength(erd_default_mark_length / 2);
    painter->drawLine(bar_line);
  }

  /* ERD_BAR2 -- Draw two lines through the main line at 90 degrees */
  /* Todo: This is only okay when line width = 1.
           The separation should be line width -- but not if line width * 3 > erd_default_mark_length!
  */
  if (erd_type == ERD_BAR2)
  {
    QLineF bar2_line= mark_line;
    bar2_line.setLength((erd_default_mark_length / 2) + 2);

    QLineF bar2_line_cross= mark_line;
    bar2_line_cross.setLength(erd_default_mark_length * 0.75);
    QPointF mark_line_75_point= bar2_line_cross.p2();
    QLineF bar_line;
//    QPointF mark_line_75_point= (mark_line_50_point + mark_line.p2()) * 0.5;
    bar_line.setP1(mark_line_75_point);
    bar_line.setAngle(erd_main_line_angle + 90);
    bar_line.setLength(erd_default_mark_length / 2);
    painter->drawLine(bar_line);
    bar_line.setP1(mark_line_75_point);
    bar_line.setAngle(erd_main_line_angle - 90);
    bar_line.setLength(erd_default_mark_length / 2);
    painter->drawLine(bar_line);

    bar2_line.setLength((erd_default_mark_length / 2) - 2);
    //bar2_line.setLength(erd_default_mark_length * 0.25);
    QPointF mark_line_25_point/*= bar2_line.p2()*/;

    bar2_line_cross.setLength(erd_default_mark_length * 0.25);
    mark_line_25_point= bar2_line_cross.p2();

    //QPointF mark_line_25_point= (mark_line_50_point + mark_line.p1()) * 0.5;
    bar_line.setP1(mark_line_25_point);
    bar_line.setAngle(erd_main_line_angle + 90);
    bar_line.setLength(erd_default_mark_length / 2);
    painter->drawLine(bar_line);
    bar_line.setP1(mark_line_25_point);
    bar_line.setAngle(erd_main_line_angle - 90);
    bar_line.setLength(erd_default_mark_length / 2);
    painter->drawLine(bar_line);
  }

  if (erd_type == ERD_CROWS_FOOT)
  {
    QLineF bar1_line;
    bar1_line.setP1(main_line_point);        /* WAS: mark_line_p2 */              /* mark_line_p2 is end line */
    bar1_line.setAngle(erd_main_line_angle - 90);       /* bar1_line_p1 = 90 degrees from line end */
    bar1_line.setLength(erd_default_mark_length / 2);
    QPointF bar1_line_p1= bar1_line.p2();
    bar1_line.setAngle(erd_main_line_angle + 90);
    bar1_line.setLength(erd_default_mark_length / 2);   /* ... for line-length / 2*/
    QPointF bar1_line_p2= bar1_line.p2();
    mark_line.setP1(mark_line_p2);       /* WAS: main_line_point */            /* main_line_point is start line */
    mark_line.setP2(bar1_line_p1);
    painter->drawLine(mark_line);
    mark_line.setP2(bar1_line_p2);
    painter->drawLine(mark_line);
  }

  if (erd_type == ERD_CIRCLE)
  {
    painter->drawEllipse(mark_line_50_point, erd_default_mark_length / 2, erd_default_mark_length / 2);
  }

  /* Restore because earlier we set the pen to thin and red (I think). */
  painter->setPen(erd_default_container_pen);
  return mark_line_p2;
}

/*
  Draw line
  Lines should always be away from top|left edge to allow for height|width of marks.
  Lines do not have label = constraint but have tooltip = constraint name.
  Option: do this first, so lines will seem to disappear underneath rects ("[lines in background]")
  Todo: Line length decreases depending on number of mark flags, or each mark overwrites
  Todo: When lines are thick, ERD_BAR2 looks like a single wider line
  It seems that P1 will be referencing and P2 will be referenced.
  Since referenced is a primary or unique key, it will always have two bars i.e. "one and only one".
  If referencing is unique, it should have one bar + circle i.e. "one or none" (TODO: WE DON'T CHECK)
  If referencing is not unique, it should have crow's foot + circle i.e. "many or none"
  If X references Y and Y references X, it should have two bars and two bars (TODO: WE DON'T CHECK)
  ... Almost always there are 3 markers in a line, all with same size, so minimum line length is known, eh?
*/
void erd::draw_line(QPainter *painter, int x1, int y1, int x2, int y2, int i_of_relation)
{
  QPointF main_line_point;

  /* Todo: This might be too big! */
  erd_default_container_pen.setWidth(erd_default_container_pen_width * 3);

  char new_color[8];
  strcpy(new_color, erd_color_palette[i_of_relation % erd_color_palette_count]);
  erd_default_container_pen.setColor(new_color);
  painter->setPen(erd_default_container_pen);

  /* Find point that is at center of mark line. Todo: Don't let line width affect the calculation. */
  QLineF main_line;
  main_line= QLineF(x1, y1, x2, y2);

  erd_main_line_angle= main_line.angle();

  /* Marks at line start */

  /* TEST! But I think p1 is always referenced_table */
  if (erd_relations[i_of_relation].i_of_referenced_table != -1)
  {
    main_line_point= main_line.p1();
    main_line_point= draw_mark(painter, ERD_CROWS_FOOT, main_line_point);
    main_line_point= draw_mark(painter, ERD_CIRCLE, main_line_point);
  }

  /* TODO: Reduce the length of main_line according to whatever the total mark sizes are */

  main_line= QLineF(main_line_point, main_line.p2());

  int line_length= main_line.length();
  line_length-= erd_default_mark_length;
  main_line.setLength(line_length);

  painter->drawLine(main_line);

  main_line_point= main_line.p2();
  /* Test! But I think p2 is always referencing_table */
  /* Marks at line end */
  //if (bar1 > 0) main_line_point= draw_mark(painter, ERD_BAR1, main_line_point);
  //if (bar2 > 0) main_line_point= draw_mark(painter, ERD_BAR2, main_line_point);
  // if (crows_foot) main_line_point= draw_mark(painter, ERD_CROWS_FOOT, main_line_point);
  main_line_point= draw_mark(painter, ERD_BAR2, main_line_point);
  return;
}

/*
  Calculate the rectangles of each table for placing in erd_tables, which draw_table() can use.
  Called from default settings()
  erd_rect should be outer i.e. include border width and border height
  We calculated x, y earlier with the assumption that every rect is one point
  Soon we will calculate positions too -- we want to place related items near each other
  Todo: Something like this could be done for calculating line positions too
        (the less that we need to do every paint event, the better)
  Getting the column values might depend on whether said "... show erdiagram of schema_name columns PRIMARY".
  initial x will be some small value
  Warning: assumption that we never go up ... oh that isn't true. Bah. Won't be in order!

  We should be saying: Loop: Anything with a HIGHER ypos and SAME xpos gets a bigger top.
                       Wow, there are so many loops within loops in the ERDiagram routines.
                       If we had fixed height and fixed width this would be loads faster.
  Each ERdiagram row has height = height of highest in row.
  Each ERdiagram column has width = width of widest in row.
  There is a separation between rects which is fixed, or depends on longest line.
  But we're starting with assumption that every rect is the same size.
*/

#ifdef PACKED
void erd::set_table_rects(int max_x, int max_y)
#else
void erd::set_table_rects()
#endif
{
//  int content_offset= ERD_MARGIN_X + ERD_MARGIN_Y + erd_default_container_pen_width;
//  int container_margin= content_offset * 2;
  int *erd_diagram_row_heights= NULL;
  int *erd_diagram_column_widths= NULL;
  int erd_diagram_row_count= -1;
  int erd_diagram_column_count= -1;
  for (int i= 0; i < erd_tables_count; ++i)
  {
    erd_tables[i].xpos= erd_tables[i].erd_rect.x();
    erd_tables[i].ypos= erd_tables[i].erd_rect.y();
    erd_tables[i].w= 0;
    erd_tables[i].l= 0;
    if (erd_tables[i].xpos > erd_diagram_column_count) erd_diagram_column_count= erd_tables[i].xpos;
    if (erd_tables[i].ypos > erd_diagram_row_count) erd_diagram_row_count= erd_tables[i].ypos;
  }
  ++erd_diagram_row_count;
  ++erd_diagram_column_count;
  /* Actual rect widths and heights based on table-name and column-name widths and heights */
  /* Calculations must match what we do in draw_table() */
  QFontMetrics fm= QFontMetrics(erd_default_font);
  for (int i= 0; i < erd_tables_count; ++i)
  {
    unsigned int i_of_oei= erd_tables[i].i_of_oei;
    QString table_name= erd_mainwindow->oei[i_of_oei].object_name;
    int content_width= fm.boundingRect(table_name).width();
    int content_height= fm.boundingRect(table_name).height();
    int column_name_count= 0;
    QString column_name;
    for (int j= i_of_oei + 1;; ++j)
    {
      if (column_name_count == erd_tables[i].columns_count) break;
      if ((erd_is_primary == false) && (erd_mainwindow->oei[j].object_type == "C"))
      {
        column_name= erd_mainwindow->oei[j].part_name;
      }
      else if ((erd_is_primary == true)
            && (erd_mainwindow->oei[j].object_type == "I")
            && (erd_mainwindow->oei[j].part_name == "PRIMARY"))
      {
        column_name= erd_mainwindow->oei[j].part_type;
      }
      else continue;

      int column_name_width= fm.boundingRect(column_name).width();
      if (column_name_width > content_width) content_width= column_name_width;
      content_height+= fm.boundingRect(column_name).height();
      ++column_name_count;
    }
    int margin_count = 2 + column_name_count + 1; /* margin,tname,margin,line,margin,cnames+margins */
    /* "+ 6" is a kludge */
    erd_tables[i].erd_rect= QRect(erd_tables[i].erd_rect.x(),
                                 erd_tables[i].erd_rect.y(),
                                 content_width + erd_default_container_pen_width * 2 + ERD_MARGIN_X * 2,
                                 content_height + erd_default_container_pen_width * 3 + margin_count * ERD_MARGIN_Y + 6);
  }
  /* There are "delete []" statements at the end of this function. */
  erd_diagram_row_heights= new int[erd_diagram_row_count];
  erd_diagram_column_widths= new int[erd_diagram_column_count];
  for (int i= 0; i < erd_diagram_row_count; ++i) erd_diagram_row_heights[i]= -1;
  for (int i= 0; i < erd_diagram_column_count; ++i) erd_diagram_column_widths[i]= -1;
  for (int i= 0; i < erd_tables_count; ++i)
  {
    if (erd_tables[i].erd_rect.width() > erd_diagram_column_widths[erd_tables[i].xpos])
      erd_diagram_column_widths[erd_tables[i].xpos]= erd_tables[i].erd_rect.width();
    if (erd_tables[i].erd_rect.height() > erd_diagram_row_heights[erd_tables[i].ypos])
      erd_diagram_row_heights[erd_tables[i].ypos]= erd_tables[i].erd_rect.height();
  }

  /* Positions based on maximum row heights and maximum column heights */

#ifdef PACKED
  /* This was an experiment so not every rect was in a fixed grid. It sort of works but would need more work. */
  /* Make an array of what tables are at each x on each y -- TODO: THIS SHOULD BE VARIABLE SIZE! */
  int xy[50][50];
  for (int xx= 0; xx <= max_x; ++xx)
  {
    for (int yy= 0; yy <= max_y; ++yy)
    {
      xy[xx][yy]= -1;
    }
  }
  for (int i= 0; i < erd_tables_count; ++i) xy[erd_tables[i].xpos][erd_tables[i].ypos]= i;


  int x;
  for (int yy= 0; yy <= max_y; ++yy)
  {
    x= 0;
    for (int xx= 0; xx <= max_x; ++xx)
    {
      int t= xy[xx][yy];
      if (t != -1)
      {
        erd_tables[t].erd_rect= QRect(x,
                                      0,
                                      erd_tables[t].erd_rect.width(),
                                      erd_tables[t].erd_rect.height());
        x+= erd_tables[t].erd_rect.width() + erd_default_space_between_rects;
      }
    }
  }

  int y;
  for (int xx= 0; xx <= max_x; ++xx)
  {
    y= 0;
    for (int yy= 0; yy <= max_y; ++yy)
    {
      int t= xy[xx][yy];
      if (t != -1)
      {
        erd_tables[t].erd_rect= QRect(erd_tables[t].erd_rect.x(),
                                      y,
                                      erd_tables[t].erd_rect.width(),
                                      erd_tables[t].erd_rect.height())
        y+= erd_tables[t].erd_rect.height() + erd_default_space_between_rects;
      }
    }
  }
#else
  for (int i= 0; i < erd_tables_count; ++i)
  {
    int x= 0;
    int y= 0;
    for (int j= 0; j < erd_tables[i].xpos; ++j) x+= erd_diagram_column_widths[j] + erd_default_space_between_rects;
    for (int j= 0; j < erd_tables[i].ypos; ++j) y+= erd_diagram_row_heights[j] + erd_default_space_between_rects;
    /* Saying every rect is at 0,0 looks odd, eh? */
    erd_tables[i].erd_rect= QRect(x,
                                  y,
                                  erd_tables[i].erd_rect.width(),
                                  erd_tables[i].erd_rect.height());
  }
#endif
  if (erd_diagram_column_widths != NULL) delete [] erd_diagram_column_widths;
  if (erd_diagram_row_heights != NULL) delete [] erd_diagram_row_heights;
  return;
}

/* Warning: 20 is an arbitrary number */
void erd::bend_count_main()
{
  int count_via_tables= 0;
  for (int i= 0; i < erd_tables_count; ++i)
  {
    int count_1= bend_count_one_table(i);
    count_via_tables+= count_1;
    if (count_1 >= 20) bend_count_try_shift(i);
  }
 count_via_tables= 0;
  for (int i= 0; i < erd_tables_count; ++i)
  {
    int count_1= bend_count_one_table(i);
    count_via_tables+= count_1;
    if (count_1 >= 20) bend_count_try_exchange(i);
  }
}

/* Return the total bend count for all relations */
int erd::bend_count_all()
{
  int count= 0;
  for (int i= 0; i < erd_relations_count; ++i)
  {
    count+= bend_count_one_relation(i);
  }
  return count;
}

/*
  Todo: take into account that we could be crossing blanks.
  For example, with the sakila database on the Windows host, perhaps because tables were created in a different
  order, we have a different diagram and a bend because line inventory <-> rental goes through some rects.
  If inventory had been placed above rental then the film<->inventory would be going through blanks, and if
  we didn't count blanks then the bend count might have been good for that.
*/
int erd::bend_count_one_relation(int i_of_relation)
{
  int count= 0;
  int t1= erd_relations[i_of_relation].i_of_referenced_table;
  int t2= erd_relations[i_of_relation].i_of_referencing_table;
  int distance_x= abs(erd_tables[t1].erd_rect.x() - erd_tables[t2].erd_rect.x());
  int distance_y= abs(erd_tables[t1].erd_rect.y() - erd_tables[t2].erd_rect.y());
  if ((distance_x <= 1) && (distance_y == 0)) {;} /* adjacent left|right, no bend */
  else if ((distance_y <= 1) && (distance_x == 0)) {;} /* adjacent up|down, no bend */
  else if ((distance_y <= 1) && (distance_x <= 1)) count+= 3; /* adjacent diagonal */
  else count+= (distance_x + distance_y) * 10;
  return count;
}

/* Return bend count for specified table, by looking at all relations that mention this table. */
/* Very similar to bend_count_all(), perhaps we should merge. */
int erd::bend_count_one_table(int i_of_table)
{
  int count= 0;
  for (int i= 0; i < erd_relations_count; ++i)
  {
    if ((erd_relations[i].i_of_referenced_table == i_of_table)
     || (erd_relations[i].i_of_referencing_table == i_of_table))
      count+= bend_count_one_relation(i);
  }
  return count;
}

/* Copy i.e. "push" all rects. Reverse is bend_count_pop(). Warning: not xpos, ypos, w, l, or columns_rect. */
void erd::bend_count_push()
{
  for (int i= 0; i < erd_tables_count; ++i)
    erd_tables[i].pushed_rect= erd_tables[i].erd_rect;
}

/* Copy i.e. "pop" all rects. Reverse is bend_count_push(). */
void erd::bend_count_pop()
{
  for (int i= 0; i < erd_tables_count; ++i)
  {
    erd_tables[i].erd_rect= erd_tables[i].pushed_rect;
  }
}

/*
  The table at erd_table[i_of_table] has a high bend count (>= 20) (arbitrary) (should be "greatest"?)
  This is a tactic which might not do much good.
  Pass: i_of_table that has a high bend count. Look for relations where bend_count > (arbitrary number) 20.
  Push. Remove rect from current position. Add with prev = distant rect. Compare bend counts. Keep or pop.
  Todo: Actually the push|pop calls are too much, you only need to push|pop i_of_table's rect, once.
  Todo: We repeat next_available_rect() with 4 different direction indicators (left/right/up/down), why not 8?
*/
void erd::bend_count_try_shift(int i_of_table)
{
  if (erd_tables[i_of_table].is_fixed == true) return;
  int i_of_related_table;
  int old_bend_count_all= bend_count_all();
  int best_bend_count_all= old_bend_count_all;
  int best_bend_count_all_related_table= 0;
  int best_bend_count_all_direction= 0;
  for (int i= 0; i < erd_relations_count; ++i)
  {
    if (erd_relations[i].i_of_referencing_table == i_of_table)
      i_of_related_table= erd_relations[i].i_of_referenced_table;
    else if (erd_relations[i].i_of_referenced_table == i_of_table)
      i_of_related_table= erd_relations[i].i_of_referencing_table;
    else continue;
    int bend_count_one= bend_count_one_relation(i);
    if (bend_count_one >= 20)
    {
      bend_count_push();

//      int i_of_oei= erd_tables[i_of_table].i_of_oei;
//      QString table_name= erd_mainwindow->oei[i_of_oei].object_name;
//      i_of_oei= erd_tables[i_of_related_table].i_of_oei;
//      table_name= erd_mainwindow->oei[i_of_oei].object_name;
      int trial_bend_count_all;
      for (int i_direction= 0; i_direction < 8; ++i_direction)
      {
        QRect trial_rect= next_available_rect_2(erd_tables[i_of_related_table].erd_rect,
                                                erd_tables[i_of_table].erd_rect,
                                                i_direction);
        if ((trial_rect.x() == -1) && (trial_rect.y() == -1)) continue;
        erd_tables[i_of_table].erd_rect= trial_rect;
        trial_bend_count_all= bend_count_all();
        if (trial_bend_count_all < best_bend_count_all)
        {
          best_bend_count_all= trial_bend_count_all;
          best_bend_count_all_related_table= i_of_related_table;
          best_bend_count_all_direction= i_direction;
        }
      }
      bend_count_pop();
    }
  }
  if (best_bend_count_all < old_bend_count_all) /* shift if it would reduce bend count */
  {
    QRect next_rect= next_available_rect(erd_tables[best_bend_count_all_related_table].erd_rect,
                                        erd_tables[i_of_table].erd_rect,
                                        best_bend_count_all_direction);
    erd_tables[i_of_table].erd_rect= next_rect;
  }
}

/*
  A bit like bend_count_try_shift() but bend count between two tables doesn't matter, all that matters
  is whether there is a relation.
  In fact, mere adjacency could be a criterion.
*/
void erd::bend_count_try_exchange(int i_of_table)
{
  if (erd_tables[i_of_table].is_fixed == true) return;
  int i_of_related_table;
  int old_bend_count_all= bend_count_all();
  int best_bend_count_all= old_bend_count_all;
  QRect best_bend_count_all_rect_of_table;
  QRect best_bend_count_all_rect_of_related_table;
  int best_bend_count_all_i_of_related_table= 0;
  for (int i= 0; i < erd_relations_count; ++i)
  {
    if (erd_relations[i].i_of_referencing_table == i_of_table)
      i_of_related_table= erd_relations[i].i_of_referenced_table;
    else if (erd_relations[i].i_of_referenced_table == i_of_table)
      i_of_related_table= erd_relations[i].i_of_referencing_table;
    else continue;
    {
      bend_count_push();
      QRect rect_of_table= erd_tables[i_of_table].erd_rect;
      QRect rect_of_related_table= erd_tables[i_of_related_table].erd_rect;
      erd_tables[i_of_table].erd_rect= rect_of_related_table;
      erd_tables[i_of_related_table].erd_rect= rect_of_table;
      int trial_bend_count_all= bend_count_all();
      if (trial_bend_count_all < best_bend_count_all)
      {
        best_bend_count_all= trial_bend_count_all;
        best_bend_count_all_i_of_related_table= i_of_related_table;
        best_bend_count_all_rect_of_table= rect_of_table;
        best_bend_count_all_rect_of_related_table= rect_of_related_table;
      }
      bend_count_pop();
    }
  }
  if (best_bend_count_all < old_bend_count_all) /* exchange if it would reduce bend count */
  {
    erd_tables[i_of_table].erd_rect= best_bend_count_all_rect_of_related_table;
    erd_tables[best_bend_count_all_i_of_related_table].erd_rect= best_bend_count_all_rect_of_table;
  }
}

/*
  Draw a table. Colors and widths from grid settings.
  Todo: Option: Calculate size but do not draw.
        We should calculate the sizes first, and draw later (in case we want to rearrange).
        So some of the calculations are done in an earlier function as well.
  What about height / width of brush?
*/
void erd::draw_table(QPainter *painter, int table_number)
{
  int x= erd_tables[table_number].erd_rect.x();
  int y= erd_tables[table_number].erd_rect.y();
  unsigned int i_of_oei= erd_tables[table_number].i_of_oei;
  int rect_table_name_height;
  QFontMetrics fm= QFontMetrics(erd_default_font);
  {
    QString table_name= erd_mainwindow->oei[i_of_oei].object_name;
    int table_name_height= fm.boundingRect(table_name).height();
    /* "+ 6" is a kludge */
    rect_table_name_height= erd_default_container_pen_width * 2 + ERD_MARGIN_Y * 2 + table_name_height + 6;

    QString color_of_rect_border= erd_mainwindow->ocelot_grid_cell_border_color;
    erd_default_container_pen.setColor(color_of_rect_border);

    painter->setPen(erd_default_container_pen); /* This might be unnecessary. */

    painter->setBrush(erd_default_header_brush);

    QRect qr= QRect(x,
                    y,
                    erd_tables[table_number].erd_rect.width(),
                    rect_table_name_height);

    /* Unfortunately we cannot pass TEXTEDITFRAME_CELL_TYPE_HEADER which would be more appropriate. */
    QRect qr_of_table= QRect(x + ERD_MARGIN_X + erd_default_container_pen_width,
                               y + ERD_MARGIN_Y + erd_default_container_pen_width,
                               fm.boundingRect(table_name).width() + 1,
                               fm.boundingRect(table_name).height());
    painter->drawRect(qr); /* draw rect with header background color */
    painter->setPen(erd_default_text_pen);
    erd_draw_text_prepare(painter, table_number, table_name, TEXTEDITFRAME_CELL_TYPE_DETAIL, qr_of_table);

    painter->drawText(qr_of_table, Qt::AlignLeft, table_name);
    y+= rect_table_name_height - erd_default_container_pen_width;
  }
  /* And now the columns */
  painter->setPen(erd_default_container_pen);
  painter->setBrush(erd_default_detail_brush);
  int cc= erd_tables[table_number].columns_count;
  if (cc <= 0) return; /* A table with no columns is possible if option = primary-keys-only and there are none */
  QRect qr= QRect(x,
                  y,
                  erd_tables[table_number].erd_rect.width(),
                  (erd_tables[table_number].erd_rect.height() - rect_table_name_height) + erd_default_container_pen_width);
  painter->drawRect(qr); /* draw rect with column background color */
  y+= erd_default_container_pen_width + ERD_MARGIN_Y;
  painter->setPen(erd_default_text_pen);
  int column_name_count= 0;
  for (unsigned int i= i_of_oei + 1;; ++i)
  {
    if (column_name_count == erd_tables[table_number].columns_count) break;
    QString column_name;
    if ((erd_is_primary == false) && (erd_mainwindow->oei[i].object_type == "C"))
    {
      column_name= erd_mainwindow->oei[i].part_name;
    }
    else if ((erd_is_primary == true)
          && (erd_mainwindow->oei[i].object_type == "I")
          && (erd_mainwindow->oei[i].part_name == "PRIMARY"))
    {
      column_name= erd_mainwindow->oei[i].part_type;
    }
    else continue;
    int column_name_width= fm.boundingRect(column_name).width();
    int column_name_height= fm.boundingRect(column_name).height();
    QRect qr_of_column= QRect(x + ERD_MARGIN_X + erd_default_container_pen_width,
                              y + ERD_MARGIN_Y,
                              column_name_width,
                              column_name_height);
    erd_draw_text_prepare(painter, table_number, column_name, TEXTEDITFRAME_CELL_TYPE_DETAIL, qr_of_column);
    painter->drawText(qr_of_column, Qt::AlignLeft, column_name);
    y+= column_name_height + ERD_MARGIN_Y;
    ++column_name_count;
  }
  /* Conditional setting can affect brush, which can affect later drawEllipse() */
  /* ... but this might be unnecessary since I reset before calling draw_line */
  painter->setBrush(erd_default_header_brush);
}

/*
  Possible pen and brush change due to grid conditional
  Oddness: conditional with column_number=2 was getting column 1, and with row_number=2 was getting row 1.
           Perhaps we're doing an offset for grid because a grid has a fake starting column?
           Shouldn't affect it?
           Anyway, by passing xpos+0 and ypos+0, I persuade evaluate to return true for the right columns and rows.
  Todo: test row_number = n when column_names = 0 (done, still no good)
 */
void erd::erd_draw_text_prepare(QPainter *painter,
               int table_number,    /* so we can get xpos i.e. column_number and ypos i.e. row_number */
               QString content,     /* table_name | column_name */
               int cell_type,       /* TEXTEDITFRAME_CELL_TYPE_DETAIL | TEXTEDITFRAME_CELL_TYPE_HEADER */
               QRect qr_of_content)
{
  QString string= content.trimmed();
  QByteArray string_utf8= string.toUtf8();
  QString new_tooltip, new_style_sheet, new_cell_height, new_cell_width, new_text;
  int cs_number;
  bool result_of_evaluate;
  result_of_evaluate= erd_mainwindow->explorer_widget->conditional_setting_evaluate_till_true(
    erd_tables[table_number].xpos, /* i.e. column number of ERDiagram not column number of table */
    erd_tables[table_number].ypos + 1, /* i.e. row number of ERDiagram */
    string_utf8.data(), /* e.g. text_frame->content_pointer */
    0, /* e.g. FIELD_VALUE_FLAG_IS_NULL */
    string_utf8.size(), /* e.g. text_frame->content_length */
    cell_type, /* e.g. text_frame->cell_type */
    &new_tooltip, /* return */
    &new_style_sheet, /* return */
    &new_cell_height, /* return */
    &new_cell_width, /* return */
    &cs_number,
    &new_text, /* return */
    NULL);
  if (result_of_evaluate == true)
  {
    QString new_background_color= erd_mainwindow->get_background_color_from_style_sheet(new_style_sheet);
    QBrush new_rect_brush= erd_default_header_brush;
    new_rect_brush.setColor(new_background_color);
    //QPen new_rect_pen;
    //new_rect_pen.setWidth(0);
    painter->setBrush(new_rect_brush);
    painter->setPen(Qt::NoPen);
    painter->drawRect(qr_of_content);

    QString new_color= erd_mainwindow->get_color_from_style_sheet(new_style_sheet);
    QPen new_text_pen= erd_default_text_pen;
    new_text_pen.setColor(new_color);
    painter->setPen(new_text_pen);

    /* This changes weight and style but not size. Original setting was in points not pixels. */
    QFont qf= erd_mainwindow->get_font_from_style_sheet(new_style_sheet);
    int point_size= erd_default_font.pointSize();
    qf.setPointSize(point_size);
    painter->setFont(qf);
  }
  else
  {
    painter->setBrush(erd_default_header_brush); /* These settings are unnecessary if there are no conditionals */
    painter->setPen(erd_default_text_pen);
    painter->setFont(erd_default_font);
  }
}

/*
  Set the lines between the rects.
  To avoid lines having the same start and end points, we check whether point has alread been assigned
  for a different line.
  Todo: if a rect side has multiple lines we could still have conflict
  Todo: sometimes there could be an alternate line e.g. if rect#2 is both down and left of rect#1
*/
void erd::set_lines()
{
  for (int i= 0; i < erd_relations_count; ++i)
  {
    int r0= erd_relations[i].i_of_referencing_table;
    int r1= erd_relations[i].i_of_referenced_table;
    QPointF p1, p2;
    QLineF l1, l2;
    line_ends(r0, r1, &p1, &p2, &l1, &l2);
    for (int j= 0; j < i; ++j)
    {
      if ((p1 == erd_relations[j].P1) || (p1 == erd_relations[j].P2)) /* P1 conflict? */
      {
        p1= point_near_point(p1, l1);
      }
      if ((p2 == erd_relations[j].P1) || (p2 == erd_relations[j].P2)) /* P2 cnflict? */
      {
        p2= point_near_point(p2, l2);
      }
    }
    erd_relations[i].P1= p1;
    erd_relations[i].P2= p2;
  }
}

/*
  Get a point which is near p, on the same line as l, and not in conflict with another point.
  Do it by getting a line from p to line end or line start, shortening it, and returning the new end.
  Todo: in order to avoid going past the end of the line (which is a side of a perpendicular rect),
        we check whether we're within 5 points of the edge, and switch p1/p2 if so. But 5 is an arbitrary
        number and we might still see lines which appear to not be connecting two rects.
*/
QPointF erd::point_near_point(QPointF p, QLineF l)
{
  QPointF line_end= l.p2();
  QLineF line_to_be_shortened= QLineF(p, line_end);
  if (line_to_be_shortened.length() < 5) /* i.e. is p1-p2 distance short i.e. are we near end of line? */
  {
    line_end= l.p1();
    line_to_be_shortened= QLineF(p, line_end);
    line_to_be_shortened.setLength(20);
    return line_to_be_shortened.p2();
  }
  line_end= l.p2();
  line_to_be_shortened= QLineF(p, line_end);
  line_to_be_shortened.setLength(20);
  return line_to_be_shortened.p2();
}

/*
  Pass two QRects. Return the start and end of a line that we can draw between them.
  I want the line to be reasonably short but if the QRects are at a bit of an angle then let the line be too.
  So I can find the place where they intersect by:
    LM = Qline(center#1 to center#2)
    L1 = QLine(edge#1)
    L2 = QLine(edge#2)
    P1 = QPoint where LM and L1 intersect
    P2 = QPoint where LM and L2 intersect
    There are simpler ways, e.g. always go from center of rect1 edge to center of p2 edge, but I like this best.
    ... Flaw: if there's a group #1 #2 #3 and we're point through #2 to #3, we get interference.
    Special case: if rects in same column and not adjacent, line from corner to corner
                  + do the same trick for rects in same row and not adjacent
*/
void erd::line_ends(int r0, int r1, QPointF *p1, QPointF *p2, QLineF *line_at_rect_side_p1, QLineF *line_at_rect_side_p2)
{
  QRect rect1= erd_tables[r0].erd_rect;
  QRect rect2= erd_tables[r1].erd_rect;
  QPointF rect1_center, rect2_center;
  if ((erd_tables[r0].xpos == erd_tables[r1].xpos) && (erd_tables[r0].ypos > erd_tables[r1].ypos + 1))
  {
    rect1_center= rect1.topRight();
    rect2_center= rect2.bottomRight();
  }
  else if ((erd_tables[r0].xpos == erd_tables[r1].xpos) && (erd_tables[r0].ypos < erd_tables[r1].ypos - 1))
  {
    rect1_center= rect1.bottomRight();
    rect2_center= rect2.topRight();
  }
  else if ((erd_tables[r0].ypos == erd_tables[r1].ypos) && (erd_tables[r0].xpos > erd_tables[r1].xpos + 1))
  {
    rect1_center= rect1.bottomLeft();
    rect2_center= rect2.bottomRight();
  }
  else if ((erd_tables[r0].ypos == erd_tables[r1].ypos) && (erd_tables[r0].xpos < erd_tables[r1].xpos - 1))
  {
    rect1_center= rect1.bottomRight();
    rect2_center= rect2.bottomLeft();
  }
  else
  {
    rect1_center= rect1.center();
    rect2_center= rect2.center();
  }

  QLineF lm= QLineF(rect1_center, rect2_center);
  QPointF l1;
  QLineF line_at_rect_side;
  *p1= line_rect_intersection(rect1, lm, &line_at_rect_side);
  *line_at_rect_side_p1= line_at_rect_side;
  *p2= line_rect_intersection(rect2, lm, &line_at_rect_side);
  *line_at_rect_side_p2= line_at_rect_side;
}

/*
  Pass: QRect and Line. Return: point where they intersect.
  line_at_rect_side =top | left | bottom | right side of the rect where the intersecting point is
  ... Flaw: Checking all four possible edges is a bit tedious, maybe there's a simpler way
  ... Flaw: if intersect is exactly at a corner e.g. bottomLeft() then there are two possible answers
  ... Flaw: if rectangles overlap you'll get UnboundedIntersection which is an error, maybe assertable,
            but we'll pretend it's okay and the result I suppose will be that the line starts within rect
            -- also user can specify the same x y position for different tables in "tables (table-list)"
  ... Flaw: "no intersections" should be impossible and assertable, but we just return the line bottomright
  Re QT_VERSION: intersects() was introduced in Qt 5.14, intersect() was later deprecated and removed.
*/
QPointF erd::line_rect_intersection(QRect rect, QLineF line, QLineF *line_at_rect_side)
{
  QLineF side_line;
  int it; /* enum QLineF::IntersectionType */
  QPointF ip, ip_unbounded;
  int i;
  bool is_bounded= false;
  bool is_unbounded= false;
//  int j= -1;
  for (i= 0; i < 4; ++i)
  {
    if (i == 0) side_line= QLineF(rect.bottomLeft(), rect.bottomRight());
    if (i == 1) side_line= QLineF(rect.bottomLeft(), rect.topLeft());
    if (i == 2) side_line= QLineF(rect.topLeft(), rect.topRight());
    if (i == 3) side_line= QLineF(rect.topRight(), rect.bottomRight());
#if (QT_VERSION >= 0x50f00)
    it= line.intersects(side_line, &ip);
#else
    it= line.intersect(side_line, &ip);
#endif
    if (it == QLineF::NoIntersection)
    {
      ;
    }
    if (it == QLineF::UnboundedIntersection)
    {
      ip_unbounded= ip;
//      j= i;
      is_unbounded= true;
    }
    if (it == QLineF::BoundedIntersection)
    {
      is_bounded= true;
      break;
    }
  }
  *line_at_rect_side= side_line;
  if (is_bounded) { return ip; }
  if (is_unbounded) { return ip_unbounded; }
  return rect.bottomRight();
}

//void scrollEvent(QScrollEvent *event)
//{
//  ;
//}

/* Sizes and positions of rectangles were established earlier. */
void erd::paintEvent(QPaintEvent *event)
{
  (void) event;
  erd_default_container_pen.setWidth(erd_default_container_pen_width);
  erd_default_container_pen.setColor(erd_mainwindow->qt_color(erd_mainwindow->ocelot_grid_cell_border_color));

  QPainter painter(this);

  if (erd_is_lines_in_background == false)
  {
    for (int i_of_erd_table= 0; i_of_erd_table < erd_tables_count; ++i_of_erd_table)
    {
      draw_table(&painter, i_of_erd_table);
    }
  }
  painter.setBrush(erd_default_header_brush);
  for (int i= 0; i < erd_relations_count; ++i)
  {
    QPointF p1= erd_relations[i].P1;
    QPointF p2= erd_relations[i].P2;
    /* Todo: Converting to x, y shouldn't be necessary, try passing p1 and p2 directly to draw_line */
    int x1= p1.rx();
    int x2= p2.rx();
    int y1= p1.ry();
    int y2= p2.ry();
    /* TODO: Find out whether there are marks. If so, draw with erd_default_mark_length, appropriately. */
    draw_line(&painter, x1, y1, x2, y2, i);
  }

  if (erd_is_lines_in_background == true)
  {
    for (int i_of_erd_table= 0; i_of_erd_table < erd_tables_count; ++i_of_erd_table)
    {
      draw_table(&painter, i_of_erd_table);
    }
  }

}

/*
  Tooltip
  I said setMouseTracking(true) earlier.
  If mouse is within a line or quite close: show the name of the foreign-key constraint.
  ELse if mouse are within a rect: show the QRect dimensions and x y.
  Else there is no tooltip. Todo: maybe some general hint e.g. name of schema + number of tables? "blank spot"?
  If user specified "lines in background", we check rects first.
  I don't know whether it is better to declare mouseMoveEvent here rather than in ERDiagram parent.
  I don't know whether to say private / protected / virtual.
  I don't know about setToolTipDuration().
  I don't know whether I need to call ERDiagram::mouseEvent() maybe it passes up the line anyway, eh?
  Todo: Check the ways a relation won't be shown and therefore its main_line should not be checked.
  To decide whether mouse is in a rect:
    QRect.contains().
  To decide whether mouse is on or close to a line:
    As we do when drawing a bar, we create "bar lines" at 90-degree angles to the line defined by relation's
    P1, P2. The bar line length is erd_default_mark_length / 2 which is affected by ocelot_grid_cell_border_size
    (because line width is based on that) plus 5 (which is arbitrary but we want to accept "near" since lines
    are typically quite thin).
    The bar line P1 is mouse_point.
    If success i.e. there is an intersection, get length of line from mouse_point to intersection_point --
    we want to get the shortest distance out of all the relations, because two relation lines might be
    within bar line length of each other.
    Re QT_VERSION: intersects() was introduced in Qt 5.14, intersect() was later deprecated and removed.
    (It's already been checked that mouse is not within a rect.)
    Todo: Save time with a rough calculation: rect formed by relation line contains mouse_point? If not, skip.
*/
void erd::mouseMoveEvent(QMouseEvent *event)
{
  QPoint mouse_point= event->pos();
  QString tooltip_string;
  if (erd_is_lines_in_background == true)
  {
    tooltip_string= tooltip_of_rect(mouse_point);
    if (tooltip_string == "") tooltip_string= tooltip_of_line(mouse_point);
  }
  else
  {
    tooltip_string= tooltip_of_line(mouse_point);
    if (tooltip_string == "") tooltip_string= tooltip_of_rect(mouse_point);
  }
  setToolTip(tooltip_string);
}

QString erd::tooltip_of_rect(QPoint mouse_point) /* see comments for mouseMoveEvent */
{
  char tooltip_char_string[1024];
  strcpy(tooltip_char_string,"");
  for (int i= 0; i < erd_tables_count; ++i)
  {
    if (erd_tables[i].erd_rect.contains(mouse_point))
    {
      sprintf(tooltip_char_string,"x (column) = %d, y (row) = %d, x (pixel) = %d, y (pixel) = %d, width (pixel) = %d, height (pixel) = %d",
             erd_tables[i].xpos,
             erd_tables[i].ypos,
             erd_tables[i].erd_rect.x(),
             erd_tables[i].erd_rect.y(),
             erd_tables[i].erd_rect.width(),
             erd_tables[i].erd_rect.height());
      if (erd_tables[i].is_fixed == true) strcat(tooltip_char_string, " (fixed)");
      break;
    }
  }
  return tooltip_char_string;
}

QString erd::tooltip_of_line(QPoint mouse_point) /* see comments for mouseMoveEvent() */
{
  char tooltip_char_string[1024];
  strcpy(tooltip_char_string, "");
  int default_bar_line_length= erd_default_mark_length / 2 + 5;
  int nearest_relation= -1;
  qreal nearest_relation_distance= 999999;
  for (int i= 0; i < erd_relations_count; ++i)
  {
    if (erd_relations[i].done == true)
    {
      bool is_near= false;
      QLineF linef= QLineF(erd_relations[i].P1, erd_relations[i].P2);
      qreal linef_angle= linef.angle();
      QLineF bar_line;
      bar_line.setP1(mouse_point);
      bar_line.setLength(default_bar_line_length);
      QPointF intersection_point;
      bar_line.setAngle(linef_angle + 90);
#if (QT_VERSION >= 0x50f00)
      if (linef.intersects(bar_line, &intersection_point) == QLineF::BoundedIntersection) is_near= true;
#else
      if (linef.intersect(bar_line, &intersection_point) == QLineF::BoundedIntersection) is_near= true;
#endif
      else
      {
        bar_line.setAngle(linef_angle - 90);
#if (QT_VERSION >= 0x50f00)
        if (linef.intersects(bar_line, &intersection_point) == QLineF::BoundedIntersection) is_near= true;
#else
        if (linef.intersect(bar_line, &intersection_point) == QLineF::BoundedIntersection) is_near= true;
#endif
      }
      if (is_near == true)
      {
        bar_line.setP2(intersection_point);
        qreal distance= bar_line.length();
        if (distance < nearest_relation_distance)
        {
          nearest_relation= i;
          nearest_relation_distance= distance;
        }
      }
    }
  }
  if (nearest_relation != -1)
  {
    int i_of_explorer_item= erd_relations[nearest_relation].i_of_explorer_items_fk;
    QByteArray constraint_name= erd_mainwindow->oei_fk[i_of_explorer_item].constraint_name;
    char constraint_name_as_char[256];
    strcpy(constraint_name_as_char, constraint_name);
    sprintf(tooltip_char_string,"constraint_name = %s", constraint_name_as_char);
  }
  return tooltip_char_string;
}

/* ?? Todo: Check if the deletes should actually be done with ~ERDiagram() */
erd::~erd()
{
  if (erd_relations != NULL) delete [] erd_relations;
  if (erd_tables != NULL) delete [] erd_tables;
}


ERDiagram::ERDiagram(MainWindow *parent_mainwindow, QString passed_schema_name, QString query)
{
  erdiagram_mainwindow= parent_mainwindow;
  setWindowTitle("ERDIAGRAM OF " + passed_schema_name);
  /* I think setWidget() will give widget_erd a parent so we won't need to delete it later, i.e. no leak? */
  erd *widget_erd;
  widget_erd= new erd(this, parent_mainwindow, passed_schema_name, query);
  QScrollArea *scroll_1= new QScrollArea();
  scroll_1->setParent(this); /* unnecessary */
  scroll_1->setVisible(true);
  //scroll_1->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded); /* this is the default anyway */
  //scroll_1->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded); /* this is the default anywy */
  scroll_1->setWidget(widget_erd);
  QVBoxLayout *layout_1= new QVBoxLayout();
  button_for_ok= new QPushButton("OK");
  button_for_ok->setParent(this); /* unnecessary */
  connect(button_for_ok, SIGNAL(clicked()), this, SLOT(handle_button_for_ok()));
  layout_1->insertWidget(0, scroll_1);
  layout_1->insertWidget(1, button_for_ok);
  setLayout(layout_1);
  /* Todo: really width + height should consider scroll bars + actual height|width of heading + OK button */
  /* If we ask for too much, that should be okay, Qt will take over the screen for it */
  resize(widget_erd->width() + 38, widget_erd->height() + 60);
  return;
}

ERDiagram::~ERDiagram() /* This should also cause ~erd because erd has ERDiagram as a parent */
{
  ;
}
/* private slots: */

void ERDiagram::handle_button_for_ok()
{
  done(QDialog::Accepted); /* i.e. close() but return Accepted */
}

/******************** ERDiagram end ***********************************************/
#endif //if (OCELOT_ERDIAGRAM == 1)

/******************** CodeEditor start ***********************************************/

void CodeEditor::mousePressEvent(QMouseEvent *event)
{
  main_window->completer_widget->hide_wrapper();
  QPlainTextEdit::mousePressEvent(event);
}

/*
   Here is where we show a tooltip help hint e.g. "reserved keyword"
   if the user hovers with the mouse over a statement_edit_widget word.
   Beware: there is more than one CodeEditor.
   We only did setMouseTracking for statement_edit_widget.
   But make sure we're right.
   Beware: This won't work unless we're parsing.
   text= statement_edit_widget->toPlainText(); but maybe I won't care.
   Todo: Consider: QToolTip::showText() instead of setToolTip()
         (it would cause immediate change but might be distracting).
         (it would allow us to control duration with ocelot_ca.completer_timeout)
*/
void CodeEditor::mouseMoveEvent(QMouseEvent *event)
{
  if (((main_window->ocelot_statement_syntax_checker.toInt()) & FLAG_FOR_HIGHLIGHTS)
   && (main_window->main_token_max_count > 0)
   && (main_window->statement_edit_widget == this))
  {
    QPoint i= event->pos();
    QTextCursor c= this->cursorForPosition(i);
    int p= c.position();
    QString s= "";
    for (int i= 0; main_window->main_token_lengths[i] != 0; ++i)
    {
      int offset= main_window->main_token_offsets[i];
      if (offset > p) break;
      int length= main_window->main_token_lengths[i];
      if ((offset <= p) && ((offset+length) > p))
      {
        s= main_window->token_reftype(i, true, main_window->main_token_types[i], main_window->main_token_reftypes[i]);
        break;
      }
    }
    this->setToolTip(s);
  }
  /* We probably don't need to say this. */
  QPlainTextEdit::mouseMoveEvent(event);
}

/******************** CodeEditor end ***********************************************/

prompt_class::prompt_class(CodeEditor *editor) : QWidget(editor)
{
  codeEditor= editor;
}

QSize prompt_class::sizeHint() const
{
  return QSize(codeEditor->prompt_width_calculate(), 0);
}

void prompt_class::paintEvent(QPaintEvent *event)
{
  codeEditor->prompt_widget_paintevent(event);
}

QScrollAreaWithSize::QScrollAreaWithSize(int width, int height)
{
  settings_width= width;
  settings_height= height;
}

QSize QScrollAreaWithSize::sizeHint() const
{
  return QSize(settings_width, settings_height);
}

void QComboBoxInSettings::hidePopup()
{
  QComboBox::hidePopup();
  emit highlighted(-1);
}

/******************** Settings start ***********************************************/

/*
  (Put most comments about Settings in ocelotgui.h after the words THE SETTINGS WIDGET)
  Called from: Settings
  Pass: &combo_box_for_top|left|width|height or &combo_box_for_default
  Pass: current value
  Fill the box with defaults.
  Point to current value
*/
void Settings::combo_box_filler(QComboBox **addr_of_combo_box, QString current_value, bool is_for_default)
{
  int i_of_current_value;
  QString c= current_value.toLower();
  if (is_for_default)
  {
    (*addr_of_combo_box)->addItem("no");
    (*addr_of_combo_box)->addItem("yes");
  }
  else
  {
    (*addr_of_combo_box)->addItem("default");
    for (int i= 0; i <= 1500; i+= 10) (*addr_of_combo_box)->addItem(QString::number(i));
  }
  i_of_current_value= (*addr_of_combo_box)->findText(c);
  if (i_of_current_value == -1)
  {    (*addr_of_combo_box)->addItem(c);
    i_of_current_value= (*addr_of_combo_box)->findText(c);
  }
  (*addr_of_combo_box)->setCurrentIndex(i_of_current_value);
}

/*
  Pass: a combo_box_for_font_name item, which looks like family - weight [style]
  Return: family, weight, style
  Todo: There's another way: you could use QFontDatabase to get the weight given family and style,
        then whatever's left over must be the style. Apparently it's omitted if it's default though.
  Todo: There are some odd styles like "roman" and "book" in QFontDatabase, I don't know how to handle them.
*/
void Settings::combo_box_for_font_name_parse(QString name, QString *family, QString *weight, QString *style)
{
  QString family_candidate, weight_and_style_candidate, style_candidate, weight_candidate;
  name= name.toLower();
  int i_of_hyphen= name.indexOf(" - ");
  family_candidate= name.left(i_of_hyphen);

  weight_and_style_candidate= name.right(name.size() - (i_of_hyphen + 3));
  int i_of_space= weight_and_style_candidate.indexOf(" ");
  if (i_of_space == -1)
  {
    if ((weight_and_style_candidate == "italic") || (weight_and_style_candidate == "oblique"))
    {
      /* Todo: maybe regular? */
      weight_candidate= "normal"; /* huh? I guess it would be default weight, whatever that would be */
      style_candidate= weight_and_style_candidate;
    }
    else
    {
      weight_candidate= weight_and_style_candidate;
      style_candidate= "normal"; /* huh?  I guess it should be default style, whatever that would be */
    }
  }
  else
  {
    weight_candidate= weight_and_style_candidate.left(i_of_space);
    style_candidate= weight_and_style_candidate.right(weight_and_style_candidate.size() - (i_of_space + 1));
  }

  *family= family_candidate;
  *weight= weight_candidate;
  *style= style_candidate;

}

/*
  Pass: QFontDatabase-style family and style
  Return: our-style family and weight and style (family doesn't need to change). or ""
*/
int Settings::qt_style_to_our_style(QString qt_family, QString qt_style, QString *our_weight, QString *our_style)
{
  QFontDatabase font_database;
  int qt_weight= font_database.weight(qt_family, qt_style);
  if (qt_weight == -1) return -1;
  *our_weight= copy_of_parent->canonical_font_weight(QString::number(qt_weight));
  if (qt_style.contains("italic", Qt::CaseInsensitive)) *our_style= "italic";
  else if (qt_style.contains("oblique", Qt::CaseInsensitive)) *our_style= "oblique";
  else *our_style= "normal";
  return 0;
}

/*
  Populate Settings combo box for font name.
  See: Font comments
*/
int Settings::combo_box_for_font_name_filler(QString actual_font_family, QString actual_font_style, QString actual_font_weight)
{
  QFontDatabase font_database;
  combo_box_for_font_name->clear();

  //int this_font_point_size= this->font().pointSize();
  //QFont font(actual_font_family, this_font_point_size);
  //combo_box_for_font_name->setFont(font);

  QStringList font_families= font_database.families();

  int font_family_index= 0;
  int font_family_index_of_first_match= 0;
  int maximum_width= 0;
  for (int i= 0; i < font_families.size(); ++i)
  {
    bool is_match_found= false;
    QStringList font_styles= font_database.styles(font_families.at(i));
    QString our_weight, our_style;

    if (font_families.at(i) == actual_font_family) font_family_index_of_first_match= font_family_index;

    for (int j= 0; j < font_styles.size(); ++j)
    {
      qt_style_to_our_style(font_families.at(i), font_styles.at(j), &our_weight, &our_style);
      QString name= font_families.at(i) + " - " + our_weight + " " + our_style;

      combo_box_for_font_name->addItem(name);
      if (name.size() > maximum_width) maximum_width= name.size();

      //QString family, weight, style;
      //combo_box_for_font_name_parse(name, &family, &weight, &style);
      /* Next few lines would display item in item's font but I think they are too slow. */
      //bool is_italic= false;
      //if ((our_style == "italic") || (our_style == "oblique")) is_italic= true;
      //int fwi= copy_of_parent->fontweights_index_via_chars(weight);
      //QFont qf(family, this_font_point_size, fontweightsvalues[fwi].qt_number, is_italic);
      //combo_box_for_font_name->setItemData(font_family_index, qf, Qt::FontRole);
      if (font_families.at(i) == actual_font_family)
      {
        QString our_weight, our_style;
        qt_style_to_our_style(font_families.at(i), font_styles.at(j), &our_weight, &our_style);
        if ((our_weight == actual_font_weight) && (our_style == actual_font_style))
        {
          combo_box_for_font_name->setCurrentIndex(font_family_index);
          is_match_found= true;
        }
      }
      ++font_family_index;
    }
    if ((font_families.at(i) == actual_font_family) && (is_match_found == false))
    {
      /* family matches but weight|style. add a new entry if qfontinfo says it's possible. else use at(0) */
      bool italic= false;
      if (actual_font_style != "normal") italic= true;
      int fwi_a= copy_of_parent->fontweights_index_via_chars(actual_font_weight);
      int font_weight_as_int= fontweightsvalues[fwi_a].qt_number; /* e.g. if weight "300" we get 25 */
      QFont qf= QFont(font_families.at(i), -1, font_weight_as_int, italic);
      QFontInfo qfi= QFontInfo(qf);
      int fwi_o= copy_of_parent->fontweights_index_via_qt_number(qfi.weight());
      if (fwi_a == fwi_o)
      {
        QString name= font_families.at(i) + " - " + actual_font_weight + " " + actual_font_style;
        combo_box_for_font_name->addItem(name);
        combo_box_for_font_name->setCurrentIndex(font_family_index);
        ++font_family_index;
      }
      else combo_box_for_font_name->setCurrentIndex(font_family_index_of_first_match);
    }


  }
  return maximum_width;
}

/*
  Settings example on the right side of the font hbox
  Called initially or from the handlers for change of the first two colors, or change of the font.
  todo: border-color would be possible too
  todo: take size into account but with a scroll bar
  todo: remove margin
  todo: since we have an example, the time-consuming name combo box might be always the same font now
  todo: read-only so tab skips over it? or allow edit? or allow cut-and-paste?
  todo: check: is it safe to call this due to connect with color combo box before we know all values?
  Todo: let user change "Example" to an identifier and then show identifier highlight colour
  Todo: Or, show all highlight possibilities (and then we really need a scroll bar)
*/
void Settings::text_for_font_example_filler(QString text_color, QString background_color, QString font_family, QString font_style, QString font_weight, QString font_size)
{
  if (font_size.right(2) == "pt") font_size= font_size.left(font_size.size() - 2);
  text_for_font_example->setText("Example");
  QString style_sheet;
  copy_of_parent->make_one_style_string(&style_sheet,
                        text_color,
                        background_color,
                        "1",
                        "red",
                        font_family,
                        font_size,
                        font_style,
                        font_weight,
                        false);
  text_for_font_example->setStyleSheet(style_sheet);
}

void Settings::combo_box_for_font_size_filler(QString actual_font_size)
{
  QFontDatabase font_database;

  QStringList font_families= font_database.families();
  QList<int> big_list;

  big_list.clear();
  for (int i= 0; i < font_families.size(); ++i)
  {
    QStringList font_styles= font_database.styles(font_families.at(i));
    for (int j= 0; j < font_styles.size(); ++j)
    {
      QList<int> point_sizes= font_database.pointSizes(font_families.at(i), font_styles.at(j));
      for (int k= 0; k < point_sizes.count(); ++k)
      {
        int k_item= point_sizes.at(k);
        int l= 0;
        for (; l < big_list.count(); ++l)
        {
          if (k_item == big_list.at(l)) break;
          if (k_item < big_list.at(l)) { big_list.insert(l, k_item); break; }
        }
        if (l >= big_list.count()) big_list.append(k_item);
      }
    }
  }
  for (int i= 0; i < big_list.size(); ++i)
  {
    int j= big_list.at(i);
    if ((j < FONT_SIZE_MIN) || (j > FONT_SIZE_MAX)) continue;
    QString s= QString::number(j) + "pt";
    combo_box_for_font_size->addItem(s);
  }
  int actual_font_size_as_int= actual_font_size.toInt();
  font_size_index_set(actual_font_size_as_int);

}

/* TODO: probably some memory is leaking. I don't say "(this)" every time I say "new". */
Settings::Settings(int passed_widget_number, MainWindow *parent): QDialog(parent) /* constructor */
{
  /*
    KLUDGE ALERT: menu_strings_menu_font_copy is a kludge.
    Windows build fails if menu_strings[menu_off + MENU_FONT] appears
    in label_for_font_dialog_set_text, or if MENU_FONT is used at all.
    Change the assert in ocelotgui.cpp if MENU_FONT changes in ostrings.h.
  */
  menu_strings_menu_font_copy= menu_strings[menu_off + 99];

  int settings_width, settings_height;

  /* settings = new QWidget(this); ... this might come later */

  copy_of_parent= parent;                                /* handle_button_for_ok() might use this */
  current_widget= passed_widget_number;

  /* Copy the parent's settings. They'll be copied back to the parent, possibly changed, if the user presses OK. */
  copy_of_parent->new_ocelot_menu_text_color= copy_of_parent->ocelot_menu_text_color;
  copy_of_parent->new_ocelot_menu_background_color= copy_of_parent->ocelot_menu_background_color;
  copy_of_parent->new_ocelot_menu_border_color= copy_of_parent->ocelot_menu_border_color;
  copy_of_parent->new_ocelot_menu_font_family= copy_of_parent->ocelot_menu_font_family;
  copy_of_parent->new_ocelot_menu_font_size= copy_of_parent->ocelot_menu_font_size;
  copy_of_parent->new_ocelot_menu_font_style= copy_of_parent->ocelot_menu_font_style;
  copy_of_parent->new_ocelot_menu_font_weight= copy_of_parent->ocelot_menu_font_weight;

  copy_of_parent->new_ocelot_history_text_color= copy_of_parent->ocelot_history_text_color;
  copy_of_parent->new_ocelot_history_background_color= copy_of_parent->ocelot_history_background_color;
  copy_of_parent->new_ocelot_history_border_color= copy_of_parent->ocelot_history_border_color;
  copy_of_parent->new_ocelot_history_font_family= copy_of_parent->ocelot_history_font_family;
  copy_of_parent->new_ocelot_history_font_size= copy_of_parent->ocelot_history_font_size;
  copy_of_parent->new_ocelot_history_font_style= copy_of_parent->ocelot_history_font_style;
  copy_of_parent->new_ocelot_history_font_weight= copy_of_parent->ocelot_history_font_weight;
  copy_of_parent->new_ocelot_history_max_row_count= copy_of_parent->ocelot_history_max_row_count;
  copy_of_parent->new_ocelot_history_height= copy_of_parent->ocelot_history_height;
  copy_of_parent->new_ocelot_history_left= copy_of_parent->ocelot_history_left;
  copy_of_parent->new_ocelot_history_top= copy_of_parent->ocelot_history_top;
  copy_of_parent->new_ocelot_history_width= copy_of_parent->ocelot_history_width;
  copy_of_parent->new_ocelot_history_detached= copy_of_parent->ocelot_history_detached;

  copy_of_parent->new_ocelot_grid_text_color= copy_of_parent->ocelot_grid_text_color;
  copy_of_parent->new_ocelot_grid_background_color= copy_of_parent->ocelot_grid_background_color;
  copy_of_parent->new_ocelot_grid_focus_cell_background_color= copy_of_parent->ocelot_grid_focus_cell_background_color;
  copy_of_parent->new_ocelot_grid_header_background_color= copy_of_parent->ocelot_grid_header_background_color;
  copy_of_parent->new_ocelot_grid_font_family= copy_of_parent->ocelot_grid_font_family;
  copy_of_parent->new_ocelot_grid_font_size= copy_of_parent->ocelot_grid_font_size;
  copy_of_parent->new_ocelot_grid_font_style= copy_of_parent->ocelot_grid_font_style;
  copy_of_parent->new_ocelot_grid_font_weight= copy_of_parent->ocelot_grid_font_weight;
  copy_of_parent->new_ocelot_grid_cell_border_color= copy_of_parent->ocelot_grid_cell_border_color;
  copy_of_parent->new_ocelot_grid_outer_color= copy_of_parent->ocelot_grid_outer_color;
  copy_of_parent->new_ocelot_grid_cell_border_size= copy_of_parent->ocelot_grid_cell_border_size;
  copy_of_parent->new_ocelot_grid_cell_width= copy_of_parent->ocelot_grid_cell_width;
  copy_of_parent->new_ocelot_grid_cell_height= copy_of_parent->ocelot_grid_cell_height;
//  copy_of_parent->new_ocelot_grid_cell_drag_line_size= copy_of_parent->ocelot_grid_cell_drag_line_size;
  copy_of_parent->new_ocelot_grid_height= copy_of_parent->ocelot_grid_height;
  copy_of_parent->new_ocelot_grid_left= copy_of_parent->ocelot_grid_left;
  copy_of_parent->new_ocelot_grid_top= copy_of_parent->ocelot_grid_top;
  copy_of_parent->new_ocelot_grid_width= copy_of_parent->ocelot_grid_width;
  copy_of_parent->new_ocelot_grid_html_effects= copy_of_parent->ocelot_grid_html_effects;
  copy_of_parent->new_ocelot_grid_detached= copy_of_parent->ocelot_grid_detached;

  copy_of_parent->new_ocelot_extra_rule_1_text_color= copy_of_parent->ocelot_extra_rule_1_text_color;
  copy_of_parent->new_ocelot_extra_rule_1_background_color= copy_of_parent->ocelot_extra_rule_1_background_color;
  copy_of_parent->new_ocelot_extra_rule_1_condition= copy_of_parent->ocelot_extra_rule_1_condition;
  copy_of_parent->new_ocelot_extra_rule_1_display_as= copy_of_parent->ocelot_extra_rule_1_display_as;

  copy_of_parent->new_ocelot_statement_text_color= copy_of_parent->ocelot_statement_text_color;
  copy_of_parent->new_ocelot_statement_background_color= copy_of_parent->ocelot_statement_background_color;
  copy_of_parent->new_ocelot_statement_border_color= copy_of_parent->ocelot_statement_border_color;
  copy_of_parent->new_ocelot_statement_font_family= copy_of_parent->ocelot_statement_font_family;
  copy_of_parent->new_ocelot_statement_font_size= copy_of_parent->ocelot_statement_font_size;
  copy_of_parent->new_ocelot_statement_font_style= copy_of_parent->ocelot_statement_font_style;
  copy_of_parent->new_ocelot_statement_font_weight= copy_of_parent->ocelot_statement_font_weight;
  copy_of_parent->new_ocelot_statement_highlight_literal_color= copy_of_parent->ocelot_statement_highlight_literal_color;
  copy_of_parent->new_ocelot_statement_highlight_identifier_color= copy_of_parent->ocelot_statement_highlight_identifier_color;
  copy_of_parent->new_ocelot_statement_highlight_comment_color= copy_of_parent->ocelot_statement_highlight_comment_color;
  copy_of_parent->new_ocelot_statement_highlight_operator_color= copy_of_parent->ocelot_statement_highlight_operator_color;
  copy_of_parent->new_ocelot_statement_highlight_keyword_color= copy_of_parent->ocelot_statement_highlight_keyword_color;
  copy_of_parent->new_ocelot_statement_prompt_background_color= copy_of_parent->ocelot_statement_prompt_background_color;
  copy_of_parent->new_ocelot_statement_highlight_current_line_color= copy_of_parent->ocelot_statement_highlight_current_line_color;
  copy_of_parent->new_ocelot_statement_highlight_function_color= copy_of_parent->ocelot_statement_highlight_function_color;
  copy_of_parent->new_ocelot_statement_syntax_checker= copy_of_parent->ocelot_statement_syntax_checker;
  copy_of_parent->new_ocelot_statement_height= copy_of_parent->ocelot_statement_height;
  copy_of_parent->new_ocelot_statement_left= copy_of_parent->ocelot_statement_left;
  copy_of_parent->new_ocelot_statement_top= copy_of_parent->ocelot_statement_top;
  copy_of_parent->new_ocelot_statement_width= copy_of_parent->ocelot_statement_width;
  copy_of_parent->new_ocelot_statement_detached= copy_of_parent->ocelot_statement_detached;

  copy_of_parent->new_ocelot_debug_height= copy_of_parent->ocelot_debug_height;
  copy_of_parent->new_ocelot_debug_left= copy_of_parent->ocelot_debug_left;
  copy_of_parent->new_ocelot_debug_top= copy_of_parent->ocelot_debug_top;
  copy_of_parent->new_ocelot_debug_width= copy_of_parent->ocelot_debug_width;
  copy_of_parent->new_ocelot_debug_detached= copy_of_parent->ocelot_debug_detached;

#if (OCELOT_EXPLORER == 1)
  copy_of_parent->new_ocelot_explorer_height= copy_of_parent->ocelot_explorer_height;
  copy_of_parent->new_ocelot_explorer_left= copy_of_parent->ocelot_explorer_left;
  copy_of_parent->new_ocelot_explorer_top= copy_of_parent->ocelot_explorer_top;
  copy_of_parent->new_ocelot_explorer_width= copy_of_parent->ocelot_explorer_width;
  copy_of_parent->new_ocelot_explorer_detached= copy_of_parent->ocelot_explorer_detached;
  copy_of_parent->new_ocelot_explorer_visible= copy_of_parent->ocelot_explorer_visible;
  copy_of_parent->new_ocelot_explorer_sort= copy_of_parent->ocelot_explorer_sort;
  copy_of_parent->new_ocelot_explorer_query= copy_of_parent->ocelot_explorer_query;
  copy_of_parent->new_ocelot_explorer_text_color= copy_of_parent->ocelot_explorer_text_color;
  copy_of_parent->new_ocelot_explorer_background_color= copy_of_parent->ocelot_explorer_background_color;
  copy_of_parent->new_ocelot_explorer_font_family= copy_of_parent->ocelot_explorer_font_family;
  copy_of_parent->new_ocelot_explorer_font_size= copy_of_parent->ocelot_explorer_font_size;
  copy_of_parent->new_ocelot_explorer_font_style= copy_of_parent->ocelot_explorer_font_style;
  copy_of_parent->new_ocelot_explorer_font_weight= copy_of_parent->ocelot_explorer_font_weight;
#endif

  {
    QString s;
    if (current_widget == MAIN_WIDGET) s= menu_strings[menu_off + MENU_SETTINGS_FOR_MENU];
    if (current_widget == HISTORY_WIDGET) s= menu_strings[menu_off + MENU_SETTINGS_FOR_HISTORY];
    if (current_widget == GRID_WIDGET) s= menu_strings[menu_off + MENU_SETTINGS_FOR_GRID];
    if (current_widget == STATEMENT_WIDGET) s= menu_strings[menu_off + MENU_SETTINGS_FOR_STATEMENT];
#if (OCELOT_MYSQL_DEBUGGER == 1)
    if (current_widget == DEBUG_WIDGET) s= menu_strings[menu_off + MENU_SETTINGS_FOR_DEBUG];
#endif
    if (current_widget == EXTRA_RULE_1) s= menu_strings[menu_off + MENU_SETTINGS_FOR_EXTRA_RULE_1];
#if (OCELOT_EXPLORER == 1)
    if (current_widget == EXPLORER_WIDGET) s= menu_strings[menu_off + MENU_SETTINGS_FOR_EXPLORER];
#endif
    setWindowTitle(s);                                                /* affects "this"] */
  }

  /* Todo: following calculation should actually be width of largest tr(label) + approximately 5. */
  int label_for_color_width= this->fontMetrics().boundingRect("W").width();
#if (OCELOT_MYSQL_DEBUGGER == 1)
if (current_widget != DEBUG_WIDGET)
#endif
{
  /* Hboxes for foreground, background, and highlights */

  /* Icons for all the colors. Todo: dynamic size. I expect about 150. */
  QPixmap pixmaps[512];
  QIcon icons[512];
  int i_of_icons;
  for (i_of_icons= 0; i_of_icons < copy_of_parent->q_color_list.size() / 2; ++i_of_icons)
  {
    pixmaps[i_of_icons]= QPixmap(100, 100);
    pixmaps[i_of_icons].fill(QColor(copy_of_parent->q_color_list[(i_of_icons * 2) + 1]));
    icons[i_of_icons]= pixmaps[i_of_icons];
  }

  for (int ci= 0; ci < 11; ++ci)
  {
    widget_for_color[ci]= new QWidget(this);
    label_for_color[ci]= new QLabel();
    label_for_color_rgb[ci]= new QLabel();
    combo_box_for_color_pick[ci]= new QComboBox(this);
    {
      /*
        When theme = CleanLooks or GTK+, the non-editable combobox's list view has no scroll bar.
        Finding the problem and putting in this one-line solution took 20 man-hours.
      */
      combo_box_for_color_pick[ci]->view()->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
      int i_44;
      for (i_44= 0; i_44 < copy_of_parent->q_color_list.size() / 2; ++i_44)
      {
        combo_box_for_color_pick[ci]->addItem(icons[i_44], copy_of_parent->q_color_list[(i_44 * 2)]);
      }
    }

    label_for_color_show[ci]= new QLabel(this);
    set_widget_values(ci);
    label_for_color[ci]->setFixedWidth(label_for_color_width * MAX_COLOR_NAME_WIDTH);
    //label_for_color_rgb[ci]->setFixedWidth(label_for_color_width * 12);
    label_for_color_rgb[ci]->setFixedWidth(this->fontMetrics().boundingRect("LightGoldenrodYellow").width());
    //label_for_color_show[ci]->setEnabled(false);
    label_for_color_show[ci]->setMinimumWidth(40);
    hbox_layout_for_color[ci]= new QHBoxLayout();
    hbox_layout_for_color[ci]->addWidget(label_for_color[ci]);
    hbox_layout_for_color[ci]->addWidget(label_for_color_rgb[ci]);
    hbox_layout_for_color[ci]->addWidget(label_for_color_show[ci]);
    hbox_layout_for_color[ci]->addWidget(combo_box_for_color_pick[ci]);
    widget_for_color[ci]->setLayout(hbox_layout_for_color[ci]);
  }
  connect(combo_box_for_color_pick[0], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_0(int)));
  connect(combo_box_for_color_pick[1], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_1(int)));
  connect(combo_box_for_color_pick[2], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_2(int)));
  connect(combo_box_for_color_pick[3], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_3(int)));
  connect(combo_box_for_color_pick[4], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_4(int)));
  connect(combo_box_for_color_pick[5], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_5(int)));
  connect(combo_box_for_color_pick[6], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_6(int)));
  connect(combo_box_for_color_pick[7], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_7(int)));
  connect(combo_box_for_color_pick[8], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_8(int)));
  connect(combo_box_for_color_pick[9], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_9(int)));
  connect(combo_box_for_color_pick[10],SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_10(int)));

  widget_font_label= new QLabel("");

  /* Hbox -- the font picker */

  widget_for_font_dialog= new QWidget(this);

  label_for_font_dialog= new QLabel(this);
  label_for_font_dialog_set_text();

  hbox_layout_for_font_dialog= new QHBoxLayout();
  hbox_layout_for_font_dialog->addWidget(label_for_font_dialog);
  /* New font dialog start */
  {
    {

      if (current_widget == STATEMENT_WIDGET)
      {
        actual_font_family= copy_of_parent->connect_stripper(copy_of_parent->new_ocelot_statement_font_family, false);
        actual_font_size= copy_of_parent->new_ocelot_statement_font_size;
        actual_font_style= copy_of_parent->new_ocelot_statement_font_style;
        actual_font_weight= copy_of_parent->new_ocelot_statement_font_weight;
      }
      if (current_widget == GRID_WIDGET)
      {
        actual_font_family= copy_of_parent->connect_stripper(copy_of_parent->new_ocelot_grid_font_family, false);
        actual_font_size= copy_of_parent->new_ocelot_grid_font_size;
        actual_font_style= copy_of_parent->new_ocelot_grid_font_style;
        actual_font_weight= copy_of_parent->new_ocelot_grid_font_weight;
      }
      if (current_widget == HISTORY_WIDGET)
      {
        actual_font_family= copy_of_parent->connect_stripper(copy_of_parent->new_ocelot_history_font_family, false);
        actual_font_size= copy_of_parent->new_ocelot_history_font_size;
        actual_font_style= copy_of_parent->new_ocelot_history_font_style;
        actual_font_weight= copy_of_parent->new_ocelot_history_font_weight;
      }
      if (current_widget == MAIN_WIDGET)
      {
        actual_font_family= copy_of_parent->connect_stripper(copy_of_parent->new_ocelot_menu_font_family, false);
        actual_font_size= copy_of_parent->new_ocelot_menu_font_size;
        actual_font_style= copy_of_parent->new_ocelot_menu_font_style;
        actual_font_weight= copy_of_parent->new_ocelot_menu_font_weight;
      }
#if (OCELOT_EXPLORER == 1)
      if (current_widget == EXPLORER_WIDGET)
      {
        actual_font_family= copy_of_parent->connect_stripper(copy_of_parent->new_ocelot_explorer_font_family, false);
        actual_font_size= copy_of_parent->new_ocelot_explorer_font_size;
        actual_font_style= copy_of_parent->new_ocelot_explorer_font_style;
        actual_font_weight= copy_of_parent->new_ocelot_explorer_font_weight;
      }
#endif
      /* todo: what if it's extra widget? */

      combo_box_for_font_name= new QComboBoxInSettings(); /* Should I say "this"? */
      combo_box_for_font_name->view()->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
      /* todo: this used to be: */
      /* int maximum_width= combo_box_for_font_name_filler(actual_font_family, actual_font_style, actual_font_weight); */
      /* QString maximum_value= QString("X").repeated(maximum_width); */
      /* ... changed because maximum_value is set later. But was there good reason for the pre-change code? */
      combo_box_for_font_name_filler(actual_font_family, actual_font_style, actual_font_weight);
      QString maximum_value;
      /* Todo: what you really need is width(maximum # of characters) + scroll bar width */
      //combo_box_for_font_name->setFixedWidth(this->fontMetrics().boundingRect(maximum_value).width());

      combo_box_for_font_size= new QComboBoxInSettings();
      combo_box_for_font_size_filler(actual_font_size);
      maximum_value= "WWWWWW"; /* Todo: this does use scroll bar width but can still be too small */
      combo_box_for_font_size->setFixedWidth(this->fontMetrics().boundingRect(maximum_value).width()
                                             + style()->pixelMetric(QStyle::PM_ScrollBarExtent)
                                             + 4);

      text_for_font_example= new QLabel();
      handle_combo_box_for_any_highlighted(-1, -1); /* to fill in the example widget initially */

      hbox_layout_for_font_dialog->addWidget(combo_box_for_font_name);
      hbox_layout_for_font_dialog->addWidget(combo_box_for_font_size);
      hbox_layout_for_font_dialog->addWidget(text_for_font_example);
    }

    //hbox_layout_for_font_dialog->addWidget(combo_box_for_font_size);
    connect(combo_box_for_font_name, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_font_name_change(int)));
    connect(combo_box_for_font_name, SIGNAL(highlighted(int)), this, SLOT(handle_combo_box_for_font_name_highlighted(int)));
    connect(combo_box_for_font_size, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_font_size_change(int)));
    connect(combo_box_for_font_size, SIGNAL(highlighted(int)), this, SLOT(handle_combo_box_for_font_size_highlighted(int)));

  }
  /* New font dialog end */
  widget_for_font_dialog->setLayout(hbox_layout_for_font_dialog);

  if (current_widget == STATEMENT_WIDGET)
  {
    widget_for_syntax_checker= new QWidget(this);
    label_for_syntax_checker= new QLabel(menu_strings[menu_off + MENU_SYNTAX_CHECKER]);
    combo_box_for_syntax_checker= new QComboBox();
    combo_box_for_syntax_checker->setFixedWidth(label_for_color_width * 3);
    for (int cj= 0; cj <= 7; ++cj) combo_box_for_syntax_checker->addItem(QString::number(cj)); /* assume OCELOT_EXTENDER == 1 */
    combo_box_for_syntax_checker->setCurrentIndex(copy_of_parent->new_ocelot_statement_syntax_checker.toInt());
    hbox_layout_for_syntax_checker= new QHBoxLayout();
    hbox_layout_for_syntax_checker->addWidget(label_for_syntax_checker);
    hbox_layout_for_syntax_checker->addWidget(combo_box_for_syntax_checker);
    widget_for_syntax_checker->setLayout(hbox_layout_for_syntax_checker);
    connect(combo_box_for_syntax_checker, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_syntax_check(int)));
  }

  if (current_widget == HISTORY_WIDGET)
  {
    widget_for_max_row_count= new QWidget(this);
    label_for_max_row_count= new QLabel(menu_strings[menu_off + MENU_MAX_ROW_COUNT]);
    spin_box_for_max_row_count= new QSpinBox();
    spin_box_for_max_row_count->setFixedWidth(label_for_color_width * 5);
    spin_box_for_max_row_count->setMaximum(99999);
    spin_box_for_max_row_count->setMinimum(0);
    spin_box_for_max_row_count->setValue(copy_of_parent->ocelot_history_max_row_count.toInt());
    spin_box_for_max_row_count->setButtonSymbols( QAbstractSpinBox::NoButtons);
    hbox_layout_for_max_row_count= new QHBoxLayout();
    hbox_layout_for_max_row_count->addWidget(label_for_max_row_count);
    hbox_layout_for_max_row_count->addWidget(spin_box_for_max_row_count);
    widget_for_max_row_count->setLayout(hbox_layout_for_max_row_count);
    connect(spin_box_for_max_row_count, SIGNAL(valueChanged(int)), this, SLOT(handle_spin_box_for_max_row_count(int)));
  }

  if (current_widget == GRID_WIDGET)
  {
    /* int label_for_size_width= this->fontMetrics().boundingRect("W").width(); */
    for (int ci= 0; ci < 3; ++ci)
    {
      widget_for_size[ci]= new QWidget(this);
      if (ci == 0) label_for_size[ci]= new QLabel(menu_strings[menu_off + MENU_GRID_CELL_HEIGHT]);
      if (ci == 1) label_for_size[ci]= new QLabel(menu_strings[menu_off + MENU_GRID_CELL_BORDER_SIZE]);
      if (ci == 2) label_for_size[ci]= new QLabel(menu_strings[menu_off + MENU_GRID_CELL_WIDTH]);
      combo_box_for_size[ci]= new QComboBox();
      if (ci == 0)
      {
        combo_box_for_size[ci]->setFixedWidth(label_for_color_width * 10);
        QString current_value= copy_of_parent->ocelot_grid_cell_height;
        combo_box_filler(&combo_box_for_size[0], current_value, false);
        label_for_size[ci]->setFixedWidth(label_for_color_width * MAX_COLOR_NAME_WIDTH);
      }
      if (ci == 1)
      {
        combo_box_for_size[ci]->setFixedWidth(label_for_color_width * 3);
        for (int cj= 0; cj < 10; ++cj) combo_box_for_size[ci]->addItem(QString::number(cj));
        label_for_size[ci]->setFixedWidth(label_for_color_width * MAX_COLOR_NAME_WIDTH);
      }
      if (ci == 2)
      {
        combo_box_for_size[ci]->setFixedWidth(label_for_color_width * 10);
        QString current_value= copy_of_parent->ocelot_grid_cell_width;
        combo_box_filler(&combo_box_for_size[2], current_value, false);
        label_for_size[ci]->setFixedWidth(label_for_color_width * MAX_COLOR_NAME_WIDTH);
      }

      // if (ci == 0) combo_box_filler should handle this
      if (ci == 1) combo_box_for_size[1]->setCurrentIndex(copy_of_parent->new_ocelot_grid_cell_border_size.toInt());
      // if (ci == 2) combo_box_filler() should handle this
      hbox_layout_for_size[ci]= new QHBoxLayout();
      hbox_layout_for_size[ci]->addWidget(label_for_size[ci]);
      hbox_layout_for_size[ci]->addWidget(combo_box_for_size[ci]);
      widget_for_size[ci]->setLayout(hbox_layout_for_size[ci]);
    }

    connect(combo_box_for_size[0], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_size_0(int)));
    connect(combo_box_for_size[1], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_size_1(int)));
    connect(combo_box_for_size[2], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_size_2(int)));

  }
}
if (current_widget == GRID_WIDGET)
{
  QString current_value;
  widget_for_html_effects= new QWidget(this);
  label_for_html_effects= new QLabel(menu_strings[menu_off + MENU_GRID_HTML_EFFECTS]);
  combo_box_for_html_effects= new QComboBox();
  current_value= copy_of_parent->ocelot_grid_html_effects;
  combo_box_filler(&combo_box_for_html_effects, current_value, true);
  hbox_layout_for_html_effects= new QHBoxLayout();
  hbox_layout_for_html_effects->addWidget(label_for_html_effects);
  hbox_layout_for_html_effects->addWidget(combo_box_for_html_effects);
  widget_for_html_effects->setLayout(hbox_layout_for_html_effects);
  connect(combo_box_for_html_effects, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_html_effects(int)));
}

#if (OCELOT_EXPLORER == 1)
  if (current_widget == EXPLORER_WIDGET)
  {
    widget_for_size[0]= new QWidget(this);
    label_for_size[0]= new QLabel("Visible");
    combo_box_for_size[0]= new QComboBox();
    combo_box_for_size[0]->addItem("no");
    combo_box_for_size[0]->addItem("yes");
    combo_box_for_size[0]->setCurrentIndex(combo_box_for_size[0]->findText(copy_of_parent->new_ocelot_explorer_visible));
    hbox_layout_for_size[0]= new QHBoxLayout();
    hbox_layout_for_size[0]->addWidget(label_for_size[0]);
    hbox_layout_for_size[0]->addWidget(combo_box_for_size[0]);
    widget_for_size[0]->setLayout(hbox_layout_for_size[0]);
    connect(combo_box_for_size[0], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_size_0(int)));
    widget_for_size[1]= new QWidget(this);
    label_for_size[1]= new QLabel("Sort alphabetically");
    combo_box_for_size[1]= new QComboBox();
    combo_box_for_size[1]->addItem("no");
    combo_box_for_size[1]->addItem("yes");
    combo_box_for_size[1]->setCurrentIndex(combo_box_for_size[1]->findText(copy_of_parent->new_ocelot_explorer_sort));
    hbox_layout_for_size[1]= new QHBoxLayout();
    hbox_layout_for_size[1]->addWidget(label_for_size[1]);
    hbox_layout_for_size[1]->addWidget(combo_box_for_size[1]);
    widget_for_size[1]->setLayout(hbox_layout_for_size[1]);
    connect(combo_box_for_size[1], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_size_1(int)));
    widget_for_size[2]= new QWidget(this);
    label_for_size[2]= new QLabel("Query");
    text_for_query= new QTextEdit;
    text_for_query->setText(copy_of_parent->new_ocelot_explorer_query);
    combo_box_for_size[2]= new QComboBox();
    hbox_layout_for_size[2]= new QHBoxLayout();
    hbox_layout_for_size[2]->addWidget(label_for_size[2]);
    hbox_layout_for_size[2]->addWidget(text_for_query);
    widget_for_size[2]->setLayout(hbox_layout_for_size[2]);
    /* For some reason I don't get a signal for this, so I'll assume change and do things in handle_button_for_ok */
    //connect(combo_box_for_size[2], SIGNAL(currentTextChanged(QString)), this, SLOT(handle_text_changed(QString)));
  }
#endif

  if ((current_widget == HISTORY_WIDGET) || (current_widget == GRID_WIDGET)
#if (OCELOT_EXPLORER == 1)
   || (current_widget == EXPLORER_WIDGET)
#endif
   || (current_widget == STATEMENT_WIDGET) || (current_widget == DEBUG_WIDGET))
  {
    QString current_value;

    widget_for_detached= new QWidget(this);
    label_for_detached= new QLabel(menu_strings[menu_off + MENU_DETACHED]);
    combo_box_for_detached= new QComboBox();
    if (current_widget == HISTORY_WIDGET)
      current_value= copy_of_parent->ocelot_history_detached;
    else if (current_widget == GRID_WIDGET)
      current_value= copy_of_parent->ocelot_grid_detached;
    else if (current_widget == STATEMENT_WIDGET)
      current_value= copy_of_parent->ocelot_statement_detached;
#if (OCELOT_EXPLORER == 1)
    else if (current_widget == EXPLORER_WIDGET)
      current_value= copy_of_parent->ocelot_explorer_detached;
#endif
    else
      current_value= copy_of_parent->ocelot_debug_detached;
    combo_box_filler(&combo_box_for_detached, current_value, true);
    hbox_layout_for_detached= new QHBoxLayout();
    hbox_layout_for_detached->addWidget(label_for_detached);
    hbox_layout_for_detached->addWidget(combo_box_for_detached);
    widget_for_detached->setLayout(hbox_layout_for_detached);
    connect(combo_box_for_detached, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_detached(int)));

    widget_for_top= new QWidget(this);
    label_for_top= new QLabel(menu_strings[menu_off + MENU_TOP]);
    combo_box_for_top= new QComboBox();
    if (current_widget == HISTORY_WIDGET)
      current_value= copy_of_parent->ocelot_history_top;
    else if (current_widget == GRID_WIDGET)
      current_value= copy_of_parent->ocelot_grid_top;
    else if (current_widget == STATEMENT_WIDGET)
      current_value= copy_of_parent->ocelot_statement_top;
#if (OCELOT_EXPLORER == 1)
    else if (current_widget == EXPLORER_WIDGET)
      current_value= copy_of_parent->ocelot_explorer_top;
#endif
    else
      current_value= copy_of_parent->ocelot_debug_top;
    combo_box_filler(&combo_box_for_top, current_value, false);
    hbox_layout_for_detached->addWidget(label_for_top);
    hbox_layout_for_detached->addWidget(combo_box_for_top);
    connect(combo_box_for_top, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_top(int)));

    widget_for_left= new QWidget(this);
    label_for_left= new QLabel(menu_strings[menu_off + MENU_LEFT]);
    combo_box_for_left= new QComboBox();
    if (current_widget == HISTORY_WIDGET)
      current_value= copy_of_parent->ocelot_history_left;
    else if (current_widget == GRID_WIDGET)
      current_value= copy_of_parent->ocelot_grid_left;
    else if (current_widget == STATEMENT_WIDGET)
      current_value= copy_of_parent->ocelot_statement_left;
#if (OCELOT_EXPLORER == 1)
    else if (current_widget == EXPLORER_WIDGET)
      current_value= copy_of_parent->ocelot_explorer_left;
#endif
    else
      current_value= copy_of_parent->ocelot_debug_left;
    combo_box_filler(&combo_box_for_left, current_value, false);
    hbox_layout_for_detached->addWidget(label_for_left);
    hbox_layout_for_detached->addWidget(combo_box_for_left);
    connect(combo_box_for_left, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_left(int)));

    widget_for_width= new QWidget(this);
    label_for_width= new QLabel(menu_strings[menu_off + MENU_WIDTH]);
    combo_box_for_width= new QComboBox;
    if (current_widget == HISTORY_WIDGET)
      current_value= copy_of_parent->ocelot_history_width;
    else if (current_widget == GRID_WIDGET)
      current_value= copy_of_parent->ocelot_grid_width;
    else if (current_widget == STATEMENT_WIDGET)
      current_value= copy_of_parent->ocelot_statement_width;
#if (OCELOT_EXPLORER == 1)
    else if (current_widget == EXPLORER_WIDGET)
      current_value= copy_of_parent->ocelot_explorer_width;
#endif
    else
      current_value= copy_of_parent->ocelot_debug_width;
    combo_box_filler(&combo_box_for_width, current_value, false);
    hbox_layout_for_detached->addWidget(label_for_width);
    hbox_layout_for_detached->addWidget(combo_box_for_width);
    connect(combo_box_for_width, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_width(int)));

    widget_for_height= new QWidget(this);
    label_for_height= new QLabel(menu_strings[menu_off + MENU_HEIGHT]);
    combo_box_for_height= new QComboBox;
    if (current_widget == HISTORY_WIDGET)
      current_value= copy_of_parent->ocelot_history_height;
    else if (current_widget == GRID_WIDGET)
      current_value= copy_of_parent->ocelot_grid_height;
    else if (current_widget == STATEMENT_WIDGET)
      current_value= copy_of_parent->ocelot_statement_height;
#if (OCELOT_EXPLORER == 1)
    else if (current_widget == EXPLORER_WIDGET)
      current_value= copy_of_parent->ocelot_explorer_height;
#endif
    else
      current_value= copy_of_parent->ocelot_debug_height;
    combo_box_filler(&combo_box_for_height, current_value, false);
    hbox_layout_for_detached->addWidget(label_for_height);
    hbox_layout_for_detached->addWidget(combo_box_for_height);
    connect(combo_box_for_height, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_height(int)));
  }
  if (current_widget == EXTRA_RULE_1)
  {
    widget_for_size[0]= new QWidget(this);
    label_for_size[0]= new QLabel(menu_strings[menu_off + MENU_CONDITION]);
    combo_box_for_size[0]= new QComboBox();
    //combo_box_for_size[0]->setFixedWidth(label_for_color_width * 30);
/*
    I'd like to be specific, but until there's a lot of time to spare,
    let's go with just two options: LIKE '%BLOB' and LIKE '%BINARY'.
    combo_box_for_size[0]->addItem("");
    combo_box_for_size[0]->addItem("data_type = 'BIT'");
    combo_box_for_size[0]->addItem("data_type = 'TINYINT'");
    combo_box_for_size[0]->addItem("data_type = 'SMALLINT'");
    combo_box_for_size[0]->addItem("data_type = 'MEDIUMINT'");
    combo_box_for_size[0]->addItem("data_type = 'INT'");
    combo_box_for_size[0]->addItem("data_type = 'BIGINT'");
    combo_box_for_size[0]->addItem("data_type = 'DECIMAL'");
    combo_box_for_size[0]->addItem("data_type = 'NUMERIC'");
    combo_box_for_size[0]->addItem("data_type = 'FLOAT'");
    combo_box_for_size[0]->addItem("data_type = 'DOUBLE'");
    combo_box_for_size[0]->addItem("data_type = 'DATE'");
    combo_box_for_size[0]->addItem("data_type = 'DATETIME'");
    combo_box_for_size[0]->addItem("data_type = 'TIMESTAMP'");
    combo_box_for_size[0]->addItem("data_type = 'TIME'");
    combo_box_for_size[0]->addItem("data_type = 'CHAR'");
    combo_box_for_size[0]->addItem("data_type = 'VARCHAR'");
    combo_box_for_size[0]->addItem("data_type = 'BINARY'");
    combo_box_for_size[0]->addItem("data_type = 'VARBINARY'");
    combo_box_for_size[0]->addItem("data_type = 'TINYBLOB'");
    combo_box_for_size[0]->addItem("data_type = 'TINYTEXT'");
    combo_box_for_size[0]->addItem("data_type = 'BLOB'");
    combo_box_for_size[0]->addItem("data_type = 'TEXT'");
    combo_box_for_size[0]->addItem("data_type = 'MEDIUMBLOB'");
    combo_box_for_size[0]->addItem("data_type = 'MEDIUMTEXT'");
    combo_box_for_size[0]->addItem("data_type = 'LONGBLOB'");
    combo_box_for_size[0]->addItem("data_type = 'LONGTEXT'");
    combo_box_for_size[0]->addItem("data_type = 'ENUM'");
    combo_box_for_size[0]->addItem("data_type = 'SET'");
*/
    combo_box_for_size[0]->addItem("");
    combo_box_for_size[0]->addItem("data_type LIKE '%BLOB'");
    combo_box_for_size[0]->addItem("data_type LIKE '%BINARY'");
    //label_for_size[0]->setFixedWidth(label_for_color_width * 30);
    combo_box_for_size[0]->setCurrentIndex(combo_box_for_size[0]->findText(copy_of_parent->new_ocelot_extra_rule_1_condition));

    hbox_layout_for_size[0]= new QHBoxLayout();
    hbox_layout_for_size[0]->addWidget(label_for_size[0]);
    hbox_layout_for_size[0]->addWidget(combo_box_for_size[0]);
    widget_for_size[0]->setLayout(hbox_layout_for_size[0]);
    connect(combo_box_for_size[0], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_size_0(int)));
    widget_for_size[1]= new QWidget(this);
    label_for_size[1]= new QLabel(menu_strings[menu_off + MENU_DISPLAY_AS]);
    combo_box_for_size[1]= new QComboBox();
    //combo_box_for_size[1]->setFixedWidth(label_for_color_width * 30);
    combo_box_for_size[1]->addItem("char");
    combo_box_for_size[1]->addItem("image");
    //combo_box_for_size[1]->addItem("hex");
    //combo_box_for_size[1]->addItem("number");
    //label_for_size[1]->setFixedWidth(label_for_color_width * 30);
    combo_box_for_size[1]->setCurrentIndex(combo_box_for_size[1]->findText(copy_of_parent->new_ocelot_extra_rule_1_display_as));
    hbox_layout_for_size[1]= new QHBoxLayout();
    hbox_layout_for_size[1]->addWidget(label_for_size[1]);
    hbox_layout_for_size[1]->addWidget(combo_box_for_size[1]);
    widget_for_size[1]->setLayout(hbox_layout_for_size[1]);
    connect(combo_box_for_size[1], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_size_1(int)));
  }
  /* The Cancel and OK buttons */
  widget_3= new QWidget(this);
  button_for_cancel= new QPushButton(menu_strings[menu_off + MENU_CANCEL], this);
  button_for_ok= new QPushButton(menu_strings[menu_off + MENU_OK], this);
  /* I have no idea why SLOT(accept() and SLOT(reject() cause crashes. The crashes can be worked around. */
  connect(button_for_ok, SIGNAL(clicked()), this, SLOT(handle_button_for_ok()));
  connect(button_for_cancel, SIGNAL(clicked()), this, SLOT(handle_button_for_cancel()));
  hbox_layout_3= new QHBoxLayout();
  hbox_layout_3->addWidget(button_for_cancel);
  hbox_layout_3->addWidget(button_for_ok);
  widget_3->setLayout(hbox_layout_3);
  /* Put the HBoxes in a VBox */
  main_layout= new QVBoxLayout();
#if (OCELOT_MYSQL_DEBUGGER == 1)
  if (current_widget != DEBUG_WIDGET)
#endif
  {
    for (int ci= 0; ci < 11; ++ci) main_layout->addWidget(widget_for_color[ci]);
    main_layout->addWidget(widget_font_label);
    main_layout->addWidget(widget_for_font_dialog);
    if (current_widget == STATEMENT_WIDGET) main_layout->addWidget(widget_for_syntax_checker);
    if (current_widget == GRID_WIDGET) for (int ci= 0; ci < 3; ++ci) main_layout->addWidget(widget_for_size[ci]);
    if (current_widget == HISTORY_WIDGET)
      main_layout->addWidget(widget_for_max_row_count);
  }
  if (current_widget == GRID_WIDGET)
  {
    main_layout->addWidget(widget_for_html_effects);
  }
#if (OCELOT_EXPLORER == 1)
  if (current_widget == EXPLORER_WIDGET) main_layout->addWidget(widget_for_size[0]);
  if (current_widget == EXPLORER_WIDGET) main_layout->addWidget(widget_for_size[1]);
  if (current_widget == EXPLORER_WIDGET) main_layout->addWidget(widget_for_size[2]);
#endif
  if ((current_widget == HISTORY_WIDGET) || (current_widget == GRID_WIDGET)
#if (OCELOT_EXPLORER == 1)
   || (current_widget == EXPLORER_WIDGET)
#endif
   || (current_widget == STATEMENT_WIDGET) || (current_widget == DEBUG_WIDGET))
  {
    main_layout->addWidget(widget_for_detached);
    //main_layout->addWidget(widget_for_top);
    //main_layout->addWidget(widget_for_left);
    //main_layout->addWidget(widget_for_width);
    //main_layout->addWidget(widget_for_height);
  }
  if (current_widget == EXTRA_RULE_1) main_layout->addWidget(widget_for_size[0]);
  if (current_widget == EXTRA_RULE_1) main_layout->addWidget(widget_for_size[1]);
  main_layout->addWidget(widget_3);
  if (current_widget != DEBUG_WIDGET) handle_combo_box_1(current_widget);
  /*
    If one merely says
    this->setLayout(main_layout);
    that almost always works because the dialog box fits within the
    typical screen area. But if it doesn't, e.g. 640x480 display, we need a scroll bar.
    Additional problem: sizeHint() seems to work for horizontal but not for vertical,
    which is why the setMinimumHeight line exists.
  */
  this->setLayout(main_layout);
  main_layout->activate();
  settings_width= this->width() + 20; /* todo: 20 is arbitrary */
  settings_height= this->height() + 20; /* todo: 20 is arbitrary */
  QWidget *widget_with_main_layout= new QWidget();
  widget_with_main_layout->setLayout(main_layout);
  QScrollAreaWithSize *scroll_area= new QScrollAreaWithSize(settings_width, settings_height);
  scroll_area->setWidget(widget_with_main_layout);
  QHBoxLayout *scroll_area_layout= new QHBoxLayout();
  scroll_area_layout->addWidget(widget_with_main_layout);
  scroll_area->setLayout(scroll_area_layout);
  scroll_area->setWidgetResizable(true);
  QHBoxLayout *upper_layout= new QHBoxLayout();
  upper_layout->addWidget(scroll_area);
  setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
  //if (parent->main_window_maximum_width > settings_width) setMinimumWidth(settings_width);
  if (parent->main_window_maximum_height > settings_height) setMinimumHeight(settings_height);
  setLayout(upper_layout);
}

/* private: */

/* We call set_widget_values() when we're doing "new Settings" (in which case current_widget == what-was-passed) */
void Settings::set_widget_values(int ci)
{
  QString color_type;
  QString color_name;

  if (current_widget == STATEMENT_WIDGET)
  {
    switch (ci)
    {
    case 0: { color_type= menu_strings[menu_off + MENU_STATEMENT_TEXT_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_text_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 1: { color_type= menu_strings[menu_off + MENU_STATEMENT_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 2: { color_type= menu_strings[menu_off + MENU_STATEMENT_HIGHLIGHT_LITERAL_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_highlight_literal_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 3: { color_type= menu_strings[menu_off + MENU_STATEMENT_HIGHLIGHT_IDENTIFIER_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_highlight_identifier_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 4: { color_type= menu_strings[menu_off + MENU_STATEMENT_HIGHLIGHT_COMMENT_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_highlight_comment_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 5: { color_type= menu_strings[menu_off + MENU_STATEMENT_HIGHLIGHT_OPERATOR_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_highlight_operator_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 6: { color_type= menu_strings[menu_off + MENU_STATEMENT_HIGHLIGHT_KEYWORD_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_highlight_keyword_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 7: { color_type= menu_strings[menu_off + MENU_STATEMENT_PROMPT_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_prompt_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 8: { color_type= menu_strings[menu_off + MENU_STATEMENT_BORDER_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_border_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 9: { color_type= menu_strings[menu_off + MENU_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_highlight_current_line_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 10:{ color_type= menu_strings[menu_off + MENU_STATEMENT_HIGHLIGHT_FUNCTION_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_highlight_function_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    }
  }
  if (current_widget == GRID_WIDGET)
  {
    switch (ci)
    {
    case 0: { color_type= menu_strings[menu_off + MENU_GRID_TEXT_COLOR];
              color_name= copy_of_parent->new_ocelot_grid_text_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 1: { color_type= menu_strings[menu_off + MENU_GRID_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_grid_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 2: { color_type= menu_strings[menu_off + MENU_GRID_CELL_BORDER_COLOR];
              color_name= copy_of_parent->new_ocelot_grid_cell_border_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 3: { color_type= menu_strings[menu_off + MENU_GRID_OUTER_COLOR];
              color_name= copy_of_parent->new_ocelot_grid_outer_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 7: { color_type= menu_strings[menu_off + MENU_GRID_HEADER_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_grid_header_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 8: { color_type= menu_strings[menu_off + MENU_GRID_FOCUS_CELL_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_grid_focus_cell_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    }
  }
  if (current_widget == EXTRA_RULE_1)
  {
    switch (ci)
    {
    case 0: { color_type= menu_strings[menu_off + MENU_GRID_TEXT_COLOR];
              color_name= copy_of_parent->new_ocelot_extra_rule_1_text_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 1: { color_type= menu_strings[menu_off + MENU_GRID_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_extra_rule_1_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    }
  }
  if (current_widget == HISTORY_WIDGET)
  {
    switch (ci)
    {
    case 0: { color_type= menu_strings[menu_off + MENU_HISTORY_TEXT_COLOR];
              color_name= copy_of_parent->new_ocelot_history_text_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 1: { color_type= menu_strings[menu_off + MENU_HISTORY_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_history_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 8: { color_type= menu_strings[menu_off + MENU_HISTORY_BORDER_COLOR];
              color_name= copy_of_parent->new_ocelot_history_border_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    }
  }
  if (current_widget == MAIN_WIDGET)
  {
    switch (ci)
    {
    case 0: { color_type= menu_strings[menu_off + MENU_MENU_TEXT_COLOR];
              color_name= copy_of_parent->new_ocelot_menu_text_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 1: { color_type= menu_strings[menu_off + MENU_MENU_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_menu_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 8: { color_type= menu_strings[menu_off + MENU_MENU_BORDER_COLOR];
              color_name= copy_of_parent->new_ocelot_menu_border_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    }
  }
#if (OCELOT_EXPLORER == 1)
  if (current_widget == EXPLORER_WIDGET)
  {
    switch (ci)
    {
    case 0: { color_type= "Explorer Text Color";
              color_name= copy_of_parent->new_ocelot_explorer_text_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 1: { color_type= "Explorer Background Color";
              color_name= copy_of_parent->new_ocelot_explorer_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    }
  }
#endif
  label_for_color[ci]->setText(color_type);
  //label_for_color_rgb[ci]->setText(color_name);
  int cli;
  /* Todo: This is a very roundabout way to get the color index. */
  cli= q_color_list_index(copy_of_parent->rgb_to_color(color_name));
  combo_box_for_color_pick[ci]->setCurrentIndex(cli);
  label_for_color_rgb[ci]->setText(combo_box_for_color_pick[ci]->currentText());
  QString sss= "border: 1px solid black; background-color: ";
  sss.append(copy_of_parent->qt_color(color_name));
  label_for_color_show[ci]->setStyleSheet(sss);
}

/*
  Todo: Only statement has highlights (I suppose the other controls
  could have highlights too, but regard that as a low priority todo).
  I tried setEnabled(false|true) but think hide|show looks better.
*/
void Settings::handle_combo_box_1(int i)
{
  int ci;
  QString color_type;

  current_widget= i;

  for (ci= 0; ci < 11; ++ci) set_widget_values(ci);
  if (i == STATEMENT_WIDGET)
  {
    color_type= menu_strings[menu_off + MENU_STATEMENT_PROMPT_BACKGROUND_COLOR]; /* necessary even though set_widget_values() does it */
    label_for_color[7]->setText(color_type);
//    for (ci= 2; ci < 11 ; ++ci)
//    {
//      label_for_color[ci]->show();
//      label_for_color_rgb[ci]->show();
//      label_for_color_show[ci]->show();
//      combo_box_for_color_pick[ci]->show();
//    }
  }

  /*
    This is a change for version 1.5.
    Instead of hiding/showing color components, we assume show() and remove widgets that have the components
    i.e. label_for_color[] label_for_color_rgb[] label_for_color_show[] combo_box_for_color_pick[] aren't
    addressed by the box they are in -- widget_for_color[] -- goes out if main_layout if it's not needed.
  */
  if (i == GRID_WIDGET)
  {
    color_type= menu_strings[menu_off + MENU_GRID_HEADER_BACKGROUND_COLOR];  /* necessary even though set_widget_values() does it */
    label_for_color[7]->setText(color_type);
    widget_for_color[4]->hide();
    widget_for_color[5]->hide();
    widget_for_color[6]->hide();
    widget_for_color[9]->hide();
    widget_for_color[10]->hide();
    main_layout->removeWidget(widget_for_color[4]);
    main_layout->removeWidget(widget_for_color[5]);
    main_layout->removeWidget(widget_for_color[6]);
    main_layout->removeWidget(widget_for_color[9]);
    main_layout->removeWidget(widget_for_color[10]);
  }
  if (i == EXTRA_RULE_1)
  {
    for (ci= 2; ci < 11; ++ci)
    {
      widget_for_color[ci]->hide();
      main_layout->removeWidget(widget_for_color[ci]);
    }
    widget_font_label->hide();
    label_for_font_dialog->hide();
    combo_box_for_font_name->hide();
    combo_box_for_font_size->hide();
    text_for_font_example->hide();
  }
  if ((i == HISTORY_WIDGET) || (i == MAIN_WIDGET) || (i == EXPLORER_WIDGET))
  {
    widget_for_color[2]->hide();
    widget_for_color[3]->hide();
    widget_for_color[4]->hide();
    widget_for_color[5]->hide();
    widget_for_color[6]->hide();
    widget_for_color[7]->hide();
    widget_for_color[9]->hide();
    widget_for_color[10]->hide();
    main_layout->removeWidget(widget_for_color[2]);
    main_layout->removeWidget(widget_for_color[3]);
    main_layout->removeWidget(widget_for_color[4]);
    main_layout->removeWidget(widget_for_color[5]);
    main_layout->removeWidget(widget_for_color[6]);
    main_layout->removeWidget(widget_for_color[7]);
    main_layout->removeWidget(widget_for_color[9]);
    main_layout->removeWidget(widget_for_color[10]);
  }
#if (OCELOT_EXPLORER == 1)
  if (i == EXPLORER_WIDGET)
  {
    widget_for_color[8]->hide();
    main_layout->removeWidget(widget_for_color[8]);
  }
#endif
}

void Settings::label_for_font_dialog_set_text()
{
  QString s_for_label_for_font_dialog= menu_strings_menu_font_copy;
  if (current_widget == STATEMENT_WIDGET)
  {
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_statement_font_family);
    s_for_label_for_font_dialog.append(" ");
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_statement_font_size);
    s_for_label_for_font_dialog.append("pt");
    if (QString::compare(copy_of_parent->new_ocelot_statement_font_weight, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_statement_font_weight);
    }
    if (QString::compare(copy_of_parent->new_ocelot_statement_font_style, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_statement_font_style);
    }
  }

  if (current_widget == GRID_WIDGET)
  {
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_grid_font_family);
    s_for_label_for_font_dialog.append(" ");
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_grid_font_size);
    s_for_label_for_font_dialog.append("pt");
    if (QString::compare(copy_of_parent->new_ocelot_grid_font_weight, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_grid_font_weight);
    }
    if (QString::compare(copy_of_parent->new_ocelot_grid_font_style, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_grid_font_style);
    }
  }

  if (current_widget == HISTORY_WIDGET)
  {
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_history_font_family);
    s_for_label_for_font_dialog.append(" ");
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_history_font_size);
    s_for_label_for_font_dialog.append("pt");
    if (QString::compare(copy_of_parent->new_ocelot_history_font_weight, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_history_font_weight);
    }
    if (QString::compare(copy_of_parent->new_ocelot_history_font_style, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_history_font_style);
    }
  }

  if (current_widget == MAIN_WIDGET)
  {
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_menu_font_family);
    s_for_label_for_font_dialog.append(" ");
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_menu_font_size);
    s_for_label_for_font_dialog.append("pt");
    if (QString::compare(copy_of_parent->new_ocelot_menu_font_weight, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_menu_font_weight);
    }
    if (QString::compare(copy_of_parent->new_ocelot_menu_font_style, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_menu_font_style);
    }
  }

#if (OCELOT_EXPLORER == 1)
  if (current_widget == EXPLORER_WIDGET)
  {
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_explorer_font_family);
    s_for_label_for_font_dialog.append(" ");
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_explorer_font_size);
    s_for_label_for_font_dialog.append("pt");
    if (QString::compare(copy_of_parent->new_ocelot_explorer_font_weight, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_explorer_font_weight);
    }
    if (QString::compare(copy_of_parent->new_ocelot_explorer_font_style, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_explorer_font_style);
    }
  }
#endif

  label_for_font_dialog->setText(s_for_label_for_font_dialog);
}

/* private slots: */

/* If user clicks OK, end. The caller will move changed "new" settings to non-new. */
void Settings::handle_button_for_ok()
{
#if (OCELOT_EXPLORER == 1)
  if (current_widget == EXPLORER_WIDGET) copy_of_parent->new_ocelot_explorer_query= text_for_query->toPlainText();
#endif
  done(QDialog::Accepted); /* i.e. close() but return Accepted */
}

/* If user clicks Cancel, don't do anything, and end. */
void Settings::handle_button_for_cancel()
{
  done(QDialog::Rejected); /* i.e. close() but return Rejected */
}

/*
  For all the handle_combo_box_for_color_pick slots:
  We no longer use QColorDialog dialog box, instead there's a QComboBox.
  Why I didn't like QColorDialog ...
    For the "name:" control: if I typed in SkyBlue, it echoed as rrggbb,
    if I typed in Silver, it did nothing, and there was no clear list
    of what color names were available. For the other controls: I thought
    brightness/hue etc., and the color wheel, would put off intimidate users
    since they're not obvious and I expect typical users want names
    rather than numbers.
  The QComboBox for color picking gets around those problems but ...
  Todo: Make sure garbage_collect is working
  Todo: The Settings menu item  itself does not have the font or colors declared by settings menu
  Todo: There surely isn't any need for the blank lines -- so it's not a matter of "hide()", you just don't create
  Todo: You need to look harder at what Tab settings are (it's hard to see what the focus is for the combobox items
*/
void Settings::handle_combo_box_for_color_pick_0(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[0]->itemText(item_number);
    copy_of_parent->new_ocelot_statement_text_color= new_color;
    label_for_color_rgb[0]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[0]->setStyleSheet(s);
  }
  if (current_widget == GRID_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[0]->itemText(item_number);
    copy_of_parent->new_ocelot_grid_text_color= new_color;
    label_for_color_rgb[0]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[0]->setStyleSheet(s);
  }
  if (current_widget == EXTRA_RULE_1)
  {
    QString new_color= combo_box_for_color_pick[0]->itemText(item_number);
    copy_of_parent->new_ocelot_extra_rule_1_text_color= new_color;
    label_for_color_rgb[0]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[0]->setStyleSheet(s);
  }
  if (current_widget == HISTORY_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[0]->itemText(item_number);
    copy_of_parent->new_ocelot_history_text_color= new_color;
    label_for_color_rgb[0]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[0]->setStyleSheet(s);
  }
  if (current_widget == MAIN_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[0]->itemText(item_number);
    copy_of_parent->new_ocelot_menu_text_color= new_color;
    label_for_color_rgb[0]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[0]->setStyleSheet(s);
  }
#if (OCELOT_EXPLORER == 1)
  if (current_widget == EXPLORER_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[0]->itemText(item_number);
    copy_of_parent->new_ocelot_explorer_text_color= new_color;
    label_for_color_rgb[0]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[0]->setStyleSheet(s);
  }
#endif

  text_for_font_example_filler(label_for_color_rgb[0]->text(),
                               label_for_color_rgb[1]->text(),
                               actual_font_family,
                               actual_font_style,
                               actual_font_weight,
                               actual_font_size);

}

void Settings::handle_combo_box_for_color_pick_1(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[1]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_background_color= new_color;
    label_for_color_rgb[1]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[1]->setStyleSheet(s);
  }
  if (current_widget == GRID_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[1]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_grid_background_color= new_color;
    label_for_color_rgb[1]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[1]->setStyleSheet(s);
  }
  if (current_widget == EXTRA_RULE_1)
  {
    QString new_color= combo_box_for_color_pick[1]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_extra_rule_1_background_color= new_color;
    label_for_color_rgb[1]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[1]->setStyleSheet(s);
  }
  if (current_widget == HISTORY_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[1]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_history_background_color= new_color;
    label_for_color_rgb[1]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[1]->setStyleSheet(s);
  }
  if (current_widget == MAIN_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[1]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_menu_background_color= new_color;
    label_for_color_rgb[1]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[1]->setStyleSheet(s);
  }
#if (OCELOT_EXPLORER == 1)
  if (current_widget == EXPLORER_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[1]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_explorer_background_color= new_color;
    label_for_color_rgb[1]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[1]->setStyleSheet(s);
  }
#endif
  text_for_font_example_filler(label_for_color_rgb[0]->text(),
                               label_for_color_rgb[1]->text(),
                               actual_font_family,
                               actual_font_style,
                               actual_font_weight,
                               actual_font_size);

}

void Settings::handle_combo_box_for_color_pick_2(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[2]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_highlight_literal_color= new_color;
    label_for_color_rgb[2]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[2]->setStyleSheet(s);
  }

  if (current_widget == GRID_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[2]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_grid_cell_border_color= new_color;
    label_for_color_rgb[2]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[2]->setStyleSheet(s);
  }
}


void Settings::handle_combo_box_for_color_pick_3(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[3]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_highlight_identifier_color= new_color;
    label_for_color_rgb[3]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[3]->setStyleSheet(s);
  }

  if (current_widget == GRID_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[3]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_grid_outer_color= new_color;
    label_for_color_rgb[3]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[3]->setStyleSheet(s);
  }
}

void Settings::handle_combo_box_for_color_pick_4(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[4]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_highlight_comment_color= new_color;
    label_for_color_rgb[4]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[4]->setStyleSheet(s);
  }
}

void Settings::handle_combo_box_for_color_pick_5(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[5]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_highlight_operator_color= new_color;
    label_for_color_rgb[5]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[5]->setStyleSheet(s);
  }
}

void Settings::handle_combo_box_for_color_pick_6(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[6]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_highlight_keyword_color= new_color;
    label_for_color_rgb[6]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[6]->setStyleSheet(s);
  }
}

void Settings::handle_combo_box_for_color_pick_7(int item_number)
{
 if (current_widget == STATEMENT_WIDGET)
 {
   QString new_color= combo_box_for_color_pick[7]->itemText(item_number);
   new_color= copy_of_parent->canonical_color_name(new_color);
   copy_of_parent->new_ocelot_statement_prompt_background_color= new_color;
   label_for_color_rgb[7]->setText(copy_of_parent->rgb_to_color(new_color));
   QString s= "border: 1px solid black; background-color: ";
   s.append(copy_of_parent->qt_color(new_color));
   label_for_color_show[7]->setStyleSheet(s);
  }
  if (current_widget == GRID_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[7]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_grid_header_background_color= new_color;
    label_for_color_rgb[7]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[7]->setStyleSheet(s);
  }
}

void Settings::handle_combo_box_for_color_pick_8(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[8]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_border_color= new_color;
    label_for_color_rgb[8]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[8]->setStyleSheet(s);
  }
  if (current_widget == GRID_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[8]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_grid_focus_cell_background_color= new_color;
    label_for_color_rgb[8]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[8]->setStyleSheet(s);
  }
  if (current_widget == HISTORY_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[8]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_history_border_color= new_color;
    label_for_color_rgb[8]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[8]->setStyleSheet(s);
  }
  if (current_widget == MAIN_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[8]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_menu_border_color= new_color;
    label_for_color_rgb[8]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[8]->setStyleSheet(s);
  }
}

void Settings::handle_combo_box_for_color_pick_9(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[9]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_highlight_current_line_color= new_color;
    label_for_color_rgb[9]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[9]->setStyleSheet(s);
  }
}

void Settings::handle_combo_box_for_color_pick_10(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[10]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_highlight_function_color= new_color;
    label_for_color_rgb[10]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[10]->setStyleSheet(s);
  }
}

void Settings::handle_combo_box_for_font_any_change()
{
  QString *family= NULL;
  QString *size= NULL;
  QString *style= NULL;
  QString *weight= NULL;
  if (current_widget == STATEMENT_WIDGET)
  {
    family= &(copy_of_parent->new_ocelot_statement_font_family);
    size= &(copy_of_parent->new_ocelot_statement_font_size);
    style= &(copy_of_parent->new_ocelot_statement_font_style);
    weight= &(copy_of_parent->new_ocelot_statement_font_weight);
  }
  if (current_widget == GRID_WIDGET)
  {
    family= &(copy_of_parent->new_ocelot_grid_font_family);
    size= &(copy_of_parent->new_ocelot_grid_font_size);
    style= &(copy_of_parent->new_ocelot_grid_font_style);
    weight= &(copy_of_parent->new_ocelot_grid_font_weight);
  }
  if (current_widget == HISTORY_WIDGET)
  {
    family= &(copy_of_parent->new_ocelot_history_font_family);
    size= &(copy_of_parent->new_ocelot_history_font_size);
    style= &(copy_of_parent->new_ocelot_history_font_style);
    weight= &(copy_of_parent->new_ocelot_history_font_weight);
  }
  if (current_widget == MAIN_WIDGET)
  {
    family= &(copy_of_parent->new_ocelot_menu_font_family);
    size= &(copy_of_parent->new_ocelot_menu_font_size);
    style= &(copy_of_parent->new_ocelot_menu_font_style);
    weight= &(copy_of_parent->new_ocelot_menu_font_weight);
  }
#if (OCELOT_EXPLORER == 1)
  if (current_widget == EXPLORER_WIDGET)
  {
    family= &(copy_of_parent->new_ocelot_explorer_font_family);
    size= &(copy_of_parent->new_ocelot_explorer_font_size);
    style= &(copy_of_parent->new_ocelot_explorer_font_style);
    weight= &(copy_of_parent->new_ocelot_explorer_font_weight);
  }
#endif
  assert((family != NULL) && (style != NULL) && (weight != NULL) && (size != NULL));
  /* todo: just pass family, weight, style. no need for candidates */
  QString family_candidate, weight_candidate, style_candidate;
  combo_box_for_font_name_parse(combo_box_for_font_name->currentText(),
                                &family_candidate,
                                &weight_candidate,
                                &style_candidate);
  *family= family_candidate;
  *style= style_candidate;

  *weight= weight_candidate;

  QString ctu= combo_box_for_font_size->currentText();
  *size= ctu.left(ctu.size() - 2);

  text_for_font_example_filler(label_for_color_rgb[0]->text(),
                               label_for_color_rgb[1]->text(),
                               family_candidate,
                               style_candidate,
                               weight_candidate,
                               combo_box_for_font_size->currentText());
}

/*
  User changed one of the font dialog settings: name - weight style.
  Warning: something can return -1 if size was specified in pixels (whatever that means).
  We might set up so weight is either "bold" or "normal" but I don't want to contradict e.g. "Ubuntu Bold".
*/
void Settings::handle_combo_box_for_font_name_change(int i)
{
  (void)i;
  /* Hmm, won't this cause us to call handle_combo_box_for_any_change()? */
  QString family_candidate, weight_candidate, style_candidate;
  combo_box_for_font_name_parse(combo_box_for_font_name->currentText(),
                                &family_candidate,
                                &weight_candidate,
                                &style_candidate);
  handle_combo_box_for_font_any_change();
}

/* set combo_box_for_fontsize currentIndex = what's closest to actual size (might not be exact) */
void Settings::font_size_index_set(int actual_font_size_as_int)
{
  int index_of_closest_match= 0;
  {
    QString s;
    for (int j= 0; j < combo_box_for_font_size->count(); ++j)
    {
      int curr_as_int;
      s= combo_box_for_font_size->itemText(j);
      curr_as_int= s.left(s.size() - 2).toInt();
      int prev_as_int;
      if (j == 0) prev_as_int= -99999;
      else
      {
        s= combo_box_for_font_size->itemText(j - 1);
        prev_as_int= s.left(s.size() - 2).toInt();
      }
      bool is_between= false;
      if ((actual_font_size_as_int > prev_as_int) && (actual_font_size_as_int <= curr_as_int)) is_between= true;
      if (j == combo_box_for_font_size->count() - 1) is_between= true;
      if (is_between == true)
      {
        int diff_from_prev= actual_font_size_as_int - prev_as_int;
        int diff_from_curr= curr_as_int - actual_font_size_as_int;
        if (diff_from_prev < diff_from_curr)
        {
          index_of_closest_match= j - 1;
          break;
        }
        else
        {
          index_of_closest_match= j;
          break;
        }
      }
    }
  }
  combo_box_for_font_size->setCurrentIndex(index_of_closest_match);
}

/* User change one of the font dialog settings: size. */
void Settings::handle_combo_box_for_font_size_change(int i)
{
  if (i == -1) return; /* -1 can happen if box is cleared */
  handle_combo_box_for_font_any_change();
}

void Settings::handle_combo_box_for_any_highlighted(int i_of_font_name, int i_of_font_size)
{
  if (i_of_font_name == -1) i_of_font_name= combo_box_for_font_name->currentIndex();
  if (i_of_font_size == -1) i_of_font_size= combo_box_for_font_size->currentIndex();
  QString family_candidate, weight_candidate, style_candidate;
  QString text_of_font_name= combo_box_for_font_name->itemText(i_of_font_name);
  combo_box_for_font_name_parse(text_of_font_name,
                                &family_candidate,
                                &weight_candidate,
                                &style_candidate);
  QString text_of_font_size= combo_box_for_font_size->itemText(i_of_font_size);
  text_for_font_example_filler(label_for_color_rgb[0]->text(),
                               label_for_color_rgb[1]->text(),
                               family_candidate,
                               style_candidate,
                               weight_candidate,
                               text_of_font_size);
}

void Settings::handle_combo_box_for_font_name_highlighted(int i)
{
  handle_combo_box_for_any_highlighted(i, -1);
}

void Settings::handle_combo_box_for_font_size_highlighted(int i)
{
  handle_combo_box_for_any_highlighted(-1, i);
}

void Settings::handle_combo_box_for_syntax_check(int i)
{
  if (current_widget == STATEMENT_WIDGET)
    copy_of_parent->new_ocelot_statement_syntax_checker= QString::number(i);
}

void Settings::handle_spin_box_for_max_row_count(int i)
{
  if (current_widget == HISTORY_WIDGET)
    copy_of_parent->new_ocelot_history_max_row_count= QString::number(i);
}

void Settings::handle_combo_box_for_detached(int item_number)
{
  QString q= combo_box_for_detached->itemText(item_number);
  if (current_widget == HISTORY_WIDGET)
    copy_of_parent->new_ocelot_history_detached= q;
  else if (current_widget == GRID_WIDGET)
    copy_of_parent->new_ocelot_grid_detached= q;
  else if (current_widget == STATEMENT_WIDGET)
    copy_of_parent->new_ocelot_statement_detached= q;
#if (OCELOT_EXPLORER == 1)
  else if (current_widget == EXPLORER_WIDGET)
    copy_of_parent->new_ocelot_explorer_detached= q;
#endif
  else
    copy_of_parent->new_ocelot_debug_detached= q;
}

void Settings::handle_combo_box_for_html_effects(int item_number)
{
  QString q= combo_box_for_detached->itemText(item_number);
  copy_of_parent->new_ocelot_grid_html_effects= q;
}

void Settings::handle_combo_box_for_top(int item_number)
{
  QString q= combo_box_for_top->itemText(item_number);
  if (current_widget == HISTORY_WIDGET)
    copy_of_parent->new_ocelot_history_top= q;
  else if (current_widget == GRID_WIDGET)
    copy_of_parent->new_ocelot_grid_top= q;
  else if (current_widget == STATEMENT_WIDGET)
    copy_of_parent->new_ocelot_statement_top= q;
#if (OCELOT_EXPLORER == 1)
  else if (current_widget == EXPLORER_WIDGET)
    copy_of_parent->new_ocelot_explorer_top= q;
#endif
  else
    copy_of_parent->new_ocelot_debug_top= q;
}

void Settings::handle_combo_box_for_left(int item_number)
{
  QString q= combo_box_for_left->itemText(item_number);
  if (current_widget == HISTORY_WIDGET)
    copy_of_parent->new_ocelot_history_left= q;
  else if (current_widget == GRID_WIDGET)
    copy_of_parent->new_ocelot_grid_left= q;
  else if (current_widget == STATEMENT_WIDGET)
    copy_of_parent->new_ocelot_statement_left= q;
#if (OCELOT_EXPLORER == 1)
  else if (current_widget == EXPLORER_WIDGET)
    copy_of_parent->new_ocelot_explorer_left= q;
#endif
  else
    copy_of_parent->new_ocelot_debug_left= q;
}

void Settings::handle_combo_box_for_width(int item_number)
{
  QString q= combo_box_for_width->itemText(item_number);
  if (current_widget == HISTORY_WIDGET)
    copy_of_parent->new_ocelot_history_width= q;
  else if (current_widget == GRID_WIDGET)
    copy_of_parent->new_ocelot_grid_width= q;
  else if (current_widget == STATEMENT_WIDGET)
    copy_of_parent->new_ocelot_statement_width= q;
#if (OCELOT_EXPLORER == 1)
  else if (current_widget == EXPLORER_WIDGET)
    copy_of_parent->new_ocelot_explorer_width= q;
#endif
  else
    copy_of_parent->new_ocelot_debug_width= q;
}

void Settings::handle_combo_box_for_height(int item_number)
{
  QString q= combo_box_for_height->itemText(item_number);
  if (current_widget == HISTORY_WIDGET)
    copy_of_parent->new_ocelot_history_height= q;
  else if (current_widget == GRID_WIDGET)
    copy_of_parent->new_ocelot_grid_height= q;
  else if (current_widget == STATEMENT_WIDGET)
    copy_of_parent->new_ocelot_statement_height= q;
#if (OCELOT_EXPLORER == 1)
  else if (current_widget == EXPLORER_WIDGET)
    copy_of_parent->new_ocelot_explorer_height= q;
#endif
  else
    copy_of_parent->new_ocelot_debug_height= q;
}

void Settings::handle_combo_box_for_size_0(int i)
{
  if (current_widget == GRID_WIDGET)
    copy_of_parent->new_ocelot_grid_cell_height= combo_box_for_size[0]->itemText(i);
  if (current_widget == EXTRA_RULE_1)
    copy_of_parent->new_ocelot_extra_rule_1_condition= combo_box_for_size[0]->itemText(i);
#if (OCELOT_EXPLORER == 1)
  if (current_widget == EXPLORER_WIDGET)
    copy_of_parent->new_ocelot_explorer_visible= combo_box_for_size[0]->itemText(i);
#endif
}

void Settings::handle_combo_box_for_size_1(int i)
{
  if (current_widget == GRID_WIDGET)
    copy_of_parent->new_ocelot_grid_cell_border_size= QString::number(i);
  if (current_widget == EXTRA_RULE_1)
    copy_of_parent->new_ocelot_extra_rule_1_display_as= combo_box_for_size[1]->itemText(i);
#if (OCELOT_EXPLORER == 1)
  if (current_widget == EXPLORER_WIDGET)
    copy_of_parent->new_ocelot_explorer_sort= combo_box_for_size[1]->itemText(i);
#endif
}

void Settings::handle_combo_box_for_size_2(int item_number)
{
  QString q= combo_box_for_size[2]->itemText(item_number);
  copy_of_parent->new_ocelot_grid_cell_width= q;
}

/* See comment that begins with the words "Font comments" */
int Settings::get_font_weight_as_qfont_weight(QString font_weight_string)
{
  int i= copy_of_parent->fontweights_index_via_chars(font_weight_string);
  if (i != -1) return fontweightsvalues[i].qt_number;
  return QFont::Normal; /* This should never happen */
}

QFont::Style Settings::get_font_style_as_qfont_style(QString font_style_string)
{
  if (QString::compare(font_style_string, "italic", Qt::CaseInsensitive) == 0) return QFont::StyleItalic;
  if (QString::compare(font_style_string, "oblique", Qt::CaseInsensitive) == 0) return QFont::StyleOblique;
  return QFont::StyleNormal;
}

/*
  Given color name, return index.
  Todo: It can be tricky, if color name isn't in the current language.
*/
int Settings::q_color_list_index(QString color_name_string)
{
//  char color_name_string_as_utf8[64];
//  int color_name_string_len;

//  color_name_string_len= color_name_string.size();             /* See comment "UTF8 Conversion" */
//  memcpy(color_name_string_as_utf8, color_name_string.toUtf8().constData(), color_name_string_len);
//  color_name_string_as_utf8[color_name_string_len]= '\0';

  for (int i= 0; i < copy_of_parent->q_color_list.size(); i+= 2)
  {
    if (QString::compare(color_name_string, copy_of_parent->q_color_list[i], Qt::CaseInsensitive) == 0) return i / 2;
    if (QString::compare(color_name_string, copy_of_parent->q_color_list[i + 1], Qt::CaseInsensitive) == 0) return i / 2;
  }
  //return (i - 1) / 2;
  return 0;  /* TEST! */
}

/******************** Settings end ***********************************************/

QTabWidget48::QTabWidget48(QWidget *parent) : QTabWidget(parent) /* constructor */
{
  ;
}

QTabBar* QTabWidget48::tabBar() const
{
  return QTabWidget::tabBar();
}


TextEditHistory::TextEditHistory(MainWindow *parent) : QTextEdit(parent) /* constructor */
{
  main_window= parent;
}

void TextEditHistory::detach_start()
{
  installEventFilter(this);
}
void TextEditHistory::detach_stop()
{
  removeEventFilter(this);
}

bool TextEditHistory::eventFilter(QObject *obj, QEvent *event)
{
  return main_window->eventfilter_function(obj, event);
}

TextEditHistory::~TextEditHistory()
{
  ;
}

#ifndef XSETTINGS
#define XSETTINGS

XSettings::XSettings(MainWindow *parent)
{
  main_window= parent;
#ifndef NDEBUG
  int v_size;
  ocelot_variables= new ocelot_variable_keywords[TOKEN_KEYWORD__UTF8MB4]; /* just to get ocelot_variables_size */
  v_size= ocelot_variables_create();
  delete[] ocelot_variables;
  assert(v_size == OCELOT_VARIABLES_SIZE);
#endif //NDEBUG
  ocelot_variables= new ocelot_variable_keywords[OCELOT_VARIABLES_SIZE]; /* permanent */
  ocelot_variables_create();
}
/*
  We originally had a series of assignments here but in older distros there were warnings
  "Warning: extended initializer lists only available with -std=c++11 or -std=gnu++11"
  so we switched to this. 145 is OCELOT_VARIABLES_SIZE and we could reduce some caller code.
  We don't have ocelot_export in the list, I don't think it's needed.
  Note: We don't get here for OCELOT_MAX_CONDITIONS and maybe other things if execute_client_statement()
        checks for them first. So there's no use having them in the table at this time.
*/
int XSettings::ocelot_variables_create()
{
  static const ocelot_variable_keywords o_v[]=
  {
    {NULL, &ocelot_ca.batch,  1, 0, 0, TOKEN_KEYWORD_OCELOT_BATCH},
    {NULL, &ocelot_ca.client_side_functions,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_CLIENT_SIDE_FUNCTIONS},
    {NULL, &ocelot_ca.completer_timeout,  1000000, 0, 0, TOKEN_KEYWORD_OCELOT_COMPLETER_TIMEOUT},
    {&main_window->ocelot_dbms, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_DBMS},
    {&main_window->ocelot_debug_detached, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED},
    {&main_window->ocelot_debug_height, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_DEBUG_HEIGHT},
    {&main_window->ocelot_debug_left, NULL, 10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_DEBUG_LEFT},
    {&main_window->ocelot_debug_top, NULL, 10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_DEBUG_TOP},
    {&main_window->ocelot_debug_width, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_DEBUG_WIDTH},
    {&main_window->ocelot_explorer_action, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_ACTION},
    {&main_window->ocelot_explorer_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_EXPLORER, TOKEN_KEYWORD_OCELOT_EXPLORER_BACKGROUND_COLOR},
    {&main_window->ocelot_explorer_detached, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED},
    {&main_window->ocelot_explorer_font_family, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY, OCELOT_VARIABLE_ENUM_SET_FOR_EXPLORER, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_FAMILY},
    {&main_window->ocelot_explorer_font_size, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_SIZE, OCELOT_VARIABLE_ENUM_SET_FOR_EXPLORER, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_SIZE},
    {&main_window->ocelot_explorer_font_style, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_STYLE, OCELOT_VARIABLE_ENUM_SET_FOR_EXPLORER, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_STYLE},
    {&main_window->ocelot_explorer_font_weight, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT, OCELOT_VARIABLE_ENUM_SET_FOR_EXPLORER, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_WEIGHT},
    {&main_window->ocelot_explorer_height, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_HEIGHT},
    {&main_window->ocelot_explorer_left, NULL, 10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_LEFT},
    {&main_window->ocelot_explorer_text, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_TEXT},
    {&main_window->ocelot_explorer_text_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_EXPLORER, TOKEN_KEYWORD_OCELOT_EXPLORER_TEXT_COLOR},
    {&main_window->ocelot_explorer_top, NULL, 10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_TOP},
    {&main_window->ocelot_explorer_visible, NULL, -1, 0, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_VISIBLE},
    {&main_window->ocelot_explorer_width, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_WIDTH},
    {&main_window->ocelot_extra_rule_1_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_EXTRA_RULE_1, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_BACKGROUND_COLOR},
    {&main_window->ocelot_extra_rule_1_condition, NULL,  -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_EXTRA_RULE_1, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_CONDITION},
    {&main_window->ocelot_extra_rule_1_display_as, NULL,  -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_EXTRA_RULE_1, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_DISPLAY_AS},
    {&main_window->ocelot_extra_rule_1_text_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_EXTRA_RULE_1, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_TEXT_COLOR},
    {&main_window->ocelot_grid_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_BACKGROUND_COLOR},
    {&main_window->ocelot_grid_cell_border_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_COLOR},
    {&main_window->ocelot_grid_cell_border_size, NULL,  10, 0, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_SIZE},
    {&main_window->ocelot_grid_cell_height, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_GRID_CELL_HEIGHT},
    {&main_window->ocelot_grid_cell_width, NULL, -1, 0, 0, TOKEN_KEYWORD_OCELOT_GRID_CELL_WIDTH},
    {&main_window->ocelot_grid_chart, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_CHART},
    {&main_window->ocelot_grid_detached, NULL, -1, 0, 0, TOKEN_KEYWORD_OCELOT_GRID_DETACHED},
    {&main_window->ocelot_grid_focus_cell_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_FOCUS_CELL_BACKGROUND_COLOR},
    {&main_window->ocelot_grid_font_family, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_FONT_FAMILY},
    {&main_window->ocelot_grid_font_size, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_SIZE, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_FONT_SIZE},
    {&main_window->ocelot_grid_font_style, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_STYLE, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_FONT_STYLE},
    {&main_window->ocelot_grid_font_weight, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_FONT_WEIGHT},
    {&main_window->ocelot_grid_header_background_color, NULL, -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_HEADER_BACKGROUND_COLOR},
    {&main_window->ocelot_grid_height, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_GRID_HEIGHT},
    {&main_window->ocelot_grid_html_effects, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_GRID_HTML_EFFECTS},
    {&main_window->ocelot_grid_left, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_GRID_LEFT},
    {&main_window->ocelot_grid_outer_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_OUTER_COLOR},
    {NULL, &ocelot_ca.grid_tabs,  10000, 0, 0, TOKEN_KEYWORD_OCELOT_GRID_TABS},
    {&main_window->ocelot_grid_text_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_GRID, TOKEN_KEYWORD_OCELOT_GRID_TEXT_COLOR},
    {&main_window->ocelot_grid_top, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_GRID_TOP},
    {&main_window->ocelot_grid_width, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_GRID_WIDTH},
    {&main_window->ocelot_histfileflags, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_HISTFILEFLAGS},
    {&main_window->ocelot_histfilesize, NULL,  2000000000, 0, 0, TOKEN_KEYWORD_OCELOT_HISTFILESIZE},
    {&main_window->ocelot_history_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY, TOKEN_KEYWORD_OCELOT_HISTORY_BACKGROUND_COLOR},
    {&main_window->ocelot_history_border_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY, TOKEN_KEYWORD_OCELOT_HISTORY_BORDER_COLOR},
    {&main_window->ocelot_history_detached, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED},
    {&main_window->ocelot_history_font_family, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY, OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_FAMILY},
    {&main_window->ocelot_history_font_size, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_SIZE, OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_SIZE},
    {&main_window->ocelot_history_font_style, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_STYLE, OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_STYLE},
    {&main_window->ocelot_history_font_weight, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT, OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_WEIGHT},
    {&main_window->ocelot_history_height, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_HISTORY_HEIGHT},
    {&main_window->ocelot_history_left, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_HISTORY_LEFT},
    {&main_window->ocelot_history_max_row_count, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_HISTORY_MAX_ROW_COUNT},
    {&main_window->ocelot_history_text_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY, TOKEN_KEYWORD_OCELOT_HISTORY_TEXT_COLOR},
    {&main_window->ocelot_history_top, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_HISTORY_TOP},
    {&main_window->ocelot_history_width, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_HISTORY_WIDTH},
    {&main_window->ocelot_histsize, NULL,  10000, 0, 0, TOKEN_KEYWORD_OCELOT_HISTSIZE},
    {NULL,  &ocelot_ca.vertical,  1, 0, 0, TOKEN_KEYWORD_OCELOT_HORIZONTAL},
    {NULL, &ocelot_ca.html,  1, 0, 0, TOKEN_KEYWORD_OCELOT_HTML},
    {NULL, &ocelot_ca.html,  1, 0, 0, TOKEN_KEYWORD_OCELOT_HTMLRAW},
    {&main_window->ocelot_language, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_LANGUAGE},
    {NULL, &ocelot_ca.log_level,  10000, 0, 0, TOKEN_KEYWORD_OCELOT_LOG_LEVEL},
    {NULL, &ocelot_ca.max_conditions, MAX_MAX_CONDITIONS,  0, 0, TOKEN_KEYWORD_OCELOT_MAX_CONDITIONS},
    {&main_window->ocelot_menu_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_MENU, TOKEN_KEYWORD_OCELOT_MENU_BACKGROUND_COLOR},
    {&main_window->ocelot_menu_border_color, NULL,  -1, 0, 0, TOKEN_KEYWORD_OCELOT_MENU_BORDER_COLOR},
    {&main_window->ocelot_menu_font_family, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY, OCELOT_VARIABLE_ENUM_SET_FOR_MENU, TOKEN_KEYWORD_OCELOT_MENU_FONT_FAMILY},
    {&main_window->ocelot_menu_font_size, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_SIZE, OCELOT_VARIABLE_ENUM_SET_FOR_MENU, TOKEN_KEYWORD_OCELOT_MENU_FONT_SIZE},
    {&main_window->ocelot_menu_font_style, NULL, -1, OCELOT_VARIABLE_FLAG_SET_FONT_STYLE, OCELOT_VARIABLE_ENUM_SET_FOR_MENU, TOKEN_KEYWORD_OCELOT_MENU_FONT_STYLE},
    {&main_window->ocelot_menu_font_weight, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT, OCELOT_VARIABLE_ENUM_SET_FOR_MENU, TOKEN_KEYWORD_OCELOT_MENU_FONT_WEIGHT},
    {&main_window->ocelot_menu_text_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_MENU, TOKEN_KEYWORD_OCELOT_MENU_TEXT_COLOR},
    {NULL, &ocelot_ca.raw,  1, 0, 0, TOKEN_KEYWORD_OCELOT_RAW},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_AUTOCOMPLETE},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_BATCH},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_BREAKPOINT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_BAR},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_LINE},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_NONE},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_PIE},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_CLEAR},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_CONNECT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_CONTINUE},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_COPY},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_CUT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_DEBUG_EXIT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_EXECUTE},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_EXIT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_FIND},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_FORMAT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_NEXT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_PREVIOUS},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_HORIZONTAL},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_HTML},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_HTMLRAW},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_INFORMATION},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_KILL},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT_WINDOW},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_PASTE},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_PREVIOUS_WINDOW},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_RAW},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_REDO},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_CALL_STACK},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_SERVER_VARIABLES},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_USER_VARIABLES},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_VARIABLES},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_SELECT_ALL},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_STEP},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_UNDO},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_VERTICAL},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_XML},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMIN},
    {NULL, NULL, -1, 0, OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT, TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMOUT},
    {&main_window->ocelot_statement_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_BACKGROUND_COLOR},
    {&main_window->ocelot_statement_border_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_BORDER_COLOR},
    {&main_window->ocelot_statement_detached, NULL, -1, 0, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED},
    {&main_window->ocelot_statement_font_family, NULL, -1, OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_FAMILY},
    {&main_window->ocelot_statement_font_size, NULL, -1, OCELOT_VARIABLE_FLAG_SET_FONT_SIZE, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_SIZE},
    {&main_window->ocelot_statement_font_style, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_STYLE, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_STYLE},
    {&main_window->ocelot_statement_font_weight, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_WEIGHT},
    {&main_window->ocelot_statement_format_clause_indent, NULL,  8, 0, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_CLAUSE_INDENT},
    {&main_window->ocelot_statement_format_rule, NULL, -1, 0, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_RULE}, /* only used during connect */
    {&main_window->ocelot_statement_format_statement_indent, NULL, 8, 0, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_STATEMENT_INDENT},
    {&main_window->ocelot_statement_height, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HEIGHT},
    {&main_window->ocelot_statement_highlight_comment_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_COMMENT_COLOR},
    {&main_window->ocelot_statement_highlight_current_line_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR},
    {&main_window->ocelot_statement_highlight_function_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_FUNCTION_COLOR},
    {&main_window->ocelot_statement_highlight_identifier_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_IDENTIFIER_COLOR},
    {&main_window->ocelot_statement_highlight_keyword_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_KEYWORD_COLOR},
    {&main_window->ocelot_statement_highlight_literal_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_LITERAL_COLOR},
    {&main_window->ocelot_statement_highlight_operator_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_OPERATOR_COLOR},
    {&main_window->ocelot_statement_left, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_LEFT},
    {&main_window->ocelot_statement_prompt_background_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_PROMPT_BACKGROUND_COLOR},
    {&main_window->ocelot_statement_syntax_checker, NULL,  7, 0, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_SYNTAX_CHECKER}, /* assume OCELOT_EXTENDER == 1 */
    {&main_window->ocelot_statement_text_color, NULL,  -1, OCELOT_VARIABLE_FLAG_SET_COLOR, OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT, TOKEN_KEYWORD_OCELOT_STATEMENT_TEXT_COLOR},
    {&main_window->ocelot_statement_top, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_TOP},
    {&main_window->ocelot_statement_width, NULL,  10000, OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_WIDTH},
    {NULL, &ocelot_ca.vertical,  1, 0, 0, TOKEN_KEYWORD_OCELOT_VERTICAL},
    {NULL, &ocelot_ca.xml,  1, 0, 0, TOKEN_KEYWORD_OCELOT_XML}
  };
  int i= 145;
  assert(sizeof(o_v) == sizeof(struct ocelot_variable_keywords) * i);
  memcpy(ocelot_variables, o_v, sizeof(o_v));
  return i;
}

/*
  Todo: in execute_client_statement() we make sure not to call this if WHERE follows, but we don't check during connect.
*/
int XSettings::ocelot_variable_set(int keyword_index, QString new_value)
{
  int offset= ocelot_variable_offset(keyword_index);
  if (offset == -1) return ER_OVERFLOW;
  bool is_font_changed= false;
  QString qv;
  if (keyword_index == TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_CONDITION) qv= main_window->connect_stripper(new_value, true);
  else qv= main_window->connect_stripper(new_value, false);
  char flags_style= ocelot_variables[offset].flags_style;
  char enums_for= ocelot_variables[offset].enums_for;
  QString *qstring_target= ocelot_variables[offset].qstring_target;
  short unsigned int *int_target= ocelot_variables[offset].int_target;
  int maximum= ocelot_variables[offset].maximum;
  if (maximum != -1)
  {
    bool is_digits= true;
    if (qv == "") is_digits= false;
    else for (int i= 0; i < qv.size(); ++i) {if (qv[i].isDigit() == false) is_digits= false; }
    if ((is_digits == false) || (qv.toInt() > maximum))
    {
      if (QString::compare(qv, "default", Qt::CaseInsensitive) == 0) qv= "default";
      if ((flags_style != OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE) || (qv != "default"))
      {
        int er= ER_ILLEGAL_VALUE; /* default = most common */
        if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_SYNTAX_CHECKER) er= ER_SYNTAX;
        if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_STATEMENT_INDENT) er= ER_FORMAT_STATEMENT;
        if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_CLAUSE_INDENT) er= ER_FORMAT_CLAUSE;
        return er;
      }
    }
  }
  if (enums_for == OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT)
  {
    /* Todo: there should be a warning that this way of setting shortcuts is obsolete */
    int ii= main_window->shortcut_set_via_keyword(keyword_index, qv);
    return ii; /* it might be ER_OK, or ER_ERROR, or ER_ILLEGAL_VALUE */
  }
  if (keyword_index == TOKEN_KEYWORD_OCELOT_HORIZONTAL)
  {
    int i= qv.toInt();
    if (i == 1) ocelot_ca.vertical= 0; else ocelot_ca.vertical= 1;
    return ER_OK;
  }
  if (keyword_index == TOKEN_KEYWORD_OCELOT_VERTICAL)
  {
    int i= qv.toInt();
    ocelot_ca.vertical= i;
    return ER_OK;
  }
  if ((keyword_index == TOKEN_KEYWORD_OCELOT_BATCH)
   || (keyword_index == TOKEN_KEYWORD_OCELOT_HTML)
   || (keyword_index == TOKEN_KEYWORD_OCELOT_HTMLRAW)
   || (keyword_index == TOKEN_KEYWORD_OCELOT_RAW)
   || (keyword_index == TOKEN_KEYWORD_OCELOT_XML))
  {
    ocelot_ca.batch= ocelot_ca.html= ocelot_ca.raw= ocelot_ca.xml= 0;
    int i= qv.toInt();
    if (i == 1)
    {
      *int_target= i;
      if (keyword_index == TOKEN_KEYWORD_OCELOT_HTMLRAW) ocelot_ca.html= ocelot_ca.raw= i;
    }
    return ER_OK;
  }
  if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_RULE)
  {
    ; /* Todo: check validity of qv here? */
  }
  if ((keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED)
#if (OCELOT_MYSQL_DEBUGGER == 1)
   || (keyword_index == TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED)
#endif
#if (OCELOT_EXPLORER == 1)
   || (keyword_index == TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED)
#endif
   || (keyword_index == TOKEN_KEYWORD_OCELOT_GRID_DETACHED)
   || (keyword_index == TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED))
  {
    {
      if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED)
      {
/* TODO: I'M NOT SURE ABOUT THIS! The * and the thing it points to are in different classes. */
        QAction *action_options_detach_statement_widget= main_window->menu_spec_find_action("action_options_detach_statement_widget");
        if (action_options_detach_statement_widget != NULL)
        {
if (qv == "no") printf("action_options_detach_statement_widget no\n"); else printf("action_options_detach_statement_widget no\n");
          if (qv == "no") { action_options_detach_statement_widget->setChecked(false); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED, false); }
          else {action_options_detach_statement_widget->setChecked(true); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED, true); }
        }
      }
#if (OCELOT_MYSQL_DEBUGGER == 1)
      if (keyword_index == TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED)
      {
        QAction *action_options_detach_debug_widget= main_window->menu_spec_find_action("action_options_detach_debug_widget");
        if (action_options_detach_debug_widget != NULL)
        {
          if (qv == "no") { action_options_detach_debug_widget->setChecked(false); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED, false); }
          else { action_options_detach_debug_widget->setChecked(true); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED, true); }
        }
      }
#endif
#if (OCELOT_EXPLORER== 1)
      if (keyword_index == TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED)
      {
        QAction *action_options_detach_explorer_widget= main_window->menu_spec_find_action("action_options_detach_explorer_widget");
        if (action_options_detach_explorer_widget != NULL)
        {
          if (qv == "no") { action_options_detach_explorer_widget->setChecked(false); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED, false); }
          else { action_options_detach_explorer_widget->setChecked(true); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED, true); }
        }
      }
#endif
      if (keyword_index == TOKEN_KEYWORD_OCELOT_GRID_DETACHED)
      {
        QAction *action_options_detach_grid_widget= main_window->menu_spec_find_action("action_options_detach_grid_widget");
        if (action_options_detach_grid_widget != NULL)
        {
          if (qv == "no") { action_options_detach_grid_widget->setChecked(false); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_GRID_DETACHED, false); }
          else { action_options_detach_grid_widget->setChecked(true); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_GRID_DETACHED, true); }
        }
      }
      if (keyword_index == TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED)
      {
        QAction *action_options_detach_history_widget= main_window->menu_spec_find_action("action_options_detach_history_widget");
        if (action_options_detach_history_widget != NULL)
        {
          if (qv == "no") { action_options_detach_history_widget->setChecked(false); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED, false); }
          else { action_options_detach_history_widget->setChecked(true); main_window->detach_widget(TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED, true); }
        }
      }
    }
  }

#if (OCELOT_EXPLORER == 1)
  if (keyword_index == TOKEN_KEYWORD_OCELOT_EXPLORER_VISIBLE)
  {
    qv= qv.toLower();
    if ((qv != "yes") && (qv != "no")) return ER_ILLEGAL_VALUE;
    *qstring_target= qv;
    if (qv == "yes")
    {
      char error_or_ok_message[ER_MAX_LENGTH]; /* todo: we're not showing this message to the user */
      int ret= main_window->explorer_refresh_caller(error_or_ok_message);
      if (ret != ER_OK_REHASH) return ret;
      return ER_OK;
    }
    else main_window->explorer_widget->hide();
  }
#endif
  if ((flags_style == 0) || (flags_style == OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE))
  {
    if (qstring_target != NULL) *qstring_target= qv;
    if (int_target != NULL) *int_target=qv.toInt();
  }

  if (flags_style == OCELOT_VARIABLE_FLAG_SET_COLOR)
  {
    QString ccn= main_window->canonical_color_name(qv);
    if (ccn == "") return ER_UNKNOWN_COLOR;
    *qstring_target= ccn;
    main_window->assign_names_for_colors();
    char tmp18[256];
    strcpy(tmp18, ccn.toUtf8());
    char tmp19[256];
    strcpy(tmp19, main_window->ocelot_explorer_background_color.toUtf8());
  }

  if ((flags_style & OCELOT_VARIABLE_FLAG_SET_FONT) != 0)
  {
    QString ccn;
    if (flags_style == OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY)
    {
      /* TODO: setting font_family can fail e.g. say 'Courier' and you could get 'Sans'
               because only 'Courier New' exists. There should be a warning, and
               setting some style hint e.g. "at least it should be monospace" would be good.
               Also ER_UNKNOWN_FONT_STYLE is the wrong error message if family is unknown.
      */
      if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_FAMILY)
         ccn= main_window->canonical_font_family(qv, &main_window->ocelot_statement_font_style);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_GRID_FONT_FAMILY)
         ccn= main_window->canonical_font_family(qv, &main_window->ocelot_grid_font_style);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_HISTORY_FONT_FAMILY)
         ccn= main_window->canonical_font_family(qv, &main_window->ocelot_history_font_style);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_MENU_FONT_FAMILY)
         ccn= main_window->canonical_font_family(qv, &main_window->ocelot_menu_font_style);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_FAMILY)
         ccn= main_window->canonical_font_family(qv, &main_window->ocelot_explorer_font_style);
      if (ccn == "") return ER_UNKNOWN_FONT_STYLE;
    }
    if (flags_style == OCELOT_VARIABLE_FLAG_SET_FONT_STYLE)
    {
      if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_STYLE)
        ccn= main_window->canonical_font_style(main_window->ocelot_statement_font_family, qv);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_GRID_FONT_STYLE)
        ccn= main_window->canonical_font_style(main_window->ocelot_grid_font_family, qv);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_HISTORY_FONT_STYLE)
         ccn= main_window->canonical_font_style(main_window->ocelot_history_font_family, qv);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_MENU_FONT_STYLE)
        ccn= main_window->canonical_font_style(main_window->ocelot_menu_font_family, qv);
      if (keyword_index == TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_STYLE)
        ccn= main_window->canonical_font_style(main_window->ocelot_explorer_font_family, qv);
      if (ccn == "") return ER_UNKNOWN_FONT_STYLE;
    }
    if (flags_style == OCELOT_VARIABLE_FLAG_SET_FONT_SIZE)
    {
      ccn= qv;
      if ((ccn.toInt() < FONT_SIZE_MIN) || (ccn.toInt() > FONT_SIZE_MAX)) return ER_UNKNOWN_FONT_SIZE;
    }
    if (flags_style == (char) OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT)
    {
      ccn= main_window->canonical_font_weight(qv);
    }
    if (ccn != *qstring_target)
    {
      *qstring_target= ccn;
      is_font_changed= true;
    }
  }

  if (enums_for == OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT)
  {
    if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR)
    {
      main_window->statement_edit_widget->highlightCurrentLine();
    }
    else
    {
      main_window->make_style_strings();
      main_window->statement_edit_widget_setstylesheet();
      if (keyword_index == TOKEN_KEYWORD_OCELOT_STATEMENT_PROMPT_BACKGROUND_COLOR)
      {
        main_window->statement_edit_widget->statement_edit_widget_left_bgcolor= QColor(main_window->ocelot_statement_prompt_background_color);
      }
    }
  }
  if (enums_for == OCELOT_VARIABLE_ENUM_SET_FOR_GRID)
  {
    ResultGrid* r;
    main_window->make_style_strings();
    for (int i_r= 0; i_r < ocelot_ca.grid_actual_tabs; ++i_r)
    {
      r= qobject_cast<ResultGrid*>(main_window->result_grid_tab_widget->widget(i_r));
#if (OCELOT_CHART_OR_QCHART == 1)
    if (keyword_index == TOKEN_KEYWORD_OCELOT_GRID_CHART)
    {
      ; /* The caller execute_client_statement() might call r->display() but only after checking for WHERE */
    }
    else
#endif
      r->set_all_style_sheets(main_window->ocelot_grid_style_string, *qstring_target, 1, is_font_changed);
    }
  }
  if (enums_for == OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY)
  {
    main_window->make_style_strings();
    main_window->history_edit_widget->setStyleSheet(main_window->ocelot_history_style_string);
  }
  if (enums_for == OCELOT_VARIABLE_ENUM_SET_FOR_MENU)
  {
    main_window->make_style_strings();
    main_window->ui->menuBar->setStyleSheet(main_window->ocelot_menu_style_string);
  }
#if (OCELOT_EXPLORER == 1)
  if (enums_for == OCELOT_VARIABLE_ENUM_SET_FOR_EXPLORER)
  {
    if (main_window->explorer_widget != NULL)
    {
      main_window->make_style_strings();
      main_window->explorer_widget->set_all_style_sheets(main_window->ocelot_explorer_style_string, 0, 1, true);
/* todo: dunno if we need to change explorer_context_menu, it's c_widget that gets font+color, eh? */
      main_window->explorer_widget->html_text_edit->explorer_context_menu->setStyleSheet(main_window->ocelot_explorer_style_string);
      main_window->c_widget->setStyleSheet(main_window->ocelot_explorer_style_string);
    }
  }
#endif
  if (enums_for == OCELOT_VARIABLE_ENUM_SET_FOR_EXTRA_RULE_1)
  {
    main_window->make_style_strings();
  }

  if (keyword_index == TOKEN_KEYWORD_OCELOT_COMPLETER_TIMEOUT)
  {
    if (main_window->completer_widget != NULL) main_window->completer_widget->set_timer_interval();
  }

  return ER_OK;
}

int XSettings::ocelot_variable_offset(int keyword_index)
{
  for (int i= 0; i < OCELOT_VARIABLES_SIZE; ++i)
  {
    if (ocelot_variables[i].k_i == keyword_index) return i;
  }
  return -1;
}


/* Return true iff keyword_index is for an ocelot_ variable for a color setting */
bool XSettings::ocelot_variable_is_color(int keyword_index)
{
  int offset= ocelot_variable_offset(keyword_index);
  if (offset < 0) return false;
  unsigned char flags_style= ocelot_variables[offset].flags_style;
  if (flags_style == OCELOT_VARIABLE_FLAG_SET_COLOR) return true;
  return false;
}

/* Return true iff keyword_index is for an ocelot_ variable for a font_weight setting */
bool XSettings::ocelot_variable_is_font_weight(int keyword_index)
{
  int offset= ocelot_variable_offset(keyword_index);
  if (offset < 0) return false;
  unsigned char flags_style= ocelot_variables[offset].flags_style;
  if (flags_style == OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT) return true;
  return false;
}

/* Return true iff keyword_index is for an ocelot_ variable for a font_style setting */
bool XSettings::ocelot_variable_is_font_style(int keyword_index)
{
  int offset= ocelot_variable_offset(keyword_index);
  if (offset < 0) return false;
  unsigned char flags_style= ocelot_variables[offset].flags_style;
  if (flags_style == OCELOT_VARIABLE_FLAG_SET_FONT_STYLE) return true;
  return false;
}

/* Return true iff keyword_index is for an ocelot_ variable for a font_family setting */
bool XSettings::ocelot_variable_is_font_family(int keyword_index)
{
  int offset= ocelot_variable_offset(keyword_index);
  if (offset < 0) return false;
  unsigned char flags_style= ocelot_variables[offset].flags_style;
  if (flags_style == OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY) return true;
  return false;
}



int XSettings::ocelot_variables_size()
{
  return OCELOT_VARIABLES_SIZE;
}

XSettings::~XSettings()
{
  delete[] ocelot_variables;
}

#endif // XSETTINGS

#if (OCELOT_EXPLORER == 1)
/*
  Explorer
  --------
  Name:
    Others say "object explorer" or "navigator". Compare the name "Windows explorer".
  Position:
    It's a widget with the same priority as history|grid|statement.
    Usually on the left. Detachable. Often hidden. Default hidden. If hidden, won't be updated.
  Style:
    It's a result grid. So it is wider, and has less decoration, compared to other products' explorers.
    However, users get some features without needing to learn anything new:
    * SET works. E.g. SET ocelot_explorer_background_color = 'tan' WHERE value > 'sys'; (if you REFRESH)
    * ^Find works. (if it's visible)
    * Vertical scroll bar works.
    * One difference: dragging doesn't happen. There wouldn't be much point, since items are short.
  Columns: all of which are 'TEXT':
    #1: Min. = Unicode Black Down-Pointing Triangle or Black Right-Pointing Triangle if database or table.
        If it's a database or table, this can be clicked to hide the parts e.g. columns, or to show them again.
        (We call this "toggling".)
        Ordinarily it has a different background color (grid header background color).
    #2: object_type. S or T or V or C or P or I or E or t
    #3: object_name. for example, if object_type='T', this is a table name.
        If object_type='C', this is a column name and is taken from part_name.
  Settings ... for Explorer
    Explorer Text Color | Background Color | Font -- As with other widgets, these can all be changed.
    Visible: yes|no. Default no. So if you don't change this to 'yes', there's nothing.
    Sort alphabetically: If 'yes', objects of the same type are sorted alphabetically. Default is 'no'.
                         This might be a bad idea that we'll remove, so always in order by how DBMS returns.
    Query: a long select with unions.
      The default query selects all databases.
      Users can change this query to add WHERE clauses. Affects MySQL/MariaDB only.
    Detached|Top|Left|Width|Height:
      As with other widgets, the explorer is detachable and the explorer's size + position are settable
      when it is detached.
      Unlike with other widgets, changing width to x has an effect even if the explorer is not detached.
      The default width depends on the widths of the object names.
  What users can do when explorer is visible:
    DoubleClick:
      This will copy the cell contents to the end of the statement widget
    Right Click: puts up a context menu.
      The relevant context is what row the mouse is over.
      For example if it's over a table, then table-related menu items will appear.
      The list of possible items is in the comment preceding menu_context_t_2_explorer.
  SET statements:
    ???? Remove this? SET ocelot_grid_cell_height=0 ... WHERE ...; causes matching rows to disappear, i.e. this is our "filter".
    New keywords begin with OCELOT_EXPLORER e.g. OCELOT_EXPLORER_DETACHED
    Important one: ocelot_visible='yes'|'no'
  REFRESH:
    A bit similar to REHASH, but this gets all schemas (databases) -- so has an effect on the server.
    REFRESH is necessary because we don't know when other users might change data definitions. And it's slow.
    Whenever users say REFRESH, the explorer tables are redone.
    In another product this would be done with a View menu.
  Options:
    New options: Detach|Attach explorer widget.
  The explorer widget is actually a grid widget with html.
  To users we want it to look like it's in same class as menu|history|grid|statement.
  Re navigation:
    The scroll bar is always present.
    We want effect of Up|Down to look the same as with Completer_widget::keyPressEvent
    but the mechanism is different: Change focus_result_row_number and call explorer_display_html,
    which will call copy_html_cell, which will change colour for result_grid->focus_result_row_number.
    So in Result_qtextedit::keyPressEvent(QKeyEvent *event) we arrange that if user presses Up key:
    If (we are at position 0)
      if scroll bar position == 0 do nothing
      else change scroll bar position, which requires explorer_display_html(new-position)
                                       which requires result_grid->grid_vertical_scroll_bar->setValue(n);
    Else
      change focus_result_row_number, it is 1 before where we were
    (If it's not EXPLORER_WIDGET then Up and Down are presumably within the edit area so that's a different path.)
  TODO: Tooltip changes. In fact that's true for result grid too.
        Could be "Explorer" + "Right-click for context menu" + "See Help|Explorer" + object type = Column, X, in table Y
        There could be SET ocelot_explorer_tooltip= ... WHERE ... as there is for grid.
  Todo: Something that shows referencing|referenced relationships of foreign keys, preferably visual.
        Add to query: something that gets us foreign keys.
  Todo: If you lack privileges for an object, you should gray some things in the menu.
        This would always be true if current database = information_schema.
  Todo: Pixmaps instead of Unicode characters for Down-pointing and Right-pointing triangle.
  Todo: Dialog box for Filter (can be done with query change)
  Todo: Dialog box for Sort (can be done with query change) (we already have Settings|Sort alphabetically)
  Todo: Help|Explorer widget, and change to README.
  Todo: example.cnf should have whatever the new options are.
  Todo: Drag and Drop: This would be for building a query.
  Todo: Check for leaks, and check for result-grid changes that cause items to be destroyed and re-created.
  Todo: When font changes or some other condition changes, or new USE, automatically adjust explorer.
        Actually font changes do have immediate effect.
  Todo: Start with visible, but just leave a message saying to look at Help|Explorer.
  Todo: Shortcut. For example, typing 'C' goes to the next thing that starts with 'C' (there's also ^F FInd).
  Todo: When you first display a result grid, there is a little blank. It's batch_text_edit.
        Should it be initially hidden for all result grid? I haven't decided yet.
  Todo: Hide the explorer widget if/when not connected.
  Todo: Your initial setup of upper_layout might be dangerous, check it more thoroughly.
        Search for calculations that depend on whole width, instead of main_window width.
        Check whether a change to grid settings will affect explorer_widget (usually yes).
  Todo: It's a bit unfortunate that explorer's abbreviation is 'S' for schema but rehash's is 'D' for database.
  Todo: "MIN" is not a wonderfulname. It should be short.
        There might be some standard term. Collapse? Tables only? Hide columns? Hide parts?
  explorer_refresh_caller():
    will do rehash_scan() (as if REHASH statement was executed), then fill up oei struc,
    so that when explorer_widget->show() happens there will be an explorer widget to show.
    There are several ways it can fail, which should cause a dialog box without showing.
  Todo: Usually when we change a Settings item the result is we generate a SET statement.
  TODO: explorer_refresh_caller() should merely give error dialog boxes if something is not ready.
        explorer_rehah() should give an error dialog box if rehash/refresh fails.
  Todo: user might set e.g. vertical or raw. make sure such settings have no effect on explorer widget
  Todo: we could say, instead of "C", "C(PK,FK,I)"
  Todo: ^C i.e. Copy should be possible on explorer cells
  Todo: SET ... WHERE column IS FOREIGN KEY | PRIMARY KEY | UNIQUE | INDEXED
        You can add a Filter combobox which generates the statement
        We only need to do it if there is a SET ocelot_grid_cell_height=0 statement
  Todo: example.cnf should include the new words, including ocelot_max_settings=n if you produce that
        (mainly we should fill in the blanks for the default colours and fonts)
        (now we do have ocelot_ca.max_conditions)
  Todo: This initializes ocelot_explorer_query to MySQL default, but we need Tarantool default
        which might change upon re-connect.
  Todo: Now that everything is in object_name we lose a bit of ability compared with
        SET ocelot_grid_... WHERE column_name ... unless we say column_type='C' means something
  Todo: In Tarantool, how good it would be to have options for creating information_schema_tables etc.!
  Todo: There could be an ocelot_explorer_focus_cell_background_color as there is for grid_cell
  Todo: If font = Nimbus mono the height is too great, although with other fonts problem wasn't noticed.
  Todo: ostrings.h needs new items for explorer-related errors and settings
  Todo:  a main-menu "set focus" or at least "set visible" shortcut, (change to "hide" when it's visible)
  Todo: Add more one-keystroke controls for navigating in explorer
  Todo: Bug: If you use one of the export options, you wipe out anything done for an earlier TEE or
        export. Somehow you've got to restore them, and/or keep separate, and/or error if they're open.
*/
void MainWindow::initialize_widget_explorer()
{
  explorer_widget->explorer_initialize();
  oei= NULL;
  oei_count= 0;
  oei_fk= NULL;
  oei_fk_count= 0;
  /* Todo: Following is also what we do for ResultGrid in result_grid_add_tab. Reduce duplication? */
  explorer_widget->installEventFilter(this); /* must catch fontChange, show, etc. */
  explorer_widget->grid_vertical_scroll_bar->installEventFilter(this);
  explorer_widget->set_all_style_sheets(ocelot_explorer_style_string, 0, 0, false);
  /* Todo: Not sure where to put this. And it's wrong if Tarantool. Compare query of rehash_scan(). */
}

/*
  Called from: connect_init().
  After we connect or reconnect, we might need to change the query that we use for the explorer.
  Todo: Flaw: This will override any change that a user makes with Settings|Explorer.
        It might be better to have two ocelot_explorer_queries, one for Tarantool, one for MySQL/MariaDB.
  Todo: think harder about how to handle switch to a different DBMS
        There might be some things made for the previous DBMS that should be deleted now.
  Todo: If explorer_refresh fails, probably because we lack an important select privilege,
        mark that explorer is disabled and explain the problem.
  Todo: Temporarily I've set auto_rehash=0. Put it back in .my.cnf.
*/
void MainWindow::initialize_widget_explorer_after_connect()
{
#if (OCELOT_MYSQL_INCLUDE == 1)
  if ((connections_dbms[0] == DBMS_MYSQL) || (connections_dbms[0] == DBMS_MARIADB))
  ocelot_explorer_query= "select 'S',schema_name,schema_name,default_character_set_name,default_collation_name\n"
                 "from information_schema.schemata\n"
                 "union all\n"
                 "select 'T',table_schema,table_name,table_type,''\n"
                 "from information_schema.tables\n"
                 "union all\n"
                 "select 'C',table_schema,table_name,column_name,column_type\n"
                 "from information_schema.columns\n"
                 "union all\n"
                 "select 'I',table_schema,table_name,index_name,column_name\n"
                 "from information_schema.statistics\n"
                 "union all\n"
                 "select 'R',trigger_schema,trigger_name,'',''\n"
                 "from information_schema.triggers\n"
                 "union all\n"
                 "select 'F',routine_schema,routine_name,routine_type,''\n"
                 "from information_schema.routines\n"
                 "where routine_type = 'FUNCTION'\n"
                 "union all\n"
                 "select 'P',routine_schema,routine_name,routine_type,''\n"
                 "from information_schema.routines\n"
                 "where routine_type = 'PROCEDURE'\n"
                 "union all\n"
                 "select 'E',event_schema,event_name,'',''\n"
                 "from information_schema.events\n"
                 ";"
         ;
#endif
  if (connections_dbms[0] == DBMS_TARANTOOL)
  {
    if ((dbms_version_mask & FLAG_VERSION_TARANTOOL_3_0) != 0)
    ocelot_explorer_query= "select 'S','main','','',//\n"
                   "union all\n"
                   "select 'C',table_schema,table_name,column_name,data_type\n"
                   "from seqscan _columns\n"
                   "union all\n"
                   "select 'T',table_schema,table_name,table_type,''\n"
                   "from seqscan _tables;"
      ;
    else
    ocelot_explorer_query= "select 'S','main','','',//\n"
                   "union all\n"
                   "select 'C',table_schema,table_name,column_name,data_type\n"
                   "from _columns\n"
                   "union all\n"
                   "select 'T',table_schema,table_name,table_type,''\n"
                   "from _tables;"
     ;
  }

  char error_or_ok_message[1024];
  if (ocelot_explorer_visible  == "yes") explorer_refresh_caller(error_or_ok_message);
}


/*
  Todo:
  !! DELETE oei IF YOU SAID NEW! (no, we don't do that unless user decides to remove the whole thing)
  Method:
    Call rehash_scan with alternate_query <> NULL.
    Set up oei.
    REHASH initially calls rehash_scan with alternate_query == NULL, because we might have wrecked things for autocomplete.
    Todo #1: The second rehash_scan call is only necessary if there was a difference but we fail to check.
    Todo #2: It would be so much nicer if rehash_scan didn't have so many globals.
    Todo #3: we have flag, and if ((flag & FIELD_VALUE_FLAG_IS_NULL) != 0) might be true, but we don't use it
    Todo #5: if failure, should not be visible, eh? we fail to check for failure of explorer_display()
    Todo #6: REFRESH; statement causes this. Therefore it jumps back to 0 on the scroll bar.
             With explorer_toggle(): we could assume that scroll bar position is unchanged.
             Ideally we could try to find the same item again, and if we fail then retreat to most-recent item
             of the same type or of upper type in the hierarchy, but that gets complicated, especially if there
             has been collapsing and filtering.
*/
int MainWindow::explorer_refresh_caller(char *error_or_ok_message)
{
  int rehash_scan_result= explorer_refresh(error_or_ok_message);
  if (rehash_scan_result != ER_OK_REHASH) return rehash_scan_result; /* Todo: does user see this result? */
  explorer_widget->explorer_display();  /* effectively: explorer_display_html(0) */
  explorer_widget->show();
  return ER_OK_REHASH;
}

/*
  Execute the default query (or whatever user changed to in Settings|Explorer), create struct explorer_items oei.
  This requires SELECT ... FROM INFORMATION_SCHEMA with many UNIONS, which is also what we have to do for
  handling autocomplete, which is what rehash_scan() is for. But currently we're doing a different SELECT,
  so we always will call rehash() twice, once for autocomplete use, once for explorer use.
SET ocelot_explorer_visible='yes'; -- if already visible: depends whether something else changed, but that's a bit hard to know
                                    if not already visible: rehash
Menu context edit menu rehash:        REFRESH
REFRESH:                              explorer_refresh if ocelot_explorer_visible='yes'
--auto_rehash:                        affects REHASH not REFRESH
After explorer_refresh, vertical scroll bar should go back to start

Called from: execute_client_statement if (statement == REFRESH;)
Called from: explorer_refresh_caller() which is due to OCELOT_EXPLORER_VISIBLE='yes' or a choice on context menu
  Method:
    For each schema
      For each item of this schema
        If "T" or "V"
          add to oei
          For each item
            If "C" of this "T":
              add to oei
            If "I" of this "T":
              add to oei
        If "R" or "P" or "E" or "F":
          add to oei (these will come last because of the way the UNION was done)
  TODO: For rehash_scan_for_tarantool(), if explorer:
        We should ignore what is not in the query, e.g. if user decided not to get 'I', or added a 'WHERE'.
  Todo: Maybe we can throw away the result set as soon as we have the oei.
  Todo: Since refresh including qsort can take a second on an almost minimal information_schema,
        think of ways to speed up. E.g. check last update to see whether a change happened,
        make a special qsort table so each swap becomes smaller, assume system tables won't change,
        take advantage of all things of same type being together initially (I think).
*/
int MainWindow::explorer_refresh(char *error_or_ok_message)
{
  log("explorer_refresh start", 65);
  if (ocelot_explorer_visible == "no")
  {
    strcpy(error_or_ok_message, "REFRESH only works if explorer is visible. To make it visible, use Settings|Explorer or SET ocelot_explorer_visible='yes';");
    return ER_ERROR;
  }
  int rehash_scan_result;
  unsigned int saved_rehash_result_row_count= result_row_count;
  rehash_scan_result= rehash_scan(error_or_ok_message, ocelot_explorer_query); /* instead of "" */
  if (strncmp(error_or_ok_message, "OK", 2) != 0)
  {
    return rehash_scan_result;
  }
  if (oei != NULL)
  {
    delete [] oei;
    oei_count= 0;
    oei= NULL;
  }
  if (oei_fk != NULL)
  {
    delete [] oei_fk;
    oei_fk_count= 0;
    oei_fk= NULL;
  }
  long unsigned int r;
  char *row_pointer;
  unsigned int column_length;
  unsigned int i;

  /* Something like what happens in rehash_search(). */
  /* ?? Maybe you should have a limit on the size, like SQL Server does (65535). */
  /* todo: "* 2" is too much, you only need to allow for adding "T", which should mean nothing. */
  /*       COMMENT ON THIS TODO: ???? in fact maybe we don't even need *2 any more, eh? */
  oei= new explorer_items[rehash_result_row_count * 2];
#ifdef DBMS_TARANTOOL
  if (connections_dbms[0] == DBMS_TARANTOOL)
  {
    oei[oei_count].object_type= "S"; /* Tarantool has no schemas but we'll pretend with a dummy named "main" */
    oei[oei_count].schema_name= "main";
    oei[oei_count].object_name= "main";
    oei[oei_count].part_name= "";
    oei[oei_count].part_type= "";
    oei[oei_count].flags= EXPLORER_FLAG_MIN;
    ++oei_count;
    for (int i= 0; i < tarantool_table_names.count(); ++i)
    {
      oei[oei_count].object_type= "T";
      oei[oei_count].schema_name= "main";
      oei[oei_count].object_name= tarantool_table_names.at(i).toUtf8();
      oei[oei_count].part_name= tarantool_table_engines.at(i).toUtf8();
      oei[oei_count].part_type= "";
      oei[oei_count].flags= EXPLORER_FLAG_MIN;
      ++oei_count;
    }
    for (int i= 0; i < tarantool_column_names.count(); ++i)
    {
      oei[oei_count].object_type= "C";
      oei[oei_count].schema_name= "main";
      oei[oei_count].object_name= tarantool_column_table_names.at(i).toUtf8();
      oei[oei_count].part_name= tarantool_column_names.at(i).toUtf8();
      oei[oei_count].part_type= tarantool_type_names.at(i).toUtf8();
      oei[oei_count].flags= EXPLORER_FLAG_MIN;
      ++oei_count;
    }
    for (int i= 0; i < tarantool_index_names.count(); ++i)
    {
      QString c= "";
      int counter= 0;
      int index_column_number= tarantool_index_column_numbers.at(i).toInt();
      for (int j= 0; j < tarantool_column_names.count(); ++j)
      {
        if (tarantool_index_table_names.at(i) == tarantool_column_table_names.at(j))
        {
          if (counter == index_column_number)
          {
            c= tarantool_column_names.at(j);
            break;
          }
          ++counter;
        }
      }
      oei[oei_count].object_type= "I";
      oei[oei_count].schema_name= "main";
      oei[oei_count].object_name= tarantool_index_table_names.at(i).toUtf8();
      oei[oei_count].part_name= tarantool_index_names.at(i).toUtf8();
      oei[oei_count].part_type= c.toUtf8();
      oei[oei_count].flags= EXPLORER_FLAG_MIN;
      ++oei_count;
    }
    for (int i= 0; i < tarantool_trigger_names.count(); ++i)
    {
      oei[oei_count].object_type= "R";
      oei[oei_count].schema_name= "main";
      oei[oei_count].object_name= tarantool_trigger_names.at(i).toUtf8();
      oei[oei_count].part_name= "";
      oei[oei_count].part_type= "";
      oei[oei_count].flags= EXPLORER_FLAG_MIN;
      ++oei_count;
    }
    for (int i= 0; i < tarantool_fk_constraint_names.count(); ++i)
    {
      /* I'm not sure we really need to do anything with this */
    }
  }
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
  if (connections_dbms[0] != DBMS_TARANTOOL)
  {
    for (r= 0; r < rehash_result_row_count; ++r)
    {
      row_pointer= rehash_result_set_copy_rows[r];
      for (i= 0; i < rehash_result_column_count; ++i)
      {
        memcpy(&column_length, row_pointer, sizeof(unsigned int));
        //char flag= *(row_pointer + sizeof(unsigned int));
        row_pointer+= sizeof(unsigned int) + sizeof(char);
        /* Now row_pointer points to contents, length has # of bytes */
        {
          if (i == 0) oei[oei_count].object_type= QByteArray(row_pointer, column_length);
          if (i == 1) oei[oei_count].schema_name= QByteArray(row_pointer, column_length);
          if (i == 2) oei[oei_count].object_name= QByteArray(row_pointer, column_length);
          if (i == 3) oei[oei_count].part_name= QByteArray(row_pointer, column_length);
          if (i == 4) oei[oei_count].part_type= QByteArray(row_pointer, column_length);
          if (i == 5) oei[oei_count].part_extra= QByteArray(row_pointer, column_length);
          if (i == rehash_result_column_count - 1) /* i.e. if now we have all columns */
          {
            oei[oei_count].flags= EXPLORER_FLAG_MIN;
            ++oei_count;
          }
        }
        row_pointer+= column_length;
      }
    }
  }
#endif
  //explorer_widget->hide(); /* Is this necessary? */
  /* this is in the initialize function */
  explorer_sort();

  /* Todo: Move this I guess */
  if (connections_dbms[0] == DBMS_TARANTOOL)
  {
    unsigned int tarantool_fk_constraint_names_count= tarantool_fk_constraint_names.count();
    oei_fk= new explorer_items_fk[tarantool_fk_constraint_names_count];
    for (oei_fk_count= 0; oei_fk_count < tarantool_fk_constraint_names_count; ++oei_fk_count)
    {
      oei_fk[oei_fk_count].schema_name= "main";
      QString s= tarantool_fk_constraint_child_ids.at(oei_fk_count);
      int i_of_child_table= tarantool_table_ids.indexOf(s);
      oei_fk[oei_fk_count].table_name= tarantool_table_names.at(i_of_child_table).toUtf8();
      oei_fk[oei_fk_count].column_name= "?";
      oei_fk[oei_fk_count].ordinal_position= "1"; /* Might be multiple child_cols or parent_cols but okay */
      s= tarantool_fk_constraint_parent_ids.at(oei_fk_count);
      int i_of_parent_table= tarantool_table_ids.indexOf(s);
      oei_fk[oei_fk_count].referenced_table_name= tarantool_table_names.at(i_of_parent_table).toUtf8();
      oei_fk[oei_fk_count].referenced_column_name= "?";
      oei_fk[oei_fk_count].constraint_name= tarantool_fk_constraint_names.at(oei_fk_count).toUtf8();
    }
  }
  if (connections_dbms[0] != DBMS_TARANTOOL)
  {
    /* Todo: Maybe better to do it with order by constraint_name? */
    QString ocelot_explorer_query_fk= "SELECT table_schema, table_name, column_name, ordinal_position,\n"
                 "referenced_table_name,referenced_column_name, constraint_name\n"
                 "FROM information_schema.key_column_usage \n"
                 "ORDER BY table_schema, table_name;"
    ;
    rehash_scan_result= rehash_scan(error_or_ok_message, ocelot_explorer_query_fk); /* instead of "" */
    if (strncmp(error_or_ok_message, "OK", 2) != 0)
    {
      return rehash_scan_result;
    }
    oei_fk_count= 0;
    oei_fk= new explorer_items_fk[rehash_result_row_count];
    for (r= 0; r < rehash_result_row_count; ++r)
    {
      row_pointer= rehash_result_set_copy_rows[r];
      for (i= 0; i < rehash_result_column_count; ++i)
      {
        memcpy(&column_length, row_pointer, sizeof(unsigned int));
        //char flag= *(row_pointer + sizeof(unsigned int));
        row_pointer+= sizeof(unsigned int) + sizeof(char);
        /* Now row_pointer points to contents, length has # of bytes */
        {
          if (i == 0) oei_fk[oei_fk_count].schema_name= QByteArray(row_pointer, column_length);
          if (i == 1) oei_fk[oei_fk_count].table_name= QByteArray(row_pointer, column_length);
          if (i == 2) oei_fk[oei_fk_count].column_name= QByteArray(row_pointer, column_length);
          if (i == 3) oei_fk[oei_fk_count].ordinal_position= QByteArray(row_pointer, column_length);
          if (i == 4) oei_fk[oei_fk_count].referenced_table_name= QByteArray(row_pointer, column_length);
          if (i == 5) oei_fk[oei_fk_count].referenced_column_name= QByteArray(row_pointer, column_length);
          if (i == 6) oei_fk[oei_fk_count].constraint_name= QByteArray(row_pointer, column_length);
          if (i == rehash_result_column_count - 1) /* i.e. if now we have all columns */
          {
            ++oei_fk_count;
          }
        }
        row_pointer+= column_length;
      }
    }
    /* If we wrecked the global rehash_scan result that's used ordinarily we'll have to call rehash_scan again. */
    if (saved_rehash_result_row_count != 0) rehash_scan(error_or_ok_message, "");
    else rehash_garbage_collect();
  }
  log("explorer_refresh end", 65);
  return ER_OK_REHASH;
}

/*
  Call this if something has changed which might affect the look of an explorer, possibly including table header.
  * condition changed so each "E%n" div must change
  * ocelot_ca.max_conditions changed to a smaller number
  Todo: error is possible, something should be returned.
  Todo: Consider calling from ocelot_variable_set() if font change, currently we change the font due to
        style sheet change but not the widget width. On the other hand, that causes displaying twice.
*/
void MainWindow::explorer_show_after_change()
{
  explorer_widget->prepare_for_display_html();
  if (explorer_widget->isVisible() == false) return;
  int gvsbv= explorer_widget->grid_vertical_scroll_bar_value;
  explorer_widget->explorer_display_html(gvsbv);
}

/*
  E.g.
    "S","information_schema",'',''
      "T","information_schema","Table-Name",""
        "C","information_schema","Table-Name","Part-Name",
        "I","information_schema","Table-Name","Part-Name",
  Case Sensitive
  Alternative: If user chose "definition order", return diff-of-row-number when names are different
  Possible enhancement: allow for case-insensitive sorting
*/
int static explorer_qsort_compare(const void *a, const void *b)
{
  struct explorer_items ea= *(struct explorer_items *) a;
  struct explorer_items eb= *(struct explorer_items *) b;
  int schema_comparison_result= QString::compare(ea.schema_name, eb.schema_name, Qt::CaseInsensitive);
  if (schema_comparison_result != 0) return schema_comparison_result;
  /* same schema name */
  //if (ea.object_type == "S") return -1;
  //if (eb.object_type == "S") return +1;
  int ea_main_number, eb_main_number;
  if (ea.object_type == "S") ea_main_number= 0;
  else if ((ea.object_type == "T") || (ea.object_type == "V") || (ea.object_type == "C") || (ea.object_type == "I")) ea_main_number= 1;
  else if (ea.object_type == "F") ea_main_number= 2;
  else if (ea.object_type == "P") ea_main_number= 3;
  else if (ea.object_type == "E") ea_main_number= 4;
  else ea_main_number= 5; /* presumably "t" */
  if (eb.object_type == "S") eb_main_number= 0;
  else if ((eb.object_type == "T") || (eb.object_type == "V") || (eb.object_type == "C") || (eb.object_type == "I")) eb_main_number= 1;
  else if (eb.object_type == "F") eb_main_number= 2;
  else if (eb.object_type == "P") eb_main_number= 3;
  else if (eb.object_type == "E") eb_main_number= 4;
  else eb_main_number= 5; /* presumably "R" */
  if (ea_main_number != eb_main_number) return ea_main_number - eb_main_number;
  /* ... so main numbers are the same ... */
  int object_comparison_result= QString::compare(ea.object_name, eb.object_name, Qt::CaseInsensitive);
  if (object_comparison_result != 0) return object_comparison_result;
  /* ... so object names are the same, which should only occur for T|V and C|I ... */
  int ea_part_type, eb_part_type;
  if ((ea.object_type == "T") || (ea.object_type == "V")) ea_part_type= 0;
  else if (ea.object_type == "C") ea_part_type= 1;
  else ea_part_type= 2; /* presumably "I" */
  if ((eb.object_type == "T") || (eb.object_type == "V")) eb_part_type= 0;
  else if (eb.object_type == "C") eb_part_type= 1;
  else eb_part_type= 2; /* presumably "I" */
  if (ea_part_type != eb_part_type) return ea_part_type - eb_part_type;
  /* ... so schema name and object name and type are the same ... */
  return QString::compare(ea.part_name, eb.part_name, Qt::CaseInsensitive);
}

/*
  Given oei that we produce in explorer_refresh(), sort so there is a hierarchy:
    schema -> object -> part, specifically 'C' and 'I' are under 'T' or 'V',
    and alphabetic within the hierarchy unless Settings|explorer said to keep defined order.
    Saying explorer_sort == "no" might be slightly faster and preserves column-definition order within table.
  Todo: Perhaps 't' should be under 'T' too.
  Todo: There could be more ways to sort.
*/
void MainWindow::explorer_sort()
{
  log("explorer_sort start", 65);

  for (unsigned int i= 0; i < oei_count; ++i)
  {
    if (oei[i].object_type == "T")
    {
      bool is_view= false;
      if ((connections_dbms[0] == DBMS_MARIADB) || (connections_dbms[0] == DBMS_MYSQL))
      {
        if (oei[i].part_name == "VIEW") /* i.e. not BASE TABLE | SYSTEM VIEW | SYSTEM VERSIONED */
          is_view= true;
      }
      else /* presumably == DBMS_TARANTOOL */
      {
        /* Todo: This only checks for user-created views starting with CREATE. Why not "sysview"? */
        QString s= QString(oei[i].part_name);
        if (s.startsWith("create", Qt::CaseInsensitive))
          is_view= true;
      }
      if (is_view)
      {
        oei[i].object_type= "V";
      }
    }
  }

  if (ocelot_explorer_sort == "yes")
  {
    qsort(oei, oei_count, sizeof(struct explorer_items), explorer_qsort_compare);
    log("explorer_sort end", 65);
    return;
  }
  explorer_items *oei_copy;
  oei_copy= new explorer_items[oei_count];
  unsigned int i_of_copy= 0;

  for (unsigned int i_of_schema= 0; i_of_schema < oei_count; ++i_of_schema)
  {
    if (oei[i_of_schema].object_type != "S") break; /* This assumes that schemas precede all other types */
    oei_copy[i_of_copy++]= oei[i_of_schema];
    for (unsigned int i_of_main= 0; i_of_main < oei_count; ++i_of_main)
    {
      if (oei[i_of_main].schema_name == oei[i_of_schema].schema_name)
      {
        if ((oei[i_of_main].object_type == "T") || (oei[i_of_main].object_type == "V"))
        {
          oei_copy[i_of_copy++]= oei[i_of_main];
          for (unsigned int i_of_column= 0; i_of_column < oei_count; ++i_of_column)
          {
            if ((oei[i_of_column].object_type == "C")
             && (oei[i_of_column].object_name == oei[i_of_main].object_name)
             && (oei[i_of_column].schema_name == oei[i_of_schema].schema_name))
              oei_copy[i_of_copy++]= oei[i_of_column];
          }
          for (unsigned int i_of_index= 0; i_of_index < oei_count; ++i_of_index)
          {
            if ((oei[i_of_index].object_type == "I")
             && (oei[i_of_index].object_name == oei[i_of_main].object_name)
             && (oei[i_of_index].schema_name == oei[i_of_schema].schema_name))
              oei_copy[i_of_copy++]= oei[i_of_index];
          }
        } /* closes if (oei[i_of_main].object_type == "T") */
        else if ((oei[i_of_main].object_type == "P")
              || (oei[i_of_main].object_type == "F")
              || (oei[i_of_main].object_type == "R")
              || (oei[i_of_main].object_type == "E"))
                oei_copy[i_of_copy++]= oei[i_of_main];
      } /* closes if (oei[i_of_main].schema_name == oei[i_of_schema].schema_name) */
    } /* closes i_of_main loop */
  } /* closes i_of_schema  loop */
  for (unsigned int i= 0; i < oei_count; ++i) oei[i]= oei_copy[i];

  delete [] oei_copy;

  /* Check */
  //for (unsigned int i= 0; i < oei_count; ++i)
  //{
  //  char tmp0[256]; strcpy(tmp0, oei[i].object_type);
  //  char tmp1[256]; strcpy(tmp1, oei[i].schema_name);
  //  char tmp2[256]; strcpy(tmp2, oei[i].object_name);
  //  char tmp3[256]; strcpy(tmp3, oei[i].part_name);
  //  printf("%s %s.%s.%s\n", tmp0,tmp1,tmp2,tmp3);
  //}
  log("explorer_sort end", 65);
}

/*
  The idea of "query" is that users can go to Settings to change the big union statement for rehash_scan()
  So far we're always returning true = OK.
  Todo: Any way to call hparse_f and reformat?
  Todo: Probably here we should check that the query has proper form e.g. selects the right number of columns.
*/
bool MainWindow::explorer_query()
{
  ;
  return true;
}

/*
  Called from hparse_f_client_statement after SET ... WHERE ocelot_explorer_text=
  For explorer the possible text values are all the oei items (explorer widget) and all the cmi items
  (explorer context menu).
  Todo: This isn't precise enough, we should be looking at part_name part_type etc.
*/
QStringList MainWindow::explorer_text_list()
{
  QStringList q;
  q.clear(); /* unnecessary? */
  for (int i= 0; i < explorer_widget->html_text_edit->explorer_context_menu->cmi_count; ++i)
    q.append(explorer_widget->html_text_edit->explorer_context_menu->cmi[i].text);
  for (unsigned int i= 0; i < oei_count; ++i)
  {
    q.append(oei[i].object_name);
  }
  return q;
}

/* Todo: This could be called when we're shutting down (?). Clean up anything made with new. */
void MainWindow::explorer_close()
{
  ;
}

/*
  In order to do a query for explorer for Tarantool, we need an information_schema equivalent.
  Luckily I produced one when working for Tarantool:
  https://www.tarantool.io/en/doc/latest/reference/reference_sql/sql_plus_lua/#sql-lua-functions
  But it can fail if some privilege is missing.
*/
//void MainWindow::make_information_schema()
//{
//}


/* Todo: Add: a function for destroying all objects created for the widget (though not the widget itself?) */

#endif //if (OCELOT_EXPLORER == 1)

#if (OCELOT_CHART == 1)

/*
  General comments about Chart class are in ocelotgui.h.
  The constructor includes: copying pointers to outer widgets, making copies of things that
  came out of result_grid->scan_rows when the selection was made.
  Assume these cannot be affected by later resize/move/font-change/colour-change.
  Recommendation: Do not change anything assigned here in later Chart:: functions.
*/

/* If we said SET ocelot_grid_chart='a b c d'; then offset_of_keyword('c') will return 2. */
int Chart::offset_of_keyword(QString keyword)
{
  for (int i= 0; chart_token_lengths[i] != 0; ++i)
  {
    QString s= chart_spec.mid(chart_token_offsets[i], chart_token_lengths[i]);
    if (QString::compare(s, keyword, Qt::CaseInsensitive) == 0) return i;
  }
  return -1;
}

Chart::Chart(ResultGrid *rg, MainWindow *parent_mainwindow, int passed_chart_type)
{
  chart_type= passed_chart_type;
  chart_rg= rg;
  setParent(chart_rg); /* dunno why this seems necessary, we call from resultgrid */

  chart_mainwindow= parent_mainwindow;
  cha_result_column_count= chart_rg->result_column_count;
  cha_result_row_count= chart_rg->result_row_count;
  cha_result_set_copy_rows= chart_rg->result_set_copy_rows;
  cha_result_field_names= chart_rg->result_field_names;

  chart_column_types.clear(); /* probably unnecessary, it should be clear initially, and we clear again later */
  {
    chart_column_names.clear();
    QString this_column_name;
    char result_field_name[256];
    char *result_field_names_pointer= &cha_result_field_names[0];
    unsigned int v_length;
    for (unsigned int j= 0; j < cha_result_column_count; ++j)
    {
      memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
      result_field_names_pointer+= sizeof(unsigned int);
      memcpy(result_field_name, result_field_names_pointer, v_length);
      result_field_name[v_length]= '\0';
      result_field_names_pointer+= v_length;
      this_column_name= result_field_name;
      chart_column_names.append(this_column_name);
      unsigned short int chart_column_type= cha_result_data_type(chart_rg->result_field_types[j], this_column_name);
      chart_column_types.append(chart_column_type);
    }
  }

  set_color_palette(); /* we also call this in default_settings_all, unnecessarily. have to do it before draw_text_prepare */

  /*
    In result_grid->evaluate_for_chart() we found that there is a SET OCELOT_GRID_CHART statement.
    So we created a QChart. Check if it's applicable. If it is, each chartable column should have a spec != "".
  */
  //cha_numeric_column_count= 0;
  chart_chartable_columns_count= 0; /* # of chartable columns */
  chart_column_specs.clear(); /* probably unnecessary */

  /* If ocelot_grid_chart > "" and there are no conditionals, every numeric column is chartable. */
  QString spec= parent_mainwindow->ocelot_grid_chart;

  int conditional_count= 0;
  for (int i= 0; i < parent_mainwindow->conditional_settings.count(); ++i)
  {
    if (parent_mainwindow->conditional_settings.at(i).left(22) == "SET OCELOT_GRID_CHART ") ++conditional_count;
  }
  if (conditional_count == 0) /* no ocelot_grid_chart conditionals? */
  {
    if (spec == "") return; /* and no ocelot_grid_chart_unconditional? then return with chart_chartable_count -- 0 */
    for (unsigned int i= 0; i < cha_result_column_count; ++i)
    {
       unsigned short int rft= cha_result_data_type(chart_rg->result_field_types[i], chart_column_names[i]);
       if (rft == OCELOT_DATA_TYPE_NUMBER)
       {
         //++cha_numeric_column_count;
         ++chart_chartable_columns_count;
         chart_column_specs.append(spec);
       }
       else chart_column_specs.append("");
     }
  }
  else /* there are conditionals */
  {
    for (unsigned int i= 0; i < cha_result_column_count; ++i)
    {
      unsigned short int rft= cha_result_data_type(chart_rg->result_field_types[i], chart_column_names[i]);
      if (rft == OCELOT_DATA_TYPE_NUMBER)
      {
        //++cha_numeric_column_count;
        /* if (cha_numeric_column_count == CHART_MAX_GROUP_SIZE) break; */ /* maybe a limit is good, though? */
        cha_draw_text_prepare(
                NULL, /* ?????? should be QPainter! we haven't made pixmap_painter yet */
                i, /* column_number */
                chart_column_names[i], /* column_name */
                0, /* row_number -- actually I don't know it */
                TEXTEDITFRAME_CELL_TYPE_DETAIL,
                i, /* column_number */
                cha_result_column_count); /* numeric_column_count */
      }
      else
      {
        chart_column_specs.append("");
      }
    }
  }
  if (chart_chartable_columns_count == 0) return; /* if not truly chartable, we'll delete chart and do a normal display */

  /* TODO: We would already know cha_numeric_column_count if we would call cha_setup()?! */
  cha_numeric_column_count= 0;
  for (unsigned int i= 0; i < cha_result_column_count; ++i)
  {
    unsigned short int rft= cha_result_data_type(chart_rg->result_field_types[i], chart_column_names[i]);
    if (rft == OCELOT_DATA_TYPE_NUMBER)
    {
      ++cha_numeric_column_count;
      /* if (cha_numeric_column_count == CHART_MAX_GROUP_SIZE) break; */ /* maybe a limit is good, though? */
    }
  }
  /* Following will be superseded because min and max are per-row  now */
  cha_max_column_height= 0;
  cha_max_column_value= 0;  /* because base is always 0 even if all negative|positive */
  cha_min_column_value= 0;
  default_settings_all();
#if (OCELOT_CHART_EVENTFILTER == 1)
  installEventFilter(this);
#endif
}

void Chart::default_settings_all()
{
  {
    QPalette p= QPalette();
    p.setColor(QPalette::Window, chart_mainwindow->ocelot_grid_background_color);
    setAutoFillBackground(true); /* is this necessary, or is it default? */
    setPalette(p);
  }
  set_color_palette();
  chart_default_font= chart_mainwindow->get_font_from_style_sheet(chart_mainwindow->ocelot_grid_style_string);
  setFont(chart_default_font); /* might be overridden by a grid conditional */
  QFontMetrics fm= QFontMetrics(chart_default_font);
  set_chart_pixmap_height(); /* todo: this is calculated again in draw_group, maybe shouldn't be here */
  cha_default_text_color= chart_mainwindow->qt_color(chart_mainwindow->ocelot_grid_text_color);
  cha_default_header_background_color= chart_mainwindow->qt_color(chart_mainwindow->ocelot_grid_header_background_color);
  cha_default_detail_background_color= chart_mainwindow->qt_color(chart_mainwindow->ocelot_grid_background_color);
  cha_default_container_pen_width= chart_mainwindow->ocelot_grid_cell_border_size.toInt();
  if (cha_default_container_pen_width < 1) cha_default_container_pen_width= 1;
  cha_default_container_pen.setColor(chart_mainwindow->qt_color(chart_mainwindow->ocelot_grid_cell_border_color));
  cha_default_container_pen.setWidth(cha_default_container_pen_width);
  cha_default_header_brush.setStyle(Qt::SolidPattern);
  cha_default_header_brush.setColor(cha_default_header_background_color);
  cha_default_detail_brush.setStyle(Qt::SolidPattern);
  cha_default_detail_brush.setColor(cha_default_detail_background_color);
  cha_default_text_pen.setColor(cha_default_text_color);
  group_header= ""; /* not sure that we use this any more */
  chart_header_widths.clear();
  for (unsigned int i= 0; i < cha_result_column_count; ++i) chart_header_widths.append(0);
}

/*
  Return general type i.e. STRING i.e. any string or NUMBER i.e. any number or BLOB i.e. other.
  Todo: since we might call this frequently we might want to save the result.
  Todo: there might be some generic function elsewhere that does something similar to this, look around.
  For example, maybe NUM_FLAG means something.
  But some functions might say BOOL and BIT are numeric, which we don't want.
  Todo: Special case: don't include columns whose names end with _id since by convention _id is for identifiers.
*/
unsigned short int Chart::cha_result_data_type(unsigned short int result_field_type, QString column_name)
{
  if (column_name.right(3).toUpper() == "_ID") return OCELOT_DATA_TYPE_BLOB;
  unsigned short int ft= result_field_type;
  if ((ft == OCELOT_DATA_TYPE_DATE) || (ft == OCELOT_DATA_TYPE_TIME) || (ft == OCELOT_DATA_TYPE_DATETIME)
   || (ft == OCELOT_DATA_TYPE_VAR_STRING) || (ft == OCELOT_DATA_TYPE_STRING) || (ft == OCELOT_DATA_TYPE_TEXT))
    return OCELOT_DATA_TYPE_STRING;
  if ((ft == OCELOT_DATA_TYPE_DECIMAL) || (ft == OCELOT_DATA_TYPE_TINY) || (ft == OCELOT_DATA_TYPE_SHORT)
   || (ft == OCELOT_DATA_TYPE_LONG) || (ft == OCELOT_DATA_TYPE_FLOAT) || (ft == OCELOT_DATA_TYPE_DOUBLE)
   || (ft == OCELOT_DATA_TYPE_LONGLONG) || (ft == OCELOT_DATA_TYPE_INT24)
   || (ft == OCELOT_DATA_TYPE_NEWDECIMAL) || (ft == OCELOT_DATA_TYPE_INTEGER)
   || (ft == OCELOT_DATA_TYPE_UNSIGNED) || (ft == OCELOT_DATA_TYPE_NUMBER))
    return OCELOT_DATA_TYPE_NUMBER;
  if (ft == OCELOT_DATA_TYPE_NULL) return OCELOT_DATA_TYPE_NUMBER; /* But NULL isn't a number! Just for testing though. */
  return OCELOT_DATA_TYPE_BLOB;
}

/*
  Supersede cha_setup. Per row.
  We have QList<double> cha_column_values;
  cha_column_values[5].at(5) is for column 5.
  Actually we could determine data type right at the start for all rows, dunno whether we should.
*/
void Chart::chart_row_setup(unsigned int tmp_result_row_number)
{
  chart_max_column_heights= 0;
  chart_max_column_values= 0;  /* because base is always 0 even if all negative|positive */
  chart_min_column_values= 0;

  char *row_pointer;
  int column_length;

  long unsigned int r= tmp_result_row_number;
  {
    row_pointer= cha_result_set_copy_rows[r];
    chart_column_types.clear();
    cha_column_values.clear();
    cha_column_values_as_strings.clear();
    cha_column_flags.clear();
    for (unsigned int i= 0; i < cha_result_column_count; ++i)
    {
      memcpy(&column_length, row_pointer, sizeof(unsigned int));
      char flag= *(row_pointer + sizeof(unsigned int));
      cha_column_flags.append(flag);
      row_pointer+= sizeof(unsigned int) + sizeof(char);
      QByteArray m(row_pointer, column_length);
      unsigned short int chart_column_type= cha_result_data_type(chart_rg->result_field_types[i], chart_column_names[i]);
      chart_column_types.append(chart_column_type);
      QString column_value_as_string= QString(m);
      double column_value= column_value_as_string.toDouble();
      if (chart_column_type == OCELOT_DATA_TYPE_NUMBER)
      {
        if (column_value > chart_max_column_values) chart_max_column_values= column_value;
        if (column_value < chart_min_column_values) chart_min_column_values= column_value;
      }
      else column_value= 0;
      cha_column_values.append(column_value);
      cha_column_values_as_strings.append(column_value_as_string);
      row_pointer+= column_length;
    }
  }

  /* Phase 2 */
  cha_heights.clear();
  chart_max_column_heights= 0;

  QFontMetrics fm= QFontMetrics(chart_default_font);

  double range_of_column_values;
  if (chart_max_column_values >= 0)
    range_of_column_values= chart_max_column_values - chart_min_column_values;
  else
    range_of_column_values= 0 - chart_min_column_values;
  double minimum_pixels= fm.boundingRect("W").height();

  double shrink_or_expand= chart_bar_line_pie_height / (range_of_column_values * minimum_pixels);
//  if (shrink_or_expand > 1) shrink_or_expand= 1;

  /* Todo: if numeric_column_count == 0, see what happens. */
//  for (int text_lines= 0; text_lines < cha_numeric_column_count; ++text_lines)

  {
    for (int i= 0; i < cha_column_values.size(); ++i)
    {
      int height;
      if (chart_column_types.at(i) == OCELOT_DATA_TYPE_NUMBER)
      {
        double cv;
        cv= cha_column_values.at(i);
        height= round(cv * minimum_pixels * shrink_or_expand);
        if (height > chart_max_column_heights) chart_max_column_heights= height;

      }
      else height= 0;
      cha_heights.append(height);
    }
  }

  /* Values and heights can be negative. If all are negative, max=0 and min is most-negative.
     If all are positive, min=0 and max is most-positive. So zero_line can be above or within or below all.
     We'll need to take abs(height) from the zero line later.
  */
  //double zero_value;
  //if (chart_min_column_values >= 0) zero_value= chart_max_column_values;
  //else
  //{
  // if (chart_max_column_values > 0) zero_value= abs(chart_max_column_values);
  // else zero_value= 0;
  //}
  //chart_height_of_zero_line= abs(round(zero_value * minimum_pixels * shrink_or_expand));

  chart_bar_width= fm.boundingRect("W").width();
  cha_chart_column_plus_margin_width= cha_max_column_width;            /* column of chart not column of result set */
  if ((chart_type == TOKEN_KEYWORD_BAR) && (chart_bar_width * cha_numeric_column_count > cha_chart_column_plus_margin_width))
    cha_chart_column_plus_margin_width= chart_bar_width * cha_numeric_column_count;
  if ((chart_type == TOKEN_KEYWORD_PIE) && (chart_bar_line_pie_height > cha_chart_column_plus_margin_width))
    cha_chart_column_plus_margin_width= chart_bar_line_pie_height; /* pies are round */
  cha_chart_column_plus_margin_width+= CHART_MARGIN_LEFT + CHART_MARGIN_RIGHT;  /* "* 2" is arbitrary as extra margin */

  /* todo: this could be too small, a minimum negative value could be wider */
  cha_max_column_value_as_utf8= QString::number(chart_max_column_values);
  cha_left_width= fm.boundingRect(cha_max_column_value_as_utf8).width();
  /* First bar or line or pie should start just after the vertical line */
  cha_x= cha_left_width + cha_default_container_pen_width + CHART_MARGIN_LEFT;

/* NO. numeric_column_count only applies for a certain number of columns? THIS CHECKS ALL. Might be 2 pies! */
  if (chart_type == TOKEN_KEYWORD_PIE) /* todo: maybe we should merge this with other totallers above */
  {
    /* Later when total_height / cha_max_total_height = 1 we fill the column, else we fill less. */
    chart_max_total_heights= 0;
    double total_height;
    for (int i= 0; i < chart_column_names.size(); ++i)
    {
      if (chart_column_types.at(i) == OCELOT_DATA_TYPE_NUMBER)
      {
        if ((i == 0) || (chart_column_types.at(i - 1) != OCELOT_DATA_TYPE_NUMBER))
        {
          total_height= 0; /* series start */
        }
        if (cha_heights.at(i) > 0) total_height+= cha_heights.at(i);
        if ((i == chart_column_names.size()) - 1 || (chart_column_types.at(i + 1) != OCELOT_DATA_TYPE_NUMBER))
        {
          if (total_height > chart_max_total_heights) chart_max_total_heights= total_height; /* series end */
        }
      }
    }
  }
  set_byte_size();
}

/* Possible pen and brush change due to grid conditional, very similar to erd_draw_text_prepare */
/* Todo: conditional with column_number=2 gets column 1 */
/* Todo: conditional with row_number=2 gets row 2 but I don't understand, shouldn't column_names affect it? */
/* We don't use background_color because bar color should equal text color of column (header line) */
/* TODO: check: column_number always == text_lines?? */
void Chart::cha_draw_text_prepare(QPainter *painter,
               int column_number,    /* so we can get xpos i.e. column_number and ypos i.e. row_number */
               QString content,     /* table_name | column_name */
               int row_number,
               int cell_type,       /* TEXTEDITFRAME_CELL_TYPE_DETAIL | TEXTEDITFRAME_CELL_TYPE_HEADER */
               int text_lines,
               int numeric_column_count)
{
  (void)painter;
  /* If there's only 1 num col, default color=grid color. Else default color=palette. Can be overridden. */
  QColor this_color;
  if (numeric_column_count < 2) this_color= cha_default_text_color;
  else
  {
    char new_color[8];
    int color_number= text_lines - chart_first_column_in_group;
    strcpy(new_color, cha_color_palette[color_number % cha_color_palette_count]);
    this_color= QColor(new_color);
  }
  chart_new_rect_brush= cha_default_detail_brush;
  chart_new_rect_brush.setColor(this_color);
  chart_new_container_pen= cha_default_container_pen;
  chart_new_container_pen.setColor(this_color);
  chart_new_text_pen= cha_default_text_pen;
  chart_new_text_pen.setColor(this_color);
  QString string= content.trimmed();
  QByteArray string_utf8= string.toUtf8();
  QString new_tooltip, new_style_sheet, new_cell_height, new_cell_width, new_text;
  int cs_number;
  bool result_of_evaluate;
  /* This was going via explorer widget. I forget why. */

  result_of_evaluate= chart_rg->conditional_setting_evaluate_till_true(
    column_number + 0, /* i.e. result set column number. dunno why +1, it's really off by 1 */
    row_number + 1, /* e.g. text_frame->ancestor_grid_result_row_number */
    string_utf8.data(), /* e.g. text_frame->content_pointer */
    0, /* e.g. FIELD_VALUE_FLAG_IS_NULL */
    string_utf8.size(), /* e.g. text_frame->content_length */
    cell_type, /* e.g. text_frame->cell_type */
    &new_tooltip, /* return */
    &new_style_sheet, /* return */
    &new_cell_height, /* return */
    &new_cell_width, /* return */
    &cs_number,
    &new_text, /* return */
    chart_rg); /* because I don't understand how "this" works */
  if (result_of_evaluate == true)
  {
    chart_column_specs.append(new_text);
    ++chart_chartable_columns_count;
  //  ++cha_numeric_column_count; /* though I think cha_numeric_column_count might be obsolete */
  }
  else
  {
    chart_column_specs.append("");
  }

  /* At the moment painter == NULL so this is the wrong place */
  //if (result_of_evaluate == true)
  //{
  //  QString new_color= chart_mainwindow->get_color_from_style_sheet(new_style_sheet);
  //  chart_new_rect_brush.setColor(new_color);
  //  chart_new_container_pen.setColor(new_color);
  //  chart_new_text_pen.setColor(new_color);
  //  /* This changes weight and style but not size. Original setting was in points not pixels. */
  //  QFont qf= chart_mainwindow->get_font_from_style_sheet(new_style_sheet);
  //  int point_size= chart_default_font.pointSize();
  //  qf.setPointSize(point_size);
  //  painter->setFont(qf);
  //}
  //else
  //{
  //  painter->setFont(chart_default_font);
  //}
}

/* Todo: This is a copy of set_color_palette() in class erd. Duplicate code should be merged. */
void Chart::set_color_palette()
{
  const char *palette[]= {
    "#000000", /* black */
    "#FFFFFF", /* white */
    "#FF0000", /* red */
    "#00FF00", /* lime */
    "#0000FF", /* blue */
    "#FFFF00", /* yellow */
    "#00FFFF", /* cyan | aqua */
    "#FF00FF", /* magenta | fuchsia */
    "#C0C0C0", /* silver */
    "#808080", /* gray */
    "#800000", /* maroon */
    "#808000", /* olive */
    "#008000", /* green */
    "#800080", /* purple */
    "#008080", /* teal */
    "#000080", /* navy */ };
  QColor bcolor, ccolor;
  char color_utf8[80];
  strcpy(color_utf8, chart_mainwindow->ocelot_grid_background_color.toUtf8());
  bcolor= QColor(color_utf8);
  cha_color_palette_count= 0;
  for (int i= 0; i < 16; ++i)
  {
    ccolor= QColor(palette[i]);
    if ((ccolor.red() >= bcolor.red() - 64) && (ccolor.red() <= bcolor.red() + 64))
    {
      if ((ccolor.blue() >= bcolor.blue() - 64) && (ccolor.blue() <= bcolor.blue() + 64))
      {
        if ((ccolor.green() >= bcolor.green() - 64) && (ccolor.green() <= bcolor.green() + 64))
        {
          continue; /* too close */
        }
      }
    }
    strcpy(cha_color_palette[cha_color_palette_count++], palette[i]);
  }
}

/*
  Return 0 for first column in group,
  Return 1 for second column in group etc.
  Return -1 for "not a chartable column at all"
  We draw all columns in group when we see the last, so it's necessary to set both first and last.
*/
int Chart::column_in_group(int result_column_no)
{
  QString spec= chart_column_specs.at(result_column_no);
  /* Compare to this test: if ((result_grid->result_field_flags[result_column_no] & NUM_FLAG) != 0) */
  if (spec == "") return -1; /* not even a number, or doesn't match a conditional */
  for (int i= result_column_no;; --i)
  {
    if ((i == 0) || (chart_column_specs.at(i - 1) != spec))
    {
      chart_first_column_in_group= i;
      break;
    }
  }
  chart_last_column_in_group= result_column_no;
  for (int i= result_column_no + 1; ; ++i)
  {
    if (i >= chart_column_specs.size())
    {
      chart_last_column_in_group= i - 1;
      break;
    }
    QString chart_column_spec= chart_column_specs.at(i);
    if (chart_column_spec != spec)
    {
      chart_last_column_in_group= i - 1;
      break;
    }
  }
  return result_column_no - chart_first_column_in_group; /* so return will be >= 0 for a member of a group */
#ifdef NOTQQ
  /* Compare to this test: if ((result_grid->result_field_flags[result_column_no] & NUM_FLAG) != 0) */
  if (chart_column_types.at(result_column_no) != OCELOT_DATA_TYPE_NUMBER) return -1; /* not even a number */
  for (int i= result_column_no;; --i)
  {
    if ((i == 0) || (chart_column_types.at(i - 1) != OCELOT_DATA_TYPE_NUMBER))
    {
      chart_first_column_in_group= i;
      break;
    }
  }
  chart_last_column_in_group= result_column_no;
  for (int i= result_column_no + 1; ; ++i)
  {
    if (i >= chart_column_types.size())
    {
      chart_last_column_in_group= i - 1;
      break;
    }
    int chart_column_type= chart_column_types.at(i);
    if (chart_column_type != OCELOT_DATA_TYPE_NUMBER)
    {
      chart_last_column_in_group= i - 1;
      break;
    }
  }
  return result_column_no - chart_first_column_in_group; /* so return will be >= 0 for a member of a group */
#endif
}

#ifdef QQ
/* Copied from Chart:... */
/*
  Return 0 for first column in group,
  Return 1 for second column in group etc.
  Return -1 for "not a chartable column at all"
  We draw all columns in group when we see the last, so it's necessary to set both first and last.
*/
int QChart::column_in_group(int result_column_no)
{
  QString spec= chart_column_specs.at(result_column_no);
  /* Compare to this test: if ((result_grid->result_field_flags[result_column_no] & NUM_FLAG) != 0) */
  if (spec == "") return -1; /* not even a number, or doesn't match a conditional */
  for (int i= result_column_no;; --i)
  {
    if ((i == 0) || (chart_column_specs.at(i - 1) != spec))
    {
      chart_first_column_in_group= i;
      break;
    }
  }
  chart_last_column_in_group= result_column_no;
  for (int i= result_column_no + 1; ; ++i)
  {
    if (i >= chart_column_specs.size())
    {
      chart_last_column_in_group= i - 1;
      break;
    }
    QString chart_column_spec= chart_column_specs.at(i);
    if (chart_column_spec != spec)
    {
      chart_last_column_in_group= i - 1;
      break;
    }
  }
  return result_column_no - chart_first_column_in_group; /* so return will be >= 0 for a member of a group */
}
#endif

/*
  null_value is used for NULL. Could be max in subgroup or max in row, but choice here is max in group.
  Todo: If all values are less than zero we should choose min instead.
  Todo: maybe values should be different for bar, line, pie
  Todo: I'm not sure about how stacked should be handled, especially if all values negative
  Todo: I'm not sure about how pie should be handle, especially if all values negative
*/
double Chart::null_value(double group_max_column_value, double group_min_column_value, int chart_type, bool is_stacked)
{
  if (is_stacked == true) return 0;
  if (chart_type == TOKEN_KEYWORD_PIE) return 0;
  if ((group_max_column_value <= 0) && (group_min_column_value < 0)) return group_min_column_value;
  return group_max_column_value;
}

/*
  Currently the subgroup options are:
    default (effectively subgrouped by column_number % 1)
    value % 3
    and coming soon: left(...)
  Return number of different sub_groups.
  Todo: Call when you get a new column to show. Currently we're calling separately for line | pie.
  Todo: There's no difference in a value calculation between 0 and NULL.
  Todo: But how does % work if we can't convert the value to an integer?
*/
void Chart::make_sub_group_list()
{
  int modulo= 1;
  int left= 1;
  chart_sub_group_list_sub_group_numbers.clear();
  chart_sub_group_list_column_numbers.clear();

  chart_sub_group_by= 0; /* default is no subgroup, or if LINE default is left(column_name,0) */
  int i_of_subgroup= offset_of_keyword("SUBGROUP");

  if ((i_of_subgroup < 0) && (chart_type == TOKEN_KEYWORD_LINE))
  {
    left= 0;
    chart_sub_group_by= TOKEN_KEYWORD_COLUMN_NAME;
  }

  if ((i_of_subgroup >= 0) && (offset_of_keyword("BY") == i_of_subgroup + 1))
  {
    if ((offset_of_keyword("VALUE") == i_of_subgroup + 2)
     && (offset_of_keyword("%") == i_of_subgroup + 3))
    {
      QString s= chart_spec.mid(chart_token_offsets[i_of_subgroup + 4], chart_token_lengths[i_of_subgroup + 4]);
      modulo= s.toInt();
      if (modulo < 1) modulo= 1; /* I'm only worried about overflow so modulo == 0 might have been okay */
      if (modulo != 1) chart_sub_group_by= TOKEN_KEYWORD_VALUE;
    }
    if ((offset_of_keyword("LEFT") == i_of_subgroup + 2)
      && (offset_of_keyword("(") == i_of_subgroup + 3)
      && (offset_of_keyword("COLUMN_NAME") == i_of_subgroup + 4)
      && (offset_of_keyword(",") == i_of_subgroup + 5))
    {
      QString s= chart_spec.mid(chart_token_offsets[i_of_subgroup + 6], chart_token_lengths[i_of_subgroup + 6]);
      left= s.toInt();
      chart_sub_group_by= TOKEN_KEYWORD_COLUMN_NAME;
    }
  }

  int sub_group_number;

  QList<int> sub_group_list_values;
  QList<QString> sub_group_list_column_names;
  /* The value % x method, with some workarounds in case there are fewer than x subgroups */
  for (int i= chart_first_column_in_group; i <= chart_last_column_in_group; ++i)
  {
    int sub_group_value= 1;
    QString sub_group_column_name= "";
    if (chart_sub_group_by == TOKEN_KEYWORD_VALUE)
    {
      double v= cha_column_values.at(i);
      int v_as_int= (int) v; /* hmm, rounding would be better, eh? */ /* what if it's outside integer range? */
      v_as_int= abs(v_as_int); /* otherwise negative values cause unexpected problemss */
      //sub_group_number= v_as_int % 3;
      sub_group_value= v_as_int % modulo;
    }
    if (chart_sub_group_by == TOKEN_KEYWORD_COLUMN_NAME)
    {
      QString s= chart_column_names.at(i);
      sub_group_column_name= s.left(left);
    }
    sub_group_number= sub_group_list_values.count();
    int max_sub_group_number= -1;
    int j= 0;
    for (j= 0; j < sub_group_list_values.count(); ++j)
    {
      if (chart_sub_group_by == TOKEN_KEYWORD_VALUE)
      {
        if (sub_group_value == sub_group_list_values.at(j))
        {
          sub_group_number= chart_sub_group_list_sub_group_numbers.at(j);
          break;
        }
      }
      if (chart_sub_group_by == TOKEN_KEYWORD_COLUMN_NAME)
      {
        if (sub_group_column_name == sub_group_list_column_names.at(j))
        {
          sub_group_number= chart_sub_group_list_sub_group_numbers.at(j);
          break;
        }
      }
      if (max_sub_group_number < chart_sub_group_list_sub_group_numbers.at(j)) max_sub_group_number= chart_sub_group_list_sub_group_numbers.at(j);
    }
    if (j == sub_group_list_values.count()) sub_group_number= max_sub_group_number + 1;
    chart_sub_group_list_sub_group_numbers.append(sub_group_number);
    chart_sub_group_list_column_numbers.append(i);
    sub_group_list_values.append(sub_group_value);
    sub_group_list_column_names.append(sub_group_column_name);
  }
  int sub_group_count= 0;
  if (chart_sub_group_list_sub_group_numbers.size() > 0)
  {
    int max_sub_group_number= 0;
    for (int i= 0; i < chart_sub_group_list_sub_group_numbers.count(); ++i)
    {
      if (chart_sub_group_list_sub_group_numbers.at(i) > max_sub_group_number) max_sub_group_number= chart_sub_group_list_sub_group_numbers.at(i);
    }
    sub_group_count= max_sub_group_number + 1;
  }
  chart_sub_group_count= sub_group_count;
}

/*
  Pass: number
  Return: bar|line|pie pixmap which can be displayed in result grid
  A group is a series of numbers preceded by before-start or non-chartable, followed by after-end or non-chartable.
  Todo: Inefficiency: This ends up in base64_tmp. We could dump directly to tmp_pointer.
  Todo: Inefficiency: Surely the size can be figured out in advance so we could memcpy not strcpy.
  Re bar width: minimum is chart_bar_width which is width of a char's boundingRect(), but if cell can fit wider
                then stretch_bar_width = (bar_line_pie_width - margins) / number-of-columns-in-group,
                reversing width_of_bars calculation in chart_set_width()
*/
int Chart::draw_group(
        long unsigned int tmp_result_row_number,
        int result_column_no, /* this might happen to = chart_last_column_in_group but we don't use it now */
        int width_i,
        char *output)
{
  (void)tmp_result_row_number;
  (void)result_column_no;
  (void)width_i;
  /* The list of tokens in the literal of a SET OCELOT_GRID_CHART= statement */
  {
    chart_spec= chart_column_specs.at(chart_first_column_in_group);
    chart_mainwindow->tokenize(chart_spec.data(),
           chart_spec.size(),
           &chart_token_lengths[0], &chart_token_offsets[0], CHART_MAX_TOKENS - 1,
          (QChar*)"33333", 2, "", 1);
  }
  if (offset_of_keyword("BAR") >= 0) {chart_type= TOKEN_KEYWORD_BAR; }
  else if (offset_of_keyword("LINE") >= 0) {chart_type= TOKEN_KEYWORD_LINE; }
  else if (offset_of_keyword("PIE") >= 0) {chart_type= TOKEN_KEYWORD_PIE; }
  else chart_type= TOKEN_KEYWORD_BAR; /* though actually it's an error if bar|line|pie not in literal */

  make_sub_group_list();

  bool is_horizontal= true;
  if ((chart_type == TOKEN_KEYWORD_BAR) && (offset_of_keyword("VERTICAL") >= 0)) is_horizontal= false;

  bool is_stacked= false;
  if ((chart_type == TOKEN_KEYWORD_BAR) && (offset_of_keyword("STACKED") >= 0)) is_stacked= true;

  QString right= "LEGEND";
  {
    int offset_of_right= offset_of_keyword("RIGHT");
    if (offset_of_right >= 0)
    {
      QString s= chart_spec.mid(chart_token_offsets[offset_of_right + 1], chart_token_lengths[offset_of_right + 1]);
      if (s == "=")
      {
        right= chart_spec.mid(chart_token_offsets[offset_of_right + 2], chart_token_lengths[offset_of_right + 2]);
      }
    }
  }
  QString top= "NULL";
  {
    int offset_of_top= offset_of_keyword("TOP");
    if (offset_of_top >= 0)
    {
      QString s= chart_spec.mid(chart_token_offsets[offset_of_top + 1], chart_token_lengths[offset_of_top + 1]);
      if (s == "=")
      {
        top= chart_spec.mid(chart_token_offsets[offset_of_top + 2], chart_token_lengths[offset_of_top + 2]);
      }
    }
  }
  QString left= "DEFAULT";
  {
    int offset_of_left= offset_of_keyword("LEFT");
    if (offset_of_left >= 0)
    {
      QString s= chart_spec.mid(chart_token_offsets[offset_of_left + 1], chart_token_lengths[offset_of_left + 1]);
      if (s == "=")
      {
        left= chart_spec.mid(chart_token_offsets[offset_of_left + 2], chart_token_lengths[offset_of_left + 2]);
      }
    }
  }
  if (left == "DEFAULT")
  {
    if (is_horizontal == true) left= "samples";
    else left= "values";
  }
  QString bottom= "DEFAULT";
  {
    int offset_of_bottom= offset_of_keyword("BOTTOM");
    if (offset_of_bottom >= 0)
    {
      QString s= chart_spec.mid(chart_token_offsets[offset_of_bottom + 1], chart_token_lengths[offset_of_bottom + 1]);
      if (s == "=")
      {
        bottom= chart_spec.mid(chart_token_offsets[offset_of_bottom + 2], chart_token_lengths[offset_of_bottom + 2]);
      }
    }
  }
  if (bottom == "DEFAULT")
  {
    if (is_horizontal == true) bottom= "values";
    else bottom= "samples";
  }
  QString axis= "all";
  {
    int offset_of_axis= offset_of_keyword("AXIS");
    if (offset_of_axis >= 0)
    {
      QString s= chart_spec.mid(chart_token_offsets[offset_of_axis + 1], chart_token_lengths[offset_of_axis + 1]);
      if (s == "=")
      {
        axis= chart_spec.mid(chart_token_offsets[offset_of_axis + 2], chart_token_lengths[offset_of_axis + 2]);
      }
    }
  }

  set_chart_width();

  /* Eventually rename numeric_column_count to number_of_columns_in_group */
  /* Todo: maybe we can remove this */
  int numeric_column_count= (chart_last_column_in_group - chart_first_column_in_group) + 1;

//  QString column_value_as_utf8= QString(ocelot_grid_detail_char_column_start, v_length);
//  double column_value= QString::number(column_value_as_utf8);
//  printf("**** column_value=%f.\n", column_value);
//  !! and it might be %f
  /* Actually we don't need this, we just use background */

  //QPen pen;
  //pen.setColor(Qt::red); /* Todo: use usual background colour */
  //pen.setWidth(5);

//  int x_of_bar;

  double group_max_column_value= 0;
  double group_min_column_value= 0;
  {
    bool is_group_max_or_min_known= false;
    for (int i= chart_first_column_in_group; i <= chart_last_column_in_group; ++i)
    {
      double v= cha_column_values.at(i);
      if ((chart_type == TOKEN_KEYWORD_PIE) && (v < 0)) v= 0;
      if (is_group_max_or_min_known == false)
      {
        group_max_column_value=  group_min_column_value= v;
        is_group_max_or_min_known= true;
      }
      else
      {
        if (v > group_max_column_value) group_max_column_value= v;
        if (v < group_min_column_value) group_min_column_value= v;
      }
    }
  }

  /* If it's not stacked, the heights will be based on the group max */
  /* How many columns in a subgroup? */
  /* We can't say what the rects are until we know the subgroups. */
  /* The test for outer group match count is understandable */

//   QRect symbols[100]; /* todo: dynamic allocation */
//   QBrush brushes[100];
//   for (int sub_group_number= 0; sub_group_number < chart_sub_group_list_sub_group_numbers.size(); ++sub_group_number)
//   {
//     symbols[sub_group_number].setWidth(chart_bar_width);
//     QBrush brush;
//     brush.setColor(cha_color_palette[sub_group_number % cha_color_palette_count]);
//     brush.setStyle(Qt::SolidPattern);
//     brushes[sub_group_number]= brush;
//   }
   QList<bool> sub_group_list_flags;
   for (int i= 0; i < chart_sub_group_list_sub_group_numbers.count(); ++i) sub_group_list_flags.append(false);
//   chart_bar_chart->setBarTitles(legend_titles); /* This only means "add to legend" */
   QVector< QVector<int> > series;
   for (int k= 0; k < 100; ++k) /* silly test based on assumption we never have > 100 items, surely unnecessary */
   {
     QVector<int> series_columns;
     int outer_group_match_count= 0;
     for (int sub_group_number= 0; sub_group_number < chart_sub_group_count; ++sub_group_number)
     {
       int sub_group_match_count= 0;
       for (int i= 0; i < chart_sub_group_list_sub_group_numbers.size(); ++i)
       {
         if (sub_group_list_flags.at(i) == true) continue;
         if (chart_sub_group_list_sub_group_numbers.at(i) == sub_group_number)
         {
//             chart_bar_chart->setSymbol(sub_group_number, symbols[sub_group_number]);
           int j= chart_sub_group_list_column_numbers.at(i);
           series_columns+= j;
           sub_group_list_flags.replace(i, true);
           ++sub_group_match_count;
           ++outer_group_match_count;
           break;
         }
       }
       if (sub_group_match_count == 0) series_columns+= -1; /* Negative column numbers will be ignored */
     }
     if (outer_group_match_count == 0) break;
     series+= series_columns;
   }

 /* At this point we know: the series has a bunch of series_columns. That's a sample. */

//     chart_bar_chart->setSamples(series);

     /* TODO: NOW YOU CAN DELETE EVERYTHING IN SYMBOLS LIST */
//   }

/* Now we have a series. One series entry per sub_group. Each series entry has one or more series_columns. One per column. */

  int max_series_column_count= 0; /* used for line and pie, might be obvious from some already-calculated item though */
  for (int i_of_series= 0; i_of_series < series.size(); ++i_of_series)
  {
    QVector<int> series_columns= series.at(i_of_series);
    if (series_columns.size() > max_series_column_count) max_series_column_count= series_columns.size();
  }

  /* max stacked value in group, useful iff stacked == true or maybe if pie == true */

  double group_max_stacked_column_value= 0;
  double group_min_stacked_column_value= 0;
  {
    bool is_group_max_or_min_known= false;
    for (int i_of_series= 0; i_of_series < series.size(); ++i_of_series)
    {
      double v= 0;
      QVector<int> series_columns= series.at(i_of_series);
      for (int i_of_series_columns= 0; i_of_series_columns < series_columns.size(); ++i_of_series_columns)
      {
        int series_column= series_columns.at(i_of_series_columns);
        if (series_column >= 0)  /* Negative column numbers will be ignored */
        {
          double value;
          value= cha_column_values[series_column]; /* ?? This does nothing about nulls */ /* ?? should be ABS? */
          if (value > 0) v+= value;
        }
      }
      if (is_group_max_or_min_known == false)
      {
        group_max_stacked_column_value= group_min_stacked_column_value= v;
        is_group_max_or_min_known= true;
      }
      else
      {
        if (v > group_max_stacked_column_value) group_max_stacked_column_value= v;
        if (v < group_min_stacked_column_value) group_min_stacked_column_value= v;
      }
    }
  }

/* Todo: delay pixmap creation till here. */
//  QPixmap pixmap(QPixmap(QSize(width, chart_max_column_heights)));

  QPixmap pixmap(QPixmap(QSize(chart_pixmap_width, chart_pixmap_height)));

  pixmap.fill(chart_mainwindow->ocelot_grid_background_color);
  QPainter pixmap_painter(&pixmap);

  pixmap_painter.setFont(chart_default_font); /* todo: a conditional setting might change this */

/* Now set_chart_rects() might work, since we know series and series_columns. */

//  bool is_horizontal= true;
//  if (offset_of_keyword("VERTICAL") >= 0) is_horizontal= false;
  /*
    If there is an axis, we will display the max value. If there is a stack, this is a combined value.
    Convert to exponential notation if value > 1 billion (arbitrary number) and exponential notation is shorter.
    Remove trailing post-decimal 0s in numbers that are not exponential notation.
    The "%1.e4" in sprintf, i.e. allowing only 4 digits if exponential, is arbitrary.
  */
  QString max_value_for_axis_display; /* if there is an axis, this will be the value that we display */
  {
    char tmp[256], tmp_exponential[256];
    double convertible_value= group_max_column_value;
    if (is_stacked) convertible_value= group_max_stacked_column_value;
    sprintf(tmp, "%f", convertible_value);
    if (strchr(tmp, '.') != NULL)
    {
      for (;;)
      {
        int strlen_tmp= strlen(tmp);
        if (strlen_tmp == 0) break;
        if (tmp[strlen_tmp - 1] == '0') tmp[strlen_tmp - 1]= '\0';
        else
        {
          if (tmp[strlen_tmp - 1] == '.') tmp[strlen_tmp - 1]= '\0';
          break;
        }
      }
    }
    if (convertible_value > 1000000000)
    {
      sprintf(tmp_exponential, "%1.4e", convertible_value);
      if (strlen(tmp) > strlen(tmp_exponential)) strcpy(tmp, tmp_exponential);
   }
    max_value_for_axis_display= tmp;
  }

  set_chart_rects(pixmap.width(), pixmap.height(), numeric_column_count, is_horizontal, top, bottom, left, right, axis, max_value_for_axis_display);

  double group_max_and_min_value; /* this is combined max used when calculating bar or line height/width */
  int zero_line_y, zero_line_x;
  if ((group_min_column_value >= 0) && (group_max_column_value >= 0))/* i.e. if there are no negative values */
  {
    group_max_and_min_value= group_max_column_value; /* i.e. max positive height */
    zero_line_y= zero_line_x= 0;
  }
  else if ((group_max_column_value <= 0) && (group_min_column_value < 0)) /* i.e. if there are no positive values */
  {
    group_max_and_min_value= abs(group_min_column_value); /* i.e. max negative height */
    zero_line_y=  chart_canvas_rect.height();
    zero_line_x= chart_canvas_rect.width();
  }
  else /* i.e. if there are positive and negative values */
  {
    group_max_and_min_value= group_max_column_value + abs(group_min_column_value);
    double zero_ratio= abs(group_min_column_value) / group_max_and_min_value;
    zero_line_y= chart_canvas_rect.height() * zero_ratio;
    zero_line_x= chart_canvas_rect.width() * zero_ratio;
  }

  /* Warning: height or width can be negative. Qt can handle that even if I don't say normalized(), but I do. */

  /* BAR, VERTICAL OR HORIZONTAL, STACKED OR GROUPED */
  int vertical_bar_count= 0;
  if (chart_type == TOKEN_KEYWORD_BAR)
  {
    if (is_stacked == true) ++vertical_bar_count; /* if stacked, there's only one bar in a series */
    else
    {
      for (int i_of_series= 0; i_of_series < series.size(); ++i_of_series)
      {
        QVector<int> series_columns= series.at(i_of_series);
        for (int i_of_series_columns= 0; i_of_series_columns < series_columns.size(); ++i_of_series_columns)
        {
          ++vertical_bar_count;
        }
      }
    }
  }
  vertical_bar_count+= series.size() - 1;

  /* So 2 numbers in the row cause 2 adjacent bars */
  /* todo: consider looking at CHART_MARGIN_BETWEEN_BARS */
  /* BAR, VERTICAL, GROUPED */
  if ((chart_type == TOKEN_KEYWORD_BAR) && (is_horizontal == false) && (is_stacked == false))
  {
    int bar_width= chart_canvas_rect.width() / vertical_bar_count;
    int bar_x= 0;
    for (int i_of_series= 0; i_of_series < series.size(); ++i_of_series)
    {
      QVector<int> series_columns= series.at(i_of_series);
      for (int i_of_series_columns= 0; i_of_series_columns < series_columns.size(); ++i_of_series_columns)
      {
        int series_column= series_columns.at(i_of_series_columns);
        if (series_column >= 0)  /* Negative column numbers will be ignored */
        {
          QBrush brush;
          brush.setColor(cha_color_palette[i_of_series_columns % cha_color_palette_count]);
          double value;
          if ((cha_column_flags.at(series_column) & FIELD_VALUE_FLAG_IS_NULL) == 0)
            {
              value= cha_column_values[series_column];
              brush.setStyle(Qt::SolidPattern);
            }
            else
            {
              value= null_value(group_max_column_value, group_min_column_value, chart_type, is_stacked);
              brush.setStyle(Qt::Dense5Pattern);
            }
//!          double ratio= value / group_max_column_value; /* this ratio would only work when all values positive */
          double ratio= value / group_max_and_min_value;
          int bar_height= chart_canvas_rect.height() * ratio;
          QRect qr_of_bar= QRect(chart_canvas_rect.x() + bar_x,
                       (chart_canvas_rect.y() - zero_line_y) + chart_canvas_rect.height() - bar_height,
                       bar_width,
                       bar_height).normalized();
          pixmap_painter.setBrush(brush);
          pixmap_painter.drawRect(qr_of_bar);
        }
        bar_x+= bar_width;
      }
      bar_x+= bar_width; /* this will be a space between series entries if there is more than one */
    }
  }
  /* BAR, HORIZONTAL, GROUPED */
  if ((chart_type == TOKEN_KEYWORD_BAR) && (is_horizontal == true) && (is_stacked == false))
  {
    int bar_height= chart_canvas_rect.height() / vertical_bar_count;
    int bar_y= 0;
    for (int i_of_series= 0; i_of_series < series.size(); ++i_of_series)
    {
      QVector<int> series_columns= series.at(i_of_series);
      for (int i_of_series_columns= 0; i_of_series_columns < series_columns.size(); ++i_of_series_columns)
      {
        int series_column= series_columns.at(i_of_series_columns);
        if (series_column >= 0)  /* Negative column numbers will be ignored */
        {
          QBrush brush;
          brush.setColor(cha_color_palette[i_of_series_columns % cha_color_palette_count]);
          double value;
          if ((cha_column_flags.at(series_column) & FIELD_VALUE_FLAG_IS_NULL) == 0)
            {
              value= cha_column_values[series_column];
              brush.setStyle(Qt::SolidPattern);
            }
            else
            {
              value= null_value(group_max_column_value, group_min_column_value, chart_type, is_stacked);
              brush.setStyle(Qt::Dense5Pattern);
            }
          double ratio= value / group_max_and_min_value;
          int bar_width= chart_canvas_rect.width() * ratio;
          QRect qr_of_bar= QRect(chart_canvas_rect.x() + zero_line_x,
                         chart_canvas_rect.y() + bar_y,
                         bar_width,
                         bar_height).normalized();
          pixmap_painter.setBrush(brush);
          pixmap_painter.drawRect(qr_of_bar);
        }
        bar_y+= bar_height;
      }
      bar_y+= bar_height; /* this will be a space between series entries if there is more than one */
    }
  }

  /* BAR, VERTICAL, STACKED */
  if ((chart_type == TOKEN_KEYWORD_BAR) && (is_horizontal == false) && (is_stacked == true))
  {
    int bar_width= chart_canvas_rect.width() / vertical_bar_count;
    int bar_x= 0;
    for (int i_of_series= 0; i_of_series < series.size(); ++i_of_series)
    {
      QVector<int> series_columns= series.at(i_of_series);
      int bar_y= chart_canvas_rect.height();
      int bar_height= 0;
      for (int i_of_series_columns= 0; i_of_series_columns < series_columns.size(); ++i_of_series_columns)
      {
        int series_column= series_columns.at(i_of_series_columns);
        if (series_column >= 0)  /* Negative column numbers will be ignored */
        {
          QBrush brush;
          brush.setColor(cha_color_palette[i_of_series_columns % cha_color_palette_count]);
          double value;
          if ((cha_column_flags.at(series_column) & FIELD_VALUE_FLAG_IS_NULL) == 0)
          {
            value= cha_column_values[series_column];
            if (value < 0) value= 0;
            brush.setStyle(Qt::SolidPattern);
          }
          else
          {
            value= null_value(group_max_column_value, group_min_column_value, chart_type, is_stacked);
            brush.setStyle(Qt::Dense5Pattern);
          }
          double ratio= value / group_max_stacked_column_value;
          bar_height= chart_canvas_rect.height() * ratio;
          QRect qr_of_bar= QRect(chart_canvas_rect.x() + bar_x,
                         chart_canvas_rect.y() + (bar_y - bar_height),
                         bar_width,
                         bar_height);
          pixmap_painter.setBrush(brush);
          pixmap_painter.drawRect(qr_of_bar);
        }
        bar_y-= bar_height;
      }
      bar_x+= bar_width; /* this will be a space between series entries if there is more than one */
    }
  }
  /* BAR, HORIZONTAL, STACKED */
  if ((chart_type == TOKEN_KEYWORD_BAR) && (is_horizontal == true) && (is_stacked == true))
  {
    int bar_height= chart_canvas_rect.height() / vertical_bar_count;
    int bar_y= 0;
    for (int i_of_series= 0; i_of_series < series.size(); ++i_of_series)
    {
      QVector<int> series_columns= series.at(i_of_series);
      int bar_x= chart_canvas_rect.x();
      int bar_width= 0;
      for (int i_of_series_columns= 0; i_of_series_columns < series_columns.size(); ++i_of_series_columns)
      {
        int series_column= series_columns.at(i_of_series_columns);
        if (series_column >= 0)  /* Negative column numbers will be ignored */
        {
          QBrush brush;
          brush.setColor(cha_color_palette[i_of_series_columns % cha_color_palette_count]);
          double value;
          if ((cha_column_flags.at(series_column) & FIELD_VALUE_FLAG_IS_NULL) == 0)
          {
            value= cha_column_values[series_column];
            if (value < 0) value= 0;
            brush.setStyle(Qt::SolidPattern);
          }
          else
          {
            value= null_value(group_max_column_value, group_min_column_value, chart_type, is_stacked);
            brush.setStyle(Qt::Dense5Pattern);
          }
          double ratio= value / group_max_stacked_column_value;
          bar_width= chart_canvas_rect.width() * ratio;
          QRect qr_of_bar= QRect(bar_x,
                         chart_canvas_rect.y() + bar_y,
                         bar_width,
                         bar_height);
          pixmap_painter.setBrush(brush);
          pixmap_painter.drawRect(qr_of_bar);
        }
        bar_x+= bar_width;
      }
      bar_y+= bar_height; /* this will be a space between series entries if there is more than one */
    }
  }
  /* LINE */
  /* Paste the line "point" for each series */
  if (chart_type == TOKEN_KEYWORD_LINE)
  {
    int line_width= chart_canvas_rect.width() / vertical_bar_count;

    /* !!!! SHOULD BE LINE_WIDTH BUT WAIT TILL WE KNOW LINE_WIDTH !!!! set_chart_rects() is wrong now */
    line_width= chart_canvas_rect.width() / series.size();

    int line_x= 0;
    int line_point_width= 13; /* arbitrary */
    int line_point_height= 13; /* arbitrary */

    QRect qr_of_last[100]; /* todo: dynamic allocation please */

    for (int i_of_series= 0; i_of_series < series.size(); ++i_of_series)
    {
      QVector<int> series_columns= series.at(i_of_series);
      for (int i_of_series_columns= 0; i_of_series_columns < series_columns.size(); ++i_of_series_columns)
      {
        QBrush brush;
        brush.setColor(cha_color_palette[i_of_series_columns % cha_color_palette_count]);
        int series_column= series_columns.at(i_of_series_columns);
        if (series_column >= 0)  /* Negative column numbers will be ignored */
        {
          double value;
          if ((cha_column_flags.at(series_column) & FIELD_VALUE_FLAG_IS_NULL) == 0)
          {
            value= cha_column_values[series_column];
            brush.setStyle(Qt::SolidPattern);
          }
          else
          {
            value= null_value(group_max_column_value, group_min_column_value, chart_type, is_stacked);
            brush.setStyle(Qt::Dense5Pattern);
          }
          double ratio= value / group_max_and_min_value;
          int line_height= chart_canvas_rect.height() * ratio;
          QRect qr_of_line_point= QRect(chart_canvas_rect.x() + line_x,
                         (chart_canvas_rect.y() - zero_line_y) + (chart_canvas_rect.height() - line_height),
                         line_point_width,
                         line_point_height).normalized();
          pixmap_painter.setBrush(brush);
          pixmap_painter.drawRect(qr_of_line_point);

          if (i_of_series > 0)
          {
            /* draw line from this qr to qr which you saved in last iteration */
            QPen saved_pen= pixmap_painter.pen();
            QPen pen;
            pen.setColor(cha_color_palette[i_of_series_columns % cha_color_palette_count]);
            pen.setWidth(4); /* arbitrary */
            pixmap_painter.setPen(pen);
            pixmap_painter.drawLine(qr_of_line_point.x(), qr_of_line_point.y(),
                                    qr_of_last[i_of_series_columns].x(), qr_of_last[i_of_series_columns].y());
            pixmap_painter.setPen(saved_pen);
          }
          qr_of_last[i_of_series_columns]= qr_of_line_point;

        }
      }
      line_x+= line_width; /* this will be a space between series entries if there is more than one */
    }
  }
  /* PIE */
  /* A full circle is 16 * 360 = 5760 */
  /* Todo: dunno what to do with negatives */
  if (chart_type == TOKEN_KEYWORD_PIE)
  {
    /* Get total of values for each bar in each series */
    double total_values[100];
    for (int i= 0; i < 100; ++i) total_values[i]= 0;

    for (int i_of_series= 0; i_of_series < series.size(); ++i_of_series)
    {
      QVector<int> series_columns= series.at(i_of_series);

      for (int i_of_series_columns= 0; i_of_series_columns < series_columns.size(); ++i_of_series_columns)
      {
        int series_column= series_columns.at(i_of_series_columns);
        if (series_column >= 0)  /* Negative column numbers will be ignored */
        {
          double value;
          if ((cha_column_flags.at(series_column) & FIELD_VALUE_FLAG_IS_NULL) == 0)
          {
            value= cha_column_values[series_column];
            if (value < 0) value= 0;
          }
          else
          {
            value= null_value(group_max_column_value, group_min_column_value, chart_type, is_stacked);
          }
          total_values[i_of_series_columns]+= value;
        }
      }
    }
    int total_total_value= 0;
    for (int i= 0; i < max_series_column_count; ++i)
    {
      total_total_value+= total_values[i];
    }

    int start_angle_of_pie= 0;

//      int x= cha_x;
    /* initially start_angle_of_pie == 0 * 180 */
    for (int column_number= 0; column_number < max_series_column_count; ++column_number)
    {
      if (total_values[column_number] > 0)
      {
        double fraction_of_total_height= total_values[column_number] / total_total_value;
        double adj= 5760 * fraction_of_total_height;
//          QString column_name= chart_column_names.at(column_number);
        QRect qr_of_pie= QRect(chart_canvas_rect.x(),
                             chart_canvas_rect.y(),
                             chart_canvas_rect.width(),
                             chart_canvas_rect.height());
//          cha_draw_text_prepare(painter, column_number, column_name, i, TEXTEDITFRAME_CELL_TYPE_DETAIL,
//                                column_number, cha_numeric_column_count);
        int span_angle= round(adj);
        QBrush *brush= new QBrush(cha_color_palette[column_number % cha_color_palette_count], Qt::SolidPattern);
        pixmap_painter.setBrush(*brush);
        pixmap_painter.drawPie(qr_of_pie, start_angle_of_pie, span_angle);
        delete brush;
        start_angle_of_pie+= span_angle;
      }
    }
  }


#ifdef CANCELLED_STUFF
//  if (chart_type == TOKEN_KEYWORD_BAR) /* actually, true for line too */
  {
    cha_x= CHART_MARGIN_LEFT;
    x_of_bar= cha_x;
//    chart_bar_width= 10; no, it depends on font size and should already be set
    cha_chart_column_plus_margin_width= chart_bar_width; /* OR SOMETHING! */
  }

  int xx= chart_canvas_rect.width()  - ((numeric_column_count - 1) * CHART_MARGIN_BETWEEN_BARS);
  int stretch_bar_width= xx / numeric_column_count;

  if (stretch_bar_width < chart_bar_width) stretch_bar_width= chart_bar_width;

  int start_angle_of_pie;
  double height_of_pie;
  double total_height_of_pie= 0;
  int height_of_pie_rounded= 0;
  double shrink_of_pie;

  int prev_x_of_bar= 0;       /* for line */
  int prev_y= 0;

  int caption_x= 0;


  if (chart_type == TOKEN_KEYWORD_PIE)
  {
//    for (int i= 0; i < chart_column_names.size(); ++i)
    {
//      int x_of_pie= cha_x;
//      x_of_pie+= chart_bar_line_pie_height * i;
      total_height_of_pie= 0;
      for (int column_number= chart_first_column_in_group; column_number <= chart_last_column_in_group; ++column_number)
      {
        if (cha_heights.at(column_number) >= 0)
          total_height_of_pie+= cha_heights.at(column_number); /* i.e. total height of this group */
      }
      shrink_of_pie= total_height_of_pie / chart_max_total_heights; /* if you want all pies equal size, let shrink be 1 */
      double max_area= chart_bar_line_pie_height * chart_bar_line_pie_height; /* e.g. 10 x 10 = 100 */
      double area_of_pie= max_area * shrink_of_pie;          /* e.g. 100 * .5 = 50 */
      height_of_pie= sqrt(area_of_pie);                            /* e.g. sqrt(50) = 7.071 */
      height_of_pie_rounded= round(height_of_pie);                      /* e.g. round(7.071) = 7 */
    }
    start_angle_of_pie= 0 * 180;
  }
  for (int column_number= chart_first_column_in_group; column_number <= chart_last_column_in_group; ++column_number)
  {
    /* Set chart_new_rect_brush etc. to chart_default_rect_brush etc., maybe change if conditional setting */
    QString column_name= chart_column_names.at(column_number); /* misnamed? isn't this content? */

    if ((cha_column_flags.at(column_number) & FIELD_VALUE_FLAG_IS_NULL) != 0)
      chart_new_rect_brush.setColor(chart_mainwindow->ocelot_grid_background_color);
    cha_draw_text_prepare(&pixmap_painter, column_number, column_name, tmp_result_row_number, TEXTEDITFRAME_CELL_TYPE_DETAIL,
                          column_number, numeric_column_count);
    pixmap_painter.setBrush(chart_new_rect_brush);
    if (chart_type == TOKEN_KEYWORD_LINE) pixmap_painter.setPen(chart_new_container_pen);
    /* cha_draw_text_prepare also set chart_new_text_pen, for captions, below */
    int bar_or_line_height= cha_heights.at(column_number); /* i.e. bar height */
    if ((cha_column_flags.at(column_number) & FIELD_VALUE_FLAG_IS_NULL) != 0)
      bar_or_line_height= chart_max_column_heights / 2;

    int bar_or_line_y= chart_max_column_heights - bar_or_line_height;
    int bar_or_line_column_height= cha_heights.at(column_number);
    /* TODO: Look at heights, not values? */
    {
      if (cha_column_values.at(column_number) >= 0)
      {
    //          column_height-= chart_height_of_zero_line;
      }
      else
      {
        bar_or_line_y= chart_max_column_heights;
        bar_or_line_column_height= abs(bar_or_line_column_height);
      }
    }
    if (chart_type == TOKEN_KEYWORD_BAR)      /* So 2 numbers in the row cause 2 adjacent bars */
    {
      if (is_horizontal == true)
      {
        printf("**** horizontal\n");
        int tmp_x_of_bar= chart_canvas_rect.x();
        int tmp_number_of_columns= (chart_last_column_in_group - chart_first_column_in_group) + 1; /* ?? already known? */
        int tmp_bar_height= chart_canvas_rect.height() / tmp_number_of_columns;
        int tmp_y_of_bar= chart_canvas_rect.y() + ((column_number - chart_first_column_in_group) * tmp_bar_height);
        double height_width_ratio= (double) chart_canvas_rect.height() / (double) chart_canvas_rect.width();
        int tmp_bar_or_line_column_height= (double) bar_or_line_column_height / height_width_ratio;
        printf("****   chart_canvas_rect.height()=%d. chart_canvas_rect_width()=%d.\n", chart_canvas_rect.height(), chart_canvas_rect.width());
        printf("****   tmp_x_of_bar=%d.\n", tmp_x_of_bar);
        printf("****   tmp_number_of_columns=%d.\n", tmp_number_of_columns);
        printf("****   tmp_bar_height=%d.\n", tmp_bar_height);
        printf("****   tmp_y_of_bar=%d.\n", tmp_y_of_bar);
        printf("****   height_width_ratio=%f.\n", height_width_ratio);
        printf("****   bar_or_line_column_height=%d.\n", bar_or_line_column_height);
        printf("****   tmp_bar_or_line_column_height=%d.\n", tmp_bar_or_line_column_height);
        QRect qr_of_bar;
        qr_of_bar= QRect(tmp_x_of_bar,
                         tmp_y_of_bar,
                         tmp_bar_or_line_column_height,
                         tmp_bar_height);
        pixmap_painter.drawRect(qr_of_bar);
      }
      else /* if (is_horizontal == false) */
      {
//      int height= cha_heights.at(column_number); /* i.e. bar height */
//      int y= chart_max_column_heights - height;
        x_of_bar= cha_x;
        x_of_bar+= (stretch_bar_width + CHART_MARGIN_BETWEEN_BARS) * (column_number - chart_first_column_in_group);
        QRect qr_of_bar;
        qr_of_bar= QRect(chart_canvas_rect.x() + x_of_bar,
                         chart_canvas_rect.y() + bar_or_line_y,
                         stretch_bar_width,
                         bar_or_line_column_height);
        pixmap_painter.drawRect(qr_of_bar);
      }
    }
    if (chart_type == TOKEN_KEYWORD_LINE)
    {
//      int height= cha_heights.at(column_number); /* i.e. bar height */
//      int y= chart_max_column_heights - height;
      x_of_bar= cha_x;
      x_of_bar+= (stretch_bar_width + CHART_MARGIN_BETWEEN_BARS) * (column_number - chart_first_column_in_group);
//      int column_height= cha_heights.at(column_number);
      if (cha_column_values.at(column_number) < 0)
        bar_or_line_y+= abs(bar_or_line_column_height);

      QRect qr_of_little_bar= QRect(x_of_bar,
                           CHART_MARGIN_TOP + bar_or_line_y,
                           CHART_LITTLE_BAR_WIDTH,
                           CHART_LITTLE_BAR_HEIGHT);
      pixmap_painter.drawRect(qr_of_little_bar);
      if (column_number != chart_first_column_in_group)
      {
        QLineF line;
        line= QLineF(x_of_bar + CHART_LITTLE_BAR_WIDTH/2,
                     CHART_MARGIN_TOP + bar_or_line_y,
                     prev_x_of_bar + CHART_LITTLE_BAR_WIDTH/2,
                     CHART_MARGIN_TOP + prev_y);
        pixmap_painter.drawLine(line);
      }
      prev_x_of_bar= x_of_bar;
      prev_y= bar_or_line_y;
    }
    if (chart_type == TOKEN_KEYWORD_PIE)
    {
/* A full circle is 16 * 360 = 5760 */
      /* Todo: dunno what to do with negatives */
//      int x= cha_x;
      /* initially start_angle_of_pie == 0 * 180 */
//      for (int column_number= 0; column_number < cha_numeric_column_count; ++column_number)
      {
        if (cha_heights.at(column_number) > 0)
        {
          double fraction_of_total_height= cha_heights.at(column_number) / total_height_of_pie;
          double adj= 5760 * fraction_of_total_height;
//          QString column_name= chart_column_names.at(column_number);
          QRect qr_of_pie= QRect(CHART_MARGIN_LEFT,
                               CHART_MARGIN_TOP,
                               height_of_pie_rounded, /* = chart_bar_line_pie_height if total height = maximum */
                               height_of_pie_rounded);
//          cha_draw_text_prepare(painter, column_number, column_name, i, TEXTEDITFRAME_CELL_TYPE_DETAIL,
//                                column_number, cha_numeric_column_count);
          int span_angle= round(adj);
          pixmap_painter.drawPie(qr_of_pie, start_angle_of_pie, span_angle);
          start_angle_of_pie+= span_angle;
        }
      }
    }
    /* Now that we have ticks, I guess we don't need a zero line. */
    /* In any case, a zero line or big-tick line would need to be in a different palette color. */
    //if ((chart_type == TOKEN_KEYWORD_BAR) || (chart_type == TOKEN_KEYWORD_LINE))
    // {
    //   /* zero line. color=last in palette e.g. navy, size=fixed, length=max, position=where zero would be */
    //   QLineF zero_line= QLineF(0, CHART_MARGIN_TOP + chart_height_of_zero_line,
    //                            chart_pixmap_width, CHART_MARGIN_TOP + chart_height_of_zero_line);
    //   QPen zero_line_pen= cha_default_container_pen;
    //   char zero_line_color[8];
    //   strcpy(zero_line_color, cha_color_palette[cha_color_palette_count - 1]);
    //   zero_line_pen.setColor(zero_line_color);
    //   zero_line_pen.setWidth(CHART_ZERO_LINE_WIDTH);
    //   pixmap_painter.setPen(zero_line_pen);
    //   pixmap_painter.drawLine(zero_line);
    // }

    /* caption i.e. text underneath chart at bottom of pixmap */ /* SHOULD BE COLUMN VALUES! */
    QString cv_as_s= cha_column_values_as_strings.at(column_number);
    QFontMetrics fm= QFontMetrics(chart_default_font);
    int caption_width= fm.boundingRect(cv_as_s).width();
    int caption_height= fm.boundingRect("W").height(); /* should be same as what we get in set_chart_pixmap_height() */
    pixmap_painter.setPen(chart_new_text_pen);
    int caption_y= chart_pixmap_height - caption_height - CHART_MARGIN_BOTTOM;
    QRect qr_of_caption= QRect(0 + CHART_MARGIN_LEFT + caption_x,
                         caption_y,
                         caption_width,
                         caption_height);
    pixmap_painter.drawText(qr_of_caption, Qt::AlignLeft, cv_as_s);
    caption_x+= caption_width;
#endif

  if ((QString::compare(right, "NULL", Qt::CaseInsensitive) != 0) && (chart_right_rect.width() != 0))
  {
    if (QString::compare(right, "LEGEND", Qt::CaseInsensitive) != 0)
    {
      QPen right_pen= cha_default_container_pen;
      right_pen.setColor(cha_color_palette[0]);
      pixmap_painter.setPen(right_pen);
      QFontMetrics fm= QFontMetrics(chart_default_font);
      for (int i= 0; i < right.size(); ++i)
      {
        QRect qr_of_caption= QRect(chart_right_rect.x(),
                         chart_right_rect.y() + (fm.boundingRect("W").height() * i),
                         chart_right_rect.width(),
                         fm.boundingRect("W").height());
        pixmap_painter.drawText(qr_of_caption, right.mid(i, 1));
      }
    }
    else /* print the legend */
    {
      /* Maybe this has to be drawn early too? */
      /* todo: change to smaller font maybe. change pen colour to default. set a rectangle! should it be 270 not 90? */
      /* todo: allow wrap? */
      if (series.size() > 0)
      {
        QVector<int> series_columns= series.at(0);
        for (int column_number= 0; column_number < series_columns.size(); ++column_number)
        {
          QPen legend_pen= cha_default_container_pen;
          legend_pen.setColor(cha_color_palette[column_number]);
          pixmap_painter.setPen(legend_pen);
          QString cv_as_s= QChar(0x25cf); /* Unicode Black Circle */
          QString s2= QString::number(column_number + 1); /* will remain = number if not subgroup by left(column_name, x) */
//          if (chart_sub_group_by == TOKEN_KEYWORD_COLUMN_NAME)
          {
            for (int i= 0; i < chart_sub_group_list_sub_group_numbers.count(); ++i)
            {
              if (column_number == chart_sub_group_list_sub_group_numbers.at(i))
              {
                int j= chart_sub_group_list_column_numbers.at(i);
                s2= chart_column_names.at(j).left(2);
                break;
              }
            }
          }
          cv_as_s= cv_as_s + s2;
          //      pixmap_painter.setFont(chart_default_font); /* Of course we'll change to smaller font if we must */
          QFontMetrics fm= QFontMetrics(chart_default_font);
//          int caption_width= fm.boundingRect(cv_as_s).width();
          /* For some reason I can't do this by drawing within the rect */
//          int caption_height= fm.boundingRect("W").height();
//          int caption_x= 0;
//          int caption_y= 0;
          QRect qr_of_caption= QRect(chart_right_rect.x(),
                           chart_right_rect.y() + (fm.boundingRect("W").height() * column_number),
                           chart_right_rect.width(),
                           fm.boundingRect("W").height());
          pixmap_painter.drawText(qr_of_caption, cv_as_s);
        }
      }
    }
  }
/* todo: find out why I have to say + 10 ... maybe this comment is obsolete */
  if ((QString::compare(top, "NULL", Qt::CaseInsensitive) != 0) && (chart_top_rect.width() != 0))
  {
    QPen top_pen= cha_default_container_pen;
    top_pen.setColor(cha_color_palette[0]);
    pixmap_painter.setPen(top_pen);
    pixmap_painter.drawText(chart_top_rect, top);
  }
  if ((QString::compare(bottom, "NULL", Qt::CaseInsensitive) != 0) && (chart_bottom_rect.width() != 0))
  {
    QPen bottom_pen= cha_default_container_pen;
    bottom_pen.setColor(cha_color_palette[0]);
    pixmap_painter.setPen(bottom_pen);
    pixmap_painter.drawText(chart_bottom_rect, bottom);
  }
  if ((QString::compare(left, "NULL", Qt::CaseInsensitive) != 0) && (chart_left_rect.width() != 0))
  {
    /* I must draw left text before drawing bars or lines, dunno why */
    /* todo: change to smaller font maybe. change pen colour to default. set a rectangle! should it be 270 not 90? */
    /* todo: allow wrap? */
    QPen left_pen= cha_default_container_pen;
    left_pen.setColor(cha_color_palette[0]);
    pixmap_painter.setPen(left_pen);
    QString cv_as_s= left;
//      pixmap_painter.setFont(chart_default_font); /* Of course we'll change to smaller font if we must */
    QFontMetrics fm= QFontMetrics(chart_default_font);
//    int caption_width= fm.boundingRect(cv_as_s).width();
//    int caption_height= fm.boundingRect("W").height();
//    int caption_x= 0;
//    int caption_y= 0;
    /* Todo: alas passing QRect does not work as expected. Passing QPoint sort of worked but I don't understand coordinates. */
    QRect qr_of_left= QRect(chart_left_rect.x(),
                         chart_left_rect.y(),
                         chart_left_rect.width(),
                         chart_left_rect.height());
    pixmap_painter.save();
    pixmap_painter.translate(qr_of_left.center());
    pixmap_painter.rotate(270);
    pixmap_painter.translate(-qr_of_left.center());
    pixmap_painter.drawText(qr_of_left,  Qt::AlignVCenter | Qt::TextDontClip, cv_as_s);
    pixmap_painter.restore();
  }

  if ((chart_vertical_line_rect.width() > 0) || (chart_horizontal_line_rect.height() > 0))
  {
    QPen line_pen= cha_default_container_pen;
    line_pen.setColor(cha_color_palette[0]);
    line_pen.setWidth(CHART_VERTICAL_LINE_WIDTH);
    pixmap_painter.setPen(line_pen);

    QFontMetrics fm= QFontMetrics(chart_default_font);
    int max_value_width= fm.boundingRect(max_value_for_axis_display).width();
    int pixels_between_ticks= fm.boundingRect("W").width(); /* could be any arbitrary distance */
    if (chart_vertical_line_rect.width() > 0)
    {
      {
        QRect qr_of_max_value= QRect(
                    chart_vertical_line_rect.x(),
                    chart_vertical_line_rect.y(),
                    max_value_width,
                    fm.boundingRect(max_value_for_axis_display).height());
        pixmap_painter.drawText(qr_of_max_value, Qt::TextSingleLine | Qt::TextDontClip, max_value_for_axis_display);
      }

      pixmap_painter.drawLine(chart_vertical_line_rect.x() + max_value_width + CHART_TICK_LENGTH,
                              chart_vertical_line_rect.y(),
                              chart_vertical_line_rect.x() + max_value_width + CHART_TICK_LENGTH,
                              chart_vertical_line_rect.y() + chart_vertical_line_rect.height());
      int tick_y_of_min= chart_vertical_line_rect.y() + chart_vertical_line_rect.height();
      for (int tick_count= 0; ; ++tick_count)
      {
        int tick_x= chart_vertical_line_rect.x()+ max_value_width;
        int tick_y= tick_y_of_min - (tick_count * pixels_between_ticks);
        if (tick_y < chart_vertical_line_rect.y()) break;
        pixmap_painter.drawLine(tick_x, tick_y, tick_x + CHART_TICK_LENGTH, tick_y);
      }
    }
    if (chart_horizontal_line_rect.height() > 0)
    {
      {
        int max_value_height= fm.boundingRect(max_value_for_axis_display).height();
         QRect qr_of_max_value= QRect(
                chart_horizontal_line_rect.x() + chart_horizontal_line_rect.width() - max_value_width,
                chart_horizontal_line_rect.y() + CHART_TICK_LENGTH,
                max_value_width,
                max_value_height);
        pixmap_painter.drawText(qr_of_max_value, Qt::TextSingleLine | Qt::TextDontClip, max_value_for_axis_display);
      }

      pixmap_painter.drawLine(chart_horizontal_line_rect.x(),
                              chart_horizontal_line_rect.y(),
                              chart_horizontal_line_rect.x() + chart_horizontal_line_rect.width(),
                              chart_horizontal_line_rect.y());
      int tick_x_of_min= chart_horizontal_line_rect.x();
      for (int tick_count= 0; ; ++tick_count)
      {
        int tick_x= tick_x_of_min  + (tick_count * pixels_between_ticks);
        int tick_y= chart_horizontal_line_rect.y();
        if (tick_x > chart_horizontal_line_rect.x() + chart_horizontal_line_rect.width()) break;
        pixmap_painter.drawLine(tick_x, tick_y, tick_x, tick_y + CHART_TICK_LENGTH);
      }
    }
  }
//return_point:
//  int y= chart_max_column_heights - height;
//  pixmap_painter.drawRect(QRect(0, y, width, height));
  pixmap_painter.end();
  QByteArray ba;
  QBuffer buffer(&ba);
  buffer.open(QIODevice::WriteOnly);
  bool save_result= pixmap.save(&buffer, "PNG");
  unsigned int expected_output_size= (ba.size() * 4) / 3 + 64;
  if ((save_result == false)
   || (pixmap.isNull() == true)
   || (expected_output_size >= CHART_MAX_BYTE_SIZE - 1))
  {
    printf("Error in Chart::draw_group. pixmap could not be saved, or was null, or was too big.\n");
    strcpy(output, "");
    return 0;
  }
  strcpy(output, ba.toBase64()); /* i.e. buffer.data() */
  return ba.size();
}

/*
  Called from draw_group() to set chart_..._rect i.e. all rects in the pixmap.
  Todo: Call for hover i.e. when mouse is in the cell see what rect it's in
        (for this I'll need to know the relation between cell rect and pixmap rect)
        (for this I'll need to have Chart widget up, which maybe is a lot of trouble)
  These are the components of pixmap, which has whole chart (after header, not including cell border)
  +--------------------------------------------------+
  |    TOP                                           |
  |L |                                              L|
  |E |   CANVAS                                     E|
  |F |                                              G|
  |T |                                              E|
  |  |                                              N|
  |  |                                              D|
  |   _____________________________________________  |
  |   BOTTOM                                         |
  +--------------------------------------------------+

  But if pixmap size is small we might cancel everything except the canvas.
  Components are painted with pixmap draw functions in draw_group().
  chart canvas: this is a non-optional component, it haa the actual bar/line/pie chart.

  LEFT: For vertical-bar or line has "values axis", for horizontal-bar has "sample axis", for pie has nothing.
        Text, rotated 90 degrees.
  BOTTOM: For horizontal-bar or line has "values axis", for vertical-bar has "values axis", for pie has nothing.
          Text, rotated 90. ... OR, no, numbers from low to high
  LEGEND: If there are too many items:
            Unlike Qwt, we do not have a legend with a vertical scroll bar because in the end we copy to a pixmap,
            which would be difficult to scroll. Perhaps we could draw a scroll bar anyway and imitate its functionality
            by monitoring mouse movements and clicks on the pixmap.
            Perhaps we should have multiple legend columns.
            Perhaps we should shrink the font.
            Perhaps we should pop up the whole legend when mouse hovers over it.
  TOP: text
  LEFT: text
  LEFT LINE: a straight line between LEFT and canvas
  BOTTOM: text
  BOTTOM LINE: a straight line between canvas and BOTTOM
  Value axis: Becomes next to LEFT or BOTTOM in a bar or line.
  Sample axis: Becomes next to LEFT or BOTTOM in a bar or line.

  pixmap_rect = 0, 0, pixmap.width(), pixmap.height()
  left_rect   = 0, TOP.height(), LEFT.width(), pixmap.height() - (TOP.height + BOTTOM.height)
  bottom_rect = LEFT.width(), TOP.height + CANVAS.height, pixmap.width) - (LEFT.width() + LEGEND.width), BOTTOM.height
  legend_rect = LEFT.width() + CANVAS.width(), 0, LEGEND.width(), pixmap.height()
  top_rect = 0, 0, 0, 0

  The rects include margins and there is no spacing between rects that meet.
  There is no canvas margin?
  The whole thing is inside a cell, and the cell definition is affected by set ocelot_grid_... statements

  minimum_canvas_width = minimum_canvas_height = # of columns because everything should have at least 1 pixel, or N = pie hgith
    (if pixmap is already smaller than that, all rects except canvas_rect must go) (todo: try reducing font + line sizes)
  What goes in is affected by the spec, for example it might say LEFT=NULL.
  todo: we're referring elsewhere to bar_line_pie_height, change the name to canvas_height
  todo: check what happens if canvas height or width is still less than minimum_canvas_height_or_width
  todo: margins for each rect, we have #define CHART_MARGIN_... but I guess we don't use it
  todo: We are setting a fixed amount for vertical line size and horizontal line size, so that canvas height + width
        will always be the same. This means they're often blank. If we determined cha_heights() during draw_group() only,
        this would be fixed -- but then we'd have different parameters for different groups.
  todo: for legend, the "* 3" is an assumption that legend has 3 characters. it might be 2 if single digit, it might be more.
*/

void Chart::set_chart_rects(int pixmap_width, int pixmap_height, int numeric_column_count,
                            bool is_horizontal,
                            QString top, QString bottom, QString left, QString right, QString axis,
                            QString max_value)
{
  QFontMetrics fm= QFontMetrics(chart_default_font);

  int left_width= fm.boundingRect(left).height();
  if (QString::compare(left, "NULL", Qt::CaseInsensitive) == 0) left_width= 0;
  int top_height= fm.boundingRect(top).height();
  if (QString::compare(top, "NULL", Qt::CaseInsensitive) == 0) top_height= 0;
  int bottom_height= fm.boundingRect(bottom).height();
  if (QString::compare(bottom, "NULL", Qt::CaseInsensitive) == 0) bottom_height= 0;
  int right_width= fm.boundingRect("W").width();
  if (QString::compare(right, "LEGEND", Qt::CaseInsensitive) == 0) right_width= fm.boundingRect("W").width() * 3;
  else if (QString::compare(right, "NULL", Qt::CaseInsensitive) == 0) right_width= 0;
  int vertical_line_width= 0; /* stays 0 if pie or horizontal bar or axis=null */
  int horizontal_line_height= 0; /* stays 0 if pie or vertical bar or axis=null */
  if ((chart_type == TOKEN_KEYWORD_BAR) || (chart_type == TOKEN_KEYWORD_LINE))
  {
    if (QString::compare(axis, "NULL", Qt::CaseInsensitive) != 0)
    {
      if (is_horizontal)
      {
        horizontal_line_height= CHART_TICK_LENGTH + CHART_HORIZONTAL_LINE_HEIGHT + fm.boundingRect(max_value).height();
      }
      else
      {
        vertical_line_width= CHART_TICK_LENGTH + CHART_VERTICAL_LINE_WIDTH + fm.boundingRect(max_value).width();
      }
    }
  }
  int canvas_width= pixmap_width - (left_width + vertical_line_width + right_width);
  int canvas_height= pixmap_height - (bottom_height + horizontal_line_height + top_height);
  int minimum_canvas_width_or_height= numeric_column_count * 3; /* ?? or ocelot_grid_cell_border_size */
  if (canvas_height < minimum_canvas_width_or_height)
  {
    bottom_height= top_height= horizontal_line_height= 0;
    canvas_height= pixmap_height;
  }
  if (canvas_width < minimum_canvas_width_or_height)
  {
    left_width= right_width= vertical_line_width= 0;
    canvas_width= pixmap_width;
  }

  if (bottom_height == 0) chart_bottom_rect= QRect(0, 0, 0, 0);
  else chart_bottom_rect= QRect(left_width, top_height + horizontal_line_height + canvas_height, vertical_line_width + canvas_width, bottom_height);
  if (left_width == 0) chart_left_rect= QRect(0, 0, 0, 0);
  else chart_left_rect= QRect(0, top_height, left_width, canvas_height);
  if (vertical_line_width == 0) chart_vertical_line_rect= QRect(0, 0, 0, 0);
  else chart_vertical_line_rect= QRect(left_width, top_height, vertical_line_width, canvas_height);

  if (horizontal_line_height == 0) chart_horizontal_line_rect= QRect(0, 0, 0, 0);
  else chart_horizontal_line_rect= QRect(left_width, top_height + canvas_height, canvas_width, horizontal_line_height);

  if (right_width == 0) chart_right_rect= QRect(0, 0, 0, 0);
  else chart_right_rect= QRect(left_width + vertical_line_width + canvas_width, 0, right_width, pixmap_height);
  if (top_height == 0) chart_top_rect= QRect(0, 0, 0, 0);
  else chart_top_rect= QRect(left_width, 0, vertical_line_width + canvas_width, top_height);
  chart_canvas_rect= QRect(left_width + vertical_line_width, top_height, canvas_width, canvas_height);
}

/*
  We'll get chart_pixmap_height = chart_pixmap_width i.e. we have a square
  -- but soon we should add for the caption.
  ... Or, we'll get chart_pixmap_height = what's available ... that's commented out.
  TODO: THIS ASSUMES THERE IS A HEADING!
  This is the total height available in the widget, chart_bar_line_pie_height will be this minus what we need for caption.
  TODO: WHAT ABOUT HORIZONTAL SCROLL BAR?
  TODO: WHAT ABOUT MARGINS WITHIN HEADER?
  Elsewhere I think we say result grid has no margins, but use contentsRect instead of frameGeometry anyway.
  Todo: re horizontal scroll bar: If we're too wide, we want to say
    chart_bar_line_pie_height-= QApplication::style()->pixelMetric(QStyle::PM_ScrollBarExtent);
    but the only way to know we're too wide is to look at the width of all columns in the result set,
    and for pies the widths depend on the heights, so this might be hard.
  Should I be looking at height_n_total instead?
*/
void Chart::set_chart_pixmap_height()
{
//  int height_of_bars= height_of_bar * group_columns_count;
//  if (height_n_total > height_of_bars) chart_pixmap_height= height_n_total;
//  else chart_pixmap_height= height_of_bars;

  QRect cr= chart_rg->contentsRect();
  chart_pixmap_height= cr.height();

  /* todo: find out why (copy_of_ocelot_result_grid_column_names == 1) is always true */
  if (chart_rg->ocelot_result_grid_column_names_copy == 1) /* if heading exists */
  {
    QFontMetrics fm= QFontMetrics(chart_default_font);
    int height_of_header_text= fm.boundingRect("W").height();
    chart_pixmap_height-= height_of_header_text + chart_rg->setting_ocelot_grid_cell_border_size_as_int;
  }

  set_chart_rects(100, chart_pixmap_height, 1, false, "NULL", "NULL", "samples", "LEGEND", "All","0"); /* to get canvas height -- TODO: DO NOT CALL */

  //chart_pixmap_height-= chart_rg->setting_ocelot_grid_cell_border_size_as_int * 5; /* why 5? dunno */
  /* The following tediously-tested instructions work around a size problem but it would be better to know WHY. */
  int border_size= chart_rg->setting_ocelot_grid_cell_border_size_as_int;
  if (border_size == 0)   chart_pixmap_height-= 8;
  if (border_size == 1)   chart_pixmap_height-= 13;
  if (border_size == 2)   chart_pixmap_height-= 18;
  if (border_size == 3)   chart_pixmap_height-= 23;
  if (border_size == 4)   chart_pixmap_height-= 28;
  if (border_size == 5)   chart_pixmap_height-= 33;
  if (border_size == 6)   chart_pixmap_height-= 38;
  if (border_size == 7)   chart_pixmap_height-= 43;
  if (border_size == 8)   chart_pixmap_height-= 48;
  if (border_size == 9)   chart_pixmap_height-= 53;

//  if (chart_pixmap_height < 100) chart_pixmap_height= 100; /* WRONG! BUT TEMPORARILY ... */

  /* Following should actually be boundingRect of the words underneath the line */
  /* Todo: figure out why height() + width wasn't enough */
//  int bottom_height= fm.boundingRect("W").height() + cha_default_container_pen_width + CHART_MARGIN_TOP;
  /* If there are multiple columns then bottom_height is lower */
//  if (cha_numeric_column_count > 1) bottom_height+= fm.boundingRect("W").height() * (cha_numeric_column_count - 1);

//  int caption_height= fm.boundingRect("W").height();

  chart_bar_line_pie_height= chart_canvas_rect.height();

  //chart_bar_line_pie_height-= CHART_MARGIN_TOP + CHART_MARGIN_BOTTOM;

//  chart_bar_line_pie_height-= 10; /* why 10? dunno */
}

/*
  Call this for each group, and whenever result widget size changes e.g. due to detach.
  We want the chart to cover the result widget, and its accompanying vertical scroll bar.
  Warning: result widget parent is not mainwindow it is result_grid_tab_widget so rg->pos() is always 0.
  Todo: really width + height should consider scroll bars
  If we ask for too much, that should be okay, Qt will take over the screen for it
  But: with the new per-row calculating, I don't think we'll have any use for chart_pixmap_width or chart_pixmap_height.
  We have width_n_total = total of width_n passed to copy_html_cell() for each column in group
  We'll get width_of_bars = margins + min-bar-widths * # of bars i.e. # of columns in group
  We'll get chart_bar_line_pie_width = greater of (width_n_total, width_of_bars).
  For a pie, chart width should = chart height, approximately. Ellipses are nice but wouldn't be expeced.
*/
void Chart::set_chart_width()
{
  if (chart_type == TOKEN_KEYWORD_BAR)
  {
    int group_columns_count= (chart_last_column_in_group - chart_first_column_in_group) + 1;
    int width_of_bars= (chart_bar_width + 2) * (group_columns_count + 6);
    width_of_bars+= CHART_MARGIN_BETWEEN_BARS * (group_columns_count - 1);
    chart_pixmap_width= width_of_bars;
    if (width_n_total > chart_pixmap_width) chart_pixmap_width= width_n_total;
    if (chart_header_widths.at(chart_last_column_in_group) > chart_pixmap_width)
      chart_pixmap_width= chart_header_widths.at(chart_last_column_in_group);
    chart_bar_line_pie_width= chart_pixmap_width;
  }
  else if (chart_type == TOKEN_KEYWORD_LINE)
  {
    int group_columns_count= (chart_last_column_in_group - chart_first_column_in_group) + 1;
    int width_of_bars= chart_bar_width * group_columns_count;
    chart_bar_line_pie_width= width_of_bars;
    chart_pixmap_width= width_of_bars + (CHART_MARGIN_LEFT + CHART_MARGIN_RIGHT);
    if (width_n_total > chart_pixmap_width) chart_pixmap_width= width_n_total;
    if (chart_header_widths.at(chart_last_column_in_group) > chart_pixmap_width)
      chart_pixmap_width= chart_header_widths.at(chart_last_column_in_group);
    chart_bar_line_pie_width= chart_pixmap_width - (CHART_MARGIN_LEFT + CHART_MARGIN_RIGHT);
  }
  else /* TOKEN_KEYWORD_PIE */
  {
    chart_bar_line_pie_width= chart_bar_line_pie_height; /* so canvas is in a square rect */
    chart_pixmap_width= chart_bar_line_pie_width + CHART_MARGIN_LEFT + CHART_MARGIN_RIGHT;
  }
}

/*
  We'd like to know the number of bytes that will be added for all groups, during copy_html_cell().
  That is: overhead per row.
  CHART_MAX_BYTE_SIZE is an arbitrary number, I find that actual size is 2000 to 25000 with my small screen.
  Todo: properly, we should find out what pixmap .png size is for each group, knowing width+height+content.
*/
void Chart::set_byte_size()
{
  int groups_count= 0; /* number of groups, which decides number of charts, in the row */
  for (int i= 0; i < chart_column_names.size(); ++i)
  {
    if (chart_column_types.at(i) != OCELOT_DATA_TYPE_NUMBER) continue; /* not even a number */
    if ((i == 0) || (chart_column_types.at(i - 1) != OCELOT_DATA_TYPE_NUMBER)) ++groups_count;
  }
  chart_alloc_byte_size= groups_count * CHART_MAX_BYTE_SIZE;
}

#if (OCELOT_CHART_EVENTFILTER == 1)
/* Sometimes for diagnostics it's useful to know what events are happening to charts but ordinarily this is disabled. */
/* Ordinarily we'd try to track chart events as part of grid events */
/* Currently the only events we see with this are polish and polishrequest, not much use */
bool Chart::eventFilter(QObject *obj, QEvent *event)
{
  //return main_window->eventfilter_function(obj, event);
  if (obj == this) printf("****     EVENT FILTER %d ", event->type());
  if (event->type() == QEvent::Scroll) printf("****       SCROLL!\n");
  else if (event->type() == QEvent::DragMove) printf("****       DRAGMOVE!\n");
  else if (event->type() == QEvent::EnabledChange) printf("****       ENABLEDCHANGE!\n");
  else if (event->type() == QEvent::Enter) printf("****       ENTER!\n");
  else if (event->type() == QEvent::Leave) printf("****       LEAVE!\n");
  else if (event->type() == QEvent::MouseButtonPress) printf("****       MOUSEBUTTONPRESS!\n");
  else if (event->type() == QEvent::MouseMove) printf("****       MOUSEMOVE!\n");
  else if (event->type() == QEvent::FocusIn) printf("****       FOCUSIN!\n");
  else if (event->type() == QEvent::Paint) printf("****       PAINT!\n");
  else if (event->type() == QEvent::UpdateLater) printf("****       UPDATELATER!\n");
  else if (event->type() == QEvent::Timer) printf("****       TIMER!\n");
  else if (event->type() == QEvent::HideToParent) printf("****       HIDETOPARENT!\n");
  else if (event->type() == QEvent::LayoutRequest) printf("****       LAYOUTREQUEST!\n");
  else if (event->type() == QEvent::Polish) printf("****       POLISH\n");
  else if (event->type() == QEvent::ChildPolished) printf("****       CHILDPOLISHED!\n");
  else if (event->type() == QEvent::Resize) printf("****       RESIZE!\n");
  else if (event->type() == QEvent::ShowToParent) printf("****       SHOWTOPARENT!\n");
  else if (event->type() == QEvent::Move) printf("****       MOVE!\n");
  else if (event->type() == QEvent::FontChange) printf("****       FONTCHANGE!\n");
  else if (event->type() == QEvent::ChildAdded) printf("****       CHILDADDED!\n");
  else if (event->type() == QEvent::PolishRequest) printf("****       POLISHREQUEST!\n");
  else printf("****       (unknown meaning)!\n");
  //return false; /* we would only return true if we wanted to filter the event filter out */
  return QObject::eventFilter(obj, event);
}
#endif

#endif //if (OCELOT_CHART == 1)



#if (OCELOT_QWT_INCLUDE == 1)
/*
  QChart
  If OCELOT_QWT_INCLUDE == 1, we use QChart:: instead of Chart:: and we depend on the Qwt library.
  The use of Qwt was an experiment, it went okay but was unnecessary at this time so OCELOT_QWT_INCLUDE == 0 is default.
  Re main_group_numbers: each group of numeric columns, corresponding to a result-set column, has a number
  Re sub_group_numbers: within main_group, determined by GROUP BY
  Todo: Legend:
        the legend can overflow when too many sub-bars, either have a working scroll bar or reduce font/icon size
          ... there is a scroll bar but it isn't working
        the legend can overflow if names are too wide
  Todo: > 1 sample, breaking up a series with some sort of group-by

  Todo: compile only works with cmake, not Qt Creator. Maybe more changes in ocelotgui.pro are necessary?
  Todo: bars are wider than what I request
  Todo: color and width of the frame and ticks should depend on some setting, or the palette
        see https://www.qtcentre.org/threads/30696-Change-the-color-of-the-qwt-plot-axis-numbers-and-ticks
  Todo: For SELECT 1,2,3; the second bar is too wide, it should be blank
  Todo: still no special handling for NULL (maybe WHERE clause should check for it)
  Todo: WHERE clause
  Todo: Margin control
        watch for curveStyle?
  ... What if we knew what the GROUP BY was? e.g. SELECT x, COUNT(x) FROM t GROUP BY x;
  ... As for pie, I just need to know where it will fit, and draw on the canvas (?)
      See https://www.qtcentre.org/threads/52924-Direct-QwtPlot-painting
  Re NULLs:
    For bars we try to distinguish NULL from zero by changing the symbol. It could be
    a frame around chart_mainwindow->ocelot_grid_background_color, but we are trying
    Qt::Dense5Pattern which keeps the color but is spotty. Size = chart_null_value = max or min or 0.
    Todo: should we treat NULL in SELECT NULL; as numeric?
  My thinking about the command is:
    SET ocelot_grid_chart='literal';
    where 'literal' has any or all of these clauses:
    STACKED (affects bar only)
    HORIZONTAL (affects bar only)
    SUBGROUP BY LEFT(COLUMN_NAME, 1)
    SUBGROUP BY VALUE % 3 (can be any digit)
    WITH LEGEND
    any combination of the above
  Someday we'll also think about other subgroups and
    NULL
    |
    BAR|LINE|PIE
    TITLE=NULL|'literal',                                  default NULL ? or TOP?
    LEFT=NULL|'literal',                                   default NULL ? or Y_AXIS?
    BOTTOM=NULL|'literal',                                 default NULL
    LEGEND=NULL|GROUP_NUMBER|COLUMN_NAMES,                 default NULL
    LABELS=NULL                                            default NULL
    TICKS=NULL|MAJOR|MEDIUM|MINOR,                         default NULL
    VERTICAL=TRUE (or: ORIENTATION=VERTICAL|HORIZONTAL)    default VERTICAL (only affects BAR)
    STACKED_OR_GROUPED=STACKED                             default NULL? aka BESIDE
    PALETTE=DEFAULT                                        or COLOR_SCHEME?
    GROUP BY PREFIX | NAME(n) | TYPE | COUNT(n) | REGEXP(expression) | NULL (but we always break for non-numeric)
    WHEN GROUP_NUMBER condition-operator number            default > 0
    WHERE COLUMN_NAME | COLUMN_NUMBER | COLUMN_TYPE | ROW_NUMBER | VALUE (these options exist already)
    ... we assume COLUMN_TYPE is any numeric, unless overridden in WHERE clause
    ... other settings also will affect charts, where possible
    ... in parentheses?
    ... repeatable? or separate statements?
    ... new menu item
    ... maybe line_width rather than ocelot_grid_cell_border_size
    Or SET ocelot_grid_cell = pie chart ... where ...;
       SET ocelot_grid_chart = line, ocelot_grid_cell_border_size=5 ... where ...;
       SET ocelot_grid_chart = pie (lengend=null, title='x')
    So far we've got:
      SET ocelot_grid_chart = 'bar' | 'bar horizontal' | 'bar stacked' | 'line' | "pie' ... [WHERE ignored];
*/
/*
  Some things are universal e.g. background colour and margin.
  Others depend on values that we're populating.
*/

#define BAR_CHART_MARGIN 3
#define BAR_CHART_ITEM_SPACING 20 /* space between bars, I think */

/*
  samples_count = derived from number of numeric columns
*/

/* This is a partial copy of Chart::chart_row_setup() phase 1 */
/* Todo: Check, do we ever call it? yes */
void QChart::chart_row_setup(unsigned int tmp_result_row_number)
{
  //chart_max_column_heights= 0;
  chart_max_column_values= 0;  /* because base is always 0 even if all negative|positive */
  chart_min_column_values= 0;
  char *row_pointer;
  int column_length;

  long unsigned int r= tmp_result_row_number;
  {
    row_pointer= cha_result_set_copy_rows[r];
//    chart_column_types.clear();
    cha_column_values.clear();
//    cha_column_values_as_strings.clear();
    chart_column_flags.clear();
    for (unsigned int i= 0; i < cha_result_column_count; ++i)
    {
      memcpy(&column_length, row_pointer, sizeof(unsigned int));
      char flag= *(row_pointer + sizeof(unsigned int));
      chart_column_flags.append(flag);
      row_pointer+= sizeof(unsigned int) + sizeof(char);
      QByteArray m(row_pointer, column_length);

      QString column_value_as_string= QString(m);

      double column_value= column_value_as_string.toDouble();
      int chart_column_type= chart_column_types.at(i);
      if (chart_column_type == OCELOT_DATA_TYPE_NUMBER)
      {
        if (column_value > chart_max_column_values) chart_max_column_values= column_value;
        if (column_value < chart_min_column_values) chart_min_column_values= column_value;
      }
      else column_value= 0;
      cha_column_values.append(column_value);
//      cha_column_values_as_strings.append(column_value_as_string);
      row_pointer+= column_length;
    }
  }
}

void QChart::fill()
{
  int main_group_number= 0; /* FAKE */
  int sub_group_number= 0;
  int samples_count= 0;

  make_sub_group_list();

  /* Todo: this must be wrong now, we go by group not by column name (unless 1 column per group?) */

  /*
    What will be in the legend.
    Todo: Check whether we really want a legend.
    Todo: This list should be the same for bar, line, and pie.
    Todo: It's not necessarily a group number. For example it could be chart_column_names.at(i) if group size = all.
  */
  QList<QwtText> legend_titles;
  for (int sub_group_number= 0; sub_group_number < chart_sub_group_count; ++sub_group_number)
  {
    QString s= QString::number(sub_group_number); /* will remain = number if not subgroup by left(column_name, x) */
    if (chart_sub_group_by == TOKEN_KEYWORD_COLUMN_NAME)
    {
      for (int i= 0; i < chart_sub_group_list_sub_group_numbers.count(); ++i)
      {
        if (sub_group_number == chart_sub_group_list_sub_group_numbers.at(i))
        {
          int j= chart_sub_group_list_column_numbers.at(i);
          s= chart_column_names.at(j).left(2);
          break;
        }
      }
    }
    set_text_item("LEGEND", s);
    legend_titles+= chart_legend;
  }

  if (chart_type == TOKEN_KEYWORD_LINE)
  {
    /* We have QwtPlotCurve *chart_chart_curvew[100]; */
    int sub_group_count= chart_sub_group_count;
    double xlist[100]; /* todo: should be dynamic allocations or different method */
    double ylist[100];
    for (int sub_group_number= 0; sub_group_number < sub_group_count; ++sub_group_number)
    {
      int items_in_sub_group= 0;
      for (int i= 0; i < chart_sub_group_list_sub_group_numbers.size(); ++i)
      {
        if (sub_group_number == chart_sub_group_list_sub_group_numbers.at(i))
        {
          xlist[items_in_sub_group]= items_in_sub_group;
          int j= chart_sub_group_list_column_numbers.at(i);
          ylist[items_in_sub_group]= cha_column_values[j];
          ++items_in_sub_group;
        }
      }
//      QString s= legend_titles.at(sub_group_number);
//      QString s= QString::number(sub_group_number);
      chart_curves[sub_group_number]= new QwtPlotCurve(legend_titles.at(sub_group_number));
      chart_curves[sub_group_number]->setLegendIconSize(chart_legend_icon_size); /* maybe only needed once? */
      QColor this_color= get_color_from_palette(sub_group_number);
      chart_curves[sub_group_number]->setPen(this_color, cha_default_container_pen_width);
      chart_curves[sub_group_number]->setSamples(xlist, ylist, items_in_sub_group);
      chart_curves[sub_group_number]->attach(this);
    }
    /* we'll delete chart_curves[] at end of draw_group() */
  }
  if (chart_type == TOKEN_KEYWORD_BAR)
  {
    QwtColumnSymbol* symbols[100]; /* todo: dynamic allocation */
    for (int sub_group_number= 0; sub_group_number < chart_sub_group_list_sub_group_numbers.size(); ++sub_group_number)
    {
      symbols[sub_group_number]= new QwtColumnSymbol(QwtColumnSymbol::Box);
      symbols[sub_group_number]->setLineWidth(chart_bar_width);
      symbols[sub_group_number]->setFrameStyle(QwtColumnSymbol::NoFrame); /* maybe should be plain frame? */
      QBrush brush;
      brush.setColor(cha_color_palette[sub_group_number % cha_color_palette_count]);
      QPalette palette;
      brush.setStyle(Qt::SolidPattern);
      palette.setBrush(QPalette::Window, brush);
      symbols[sub_group_number]->setPalette(palette);
    }
    QList<bool> sub_group_list_flags;
    for (int i= 0; i < chart_sub_group_list_sub_group_numbers.count(); ++i) sub_group_list_flags.append(false);
    chart_bar_chart->setBarTitles(legend_titles);
    QVector< QVector<double> > series;
    for (int k= 0; k < 100; ++k) /* silly test based on assumption we never have > 100 items, surely unnecessary */
    {
      QVector<double> values;
      int outer_group_match_count= 0;
      for (int sub_group_number= 0; sub_group_number < chart_sub_group_count; ++sub_group_number)
      {
        int sub_group_match_count= 0;
        for (int i= 0; i < chart_sub_group_list_sub_group_numbers.size(); ++i)
        {
          if (sub_group_list_flags.at(i) == true) continue;
          if (chart_sub_group_list_sub_group_numbers.at(i) == sub_group_number)
          {

            chart_bar_chart->setSymbol(sub_group_number, symbols[sub_group_number]);
            int j= chart_sub_group_list_column_numbers.at(i);
            if ((chart_column_flags.at(j) & FIELD_VALUE_FLAG_IS_NULL) == 0)
            {
              values+= cha_column_values[j];
            }
            else
            {
              char null_flag= 0;
              values+= null_value(sub_group_number, TOKEN_KEYWORD_BAR, &null_flag);
            }
            sub_group_list_flags.replace(i, true);
            ++sub_group_match_count;
            ++outer_group_match_count;
            break;
          }
        }
        if (sub_group_match_count == 0) values+= 0;
      }
      if (outer_group_match_count == 0) break;
      series+= values;
    }
    chart_bar_chart->setSamples(series);
    /* TODO: NOW YOU CAN DELETE EVERYTHING IN SYMBOLS LIST */
  }
  if (chart_type == TOKEN_KEYWORD_PIE)
  {
    /*
      pie chart -- qwt does not supply, so we produce a QPixmap and add it, it's raster so fit won't be perfect
      Initially we show() so that canvas size won't be tiny, perhaps we should depend on a resize event instead
    */

    /* Actually we won't draw any curves, this is just to ensure legend is drawn, almost certainly there's a better way */
    /* We have QwtPlotCurve *chart_curves[100]; */
//    double xlist[100]; /* todo: should be dynamic allocations or different method */
//    double ylist[100];
//    xlist[0]= 0;
//    ylist[0]= 0;
//    xlist[1]= 0;
//    ylist[1]= 0;

    for (int sub_group_number= 0; sub_group_number < chart_sub_group_count; ++sub_group_number)
    {
      chart_curves[sub_group_number]= new QwtPlotCurve(legend_titles.at(sub_group_number));
      chart_curves[sub_group_number]->setLegendIconSize(chart_legend_icon_size); /* maybe only needed once? */
      QColor this_color= get_color_from_palette(sub_group_number);
      chart_curves[sub_group_number]->setPen(this_color, cha_default_container_pen_width);
      //chart_curves[0]->setLegendAttribute(QwtPlotCurve::LegendShowLine);
      chart_curves[sub_group_number]->attach(this);
    }

    /* Following might not all be necessary, and/or might be better done for all chart types */
    plotLayout()->setCanvasMargin(0);
//    replot(); /* todo: eliminate? we call replot() soon anyway */
    /* KEEP: removes the axes but leaves the "values" and "()" text */
    setAxisScaleDiv(QwtPlot::xBottom, QwtScaleDiv(0, 0.9)); /* removing this won't fix the width problem */
    setAxisScaleDiv(QwtPlot::yLeft, QwtScaleDiv(0, 0.9)); /* removing this won't fix the width problem */
    //setContentsMargins(0, 0, 0, 0); /* this does nothing. if you figure it out, base on some ocelot_grid_... setting */
    /* Todo: consider using canvas()->contentsRect().width()|height() instead */
    /* Anyway, it's still too small */
    chart_canvas_width= canvas()->width(); /* so drawcanvas sees it */
    chart_canvas_height= canvas()->height();
    //width= width * 2; /* TEST! */ /* Something to do with scale, I don't understand how to adjust */
    //height= height * 2; /* TEST! */
  }

  set_orientation();
  set_mode();
//  set_orientation();
//  fill();

  replot();

}

/*
  null_value = max in values of a subgroup. used for NULL. maybe could be max in group? maybe could be max in row?
  possibly values should be different for bar, line, pie
  a "past end of short series" is not handled here, we treat empty subgroups as nothing rather than as NULL
*/
double QChart::null_value(int series, int chart_type, char *null_flag)
{
  double n= 0;
  double max_value= 0;
  double min_value= 0;
  bool is_value_seen= false;
  *null_flag= 0; /* stays 0 if no nulls in series */
  for (int i= 0; i < chart_sub_group_list_sub_group_numbers.size(); ++i)
  {
    if (series != chart_sub_group_list_sub_group_numbers.at(i)) continue;
    int j= chart_sub_group_list_column_numbers.at(i);
    double v= cha_column_values[j];
    if ((chart_column_flags[j] & FIELD_VALUE_FLAG_IS_NULL) != 0)
    {
      v= 0; /* probably it's 0 anyway */
      *null_flag= 1;
    }
    if (is_value_seen == false) { is_value_seen= true; max_value= min_value= v; }
    else if (v > max_value) max_value= v;
    else if (v < min_value) min_value= v;
  }
  if (max_value > 0) n= max_value;
  else if (chart_type != TOKEN_KEYWORD_PIE) n= min_value;
  return n;
}

/*
  Currently the subgroup options are:
    default (effectively subgrouped by column_number % 1)
    value % 3
    and coming soon: left(...)
  Return number of different sub_groups.
  Todo: Call when you get a new column to show. Currently we're calling separately for line | pie.
  Todo: There's no difference in a value calculation between 0 and NULL.
  Todo: But how does % work if we can't convert the value to an integer?
*/
void QChart::make_sub_group_list()
{
  int modulo= 1;
  int left= 1;
  chart_sub_group_list_sub_group_numbers.clear();
  chart_sub_group_list_column_numbers.clear();

  chart_sub_group_by= 0; /* default is no subgroup, or if LINE default is left(column_name,0) */
  int i_of_subgroup= offset_of_keyword("SUBGROUP");

  if ((i_of_subgroup < 0) && (chart_type == TOKEN_KEYWORD_LINE))
  {
    left= 0;
    chart_sub_group_by= TOKEN_KEYWORD_COLUMN_NAME;
  }

  if ((i_of_subgroup >= 0) && (offset_of_keyword("BY") == i_of_subgroup + 1))
  {
    if ((offset_of_keyword("VALUE") == i_of_subgroup + 2)
     && (offset_of_keyword("%") == i_of_subgroup + 3))
    {
      QString s= chart_spec.mid(chart_token_offsets[i_of_subgroup + 4], chart_token_lengths[i_of_subgroup + 4]);
      modulo= s.toInt();
      if (modulo < 1) modulo= 1; /* I'm only worried about overflow so modulo == 0 might have been okay */
      if (modulo != 1) chart_sub_group_by= TOKEN_KEYWORD_VALUE;
    }
    if ((offset_of_keyword("LEFT") == i_of_subgroup + 2)
      && (offset_of_keyword("(") == i_of_subgroup + 3)
      && (offset_of_keyword("COLUMN_NAME") == i_of_subgroup + 4)
      && (offset_of_keyword(",") == i_of_subgroup + 5))
    {
      QString s= chart_spec.mid(chart_token_offsets[i_of_subgroup + 6], chart_token_lengths[i_of_subgroup + 6]);
      left= s.toInt();
      chart_sub_group_by= TOKEN_KEYWORD_COLUMN_NAME;
    }
  }

  int sub_group_number;

  QList<int> sub_group_list_values;
  QList<QString> sub_group_list_column_names;
  /* The value % x method, with some workarounds in case there are fewer than x subgroups */
  for (int i= chart_first_column_in_group; i <= chart_last_column_in_group; ++i)
  {
    int sub_group_value= 1;
    QString sub_group_column_name= "";
    if (chart_sub_group_by == TOKEN_KEYWORD_VALUE)
    {
      double v= cha_column_values.at(i);
      int v_as_int= (int) v; /* hmm, rounding would be better, eh? */ /* what if it's outside integer range? */
      v_as_int= abs(v_as_int); /* otherwise negative values cause unexpected problemss */
      //sub_group_number= v_as_int % 3;
      sub_group_value= v_as_int % modulo;
    }
    if (chart_sub_group_by == TOKEN_KEYWORD_COLUMN_NAME)
    {
      QString s= chart_column_names.at(i);
      sub_group_column_name= s.left(left);
    }
    sub_group_number= sub_group_list_values.count();
    int max_sub_group_number= -1;
    int j= 0;
    for (j= 0; j < sub_group_list_values.count(); ++j)
    {
      if (chart_sub_group_by == TOKEN_KEYWORD_VALUE)
      {
        if (sub_group_value == sub_group_list_values.at(j))
        {
          sub_group_number= chart_sub_group_list_sub_group_numbers.at(j);
          break;
        }
      }
      if (chart_sub_group_by == TOKEN_KEYWORD_COLUMN_NAME)
      {
        if (sub_group_column_name == sub_group_list_column_names.at(j))
        {
          sub_group_number= chart_sub_group_list_sub_group_numbers.at(j);
          break;
        }
      }
      if (max_sub_group_number < chart_sub_group_list_sub_group_numbers.at(j)) max_sub_group_number= chart_sub_group_list_sub_group_numbers.at(j);
    }
    if (j == sub_group_list_values.count()) sub_group_number= max_sub_group_number + 1;
    chart_sub_group_list_sub_group_numbers.append(sub_group_number);
    chart_sub_group_list_column_numbers.append(i);
    sub_group_list_values.append(sub_group_value);
    sub_group_list_column_names.append(sub_group_column_name);
  }
  int sub_group_count= 0;
  if (chart_sub_group_list_sub_group_numbers.size() > 0)
  {
    int max_sub_group_number= 0;
    for (int i= 0; i < chart_sub_group_list_sub_group_numbers.count(); ++i)
    {
      if (chart_sub_group_list_sub_group_numbers.at(i) > max_sub_group_number) max_sub_group_number= chart_sub_group_list_sub_group_numbers.at(i);
    }
    sub_group_count= max_sub_group_number + 1;
  }
  chart_sub_group_count= sub_group_count;
}

void QChart::set_mode()
{
  if (chart_type != TOKEN_KEYWORD_BAR) return;
  if (offset_of_keyword("STACKED") >= 0)
    chart_bar_chart->setStyle(QwtPlotMultiBarChart::Stacked);
  else /* grouped is default */
    chart_bar_chart->setStyle(QwtPlotMultiBarChart::Grouped);
}

void QChart::set_orientation()
{
  if (chart_type != TOKEN_KEYWORD_BAR) return;
  int axis1, axis2;

  if (offset_of_keyword("VERTICAL") >= 0)
  {
    axis1= QwtPlot::xBottom;
    axis2= QwtPlot::yLeft;
    chart_bar_chart->setOrientation(Qt::Vertical);
  }
  else /* horizontal is default */
  {
    axis1= QwtPlot::yLeft;
    axis2= QwtPlot::xBottom;
    chart_bar_chart->setOrientation(Qt::Horizontal);
  }

  /* Kludge. bottom text is clipped when there are few bars. I wasted lots of time trying to figure it out, and failed. */
//  if ((chart_sub_group_list_sub_group_numbers.count() < 4) && (offset_of_keyword("VERTICAL") > 0))
//    setAxisTitle(QwtPlot::xBottom, "-");
//  else
    setAxisTitle(QwtPlot::xBottom, chart_bottom);

  /*void QwtPlot::setAxisScale(QwtAxisId axisId, double min, double max, double stepSize = 0) */
  /* !! MORE TESTING !! */
  if (chart_bar_chart->dataSize() > 1)
    setAxisScale(axis1, 0, chart_bar_chart->dataSize() - 1, 1.0);
  setAxisAutoScale(axis2);
  if (chart_bar_chart->dataSize() <= 1)
  {
    QwtScaleDraw *scaleDraw1= axisScaleDraw(axis1);
    scaleDraw1->enableComponent(QwtScaleDraw::Backbone, false);
    scaleDraw1->enableComponent(QwtScaleDraw::Ticks, false);
    scaleDraw1->enableComponent(QwtScaleDraw::Labels, false);
  }
  if (chart_bar_chart->dataSize() > 1)
  {
    QwtScaleDraw *scaleDraw1= axisScaleDraw(axis1);
    scaleDraw1->enableComponent(QwtScaleDraw::Backbone, false);
    if (is_ticks == true) scaleDraw1->enableComponent(QwtScaleDraw::Ticks, false);
  }
  QwtScaleDraw *scaleDraw2 = axisScaleDraw(axis2);
  scaleDraw2->enableComponent(QwtScaleDraw::Backbone, true);
  if (is_ticks == true) scaleDraw2->enableComponent(QwtScaleDraw::Ticks, true);
  if (chart_bar_chart->dataSize() > 1)
    plotLayout()->setAlignCanvasToScale(axis1, true);

  plotLayout()->setAlignCanvasToScale(axis2, false);
  plotLayout()->setCanvasMargin(0);
  updateCanvasMargins();

  /* TEST!! Various attempts to fix width */
  //scaleDraw2->enableComponent(QwtScaleDraw::Backbone, false); /* Flounder, does nothing */
  //scaleDraw2->enableComponent(QwtScaleDraw::Ticks, false); /* Flounder, does nothing */
  //scaleDraw2->enableComponent(QwtScaleDraw::Labels, false); /* Flounder, does nothing */

  //chart_bar_chart->setLayoutHint(0.75); /* Flounder, does nothing */
  //canvas()->setLayoutHint(0.75); /* Flounder, not legal */

  replot();
}

/* Copied from Chart:... */
/* Todo: This is a copy of set_color_palette() in class erd. Duplicate code should be merged. */
void QChart::set_color_palette()
{
  const char *palette[]= {
    "#000000", /* black */
    "#FFFFFF", /* white */
    "#FF0000", /* red */
    "#00FF00", /* lime */
    "#0000FF", /* blue */
    "#FFFF00", /* yellow */
    "#00FFFF", /* cyan | aqua */
    "#FF00FF", /* magenta | fuchsia */
    "#C0C0C0", /* silver */
    "#808080", /* gray */
    "#800000", /* maroon */
    "#808000", /* olive */
    "#008000", /* green */
    "#800080", /* purple */
    "#008080", /* teal */
    "#000080", /* navy */ };
  QColor bcolor, ccolor;
  char color_utf8[80];
  strcpy(color_utf8, chart_mainwindow->ocelot_grid_background_color.toUtf8());
  bcolor= QColor(color_utf8);
  cha_color_palette_count= 0;
  for (int i= 0; i < 16; ++i)
  {
    ccolor= QColor(palette[i]);
    if ((ccolor.red() >= bcolor.red() - 64) && (ccolor.red() <= bcolor.red() + 64))
    {
      if ((ccolor.blue() >= bcolor.blue() - 64) && (ccolor.blue() <= bcolor.blue() + 64))
      {
        if ((ccolor.green() >= bcolor.green() - 64) && (ccolor.green() <= bcolor.green() + 64))
        {
          continue; /* too close */
        }
      }
    }
    strcpy(cha_color_palette[cha_color_palette_count++], palette[i]);
  }
}

QColor QChart::get_color_from_palette(int sub_group_number)
{
  char new_color[8];
  strcpy(new_color, cha_color_palette[sub_group_number % cha_color_palette_count]);
  return QColor(new_color);
}

/* Copied from Chart:... */
/*
  Return 0 for first column in group,
  Return 1 for second column in group etc.
  Return -1 for "not a chartable column at all"
  We draw all columns in group when we see the last, so it's necessary to set both first and last.
*/
int QChart::column_in_group(int result_column_no)
{
  QString spec= chart_column_specs.at(result_column_no);
  /* Compare to this test: if ((result_grid->result_field_flags[result_column_no] & NUM_FLAG) != 0) */
  if (spec == "") return -1; /* not even a number, or doesn't match a conditional */
  for (int i= result_column_no;; --i)
  {
    if ((i == 0) || (chart_column_specs.at(i - 1) != spec))
    {
      chart_first_column_in_group= i;
      break;
    }
  }
  chart_last_column_in_group= result_column_no;
  for (int i= result_column_no + 1; ; ++i)
  {
    if (i >= chart_column_specs.size())
    {
      chart_last_column_in_group= i - 1;
      break;
    }
    QString chart_column_spec= chart_column_specs.at(i);
    if (chart_column_spec != spec)
    {
      chart_last_column_in_group= i - 1;
      break;
    }
  }
  return result_column_no - chart_first_column_in_group; /* so return will be >= 0 for a member of a group */
}

/*
  Pass sub_group_number i.e. series # + sample # e.g. first set of bars is 0.
  Return column # so we can see value and flag. And maybe someday column name or type.
*/
int QChart::column_number_from_sample_and_series(int sample_number, int sub_group_number)
{
  int j= 0;
  for (int i= 0; i < chart_sub_group_list_sub_group_numbers.size(); ++i)
  {
    if (chart_sub_group_list_sub_group_numbers.at(i) == sub_group_number)
    {
      if (j == sample_number)
      {
        return chart_sub_group_list_column_numbers.at(i);
      }
      ++j;
    }
  }
  return 0;
}


/*
  Pass: number
  Return: bar|line|pie pixmap which can be displayed in result grid
  A group is a series of numbers preceded by before-start or non-number, followed by after-end or non-number.
  Todo: Inefficiency: This ends up in base64_tmp. We could dump directly to tmp_pointer.
  Todo: Inefficiency: Surely the size can be figured out in advance so we could memcpy not strcpy.
  Re bar width: If there's no subgrouping or stacking then setLayoutHint(0.9) gets rid of too-wide margins.
*/
int QChart::draw_group(
        long unsigned int tmp_result_row_number,
        int result_column_no, /* this might happen to = chart_last_column_in_group but we don't use it now */
        int width_i,
        char *output)
{
  (void)result_column_no;
  (void)width_i;

  /* The list of tokens in the literal of a SET OCELOT_GRID_CHART= statement */
  {
    chart_spec= chart_column_specs.at(chart_first_column_in_group);
    chart_mainwindow->tokenize(chart_spec.data(),
           chart_spec.size(),
           &chart_token_lengths[0], &chart_token_offsets[0], CHART_MAX_TOKENS - 1,
          (QChar*)"33333", 2, "", 1);
  }

  if (offset_of_keyword("BAR") >= 0) {chart_type= TOKEN_KEYWORD_BAR; }
  else if (offset_of_keyword("LINE") >= 0) {chart_type= TOKEN_KEYWORD_LINE; }
  else if (offset_of_keyword("PIE") >= 0) {chart_type= TOKEN_KEYWORD_PIE; }
  else chart_type= TOKEN_KEYWORD_BAR; /* though actually it's an error if bar|line|pie not in literal */

  /* Following is temporary, ordinarily defaults will be null and users must override */
  set_text_item("TITLE", "title"); /* but we never see this anyway */

  if (chart_type == TOKEN_KEYWORD_LINE) { set_text_item("LEFT", "samples"); set_text_item("BOTTOM", "values"); }

  if (chart_type == TOKEN_KEYWORD_PIE) { chart_left_is_null= chart_bottom_is_null= true; }
  if (chart_type == TOKEN_KEYWORD_BAR)
  {
    /* Following might be overridden by a kludge in set_orientation() */
    if (offset_of_keyword("VERTICAL") >= 0) { set_text_item("LEFT", "values"); set_text_item("BOTTOM", ""); }
    else { set_text_item("LEFT", ""); set_text_item("BOTTOM", "values"); }
    chart_bar_chart= new QMultiBarChart(this); /* I'm not sure what saying "Top" does */
    if ((offset_of_keyword("SUBGROUP") < 0) && (offset_of_keyword("STACKED") < 0))
    {
      chart_bar_chart->setLayoutPolicy(QwtPlotMultiBarChart::ScaleSampleToCanvas);
      chart_bar_chart->setLayoutHint(1.0);
    }
    chart_bar_chart->setSpacing(BAR_CHART_ITEM_SPACING);
    chart_bar_chart->setMargin(BAR_CHART_MARGIN);
    chart_bar_chart->attach(this); /* i.e. attach bar chart to plot. we only attach one chart to each plot. */
  }
//  insertLegend(chart_qwtlegend); /* necessary, seems to affect whole plot */
//  insertLegend(new QwtLegend()); /* necessary, seems to affect whole plot */
  /* nb: if we want left|bottom text, set_text_item() calls must precede this. */
  //if (chart_title_is_null == false) setTitle(chart_title);


  if (chart_left_is_null == false) { enableAxis(QwtPlot::yLeft, true); setAxisTitle(QwtPlot::yLeft, chart_left); }
  else enableAxis(QwtPlot::yLeft, false);
  if (chart_bottom_is_null == false) { enableAxis(QwtPlot::xBottom, true); setAxisTitle(QwtPlot::xBottom, chart_bottom); }
  else enableAxis(QwtPlot::xBottom, false);
  /* Todo: if I change the order of the following things, I run into trouble. */
  //  set_mode();
  set_chart_width();
  /* todo: check what happens if no header or very short header, that could ruin chart_bar_line_pie_width */
  resize(chart_bar_line_pie_width, chart_pixmap_height); /* todo: but that won't work on canvas width */

  /* Finished setting, now populate */
  fill();

  /* Finished chart, now make it a pixmap so copy_html_cell() will have a byte array to put in the HTML cell */
  QPixmap new_pixmap(this->size());
  new_pixmap= grab(this->rect());
  QByteArray ba;
  QBuffer buffer(&ba);
  buffer.open(QIODevice::WriteOnly);
  bool save_result= new_pixmap.save(&buffer, "PNG");
  unsigned int expected_output_size= (ba.size() * 4) / 3 + 64;
  if ((save_result == false)
   || (new_pixmap.isNull() == true)
   || (expected_output_size >= CHART_MAX_BYTE_SIZE - 1))
  {
    printf("Error in Chart::draw_group. pixmap could not be saved, or was null, or was too big.\n");
    if (save_result == false) printf("    save_result == false\n");
    if (new_pixmap.isNull() == true) printf("    new_pixmap.isNull() == true\n");
    printf("    expected_output_size=%d\n", expected_output_size);
    printf("    CHART_MAX_BYTE_SIZE=%d\n", CHART_MAX_BYTE_SIZE);
    strcpy(output, "");
    return 0;
  }
  strcpy(output, ba.toBase64()); /* i.e. buffer.data() */

  /* Finished producing chart and making it a pixmap, now clean up. If we don't, we'll have multiple bar charts etc. */
  if (chart_type == TOKEN_KEYWORD_BAR)
  {
    chart_bar_chart->attach(NULL);
    delete chart_bar_chart;
  }
  if ((chart_type == TOKEN_KEYWORD_LINE)|| (chart_type == TOKEN_KEYWORD_PIE))
  {
    for (int sub_group_number= 0; sub_group_number < chart_sub_group_count; ++sub_group_number)
    {
      chart_curves[sub_group_number]->attach(NULL);
      delete chart_curves[sub_group_number];
    }
  }
  return ba.size();
}

/*
  Plot height = result grid widget height, chart_pixmap_height will affect a later resize()
  Todo: for pies, we'll get chart_pixmap_height = chart_pixmap_width i.e. we have a square
  -- but soon we should add for the caption.
  ... Or, we'll get chart_pixmap_height = what's available ... that's commented out.
  This is the total height available in the widget, chart_bar_line_pie_height will be this minus what we need for caption.
  TODO: WHAT ABOUT HORIZONTAL SCROLL BAR?
  TODO: WHAT ABOUT MARGINS WITHIN HEADER?
  Elsewhere I think we say result grid has no margins, but use contentsRect instead of frameGeometry anyway.
  Todo: re horizontal scroll bar: If we're too wide, we want to say
    chart_bar_line_pie_height-= QApplication::style()->pixelMetric(QStyle::PM_ScrollBarExtent);
    but the only way to know we're too wide is to look at the width of all columns in the result set,
    and for pies the widths depend on the heights, so this might be hard.
*/
void QChart::set_chart_pixmap_height()
{
  QFontMetrics fm= QFontMetrics(chart_default_font);
  int height_of_bar= fm.boundingRect("W").height();

//  int height_of_bars= height_of_bar * group_columns_count;
//  if (height_n_total > height_of_bars) chart_pixmap_height= height_n_total;
//  else chart_pixmap_height= height_of_bars;

  QRect cr= chart_rg->contentsRect();

  chart_pixmap_height= cr.height();

  if (chart_rg->copy_of_ocelot_result_grid_column_names == 1) /* if heading exists */
    chart_pixmap_height-= height_of_bar + chart_rg->setting_ocelot_grid_cell_border_size_as_int;

  chart_pixmap_height-= 8; /* why 8? dunno */
  chart_pixmap_height-= chart_rg->setting_ocelot_grid_cell_border_size_as_int * 5; /* why 5? dunno */
  /* The above chart_pixmap_height changes were a reduction of the following tediously-tested instructions:
  int border_size= chart_rg->setting_ocelot_grid_cell_border_size_as_int;
  if (border_size == 0)   chart_pixmap_height-= 8;
  if (border_size == 1)   chart_pixmap_height-= 13;
  if (border_size == 2)   chart_pixmap_height-= 18;
  if (border_size == 3)   chart_pixmap_height-= 23;
  if (border_size == 4)   chart_pixmap_height-= 28;
  if (border_size == 5)   chart_pixmap_height-= 33;
  if (border_size == 6)   chart_pixmap_height-= 38;
  if (border_size == 7)   chart_pixmap_height-= 43;
  if (border_size == 8)   chart_pixmap_height-= 48;
  if (border_size == 9)   chart_pixmap_height-= 53;
  */

//  if (chart_pixmap_height < 100) chart_pixmap_height= 100; /* WRONG! BUT TEMPORARILY ... */

  /* Following should actually be boundingRect of the words underneath the line */
  /* Todo: figure out why height() + width wasn't enough */
//  int bottom_height= fm.boundingRect("W").height() + cha_default_container_pen_width + CHART_MARGIN_TOP;
  /* If there are multiple columns then bottom_height is lower */
//  if (cha_numeric_column_count > 1) bottom_height+= fm.boundingRect("W").height() * (cha_numeric_column_count - 1);

  int caption_height= fm.boundingRect("W").height();

  chart_bar_line_pie_height= chart_pixmap_height - caption_height;

  chart_bar_line_pie_height-= CHART_MARGIN_TOP + CHART_MARGIN_BOTTOM;

//  chart_bar_line_pie_height-= 10; /* why 10? dunno */
}

/*
  Call this for each group, and whenever result widget size changes e.g. due to detach.
  We want the chart to cover the result widget, and its accompanying vertical scroll bar.
  Warning: result widget parent is not mainwindow it is result_grid_tab_widget so rg->pos() is always 0.
  Todo: really width + height should consider scroll bars
  If we ask for too much, that should be okay, Qt will take over the screen for it
  But: with the new per-row calculating, I don't think we'll have any use for chart_pixmap_width or chart_pixmap_height.
  We have width_n_total = total of width_n passed to copy_html_cell() for each column in group
  We'll get width_of_bars = margins + min-bar-widths * # of bars i.e. # of columns in group
    (+1 for "left", +2 for left-axis, +1 for legend-icon, +2 for legend as if legend is always 2 chars)
  We'll get chart_bar_line_pie_width = greater of (width_n_total, width_of_bars).
  For a pie, chart width should = chart height, approximately. Ellipses are nice but wouldn't be expeced.
  We can override with set ocelot_grid_cell_width, but I'm not sure what units that's using.
  Re pie width: QwtAbstractLegend *legend= this->legend()'s QRect legend_rect= legend->contentsRect() width
    is not valid yet so we try increase by font width * 2, but shouldn't if there's no legend
  We should allow room for a scroll bar for the legend, it appears but clicking on it won't work
*/
void QChart::set_chart_width()
{
  int local_chart_pixmap_width;
  if ((chart_type == TOKEN_KEYWORD_BAR) || (chart_type == TOKEN_KEYWORD_LINE))
  {
    int group_columns_count= (chart_last_column_in_group - chart_first_column_in_group) + 1;
    int width_of_bars= (chart_bar_width * 2) * (group_columns_count + 7);
    width_of_bars+= CHART_MARGIN_BETWEEN_BARS * (group_columns_count - 1);
    local_chart_pixmap_width= width_of_bars + (CHART_MARGIN_LEFT + CHART_MARGIN_RIGHT);
    if (width_n_total > local_chart_pixmap_width) local_chart_pixmap_width= width_n_total;
    if (chart_header_widths.at(chart_last_column_in_group) > local_chart_pixmap_width)
      local_chart_pixmap_width= chart_header_widths.at(chart_last_column_in_group);
    chart_bar_line_pie_width= local_chart_pixmap_width - (CHART_MARGIN_LEFT + CHART_MARGIN_RIGHT);
  }
  else /* TOKEN_KEYWORD_PIE */
  {
    chart_bar_line_pie_width= chart_bar_line_pie_height; /* so canvas is in a square rect */
    chart_bar_line_pie_width+= chart_bar_width * 2;
    local_chart_pixmap_width= chart_bar_line_pie_width + CHART_MARGIN_LEFT + CHART_MARGIN_RIGHT;
  }
}

//void QChart::exportChart()
//{
//  QwtPlotRenderer renderer;
//  renderer.exportTo(this, "barchart.pdf");
//}

void QChart::default_settings_all()
{
  /* Copied from Chart:... start */
  {
    QPalette p= QPalette();
    p.setColor(QPalette::Window, chart_mainwindow->ocelot_grid_background_color);
    setAutoFillBackground(true); /* is this necessary, or is it default? */
    setPalette(p);
  }
  set_color_palette();
  chart_default_font= chart_mainwindow->get_font_from_style_sheet(chart_mainwindow->ocelot_grid_style_string);
  setFont(chart_default_font); /* might be overridden by a grid conditional */
  QFontMetrics fm= QFontMetrics(chart_default_font);
  set_chart_pixmap_height();
  cha_default_text_color= chart_mainwindow->qt_color(chart_mainwindow->ocelot_grid_text_color);
  cha_default_header_background_color= chart_mainwindow->qt_color(chart_mainwindow->ocelot_grid_header_background_color);
  cha_default_detail_background_color= chart_mainwindow->qt_color(chart_mainwindow->ocelot_grid_background_color);
  cha_default_container_pen_width= chart_mainwindow->ocelot_grid_cell_border_size.toInt();
  if (cha_default_container_pen_width < 1) cha_default_container_pen_width= 1;
  cha_default_container_pen.setColor(chart_mainwindow->qt_color(chart_mainwindow->ocelot_grid_cell_border_color));
  cha_default_container_pen.setWidth(cha_default_container_pen_width);
  cha_default_header_brush.setStyle(Qt::SolidPattern);
  cha_default_header_brush.setColor(cha_default_header_background_color);
  cha_default_detail_brush.setStyle(Qt::SolidPattern);
  cha_default_detail_brush.setColor(cha_default_detail_background_color);
  cha_default_text_pen.setColor(cha_default_text_color);
  group_header= ""; /* not sure that we use this any more */
  chart_header_widths.clear();
  for (unsigned int i= 0; i < cha_result_column_count; ++i) chart_header_widths.append(0);
  /* Copied from Chart::... end */

  /* But will QwtText inherit the font? But will you look for a conditional? */
  chart_legend_icon_size= fm.boundingRect("W").size();
  chart_bar_width= fm.boundingRect("W").width();
  chart_title_is_null= false; /* this might be unnecessary */
}

/*
  All text items are QwtText.
  I suspect that some things e.g. font size are inherited from the chart or the canvas, should I skip?
  Eventually this will be public because things like title are affected by client commands.
  We should be checking whether content is NULL rather than 'string', and change ..._is_null accordingly.
  I'm tempted to allow cha_color_palette[0] rather than ocelot_grid_text_color.
  Font and color are supposed to be conditional settings, I'm not checking for that yet.
*/
void QChart::set_text_item(QString name, QString content)
{
  QwtText* p;
  bool* pn;
  if (name == "TITLE") { p= &chart_title; pn =&chart_title_is_null; }
  else if (name == "LEFT") { p= &chart_left; pn =&chart_left_is_null; }
  else if (name == "BOTTOM") { p= &chart_bottom; pn =&chart_bottom_is_null; }
  else /* presumably "LEGEND" */ { p= &chart_legend; pn =&chart_legend_is_null; }
  p->setText(content);
  p->setFont(chart_default_font);
  p->setColor(chart_mainwindow->ocelot_grid_text_color);
  *pn= false;
}

/* copied from Chart:... */
/* TEST!!! We'll say NULLs are numbers for now, just so we can run tests without needing to create tables */
unsigned short int QChart::cha_result_data_type(unsigned short int result_field_type, QString column_name)
{
  if (column_name.right(3).toUpper() == "_ID") return OCELOT_DATA_TYPE_BLOB;
  unsigned short int ft= result_field_type;
  if ((ft == OCELOT_DATA_TYPE_DATE) || (ft == OCELOT_DATA_TYPE_TIME) || (ft == OCELOT_DATA_TYPE_DATETIME)
   || (ft == OCELOT_DATA_TYPE_VAR_STRING) || (ft == OCELOT_DATA_TYPE_STRING) || (ft == OCELOT_DATA_TYPE_TEXT))
    return OCELOT_DATA_TYPE_STRING;
  if ((ft == OCELOT_DATA_TYPE_DECIMAL) || (ft == OCELOT_DATA_TYPE_TINY) || (ft == OCELOT_DATA_TYPE_SHORT)
   || (ft == OCELOT_DATA_TYPE_LONG) || (ft == OCELOT_DATA_TYPE_FLOAT) || (ft == OCELOT_DATA_TYPE_DOUBLE)
   || (ft == OCELOT_DATA_TYPE_LONGLONG) || (ft == OCELOT_DATA_TYPE_INT24)
   || (ft == OCELOT_DATA_TYPE_NEWDECIMAL) || (ft == OCELOT_DATA_TYPE_INTEGER)
   || (ft == OCELOT_DATA_TYPE_UNSIGNED) || (ft == OCELOT_DATA_TYPE_NUMBER))
    return OCELOT_DATA_TYPE_NUMBER;
  if (ft == OCELOT_DATA_TYPE_NULL) return OCELOT_DATA_TYPE_NUMBER;
  return OCELOT_DATA_TYPE_BLOB;
}

/*
  Determine whether ocelot_grid_chart is applicable for this column
  Possible pen and brush change due to grid conditional, very similar to erd_draw_text_prepare
  Todo: conditional with column_number=2 gets column 1
  Todo: conditional with row_number=2 gets row 2 but I don't understand, shouldn't column_names affect it?
  We don't use background_color because bar color should equal text color of column (header line)
  TODO: check: column_number always == text_lines??
*/
void QChart::cha_draw_text_prepare(
               int column_number,    /* so we can get xpos i.e. column_number and ypos i.e. row_number */
               QString content,     /* table_name | column_name */
               int row_number,
               int cell_type,       /* TEXTEDITFRAME_CELL_TYPE_DETAIL | TEXTEDITFRAME_CELL_TYPE_HEADER */
               int text_lines,
               int numeric_column_count)
{
//  /* If there's only 1 num col, default color=grid color. Else default color=palette. Can be overridden. */
//  QColor this_color;
//  if (numeric_column_count < 2) this_color= cha_default_text_color;
//  else
//  {
//    char new_color[8];
//    int color_number= text_lines - chart_first_column_in_group;
//    strcpy(new_color, cha_color_palette[color_number % cha_color_palette_count]);
//    this_color= QColor(new_color);
//  }
//  chart_new_rect_brush= cha_default_detail_brush;
//  chart_new_rect_brush.setColor(this_color);
//  chart_new_container_pen= cha_default_container_pen;
//  chart_new_container_pen.setColor(this_color);
//  chart_new_text_pen= cha_default_text_pen;
//  chart_new_text_pen.setColor(this_color);
  QString string= content.trimmed();
  QByteArray string_utf8= string.toUtf8();
  QString new_tooltip, new_style_sheet, new_cell_height, new_cell_width, new_text;
  int cs_number;
  bool result_of_evaluate;
  result_of_evaluate= chart_rg->conditional_setting_evaluate_till_true(
    column_number + 0, /* i.e. result set column number. dunno why +1, it's really off by 1 */
    row_number + 1, /* e.g. text_frame->ancestor_grid_result_row_number */
    string_utf8.data(), /* e.g. text_frame->content_pointer */
    0, /* e.g. FIELD_VALUE_FLAG_IS_NULL */
    string_utf8.size(), /* e.g. text_frame->content_length */
    cell_type, /* e.g. text_frame->cell_type */
    &new_tooltip, /* return */
    &new_style_sheet, /* return */
    &new_cell_height, /* return */
    &new_cell_width, /* return */
    &cs_number,
    &new_text, NULL); /* return */

if (result_of_evaluate == true)
{
  chart_column_specs.append(new_text);
  ++chart_chartable_columns_count;
//  ++cha_numeric_column_count; /* though I think cha_numeric_column_count might be obsolete */
}
else
{
  chart_column_specs.append("");
}

//  if (result_of_evaluate == true)
//  {
//    QString new_color= chart_mainwindow->get_color_from_style_sheet(new_style_sheet);
//    chart_new_rect_brush.setColor(new_color);
//    chart_new_container_pen.setColor(new_color);
//    chart_new_text_pen.setColor(new_color);
//    /* This changes weight and style but not size. Original setting was in points not pixels. */
//    QFont qf= chart_mainwindow->get_font_from_style_sheet(new_style_sheet);
//    int point_size= chart_default_font.pointSize();
//    qf.setPointSize(point_size);
//    painter->setFont(qf);
//  }
//  else
//  {
//    painter->setFont(chart_default_font);
//  }
}

/* If we said SET ocelot_grid_chart='a b c d'; then offset_of_keyword('c') will return 2. */
int QChart::offset_of_keyword(QString keyword)
{
  for (int i= 0; chart_token_lengths[i] != 0; ++i)
  {
    QString s= chart_spec.mid(chart_token_offsets[i], chart_token_lengths[i]);
    if (QString::compare(s, keyword, Qt::CaseInsensitive) == 0) return i;
  }
  return -1;
}

QChart::QChart(ResultGrid *rg, MainWindow *parent_mainwindow, int passed_chart_type)
{
/* TEST ! */

///* TEST */
//double x[3];
//double y[3];
//x[0]= 0; x[1]= 1; x[2]= 2;
//y[0]= 8; y[1]= 5; y[2]= 8;
//QwtPlotCurve curve;
//curve.setSamples(x,y,3);
//curve.attach(this);
//replot();
//show();
//QMessageBox ms;
//ms.setText("OK");
//ms.exec();
//exit(0);
///* TEST */

  chart_type= passed_chart_type;
  chart_rg= rg;
  setParent(chart_rg); /* dunno why this seems necessary, we call from resultgrid */

  chart_mainwindow= parent_mainwindow;

  cha_result_column_count= chart_rg->result_column_count;
  cha_result_row_count= chart_rg->result_row_count;
  cha_result_set_copy_rows= chart_rg->result_set_copy_rows;
  cha_result_field_names= chart_rg->result_field_names;

  chart_column_types.clear(); /* probably unnecessary, it should be clear initially, and we clear again later */
  {
    chart_column_names.clear();
    QString this_column_name;
    char result_field_name[256];
    char *result_field_names_pointer= &cha_result_field_names[0];
    unsigned int v_length;
    for (unsigned int j= 0; j < cha_result_column_count; ++j)
    {
      memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
      result_field_names_pointer+= sizeof(unsigned int);
      memcpy(result_field_name, result_field_names_pointer, v_length);
      result_field_name[v_length]= '\0';
      result_field_names_pointer+= v_length;
      this_column_name= result_field_name;
      chart_column_names.append(this_column_name);

      unsigned short int chart_column_type= cha_result_data_type(chart_rg->result_field_types[j], this_column_name);
      chart_column_types.append(chart_column_type);
    }
  }

  /*
    In result_grid->evaluate_for_chart() we found that there is a SET OCELOT_GRID_CHART statement.
    So we created a QChart. Check if it's applicable. If it is, each chartable column should have a spec != "".
  */
  //cha_numeric_column_count= 0;
  chart_chartable_columns_count= 0; /* # of chartable columns */
  chart_column_specs.clear(); /* probably unnecessary */
  
  /* If ocelot_grid_chart > "" and there are no conditionals, every numeric column is chartable. */
  QString spec= parent_mainwindow->ocelot_grid_chart;
  int conditional_count= 0;
  for (int i= 0; i < parent_mainwindow->conditional_settings.count(); ++i)
  {
    if (parent_mainwindow->conditional_settings.at(i).left(22) == "SET OCELOT_GRID_CHART ") ++conditional_count;
  }
  if (conditional_count == 0) /* no ocelot_grid_chart conditionals? */
  {
    if (spec == "") return; /* and no ocelot_grid_chart_unconditional? then return with chart_chartable_count -- 0 */
    for (int i= 0; i < cha_result_column_count; ++i)
    {
       unsigned short int rft= cha_result_data_type(chart_rg->result_field_types[i], chart_column_names[i]);
       if (rft == OCELOT_DATA_TYPE_NUMBER)
       {
         //++cha_numeric_column_count;
         ++chart_chartable_columns_count;
         chart_column_specs.append(spec);
       }
       else chart_column_specs.append("");
     }
  }
  else /* there are conditionals */
  {
    for (int i= 0; i < cha_result_column_count; ++i)
    {
      unsigned short int rft= cha_result_data_type(chart_rg->result_field_types[i], chart_column_names[i]);
      if (rft == OCELOT_DATA_TYPE_NUMBER)
      {
        //++cha_numeric_column_count;
        /* if (cha_numeric_column_count == CHART_MAX_GROUP_SIZE) break; */ /* maybe a limit is good, though? */
        cha_draw_text_prepare(
                i, /* column_number */
                chart_column_names[i], /* column_name */
                0, /* row_number -- actually I don't know it */
                TEXTEDITFRAME_CELL_TYPE_DETAIL,
                i, /* column_number */
                cha_result_column_count); /* numeric_column_count */
      }
      else chart_column_specs.append("");
    }
  }
  
  if (chart_chartable_columns_count == 0) return; /* if not truly chartable, we'll delete chart and do a normal display */

  /* TODO: We would already know cha_numeric_column_count if we would call cha_setup()?! */

  /* Following will be superseded because min and max are per-row  now */
  //cha_max_column_height= 0;
  //cha_max_column_value= 0;  /* because base is always 0 even if all negative|positive */
  //cha_min_column_value= 0;
  default_settings_all();
//}

//QChart::QChart(QWidget *parent):
//  QwtPlot(parent)
//{
  //is_grouped= true; /* instead of default false i.e. stacked */
  //is_vertical= true; /* instead of default false i.e. horizontal */
  is_ticks= true; /* instead of default false i.e. no ticks (?? I think) (look at enable component) */

  /*
     Todo: I'd like to override this in draw_group but for some reason height will be wrong if we delay
  */
  resize(width(), chart_pixmap_height);
  //resize(500, chart_pixmap_height); /* TEST!! was 800. 500 is arbitrary. */ /* maybe this belongs in draw_group? */

  chart_qwtlegend= new QwtLegend();
  insertLegend(chart_qwtlegend); /* necessary, seems to affect whole plot */
  chart_qwtlegend_scroll_bar= chart_qwtlegend->verticalScrollBar();
  //chart_qwtlegend_scroll_bar->hide();
  if (chart_qwtlegend_scroll_bar == NULL) { printf("***** scroll bar NULL\n"); exit(0); }
  //installEventFilter(this); /* put this back in if you want to filter events other than on scroll bar */
  //chart_qwtlegend->installEventFilter(this);
  //chart_qwtlegend_scroll_bar->installEventFilter(this);
}

//bool QChart::eventFilter(QObject *obj, QEvent *event)
//{
//  //return main_window->eventfilter_function(obj, event);
//  printf("**** eventFilter! %d\n", event->type());
//  if (chart_qwtlegend == this->legend())
//  {
//    printf("**** legend =\n");
//    if (event->type() != QEvent::FontChange)
//    {
//      if (chart_qwtlegend_scroll_bar == chart_qwtlegend->verticalScrollBar()) printf("**** scroll bar =\n");
//      if (chart_qwtlegend_scroll_bar->isVisible()) printf("****                               isVisible\n");
//      if (chart_qwtlegend_scroll_bar->isEnabled()) printf("****                               isEnabled\n");
//    }
//  }
//  printf("**\n");
//  if (obj == this) printf("****     THIS EVENT %d!\n", event->type());
//  if (obj == chart_qwtlegend) printf("****     LEGEND EVENT %d!\n", event->type());
//  if (obj == chart_qwtlegend_scroll_bar)
//  {
////    printf("****     SCROLL EVENT %d. maximum=%d\n", event->type(), chart_qwtlegend_scroll_bar->maximum());
////    if (chart_qwtlegend_scroll_bar->maximum() > 0) chart_qwtlegend_scroll_bar->setValue(10);
//
//    int new_value;
//    new_value= chart_qwtlegend_scroll_bar->value();
//    printf("****     new_value=%d\n", new_value);
//  }
//    if (event->type() == QEvent::Scroll) printf("****       SCROLL!\n");
//    if (event->type() == QEvent::DragMove) printf("****       DRAGMOVE!\n");
//    if (event->type() == QEvent::EnabledChange) printf("****       ENABLEDCHANGE!\n");
//    if (event->type() == QEvent::Enter) printf("****       ENTER!\n");
//    if (event->type() == QEvent::Leave) printf("****       LEAVE!\n");
//    if (event->type() == QEvent::MouseButtonPress) printf("****       MOUSEBUTTONPRESS!\n");
//    if (event->type() == QEvent::FocusIn) printf("****       FOCUSIN!\n");
//    if (event->type() == QEvent::Paint) printf("****       PAINT!\n");
//    if (event->type() == QEvent::UpdateLater) printf("****       UPDATELATER!\n");
//    if (event->type() == QEvent::Timer) printf("****       TIMER!\n");
//    if (event->type() == QEvent::HideToParent) printf("****       HIDETOPARENT!\n");
//    if (event->type() == QEvent::LayoutRequest) printf("****       LAYOUTREQUEST!\n");
//    if (event->type() == QEvent::Polish) printf("****       POLISH\n");
//    if (event->type() == QEvent::ChildPolished) printf("****       CHILDPOLISHED!\n");
//    if (event->type() == QEvent::Resize) printf("****       RESIZE!\n");
//    if (event->type() == QEvent::ShowToParent) printf("****       SHOWTOPARENT!\n");
//    if (event->type() == QEvent::Move) printf("****       MOVE!\n");
//    if (event->type() == QEvent::FontChange) printf("****       FONTCHANGE!\n");
//    if (event->type() == QEvent::ChildAdded) printf("****       CHILDADDED!\n");
//    if (event->type() == QEvent::PolishRequest) printf("****       POLISHREQUEST!\n");
//
//  //return false; /* we would only return true if we wanted to filter the event filter out */
//    printf("**** return!\n");
//    return QObject::eventFilter(obj, event);
//}

/*
  Todo: Maybe we could find and subtract legend width width at an earlier point, and not repeat for each draw.
        Anyway the pie is too small now but at least it's a pie.
*/
void QChart::drawCanvas(QPainter *pixmap_painter)
{
  if (chart_type == TOKEN_KEYWORD_PIE)
  {
    int width_or_height= chart_canvas_height;
    if (chart_canvas_width < chart_canvas_height) width_or_height= chart_canvas_width;
//    canvas()->resize(chart_canvas_width, chart_canvas_height);
//      QPixmap pixmap= QPixmap(QSize(width_or_height, width_or_height));
  //    pixmap.fill(Qt::red);
    //  pixmap_painter->drawPixmap(0, 0, pixmap);

    /* setPen? */
    //pixmap_painter->setPen(Qt::red);
    //pixmap_painter->drawText(50, 50, "WOMBAT");
    //pixmap_painter->drawText(100, 100, "A");
    //pixmap_painter->drawText(120, 120, "B");
    //pixmap_painter->drawText(300, 130, "C");
    //pixmap_painter->drawText(600, 140, "D");

    /* COPIED start */
    /* initial faking  start */

    int sub_group_count= chart_sub_group_count;

    int sub_group_number= 0;

    int start_angle_of_pie= 0;

    QwtAbstractLegend *legend= this->legend();
    QRect legend_rect= legend->contentsRect();
    int height_of_pie_rounded= width_or_height - legend_rect.width();
    height_of_pie_rounded-= chart_bar_width;    /* Dunno why, but subtracting legend_rect.width() isn't enough */

    double total_height_of_pie= 0;
    // cha_heights.clear(); /* why? */

    double heights[100]; /* todo: dynamic allocation or better method */
    for (sub_group_number= 0; sub_group_number < sub_group_count; ++sub_group_number) heights[sub_group_number]= 0;

    for (sub_group_number= 0; sub_group_number < sub_group_count; ++sub_group_number)
    {
      for (int i= 0; i < chart_sub_group_list_sub_group_numbers.size(); ++i)
      {
        if (chart_sub_group_list_sub_group_numbers.at(i) == sub_group_number)
        {
          int j= chart_sub_group_list_column_numbers.at(i);
          double v= cha_column_values.at(j);
          total_height_of_pie+= v;
          heights[sub_group_number]+= v;
        }
      }
    }
    sub_group_number= 0; /* unnecessary? */

    /* initial faking end */
    if (chart_type == TOKEN_KEYWORD_PIE) /* ?? I already said this */
    {
/* A full circle is 16 * 360 = 5760 */
      /* Todo: dunno what to do with negatives */
//      int x= cha_x;
      /* initially start_angle_of_pie == 0 * 180 */
      for (sub_group_number= 0; sub_group_number < sub_group_count; ++sub_group_number)
      {
        if (heights[sub_group_number] > 0) /* ?? wrong because palette index should keep rising? no, I guess it's okay */
        {
          double fraction_of_total_height= heights[sub_group_number] / total_height_of_pie;
          double adj= 5760 * fraction_of_total_height;
//          QString column_name= chart_column_names.at(column_number);
          /* I used to have CHART_MARGIN_LEFT, CHART_MARGIN_TOP instead of 0, 0 */
          QRect qr_of_pie= QRect(0,
                               0,
                               height_of_pie_rounded, /* = chart_bar_line_pie_height if total height = maximum */
                               height_of_pie_rounded);
//          cha_draw_text_prepare(painter, column_number, column_name, i, TEXTEDITFRAME_CELL_TYPE_DETAIL,
//                                column_number, cha_numeric_column_count);
          int span_angle= round(adj);
//          QBrush brush;
          //brush.setColor(cha_color_palette[column_number % cha_color_palette_count]);

          QColor this_color= get_color_from_palette(sub_group_number);

//          brush.setColor(Qt::blue);

          pixmap_painter->setBrush(this_color);
          pixmap_painter->drawPie(qr_of_pie, start_angle_of_pie, span_angle);
          start_angle_of_pie+= span_angle;
        }
      }
    }
    /* COPIED end */

  }
  QwtPlot::drawCanvas(pixmap_painter);
}

/*
  Warning: this can be called with valueIndex == -1.
  If NULL, display is less dense. There's duplication here, QwtColumnSymbol is done similarly elsewhere.
  If NULL, there is no call for specialSymbol.
*/
void QMultiBarChart::drawBar(QPainter *painter, int sampleIndex, int valueIndex, const QwtColumnRect &rect) const
{
  int column_number= qchart->column_number_from_sample_and_series(sampleIndex, valueIndex);
  if ((qchart->chart_column_flags.at(column_number) & FIELD_VALUE_FLAG_IS_NULL) != 0)
  {
    QwtColumnSymbol symbol_for_null(QwtColumnSymbol::Box);
    symbol_for_null.setLineWidth(qchart->chart_bar_width);
    symbol_for_null.setFrameStyle(QwtColumnSymbol::Plain);
    symbol_for_null.setFrameStyle(QwtColumnSymbol::NoFrame); /* maybe should be plain frame? */
    QBrush brush(qchart->cha_color_palette[valueIndex % qchart->cha_color_palette_count], Qt::Dense5Pattern);
    QPalette palette;
    palette.setBrush(QPalette::Window, brush);
    symbol_for_null.setPalette(palette);
    symbol_for_null.draw(painter, rect);
  }
  else
    QwtPlotMultiBarChart::drawBar(painter, sampleIndex, valueIndex, rect);
}

//void MainWindow::chart_thermo()
//{
//  QwtThermo *thermo;
//  thermo= new QwtThermo;
//  thermo->setFillBrush(QBrush(Qt::red));
//  thermo->setScale(0, 10);
//  thermo->show();
//  QMessageBox msgbo;
//  msgbo.setText("OK");
//  msgbo.exec();
//}
#endif

#if (OCELOT_PLUGIN == 1)
/*
  e.g. plugin_widget_list_caller(PLUGIN_BEFORE_SEND_TO_SERVER, "");
  Warning: if two plugins have the same plugin_type, results are undefined. Maybe that should be illegal?
  Maybe we should return &ocelot_plugin_pass?
  What should the return be? The last return?
  If two plugins have the same type: calling is in order they were installed, we do not stop if plugin#1 returns error,
  we do not replace if plugin#1 used replacer_buffer (whatever plugin#2 does will override that).
  Todo: Maybe we should say INSERT ... EXCLUSIVE|UNIQUE if we want to prevent two with the same type.
  We return ER_OK even if there is no plugin. So if a menu refers to a nonexistent plugin, nothing will happen.
  Todo: I think we should return return_value immediately in all cases, i.e. ignore if there's a second matching plugin.
*/
int MainWindow::plugin_widget_list_caller(int plugin_type, QString menu_function_name)
{
  if (plugin_widget_list.size() == 0) return ER_OK;
  int return_value= ER_OK;
  for (int i= 0; i  < plugin_widget_list.size(); ++i)
  {
    Plugin *plugin_widget= plugin_widget_list[i];

    if (plugin_type == PLUGIN_MENU_CHOICE) /* if we're here because user clicked a menu item, function must match */
    {
      if (plugin_widget->id == menu_function_name)
      {
        return_value= plugin_widget->caller(plugin_type, &ocelot_plugin_pass);
        return return_value;
      }
    }
    if ((plugin_widget->plugin_type == plugin_type) || (plugin_widget->plugin_type == PLUGIN_ALL))
    {
      if (plugin_type != PLUGIN_MENU_CHOICE) /* ALL only means all trigger plugins not menu plugins */
      {
        return_value= plugin_widget->caller(plugin_type, &ocelot_plugin_pass);
        /* Check: error return? */
      }
    }
  }
  return return_value;
}

/*
  Effectively this is "install plugin", we use INSERT|DELETE to add to the PLUGINS table as well.
*/
int MainWindow::insert_plugin(QString plugin_id, QString plugin_soname, const QString *alltext)
{
  int plugin_type= -1;
  {
    int i;  /* There's a limited number of possible plugin identifiers. todo: for uninstall, list could be shorter. */
    for (i= 0; i <= PLUGIN_MAX; ++i)
    {
      if (strcmp(plugin_id.toUtf8(), plugin_strvalues[i].chars) == 0)
      {
        plugin_type= plugin_strvalues[i].token_keyword;
        break;
      }
    }
    /* Now if i > PLUGIN_MAX this name is not pre-assigned i.e. cannot be a trigger plugin but might be a menu plugin */
  }
  int return_code;
  {
    Plugin *plugin_widget= new Plugin(this);
    plugin_widget->plugin_type= plugin_type;
    if (alltext == NULL) return_code= plugin_widget->init(plugin_id, plugin_soname, 0);
    else return_code= plugin_widget->init(plugin_id, plugin_soname, 1);
    if (return_code != 0) delete plugin_widget;
    else plugin_widget_list.append(plugin_widget);
    return return_code;
  }
  return 0;
}

/*
  Effectively this is "uninstall plugin", we use DELETE to remove from the PLUGINS table as well.
  warning: if two plugins have the same id, we only delete the first one
  there is no check whether soname matches, I'm hoping that somewhere we ensure id is unique
  todo: case-insensitive matching? (if windows, I guess
*/
int MainWindow::delete_plugin(QString id)
{
  for (int i= 0; i  < plugin_widget_list.size(); ++i)
  {
    Plugin *plugin_widget= plugin_widget_list[i];
    if (id == plugin_widget->id)
    {
      /* todo: might be good to have  a call for uninstall here */
      delete plugin_widget;
      plugin_widget_list.removeAt(i);
      return ER_OK;
    }
  }
  return ER_0_ROWS_RETURNED;
}

/* For general comments about the Plugin class see ocelotgui.h after the directive #ifndef PLUGIN_H */
Plugin::Plugin(MainWindow *m) /* constructor */
{
  /* Error if plugin_widget_list cannot be increased! */
#ifdef _WIN32
  plugin_library.setFileName("");
#else
  plugin_handle= NULL;
#endif
  plugin_function_pointer= NULL;
  plugin_main_window= m;
}

/* Warning: assume statement_edit_widget exists but error messages won't appear until display happens. printf()? */
/* Expect plugin_id = what we call (so dlsym should work), plugin_library_name = soname (so dlopen should work) */
int Plugin::init(QString plugin_id, QString plugin_library_name, int call_type)
{
  int result= 0;
  char message[256];
  /* TODO: actually these are items you should allocate as char[] ! */
  id= plugin_main_window->connect_stripper(plugin_id, true);
  soname= plugin_main_window->connect_stripper(plugin_library_name, true);
  char plugin_soname_as_utf8[1024];
  strcpy(plugin_soname_as_utf8, soname.toUtf8()); /* e.g. /home/pgulutzan/ocelotgui/libplugin.so */
#ifdef _WIN32
  plugin_library.setFileName(soname);
  bool is_library_loaded= plugin_library.load();
  if (is_library_loaded == false)
  {
    /* load failed, plugin_library.errorString()) should have more info */
    strcpy(message, "dlopen or LoadLibrary failed for ");
    strcat(message, plugin_soname_as_utf8);
    plugin_library.setFileName("");
    goto error_return;
  }
#else  /* i.e. not Windows, probably OCELOT_OS_LINUX */
  plugin_handle= dlopen(plugin_soname_as_utf8, RTLD_NOW);
  if (plugin_handle == NULL)
  {
    strcpy(message, "dlopen or LoadLibrary failed for ");
    strcat(message, plugin_soname_as_utf8);
    goto error_return;
  }
#endif
  strcpy(ocelot_plugin_pass.id, id.toUtf8());
  char plugin_id_as_utf8[1024];
  strcpy(plugin_id_as_utf8, id.toUtf8()); /* e.g. the name of a function in the library */
#ifdef _WIN32
  /* test only */
//  typedef void (*MyPrototype)();
//  MyPrototype myFunction = (MyPrototype) plugin_library.resolve("W");
//  if (myFunction == NULL) printf("**** myFuncion = NULL\n");
//  if (myFunction)
//      myFunction();
//  mbox.setText(plugin_library.errorString());
//  mbox.exec();
//  plugin_function_pointer= (int (*)(struct plugin_pass *))GetProcAddress(plugin_handle, "before_insert");
  plugin_function_pointer= (int (*)(struct plugin_pass *))plugin_library.resolve("before_insert");
#else  /* i.e. not Windows, probably OCELOT_OS_LINUX */
  plugin_function_pointer= (int (*)(struct plugin_pass *))dlsym(plugin_handle, "before_insert");
#endif
  if (plugin_function_pointer != NULL)
  {
    int install_result= (*plugin_function_pointer)(&ocelot_plugin_pass);
    if (install_result != 0)
    {
      strcpy(message, "The before_insert plugin returned a non-zero value so install fails");
      goto error_return;
    }
  }
  /* todo: the name should be for a function that we will call, we're not checking for that. check in hparse too */
#ifdef _WIN32
//  plugin_function_pointer= (int (*)(struct plugin_pass *))GetProcAddress(plugin_handle, plugin_id_as_utf8);
  plugin_function_pointer= (int (*)(struct plugin_pass *))plugin_library.resolve(plugin_id_as_utf8);
#else  /* i.e. not Windows, probably OCELOT_OS_LINUX */
  plugin_function_pointer= (int (*)(struct plugin_pass *))dlsym(plugin_handle, plugin_id_as_utf8);
#endif
  if (plugin_function_pointer == NULL)
  {
    strcpy(message, "dlsym or GetProcAddress failed for ");
    strcat(message, plugin_id_as_utf8);
    goto error_return;
  }
  /* This is the older way to call, the C99 way to call is result= plugin_function_pointer(n, arg); */
  /* ... but we don't call the function, this is just an illustration */
  /* result= (*plugin_function_pointer)(&ocelot_plugin_pass); */    /* Pass struct connect_arguments */
  /* if result != 0, it means error, and so the install should fail */
  return result;
error_return:
  if (call_type == 0) printf("%s\n", message);
  else plugin_main_window->put_message_in_result(message);
  return ER_ERROR;
}

int Plugin::caller(int type, struct plugin_pass *plugin_pass)
{
  assert(plugin_function_pointer != NULL); /* impossible */
  plugin_pass->type= type;
  int result= (*plugin_function_pointer)(plugin_pass);
  return result;
}

Plugin::~Plugin()
{
#ifdef _WIN32
  if ((plugin_library.fileName() != "") && (plugin_library.isLoaded())) plugin_library.unload();
#endif
#ifdef OCELOT_OS_LINUX
  if (plugin_handle != NULL) dlclose(plugin_handle);
#endif
}
#endif // #if (OCELOT_PLUGIN == 1)

#ifdef DBMS_TARANTOOL
#if (OCELOT_THIRD_PARTY==1)
#define OCELOT_THIRD_PARTY_CODE
  #include "third_party.h"
#endif
#endif

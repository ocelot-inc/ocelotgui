/* Copyright (c) 2021 by Peter Gulutzan. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
*/

#ifndef OCELOTGUI_H
#define OCELOTGUI_H

/* If you tell CMakeLists.txt -DOCELOT_MYSQL_INCLUDE=0, you can't access MySQL/MariaDB. Of course default is 1 and recommended. */
#ifndef OCELOT_MYSQL_INCLUDE
#define OCELOT_MYSQL_INCLUDE 1
#endif

/* The debugger is integrated now, but "if (OCELOT_MYSQL_DEBUGGER = 1)" directives help to delineate code that is debugger-specific. */
#ifndef OCELOT_MYSQL_DEBUGGER
#define OCELOT_MYSQL_DEBUGGER OCELOT_MYSQL_INCLUDE
#endif

/* To remove most of the code related to Edit|Find feature if you don't need it, set OCELOT_FIND_WIDGET 0 */
#ifndef OCELOT_FIND_WIDGET
#define OCELOT_FIND_WIDGET 1
#endif

/* To remove most of the code related to SET ocelot_import|ocelot_export, set OCELOT_IMPORT_EXPORT 0 */
#ifndef OCELOT_IMPORT_EXPORT
#define OCELOT_IMPORT_EXPORT 1
#endif

#if (OCELOT_MYSQL_INCLUDE == 0)
typedef struct
{
  int not_really_mysql_res;
} MYSQL_RES;
#endif //#if (OCELOT_MYSQL_INCLUDE == 0)

/*
  Predefined OS macro
  I depend on https://sourceforge.net/p/predef/wiki/OperatingSystems/
  Also useful are Q_OS_... declarations in http://doc.qt.io/qt-5/qtglobal.html
  but they're not known until we do Qt includes, later.
  (So far, only ostrings.h has been #included.)
  See also ./CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp
  which checks for __CYGWIN__ and __MINGW32__.
  OCELOT_OS_LINUX is for Linux-specific code, actually tested on Linux
  OCELOT_OS_NONLINUX is for Qt-specific code, seems to work on Windows
  The idea is that, if we support more platforms, we'll add more
  e.g. OCELOT_OS_OPENBSD.
  With OCELOT_OS_FREEBSD we can build but haven't checked all the places
  where we check if it's nonlinux (which is also true if FreeBSD is true),
  so runtime failures are likely.
  "__linux" and "linux" are obsolete, someday we'll stop looking for them
  Todo: we also check Q_OS_LINUX or Q_OS_FREEBSD Qt macros. Stop doing so?
*/
#if defined(__linux__) || defined(__linux) || defined(linux)
#define OCELOT_OS_LINUX
#else
#define OCELOT_OS_NONLINUX
#endif
#if defined(__FreeBSD__)
#define OCELOT_OS_FREEBSD
#endif

/*
  The possible DBMS values.
  These are related to ocelot_dbms values.
  --ocelot_dbms='mysql' is default.
  --ocelot_dbms='mariadb' is non-default but officially supported.
  --ocelot_dbms='tarantool' is non-default and experimental.
  If we start as MySQL but then connect to MariaDB, or vice versa,
  it's okay because we change to what we connected to.
  If --ocelot_dbms='tarantool', connection must be to a Tarantool server.
  Before defining for a new version, check set_dbms_version_mask().
  In set_dbms_version_mask we set for the version and for lower versions,
  e.g. if it's MySQL 5.6 we set both FLAG_VERSION_MYSQL_5_5 and
  FLAG_VERSION_MYSQL_5_6.
  Todo: eventually FLAG_VERSION_TARANTOOL_2_2 etc. has to be part of FLAG_VERSION_ALL
*/
#define DBMS_MYSQL 1
#define DBMS_MARIADB 2
#define DBMS_TARANTOOL 3
#define FLAG_VERSION_MYSQL_5_5      1
#define FLAG_VERSION_MYSQL_5_6      2
#define FLAG_VERSION_MYSQL_5_7      4
#define FLAG_VERSION_MYSQL_8_0      8
#define FLAG_VERSION_MYSQL_ALL      (1 | 2 | 4 | 8)
#define FLAG_VERSION_MARIADB_5_5    16
#define FLAG_VERSION_MARIADB_10_0   32
#define FLAG_VERSION_MARIADB_10_1   64
#define FLAG_VERSION_MARIADB_10_2_2 128
#define FLAG_VERSION_MARIADB_10_2_3 256
#define FLAG_VERSION_MARIADB_10_3   512
#define FLAG_VERSION_MARIADB_ALL    (16 | 32 | 64 | 128 | 256 | 512)
#define FLAG_VERSION_MYSQL_OR_MARIADB_ALL (1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 | 512)
#define FLAG_VERSION_TARANTOOL      1024
#define FLAG_VERSION_ALL (1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 | 512 | 1024)
#define FLAG_VERSION_LUA            2048
#define FLAG_VERSION_ALL_OR_LUA (FLAG_VERSION_ALL | FLAG_VERSION_LUA)
#define FLAG_VERSION_PLSQL          4096
#define FLAG_VERSION_SET_OPTION         8192
#define FLAG_VERSION_CONNECT_OPTION     16384
#define FLAG_VERSION_OPTION             (8192 | 16384)
#define FLAG_VERSION_TARANTOOL_2_2  32768
#define FLAG_VERSION_TARANTOOL_2_3  65536
#define FLAG_VERSION_LUA_OUTPUT       131072
#define FLAG_VERSION_TARANTOOL_2_4    262144
#define FLAG_VERSION_TARANTOOL_2_7    262144
#define FLAG_VERSION_TARANTOOL_ALL    (262144 | 65536 | 32768 | 1024)
#define FLAG_VERSION_DEFAULT FLAG_VERSION_MYSQL_OR_MARIADB_ALL

#include <assert.h>
#include <stdint.h>

/*
  Decide whether to use static-linked library for use with MySQL/MariaDB.
  Builders can say cmake . -DOCELOT_STATIC_LIBRARY=1 to use.
  They will have to deliberately add an appropriate library when they
  build, probably libmariadb.a.
  Otherwise OCELOT_STATIC_LIBRARY=0 on Linux|FreeBSD, OCELOT_STATIC_LIBRARY=1 on Windows.
*/
#ifndef OCELOT_STATIC_LIBRARY
#ifdef OCELOT_OS_LINUX
#define OCELOT_STATIC_LIBRARY 0
#endif
#ifdef OCELOT_OS_FREEBSD
#define OCELOT_STATIC_LIBRARY 0
#endif
#ifndef OCELOT_STATIC_LIBRARY
#define OCELOT_STATIC_LIBRARY 1
#endif
#endif

/*
  Decide whether to #include third_party.h for use with Tarantool.
  Mostly third_party.h has tarantool-c source modified for Windows.
  By default it is included for both Windows and Linux starting with ocelotgui 1.0.7.
  To say it is not included, either build with cmake . -DOCELOT_THIRD_PARTY=0
  or change the lines below to say "#define OCELOT_THIRD_PARTY 0".
  If it is not included, then:
  (if you only connect to MariaDB / MySQL) it doesn't matter, we never use it
  (if you start with --ocelot_dbms=tarantool) ocelotgui will load libtarantool.so.
  On Windows there is no libtarantool.so.
  On Linux libtarantool.so is easily acquired by installing and building from
  tarantool-c, and actually it's probably better to use libtarantool.so because
  it may contain bug fixes or enhancements, so it's actually good on Linux to not include third_party.h.
  We only include it on Linux so that the code base on Linux and Windows will be the same.
  Todo: I've never tried to find libtarantool.so on FreeBSD.
*/
#ifndef OCELOT_THIRD_PARTY
#ifdef OCELOT_OS_LINUX
#define OCELOT_THIRD_PARTY 1
#endif
#ifdef OCELOT_OS_NONLINUX
#ifdef OCELOT_OS_FREEBSD
#define OCELOT_THIRD_PARTY 1
#else
#define OCELOT_THIRD_PARTY 1
#endif
#endif
#endif


enum {                                        /* possible returns from token_type() */
  TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE= 1, /* starts with ' or N' or X' or B' */
  TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE= 2, /* starts with " */
  TOKEN_TYPE_LITERAL_WITH_DIGIT= 3,        /* starts with 0-9 */
  TOKEN_TYPE_LITERAL_WITH_BRACKET= 4,      /* starts with [[, Lua only */
  TOKEN_TYPE_LITERAL_WITH_BRACE= 5,        /* starts with { */ /* obsolete? */
  TOKEN_TYPE_LITERAL= 5,
  TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK= 6,  /* starts with ` */
  TOKEN_TYPE_IDENTIFIER_WITH_DOUBLE_QUOTE= 7, /* starts with " and hparse_ansi_quote=true */
  TOKEN_TYPE_IDENTIFIER_WITH_AT= 8,        /* starts with @ */
  TOKEN_TYPE_IDENTIFIER= 8,
  TOKEN_TYPE_COMMENT_WITH_SLASH = 9,        /* starts with / * or * / */
  TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE= 10,   /* starts with # */
  TOKEN_TYPE_COMMENT_WITH_MINUS= 11,        /* starts with -- */
  TOKEN_TYPE_OPERATOR= 12,                 /* starts with < > = ! etc. */
  TOKEN_TYPE_OTHER= 13,                    /* identifier? keyword? */
  /* The TOKEN_KEYWORD_... numbers must match the strvalues list for tokens_to_keywords(). */
  TOKEN_KEYWORDS_START= TOKEN_TYPE_OTHER + 1,
  TOKEN_KEYWORD_QUESTIONMARK= TOKEN_KEYWORDS_START, /* ocelotgui keyword */
    TOKEN_KEYWORD_ABORT,
        TOKEN_KEYWORD_ABORT_SOURCE_ON_ERROR,
    TOKEN_KEYWORD_ABS,
    TOKEN_KEYWORD_ACCESSIBLE,
    TOKEN_KEYWORD_ACOS,
    TOKEN_KEYWORD_ACTION,
    TOKEN_KEYWORD_ADD,
    TOKEN_KEYWORD_ADDDATE,
    TOKEN_KEYWORD_ADDTIME,
    TOKEN_KEYWORD_AES_DECRYPT,
    TOKEN_KEYWORD_AES_ENCRYPT,
    TOKEN_KEYWORD_AFTER,
    TOKEN_KEYWORD_AGAINST,
    TOKEN_KEYWORD_ALGORITHM,
    TOKEN_KEYWORD_ALL,
    TOKEN_KEYWORD_ALTER,
    TOKEN_KEYWORD_ALWAYS,
    TOKEN_KEYWORD_ANALYZE,
    TOKEN_KEYWORD_AND,
    TOKEN_KEYWORD_ANY,
    TOKEN_KEYWORD_ANY_VALUE,
    TOKEN_KEYWORD_AREA,
    TOKEN_KEYWORD_ARRAY,
    TOKEN_KEYWORD_AS,
    TOKEN_KEYWORD_ASBINARY,
    TOKEN_KEYWORD_ASC,
    TOKEN_KEYWORD_ASCII,
    TOKEN_KEYWORD_ASENSITIVE,
    TOKEN_KEYWORD_ASIN,
    TOKEN_KEYWORD_ASTEXT,
    TOKEN_KEYWORD_ASWKB,
    TOKEN_KEYWORD_ASWKT,
    TOKEN_KEYWORD_ASYMMETRIC_DECRYPT,
    TOKEN_KEYWORD_ASYMMETRIC_DERIVE,
    TOKEN_KEYWORD_ASYMMETRIC_ENCRYPT,
    TOKEN_KEYWORD_ASYMMETRIC_SIGN,
    TOKEN_KEYWORD_ASYMMETRIC_VERIFY,
    TOKEN_KEYWORD_ATAN,
    TOKEN_KEYWORD_ATAN2,
    TOKEN_KEYWORD_ATOMIC,
    TOKEN_KEYWORD_ATTACH,
    TOKEN_KEYWORD_AUTOINCREMENT,
        TOKEN_KEYWORD_AUTO_REHASH,
        TOKEN_KEYWORD_AUTO_VERTICAL_OUTPUT,
    TOKEN_KEYWORD_AVG,
    TOKEN_KEYWORD_BACKUP_ADMIN,
    TOKEN_KEYWORD_BATCH,
    TOKEN_KEYWORD_BECOMES,
    TOKEN_KEYWORD_BEFORE,
    TOKEN_KEYWORD_BEGIN,
    TOKEN_KEYWORD_BENCHMARK,
    TOKEN_KEYWORD_BETWEEN,
    TOKEN_KEYWORD_BFILE,
    TOKEN_KEYWORD_BIGINT,
    TOKEN_KEYWORD_BIN,
    TOKEN_KEYWORD_BINARY,
    TOKEN_KEYWORD_BINARY_DOUBLE,
    TOKEN_KEYWORD_BINARY_FLOAT,
    TOKEN_KEYWORD_BINARY_MODE,
    TOKEN_KEYWORD_BIND,
    TOKEN_KEYWORD_BIND_ADDRESS,
    TOKEN_KEYWORD_BINLOG,
    TOKEN_KEYWORD_BINLOG_ADMIN,
    TOKEN_KEYWORD_BINLOG_GTID_POS,
    TOKEN_KEYWORD_BIT,
    TOKEN_KEYWORD_BIT_AND,
    TOKEN_KEYWORD_BIT_COUNT,
    TOKEN_KEYWORD_BIT_LENGTH,
    TOKEN_KEYWORD_BIT_OR,
    TOKEN_KEYWORD_BIT_XOR,
    TOKEN_KEYWORD_BLOB,
    TOKEN_KEYWORD_BODY,
    TOKEN_KEYWORD_BOOL,
    TOKEN_KEYWORD_BOOLEAN,
    TOKEN_KEYWORD_BOTH,
    TOKEN_KEYWORD_BOXES,
    TOKEN_KEYWORD_BREAK,
    TOKEN_KEYWORD_BUFFER,
    TOKEN_KEYWORD_BUSY_TIMEOUT,
    TOKEN_KEYWORD_BY,
    TOKEN_KEYWORD_CALL,
    TOKEN_KEYWORD_CASCADE,
    TOKEN_KEYWORD_CASE,
    TOKEN_KEYWORD_CAST,
    TOKEN_KEYWORD_CEIL,
    TOKEN_KEYWORD_CEILING,
    TOKEN_KEYWORD_CENTROID,
    TOKEN_KEYWORD_CHANGE,
    TOKEN_KEYWORD_CHAR,
    TOKEN_KEYWORD_CHARACTER,
    TOKEN_KEYWORD_CHARACTER_LENGTH,

    TOKEN_KEYWORD_CHARACTER_SETS_DIR,


    TOKEN_KEYWORD_CHARSET,
    TOKEN_KEYWORD_CHAR_LENGTH,
    TOKEN_KEYWORD_CHECK,
    TOKEN_KEYWORD_CLEAR,
    TOKEN_KEYWORD_CLOB,
    TOKEN_KEYWORD_CLOSE,
    TOKEN_KEYWORD_COALESCE,
    TOKEN_KEYWORD_COERCIBILITY,
    TOKEN_KEYWORD_COLLATE,
    TOKEN_KEYWORD_COLLATION,
    TOKEN_KEYWORD_COLLATION_LIST,
    TOKEN_KEYWORD_COLUMN,
    TOKEN_KEYWORD_COLUMNS,
    TOKEN_KEYWORD_COLUMN_ADD,
    TOKEN_KEYWORD_COLUMN_CHECK,
    TOKEN_KEYWORD_COLUMN_CREATE,
    TOKEN_KEYWORD_COLUMN_DELETE,
    TOKEN_KEYWORD_COLUMN_EXISTS,
    TOKEN_KEYWORD_COLUMN_GET,
    TOKEN_KEYWORD_COLUMN_JSON,
    TOKEN_KEYWORD_COLUMN_LIST,
    TOKEN_KEYWORD_COLUMN_NAME,
    TOKEN_KEYWORD_COLUMN_NAMES,
    TOKEN_KEYWORD_COLUMN_NUMBER,
    TOKEN_KEYWORD_COLUMN_TYPE,
    TOKEN_KEYWORD_COLUMN_TYPE_INFO,

    TOKEN_KEYWORD_COMMA,
    TOKEN_KEYWORD_COMMENT,
        TOKEN_KEYWORD_COMMENTS,
    TOKEN_KEYWORD_COMMIT,
    TOKEN_KEYWORD_COMPACT,
    TOKEN_KEYWORD_COMPRESS,
    TOKEN_KEYWORD_COMPRESSED,
    TOKEN_KEYWORD_COMPRESSION,
    TOKEN_KEYWORD_CONCAT,
    TOKEN_KEYWORD_CONCAT_WS,
    TOKEN_KEYWORD_CONDITION,
    TOKEN_KEYWORD_CONFLICT,
    TOKEN_KEYWORD_CONNECT,
    TOKEN_KEYWORD_CONNECTION_ADMIN,
        TOKEN_KEYWORD_CONNECTION_ID,
    TOKEN_KEYWORD_CONNECT_ATTR_DELETE,
    TOKEN_KEYWORD_CONNECT_ATTR_RESET,
    TOKEN_KEYWORD_CONNECT_EXPIRED_PASSWORD,
    TOKEN_KEYWORD_CONNECT_TIMEOUT,

    TOKEN_KEYWORD_CONSTRAINT,
    TOKEN_KEYWORD_CONTAINS,
    TOKEN_KEYWORD_CONTINUE,
    TOKEN_KEYWORD_CONV,
    TOKEN_KEYWORD_CONVERT,
    TOKEN_KEYWORD_CONVERT_TZ,
    TOKEN_KEYWORD_CONVEXHULL,
    TOKEN_KEYWORD_COS,
    TOKEN_KEYWORD_COT,
    TOKEN_KEYWORD_COUNT,
    TOKEN_KEYWORD_CRC32,
    TOKEN_KEYWORD_CREATE,
    TOKEN_KEYWORD_CREATE_ASYMMETRIC_PRIV_KEY,
    TOKEN_KEYWORD_CREATE_ASYMMETRIC_PUB_KEY,
    TOKEN_KEYWORD_CREATE_DH_PARAMETERS,
    TOKEN_KEYWORD_CREATE_DIGEST,
    TOKEN_KEYWORD_CROSS,
    TOKEN_KEYWORD_CROSSES,
    TOKEN_KEYWORD_CUBE,
    TOKEN_KEYWORD_CUME_DIST,
    TOKEN_KEYWORD_CURDATE,
    TOKEN_KEYWORD_CURRENT,
    TOKEN_KEYWORD_CURRENT_DATE,
    TOKEN_KEYWORD_CURRENT_ROLE,
    TOKEN_KEYWORD_CURRENT_TIME,
    TOKEN_KEYWORD_CURRENT_TIMESTAMP,
    TOKEN_KEYWORD_CURRENT_USER,
    TOKEN_KEYWORD_CURSOR,
    TOKEN_KEYWORD_CURTIME,
    TOKEN_KEYWORD_CYCLE,
    TOKEN_KEYWORD_DATABASE,
    TOKEN_KEYWORD_DATABASES,
    TOKEN_KEYWORD_DATE,
    TOKEN_KEYWORD_DATEDIFF,
    TOKEN_KEYWORD_DATETIME,
    TOKEN_KEYWORD_DATE_ADD,
    TOKEN_KEYWORD_DATE_FORMAT,
    TOKEN_KEYWORD_DATE_SUB,
    TOKEN_KEYWORD_DAY,
    TOKEN_KEYWORD_DAYNAME,
    TOKEN_KEYWORD_DAYOFMONTH,
    TOKEN_KEYWORD_DAYOFWEEK,
    TOKEN_KEYWORD_DAYOFYEAR,
    TOKEN_KEYWORD_DAY_HOUR,
    TOKEN_KEYWORD_DAY_MICROSECOND,
    TOKEN_KEYWORD_DAY_MINUTE,
    TOKEN_KEYWORD_DAY_SECOND,
    TOKEN_KEYWORD_DEALLOCATE,
    TOKEN_KEYWORD_DEBUG,
    TOKEN_KEYWORD_DEBUG_CHECK,
    TOKEN_KEYWORD_DEBUG_INFO,
    TOKEN_KEYWORD_DEC,
    TOKEN_KEYWORD_DECIMAL,
    TOKEN_KEYWORD_DECLARE,
    TOKEN_KEYWORD_DECODE,
    TOKEN_KEYWORD_DECODE_HISTOGRAM,
    TOKEN_KEYWORD_DEFAULT,
    TOKEN_KEYWORD_DEFAULTS_EXTRA_FILE,
    TOKEN_KEYWORD_DEFAULTS_FILE,
    TOKEN_KEYWORD_DEFAULTS_GROUP_SUFFIX,
    TOKEN_KEYWORD_DEFAULT_AUTH,
    TOKEN_KEYWORD_DEFAULT_CHARACTER_SET,
    TOKEN_KEYWORD_DEFERRABLE,
    TOKEN_KEYWORD_DEFERRED,
    TOKEN_KEYWORD_DEGREES,
    TOKEN_KEYWORD_DELAYED,
    TOKEN_KEYWORD_DELETE,
    TOKEN_KEYWORD_DELIMITED,
    TOKEN_KEYWORD_DELIMITER,
    TOKEN_KEYWORD_DENSE_RANK,
    TOKEN_KEYWORD_DESC,
    TOKEN_KEYWORD_DESCRIBE,
    TOKEN_KEYWORD_DES_DECRYPT,
    TOKEN_KEYWORD_DES_ENCRYPT,
    TOKEN_KEYWORD_DETACH,
    TOKEN_KEYWORD_DETERMINISTIC,
    TOKEN_KEYWORD_DIMENSION,
    TOKEN_KEYWORD_DIRECTORY,
    TOKEN_KEYWORD_DISJOINT,
    TOKEN_KEYWORD_DISTANCE,
    TOKEN_KEYWORD_DISTINCT,
    TOKEN_KEYWORD_DISTINCTROW,
    TOKEN_KEYWORD_DIV,
    TOKEN_KEYWORD_DO,
    TOKEN_KEYWORD_DOUBLE,
    TOKEN_KEYWORD_DROP,
    TOKEN_KEYWORD_DUAL,
    TOKEN_KEYWORD_DUPLICATE,
    TOKEN_KEYWORD_DYNAMIC,
    TOKEN_KEYWORD_EACH,
    TOKEN_KEYWORD_EDIT,
    TOKEN_KEYWORD_EGO,
    TOKEN_KEYWORD_ELSE,
    TOKEN_KEYWORD_ELSEIF,
    TOKEN_KEYWORD_ELSIF,
    TOKEN_KEYWORD_ELT,
    TOKEN_KEYWORD_EMPTY,
    TOKEN_KEYWORD_ENABLE,
        TOKEN_KEYWORD_ENABLE_CLEARTEXT_PLUGIN,
    TOKEN_KEYWORD_ENCLOSED,
    TOKEN_KEYWORD_ENCODE,
    TOKEN_KEYWORD_ENCRYPT,
    TOKEN_KEYWORD_ENCRYPTION_KEY_ADMIN,
    TOKEN_KEYWORD_END,
    TOKEN_KEYWORD_ENDPOINT,
    TOKEN_KEYWORD_ENGINE,
    TOKEN_KEYWORD_ENUM,
    TOKEN_KEYWORD_ENVELOPE,
    TOKEN_KEYWORD_EQUALS,
    TOKEN_KEYWORD_ESCAPE,
    TOKEN_KEYWORD_ESCAPED,
    TOKEN_KEYWORD_EVENT,
    TOKEN_KEYWORD_EXCEPT,
    TOKEN_KEYWORD_EXCEPTION,
    TOKEN_KEYWORD_EXCHANGE,
    TOKEN_KEYWORD_EXCLUSIVE,
    TOKEN_KEYWORD_EXECUTE,
    TOKEN_KEYWORD_EXISTS,
    TOKEN_KEYWORD_EXIT,
    TOKEN_KEYWORD_EXP,
    TOKEN_KEYWORD_EXPANSION,
    TOKEN_KEYWORD_EXPLAIN,
    TOKEN_KEYWORD_EXPORT,
    TOKEN_KEYWORD_EXPORT_SET,
    TOKEN_KEYWORD_EXTERIORRING,
    TOKEN_KEYWORD_EXTRACT,
    TOKEN_KEYWORD_EXTRACTVALUE,
    TOKEN_KEYWORD_FAIL,
    TOKEN_KEYWORD_FALSE,
    TOKEN_KEYWORD_FETCH,
    TOKEN_KEYWORD_FIELD,
    TOKEN_KEYWORD_FIELDS,
    TOKEN_KEYWORD_FILE,
    TOKEN_KEYWORD_FIND_IN_SET,
    TOKEN_KEYWORD_FIREWALL_ADMIN,
    TOKEN_KEYWORD_FIREWALL_USER,
    TOKEN_KEYWORD_FIRST,
    TOKEN_KEYWORD_FIRST_VALUE,
    TOKEN_KEYWORD_FIXED,
    TOKEN_KEYWORD_FLOAT,
    TOKEN_KEYWORD_FLOAT4,
    TOKEN_KEYWORD_FLOAT8,
    TOKEN_KEYWORD_FLOOR,
    TOKEN_KEYWORD_FLUSH,
    TOKEN_KEYWORD_FOLLOWING,
    TOKEN_KEYWORD_FOLLOWS,
    TOKEN_KEYWORD_FOR,
    TOKEN_KEYWORD_FORCE,
    TOKEN_KEYWORD_FOREIGN,
    TOKEN_KEYWORD_FOREIGN_KEY_LIST,
    TOKEN_KEYWORD_FORMAT,
    TOKEN_KEYWORD_FOUND,
    TOKEN_KEYWORD_FOUND_ROWS,
    TOKEN_KEYWORD_FROM,
    TOKEN_KEYWORD_FROM_BASE64,
    TOKEN_KEYWORD_FROM_DAYS,
    TOKEN_KEYWORD_FROM_UNIXTIME,
    TOKEN_KEYWORD_FULL,
    TOKEN_KEYWORD_FULLTEXT,
    TOKEN_KEYWORD_FUNCTION,
    TOKEN_KEYWORD_GENERAL,
    TOKEN_KEYWORD_GENERATED,
    TOKEN_KEYWORD_GEOMCOLLFROMTEXT,
    TOKEN_KEYWORD_GEOMCOLLFROMWKB,
    TOKEN_KEYWORD_GEOMETRY,
    TOKEN_KEYWORD_GEOMETRYCOLLECTION,
    TOKEN_KEYWORD_GEOMETRYCOLLECTIONFROMTEXT,
    TOKEN_KEYWORD_GEOMETRYCOLLECTIONFROMWKB,
    TOKEN_KEYWORD_GEOMETRYFROMTEXT,
    TOKEN_KEYWORD_GEOMETRYFROMWKB,
    TOKEN_KEYWORD_GEOMETRYN,
    TOKEN_KEYWORD_GEOMETRYTYPE,
    TOKEN_KEYWORD_GEOMFROMTEXT,
    TOKEN_KEYWORD_GEOMFROMWKB,
    TOKEN_KEYWORD_GET,
    TOKEN_KEYWORD_GET_FORMAT,
    TOKEN_KEYWORD_GET_LOCK,
    TOKEN_KEYWORD_GLENGTH,
    TOKEN_KEYWORD_GLOBAL,
    TOKEN_KEYWORD_GO,
    TOKEN_KEYWORD_GOTO,
    TOKEN_KEYWORD_GRANT,
    TOKEN_KEYWORD_GREATEST,
    TOKEN_KEYWORD_GROUP,
    TOKEN_KEYWORD_GROUPING,
    TOKEN_KEYWORD_GROUPS,
    TOKEN_KEYWORD_GROUP_CONCAT,
    TOKEN_KEYWORD_GROUP_REPLICATION_ADMIN,
    TOKEN_KEYWORD_GTID_SUBSET,
    TOKEN_KEYWORD_GTID_SUBTRACT,
    TOKEN_KEYWORD_HANDLER,
    TOKEN_KEYWORD_HAVING,
    TOKEN_KEYWORD_HELP,
    TOKEN_KEYWORD_HEX,
    TOKEN_KEYWORD_HIGH_PRIORITY,
    TOKEN_KEYWORD_HISTFILE,
    TOKEN_KEYWORD_HISTIGNORE,
    TOKEN_KEYWORD_HOST,

    TOKEN_KEYWORD_HOUR,
    TOKEN_KEYWORD_HOUR_MICROSECOND,
    TOKEN_KEYWORD_HOUR_MINUTE,
    TOKEN_KEYWORD_HOUR_SECOND,
        TOKEN_KEYWORD_HTML,
    TOKEN_KEYWORD_IDENTIFIER,
    TOKEN_KEYWORD_IF,
    TOKEN_KEYWORD_IFNULL,
    TOKEN_KEYWORD_IGNORE,
        TOKEN_KEYWORD_IGNORE_SPACES,
    TOKEN_KEYWORD_IMMEDIATE,
    TOKEN_KEYWORD_IMPORT,
    TOKEN_KEYWORD_IN,
    TOKEN_KEYWORD_INDEX,
    TOKEN_KEYWORD_INDEXED,
    TOKEN_KEYWORD_INDEX_INFO,
    TOKEN_KEYWORD_INDEX_LIST,
    TOKEN_KEYWORD_INET6_ATON,
    TOKEN_KEYWORD_INET6_NTOA,
    TOKEN_KEYWORD_INET_ATON,
    TOKEN_KEYWORD_INET_NTOA,
    TOKEN_KEYWORD_INFILE,
    TOKEN_KEYWORD_INITIALLY,
        TOKEN_KEYWORD_INIT_COMMAND,
    TOKEN_KEYWORD_INNER,
    TOKEN_KEYWORD_INOUT,
    TOKEN_KEYWORD_INSENSITIVE,
    TOKEN_KEYWORD_INSERT,
    TOKEN_KEYWORD_INSTALL,
    TOKEN_KEYWORD_INSTEAD,
    TOKEN_KEYWORD_INSTR,
    TOKEN_KEYWORD_INT,
    TOKEN_KEYWORD_INT1,
    TOKEN_KEYWORD_INT2,
    TOKEN_KEYWORD_INT3,
    TOKEN_KEYWORD_INT4,
    TOKEN_KEYWORD_INT8,
    TOKEN_KEYWORD_INTEGER,
    TOKEN_KEYWORD_INTERIORRINGN,
    TOKEN_KEYWORD_INTERSECT,
    TOKEN_KEYWORD_INTERSECTS,
    TOKEN_KEYWORD_INTERVAL,
    TOKEN_KEYWORD_INTO,
    TOKEN_KEYWORD_IO_AFTER_GTIDS,
    TOKEN_KEYWORD_IO_BEFORE_GTIDS,
    TOKEN_KEYWORD_IS,
    TOKEN_KEYWORD_ISCLOSED,
    TOKEN_KEYWORD_ISEMPTY,
    TOKEN_KEYWORD_ISNULL,
    TOKEN_KEYWORD_ISSIMPLE,
    TOKEN_KEYWORD_IS_FREE_LOCK,
    TOKEN_KEYWORD_IS_IPV4,
    TOKEN_KEYWORD_IS_IPV4_COMPAT,
    TOKEN_KEYWORD_IS_IPV4_MAPPED,
    TOKEN_KEYWORD_IS_IPV6,
    TOKEN_KEYWORD_IS_USED_LOCK,
    TOKEN_KEYWORD_ITERATE,
    TOKEN_KEYWORD_JOIN,
    TOKEN_KEYWORD_JSON,
    TOKEN_KEYWORD_JSON_APPEND,
    TOKEN_KEYWORD_JSON_ARRAY,
    TOKEN_KEYWORD_JSON_ARRAY_APPEND,
    TOKEN_KEYWORD_JSON_ARRAY_INSERT,
    TOKEN_KEYWORD_JSON_CONTAINS,
    TOKEN_KEYWORD_JSON_CONTAINS_PATH,
    TOKEN_KEYWORD_JSON_DEPTH,
    TOKEN_KEYWORD_JSON_EXTRACT,
    TOKEN_KEYWORD_JSON_INSERT,
    TOKEN_KEYWORD_JSON_KEYS,
    TOKEN_KEYWORD_JSON_LENGTH,
    TOKEN_KEYWORD_JSON_MERGE,
    TOKEN_KEYWORD_JSON_OBJECT,
    TOKEN_KEYWORD_JSON_QUERY,
    TOKEN_KEYWORD_JSON_QUOTE,
    TOKEN_KEYWORD_JSON_REMOVE,
    TOKEN_KEYWORD_JSON_REPLACE,
    TOKEN_KEYWORD_JSON_SEARCH,
    TOKEN_KEYWORD_JSON_SET,
    TOKEN_KEYWORD_JSON_TABLE,
    TOKEN_KEYWORD_JSON_TYPE,
    TOKEN_KEYWORD_JSON_UNQUOTE,
    TOKEN_KEYWORD_JSON_VALID,
    TOKEN_KEYWORD_JSON_VALUE,
    TOKEN_KEYWORD_JULIANDAY,
    TOKEN_KEYWORD_KEY,
    TOKEN_KEYWORD_KEYS,
    TOKEN_KEYWORD_KEYWORD,
    TOKEN_KEYWORD_KILL,
    TOKEN_KEYWORD_LAG,
    TOKEN_KEYWORD_LANGUAGE,
    TOKEN_KEYWORD_LAST,
    TOKEN_KEYWORD_LASTVAL,
    TOKEN_KEYWORD_LAST_DAY,
    TOKEN_KEYWORD_LAST_INSERT_ID,
    TOKEN_KEYWORD_LAST_VALUE,
    TOKEN_KEYWORD_LATERAL,
    TOKEN_KEYWORD_LCASE,
        TOKEN_KEYWORD_LD_RUN_PATH,
    TOKEN_KEYWORD_LEAD,
    TOKEN_KEYWORD_LEADING,
    TOKEN_KEYWORD_LEAST,
    TOKEN_KEYWORD_LEAVE,
    TOKEN_KEYWORD_LEFT,
    TOKEN_KEYWORD_LENGTH,
    TOKEN_KEYWORD_LEVEL,
    TOKEN_KEYWORD_LIKE,
    TOKEN_KEYWORD_LIMIT,
    TOKEN_KEYWORD_LINEAR,
    TOKEN_KEYWORD_LINEFROMTEXT,
    TOKEN_KEYWORD_LINEFROMWKB,
    TOKEN_KEYWORD_LINES,
    TOKEN_KEYWORD_LINESTRING,
    TOKEN_KEYWORD_LINESTRINGFROMTEXT,
    TOKEN_KEYWORD_LINESTRINGFROMWKB,
        TOKEN_KEYWORD_LINE_NUMBERS,
    TOKEN_KEYWORD_LITERAL,
    TOKEN_KEYWORD_LN,
    TOKEN_KEYWORD_LOAD,
    TOKEN_KEYWORD_LOAD_FILE,
    TOKEN_KEYWORD_LOCAL,
    TOKEN_KEYWORD_LOCALTIME,
    TOKEN_KEYWORD_LOCALTIMESTAMP,
        TOKEN_KEYWORD_LOCAL_INFILE,
    TOKEN_KEYWORD_LOCATE,
    TOKEN_KEYWORD_LOCK,
    TOKEN_KEYWORD_LOG,
    TOKEN_KEYWORD_LOG10,
    TOKEN_KEYWORD_LOG2,
    TOKEN_KEYWORD_LOGFILE,
        TOKEN_KEYWORD_LOGIN_PATH,
    TOKEN_KEYWORD_LONG,
    TOKEN_KEYWORD_LONGBLOB,
    TOKEN_KEYWORD_LONGTEXT,
    TOKEN_KEYWORD_LOOP,
    TOKEN_KEYWORD_LOWER,
    TOKEN_KEYWORD_LOW_PRIORITY,
    TOKEN_KEYWORD_LPAD,
    TOKEN_KEYWORD_LTRIM,
    TOKEN_KEYWORD_LUA,
    TOKEN_KEYWORD_MAKEDATE,
    TOKEN_KEYWORD_MAKETIME,
    TOKEN_KEYWORD_MAKE_SET,
    TOKEN_KEYWORD_MAP,
    TOKEN_KEYWORD_MASTER_BIND,
    TOKEN_KEYWORD_MASTER_HEARTBEAT_PERIOD,
    TOKEN_KEYWORD_MASTER_POS_WAIT,
    TOKEN_KEYWORD_MASTER_SSL_VERIFY_SERVER_CERT,
    TOKEN_KEYWORD_MATCH,
    TOKEN_KEYWORD_MAX,
    TOKEN_KEYWORD_MAXVALUE,
        TOKEN_KEYWORD_MAX_ALLOWED_PACKET,
        TOKEN_KEYWORD_MAX_JOIN_SIZE,
    TOKEN_KEYWORD_MBRCONTAINS,
    TOKEN_KEYWORD_MBRCOVEREDBY,
    TOKEN_KEYWORD_MBRCOVERS,
    TOKEN_KEYWORD_MBRDISJOINT,
    TOKEN_KEYWORD_MBREQUAL,
    TOKEN_KEYWORD_MBREQUALS,
    TOKEN_KEYWORD_MBRINTERSECTS,
    TOKEN_KEYWORD_MBROVERLAPS,
    TOKEN_KEYWORD_MBRTOUCHES,
    TOKEN_KEYWORD_MBRWITHIN,
    TOKEN_KEYWORD_MD5,
    TOKEN_KEYWORD_MEDIAN,
    TOKEN_KEYWORD_MEDIUMBLOB,
    TOKEN_KEYWORD_MEDIUMINT,
    TOKEN_KEYWORD_MEDIUMTEXT,
    TOKEN_KEYWORD_MICROSECOND,
    TOKEN_KEYWORD_MID,
    TOKEN_KEYWORD_MIDDLEINT,
    TOKEN_KEYWORD_MIN,
    TOKEN_KEYWORD_MINUTE,
    TOKEN_KEYWORD_MINUTE_MICROSECOND,
    TOKEN_KEYWORD_MINUTE_SECOND,
    TOKEN_KEYWORD_MINVALUE,
    TOKEN_KEYWORD_MLINEFROMTEXT,
    TOKEN_KEYWORD_MLINEFROMWKB,
    TOKEN_KEYWORD_MOD,
    TOKEN_KEYWORD_MODE,
    TOKEN_KEYWORD_MODIFIES,
    TOKEN_KEYWORD_MONTH,
    TOKEN_KEYWORD_MONTHNAME,
    TOKEN_KEYWORD_MPOINTFROMTEXT,
    TOKEN_KEYWORD_MPOINTFROMWKB,
    TOKEN_KEYWORD_MPOLYFROMTEXT,
    TOKEN_KEYWORD_MPOLYFROMWKB,
    TOKEN_KEYWORD_MULTILINESTRING,
    TOKEN_KEYWORD_MULTILINESTRINGFROMTEXT,
    TOKEN_KEYWORD_MULTILINESTRINGFROMWKB,
    TOKEN_KEYWORD_MULTIPOINT,
    TOKEN_KEYWORD_MULTIPOINTFROMTEXT,
    TOKEN_KEYWORD_MULTIPOINTFROMWKB,
    TOKEN_KEYWORD_MULTIPOLYGON,
    TOKEN_KEYWORD_MULTIPOLYGONFROMTEXT,
    TOKEN_KEYWORD_MULTIPOLYGONFROMWKB,
        TOKEN_KEYWORD_NAMED_COMMANDS,
    TOKEN_KEYWORD_NAMES,
    TOKEN_KEYWORD_NAME_CONST,
    TOKEN_KEYWORD_NATURAL,
    TOKEN_KEYWORD_NCHAR,
        TOKEN_KEYWORD_NET_BUFFER_LENGTH,
    TOKEN_KEYWORD_NEWLINE,
    TOKEN_KEYWORD_NEXTVAL,
    TOKEN_KEYWORD_NIL,
    TOKEN_KEYWORD_NO,
    TOKEN_KEYWORD_NOPAGER,
    TOKEN_KEYWORD_NOT,
    TOKEN_KEYWORD_NOTEE,
    TOKEN_KEYWORD_NOTNULL,
    TOKEN_KEYWORD_NOW,
    TOKEN_KEYWORD_NOWARNING,
        TOKEN_KEYWORD_NO_AUTO_REHASH,
        TOKEN_KEYWORD_NO_BEEP,
    TOKEN_KEYWORD_NO_DEFAULTS,
    TOKEN_KEYWORD_NO_NAMED_COMMANDS,
    TOKEN_KEYWORD_NO_TEE,
    TOKEN_KEYWORD_NO_WRITE_TO_BINLOG,
    TOKEN_KEYWORD_NTH_VALUE,
    TOKEN_KEYWORD_NTILE,
    TOKEN_KEYWORD_NULL,
    TOKEN_KEYWORD_NULLIF,
    TOKEN_KEYWORD_NULLS,
    TOKEN_KEYWORD_NUM,
    TOKEN_KEYWORD_NUMBER,
    TOKEN_KEYWORD_NUMERIC,
    TOKEN_KEYWORD_NUMGEOMETRIES,
    TOKEN_KEYWORD_NUMINTERIORRINGS,
    TOKEN_KEYWORD_NUMPOINTS,
    TOKEN_KEYWORD_NVARCHAR2,
    TOKEN_KEYWORD_OCELOT_BATCH,
    TOKEN_KEYWORD_OCELOT_CLIENT_SIDE_FUNCTIONS,
    TOKEN_KEYWORD_OCELOT_COMPLETER_TIMEOUT,
        TOKEN_KEYWORD_OCELOT_DBMS,
    TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED,
    TOKEN_KEYWORD_OCELOT_DEBUG_HEIGHT,
    TOKEN_KEYWORD_OCELOT_DEBUG_LEFT,
    TOKEN_KEYWORD_OCELOT_DEBUG_TOP,
    TOKEN_KEYWORD_OCELOT_DEBUG_WIDTH,
    TOKEN_KEYWORD_OCELOT_EXPORT, /* if OCELOT_IMPORT_EXPORT == 1 */
    TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_CONDITION,
    TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_DISPLAY_AS,
    TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_TEXT_COLOR,
    TOKEN_KEYWORD_OCELOT_GRID_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_GRID_BORDER_SIZE, /* no longer used */
    TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_COLOR,
    TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_SIZE,
    TOKEN_KEYWORD_OCELOT_GRID_CELL_HEIGHT,
    TOKEN_KEYWORD_OCELOT_GRID_CELL_WIDTH,
    TOKEN_KEYWORD_OCELOT_GRID_DETACHED,
    TOKEN_KEYWORD_OCELOT_GRID_FOCUS_CELL_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_GRID_FONT_FAMILY,
    TOKEN_KEYWORD_OCELOT_GRID_FONT_SIZE,
    TOKEN_KEYWORD_OCELOT_GRID_FONT_STYLE,
    TOKEN_KEYWORD_OCELOT_GRID_FONT_WEIGHT,
    TOKEN_KEYWORD_OCELOT_GRID_HEADER_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_GRID_HEIGHT,
    TOKEN_KEYWORD_OCELOT_GRID_HTML_EFFECTS,
    TOKEN_KEYWORD_OCELOT_GRID_LEFT,
    TOKEN_KEYWORD_OCELOT_GRID_OUTER_COLOR,
    TOKEN_KEYWORD_OCELOT_GRID_TABS,
    TOKEN_KEYWORD_OCELOT_GRID_TEXT_COLOR,
    TOKEN_KEYWORD_OCELOT_GRID_TOOLTIP,
    TOKEN_KEYWORD_OCELOT_GRID_TOP,
    TOKEN_KEYWORD_OCELOT_GRID_WIDTH,
    TOKEN_KEYWORD_OCELOT_HISTFILEFLAGS,
    TOKEN_KEYWORD_OCELOT_HISTFILESIZE,
    TOKEN_KEYWORD_OCELOT_HISTORY_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_HISTORY_BORDER_COLOR,
    TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED,
    TOKEN_KEYWORD_OCELOT_HISTORY_FONT_FAMILY,
    TOKEN_KEYWORD_OCELOT_HISTORY_FONT_SIZE,
    TOKEN_KEYWORD_OCELOT_HISTORY_FONT_STYLE,
    TOKEN_KEYWORD_OCELOT_HISTORY_FONT_WEIGHT,
    TOKEN_KEYWORD_OCELOT_HISTORY_HEIGHT,
    TOKEN_KEYWORD_OCELOT_HISTORY_LEFT,
    TOKEN_KEYWORD_OCELOT_HISTORY_MAX_ROW_COUNT,
    TOKEN_KEYWORD_OCELOT_HISTORY_TEXT_COLOR,
    TOKEN_KEYWORD_OCELOT_HISTORY_TOP,
    TOKEN_KEYWORD_OCELOT_HISTORY_WIDTH,
    TOKEN_KEYWORD_OCELOT_HISTSIZE,
    TOKEN_KEYWORD_OCELOT_HORIZONTAL,
    TOKEN_KEYWORD_OCELOT_HTML,
    TOKEN_KEYWORD_OCELOT_HTMLRAW,
    TOKEN_KEYWORD_OCELOT_IMPORT, /* if OCELOT_IMPORT_EXPORT == 1 */
    TOKEN_KEYWORD_OCELOT_LANGUAGE,
    TOKEN_KEYWORD_OCELOT_LOG_LEVEL,
    TOKEN_KEYWORD_OCELOT_MENU_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_MENU_BORDER_COLOR,
    TOKEN_KEYWORD_OCELOT_MENU_FONT_FAMILY,
    TOKEN_KEYWORD_OCELOT_MENU_FONT_SIZE,
    TOKEN_KEYWORD_OCELOT_MENU_FONT_STYLE,
    TOKEN_KEYWORD_OCELOT_MENU_FONT_WEIGHT,
    TOKEN_KEYWORD_OCELOT_MENU_TEXT_COLOR,
    TOKEN_KEYWORD_OCELOT_RAW,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_AUTOCOMPLETE,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_BATCH,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_BREAKPOINT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_CLEAR,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_CONNECT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_CONTINUE,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_COPY,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_CUT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_DEBUG_EXIT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_EXECUTE,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_EXIT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_FIND,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_FORMAT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_NEXT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_PREVIOUS,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_HORIZONTAL,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_HTML,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_HTMLRAW,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_INFORMATION,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_KILL,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT_WINDOW,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_PASTE,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_PREVIOUS_WINDOW,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_RAW,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_REDO,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_CALL_STACK,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_SERVER_VARIABLES,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_USER_VARIABLES,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_VARIABLES,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_SELECT_ALL,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_STEP,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_UNDO,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_VERTICAL,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_XML,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMIN,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMOUT,
    TOKEN_KEYWORD_OCELOT_STATEMENT_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_BORDER_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED,
    TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_FAMILY,
    TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_SIZE,
    TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_STYLE,
    TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_WEIGHT,
    TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_CLAUSE_INDENT,
    TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_RULE,
    TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_STATEMENT_INDENT,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HEIGHT,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_COMMENT_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_FUNCTION_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_IDENTIFIER_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_KEYWORD_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_LITERAL_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_OPERATOR_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_LEFT,
    TOKEN_KEYWORD_OCELOT_STATEMENT_PROMPT_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_SYNTAX_CHECKER,
    TOKEN_KEYWORD_OCELOT_STATEMENT_TEXT_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_TOP,
    TOKEN_KEYWORD_OCELOT_STATEMENT_WIDTH,
    TOKEN_KEYWORD_OCELOT_VERTICAL,
    TOKEN_KEYWORD_OCELOT_XML,
    TOKEN_KEYWORD_OCT,
    TOKEN_KEYWORD_OCTET_LENGTH,
    TOKEN_KEYWORD_OF,
    TOKEN_KEYWORD_OFF,
    TOKEN_KEYWORD_OFFSET,
    TOKEN_KEYWORD_OJ,
    TOKEN_KEYWORD_OLD_PASSWORD,
    TOKEN_KEYWORD_ON,
        TOKEN_KEYWORD_ONE_DATABASE,
    TOKEN_KEYWORD_OPEN,
    TOKEN_KEYWORD_OPERATOR,
    TOKEN_KEYWORD_OPTIMIZE,
    TOKEN_KEYWORD_OPTIMIZER_COSTS,
    TOKEN_KEYWORD_OPTION,
    TOKEN_KEYWORD_OPTIONALLY,
    TOKEN_KEYWORD_OR,
    TOKEN_KEYWORD_ORD,
    TOKEN_KEYWORD_ORDER,
    TOKEN_KEYWORD_OUT,
    TOKEN_KEYWORD_OUTER,
    TOKEN_KEYWORD_OUTFILE,
    TOKEN_KEYWORD_OVER,
    TOKEN_KEYWORD_OVERLAPS,
    TOKEN_KEYWORD_PACKAGE,
    TOKEN_KEYWORD_PAGER,
    TOKEN_KEYWORD_PARSER_TRACE,
    TOKEN_KEYWORD_PARTIAL,
    TOKEN_KEYWORD_PARTITION,
    TOKEN_KEYWORD_PASSWORD,
    TOKEN_KEYWORD_PERCENTILE_CONT,
    TOKEN_KEYWORD_PERCENTILE_DISC,
    TOKEN_KEYWORD_PERCENT_RANK,
    TOKEN_KEYWORD_PERIOD_ADD,
    TOKEN_KEYWORD_PERIOD_DIFF,
    TOKEN_KEYWORD_PERSIST,
    TOKEN_KEYWORD_PERSIST_ONLY,
    TOKEN_KEYWORD_PERSIST_RO_VARIABLES_ADMIN,
    TOKEN_KEYWORD_PI,
    TOKEN_KEYWORD_PIPE,
    TOKEN_KEYWORD_PLAN,
        TOKEN_KEYWORD_PLUGIN_DIR,
    TOKEN_KEYWORD_POINT,
    TOKEN_KEYWORD_POINTFROMTEXT,
    TOKEN_KEYWORD_POINTFROMWKB,
    TOKEN_KEYWORD_POINTN,
    TOKEN_KEYWORD_POLYFROMTEXT,
    TOKEN_KEYWORD_POLYFROMWKB,
    TOKEN_KEYWORD_POLYGON,
    TOKEN_KEYWORD_POLYGONFROMTEXT,
    TOKEN_KEYWORD_POLYGONFROMWKB,
        TOKEN_KEYWORD_PORT,
    TOKEN_KEYWORD_POSITION,
    TOKEN_KEYWORD_POW,
    TOKEN_KEYWORD_POWER,
    TOKEN_KEYWORD_PRAGMA,
    TOKEN_KEYWORD_PRECEDES,
    TOKEN_KEYWORD_PRECISION,
    TOKEN_KEYWORD_PREPARE,
    TOKEN_KEYWORD_PRIMARY,
    TOKEN_KEYWORD_PRINT,
    TOKEN_KEYWORD_PRINTF,
        TOKEN_KEYWORD_PRINT_DEFAULTS,
    TOKEN_KEYWORD_PROCEDURE,
    TOKEN_KEYWORD_PROCESS,
    TOKEN_KEYWORD_PROMPT,
        TOKEN_KEYWORD_PROTOCOL,
    TOKEN_KEYWORD_PROXY,
    TOKEN_KEYWORD_PURGE,
    TOKEN_KEYWORD_QUARTER,
    TOKEN_KEYWORD_QUERY,
        TOKEN_KEYWORD_QUICK,
    TOKEN_KEYWORD_QUIT,
    TOKEN_KEYWORD_QUOTE,
    TOKEN_KEYWORD_RADIANS,
    TOKEN_KEYWORD_RAISE,
    TOKEN_KEYWORD_RAND,
    TOKEN_KEYWORD_RANDOM,
    TOKEN_KEYWORD_RANDOMBLOB,
    TOKEN_KEYWORD_RANDOM_BYTES,
    TOKEN_KEYWORD_RANGE,
    TOKEN_KEYWORD_RANK,
    TOKEN_KEYWORD_RAW,
    TOKEN_KEYWORD_READ,
    TOKEN_KEYWORD_READS,
    TOKEN_KEYWORD_READ_DEFAULT_FILE,
    TOKEN_KEYWORD_READ_DEFAULT_GROUP,
    TOKEN_KEYWORD_READ_TIMEOUT,
    TOKEN_KEYWORD_READ_WRITE,
    TOKEN_KEYWORD_REAL,
    TOKEN_KEYWORD_REBUILD,
        TOKEN_KEYWORD_RECONNECT,
    TOKEN_KEYWORD_RECURSIVE,
    TOKEN_KEYWORD_REDOFILE,
    TOKEN_KEYWORD_REDUNDANT,
    TOKEN_KEYWORD_REFERENCES,
    TOKEN_KEYWORD_REGEXP,
    TOKEN_KEYWORD_REHASH,
    TOKEN_KEYWORD_RELEASE,
    TOKEN_KEYWORD_RELEASE_ALL_LOCKS,
    TOKEN_KEYWORD_RELEASE_LOCK,
    TOKEN_KEYWORD_RELOAD,
    TOKEN_KEYWORD_RENAME,
    TOKEN_KEYWORD_REORGANIZE,
    TOKEN_KEYWORD_REPAIR,
    TOKEN_KEYWORD_REPEAT,
    TOKEN_KEYWORD_REPLACE,
    TOKEN_KEYWORD_REPLICATION,
    TOKEN_KEYWORD_REPLICATION_SLAVE_ADMIN,
        TOKEN_KEYWORD_REPORT_DATA_TRUNCATION,
    TOKEN_KEYWORD_REQUIRE,
    TOKEN_KEYWORD_RESET,
    TOKEN_KEYWORD_RESETCONNECTION,
    TOKEN_KEYWORD_RESIGNAL,
    TOKEN_KEYWORD_RESOURCE_GROUP_ADMIN,
    TOKEN_KEYWORD_RESOURCE_GROUP_USER,
    TOKEN_KEYWORD_RESTRICT,
    TOKEN_KEYWORD_RETURN,
    TOKEN_KEYWORD_RETURNS,
    TOKEN_KEYWORD_REVERSE,
    TOKEN_KEYWORD_REVOKE,
    TOKEN_KEYWORD_RIGHT,
    TOKEN_KEYWORD_RLIKE,
    TOKEN_KEYWORD_ROLE,
    TOKEN_KEYWORD_ROLE_ADMIN,
    TOKEN_KEYWORD_ROLLBACK,
    TOKEN_KEYWORD_ROUND,
    TOKEN_KEYWORD_ROW,
    TOKEN_KEYWORD_ROWS,
    TOKEN_KEYWORD_ROWTYPE,
    TOKEN_KEYWORD_ROW_COUNT,
    TOKEN_KEYWORD_ROW_NUMBER,
    TOKEN_KEYWORD_RPAD,
    TOKEN_KEYWORD_RTRIM,
        TOKEN_KEYWORD_SAFE_UPDATES,
    TOKEN_KEYWORD_SAVEPOINT,
    TOKEN_KEYWORD_SCALAR,
    TOKEN_KEYWORD_SCHEMA,
    TOKEN_KEYWORD_SCHEMAS,
    TOKEN_KEYWORD_SECOND,
    TOKEN_KEYWORD_SECOND_MICROSECOND,
        TOKEN_KEYWORD_SECURE_AUTH,
    TOKEN_KEYWORD_SECURITY,
    TOKEN_KEYWORD_SEC_TO_TIME,
    TOKEN_KEYWORD_SELECT,
        TOKEN_KEYWORD_SELECT_LIMIT,
    TOKEN_KEYWORD_SEMICOLON,
    TOKEN_KEYWORD_SENSITIVE,
    TOKEN_KEYWORD_SEPARATOR,
    TOKEN_KEYWORD_SEQUENCE,
    TOKEN_KEYWORD_SERIAL,
    TOKEN_KEYWORD_SERVER,
        TOKEN_KEYWORD_SERVER_PUBLIC_KEY,
    TOKEN_KEYWORD_SESSION,
    TOKEN_KEYWORD_SESSION_USER,
    TOKEN_KEYWORD_SET,
    TOKEN_KEYWORD_SETVAL,
    TOKEN_KEYWORD_SET_USER_ID,
    TOKEN_KEYWORD_SHA,
    TOKEN_KEYWORD_SHA1,
    TOKEN_KEYWORD_SHA2,
    TOKEN_KEYWORD_SHARED,
        TOKEN_KEYWORD_SHARED_MEMORY_BASE_NAME,
    TOKEN_KEYWORD_SHOW,
        TOKEN_KEYWORD_SHOW_WARNINGS,
    TOKEN_KEYWORD_SHUTDOWN,
        TOKEN_KEYWORD_SIGINT_IGNORE,
    TOKEN_KEYWORD_SIGN,
    TOKEN_KEYWORD_SIGNAL,
    TOKEN_KEYWORD_SIGNED,
        TOKEN_KEYWORD_SILENT,
    TOKEN_KEYWORD_SIMPLE,
    TOKEN_KEYWORD_SIN,
    TOKEN_KEYWORD_SLEEP,
    TOKEN_KEYWORD_SLOW,
    TOKEN_KEYWORD_SMALLINT,
        TOKEN_KEYWORD_SOCKET,
    TOKEN_KEYWORD_SONAME,
    TOKEN_KEYWORD_SOUNDEX,
    TOKEN_KEYWORD_SOURCE,
    TOKEN_KEYWORD_SPACE,
    TOKEN_KEYWORD_SPATIAL,
    TOKEN_KEYWORD_SPECIFIC,
    TOKEN_KEYWORD_SQL,
    TOKEN_KEYWORD_SQLEXCEPTION,
    TOKEN_KEYWORD_SQLSTATE,
    TOKEN_KEYWORD_SQLWARNING,
    TOKEN_KEYWORD_SQL_BIG_RESULT,
    TOKEN_KEYWORD_SQL_CALC_FOUND_ROWS,
    TOKEN_KEYWORD_SQL_COMPOUND_SELECT_LIMIT,
    TOKEN_KEYWORD_SQL_DEFAULT_ENGINE,
    TOKEN_KEYWORD_SQL_SMALL_RESULT,
    TOKEN_KEYWORD_SQRT,
    TOKEN_KEYWORD_SRID,
    TOKEN_KEYWORD_SSL,
    TOKEN_KEYWORD_SSL_CA,
    TOKEN_KEYWORD_SSL_CAPATH,
    TOKEN_KEYWORD_SSL_CERT,
    TOKEN_KEYWORD_SSL_CIPHER,
    TOKEN_KEYWORD_SSL_CRL,
    TOKEN_KEYWORD_SSL_CRLPATH,
    TOKEN_KEYWORD_SSL_KEY,
    TOKEN_KEYWORD_SSL_MODE,
    TOKEN_KEYWORD_SSL_VERIFY,
    TOKEN_KEYWORD_SSL_VERIFY_SERVER_CERT,
    TOKEN_KEYWORD_START,
    TOKEN_KEYWORD_STARTING,
    TOKEN_KEYWORD_STARTPOINT,
    TOKEN_KEYWORD_STATEMENT,
    TOKEN_KEYWORD_STATS,
    TOKEN_KEYWORD_STATUS,
    TOKEN_KEYWORD_STD,
    TOKEN_KEYWORD_STDDEV,
    TOKEN_KEYWORD_STDDEV_POP,
    TOKEN_KEYWORD_STDDEV_SAMP,
    TOKEN_KEYWORD_STDOUT,
    TOKEN_KEYWORD_STOP,
    TOKEN_KEYWORD_STORED,
    TOKEN_KEYWORD_STRAIGHT_JOIN,
    TOKEN_KEYWORD_STRCMP,
    TOKEN_KEYWORD_STRFTIME,
    TOKEN_KEYWORD_STRING,
    TOKEN_KEYWORD_STR_TO_DATE,
    TOKEN_KEYWORD_ST_AREA,
    TOKEN_KEYWORD_ST_ASBINARY,
    TOKEN_KEYWORD_ST_ASGEOJSON,
    TOKEN_KEYWORD_ST_ASTEXT,
    TOKEN_KEYWORD_ST_ASWKB,
    TOKEN_KEYWORD_ST_ASWKT,
    TOKEN_KEYWORD_ST_BUFFER,
    TOKEN_KEYWORD_ST_BUFFER_STRATEGY,
    TOKEN_KEYWORD_ST_CENTROID,
    TOKEN_KEYWORD_ST_CONTAINS,
    TOKEN_KEYWORD_ST_CONVEXHULL,
    TOKEN_KEYWORD_ST_CROSSES,
    TOKEN_KEYWORD_ST_DIFFERENCE,
    TOKEN_KEYWORD_ST_DIMENSION,
    TOKEN_KEYWORD_ST_DISJOINT,
    TOKEN_KEYWORD_ST_DISTANCE,
    TOKEN_KEYWORD_ST_DISTANCE_SPHERE,
    TOKEN_KEYWORD_ST_ENDPOINT,
    TOKEN_KEYWORD_ST_ENVELOPE,
    TOKEN_KEYWORD_ST_EQUALS,
    TOKEN_KEYWORD_ST_EXTERIORRING,
    TOKEN_KEYWORD_ST_GEOHASH,
    TOKEN_KEYWORD_ST_GEOMCOLLFROMTEXT,
    TOKEN_KEYWORD_ST_GEOMCOLLFROMTXT,
    TOKEN_KEYWORD_ST_GEOMCOLLFROMWKB,
    TOKEN_KEYWORD_ST_GEOMETRYCOLLECTIONFROMTEXT,
    TOKEN_KEYWORD_ST_GEOMETRYCOLLECTIONFROMWKB,
    TOKEN_KEYWORD_ST_GEOMETRYFROMTEXT,
    TOKEN_KEYWORD_ST_GEOMETRYFROMWKB,
    TOKEN_KEYWORD_ST_GEOMETRYN,
    TOKEN_KEYWORD_ST_GEOMETRYTYPE,
    TOKEN_KEYWORD_ST_GEOMFROMGEOJSON,
    TOKEN_KEYWORD_ST_GEOMFROMTEXT,
    TOKEN_KEYWORD_ST_GEOMFROMWKB,
    TOKEN_KEYWORD_ST_INTERIORRINGN,
    TOKEN_KEYWORD_ST_INTERSECTION,
    TOKEN_KEYWORD_ST_INTERSECTS,
    TOKEN_KEYWORD_ST_ISCLOSED,
    TOKEN_KEYWORD_ST_ISEMPTY,
    TOKEN_KEYWORD_ST_ISSIMPLE,
    TOKEN_KEYWORD_ST_ISVALID,
    TOKEN_KEYWORD_ST_LATFROMGEOHASH,
    TOKEN_KEYWORD_ST_LENGTH,
    TOKEN_KEYWORD_ST_LINEFROMTEXT,
    TOKEN_KEYWORD_ST_LINEFROMWKB,
    TOKEN_KEYWORD_ST_LINESTRINGFROMTEXT,
    TOKEN_KEYWORD_ST_LINESTRINGFROMWKB,
    TOKEN_KEYWORD_ST_LONGFROMGEOHASH,
    TOKEN_KEYWORD_ST_MAKEENVELOPE,
    TOKEN_KEYWORD_ST_MLINEFROMTEXT,
    TOKEN_KEYWORD_ST_MLINEFROMWKB,
    TOKEN_KEYWORD_ST_MPOINTFROMTEXT,
    TOKEN_KEYWORD_ST_MPOINTFROMWKB,
    TOKEN_KEYWORD_ST_MPOLYFROMTEXT,
    TOKEN_KEYWORD_ST_MPOLYFROMWKB,
    TOKEN_KEYWORD_ST_MULTILINESTRINGFROMTEXT,
    TOKEN_KEYWORD_ST_MULTILINESTRINGFROMWKB,
    TOKEN_KEYWORD_ST_MULTIPOINTFROMTEXT,
    TOKEN_KEYWORD_ST_MULTIPOINTFROMWKB,
    TOKEN_KEYWORD_ST_MULTIPOLYGONFROMTEXT,
    TOKEN_KEYWORD_ST_MULTIPOLYGONFROMWKB,
    TOKEN_KEYWORD_ST_NUMGEOMETRIES,
    TOKEN_KEYWORD_ST_NUMINTERIORRING,
    TOKEN_KEYWORD_ST_NUMINTERIORRINGS,
    TOKEN_KEYWORD_ST_NUMPOINTS,
    TOKEN_KEYWORD_ST_OVERLAPS,
    TOKEN_KEYWORD_ST_POINTFROMGEOHASH,
    TOKEN_KEYWORD_ST_POINTFROMTEXT,
    TOKEN_KEYWORD_ST_POINTFROMWKB,
    TOKEN_KEYWORD_ST_POINTN,
    TOKEN_KEYWORD_ST_POLYFROMTEXT,
    TOKEN_KEYWORD_ST_POLYFROMWKB,
    TOKEN_KEYWORD_ST_POLYGONFROMTEXT,
    TOKEN_KEYWORD_ST_POLYGONFROMWKB,
    TOKEN_KEYWORD_ST_SIMPLIFY,
    TOKEN_KEYWORD_ST_SRID,
    TOKEN_KEYWORD_ST_STARTPOINT,
    TOKEN_KEYWORD_ST_SYMDIFFERENCE,
    TOKEN_KEYWORD_ST_TOUCHES,
    TOKEN_KEYWORD_ST_UNION,
    TOKEN_KEYWORD_ST_VALIDATE,
    TOKEN_KEYWORD_ST_WITHIN,
    TOKEN_KEYWORD_ST_X,
    TOKEN_KEYWORD_ST_Y,
    TOKEN_KEYWORD_SUBDATE,
    TOKEN_KEYWORD_SUBSTR,
    TOKEN_KEYWORD_SUBSTRING,
    TOKEN_KEYWORD_SUBSTRING_INDEX,
    TOKEN_KEYWORD_SUBTIME,
    TOKEN_KEYWORD_SUM,
    TOKEN_KEYWORD_SUPER,
    TOKEN_KEYWORD_SYSDATE,
        TOKEN_KEYWORD_SYSLOG,
    TOKEN_KEYWORD_SYSTEM,
    TOKEN_KEYWORD_SYSTEM_USER,
    TOKEN_KEYWORD_SYSTEM_VARIABLES_ADMIN,
    TOKEN_KEYWORD_TAB,
    TOKEN_KEYWORD_TABLE,
    TOKEN_KEYWORD_TABLESPACE,
    TOKEN_KEYWORD_TABLE_INFO,
    TOKEN_KEYWORD_TAN,
    TOKEN_KEYWORD_TEE,
    TOKEN_KEYWORD_TEMP,
    TOKEN_KEYWORD_TEMPORARY,
    TOKEN_KEYWORD_TERMINATED,
    TOKEN_KEYWORD_TEXT,
    TOKEN_KEYWORD_THEN,
    TOKEN_KEYWORD_TIME,
    TOKEN_KEYWORD_TIMEDIFF,
    TOKEN_KEYWORD_TIMESTAMP,
    TOKEN_KEYWORD_TIMESTAMPADD,
    TOKEN_KEYWORD_TIMESTAMPDIFF,
    TOKEN_KEYWORD_TIME_FORMAT,
    TOKEN_KEYWORD_TIME_TO_SEC,
    TOKEN_KEYWORD_TINYBLOB,
    TOKEN_KEYWORD_TINYINT,
    TOKEN_KEYWORD_TINYTEXT,
    TOKEN_KEYWORD_TO,
    TOKEN_KEYWORD_TOUCHES,
    TOKEN_KEYWORD_TO_BASE64,
    TOKEN_KEYWORD_TO_DAYS,
    TOKEN_KEYWORD_TO_SECONDS,
    TOKEN_KEYWORD_TRAILING,
    TOKEN_KEYWORD_TRANSACTION,
    TOKEN_KEYWORD_TRIGGER,
    TOKEN_KEYWORD_TRIM,
    TOKEN_KEYWORD_TRUE,
    TOKEN_KEYWORD_TRUNCATE,
    TOKEN_KEYWORD_TYPE,
    TOKEN_KEYWORD_TYPEOF,
    TOKEN_KEYWORD_UCASE,
    TOKEN_KEYWORD_UNBOUNDED,
        TOKEN_KEYWORD_UNBUFFERED,
    TOKEN_KEYWORD_UNCOMPRESS,
    TOKEN_KEYWORD_UNCOMPRESSED_LENGTH,
    TOKEN_KEYWORD_UNDO,
    TOKEN_KEYWORD_UNHEX,
    TOKEN_KEYWORD_UNICODE,
    TOKEN_KEYWORD_UNINSTALL,
    TOKEN_KEYWORD_UNION,
    TOKEN_KEYWORD_UNIQUE,
    TOKEN_KEYWORD_UNIX_TIMESTAMP,
    TOKEN_KEYWORD_UNKNOWN,
    TOKEN_KEYWORD_UNLOCK,
    TOKEN_KEYWORD_UNSIGNED,
    TOKEN_KEYWORD_UNTIL,
    TOKEN_KEYWORD_UPDATE,
    TOKEN_KEYWORD_UPDATEXML,
    TOKEN_KEYWORD_UPPER,
    TOKEN_KEYWORD_USAGE,
    TOKEN_KEYWORD_USE,
    TOKEN_KEYWORD_USER,
        TOKEN_KEYWORD_USE_RESULT,
    TOKEN_KEYWORD_USING,
    TOKEN_KEYWORD_UTC_DATE,
    TOKEN_KEYWORD_UTC_TIME,
    TOKEN_KEYWORD_UTC_TIMESTAMP,
    TOKEN_KEYWORD_UUID,
    TOKEN_KEYWORD_UUID_SHORT,
    TOKEN_KEYWORD_VACUUM,
    TOKEN_KEYWORD_VALIDATE_PASSWORD_STRENGTH,
    TOKEN_KEYWORD_VALIDATION,
    TOKEN_KEYWORD_VALUE,
    TOKEN_KEYWORD_VALUES,
    TOKEN_KEYWORD_VARBINARY,
    TOKEN_KEYWORD_VARCHAR,
    TOKEN_KEYWORD_VARCHAR2,
    TOKEN_KEYWORD_VARCHARACTER,
    TOKEN_KEYWORD_VARIANCE,
    TOKEN_KEYWORD_VARYING,
    TOKEN_KEYWORD_VAR_POP,
    TOKEN_KEYWORD_VAR_SAMP,
        TOKEN_KEYWORD_VERBOSE,
    TOKEN_KEYWORD_VERSION,
    TOKEN_KEYWORD_VERSION_TOKEN_ADMIN,
        TOKEN_KEYWORD_VERTICAL,
    TOKEN_KEYWORD_VIEW,
    TOKEN_KEYWORD_VIRTUAL,
        TOKEN_KEYWORD_WAIT,
    TOKEN_KEYWORD_WAIT_FOR_EXECUTED_GTID_SET,
    TOKEN_KEYWORD_WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS,
    TOKEN_KEYWORD_WARNINGS,
    TOKEN_KEYWORD_WEEK,
    TOKEN_KEYWORD_WEEKDAY,
    TOKEN_KEYWORD_WEEKOFYEAR,
    TOKEN_KEYWORD_WEIGHT_STRING,
    TOKEN_KEYWORD_WHEN,
    TOKEN_KEYWORD_WHENEVER,
    TOKEN_KEYWORD_WHERE,
    TOKEN_KEYWORD_WHILE,
    TOKEN_KEYWORD_WINDOW,
    TOKEN_KEYWORD_WITH,
    TOKEN_KEYWORD_WITHIN,
    TOKEN_KEYWORD_WITHOUT,
    TOKEN_KEYWORD_WRITE,
        TOKEN_KEYWORD_WRITE_TIMEOUT,
    TOKEN_KEYWORD_X,
    TOKEN_KEYWORD_XA,
    TOKEN_KEYWORD_XA_RECOVER_ADMIN,
        TOKEN_KEYWORD_XML,
    TOKEN_KEYWORD_XOR,
    TOKEN_KEYWORD_Y,
    TOKEN_KEYWORD_YEAR,
    TOKEN_KEYWORD_YEARWEEK,
    TOKEN_KEYWORD_YEAR_MONTH,
    TOKEN_KEYWORD_ZEROFILL,
    TOKEN_KEYWORD__ARMSCII8,
    TOKEN_KEYWORD__ASCII,
    TOKEN_KEYWORD__BIG5,
    TOKEN_KEYWORD__BINARY,
    TOKEN_KEYWORD__CP1250,
    TOKEN_KEYWORD__CP1251,
    TOKEN_KEYWORD__CP1256,
    TOKEN_KEYWORD__CP1257,
    TOKEN_KEYWORD__CP850,
    TOKEN_KEYWORD__CP852,
    TOKEN_KEYWORD__CP866,
    TOKEN_KEYWORD__CP932,
    TOKEN_KEYWORD__DEC8,
    TOKEN_KEYWORD__EUCJPMS,
    TOKEN_KEYWORD__EUCKR,
    TOKEN_KEYWORD__FILENAME,
    TOKEN_KEYWORD__GB18030,
    TOKEN_KEYWORD__GB2312,
    TOKEN_KEYWORD__GBK,
    TOKEN_KEYWORD__GEOSTD8,
    TOKEN_KEYWORD__GREEK,
    TOKEN_KEYWORD__HEBREW,
    TOKEN_KEYWORD__HP8,
    TOKEN_KEYWORD__KEYBCS2,
    TOKEN_KEYWORD__KOI8R,
    TOKEN_KEYWORD__KOI8U,
    TOKEN_KEYWORD__LATIN1,
    TOKEN_KEYWORD__LATIN2,
    TOKEN_KEYWORD__LATIN5,
    TOKEN_KEYWORD__LATIN7,
    TOKEN_KEYWORD__MACCE,
    TOKEN_KEYWORD__MACROMAN,
    TOKEN_KEYWORD__SJIS,
    TOKEN_KEYWORD__SWE7,
    TOKEN_KEYWORD__TIS620,
    TOKEN_KEYWORD__UCS2,
    TOKEN_KEYWORD__UJIS,
    TOKEN_KEYWORD__UTF16,
    TOKEN_KEYWORD__UTF16LE,
    TOKEN_KEYWORD__UTF32,
    TOKEN_KEYWORD__UTF8,
    TOKEN_KEYWORD__UTF8MB4,
#if (OCELOT_MYSQL_DEBUGGER == 1)
  TOKEN_KEYWORD_DEBUG_BREAKPOINT = TOKEN_KEYWORD__UTF8MB4 + 1,
  TOKEN_KEYWORD_DEBUG_CLEAR= TOKEN_KEYWORD_DEBUG_BREAKPOINT + 1,
  TOKEN_KEYWORD_DEBUG_CONTINUE= TOKEN_KEYWORD_DEBUG_CLEAR + 1,
  TOKEN_KEYWORD_DEBUG_DEBUG= TOKEN_KEYWORD_DEBUG_CONTINUE + 1,
  TOKEN_KEYWORD_DEBUG_DELETE= TOKEN_KEYWORD_DEBUG_DEBUG + 1,
  TOKEN_KEYWORD_DEBUG_EXECUTE= TOKEN_KEYWORD_DEBUG_DELETE + 1,
  TOKEN_KEYWORD_DEBUG_EXIT= TOKEN_KEYWORD_DEBUG_EXECUTE + 1,
  TOKEN_KEYWORD_DEBUG_INFORMATION= TOKEN_KEYWORD_DEBUG_EXIT + 1,
  TOKEN_KEYWORD_DEBUG_INSTALL= TOKEN_KEYWORD_DEBUG_INFORMATION + 1,
  TOKEN_KEYWORD_DEBUG_LEAVE= TOKEN_KEYWORD_DEBUG_INSTALL + 1,
  TOKEN_KEYWORD_DEBUG_NEXT= TOKEN_KEYWORD_DEBUG_LEAVE + 1,
  TOKEN_KEYWORD_DEBUG_REFRESH= TOKEN_KEYWORD_DEBUG_NEXT + 1,
  TOKEN_KEYWORD_DEBUG_SET= TOKEN_KEYWORD_DEBUG_REFRESH + 1,
  TOKEN_KEYWORD_DEBUG_SETUP= TOKEN_KEYWORD_DEBUG_SET + 1,
  TOKEN_KEYWORD_DEBUG_SKIP= TOKEN_KEYWORD_DEBUG_SETUP + 1,
  TOKEN_KEYWORD_DEBUG_SOURCE= TOKEN_KEYWORD_DEBUG_SKIP + 1,
  TOKEN_KEYWORD_DEBUG_STEP= TOKEN_KEYWORD_DEBUG_SOURCE + 1,
  TOKEN_KEYWORD_DEBUG_TBREAKPOINT= TOKEN_KEYWORD_DEBUG_STEP + 1,
#endif
  TOKEN_TYPE_KEYWORD,  /* generic, lots of keywords have this */
  TOKEN_KEYWORD_BEGIN_WORK,         /* some non-reserved keywords */
  TOKEN_KEYWORD_ROLLBACK_IN_ROLLBACK_TO,
  TOKEN_KEYWORD_BEGIN_XA,
  TOKEN_KEYWORD_CASE_IN_CASE_EXPRESSION,
  TOKEN_KEYWORD_END_IN_CASE_EXPRESSION,
  TOKEN_KEYWORD_IF_IN_IF_EXPRESSION,
  TOKEN_KEYWORD_IF_IN_IF_EXISTS,
  TOKEN_KEYWORD_REPEAT_IN_REPEAT_EXPRESSION,
  TOKEN_KEYWORD_HELP_IN_CLIENT,
  TOKEN_KEYWORD_DO_LUA,
  TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT,
  TOKEN_KEYWORD_END_IN_CREATE_STATEMENT,
  TOKEN_TYPE_DELIMITER
};

/*
  Sorted list of keywords.
  If you change this, you must also change bsearch parameters and change TOKEN_KEYWORD list.
  We consider introducers e.g. _UTF8 to be equivalent to reserved words.
  Some keywords e.g. "OCELOT_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR" are long,
  therefore MAX_KEYWORD_LENGTH is a big number, that causes some space waste.
*/
/*
  I got tired of repeating
  if (QString::compare(text.mid(main_token_offsets[0], main_token_lengths[0]), "SELECT", Qt::CaseInsensitive) == 0) ...
  so switched to maintaining a permanent list.
  Two compiler-dependent assumptions: bsearch() exists, and char* can be converted to unsigned long.
  Alphabetic order, and upper case because bsearch() calls strcmp().
  Placeholders at the start are so that strvalues[TOKEN_KEYWORD_QUESTIONMARK] will be 14.
*/
/* TODO: you don't need to calculate index, it's strvalues[...].token_keyword. */
/* Todo: use "const" and "static" more often */

/* Do not change this #define without seeing its use in e.g. initial_asserts(). */
#define KEYWORD_LIST_SIZE 1178

#define MAX_KEYWORD_LENGTH 46
struct keywords {
   char  chars[MAX_KEYWORD_LENGTH];
   unsigned int reserved_flags;
   unsigned int built_in_function_flags;
   unsigned short int token_keyword;
};
static const keywords strvalues[]=
    {
      {"\ba", 0, 0, 0}, /* 0 placeholder */
      {"\bb", 0, 0, 0}, /* 1 placeholder */
      {"\bc", 0, 0, 0}, /* 2 placeholder */
      {"\bd", 0, 0, 0}, /* 3 placeholder */
      {"\be", 0, 0, 0}, /* 4 placeholder */
      {"\bf", 0, 0, 0}, /* 5 placeholder */
      {"\bg", 0, 0, 0}, /* 6 placeholder */
      {"\bh", 0, 0, 0}, /* 7 placeholder */
      {"\bi", 0, 0, 0}, /* 8 placeholder */
      {"\bj", 0, 0, 0}, /* 9 placeholder */
      {"\bk", 0, 0, 0}, /* 10 placeholder */
      {"\bl", 0, 0, 0}, /* 11 placeholder */
      {"\bm", 0, 0, 0}, /* 12 placeholder */
      {"\bn", 0, 0, 0}, /* 13 placeholder */
      {"?", 0, 0, TOKEN_KEYWORD_QUESTIONMARK}, /* ocelotgui keyword, although tokenize() regards it as an operator */
      {"ABORT", 0, 0, TOKEN_KEYWORD_ABORT},
        {"ABORT_SOURCE_ON_ERROR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_ABORT_SOURCE_ON_ERROR},
      {"ABS", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_ABS},
      {"ACCESSIBLE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_ACCESSIBLE},
      {"ACOS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ACOS},
      {"ACTION", 0, 0, TOKEN_KEYWORD_ACTION},
      {"ADD", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_ADD},
      {"ADDDATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ADDDATE},
      {"ADDTIME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ADDTIME},
      {"AES_DECRYPT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_AES_DECRYPT},
      {"AES_ENCRYPT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_AES_ENCRYPT},
      {"AFTER", 0, 0, TOKEN_KEYWORD_AFTER},
      {"AGAINST", 0, 0, TOKEN_KEYWORD_AGAINST},
      {"ALGORITHM", 0, 0, TOKEN_KEYWORD_ALGORITHM},
      {"ALL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ALL},
      {"ALTER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ALTER},
      {"ALWAYS", 0, 0, TOKEN_KEYWORD_ALWAYS},
      {"ANALYZE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ANALYZE},
      {"AND", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_AND},
      {"ANY", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ANY},
      {"ANY_VALUE", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_ANY_VALUE},
      {"AREA", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_AREA}, /* deprecated in MySQL 5.7.6 */
      {"ARRAY", 0, 0, TOKEN_KEYWORD_ARRAY},
      {"AS", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_AS},
      {"ASBINARY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ASBINARY}, /* deprecated in MySQL 5.7.6 */
      {"ASC", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ASC},
      {"ASCII", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ASCII},
      {"ASENSITIVE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ASENSITIVE},
      {"ASIN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ASIN},
      {"ASTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ASTEXT}, /* deprecated in MySQL 5.7.6 */
      {"ASWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ASWKB}, /* deprecated in MySQL 5.7.6 */
      {"ASWKT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ASWKT}, /* deprecated in MySQL 5.7.6 */
      {"ASYMMETRIC_DECRYPT", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_ASYMMETRIC_DECRYPT},
      {"ASYMMETRIC_DERIVE", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_ASYMMETRIC_DERIVE},
      {"ASYMMETRIC_ENCRYPT", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_ASYMMETRIC_ENCRYPT},
      {"ASYMMETRIC_SIGN", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_ASYMMETRIC_SIGN},
      {"ASYMMETRIC_VERIFY", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_ASYMMETRIC_VERIFY},
      {"ATAN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ATAN},
      {"ATAN2", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ATAN2},
      {"ATOMIC", 0, 0, TOKEN_KEYWORD_ATOMIC},
      {"ATTACH", 0, 0, TOKEN_KEYWORD_ATTACH},
      {"AUTOINCREMENT", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_AUTOINCREMENT},
        {"AUTO_REHASH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_AUTO_REHASH},
        {"AUTO_VERTICAL_OUTPUT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_AUTO_VERTICAL_OUTPUT},
      {"AVG", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_AVG},
          {"BACKUP_ADMIN", 0, 0, TOKEN_KEYWORD_BACKUP_ADMIN},
        {"BATCH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_BATCH},
    {"BECOMES", 0, 0, TOKEN_KEYWORD_BECOMES},  /* for format rule */
      {"BEFORE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_BEFORE},
      {"BEGIN", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_BEGIN},
      {"BENCHMARK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BENCHMARK},
      {"BETWEEN", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_BETWEEN},
      {"BFILE", 0, 0, TOKEN_KEYWORD_BFILE},
      {"BIGINT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_BIGINT},
      {"BIN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BIN},
      {"BINARY", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_BINARY},
      {"BINARY_DOUBLE", 0, 0, TOKEN_KEYWORD_BINARY_DOUBLE},
      {"BINARY_FLOAT", 0, 0, TOKEN_KEYWORD_BINARY_FLOAT},
        {"BINARY_MODE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_BINARY_MODE},
        {"BIND", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_BIND},
        {"BIND_ADDRESS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_BIND_ADDRESS},
      {"BINLOG", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BINLOG},
          {"BINLOG_ADMIN", 0, 0, TOKEN_KEYWORD_BINLOG_ADMIN},
          {"BINLOG_GTID_POS", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BINLOG_GTID_POS},
      {"BIT", 0, 0, TOKEN_KEYWORD_BIT},
      {"BIT_AND", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BIT_AND},
      {"BIT_COUNT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BIT_COUNT},
      {"BIT_LENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BIT_LENGTH},
      {"BIT_OR", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BIT_OR},
      {"BIT_XOR", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BIT_XOR},
      {"BLOB", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_BLOB},
      {"BODY", FLAG_VERSION_PLSQL, 0, TOKEN_KEYWORD_BODY},
      {"BOOL", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_BOOL},
      {"BOOLEAN", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_BOOLEAN},
      {"BOTH", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_BOTH},
      {"BOXES", 0, 0, TOKEN_KEYWORD_BOXES},
      {"BREAK", FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_BREAK},
      {"BUFFER", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BUFFER}, /* deprecated in MySQL 5.7.6 */
      {"BUSY_TIMEOUT", 0, 0, TOKEN_KEYWORD_BUSY_TIMEOUT},
      {"BY", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_BY},
      {"CALL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CALL},
      {"CASCADE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_CASCADE},
      {"CASE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CASE},
      {"CAST", FLAG_VERSION_TARANTOOL, FLAG_VERSION_ALL, TOKEN_KEYWORD_CAST},
      {"CEIL", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CEIL},
      {"CEILING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CEILING},
      {"CENTROID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CENTROID}, /* deprecated in MySQL 5.7.6 */
      {"CHANGE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_CHANGE},
      {"CHAR", FLAG_VERSION_ALL, FLAG_VERSION_ALL, TOKEN_KEYWORD_CHAR},
      {"CHARACTER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CHARACTER},
      {"CHARACTER_LENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CHARACTER_LENGTH},
        {"CHARACTER_SETS_DIR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_CHARACTER_SETS_DIR},
      {"CHARSET", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CHARSET},  /* + ocelotgui keyword */
      {"CHAR_LENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CHAR_LENGTH},
      {"CHECK", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CHECK},
      {"CLEAR", 0, 0, TOKEN_KEYWORD_CLEAR}, /* ocelotgui keyword */
      {"CLOB", 0, 0, TOKEN_KEYWORD_CLOB},
      {"CLOSE", 0, 0, TOKEN_KEYWORD_CLOSE},
      {"COALESCE", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_COALESCE},
      {"COERCIBILITY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_COERCIBILITY},
      {"COLLATE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_COLLATE},
      {"COLLATION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_COLLATION},
      {"COLLATION_LIST", 0, 0, TOKEN_KEYWORD_COLLATION_LIST},
      {"COLUMN", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_COLUMN},
      {"COLUMNS", 0, 0, TOKEN_KEYWORD_COLUMNS},
      {"COLUMN_ADD", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_ADD},
      {"COLUMN_CHECK", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_CHECK},
      {"COLUMN_CREATE", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_CREATE},
      {"COLUMN_DELETE", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_DELETE},
      {"COLUMN_EXISTS", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_EXISTS},
      {"COLUMN_GET", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_GET},
      {"COLUMN_JSON", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_JSON},
      {"COLUMN_LIST", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_LIST},
      {"COLUMN_NAME", 0, 0, TOKEN_KEYWORD_COLUMN_NAME},
      {"COLUMN_NAMES", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_COLUMN_NAMES},
      {"COLUMN_NUMBER", 0, 0, TOKEN_KEYWORD_COLUMN_NUMBER},
      {"COLUMN_TYPE", 0, 0, TOKEN_KEYWORD_COLUMN_TYPE},
      {"COLUMN_TYPE_INFO", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_COLUMN_TYPE_INFO},
      {"COMMA", 0, 0, TOKEN_KEYWORD_COMMA}, /* for format rule */
      {"COMMENT", 0, 0, TOKEN_KEYWORD_COMMENT},
        {"COMMENTS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_COMMENTS},
      {"COMMIT", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_COMMIT},
      {"COMPACT", 0, 0, TOKEN_KEYWORD_COMPACT},
      {"COMPRESS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_OPTION, TOKEN_KEYWORD_COMPRESS},
      {"COMPRESSED", 0, 0, TOKEN_KEYWORD_COMPRESSED},
      {"COMPRESSION", 0, 0, TOKEN_KEYWORD_COMPRESSION},
      {"CONCAT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONCAT},
      {"CONCAT_WS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONCAT_WS},
      {"CONDITION", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CONDITION},
      {"CONFLICT", 0, 0, TOKEN_KEYWORD_CONFLICT},
      {"CONNECT", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_CONNECT}, /* ocelotgui keyword */
          {"CONNECTION_ADMIN", 0, 0, TOKEN_KEYWORD_CONNECTION_ADMIN},
      {"CONNECTION_ID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONNECTION_ID},
        {"CONNECT_ATTR_DELETE", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_CONNECT_ATTR_DELETE},
        {"CONNECT_ATTR_RESET", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_CONNECT_ATTR_RESET},
        {"CONNECT_EXPIRED_PASSWORD", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_CONNECT_EXPIRED_PASSWORD},
        {"CONNECT_TIMEOUT", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_CONNECT_TIMEOUT},
      {"CONSTRAINT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CONSTRAINT},
      {"CONTAINS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONTAINS}, /* deprecated in MySQL 5.7.6 */
      {"CONTINUE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_CONTINUE},
      {"CONV", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONV},
      {"CONVERT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONVERT},
      {"CONVERT_TZ", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONVERT_TZ},
      {"CONVEXHULL", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONVEXHULL}, /* deprecated in MySQL 5.7.6 */
      {"COS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_COS},
      {"COT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_COT},
      {"COUNT", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_COUNT},
      {"CRC32", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CRC32},
      {"CREATE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CREATE},
      {"CREATE_ASYMMETRIC_PRIV_KEY", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_CREATE_ASYMMETRIC_PRIV_KEY},
      {"CREATE_ASYMMETRIC_PUB_KEY", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_CREATE_ASYMMETRIC_PUB_KEY},
      {"CREATE_DH_PARAMETERS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CREATE_DH_PARAMETERS},
      {"CREATE_DIGEST", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CREATE_DIGEST},
      {"CROSS", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CROSS},
      {"CROSSES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CROSSES}, /* deprecated in MySQL 5.7.6 */
      {"CUBE", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_CUBE},
      {"CUME_DIST", FLAG_VERSION_MYSQL_8_0, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_2_2, TOKEN_KEYWORD_CUME_DIST},
      {"CURDATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CURDATE},
      {"CURRENT", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_CURRENT},
      {"CURRENT_DATE", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CURRENT_DATE},
      {"CURRENT_ROLE", FLAG_VERSION_MARIADB_10_0, 0, TOKEN_KEYWORD_CURRENT_ROLE},
      {"CURRENT_TIME", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CURRENT_TIME},
      {"CURRENT_TIMESTAMP", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CURRENT_TIMESTAMP},
      {"CURRENT_USER", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CURRENT_USER},
      {"CURSOR", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CURSOR},
      {"CURTIME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CURTIME},
      {"CYCLE", 0, 0, TOKEN_KEYWORD_CYCLE},
      {"DATABASE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_OPTION, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DATABASE},
      {"DATABASES", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DATABASES},
      {"DATE", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_DATE},
      {"DATEDIFF", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DATEDIFF},
      {"DATETIME", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_DATETIME},
      {"DATE_ADD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DATE_ADD},
      {"DATE_FORMAT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DATE_FORMAT},
      {"DATE_SUB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DATE_SUB},
      {"DAY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DAY},
      {"DAYNAME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DAYNAME},
      {"DAYOFMONTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DAYOFMONTH},
      {"DAYOFWEEK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DAYOFWEEK},
      {"DAYOFYEAR", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DAYOFYEAR},
      {"DAY_HOUR", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DAY_HOUR},
      {"DAY_MICROSECOND", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DAY_MICROSECOND},
      {"DAY_MINUTE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DAY_MINUTE},
      {"DAY_SECOND", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DAY_SECOND},
      {"DEALLOCATE", 0, 0, TOKEN_KEYWORD_DEALLOCATE},
    {"DEBUG", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DEBUG},
    {"DEBUG_CHECK", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_DEBUG_CHECK},
    {"DEBUG_INFO", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DEBUG_INFO},
      {"DEC", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DEC},
      {"DECIMAL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DECIMAL},
      {"DECLARE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DECLARE},
      {"DECODE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DECODE},
      {"DECODE_HISTOGRAM", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_DECODE_HISTOGRAM},
      {"DEFAULT", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DEFAULT},
    {"DEFAULTS_EXTRA_FILE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DEFAULTS_EXTRA_FILE},
    {"DEFAULTS_FILE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DEFAULTS_FILE},
    {"DEFAULTS_GROUP_SUFFIX", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DEFAULTS_GROUP_SUFFIX},
    {"DEFAULT_AUTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DEFAULT_AUTH},
    {"DEFAULT_CHARACTER_SET", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DEFAULT_CHARACTER_SET},
      {"DEFERRABLE", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_DEFERRABLE},
      {"DEFERRED", 0, 0, TOKEN_KEYWORD_DEFERRED},
      {"DEGREES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DEGREES},
      {"DELAYED", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DELAYED},
      {"DELETE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DELETE},
      {"DELIMITED", 0, 0, TOKEN_KEYWORD_DELIMITED},
      {"DELIMITER", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DELIMITER}, /* ocelotgui keyword */
      {"DENSE_RANK", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_TARANTOOL, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_2_2, TOKEN_KEYWORD_DENSE_RANK},
      {"DESC", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DESC},
      {"DESCRIBE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DESCRIBE},
      {"DES_DECRYPT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DES_DECRYPT}, /* deprecated in MySQL 5.7.6 */
      {"DES_ENCRYPT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DES_ENCRYPT}, /* deprecated in MySQL 5.7.6 */
      {"DETACH", 0, 0, TOKEN_KEYWORD_DETACH},
      {"DETERMINISTIC", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DETERMINISTIC},
      {"DIMENSION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DIMENSION}, /* deprecated in MySQL 5.7.6 */
      {"DIRECTORY", 0, 0, TOKEN_KEYWORD_DIRECTORY},
      {"DISJOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DISJOINT}, /* deprecated in MySQL 5.7.6 */
      {"DISTANCE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DISTANCE}, /* deprecated in MySQL 5.7.6 */
      {"DISTINCT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DISTINCT},
      {"DISTINCTROW", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DISTINCTROW},
      {"DIV", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DIV},
      {"DO", FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_DO},
      {"DOUBLE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DOUBLE},
      {"DROP", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DROP},
      {"DUAL", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DUAL},
      {"DUPLICATE", 0, 0, TOKEN_KEYWORD_DUPLICATE},
      {"DYNAMIC", 0, 0, TOKEN_KEYWORD_DYNAMIC},
      {"EACH", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_EACH},
      {"EDIT", 0, 0, TOKEN_KEYWORD_EDIT}, /* ocelotgui keyword */
      {"EGO", 0, 0, TOKEN_KEYWORD_EGO}, /* ocelotgui keyword */
      {"ELSE", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_ELSE},
      {"ELSEIF", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_ELSEIF},
      {"ELSIF", FLAG_VERSION_PLSQL, 0, TOKEN_KEYWORD_ELSIF},
      {"ELT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ELT},
    {"EMPTY", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_EMPTY},
      {"ENABLE", 0, 0, TOKEN_KEYWORD_ENABLE},
        {"ENABLE_CLEARTEXT_PLUGIN", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_ENABLE_CLEARTEXT_PLUGIN},
      {"ENCLOSED", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_ENCLOSED},
      {"ENCODE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ENCODE},
      {"ENCRYPT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ENCRYPT}, /* deprecated in MySQL 5.7.6 */
          {"ENCRYPTION_KEY_ADMIN", 0, 0, TOKEN_KEYWORD_ENCRYPTION_KEY_ADMIN},
      {"END", FLAG_VERSION_TARANTOOL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_END},
      {"ENDPOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ENDPOINT}, /* deprecated in MySQL 5.7.6 */
      {"ENGINE", FLAG_VERSION_TARANTOOL_2_3, 0, TOKEN_KEYWORD_ENGINE},
      {"ENUM", 0, 0, TOKEN_KEYWORD_ENUM},
      {"ENVELOPE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ENVELOPE}, /* deprecated in MySQL 5.7.6 */
      {"EQUALS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_EQUALS}, /* deprecated in MySQL 5.7.6 */
      {"ESCAPE", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_ESCAPE},
      {"ESCAPED", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_ESCAPED},
      {"EVENT", 0, 0, TOKEN_KEYWORD_EVENT},
      {"EXCEPT", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_TARANTOOL|FLAG_VERSION_MARIADB_10_3, 0, TOKEN_KEYWORD_EXCEPT},
      {"EXCEPTION", 0, 0, TOKEN_KEYWORD_EXCEPTION},
      {"EXCHANGE", 0, 0, TOKEN_KEYWORD_EXCHANGE},
      {"EXCLUSIVE", 0, 0, TOKEN_KEYWORD_EXCLUSIVE},
      {"EXECUTE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_EXECUTE},
      {"EXISTS", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_EXISTS},
      {"EXIT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_EXIT},
      {"EXP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_EXP},
      {"EXPANSION", 0, 0, TOKEN_KEYWORD_EXPANSION},
      {"EXPLAIN", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_EXPLAIN},
      {"EXPORT", 0, 0, TOKEN_KEYWORD_EXPORT},
      {"EXPORT_SET", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_EXPORT_SET},
      {"EXTERIORRING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_EXTERIORRING}, /* deprecated in MySQL 5.7.6 */
      {"EXTRACT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_EXTRACT},
      {"EXTRACTVALUE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_EXTRACTVALUE},
      {"FAIL", 0, 0, TOKEN_KEYWORD_FAIL},
      {"FALSE", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_FALSE},
      {"FETCH", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_FETCH},
      {"FIELD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FIELD},
      {"FIELDS", 0, 0, TOKEN_KEYWORD_FIELDS},
      {"FILE", 0, 0, TOKEN_KEYWORD_FILE},
      {"FIND_IN_SET", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FIND_IN_SET},
          {"FIREWALL_ADMIN", 0, 0, TOKEN_KEYWORD_FIREWALL_ADMIN},
          {"FIREWALL_USER", 0, 0, TOKEN_KEYWORD_FIREWALL_USER},
      {"FIRST", 0, 0, TOKEN_KEYWORD_FIRST}, /* MariaDB 10.2 nonreserved */
      {"FIRST_VALUE", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_FIRST_VALUE}, /* MariaDB 10.2 nonreserved -- or, maybe not in MariaDB 10.2*/
      {"FIXED", 0, 0, TOKEN_KEYWORD_FIXED},
      {"FLOAT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_FLOAT},
      {"FLOAT4", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_FLOAT4},
      {"FLOAT8", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_FLOAT8},
      {"FLOOR", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FLOOR},
      {"FLUSH", 0, 0, TOKEN_KEYWORD_FLUSH},
      {"FOLLOWING", FLAG_VERSION_MARIADB_10_2_2, 0, TOKEN_KEYWORD_FOLLOWING},
      {"FOLLOWS", FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, 0, TOKEN_KEYWORD_FOLLOWS},
      {"FOR", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_FOR},
      {"FORCE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_FORCE},
      {"FOREIGN", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_FOREIGN},
      {"FOREIGN_KEY_LIST", 0, 0, TOKEN_KEYWORD_FOREIGN_KEY_LIST},
      {"FORMAT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FORMAT},
      {"FOUND", 0, 0, TOKEN_KEYWORD_FOUND},
      {"FOUND_ROWS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FOUND_ROWS},
      {"FROM", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_FROM},
      {"FROM_BASE64", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FROM_BASE64},
      {"FROM_DAYS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FROM_DAYS},
      {"FROM_UNIXTIME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FROM_UNIXTIME},
      {"FULL", 0, 0, TOKEN_KEYWORD_FULL},
      {"FULLTEXT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_FULLTEXT},
      {"FUNCTION", FLAG_VERSION_MYSQL_8_0 | FLAG_VERSION_TARANTOOL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_FUNCTION},
      {"GENERAL", 0, 0, TOKEN_KEYWORD_GENERAL},
      {"GENERATED", FLAG_VERSION_MYSQL_5_7, 0, TOKEN_KEYWORD_GENERATED},
      {"GEOMCOLLFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMCOLLFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"GEOMCOLLFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMCOLLFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"GEOMETRY", 0, 0, TOKEN_KEYWORD_GEOMETRY},
      {"GEOMETRYCOLLECTION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMETRYCOLLECTION},
      {"GEOMETRYCOLLECTIONFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMETRYCOLLECTIONFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"GEOMETRYCOLLECTIONFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMETRYCOLLECTIONFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"GEOMETRYFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMETRYFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"GEOMETRYFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMETRYFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"GEOMETRYN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMETRYN}, /* deprecated in MySQL 5.7.6 */
      {"GEOMETRYTYPE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMETRYTYPE}, /* deprecated in MySQL 5.7.6 */
      {"GEOMFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMFROMTEXT},/* deprecated in MySQL 5.7.6 */
      {"GEOMFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"GET", FLAG_VERSION_TARANTOOL | FLAG_VERSION_MYSQL_5_6, 0, TOKEN_KEYWORD_GET},
      {"GET_FORMAT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GET_FORMAT},
      {"GET_LOCK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GET_LOCK},
      {"GLENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GLENGTH}, /* deprecated in MySQL 5.7.6 */
      {"GLOBAL", 0, 0, TOKEN_KEYWORD_GLOBAL},
      {"GO", 0, 0, TOKEN_KEYWORD_GO}, /* ocelotgui keyword */
      {"GOTO", FLAG_VERSION_LUA|FLAG_VERSION_PLSQL, 0, TOKEN_KEYWORD_GOTO},
      {"GRANT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_GRANT},
      {"GREATEST", FLAG_VERSION_TARANTOOL_2_3, FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_TARANTOOL_2_3, TOKEN_KEYWORD_GREATEST},
      {"GROUP", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_GROUP},
    {"GROUPING", FLAG_VERSION_MYSQL_8_0, FLAG_VERSION_MYSQL_8_0, TOKEN_KEYWORD_GROUPING},
    {"GROUPS", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_GROUPS},
      {"GROUP_CONCAT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GROUP_CONCAT},
          {"GROUP_REPLICATION_ADMIN", 0, 0, TOKEN_KEYWORD_GROUP_REPLICATION_ADMIN},
      {"GTID_SUBSET", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GTID_SUBSET},
      {"GTID_SUBTRACT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GTID_SUBTRACT},
      {"HANDLER", 0, 0, TOKEN_KEYWORD_HANDLER},
      {"HAVING", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_HAVING},
      {"HELP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_HELP}, /* ocelotgui keyword */
      {"HEX", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_HEX},
      {"HIGH_PRIORITY", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_HIGH_PRIORITY},
    {"HISTFILE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_HISTFILE},
    {"HISTIGNORE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_HISTIGNORE},
    {"HOST", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_HOST},
      {"HOUR", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_HOUR},
      {"HOUR_MICROSECOND", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_HOUR_MICROSECOND},
      {"HOUR_MINUTE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_HOUR_MINUTE},
      {"HOUR_SECOND", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_HOUR_SECOND},
        {"HTML", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_HTML},
      {"IDENTIFIER", 0, 0, TOKEN_KEYWORD_IDENTIFIER}, /* for format rule */
      {"IF", FLAG_VERSION_ALL | FLAG_VERSION_LUA, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IF},
      {"IFNULL", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_IFNULL},
      {"IGNORE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_IGNORE},
        {"IGNORE_SPACES", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_IGNORE_SPACES},
      {"IMMEDIATE", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_IMMEDIATE},
      {"IMPORT", 0, 0, TOKEN_KEYWORD_IMPORT},
      {"IN", FLAG_VERSION_ALL | FLAG_VERSION_LUA, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IN},
      {"INDEX", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_INDEX},
      {"INDEXED", 0, 0, TOKEN_KEYWORD_INDEXED},
      {"INDEX_INFO", 0, 0, TOKEN_KEYWORD_INDEX_INFO},
      {"INDEX_LIST", 0, 0, TOKEN_KEYWORD_INDEX_LIST},
      {"INET6_ATON", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INET6_ATON},
      {"INET6_NTOA", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INET6_NTOA},
      {"INET_ATON", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INET_ATON},
      {"INET_NTOA", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INET_NTOA},
      {"INFILE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_INFILE},
      {"INITIALLY", 0, 0, TOKEN_KEYWORD_INITIALLY},
        {"INIT_COMMAND", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_INIT_COMMAND},
      {"INNER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_INNER},
      {"INOUT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_INOUT},
      {"INSENSITIVE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_INSENSITIVE},
      {"INSERT", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INSERT},
      {"INSTALL", 0, 0, TOKEN_KEYWORD_INSTALL},
      {"INSTEAD", 0, 0, TOKEN_KEYWORD_INSTEAD},
      {"INSTR", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_INSTR},
      {"INT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_INT},
      {"INT1", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_INT1},
      {"INT2", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_INT2},
      {"INT3", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_INT3},
      {"INT4", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_INT4},
      {"INT8", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_INT8},
      {"INTEGER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_INTEGER},
      {"INTERIORRINGN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INTERIORRINGN}, /* deprecated in MySQL 5.7.6 */
      {"INTERSECT", FLAG_VERSION_TARANTOOL|FLAG_VERSION_MARIADB_10_3, 0, TOKEN_KEYWORD_INTERSECT},
      {"INTERSECTS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INTERSECTS}, /* deprecated in MySQL 5.7.6 */
      {"INTERVAL", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INTERVAL},
      {"INTO", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_INTO},
      {"IO_AFTER_GTIDS", FLAG_VERSION_MYSQL_5_6, 0, TOKEN_KEYWORD_IO_AFTER_GTIDS},
      {"IO_BEFORE_GTIDS", FLAG_VERSION_MYSQL_5_6, 0, TOKEN_KEYWORD_IO_BEFORE_GTIDS},
      {"IS", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_IS},
      {"ISCLOSED", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ISCLOSED}, /* deprecated in MySQL 5.7.6 */
      {"ISEMPTY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ISEMPTY}, /* deprecated in MySQL 5.7.6 */
      {"ISNULL", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_ISNULL},
      {"ISSIMPLE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ISSIMPLE}, /* deprecated in MySQL 5.7.6 */
      {"IS_FREE_LOCK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IS_FREE_LOCK},
      {"IS_IPV4", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IS_IPV4},
      {"IS_IPV4_COMPAT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IS_IPV4_COMPAT},
      {"IS_IPV4_MAPPED", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IS_IPV4_MAPPED},
      {"IS_IPV6", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IS_IPV6},
      {"IS_USED_LOCK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IS_USED_LOCK},
      {"ITERATE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ITERATE},
      {"JOIN", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_JOIN},
      {"JSON", 0, 0, TOKEN_KEYWORD_JSON},
      {"JSON_APPEND", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_APPEND},
      {"JSON_ARRAY", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_ARRAY},
      {"JSON_ARRAY_APPEND", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_ARRAY_APPEND},
      {"JSON_ARRAY_INSERT", 0, FLAG_VERSION_MYSQL_5_7, TOKEN_KEYWORD_JSON_ARRAY_INSERT},
      {"JSON_CONTAINS", 0, FLAG_VERSION_MYSQL_5_7, TOKEN_KEYWORD_JSON_CONTAINS},
      {"JSON_CONTAINS_PATH", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_CONTAINS_PATH},
      {"JSON_DEPTH", 0, FLAG_VERSION_MYSQL_5_7, TOKEN_KEYWORD_JSON_DEPTH},
      {"JSON_EXTRACT", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_EXTRACT},
      {"JSON_INSERT", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_INSERT},
      {"JSON_KEYS", 0, FLAG_VERSION_MYSQL_5_7, TOKEN_KEYWORD_JSON_KEYS},
      {"JSON_LENGTH", 0, FLAG_VERSION_MYSQL_5_7, TOKEN_KEYWORD_JSON_LENGTH},
      {"JSON_MERGE", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_MERGE},
      {"JSON_OBJECT", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_OBJECT},
      {"JSON_QUERY", 0, FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_QUERY},
      {"JSON_QUOTE", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_QUOTE},
      {"JSON_REMOVE", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_REMOVE},
      {"JSON_REPLACE", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_REPLACE},
      {"JSON_SEARCH", 0, FLAG_VERSION_MYSQL_5_7, TOKEN_KEYWORD_JSON_SEARCH},
      {"JSON_SET", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_SET},
    {"JSON_TABLE", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_JSON_TABLE},
      {"JSON_TYPE", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_TYPE},
      {"JSON_UNQUOTE", 0, FLAG_VERSION_MYSQL_5_7, TOKEN_KEYWORD_JSON_UNQUOTE},
      {"JSON_VALID", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_VALID},
      {"JSON_VALUE", 0, FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_VALUE},
      {"JULIANDAY", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JULIANDAY},
      {"KEY", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_KEY},
      {"KEYS", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_KEYS},
      {"KEYWORD", 0, 0, TOKEN_KEYWORD_KEYWORD}, /* for format rule */
      {"KILL", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_KILL},
      {"LAG", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_3, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_LAG}, /* MariaDB 10.2 nonreserved -- or, maybe not in MariaDB 10.2 */
      {"LANGUAGE", 0, 0, TOKEN_KEYWORD_LANGUAGE},
      {"LAST", 0, 0, TOKEN_KEYWORD_LAST}, /* MariaDB 10.2 nonreserved */
      {"LASTVAL", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_LASTVAL},
      {"LAST_DAY", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_LAST_DAY},
      {"LAST_INSERT_ID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LAST_INSERT_ID},
      {"LAST_VALUE", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_LAST_VALUE}, /* MariaDB 10.2 nonreserved */
      {"LATERAL", 0, 0, TOKEN_KEYWORD_LATERAL}, /* MySQL 8.0.2 manual says reserved but it isn't */
      {"LCASE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LCASE},
        {"LD_RUN_PATH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_LD_RUN_PATH},
      {"LEAD", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_3, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_LEAD}, /* MariaDB 10.2 nonreserved -- or, maybe not in MariaDB 10.2 */
      {"LEADING", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_LEADING},
      {"LEAST", FLAG_VERSION_TARANTOOL_2_3, FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_TARANTOOL_2_3, TOKEN_KEYWORD_LEAST},
      {"LEAVE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_LEAVE},
      {"LEFT", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LEFT},
      {"LENGTH", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_LENGTH},
      {"LEVEL", 0, 0, TOKEN_KEYWORD_LEVEL},
      {"LIKE", FLAG_VERSION_ALL, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_LIKE},
      {"LIMIT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_LIMIT},
      {"LINEAR", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LINEAR},
      {"LINEFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LINEFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"LINEFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LINEFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"LINES", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LINES},
      {"LINESTRING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LINESTRING},
      {"LINESTRINGFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LINESTRINGFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"LINESTRINGFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LINESTRINGFROMWKB},   /* deprecated in MySQL 5.7.6 */
        {"LINE_NUMBERS", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_LINE_NUMBERS},
      {"LITERAL", 0, 0, TOKEN_KEYWORD_LITERAL}, /* for format rule */
      {"LN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LN},
      {"LOAD", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LOAD},
      {"LOAD_FILE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LOAD_FILE},
      {"LOCAL", FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_LOCAL},
      {"LOCALTIME", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LOCALTIME},
      {"LOCALTIMESTAMP", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LOCALTIMESTAMP},
        {"LOCAL_INFILE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_LOCAL_INFILE},
      {"LOCATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LOCATE},
      {"LOCK", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LOCK},
      {"LOG", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LOG},
      {"LOG10", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LOG10},
      {"LOG2", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LOG2},
      {"LOGFILE", 0, 0, TOKEN_KEYWORD_LOGFILE},
        {"LOGIN_PATH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_LOGIN_PATH},
      {"LONG", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LONG},
      {"LONGBLOB", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LONGBLOB},
      {"LONGTEXT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LONGTEXT},
      {"LOOP", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_LOOP},
      {"LOWER", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_LOWER},
      {"LOW_PRIORITY", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LOW_PRIORITY},
      {"LPAD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LPAD},
      {"LTRIM", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_LTRIM},
      {"LUA", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_LUA},
      {"MAKEDATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MAKEDATE},
      {"MAKETIME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MAKETIME},
      {"MAKE_SET", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MAKE_SET},
      {"MAP", 0, 0, TOKEN_KEYWORD_MAP},
      {"MASTER_BIND", FLAG_VERSION_MYSQL_5_6, 0, TOKEN_KEYWORD_MASTER_BIND},
      {"MASTER_HEARTBEAT_PERIOD", 0, 0, TOKEN_KEYWORD_MASTER_HEARTBEAT_PERIOD},
      {"MASTER_POS_WAIT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MASTER_POS_WAIT},
      {"MASTER_SSL_VERIFY_SERVER_CERT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MASTER_SSL_VERIFY_SERVER_CERT},
      {"MATCH", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_MATCH},
      {"MAX", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_MAX},
      {"MAXVALUE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MAXVALUE},
    {"MAX_ALLOWED_PACKET", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_MAX_ALLOWED_PACKET},
    {"MAX_JOIN_SIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_MAX_JOIN_SIZE},
      {"MBRCONTAINS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBRCONTAINS},
      {"MBRCOVEREDBY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBRCOVEREDBY},
      {"MBRCOVERS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBRCOVERS},
      {"MBRDISJOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBRDISJOINT},
      {"MBREQUAL", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBREQUAL}, /* deprecated in MySQL 5.7.6 */
      {"MBREQUALS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBREQUALS},
      {"MBRINTERSECTS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBRINTERSECTS},
      {"MBROVERLAPS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBROVERLAPS},
      {"MBRTOUCHES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBRTOUCHES},
      {"MBRWITHIN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBRWITHIN},
      {"MD5", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MD5},
      {"MEDIAN", FLAG_VERSION_MARIADB_10_3, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_MEDIAN}, /* MariaDB 10.3.3 */
      {"MEDIUMBLOB", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MEDIUMBLOB},
      {"MEDIUMINT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MEDIUMINT},
      {"MEDIUMTEXT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MEDIUMTEXT},
      {"MICROSECOND", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MICROSECOND},
      {"MID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MID},
      {"MIDDLEINT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MIDDLEINT},
      {"MIN", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_MIN},
      {"MINUTE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MINUTE},
      {"MINUTE_MICROSECOND", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MINUTE_MICROSECOND},
      {"MINUTE_SECOND", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MINUTE_SECOND},
      {"MINVALUE", 0, 0, TOKEN_KEYWORD_MINVALUE},
      {"MLINEFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MLINEFROMTEXT},  /* deprecated in MySQL 5.7.6 */
      {"MLINEFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MLINEFROMWKB},  /* deprecated in MySQL 5.7.6 */
      {"MOD", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MOD},
      {"MODE", 0, 0, TOKEN_KEYWORD_MODE},
      {"MODIFIES", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MODIFIES},
      {"MONTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MONTH},
      {"MONTHNAME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MONTHNAME},
      {"MPOINTFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MPOINTFROMTEXT},  /* deprecated in MySQL 5.7.6 */
      {"MPOINTFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MPOINTFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"MPOLYFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MPOLYFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"MPOLYFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MPOLYFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"MULTILINESTRING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTILINESTRING},
      {"MULTILINESTRINGFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTILINESTRINGFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"MULTILINESTRINGFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTILINESTRINGFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"MULTIPOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTIPOINT},
      {"MULTIPOINTFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTIPOINTFROMTEXT},  /* deprecated in MySQL 5.7.6 */
      {"MULTIPOINTFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTIPOINTFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"MULTIPOLYGON", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTIPOLYGON},
      {"MULTIPOLYGONFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTIPOLYGONFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"MULTIPOLYGONFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTIPOLYGONFROMWKB}, /* deprecated in MySQL 5.7.6 */
        {"NAMED_COMMANDS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_NAMED_COMMANDS},
      {"NAMES", 0, 0, TOKEN_KEYWORD_NAMES},
      {"NAME_CONST", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_NAME_CONST},
      {"NATURAL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_NATURAL},
      {"NCHAR", 0, 0, TOKEN_KEYWORD_NCHAR},
        {"NET_BUFFER_LENGTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_NET_BUFFER_LENGTH},
      {"NEWLINE", 0, 0, TOKEN_KEYWORD_NEWLINE}, /* for format rule */
      {"NEXTVAL", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_NEXTVAL},
      {"NIL", FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_NIL},
      {"NO", 0, 0, TOKEN_KEYWORD_NO},
      {"NOPAGER", 0, 0, TOKEN_KEYWORD_NOPAGER}, /* ocelotgui keyword */
      {"NOT", FLAG_VERSION_TARANTOOL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_NOT},
      {"NOTEE", 0, 0, TOKEN_KEYWORD_NOTEE}, /* ocelotgui keyword */
      {"NOTNULL", 0, 0, TOKEN_KEYWORD_NOTNULL},
      {"NOW", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_NOW},
      {"NOWARNING", 0, 0, TOKEN_KEYWORD_NOWARNING}, /* ocelotgui keyword */
        {"NO_AUTO_REHASH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_NO_AUTO_REHASH},
    {"NO_BEEP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_NO_BEEP},
    {"NO_DEFAULTS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_NO_DEFAULTS},
    {"NO_NAMED_COMMANDS", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_NO_NAMED_COMMANDS},
    {"NO_TEE", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_NO_TEE},
      {"NO_WRITE_TO_BINLOG", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_NO_WRITE_TO_BINLOG},
      {"NTH_VALUE", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_3, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_NTH_VALUE}, /* MariaDB 10.2 nonreserved -- or, maybe not in MariaDB 10.2 */
      {"NTILE", FLAG_VERSION_MYSQL_8_0, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_2_2, TOKEN_KEYWORD_NTILE},
      {"NULL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_NULL},
      {"NULLIF", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_NULLIF},
      {"NULLS", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_NULLS}, /* MariaDB 10.2 nonreserved  -- or, maybe not in MariaDB 10.2 */
      {"NUM", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_NUM},
      {"NUMBER", FLAG_VERSION_TARANTOOL_2_2, 0, TOKEN_KEYWORD_NUMBER},
      {"NUMERIC", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_NUMERIC},
      {"NUMGEOMETRIES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_NUMGEOMETRIES}, /* deprecated in MySQL 5.7.6 */
      {"NUMINTERIORRINGS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_NUMINTERIORRINGS}, /* deprecated in MySQL 5.7.6 */
      {"NUMPOINTS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_NUMPOINTS}, /* deprecated in MySQL 5.7.6 */
      {"NVARCHAR2", 0, 0, TOKEN_KEYWORD_NVARCHAR2},

    {"OCELOT_BATCH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_BATCH},
    {"OCELOT_CLIENT_SIDE_FUNCTIONS", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_OCELOT_CLIENT_SIDE_FUNCTIONS},
    {"OCELOT_COMPLETER_TIMEOUT", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_OCELOT_COMPLETER_TIMEOUT},
    {"OCELOT_DBMS", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_OCELOT_DBMS},
    {"OCELOT_DEBUG_DETACHED", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED},
    {"OCELOT_DEBUG_HEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_DEBUG_HEIGHT},
    {"OCELOT_DEBUG_LEFT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_DEBUG_LEFT},
    {"OCELOT_DEBUG_TOP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_DEBUG_TOP},
    {"OCELOT_DEBUG_WIDTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_DEBUG_WIDTH},
    {"OCELOT_EXPORT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXPORT}, /* if OCELOT_IMPORT_EXPORT == 1 */
    {"OCELOT_EXTRA_RULE_1_BACKGROUND_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_BACKGROUND_COLOR},
    {"OCELOT_EXTRA_RULE_1_CONDITION", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_CONDITION},
    {"OCELOT_EXTRA_RULE_1_DISPLAY_AS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_DISPLAY_AS},
    {"OCELOT_EXTRA_RULE_1_TEXT_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_TEXT_COLOR},
    {"OCELOT_GRID_BACKGROUND_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_BACKGROUND_COLOR},
    {"OCELOT_GRID_BORDER_SIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_BORDER_SIZE}, /* no longer used */
    {"OCELOT_GRID_CELL_BORDER_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_COLOR},
    {"OCELOT_GRID_CELL_BORDER_SIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_SIZE},
    {"OCELOT_GRID_CELL_HEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_CELL_HEIGHT},
    {"OCELOT_GRID_CELL_WIDTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_CELL_WIDTH},
    {"OCELOT_GRID_DETACHED", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_DETACHED},
    {"OCELOT_GRID_FOCUS_CELL_BACKGROUND_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_FOCUS_CELL_BACKGROUND_COLOR},
    {"OCELOT_GRID_FONT_FAMILY", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_FONT_FAMILY},
    {"OCELOT_GRID_FONT_SIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_FONT_SIZE},
    {"OCELOT_GRID_FONT_STYLE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_FONT_STYLE},
    {"OCELOT_GRID_FONT_WEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_FONT_WEIGHT},
    {"OCELOT_GRID_HEADER_BACKGROUND_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_HEADER_BACKGROUND_COLOR},
    {"OCELOT_GRID_HEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_HEIGHT},
    {"OCELOT_GRID_HTML_EFFECTS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_HTML_EFFECTS},
    {"OCELOT_GRID_LEFT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_LEFT},
    {"OCELOT_GRID_OUTER_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_OUTER_COLOR},
    {"OCELOT_GRID_TABS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_TABS},
    {"OCELOT_GRID_TEXT_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_TEXT_COLOR},
    {"OCELOT_GRID_TOOLTIP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_TOOLTIP},
    {"OCELOT_GRID_TOP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_TOP},
    {"OCELOT_GRID_WIDTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_WIDTH},
    {"OCELOT_HISTFILEFLAGS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTFILEFLAGS},
    {"OCELOT_HISTFILESIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTFILESIZE},
    {"OCELOT_HISTORY_BACKGROUND_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_BACKGROUND_COLOR},
    {"OCELOT_HISTORY_BORDER_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_BORDER_COLOR},
    {"OCELOT_HISTORY_DETACHED", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED},
    {"OCELOT_HISTORY_FONT_FAMILY", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_FAMILY},
    {"OCELOT_HISTORY_FONT_SIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_SIZE},
    {"OCELOT_HISTORY_FONT_STYLE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_STYLE},
    {"OCELOT_HISTORY_FONT_WEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_WEIGHT},
    {"OCELOT_HISTORY_HEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_HEIGHT},
    {"OCELOT_HISTORY_LEFT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_LEFT},
    {"OCELOT_HISTORY_MAX_ROW_COUNT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_MAX_ROW_COUNT},
    {"OCELOT_HISTORY_TEXT_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_TEXT_COLOR},
    {"OCELOT_HISTORY_TOP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_TOP},
    {"OCELOT_HISTORY_WIDTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_WIDTH},
    {"OCELOT_HISTSIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTSIZE},
    {"OCELOT_HORIZONTAL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HORIZONTAL},
    {"OCELOT_HTML", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HTML},
    {"OCELOT_HTMLRAW", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HTMLRAW},
    {"OCELOT_IMPORT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_IMPORT}, /* if OCELOT_IMPORT_EXPORT == 1 */
    {"OCELOT_LANGUAGE", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_OCELOT_LANGUAGE},
    {"OCELOT_LOG_LEVEL", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_OCELOT_LOG_LEVEL},
    {"OCELOT_MENU_BACKGROUND_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_MENU_BACKGROUND_COLOR},
    {"OCELOT_MENU_BORDER_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_MENU_BORDER_COLOR},
    {"OCELOT_MENU_FONT_FAMILY", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_MENU_FONT_FAMILY},
    {"OCELOT_MENU_FONT_SIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_MENU_FONT_SIZE},
    {"OCELOT_MENU_FONT_STYLE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_MENU_FONT_STYLE},
    {"OCELOT_MENU_FONT_WEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_MENU_FONT_WEIGHT},
    {"OCELOT_MENU_TEXT_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_MENU_TEXT_COLOR},
    {"OCELOT_RAW", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_RAW},
    {"OCELOT_SHORTCUT_AUTOCOMPLETE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_AUTOCOMPLETE},
    {"OCELOT_SHORTCUT_BATCH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_BATCH},
    {"OCELOT_SHORTCUT_BREAKPOINT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_BREAKPOINT},
    {"OCELOT_SHORTCUT_CLEAR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_CLEAR},
    {"OCELOT_SHORTCUT_CONNECT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_CONNECT},
    {"OCELOT_SHORTCUT_CONTINUE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_CONTINUE},
    {"OCELOT_SHORTCUT_COPY", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_COPY},
    {"OCELOT_SHORTCUT_CUT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_CUT},
    {"OCELOT_SHORTCUT_DEBUG_EXIT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_DEBUG_EXIT},
    {"OCELOT_SHORTCUT_EXECUTE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_EXECUTE},
    {"OCELOT_SHORTCUT_EXIT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_EXIT},
    {"OCELOT_SHORTCUT_FIND", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_FIND},
    {"OCELOT_SHORTCUT_FORMAT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_FORMAT},
    {"OCELOT_SHORTCUT_HISTORY_MARKUP_NEXT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_NEXT},
    {"OCELOT_SHORTCUT_HISTORY_MARKUP_PREVIOUS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_PREVIOUS},
    {"OCELOT_SHORTCUT_HORIZONTAL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_HORIZONTAL},
    {"OCELOT_SHORTCUT_HTML", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_HTML},
    {"OCELOT_SHORTCUT_HTMLRAW", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_HTMLRAW},
    {"OCELOT_SHORTCUT_INFORMATION", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_INFORMATION},
    {"OCELOT_SHORTCUT_KILL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_KILL},
    {"OCELOT_SHORTCUT_NEXT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT},
    {"OCELOT_SHORTCUT_NEXT_WINDOW", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT_WINDOW},
    {"OCELOT_SHORTCUT_PASTE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_PASTE},
    {"OCELOT_SHORTCUT_PREVIOUS_WINDOW", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_PREVIOUS_WINDOW},
    {"OCELOT_SHORTCUT_RAW", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_RAW},
    {"OCELOT_SHORTCUT_REDO", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_REDO},
    {"OCELOT_SHORTCUT_REFRESH_CALL_STACK", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_CALL_STACK},
    {"OCELOT_SHORTCUT_REFRESH_SERVER_VARIABLES", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_SERVER_VARIABLES},
    {"OCELOT_SHORTCUT_REFRESH_USER_VARIABLES", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_USER_VARIABLES},
    {"OCELOT_SHORTCUT_REFRESH_VARIABLES", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_VARIABLES},
    {"OCELOT_SHORTCUT_SELECT_ALL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_SELECT_ALL},
    {"OCELOT_SHORTCUT_STEP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_STEP},
    {"OCELOT_SHORTCUT_UNDO", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_UNDO},
    {"OCELOT_SHORTCUT_VERTICAL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_VERTICAL},
    {"OCELOT_SHORTCUT_XML", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_XML},
    {"OCELOT_SHORTCUT_ZOOMIN", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMIN},
    {"OCELOT_SHORTCUT_ZOOMOUT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMOUT},
    {"OCELOT_STATEMENT_BACKGROUND_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_BACKGROUND_COLOR},
    {"OCELOT_STATEMENT_BORDER_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_BORDER_COLOR},
    {"OCELOT_STATEMENT_DETACHED", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED},
    {"OCELOT_STATEMENT_FONT_FAMILY", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_FAMILY},
    {"OCELOT_STATEMENT_FONT_SIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_SIZE},
    {"OCELOT_STATEMENT_FONT_STYLE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_STYLE},
    {"OCELOT_STATEMENT_FONT_WEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_WEIGHT},
    {"OCELOT_STATEMENT_FORMAT_CLAUSE_INDENT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_CLAUSE_INDENT},
    {"OCELOT_STATEMENT_FORMAT_RULE", 0, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_RULE},
    {"OCELOT_STATEMENT_FORMAT_STATEMENT_INDENT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_STATEMENT_INDENT},
    {"OCELOT_STATEMENT_HEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HEIGHT},
    {"OCELOT_STATEMENT_HIGHLIGHT_COMMENT_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_COMMENT_COLOR},
    {"OCELOT_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR},
    {"OCELOT_STATEMENT_HIGHLIGHT_FUNCTION_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_FUNCTION_COLOR},
    {"OCELOT_STATEMENT_HIGHLIGHT_IDENTIFIER_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_IDENTIFIER_COLOR},
    {"OCELOT_STATEMENT_HIGHLIGHT_KEYWORD_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_KEYWORD_COLOR},
    {"OCELOT_STATEMENT_HIGHLIGHT_LITERAL_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_LITERAL_COLOR},
    {"OCELOT_STATEMENT_HIGHLIGHT_OPERATOR_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_OPERATOR_COLOR},
    {"OCELOT_STATEMENT_LEFT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_LEFT},
    {"OCELOT_STATEMENT_PROMPT_BACKGROUND_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_PROMPT_BACKGROUND_COLOR},
    {"OCELOT_STATEMENT_SYNTAX_CHECKER", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_SYNTAX_CHECKER},
    {"OCELOT_STATEMENT_TEXT_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_TEXT_COLOR},
    {"OCELOT_STATEMENT_TOP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_TOP},
    {"OCELOT_STATEMENT_WIDTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_WIDTH},
    {"OCELOT_VERTICAL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_VERTICAL},
    {"OCELOT_XML", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_XML},

      {"OCT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_OCT},
      {"OCTET_LENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_OCTET_LENGTH},
      {"OF", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_OF},
      {"OFF", 0, 0, TOKEN_KEYWORD_OFF},
      {"OFFSET", 0, 0, TOKEN_KEYWORD_OFFSET},
      {"OJ", 0, 0, TOKEN_KEYWORD_OJ},
      {"OLD_PASSWORD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_OLD_PASSWORD},
      {"ON", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ON},
        {"ONE_DATABASE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_ONE_DATABASE},
      {"OPEN", 0, 0, TOKEN_KEYWORD_OPEN},
      {"OPERATOR", 0, 0, TOKEN_KEYWORD_OPERATOR}, /* for format rule */
      {"OPTIMIZE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_OPTIMIZE},
      {"OPTIMIZER_COSTS", FLAG_VERSION_MYSQL_5_7, 0, TOKEN_KEYWORD_OPTIMIZER_COSTS},
      {"OPTION", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_OPTION},
      {"OPTIONALLY", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_OPTIONALLY},
      {"OR", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_OR},
      {"ORD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ORD},
      {"ORDER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ORDER},
      {"OUT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_OUT},
      {"OUTER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_OUTER},
      {"OUTFILE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_OUTFILE},
      {"OVER", FLAG_VERSION_MYSQL_8_0 | FLAG_VERSION_TARANTOOL | FLAG_VERSION_MARIADB_10_2_2, 0, TOKEN_KEYWORD_OVER},
      {"OVERLAPS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_OVERLAPS}, /* deprecated in MySQL 5.7.6 */
      {"PACKAGE", FLAG_VERSION_PLSQL, 0, TOKEN_KEYWORD_PACKAGE},
      {"PAGER", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_PAGER}, /* ocelotgui keyword */
      {"PARSER_TRACE", 0, 0, TOKEN_KEYWORD_PARSER_TRACE},
      {"PARTIAL", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_PARTIAL},
      {"PARTITION", FLAG_VERSION_TARANTOOL | FLAG_VERSION_MYSQL_5_6 | FLAG_VERSION_MARIADB_10_0, 0, TOKEN_KEYWORD_PARTITION},
      {"PASSWORD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_OPTION, TOKEN_KEYWORD_PASSWORD}, /* deprecated in MySQL 5.7.6 */
      {"PERCENTILE_CONT", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_PERCENTILE_CONT}, /* MariaDB 10.2 nonreserved -- or, maybe not in MariaDB 10.2 */
      {"PERCENTILE_DISC", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_PERCENTILE_DISC}, /* MariaDB 10.2 nonreserved -- or, maybe not in MariaDB 10.2 */
      {"PERCENT_RANK", FLAG_VERSION_MYSQL_8_0, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_2_2, TOKEN_KEYWORD_PERCENT_RANK},
      {"PERIOD_ADD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_PERIOD_ADD},
      {"PERIOD_DIFF", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_PERIOD_DIFF},
    {"PERSIST", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_PERSIST},
    {"PERSIST_ONLY", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_PERSIST_ONLY},
          {"PERSIST_RO_VARIABLES_ADMIN", 0, 0, TOKEN_KEYWORD_PERSIST_RO_VARIABLES_ADMIN},
      {"PI", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_PI},
        {"PIPE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_PIPE},
      {"PLAN", 0, 0, TOKEN_KEYWORD_PLAN},
        {"PLUGIN_DIR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_PLUGIN_DIR},
      {"POINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POINT},
      {"POINTFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POINTFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"POINTFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POINTFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"POINTN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POINTN}, /* deprecated in MySQL 5.7.6 */
      {"POLYFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POLYFROMTEXT},
      {"POLYFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POLYFROMWKB}, /* deprecated in MySQL 5.7 */
      {"POLYGON", 0, 0, TOKEN_KEYWORD_POLYGON},
      {"POLYGONFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POLYGONFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"POLYGONFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POLYGONFROMWKB}, /* deprecated in MySQL 5.7.6 */
        {"PORT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_PORT},
      {"POSITION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POSITION},
      {"POW", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POW},
      {"POWER", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POWER},
      {"PRAGMA", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_PRAGMA},
      {"PRECEDES", FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, 0, TOKEN_KEYWORD_PRECEDES},
      {"PRECISION", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_PRECISION},
      {"PREPARE", 0, 0, TOKEN_KEYWORD_PREPARE},
      {"PRIMARY", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_PRIMARY},
      {"PRINT", 0, 0, TOKEN_KEYWORD_PRINT}, /* ocelotgui keyword */
      {"PRINTF", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_PRINTF},
        {"PRINT_DEFAULTS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_PRINT_DEFAULTS},
      {"PROCEDURE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_PROCEDURE},
      {"PROCESS", 0, 0, TOKEN_KEYWORD_PROCESS},
      {"PROMPT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_PROMPT}, /* ocelotgui keyword */
        {"PROTOCOL", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_PROTOCOL},
      {"PROXY", 0, 0, TOKEN_KEYWORD_PROXY},
      {"PURGE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_PURGE},
      {"QUARTER", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_QUARTER},
      {"QUERY", 0, 0, TOKEN_KEYWORD_QUERY},
        {"QUICK", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_QUICK},
      {"QUIT", 0, 0, TOKEN_KEYWORD_QUIT}, /* ocelotgui keyword */
      {"QUOTE", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_QUOTE},
      {"RADIANS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_RADIANS},
      {"RAISE", FLAG_VERSION_PLSQL, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_RAISE},
      {"RAND", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_RAND},
      {"RANDOM", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_RANDOM},
      {"RANDOMBLOB", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_RANDOMBLOB},
      {"RANDOM_BYTES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_RANDOM_BYTES},
      {"RANGE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_RANGE},
      {"RANK", FLAG_VERSION_MYSQL_8_0, FLAG_VERSION_MYSQL_8_0 | FLAG_VERSION_TARANTOOL | FLAG_VERSION_MARIADB_10_2_2, TOKEN_KEYWORD_RANK},
      {"RAW", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_RAW},
      {"READ", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_READ},
      {"READS", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_READS},
    {"READ_DEFAULT_FILE", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_READ_DEFAULT_FILE},
    {"READ_DEFAULT_GROUP", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_READ_DEFAULT_GROUP},
    {"READ_TIMEOUT", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_READ_TIMEOUT},
      {"READ_WRITE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_READ_WRITE},
      {"REAL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_REAL},
      {"REBUILD", 0, 0, TOKEN_KEYWORD_REBUILD},
        {"RECONNECT", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_RECONNECT},
      {"RECURSIVE", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_2_2|FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_RECURSIVE},
    {"REDOFILE", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_REDOFILE},
      {"REDUNDANT", 0, 0, TOKEN_KEYWORD_REDUNDANT},
      {"REFERENCES", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_REFERENCES},
      {"REGEXP", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_REGEXP},
      {"REHASH", 0, 0, TOKEN_KEYWORD_REHASH}, /* ocelotgui keyword */
      {"RELEASE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_RELEASE},
      {"RELEASE_ALL_LOCKS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_RELEASE_ALL_LOCKS},
      {"RELEASE_LOCK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_RELEASE_LOCK},
      {"RELOAD", 0, 0, TOKEN_KEYWORD_RELOAD},
      {"RENAME", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_RENAME},
      {"REORGANIZE", 0, 0, TOKEN_KEYWORD_REORGANIZE},
      {"REPAIR", 0, 0, TOKEN_KEYWORD_REPAIR},
      {"REPEAT", FLAG_VERSION_ALL | FLAG_VERSION_LUA, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_REPEAT},
      {"REPLACE", FLAG_VERSION_ALL, FLAG_VERSION_ALL, TOKEN_KEYWORD_REPLACE},
      {"REPLICATION", 0, 0, TOKEN_KEYWORD_REPLICATION},
          {"REPLICATION_SLAVE_ADMIN", 0, 0, TOKEN_KEYWORD_REPLICATION_SLAVE_ADMIN},
        {"REPORT_DATA_TRUNCATION", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_REPORT_DATA_TRUNCATION},
      {"REQUIRE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_REQUIRE},
      {"RESET", 0, 0, TOKEN_KEYWORD_RESET},
      {"RESETCONNECTION", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_RESETCONNECTION},
      {"RESIGNAL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_RESIGNAL},
          {"RESOURCE_GROUP_ADMIN", 0, 0, TOKEN_KEYWORD_RESOURCE_GROUP_ADMIN},
          {"RESOURCE_GROUP_USER", 0, 0, TOKEN_KEYWORD_RESOURCE_GROUP_USER},
      {"RESTRICT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_RESTRICT},
      {"RETURN", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_RETURN},
      {"RETURNS", 0, 0, TOKEN_KEYWORD_RETURNS},
      {"REVERSE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_REVERSE},
      {"REVOKE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_REVOKE},
      {"RIGHT", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_RIGHT},
      {"RLIKE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_RLIKE},
      {"ROLE", 0, 0, TOKEN_KEYWORD_ROLE},
          {"ROLE_ADMIN", 0, 0, TOKEN_KEYWORD_ROLE_ADMIN},
      {"ROLLBACK", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_ROLLBACK},
      {"ROUND", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_ROUND},
      {"ROW", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_ROW},
      {"ROWS", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_ROWS},
      {"ROWTYPE", FLAG_VERSION_PLSQL, 0, TOKEN_KEYWORD_ROWTYPE},
      {"ROW_COUNT", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_ROW_COUNT},
      {"ROW_NUMBER", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_TARANTOOL, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_2_2, TOKEN_KEYWORD_ROW_NUMBER},
      {"RPAD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_RPAD},
      {"RTRIM", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_RTRIM},
        {"SAFE_UPDATES", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SAFE_UPDATES},
      {"SAVEPOINT", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_SAVEPOINT},
      {"SCALAR", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_SCALAR},
      {"SCHEMA", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SCHEMA},
      {"SCHEMAS", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SCHEMAS},
      {"SECOND", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SECOND},
      {"SECOND_MICROSECOND", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SECOND_MICROSECOND},
        {"SECURE_AUTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SECURE_AUTH},
      {"SECURITY", 0, 0, TOKEN_KEYWORD_SECURITY},
      {"SEC_TO_TIME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SEC_TO_TIME},
      {"SELECT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_SELECT},
        {"SELECT_LIMIT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SELECT_LIMIT},
      {"SEMICOLON", 0, 0, TOKEN_KEYWORD_SEMICOLON}, /* for format rule */
      {"SENSITIVE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_SENSITIVE},
      {"SEPARATOR", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SEPARATOR},
      {"SEQUENCE", 0, 0, TOKEN_KEYWORD_SEQUENCE},
      {"SERIAL", 0, 0, TOKEN_KEYWORD_SERIAL},
      {"SERVER", 0, 0, TOKEN_KEYWORD_SERVER},
        {"SERVER_PUBLIC_KEY", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SERVER_PUBLIC_KEY},
      {"SESSION", FLAG_VERSION_TARANTOOL_2_4, 0, TOKEN_KEYWORD_SESSION},
      {"SESSION_USER", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SESSION_USER},
      {"SET", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_SET},
      {"SETVAL", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_SETVAL},
          {"SET_USER_ID", 0, 0, TOKEN_KEYWORD_SET_USER_ID},
      {"SHA", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SHA},
      {"SHA1", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SHA1},
      {"SHA2", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SHA2},
      {"SHARED", 0, 0, TOKEN_KEYWORD_SHARED},
        {"SHARED_MEMORY_BASE_NAME", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SHARED_MEMORY_BASE_NAME},
      {"SHOW", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SHOW},
        {"SHOW_WARNINGS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SHOW_WARNINGS},
      {"SHUTDOWN", 0, 0, TOKEN_KEYWORD_SHUTDOWN},
        {"SIGINT_IGNORE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SIGINT_IGNORE},
      {"SIGN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SIGN},
      {"SIGNAL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_SIGNAL},
      {"SIGNED", 0, 0, TOKEN_KEYWORD_SIGNED},
        {"SILENT", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_SILENT},
      {"SIMPLE", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_SIMPLE},
      {"SIN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SIN},
      {"SLEEP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SLEEP},
      {"SLOW", 0, 0, TOKEN_KEYWORD_SLOW},
      {"SMALLINT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_SMALLINT},
        {"SOCKET", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SOCKET},
      {"SONAME", 0, 0, TOKEN_KEYWORD_SONAME},
      {"SOUNDEX", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SOUNDEX},
      {"SOURCE", 0, 0, TOKEN_KEYWORD_SOURCE}, /* ocelotgui keyword */
      {"SPACE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SPACE},
      {"SPATIAL", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SPATIAL},
      {"SPECIFIC", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_SPECIFIC},
      {"SQL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_SQL},
      {"SQLEXCEPTION", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SQLEXCEPTION},
      {"SQLSTATE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SQLSTATE},
      {"SQLWARNING", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SQLWARNING},
      {"SQL_BIG_RESULT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SQL_BIG_RESULT},
      {"SQL_CALC_FOUND_ROWS", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SQL_CALC_FOUND_ROWS},
      {"SQL_COMPOUND_SELECT_LIMIT", 0, 0, TOKEN_KEYWORD_SQL_COMPOUND_SELECT_LIMIT},
      {"SQL_DEFAULT_ENGINE", 0, 0, TOKEN_KEYWORD_SQL_DEFAULT_ENGINE},
      {"SQL_SMALL_RESULT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SQL_SMALL_RESULT},
      {"SQRT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SQRT},
      {"SRID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SRID},
      {"SSL", FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL},
    {"SSL_CA", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_CA},
    {"SSL_CAPATH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_CAPATH},
    {"SSL_CERT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_CERT},
    {"SSL_CIPHER", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_CIPHER},
    {"SSL_CRL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_CRL},
    {"SSL_CRLPATH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_CRLPATH},
    {"SSL_KEY", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_KEY},
    {"SSL_MODE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_MODE},
    {"SSL_VERIFY", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_SSL_VERIFY},
    {"SSL_VERIFY_SERVER_CERT", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_SSL_VERIFY_SERVER_CERT},
          {"START", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_START},
      {"STARTING", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_STARTING},
      {"STARTPOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_STARTPOINT}, /* deprecated in MySQL 5.7.6 */
      {"STATEMENT", 0, 0, TOKEN_KEYWORD_STATEMENT},
      {"STATS", 0, 0, TOKEN_KEYWORD_STATS},
      {"STATUS", 0, 0, TOKEN_KEYWORD_STATUS}, /* ocelotgui keyword */
      {"STD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_STD},
      {"STDDEV", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_STDDEV},
      {"STDDEV_POP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_STDDEV_POP},
      {"STDDEV_SAMP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_STDDEV_SAMP},
      {"STDOUT", 0, 0, TOKEN_KEYWORD_STDOUT},
      {"STOP", 0, 0, TOKEN_KEYWORD_STOP},
      {"STORED", FLAG_VERSION_MYSQL_5_7, 0, TOKEN_KEYWORD_STORED},
      {"STRAIGHT_JOIN", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_STRAIGHT_JOIN},
      {"STRCMP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_STRCMP},
      {"STRFTIME", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_STRFTIME},
      {"STRING", FLAG_VERSION_TARANTOOL_2_2, 0, TOKEN_KEYWORD_STRING},
      {"STR_TO_DATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_STR_TO_DATE},
      {"ST_AREA", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_AREA},
      {"ST_ASBINARY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ASBINARY},
      {"ST_ASGEOJSON", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ASGEOJSON},
      {"ST_ASTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ASTEXT},
      {"ST_ASWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ASWKB},
      {"ST_ASWKT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ASWKT},
      {"ST_BUFFER", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_BUFFER},
      {"ST_BUFFER_STRATEGY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_BUFFER_STRATEGY},
      {"ST_CENTROID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_CENTROID},
      {"ST_CONTAINS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_CONTAINS},
      {"ST_CONVEXHULL", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_CONVEXHULL},
      {"ST_CROSSES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_CROSSES},
      {"ST_DIFFERENCE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_DIFFERENCE},
      {"ST_DIMENSION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_DIMENSION},
      {"ST_DISJOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_DISJOINT},
      {"ST_DISTANCE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_DISTANCE},
      {"ST_DISTANCE_SPHERE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_DISTANCE_SPHERE},
      {"ST_ENDPOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ENDPOINT},
      {"ST_ENVELOPE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ENVELOPE},
      {"ST_EQUALS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_EQUALS},
      {"ST_EXTERIORRING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_EXTERIORRING},
      {"ST_GEOHASH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOHASH},
      {"ST_GEOMCOLLFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMCOLLFROMTEXT},
      {"ST_GEOMCOLLFROMTXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMCOLLFROMTXT},
      {"ST_GEOMCOLLFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMCOLLFROMWKB},
      {"ST_GEOMETRYCOLLECTIONFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMETRYCOLLECTIONFROMTEXT},
      {"ST_GEOMETRYCOLLECTIONFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMETRYCOLLECTIONFROMWKB},
      {"ST_GEOMETRYFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMETRYFROMTEXT},
      {"ST_GEOMETRYFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMETRYFROMWKB},
      {"ST_GEOMETRYN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMETRYN},
      {"ST_GEOMETRYTYPE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMETRYTYPE},
      {"ST_GEOMFROMGEOJSON", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMFROMGEOJSON},
      {"ST_GEOMFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMFROMTEXT},
      {"ST_GEOMFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMFROMWKB},
      {"ST_INTERIORRINGN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_INTERIORRINGN},
      {"ST_INTERSECTION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_INTERSECTION},
      {"ST_INTERSECTS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_INTERSECTS},
      {"ST_ISCLOSED", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ISCLOSED},
      {"ST_ISEMPTY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ISEMPTY},
      {"ST_ISSIMPLE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ISSIMPLE},
      {"ST_ISVALID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ISVALID},
      {"ST_LATFROMGEOHASH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_LATFROMGEOHASH},
      {"ST_LENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_LENGTH},
      {"ST_LINEFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_LINEFROMTEXT},
      {"ST_LINEFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_LINEFROMWKB},
      {"ST_LINESTRINGFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_LINESTRINGFROMTEXT},
      {"ST_LINESTRINGFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_LINESTRINGFROMWKB},
      {"ST_LONGFROMGEOHASH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_LONGFROMGEOHASH},
      {"ST_MAKEENVELOPE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MAKEENVELOPE},
      {"ST_MLINEFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MLINEFROMTEXT},
      {"ST_MLINEFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MLINEFROMWKB},
      {"ST_MPOINTFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MPOINTFROMTEXT},
      {"ST_MPOINTFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MPOINTFROMWKB},
      {"ST_MPOLYFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MPOLYFROMTEXT},
      {"ST_MPOLYFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MPOLYFROMWKB},
      {"ST_MULTILINESTRINGFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MULTILINESTRINGFROMTEXT},
      {"ST_MULTILINESTRINGFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MULTILINESTRINGFROMWKB},
      {"ST_MULTIPOINTFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MULTIPOINTFROMTEXT},
      {"ST_MULTIPOINTFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MULTIPOINTFROMWKB},
      {"ST_MULTIPOLYGONFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MULTIPOLYGONFROMTEXT},
      {"ST_MULTIPOLYGONFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MULTIPOLYGONFROMWKB},
      {"ST_NUMGEOMETRIES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_NUMGEOMETRIES},
      {"ST_NUMINTERIORRING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_NUMINTERIORRING},
      {"ST_NUMINTERIORRINGS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_NUMINTERIORRINGS},
      {"ST_NUMPOINTS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_NUMPOINTS},
      {"ST_OVERLAPS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_OVERLAPS},
      {"ST_POINTFROMGEOHASH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POINTFROMGEOHASH},
      {"ST_POINTFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POINTFROMTEXT},
      {"ST_POINTFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POINTFROMWKB},
      {"ST_POINTN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POINTN},
      {"ST_POLYFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POLYFROMTEXT},
      {"ST_POLYFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POLYFROMWKB},
      {"ST_POLYGONFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POLYGONFROMTEXT},
      {"ST_POLYGONFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POLYGONFROMWKB},
      {"ST_SIMPLIFY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_SIMPLIFY},
      {"ST_SRID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_SRID},
      {"ST_STARTPOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_STARTPOINT},
      {"ST_SYMDIFFERENCE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_SYMDIFFERENCE},
      {"ST_TOUCHES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_TOUCHES},
      {"ST_UNION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_UNION},
      {"ST_VALIDATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_VALIDATE},
      {"ST_WITHIN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_WITHIN},
      {"ST_X", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_X},
      {"ST_Y", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_Y},
      {"SUBDATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SUBDATE},
      {"SUBSTR", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_SUBSTR},
      {"SUBSTRING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SUBSTRING},
      {"SUBSTRING_INDEX", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SUBSTRING_INDEX},
      {"SUBTIME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SUBTIME},
      {"SUM", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_SUM},
      {"SUPER", 0, 0, TOKEN_KEYWORD_SUPER},
      {"SYSDATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SYSDATE},
        {"SYSLOG", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SYSLOG},
      {"SYSTEM", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_SYSTEM}, /* ocelotgui keyword */
      {"SYSTEM_USER", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SYSTEM_USER},
          {"SYSTEM_VARIABLES_ADMIN", 0, 0, TOKEN_KEYWORD_SYSTEM_VARIABLES_ADMIN},
      {"TAB", 0, 0, TOKEN_KEYWORD_TAB}, /* for format rule */
      {"TABLE", FLAG_VERSION_ALL | FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_TABLE},
      {"TABLESPACE", 0, 0, TOKEN_KEYWORD_TABLESPACE},
      {"TABLE_INFO", 0, 0, TOKEN_KEYWORD_TABLE_INFO},
      {"TAN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TAN},
      {"TEE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_TEE}, /* ocelotgui keyword */
      {"TEMP", 0, 0, TOKEN_KEYWORD_TEMP},
      {"TEMPORARY", 0, 0, TOKEN_KEYWORD_TEMPORARY},
      {"TERMINATED", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_TERMINATED},
      {"TEXT", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_TEXT},
      {"THEN", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_THEN},
      {"TIME", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_TIME},
      {"TIMEDIFF", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TIMEDIFF},
      {"TIMESTAMP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TIMESTAMP},
      {"TIMESTAMPADD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TIMESTAMPADD},
      {"TIMESTAMPDIFF", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TIMESTAMPDIFF},
      {"TIME_FORMAT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TIME_FORMAT},
      {"TIME_TO_SEC", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TIME_TO_SEC},
      {"TINYBLOB", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_TINYBLOB},
      {"TINYINT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_TINYINT},
      {"TINYTEXT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_TINYTEXT},
      {"TO", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_TO},
      {"TOUCHES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TOUCHES}, /* deprecated in MySQL 5.7.6 */
      {"TO_BASE64", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TO_BASE64},
      {"TO_DAYS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TO_DAYS},
      {"TO_SECONDS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TO_SECONDS},
      {"TRAILING", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_TRAILING},
      {"TRANSACTION", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_TRANSACTION},
      {"TRIGGER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_TRIGGER},
      {"TRIM", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_TRIM},
      {"TRUE", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_TRUE},
      {"TRUNCATE", FLAG_VERSION_TARANTOOL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TRUNCATE},
      {"TYPE", 0, 0, TOKEN_KEYWORD_TYPE},
      {"TYPEOF", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_TYPEOF},
      {"UCASE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UCASE},
      {"UNBOUNDED", 0, 0, TOKEN_KEYWORD_UNBOUNDED},
        {"UNBUFFERED", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_UNBUFFERED},
      {"UNCOMPRESS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UNCOMPRESS},
      {"UNCOMPRESSED_LENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UNCOMPRESSED_LENGTH},
      {"UNDO", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_UNDO},
      {"UNHEX", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UNHEX},
      {"UNICODE", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_UNICODE},
      {"UNINSTALL", 0, 0, TOKEN_KEYWORD_UNINSTALL},
      {"UNION", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_UNION},
      {"UNIQUE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_UNIQUE},
      {"UNIX_TIMESTAMP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UNIX_TIMESTAMP},
      {"UNKNOWN", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_UNKNOWN},
      {"UNLOCK", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_UNLOCK},
      {"UNSIGNED", FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_TARANTOOL_2_2, 0, TOKEN_KEYWORD_UNSIGNED},
      {"UNTIL", FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_UNTIL},
      {"UPDATE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_UPDATE},
      {"UPDATEXML", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UPDATEXML},
      {"UPPER", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_UPPER},
      {"USAGE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_USAGE},
      {"USE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_USE}, /* ocelotgui keyword, also reserved word */
      {"USER", FLAG_VERSION_TARANTOOL | FLAG_VERSION_OPTION, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_USER},
        {"USE_RESULT", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_USE_RESULT},
      {"USING", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_USING},
      {"UTC_DATE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UTC_DATE},
      {"UTC_TIME", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UTC_TIME},
      {"UTC_TIMESTAMP", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UTC_TIMESTAMP},
      {"UUID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UUID},
      {"UUID_SHORT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UUID_SHORT},
      {"VACUUM", 0, 0, TOKEN_KEYWORD_VACUUM},
      {"VALIDATE_PASSWORD_STRENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_VALIDATE_PASSWORD_STRENGTH},
      {"VALIDATION", 0, 0, TOKEN_KEYWORD_VALIDATION},
      {"VALUE", 0, 0, TOKEN_KEYWORD_VALUE},
      {"VALUES", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_VALUES},
      {"VARBINARY", FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_TARANTOOL_2_2, 0, TOKEN_KEYWORD_VARBINARY},
      {"VARCHAR", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_VARCHAR},
      {"VARCHAR2", 0, 0, TOKEN_KEYWORD_VARCHAR2},
      {"VARCHARACTER", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_VARCHARACTER},
      {"VARIANCE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_VARIANCE},
      {"VARYING", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_VARYING},
      {"VAR_POP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_VAR_POP},
      {"VAR_SAMP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_VAR_SAMP},
        {"VERBOSE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_VERBOSE},
      {"VERSION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_OPTION, TOKEN_KEYWORD_VERSION},
          {"VERSION_TOKEN_ADMIN", 0, 0, TOKEN_KEYWORD_VERSION_TOKEN_ADMIN},
        {"VERTICAL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_VERTICAL},
      {"VIEW", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_VIEW},
      {"VIRTUAL", FLAG_VERSION_MYSQL_5_7, 0, TOKEN_KEYWORD_VIRTUAL},
        {"WAIT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_WAIT},
      {"WAIT_FOR_EXECUTED_GTID_SET", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_WAIT_FOR_EXECUTED_GTID_SET},
      {"WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS},
      {"WARNINGS", 0, 0, TOKEN_KEYWORD_WARNINGS}, /* ocelotgui keyword */
      {"WEEK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_WEEK},
      {"WEEKDAY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_WEEKDAY},
      {"WEEKOFYEAR", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_WEEKOFYEAR},
      {"WEIGHT_STRING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_WEIGHT_STRING},
      {"WHEN", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_WHEN},
      {"WHENEVER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_WHENEVER},
      {"WHERE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_WHERE},
      {"WHILE", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_WHILE},
    {"WINDOW", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_WINDOW},
      {"WITH", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_WITH},
      {"WITHIN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_WITHIN}, /* deprecated in MySQL 5.7.6 */
      {"WITHOUT", 0, 0, TOKEN_KEYWORD_WITHOUT},
      {"WRITE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_WRITE},
        {"WRITE_TIMEOUT", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_WRITE_TIMEOUT},
      {"X", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_X}, /* deprecated in MySQL 5.7.6 */
      {"XA", 0, 0, TOKEN_KEYWORD_XA},
          {"XA_RECOVER_ADMIN", 0, 0, TOKEN_KEYWORD_XA_RECOVER_ADMIN},
        {"XML", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_XML},
      {"XOR", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_XOR},
      {"Y", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_Y}, /* deprecated in MySQL 5.7.6 */
      {"YEAR", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_YEAR},
      {"YEARWEEK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_YEARWEEK},
      {"YEAR_MONTH", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_YEAR_MONTH},
      {"ZEROFILL", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_ZEROFILL},
      {"_ARMSCII8", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__ARMSCII8},
      {"_ASCII", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__ASCII},
      {"_BIG5", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__BIG5},
      {"_BINARY", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__BINARY},
      {"_CP1250", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP1250},
      {"_CP1251", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP1251},
      {"_CP1256", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP1256},
      {"_CP1257", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP1257},
      {"_CP850", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP850},
      {"_CP852", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP852},
      {"_CP866", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP866},
      {"_CP932", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP932},
      {"_DEC8", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__DEC8},
      {"_EUCJPMS", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__EUCJPMS},
      {"_EUCKR", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__EUCKR},
      {"_FILENAME", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__FILENAME},
      {"_GB18030", FLAG_VERSION_MYSQL_5_7, 0, TOKEN_KEYWORD__GB18030},
      {"_GB2312", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__GB2312},
      {"_GBK", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__GBK},
      {"_GEOSTD8", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__GEOSTD8},
      {"_GREEK", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__GREEK},
      {"_HEBREW", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__HEBREW},
      {"_HP8", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__HP8},
      {"_KEYBCS2", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__KEYBCS2},
      {"_KOI8R", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__KOI8R},
      {"_KOI8U", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__KOI8U},
      {"_LATIN1", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__LATIN1},
      {"_LATIN2", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__LATIN2},
      {"_LATIN5", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__LATIN5},
      {"_LATIN7", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__LATIN7},
      {"_MACCE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__MACCE},
      {"_MACROMAN", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__MACROMAN},
      {"_SJIS", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__SJIS},
      {"_SWE7", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__SWE7},
      {"_TIS620", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__TIS620},
      {"_UCS2", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__UCS2},
      {"_UJIS", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__UJIS},
      {"_UTF16", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__UTF16},
      {"_UTF16LE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__UTF16LE},
      {"_UTF32", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__UTF32},
      {"_UTF8", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__UTF8},
      {"_UTF8MB4", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__UTF8MB4}
    };

/* For talk about fontweightsvalues see "Font comments" */

struct fontweights {
   char  chars[12];
   char  alternate_chars[12];
   unsigned int qt_number;
   unsigned int css_number;
};
static const fontweights fontweightsvalues[]=
  {
    {"thin", "", 0, 100}, /* QFont::Thin */
    {"extralight", "", 12, 200}, /* QFont::ExtraLight */ /* though an Internet site says extralight is 250 */
    /* Ubuntu Light is 18 but an Internet site says the css value is 200 */
    {"light", "", 25, 300}, /* QFont::Light */
    /* "semilight" would be between light and book says an Internet site */
    /* URW Gothic Book is 45 and an Internet site says book=350 */
    {"normal", "regular", 50, 400}, /* QFont::Normal */
    {"medium", "dark", 57, 500}, /* QFont::Medium */
    {"demibold", "demi", 63, 600}, /* QFont::DemiBold */ /* todo: should we allow for aka semibold? */
    {"bold", "", 75, 700}, /* QFont::Bold */
    {"extrabold", "ultrabold", 81, 800}, /* QFont::ExtraBold */
    {"black", "heavy", 87, 900},   /* QFont::Black */ /* alternate_chars == "heavy" might be wrong */
    {"extrablack", "ultrablack", 93, 950}, /* no enum but documented for Qt 6.x so I guessed 93 */
  };
#define FONTWEIGHTSVALUES_SIZE 10 /* # of entries in fontweightsvalues */

#ifndef MAINWINDOW_H
#define MAINWINDOW_H

/* All Qt includes go here. Most of them could be handled by just saying "#include <QtWidgets>". */
#include <QAbstractItemView>
#ifdef OCELOT_OS_NONLINUX
#include <QApplication>
#endif
#include <QBuffer>             /* only needed for pasting pixmaps to QByteArray */
#include <QClipboard>
#include <QComboBox>
#include <QDateTime>
#include <QDialog>
#include <QDir>
#include <QElapsedTimer>        /* only needed for log(), and even for that it's not needed much */
#include <QFrame>
#include <QHBoxLayout>
#include <QLabel>
#include <QSpinBox>
#ifdef OCELOT_OS_NONLINUX
#include <QLibrary>
#endif
//#include <QLibraryInfo>
#include <QLineEdit>
#include <QMainWindow>
#include <QMessageBox>
#include <QPainter>
#include <QPlainTextEdit>
#include <QPushButton>
#include <QScrollArea>
#include <QScrollBar>
#include <QTextBlock>
#include <QTextEdit>
#include <QThread>
#include <QTimer>
//#include <QWidget>
#include <QTextStream>
#if (QT_VERSION >= 0x50000)
#include <QGuiApplication>
#include <QScreen>
#include <QRegularExpression>
#else
#include <QDesktopWidget>
#endif
#if (OCELOT_FIND_WIDGET == 1)
#include <QToolButton>
#endif

/* QRegExp is unavailable in Qt 6. Todo: We have never tested the replacemnt QRegularExpression code. */
#if (QT_VERSION < 0x60000)
#include <QRegExp>
#endif

#if (OCELOT_IMPORT_EXPORT == 1)
#endif

#if (OCELOT_MYSQL_INCLUDE == 1)
/* Several possible include paths for mysql.h are hard coded in ocelotgui.pro. */
#include <mysql.h>
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

/*
  my_bool might not be in mysql.h due to https://bugs.mysql.com/bug.php?id=85131
  MariaDB: my_bool STDCALL mysql_more_results(MYSQL *mysql);
  MySQL:   bool STDCALL mysql_more_results(MYSQL *mysql);
  I cannot use ifndef to see whether my_bool was used, it is a typedef.
  So I will use MY_BOOL instead of my_bool or bool, for mysql_more_results.
*/
typedef char MY_BOOL;

/* Strangely MYSQL_PORT might not be brought in by #include <mysql.h> */
/* Now in MariaDB there's a MARIADB_PORT, but it's 3306 anyway. */
#ifndef MYSQL_PORT
#define MYSQL_PORT 3306
#endif

/*
  Linux-specific:
  We use dlopen() when opening libmysqlclient.so and libcrypto.so, therefore include dlfcn.h.
  We use dlinfo() to find the libmysqlclient file name for help|about, therefore include link.h.
  We use readlink() when checking if histfile links to dev/null, therefore include unistd.h.
  We use getpwuid() when getting password, therefore include pwd.h.
  We use pthread_create() for debug and kill, therefore include pthread.h.
  We use stat() to see if a configuration file is world-writable, therefore include stat.h.
  Todo: There was no error when I didn't do this for FreeBSD. Is it using Qt library and surviving?
*/
#if (defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD))
#include <dlfcn.h>
#if (OCELOT_STATIC_LIBRARY == 0)
#include <link.h>
#endif
#include <unistd.h>
#include <pwd.h>
#include <pthread.h>
#include <sys/stat.h>
#endif

#ifdef DBMS_TARANTOOL

#if (OCELOT_THIRD_PARTY==1)
#include "third_party.h"
#else
/*
  Definitions of tnt_opt_type and tnt_reply are taken from tarantool-c.
  Although there is no copyright, there is a request for an AS IS notice (which is done)
*/
  enum tnt_opt_type {
          TNT_OPT_URI,
          TNT_OPT_TMOUT_CONNECT,
          TNT_OPT_TMOUT_RECV,
          TNT_OPT_TMOUT_SEND,
          TNT_OPT_SEND_CB,
          TNT_OPT_SEND_CBV,
          TNT_OPT_SEND_CB_ARG,
          TNT_OPT_SEND_BUF,
          TNT_OPT_RECV_CB,
          TNT_OPT_RECV_CB_ARG,
          TNT_OPT_RECV_BUF
  };
  struct tnt_reply {
          int alloc;
          uint64_t bitmap;
          const char *buf;
          size_t buf_size;
          uint64_t code;
          uint64_t sync;
          uint64_t schema_id;
          const char *error;
          const char *error_end;
          const char *data;
          const char *data_end;
          const char *metadata; /* new */
          const char *metadata_end; /* new */
          const char *sqlinfo; /* new */
          const char *sqlinfo_end; /* new */
  };
  /* Amazing but true: write_request was silently added after release! */
  struct tnt_stream {
          int alloc; /*!< Allocation mark */
          ssize_t (*write)(struct tnt_stream *s, const char *buf, size_t size); /*!< write to buffer function */
          ssize_t (*writev)(struct tnt_stream *s, struct iovec *iov, int count); /*!< writev function */
          ssize_t (*write_request)(struct tnt_stream *s, struct tnt_request *r, uint64_t *sync); /*!< write request function */
          ssize_t (*read)(struct tnt_stream *s, char *buf, size_t size); /*!< read from buffer function */
          int (*read_reply)(struct tnt_stream *s, struct tnt_reply *r); /*!< read reply from buffer */
          void (*free)(struct tnt_stream *s); /*!< free custom buffer types (destructor) */
          void *data; /*!< subclass data */
          uint32_t wrcnt; /*!< count of write operations */
          uint64_t reqid; /*!< request id of current operation */
  };

  enum  	mp_type {
    MP_NIL = 0, MP_UINT, MP_INT, MP_STR,
    MP_BIN, MP_ARRAY, MP_MAP, MP_BOOL,
    MP_FLOAT, MP_DOUBLE, MP_EXT
  };
  /**
   * \brief Request types
   */
  enum tnt_request_t {
      TNT_OP_SELECT = 1,
      TNT_OP_INSERT = 2,
      TNT_OP_REPLACE = 3,
      TNT_OP_UPDATE = 4,
      TNT_OP_DELETE = 5,
      TNT_OP_CALL = 6,
      TNT_OP_AUTH = 7,
      TNT_OP_EVAL = 8,
      TNT_OP_UPSERT = 9,
      TNT_OP_PING = 64,
      TNT_OP_JOIN = 65,
      TNT_OP_SUBSCRIBE = 66
  };
  /**
   * \brief Iterator types
   */
  enum tnt_iterator_t {
      TNT_ITER_EQ = 0,
      TNT_ITER_REQ,
      TNT_ITER_ALL,
      TNT_ITER_LT,
      TNT_ITER_LE,
      TNT_ITER_GE,
      TNT_ITER_GT,
      TNT_ITER_BITS_ALL_SET,
      TNT_ITER_BITS_ANY_SET,
      TNT_ITER_BITS_ALL_NOT_SET,
      TNT_ITER_OVERLAP,
      TNT_ITER_NEIGHBOR,
  };
  struct tnt_request {
      struct {
          uint32_t sync; /*!< Request sync id. Generated when encoded */
          enum tnt_request_t type; /*!< Request type */
      } hdr; /*!< fields for header */
      uint32_t space_id; /*!< Space number */
      uint32_t index_id; /*!< Index number */
      uint32_t offset; /*!< Offset for select */
      uint32_t limit; /*!< Limit for select */
      enum tnt_iterator_t iterator; /*!< Iterator for select */
      /* Search key, proc name or eval expression */
      const char *key; /*!< Pointer for
                * key for select/update/delete,
                * procedure  for call,
                * expression for eval,
                * operations for upsert
                */
      const char *key_end;
      struct tnt_stream *key_object; /*!< Pointer for key object
                      * if allocated inside requests
                      * functions
                      */
      const char *tuple; /*!< Pointer for
                  * tuple for insert/replace,
                  * ops for update
                  * default tuple for upsert,
                  * args for eval/call
                  */
      const char *tuple_end;
      struct tnt_stream *tuple_object; /*!< Pointer for tuple object
                        * if allocated inside requests
                        * functions
                        */
      int index_base; /*!< field offset for UPDATE */
      int alloc; /*!< allocation mark */
  };
  enum tnt_error {
      TNT_EOK, /*!< Everything is OK */
      TNT_EFAIL, /*!< Fail */
      TNT_EMEMORY, /*!< Memory allocation failed */
      TNT_ESYSTEM, /*!< System error */
      TNT_EBIG, /*!< Buffer is too big */
      TNT_ESIZE, /*!< Bad buffer size */
      TNT_ERESOLVE, /*!< gethostbyname(2) failed */
      TNT_ETMOUT, /*!< Operation timeout */
      TNT_EBADVAL, /*!< Bad argument (value) */
      TNT_ELOGIN, /*!< Failed to login */
      TNT_LAST /*!< Not an error */
  };
#endif

#endif

/* Flags used for row_form_box. NUM_FLAG is also defined in mysql include, with same value. */
#define READONLY_FLAG 1
#define NUM_FLAG 32768

/*
  Most ocelot_ variables are in ocelotgui.cpp but if one is required by ocelotgui.h, say so here.
  Weirdly, ocelotgui.h is included in two places, ocelotgui.pro + ocelotgui.cpp,
  so say 'static' if you do that.
*/

/* References to ostrings.h variables and pseudo-constants */
extern const char *menu_strings[];
extern int MENU_STATEMENT_TEXT_COLOR;
extern int MENU_STATEMENT_BACKGROUND_COLOR;
extern int MENU_STATEMENT_HIGHLIGHT_LITERAL_COLOR;
extern int MENU_STATEMENT_HIGHLIGHT_IDENTIFIER_COLOR;
extern int MENU_STATEMENT_HIGHLIGHT_COMMENT_COLOR;
extern int MENU_STATEMENT_HIGHLIGHT_OPERATOR_COLOR;
extern int MENU_STATEMENT_HIGHLIGHT_KEYWORD_COLOR;
extern int MENU_STATEMENT_PROMPT_BACKGROUND_COLOR;
extern int MENU_STATEMENT_BORDER_COLOR;
extern int MENU_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR;
extern int MENU_STATEMENT_HIGHLIGHT_FUNCTION_COLOR;
extern int MENU_GRID_TEXT_COLOR;
extern int MENU_GRID_BACKGROUND_COLOR;
extern int MENU_GRID_CELL_BORDER_COLOR;
extern int MENU_GRID_OUTER_COLOR;
extern int MENU_GRID_HEADER_BACKGROUND_COLOR;
extern int MENU_GRID_FOCUS_CELL_BACKGROUND_COLOR;
extern int MENU_GRID_CELL_HEIGHT;
extern int MENU_GRID_CELL_BORDER_SIZE;
extern int MENU_GRID_CELL_WIDTH;
extern int MENU_GRID_TEXT_COLOR;
extern int MENU_GRID_BACKGROUND_COLOR;
extern int MENU_HISTORY_TEXT_COLOR;
extern int MENU_HISTORY_BACKGROUND_COLOR;
extern int MENU_HISTORY_BORDER_COLOR;
extern int MENU_MENU_TEXT_COLOR;
extern int MENU_MENU_BACKGROUND_COLOR;
extern int MENU_MENU_BORDER_COLOR;
extern int MENU_FONT;
extern int MENU_MAX_ROW_COUNT;
extern int MENU_SYNTAX_CHECKER;
extern int MENU_DETACHED;
extern int MENU_TOP;
extern int MENU_LEFT;
extern int MENU_WIDTH;
extern int MENU_HEIGHT;
extern int MENU_CONDITION;
extern int MENU_DISPLAY_AS;
extern int MENU_CANCEL;
extern int MENU_OK;
extern int MENU_SETTINGS_FOR_MENU;
extern int MENU_SETTINGS_FOR_HISTORY;
extern int MENU_SETTINGS_FOR_GRID;
extern int MENU_SETTINGS_FOR_STATEMENT;
extern int MENU_SETTINGS_FOR_DEBUG;
extern int MENU_SETTINGS_FOR_EXTRA_RULE_1;
extern int MENU_GRID_HTML_EFFECTS; /* was for font dialog, but since version 1.5 we don't call QFontDialog*/

extern unsigned int menu_off;

extern unsigned int dbms_version_mask;

#if (OCELOT_IMPORT_EXPORT == 1)
extern int export_type;
extern QByteArray export_columns_enclosed_by;
extern QByteArray export_columns_escaped_by;
extern bool export_columns_optionally;
extern QByteArray export_columns_terminated_by;
extern QByteArray export_lines_starting_by;
extern QByteArray export_lines_terminated_by;
extern unsigned short export_column_names;
extern bool export_queries;
extern bool export_row_counts;
extern long unsigned export_max_row_count;
extern unsigned short export_margin;
extern unsigned short export_padding;
extern unsigned short export_last;
extern unsigned short export_divider;
#endif

namespace Ui
{
class MainWindow;
}

QT_BEGIN_NAMESPACE
//class QAction;
//class QLabel;
//class QMenu;
//class QMenuBar;
//class QComboBox;
//class QPushButton;
//class QTextEdit;
//class QPlainTextEdit;
//class QScrollArea;
//class QVBoxLayout;
class CodeEditor;
class ResultGrid;
class Settings;
class QComboBoxInSettings;
#ifdef OLD_STUFF
class TextEditFrame;
class TextEditWidget;
#endif
class QScrollAreaWithSize;
class QThread48;
class QTabWidget48;
class TextEditHistory;
class TextEditWidget2;
class XSettings;
class Completer_widget;
#if (OCELOT_FIND_WIDGET == 1)
class Find_widget;
#endif
class Result_qtextedit;
class Result_changes;

QT_END_NAMESPACE

class MainWindow : public QMainWindow
{
  Q_OBJECT

public:
  explicit MainWindow(int argc, char *argv[], QWidget *parent= 0);
  ~MainWindow();

  /*
    Client variables
    Client variables can be changed via Settings menu or via SET statements.
    Client variables have the prefix 'ocelot_'.
    Every client variable has an item on the Settings menu,
    and most may be changed with the SET statement. For example,
    ocelot_grid_outer_color is on menu item Settings | Grid Widget,
    SET ocelot_grid_outer_color = value; will change.
    The important thing is: if it's changed on the Settings menu, then
    a SET statement is generated, so that can be saved and replayed.
    Naming convention: ocelot_ + settings-menu-item + object + color|size|font.
    Todo: (unlikely) pass it on to the server, without interfering with ordinary SET statements.
    Todo: use keywords.
    Todo: allow SET ocelot_... = DEFAULT
    Todo: need a more flexible parser, eventually.
    Todo: should it be optional whether such statements go to history?
    Todo: do not consider it an error if you're not connected but it's a SET statement
    Todo: make sure it's a valid setting
    Todo: pay attention to the delimiter
    Todo: what should happen if the SET fails?
    Todo: isValid() check
    Todo: rename the Settings menu items and let the prompts match the names
    Todo: there is also  Qt way to save current settings, maybe it's another option
    Todo: menu item = "save settings" which would put a file in ~/ocelot.ini or ~/.my.cnf
    Todo: a single big setting
    Todo: a comment e.g. / *! OCELOT CLIENT * / meaning do not pass to server
    Problem: you cannot muck statement itself because menu might be changed while statement is up
    See also: Client variables that can be changed with the Settings widget
    Todo: Shouldn't client variables be in statement widget?
    Todo: (bug) If I change grid color or font weight or font style
          via the settings menu, the effect is immediate. But if I change
          them by executing SET ..., the effect is delayed, until the
          next time I type something or bring up a menu. I believe this
          is happening because going to settings menu will invalidate the
          grid widget area so it gets repainted; however, explicitly
          saying update() or repaint() solves nothing -- only hide()
          and show() force the widget change to be immediate.
          For other widgets I have kludged around similar problems,
          but I fear that I'm repainting multiple times unnecessarily.
  */
  QString ocelot_statement_text_color, new_ocelot_statement_text_color;
  QString ocelot_statement_background_color, new_ocelot_statement_background_color;
  QString ocelot_statement_border_color, new_ocelot_statement_border_color;
  QString ocelot_statement_font_family, new_ocelot_statement_font_family;
  QString ocelot_statement_font_size, new_ocelot_statement_font_size;
  QString ocelot_statement_font_style, new_ocelot_statement_font_style;
  QString ocelot_statement_font_weight, new_ocelot_statement_font_weight;
  QString ocelot_statement_highlight_literal_color, new_ocelot_statement_highlight_literal_color;
  QString ocelot_statement_highlight_identifier_color, new_ocelot_statement_highlight_identifier_color;
  QString ocelot_statement_highlight_comment_color, new_ocelot_statement_highlight_comment_color;
  QString ocelot_statement_highlight_operator_color, new_ocelot_statement_highlight_operator_color;
  QString ocelot_statement_highlight_keyword_color, new_ocelot_statement_highlight_keyword_color;
  QString ocelot_statement_prompt_background_color, new_ocelot_statement_prompt_background_color;
  QString ocelot_statement_highlight_current_line_color, new_ocelot_statement_highlight_current_line_color;
  QString ocelot_statement_highlight_function_color, new_ocelot_statement_highlight_function_color;
  QString ocelot_statement_syntax_checker, new_ocelot_statement_syntax_checker;
  QString ocelot_statement_style_string;
  QString ocelot_statement_format_statement_indent;
  QString ocelot_statement_format_clause_indent;
  QString ocelot_statement_format_rule;
  QString ocelot_statement_height, new_ocelot_statement_height;
  QString ocelot_statement_left, new_ocelot_statement_left;
  QString ocelot_statement_top, new_ocelot_statement_top;
  QString ocelot_statement_width, new_ocelot_statement_width;
  QString ocelot_statement_detached, new_ocelot_statement_detached;
  QString ocelot_debug_height, new_ocelot_debug_height;
  QString ocelot_debug_left, new_ocelot_debug_left;
  QString ocelot_debug_top, new_ocelot_debug_top;
  QString ocelot_debug_width, new_ocelot_debug_width;
  QString ocelot_debug_detached, new_ocelot_debug_detached;
  QString ocelot_grid_text_color, new_ocelot_grid_text_color;
  QString ocelot_grid_background_color, new_ocelot_grid_background_color;
  QString ocelot_grid_focus_cell_background_color, new_ocelot_grid_focus_cell_background_color;
  QString ocelot_grid_header_background_color, new_ocelot_grid_header_background_color;
  QString ocelot_grid_font_family, new_ocelot_grid_font_family;
  QString ocelot_grid_font_size, new_ocelot_grid_font_size;
  QString ocelot_grid_font_style, new_ocelot_grid_font_style;
  QString ocelot_grid_font_weight, new_ocelot_grid_font_weight;
  QString ocelot_grid_cell_border_color, new_ocelot_grid_cell_border_color;
  QString ocelot_grid_outer_color, new_ocelot_grid_outer_color;
  QString ocelot_grid_border_size, new_ocelot_grid_border_size; /* no longer used */
  QString ocelot_grid_cell_border_size, new_ocelot_grid_cell_border_size;
//  QString ocelot_grid_cell_drag_line_size, new_ocelot_grid_cell_drag_line_size; /* no longer used */
  QString ocelot_grid_cell_height, new_ocelot_grid_cell_height;
  QString ocelot_grid_cell_width, new_ocelot_grid_cell_width;
  QString ocelot_grid_style_string;
  QString ocelot_grid_header_style_string;
  QString ocelot_grid_height, new_ocelot_grid_height;
  QString ocelot_grid_left, new_ocelot_grid_left;
  QString ocelot_grid_top, new_ocelot_grid_top;
  QString ocelot_grid_width, new_ocelot_grid_width;
  QString ocelot_grid_html_effects, new_ocelot_grid_html_effects;
  QString ocelot_grid_detached, new_ocelot_grid_detached;
  QString ocelot_extra_rule_1_background_color, new_ocelot_extra_rule_1_background_color;
  QString ocelot_extra_rule_1_text_color, new_ocelot_extra_rule_1_text_color;
  QString ocelot_extra_rule_1_condition, new_ocelot_extra_rule_1_condition;
  QString ocelot_extra_rule_1_display_as, new_ocelot_extra_rule_1_display_as;
  QString ocelot_extra_rule_1_style_string;
  QString ocelot_history_text_color, new_ocelot_history_text_color;
  QString ocelot_history_background_color, new_ocelot_history_background_color;
  QString ocelot_history_border_color, new_ocelot_history_border_color;
  QString ocelot_history_font_family, new_ocelot_history_font_family;
  QString ocelot_history_font_size, new_ocelot_history_font_size;
  QString ocelot_history_font_style, new_ocelot_history_font_style;
  QString ocelot_history_font_weight, new_ocelot_history_font_weight;
  QString ocelot_history_style_string;
  QString ocelot_history_height, new_ocelot_history_height;
  QString ocelot_history_left, new_ocelot_history_left;
  QString ocelot_history_top, new_ocelot_history_top;
  QString ocelot_history_width, new_ocelot_history_width;
  QString ocelot_history_max_row_count, new_ocelot_history_max_row_count;
  QString ocelot_history_detached, new_ocelot_history_detached;
  QString ocelot_histfileflags;
  QString ocelot_histfilesize;
  QString ocelot_histsize;
  QString ocelot_menu_text_color, new_ocelot_menu_text_color;
  QString ocelot_menu_background_color, new_ocelot_menu_background_color;
  QString ocelot_menu_border_color, new_ocelot_menu_border_color;
  QString ocelot_menu_font_family, new_ocelot_menu_font_family;
  QString ocelot_menu_font_size, new_ocelot_menu_font_size;
  QString ocelot_menu_font_style, new_ocelot_menu_font_style;
  QString ocelot_menu_font_weight, new_ocelot_menu_font_weight;
  QString ocelot_menu_style_string;

  QStringList conditional_settings;

  QString ocelot_language;

  /* Strings for CONNECT. Some of these will be converted e.g. ocelot_host to ocelot_host_as_utf8 */
  QString ocelot_histignore;
  QString ocelot_host;
  QString ocelot_database;
  QString ocelot_user;
  QString ocelot_password;
  QString ocelot_unix_socket;
  QString ocelot_default_auth;
  QString ocelot_init_command;
  QString ocelot_opt_bind;
  QString ocelot_bind_address; /* Todo: check: is this the same as ocelot_opt_bind? */
  QString ocelot_opt_connect_attr_delete;
  QString ocelot_debug;
  QString ocelot_execute;
  QString ocelot_ld_run_path;
  QString ocelot_login_path;
  QString ocelot_opt_lua;
  QString ocelot_opt_ssl;
  QString ocelot_opt_ssl_ca;
  QString ocelot_opt_ssl_capath;
  QString ocelot_opt_ssl_cert;
  QString ocelot_opt_ssl_cipher;
  QString ocelot_opt_ssl_crl;
  QString ocelot_opt_ssl_crlpath;
  QString ocelot_opt_ssl_key;
  QString ocelot_opt_ssl_mode;
  QString ocelot_pager;
  QString ocelot_plugin_dir;
  QString ocelot_read_default_file;
  QString ocelot_read_default_group;
  QString ocelot_server_public_key;
  QString ocelot_set_charset_dir;
  QString ocelot_set_charset_name;           /* was: ocelot_default_character_set */
  QString ocelot_shared_memory_base_name;
  QString ocelot_protocol;
  //unsigned short ocelot_no_defaults;         /* for CONNECT */
  QString ocelot_defaults_file;              /* for CONNECT */
  QString ocelot_defaults_extra_file;        /* for CONNECT */
  QString ocelot_defaults_group_suffix;
  QString ocelot_prompt;
  QString ocelot_opt_ssl_verify;
  QString options_files_read;

  QList<QString> q_color_list;
  QString q_color_list_name(QString rgb_name);
  QString qt_color(QString);
  QString rgb_to_color(QString);
  QString canonical_color_name(QString);
  void assign_names_for_colors();
  QString canonical_font_weight(QString);
  int fontweights_index_via_chars(QString);
  int fontweights_index_via_qt_number(int);
  int fontweights_index_via_css_number(int);
  QString canonical_font_family(QString,QString*);
  QString canonical_font_style(QString,QString);
  QString connect_stripper(QString value_to_strip, bool strip_doublets_flag);
  QString connect_unstripper(QString value_to_unstrip);
  /* Following were moved from 'private:', merely so all client variables could be together. Cannot be used with SET. */

  QString ocelot_dbms;                    /* for CONNECT */
  unsigned int ocelot_grid_max_row_lines;          /* ?? should be unsigned long? */
  /* unsigned int ocelot_grid_max_desired_width_in_chars; */

  QString history_markup_statement_start;    /* for markup */
  QString history_markup_statement_end;      /* for markup */
  QString history_markup_prompt_start;       /* for markup */
  QString history_markup_prompt_end;         /* for markup */
  QString history_markup_result;             /* for markup */
  QString history_markup_entity;             /* for markup */

  QString ocelot_history_tee_file_name;      /* see comment=tee+hist */
  QFile ocelot_history_tee_file;             /* see comment=tee+hist */
  QString ocelot_history_hist_file_name;     /* see comment=tee+hist */
  QFile ocelot_history_hist_file;            /* see comment=tee+hist */
  CodeEditor *statement_edit_widget;

  int position_for_redo;
  int chars_added_for_redo;
  int chars_removed_for_redo;

  QStringList tarantool_statements_in_begin;

  int main_window_maximum_width;
  int main_window_maximum_height;
  void component_size_calc(int *character_height, int *borders_height);
  QFont get_font_from_style_sheet(QString style_string);
  void set_dbms_version_mask(QString);
  int next_i(int, int);
  bool get_sql_mode(int who_is_calling, QString text, bool is_in_hparse, int start_token_number);
  QString get_doc_path(QString);
  void hparse_f_nexttoken();
  void hparse_f_next_nexttoken();
  void hparse_f_error();
  bool hparse_f_is_equal(QString,QString);
  bool hparse_f_is_special_verb(int);
  int hparse_f_accept(unsigned int,unsigned char,int,QString);
  int hparse_f_acceptn(int,QString,int);
  int hparse_f_acceptf(int pass_number, QString replacee);
  void hparse_f_expected_initialize();
  void hparse_f_expected_clear();
  int hparse_f_expected_exact(int reftype);
  void hparse_f_expected_append(QString token, unsigned char reftype, int proposed_type);
  void hparse_f_expected_append_endquote(QString token);
  QString hparse_f_token_to_appendee(QString,int,char);
  int hparse_f_expect(unsigned int,unsigned char,int,QString);
  int hparse_f_literal(unsigned char,unsigned int,int);
  int hparse_f_default(int,bool);
  int hparse_f_user_or_role_name(int);
  int hparse_f_character_set_name();
  int hparse_f_collation_name();
  int hparse_f_qualified_name_with_star();
  int hparse_f_qualified_name_of_object(unsigned int,int,int);
  int hparse_f_qualified_name_of_object_with_star(int,int);
  int hparse_f_e_to_reftype(int);
  int hparse_f_accept_qualifier(unsigned int,unsigned char,int,QString);
  bool hparse_f_is_variable(int, int);
  int hparse_f_qualified_name_of_operand(unsigned int,bool,bool,bool);
  int hparse_f_table_references();
  void hparse_f_table_escaped_table_reference();
  int hparse_f_table_reference(int);
  int hparse_f_table_factor();
  int hparse_f_table_join_table();
  int hparse_f_table_join_condition();
  void hparse_f_table_index_hint_list();
  int hparse_f_table_index_hint();
  int hparse_f_table_index_list();
  int hparse_f_comp_op();
  void hparse_f_opr_1(int,int),hparse_f_opr_2(int,int),hparse_f_opr_3(int,int),hparse_f_opr_4(int,int);
  void hparse_f_opr_5(int,int),hparse_f_opr_6(int,int),hparse_f_opr_7(int,int);
  void hparse_f_opr_8(int,int);
  void hparse_f_opr_9(int,int);
  void hparse_f_opr_10(int,int);
  void hparse_f_opr_11(int,int);
  void hparse_f_opr_12(int,int);
  void hparse_f_opr_13(int,int);
  void hparse_f_opr_14(int,int);
  void hparse_f_opr_15(int,int);
  void hparse_f_opr_16(int,int);
  void hparse_f_opr_17(int,int);
  void hparse_f_opr_18(int,int);
  void hparse_f_over(int,int);
  int hparse_f_over_start(int);
  int hparse_f_over_end();
  void hparse_f_function_arguments(QString);
  int hparse_f_expression_list(int);
  void hparse_f_parenthesized_value_list();
  void hparse_f_parameter_list(int);
  void hparse_f_parenthesized_expression();
  void hparse_f_parenthesized_multi_expression(int*);
  void hparse_f_like_or_where();
  void hparse_f_from_or_like_or_where();
  void hparse_f_infile_or_outfile();
  void hparse_f_show_columns();
  void hparse_f_if_not_exists();
  void hparse_f_indexes_or_keys();
  void hparse_f_alter_or_create_clause(int,unsigned int*,bool*);
  int hparse_f_semicolon_and_or_delimiter(int);
  int hparse_f_explainable_statement(int);
  void hparse_f_statement(int);
  void hparse_f_pseudo_statement(int);
  void hparse_f_is_global_or_persist(bool *,bool *);
  void hparse_f_assignment(int,int,bool,bool);
  void hparse_f_alter_table();
  int hparse_f_character_set();
  void hparse_f_alter_database();
  void hparse_f_alter_specification();
  void hparse_f_characteristics();
  int hparse_f_algorithm_or_lock();
  void hparse_f_definer();
  void hparse_f_character_set_or_collate();
  int hparse_f_length(bool, bool,bool);
  void hparse_f_enum_or_set();
  int hparse_f_data_type(int);
  void hparse_f_reference_option();
  int hparse_f_reference_definition();
  int hparse_f_create_definition(int);
  int hparse_f_default_clause(int);
  int hparse_f_current_timestamp();
  void hparse_f_column_definition();
  void hparse_f_comment();
  void hparse_f_column_list(int,int);
  void hparse_f_engine();
  void hparse_f_table_or_partition_options(int);
  void hparse_f_partition_options();
  void hparse_f_partition_or_subpartition(int);
  void hparse_f_partition_or_subpartition_definition(int);
  int hparse_f_partition_list(bool, bool);
  void hparse_f_algorithm();
  void hparse_f_sql();
  void hparse_f_for_channel();
  void hparse_f_interval_quantity(int);
  void hparse_f_alter_or_create_event(int);
  void hparse_f_alter_or_create_sequence(int);
  void hparse_f_alter_or_create_server(int);
  void hparse_f_require(int,bool,bool);
  void hparse_f_user_specification_list();
  void hparse_f_create_database();
  void hparse_f_create_package(bool);
  void hparse_f_create_function_clauses();
  void hparse_f_create_procedure_clauses();
  int hparse_f_index_column_expecter();
  void hparse_f_index_columns(int,bool,bool,bool);
  void hparse_f_alter_or_create_view();
  int hparse_f_analyze_or_optimize(int,int*);
  void hparse_f_call();
  void hparse_f_call_arguments();
  void hparse_f_commit_or_rollback();
  int is_token_priv(int);
  void hparse_f_explain_or_describe(int);
  void hparse_f_grant_or_revoke(int,bool*);
  void hparse_f_insert_or_replace();
  void hparse_f_conflict_clause();
  void hparse_f_conflict_algorithm();
  void hparse_f_condition_information_item_name();
  int hparse_f_signal_or_resignal(int,int);
  int hparse_f_into();
  void hparse_f_with_clause(int,bool);
  int hparse_f_values();
  int hparse_f_unionize();
  bool hparse_f_is_query(bool);
  int hparse_f_query(int,bool,bool,bool);
  int hparse_f_select(bool,bool);
  int hparse_f_deep_query(int,bool,bool);
  void hparse_f_where();
  void hparse_f_window_spec(bool);
  int hparse_f_order_by(int);
  void hparse_f_limit(int);
  void hparse_f_block(int, int);
  bool hparse_f_is_in_compound();
  int hparse_f_plsql_condition(int);
  void hparse_f_declare(int, int);
  int hparse_f_declare_plsql(int);
  int hparse_f_recover_if_error(bool,QString);
  void hparse_f_lua_blocklist(int,int);
  void hparse_f_lua_blockseries(int,int,bool);
  int hparse_f_lua_block(int,int,bool);
  int hparse_f_lua_funcname();
  int hparse_f_lua_varlist();
  int hparse_f_lua_var();
  int hparse_f_lua_namelist();
  int hparse_f_lua_explist();
  int hparse_f_lua_exp();
  int hparse_f_lua_prefixexp();
  int hparse_f_lua_functioncall();
  int hparse_f_lua_args();
  int hparse_f_lua_function();
  int hparse_f_lua_funcbody();
  int hparse_f_lua_parlist();
  int hparse_f_lua_tableconstructor();
  int hparse_f_lua_fieldlist();
  int hparse_f_lua_field();
  int hparse_f_lua_fieldsep();
  int hparse_f_lua_name();
  int hparse_f_lua_name_equivalent();
  int hparse_f_lua_number();
  int hparse_f_lua_string();
  int hparse_f_lua_oprlist();
  int hparse_f_lua_literal();
  void hparse_f_lua_opr_1(int);
  void hparse_f_lua_opr_2(int);
  void hparse_f_lua_opr_3(int);
  void hparse_f_lua_opr_4(int);
  void hparse_f_lua_opr_5(int);
  void hparse_f_lua_opr_6(int);
  void hparse_f_lua_opr_7(int);
  void hparse_f_lua_opr_8(int,int);
  void hparse_f_lua_opr_9(int,int);
  void hparse_f_lua_opr_10(int,int);
  void hparse_f_lua_opr_11(int,int);
  void hparse_f_lua_opr_12(int,int);
  void hparse_f_lua_opr_13(int,int);
  void hparse_f_lua_opr_14(int,int);
  void hparse_f_lua_opr_15(int,int);
  void hparse_f_lua_opr_16(int,int);
  void hparse_f_lua_opr_17(int,int);
  void hparse_f_lua_opr_18(int,int);
  int hparse_f_lua_accept_dotted(unsigned int,unsigned char,int,QString);
  QString hparse_f_label(int *);
  int hparse_f_find_define(int,int,int,bool);
  void hparse_f_cursors(int);
  int hparse_f_variables(int*);
  void msgBoxClosed(QAbstractButton*);
  void hparse_f_multi_block(QString text);
  int i_of_elementary_statement();
  QString hparse_f_pre_rehash_search(int reftype);
  bool hparse_f_is_rehash_searchable();
  int hparse_f_backslash_command(bool);
  void hparse_f_other(int);
#if (OCELOT_IMPORT_EXPORT == 1)
  int hparse_f_client_set_import_export();
#endif
  int hparse_f_client_set_rule();
  bool hparse_pick_from_list(QStringList);
  int hparse_f_client_set();
  int hparse_f_client_statement();
  void hparse_f_parse_hint_line_create();
  bool hparse_f_is_nosql(QString);
  void hparse_f_variables_append(int i_of_statement_start, QString text, unsigned char reftype);
  void log(const char*,int);
  void extra_result_set(int, unsigned short int);
  int execute_real_query(QString, int, const QString *);
#ifdef DBMS_TARANTOOL
  void tparse_f_factor();
  void tparse_f_term();
  void tparse_f_expression();
  void tparse_f_restricted_expression();
  void tparse_f_indexed_condition(int);
  void tparse_f_statement();
  void tparse_f_assignment();
  void tparse_f_block(int);
  void tparse_f_program(QString text);
#endif
#ifdef DBMS_TARANTOOL
  /* todo: field_name_list_all_rows* stuff could be cleared sometimes, or could be in ResultGrid */
  QStringList field_name_list_all_rows;
  QList<int> field_name_list_all_rows_count;
  QList<char*> field_name_list_all_rows_address;
  QList<int> field_type_list_all_rows;
  QString tarantool_add_return(QString);
  const char *tarantool_result_set_init(int,long unsigned int *,int *);
  const char *tarantool_result_set_init_select(long unsigned int *, int, int);

  long unsigned int tarantool_num_rows(unsigned int connection_number);
  unsigned int tarantool_num_fields();
  int tarantool_num_fields_recursive(const char **tarantool_tnt_reply_data,
                                     char *field_name,
                                     int field_number_within_array,
                                     QStringList *field_name_list,
                                     QList<int> *field_name_list_count,
                                     QList<char*> *field_name_list_address,
                                     int field_type_upper);
  QString tarantool_scan_rows(unsigned int p_result_column_count,
                 unsigned int p_result_row_count,
                 MYSQL_RES *p_mysql_res,
                 char **p_result_set_copy,
                 char ***p_result_set_copy_rows,
                 unsigned int **p_result_max_column_widths);
  QString tarantool_scan_field_names(
                 const char *which_field,
                 unsigned int p_result_column_count,
                 char **p_result_field_names,
                 bool is_for_display);
  int create_table_server(QString, bool *, unsigned int, unsigned int);
  QString tarantool_read_format(QString);
#endif
  QVBoxLayout *main_layout;
  QString token_reftype(int i, bool, int, char);
  QString get_font_style_as_string(QFont);

  Completer_widget *completer_widget= NULL;

public slots:
  void action_connect();
  void action_connect_once(QString);
  void action_exit();
#if (OCELOT_IMPORT_EXPORT == 1)
  QStringList fake_statement(QString fake_statement_text);
  void action_export();
#endif
  void action_execute_force();
  int action_execute(int);
  void action_kill();
  void action_about();
  void action_the_manual();
#if (OCELOT_MYSQL_INCLUDE == 1)
  void action_libmysqlclient();
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  void action_settings();
  void action_statement_edit_widget_text_changed(int,int,int);
  QTextCharFormat get_format_of_current_token(int token_type, int token_flags, QString mid_next_token);
  void action_undo();
  void action_redo();
  void menu_activations(QObject*, QEvent::Type);
  void statement_edit_widget_formatter();
  int statement_format_rule_set(QString text);
  QString statement_format_rule_apply(QString, int, unsigned char, unsigned int, int*, int*, int*);
#if (OCELOT_IMPORT_EXPORT == 1)
  QByteArray to_byte_array(QString);
  void import_export_rule_set(QString text);
#endif
  void action_change_one_setting(QString old_setting, QString new_setting, int keyword_index);
  void action_menu();
  void action_history();
  void action_grid();
  void action_statement();
#if (OCELOT_MYSQL_DEBUGGER == 1)
  void action_debug();
#endif
  void action_extra_rule_1();
  void history_markup_previous();
  void history_markup_next();
  void action_option_detach_history_widget(bool checked); void detach_history_widget(bool checked);
  void action_option_detach_result_grid_widget(bool checked); void detach_result_grid_widget(bool checked);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  void action_option_detach_debug_widget(bool checked); void detach_debug_widget(bool checked);
#endif
  void action_option_detach_statement_widget(bool checked); void detach_statement_widget(bool checked);
  void action_option_next_window();
  void action_option_previous_window();
  void action_option_change_result_display(QString);
  void action_option_batch();
  void action_option_horizontal();
  void action_option_html();
  void action_option_htmlraw();
  void action_option_raw();
  void action_option_vertical();
  void action_option_xml();

#if (OCELOT_MYSQL_DEBUGGER == 1)
  int debug_mdbug_install_sql(MYSQL *mysql, char *x); /* the only routine in install_sql.cpp */
  int debug_parse_statement(QString text,
                             char *returned_command_string,
                             int *index_of_number_1,
                             int *index_of_number_2);
  int debug_error(char *text);
//  void action_debug_install();
  void debug_install_go();
//  void action_debug_setup();
  void debug_setup_go(QString text);
  void debug_setup_mysql_proc_insert();
//  void action_debug_debug();
  void debug_debug_go(QString text);
  void action_debug_breakpoint();
  void debug_breakpoint_or_clear_go(int statement_type, QString text);
  void action_debug_mousebuttonpress(QEvent *event, int which_debug_widget_index);
  void action_debug_continue();
//  void action_debug_leave();
  void debug_skip_go();
  void debug_source_go();
  void debug_set_go(QString text);
  void debug_other_go(QString text);
  void action_debug_next();
//  void action_debug_skip();
  void action_debug_step();
  void action_debug_clear();
//  void action_debug_delete();
  void debug_delete_go();
  void debug_execute_go();
  void action_debug_exit();
  void debug_exit_go(int flagger);
  void debug_delete_tab_widgets();
  void action_debug_information();
  void action_debug_refresh_server_variables();
  void action_debug_refresh_user_variables();
  void action_debug_refresh_variables();
  void action_debug_refresh_call_stack();
  void action_debug_timer_status();
#endif
  int shortcut(int,QString,bool,bool);
  void menu_edit_undo();
  void menu_edit_redo();
  void menu_edit_cut();
  void menu_edit_copy();
  void menu_edit_paste();
  void menu_edit_select_all();
  void menu_edit_zoomin();
  void menu_edit_zoomout();
  void menu_edit_autocomplete_via_menu();
  bool menu_edit_autocomplete();
#if (OCELOT_FIND_WIDGET == 1)
  void menu_edit_find();
#endif
  bool eventfilter_function(QObject *obj, QEvent *event);
  void menu_context(const QPoint &);
//  int typer_to_ocelot_data_type(char *s); /* exists in ocelotgui.cpp but is commented out */
  char *typer_to_keyword(unsigned int); /* todo: check: why are some things in "public slots" not "public"? */

protected:
  bool eventFilter(QObject *obj, QEvent *ev);
  void resizeEvent(QResizeEvent *ev);

private:
public:
  Ui::MainWindow *ui;
private:
  int history_markup_previous_or_next();
  void initialize_widget_history();
  int result_grid_add_tab();
  void initialize_widget_statement();
  void menu_edit_zoominorout(int);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  void debug_menu_enable_or_disable(int statement_type);
  void create_widget_debug();
  int debug_information_status(char *last_command);
  int debug_call_xxxmdbug_command(const char *command);
  void debug_highlight_line();
  void debug_maintain_prompt(int action, int debug_widget_index, int line_number);
  QString debug_privilege_check(int statement_type);
#endif
  void main_token_new(int), main_token_push(), main_token_pop();
  void create_menu(); void fill_menu();
  int rehash_scan(char *); int rehash_scan_for_tarantool(char *);
  void rehash_scan_one_space(int space_number);
  QString rehash_search(QString table_name, char *search_string, int reftype,
                        QString hparse_token,
                        bool is_exact_required);
  void rehash_get_database_name(char *);
  void widget_sizer();
  QString get_delimiter(QString,QString,int);
  QString detached_value(QString);
  QString rect_value(QString);
  int execute_client_statement(QString text, int *additional_result);
  void prompt_default();
  int conditional_settings_insert(QString text);
  void put_diagnostics_in_result(unsigned int);
  void put_message_in_result(QString);
  void make_and_put_message_in_result(unsigned int, int, char*);
  void make_and_put_open_message_in_result(unsigned int, int, QString);
  void make_and_append_message_in_result(unsigned int, int, char*);
  unsigned int get_ocelot_protocol_as_int(QString s);
//  int options_and_connect(char *host, char *database, char *user, char *password, char *tmp_init_command,
//                       char *tmp_plugin_dir, char *tmp_default_auth, char *unix_socket, unsigned int connection_number);

  void connect_mysql_options_2(int w_argc, char *argv[]);
  void connect_read_command_line(int argc, char *argv[]);
  void connect_read_my_cnf(const char *file_name, int is_mylogin_cnf);
  int connect_readmylogin(QFile&, unsigned char *);
  //int connect_readmylogin(FILE *, unsigned char *);
  void connect_set_variable(QString token0, QString token1, QString token2);
  void connect_make_statement();
  long to_long(QString token);
  QString get_version();
  void print_version();
  void print_help();
  int setup_mysql_real_query(char*,char*);
  int setup_routine_list(QString);
  int setup_find(QString,QString);
  int setup_generate(int);
  int setup_generate_icc_process_user_command_r_server_variables();
  int setup_append(QString, QString, int);
  int setup_generate_routine_entry_parameter(QString);
  int setup_generate_starter(QString, QString, QString, QString);
  void setup_generate_ender();
  int setup_generate_statements(int, QString, int);
  int setup_initialize_variables();
  int setup_get_setup_group_name();
  QString setup_add_delimiters(QString);
  int setup_insert_into_statements(QString,int);
  int setup_insert_into_variables_user_variables(QString,int);
  int setup_create_setup_log_table();
  int setup_internal(QString);
  int setup_drop_routines();
  void setup_cleanup();
  int setup_set_session_sql_mode(QString);
  int setup_generate_icc_core();
  int setup_generate_statements_debuggable(int, int, int, QString, int, int);
  int setup_generate_label(int, QString, int);
  int setup_row_type(int);
  int setup_determine_what_variables_are_in_scope(int, QString);
  int setup_generate_statement_text(int, QString, int, int);
  int setup_generate_statement_text_as_is(int, QString, int);
  void copy_options_to_main_window();
  void delete_utf8_copies();
  void copy_connect_strings_to_utf8(); /* in effect, copy options from main_window */
#if (OCELOT_MYSQL_INCLUDE == 1)
  int the_connect(unsigned int connection_number);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  int the_connect_2(); /* intended replacement for the_connect() */
  //my_bool get_one_option(int optid, const struct my_option *opt __attribute__((unused)),char *argument);
  void connect_init(int connection_number);
  void set_current_colors_and_font(QFont);
  QFont get_fixed_font();

public:
  void make_style_strings();
  void make_one_style_string(QString *style_string, QString text_color, QString background_color, QString border_size, QString border_color, QString font_family, QString font_size, QString font_style, QString font_weight, bool is_menu);

private:
  //void create_the_manual_widget();
  int get_next_statement_in_string(int passed_main_token_number, int *returned_begin_count, bool);
  int make_statement_ready_to_send(QString, char *, int, int);
  void remove_statement(QString);
  int action_execute_one_statement(QString text);

  void history_markup_make_strings();
  void history_markup_append(QString result_set_for_history, bool is_interactive);
  void tee_export(QString);
  QString history_markup_copy_for_history(QString);
  int history_file_start(QString, QString, QString *r);        /* see comment=tee+hist */
  void history_file_stop(QString);                 /* see comment=tee+hist */
public:
  void history_file_write(QString, QString, bool);       /* see comment=tee+hist */
private:
  void history_file_to_history_widget();           /* see comment=tee+hist */
  int history_line(char *);
public:
  void statement_edit_widget_setstylesheet();
  void tokenize(QChar *text, int text_length, int *token_lengths, int *token_offsets, int max_tokens, QChar *version, int passed_comment_behaviour, QString special_token, int minus_behaviour);
private:
  bool is_statement_complete(QString);
  void message_box(QString the_title, QString the_text);

  void clf(QString);
  int clf_block(QString, int, QString*);
  bool clf_internal_select(int, QString, QString *);
  bool clfdw(QString, QString*);
  bool clfds(QString, int, QString, QString, QString*);
  void clf_dump_whitespace(QString, QString*);
  QString clf_label(QString, QString);
  bool clf_set(QString, QString, QString*);
  QString clf_v(const QString, int, int);
  QString clf_indent(QString*);
  bool clf_find_handler(QString, QString*, QString, int, int);
  int clf_find_begin(int);
  bool clf_handler_list(QString, int, int, QString*);
  QString clf_handler_name(int);
  bool clf_check_reference(QString, int, int, QString*);
  void clf_handler_end(int, QString*);
  bool clf_make_sql_execute_starter_and_ender(QString, QString*);
  void clf_make_sql_execute_function(QString*);

/*
  ocelot_statement_syntax_checker is planned as a bunch of flags, e.g.
    0 = none
    1 = use for highlights
    2 = errors, i.e. pop up a dialog box if user tries to execute a bad-looking statement
    4 = severe e.g. look whether declared variable is known
    8 = severe e.g. look whether table is known (need to ask server)
   16 = tooltip
   32 = word-completion
   ... although so far the only thing being checked is 2 = errors
*/
#define FLAG_FOR_HIGHLIGHTS 1
#define FLAG_FOR_ERRORS     2

  int token_type(QChar *token, int token_length, bool ansi_quotes);
  void initial_asserts();
  void tokens_to_keywords(QString text, int start, bool ansi_quotes);
  void tokens_to_keywords_revert(int i_of_body, int i_of_function, int i_of_do, QString text, int start);
  int next_token(int i);
  int get_keyword_index(const char *, char *);
  bool is_client_statement(int, int, QString);
  int find_start_of_body(QString text, int start, int *i_of_function, int *i_of_do);
#if (OCELOT_MYSQL_INCLUDE == 1)
  int connect_mysql(unsigned int connection_number);
  void connect_mysql_error_box(QString, unsigned int);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
  int connect_tarantool(unsigned int connection_number, QString, QString, QString, QString);
  void tarantool_initialize(int connection_number);
  void tarantool_flush_and_save_reply(unsigned int);
  const char *tarantool_point_to_data();
  int tarantool_real_query(const char *dbms_query, unsigned long dbms_query_len, unsigned int, unsigned int, unsigned int, const QString *);
  int tarantool_get_result_set(int, int);
  QString tarantool_get_messages(int);
  bool tarantool_is_result_count(const char *);
  const char *tarantool_get_result_type(int, const char *, int *);
  QString get_statement_type(QString, int *);
  int get_statement_type_low(QString, QString, QString);
  QString tarantool_fetch_row(const char *tarantool_tnt_reply_data, int *bytes, int *tsize);
  int tarantool_fetch_row_ext(const char *tarantool_tnt_reply_data, char *value_as_string);
  QString tarantool_fetch_header_row();
  const char * tarantool_seek_0(int*);
  QString tarantool_internal_query(char*, int);
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
  QString select_1_row(const char *select_statement);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  QWidget *main_window;
public:
  TextEditHistory *history_edit_widget;
private:

#if (OCELOT_MYSQL_DEBUGGER == 1)
#define DEBUG_TAB_WIDGET_MAX 10
  QWidget *debug_top_widget;
  QVBoxLayout *debug_top_widget_layout;
  QLineEdit *debug_line_widget;
  QTabWidget *debug_tab_widget;
  CodeEditor *debug_widget[DEBUG_TAB_WIDGET_MAX]; /* todo: this should be variable-size */
#endif
#if (OCELOT_FIND_WIDGET == 1)
  Find_widget *find_widget;
#endif
  XSettings *xsettings_widget;
  QMenu *menu_file;
    QAction *menu_file_action_connect;
    QAction *menu_file_action_exit;
#if (OCELOT_IMPORT_EXPORT == 1)
    QAction *menu_file_action_export;
#endif
  QMenu *menu_edit;
    QAction *menu_edit_action_cut;
    QAction *menu_edit_action_copy;
    QAction *menu_edit_action_paste;
    QAction *menu_edit_action_undo;
    QAction *menu_edit_action_redo;
    QAction *menu_edit_action_select_all;
    QAction *menu_edit_action_history_markup_previous;
    QAction *menu_edit_action_history_markup_next;
    QAction *menu_edit_action_formatter;
    QAction *menu_edit_action_zoomin;
    QAction *menu_edit_action_zoomout;
    QAction *menu_edit_action_find;
public:
    QAction *menu_edit_action_autocomplete;
private:
  QMenu *menu_run;
    QAction *menu_run_action_execute;
    QAction *menu_run_action_kill;
  QMenu *menu_settings;
    QAction *menu_settings_action_menu;
    QAction *menu_settings_action_history;
    QAction *menu_settings_action_grid;
    QAction *menu_settings_action_statement;
    QAction *menu_settings_action_debug;
    QAction *menu_settings_action_extra_rule_1;
public:
  QMenu *menu_options;
  QAction *menu_options_action_option_detach_history_widget;
    QAction *menu_options_action_option_detach_result_grid_widget;
#if (OCELOT_MYSQL_DEBUGGER == 1)
    QAction *menu_options_action_option_detach_debug_widget;
#endif
    QAction *menu_options_action_option_detach_statement_widget;
    QAction *menu_options_action_next_window;
    QAction *menu_options_action_previous_window;
    QAction *menu_options_action_batch;
    QAction *menu_options_action_horizontal;
    QAction *menu_options_action_html;
    QAction *menu_options_action_htmlraw;
    QAction *menu_options_action_raw;
    QAction *menu_options_action_vertical;
    QAction *menu_options_action_xml;
private:
#if (OCELOT_MYSQL_DEBUGGER == 1)
  QMenu *menu_debug;
//    QAction *menu_debug_action_install;
//    QAction *menu_debug_action_setup;
//    QAction *menu_debug_action_debug;
    QAction *menu_debug_action_breakpoint;
    QAction *menu_debug_action_continue;
    QAction *menu_debug_action_leave;
    QAction *menu_debug_action_next;
//    QAction *menu_debug_action_skip;
    QAction *menu_debug_action_step;
    QAction *menu_debug_action_clear;
//    QAction *menu_debug_action_delete;
    QAction *menu_debug_action_exit;
    QAction *menu_debug_action_information;
    QAction *menu_debug_action_refresh_server_variables;
    QAction *menu_debug_action_refresh_user_variables;
    QAction *menu_debug_action_refresh_variables;
    QAction *menu_debug_action_refresh_call_stack;
#endif
  QMenu *menu_help;
    QAction *menu_help_action_about;
    QAction *menu_help_action_the_manual;
#if (OCELOT_MYSQL_INCLUDE == 1)
    QAction *menu_help_action_libmysqlclient;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
    QAction *menu_help_action_settings;

  //QWidget *the_manual_widget;
  //  QVBoxLayout *the_manual_layout;
  //  QTextEdit *the_manual_text_edit;
  //  QPushButton *the_manual_pushbutton;

  /* QTableWidget *grid_table_widget; */
public:
  QTabWidget48 *result_grid_tab_widget;
private:
  unsigned long result_row_count;

  int history_markup_counter; /* 0 when execute, +1 when "previous statement", -1 for "next statement" */

  int statement_edit_widget_text_changed_flag;
  QString ocelot_delimiter_str;                                           /* set up in connect section */
  int ocelot_password_was_specified; /* 0: never mentioned. 1: "--password=". 2: "password" but not "=". */

  /* MYSQL mysql; */
  MYSQL_RES *mysql_res;
  /* MYSQL_FIELD *fields; */

#ifdef DBMS_TARANTOOL
  struct tnt_reply tarantool_tnt_reply;
  const char *tarantool_tnt_reply_data_p; /* initially = tarantool_tnt_reply.data. can move if transaction. */
  unsigned int tarantool_field_names_count; /* duplication of field_name_list_all_rows.count() -- unnecessary? */
  bool tarantool_select_nosql;
  QStringList tarantool_table_ids;
  QStringList tarantool_table_names;
  QStringList tarantool_column_table_names;
  QStringList tarantool_column_names;
  QStringList tarantool_index_table_names;
  QStringList tarantool_index_names;
  QStringList tarantool_trigger_names;
#endif

  QKeySequence ocelot_shortcut_connect_keysequence;
  QKeySequence ocelot_shortcut_exit_keysequence;
  QKeySequence ocelot_shortcut_undo_keysequence;
  QKeySequence ocelot_shortcut_redo_keysequence;
  QKeySequence ocelot_shortcut_cut_keysequence;
  QKeySequence ocelot_shortcut_copy_keysequence;
  QKeySequence ocelot_shortcut_paste_keysequence;
  QKeySequence ocelot_shortcut_select_all_keysequence;
  QKeySequence ocelot_shortcut_history_markup_previous_keysequence;
  QKeySequence ocelot_shortcut_history_markup_next_keysequence;
  QKeySequence ocelot_shortcut_format_keysequence;
  QKeySequence ocelot_shortcut_zoomin_keysequence;
  QKeySequence ocelot_shortcut_zoomout_keysequence;
  QKeySequence ocelot_shortcut_autocomplete_keysequence;
  QKeySequence ocelot_shortcut_find_keysequence;
  QKeySequence ocelot_shortcut_execute_keysequence;
  QKeySequence ocelot_shortcut_kill_keysequence;
  QKeySequence ocelot_shortcut_next_window_keysequence;
  QKeySequence ocelot_shortcut_previous_window_keysequence;
  QKeySequence ocelot_shortcut_batch_keysequence;
  QKeySequence ocelot_shortcut_horizontal_keysequence;
  QKeySequence ocelot_shortcut_html_keysequence;
  QKeySequence ocelot_shortcut_htmlraw_keysequence;
  QKeySequence ocelot_shortcut_raw_keysequence;
  QKeySequence ocelot_shortcut_vertical_keysequence;
  QKeySequence ocelot_shortcut_xml_keysequence;
#if (OCELOT_MYSQL_DEBUGGER == 1)
  QKeySequence ocelot_shortcut_breakpoint_keysequence;
  QKeySequence ocelot_shortcut_continue_keysequence;
  QKeySequence ocelot_shortcut_next_keysequence;
  QKeySequence ocelot_shortcut_step_keysequence;
  QKeySequence ocelot_shortcut_clear_keysequence;
  QKeySequence ocelot_shortcut_debug_exit_keysequence;
  QKeySequence ocelot_shortcut_information_keysequence;
  QKeySequence ocelot_shortcut_refresh_server_variables_keysequence;
  QKeySequence ocelot_shortcut_refresh_user_variables_keysequence;
  QKeySequence ocelot_shortcut_refresh_variables_keysequence;
  QKeySequence ocelot_shortcut_refresh_call_stack_keysequence;
#endif

public:
#if (OCELOT_FIND_WIDGET == 1)
  QObject *last_focus_widget;
#endif
  bool keypress_shortcut_handler(QKeyEvent *, bool);
  int tarantool_execute_sql(const char *, unsigned int, int);
  int tarantool_execute_lua(const char *, unsigned int, int);
  int tarantool_execute_lua_select(int, int);
  QString query_utf16;
  QString query_utf16_copy;
  /* main_token_offsets|lengths|types|flags|pointers are alloc'd in main_token_new() */
  int  *main_token_offsets;
  int  *main_token_lengths;
  int  *main_token_types;
  unsigned int *main_token_flags; /* e.g. TOKEN_FLAG_IS_RESERVED */
  int  *main_token_pointers;
  unsigned char *main_token_reftypes;
  unsigned int main_token_max_count;
  unsigned int main_token_count_in_all;
  unsigned int main_token_count_in_statement;
  /* todo: is main_token_number obsolete? does it do anything? */
  unsigned int main_token_number;      /* = offset within main_token_offsets, e.g. 0 if currently at first token */

  int  *saved_main_token_offsets;
  int  *saved_main_token_lengths;
  int  *saved_main_token_types;
  unsigned int *saved_main_token_flags;
  int  *saved_main_token_pointers;
  unsigned char *saved_main_token_reftypes;
  /* unsigned int saved_main_token_max_count; doesn't need saving */
  unsigned int saved_main_token_count_in_all;
  unsigned int saved_main_token_count_in_statement;
  unsigned int saved_main_token_number;

  QString tarantool_table_name;
  QString tarantool_column_name;

  /*
    result_type values, determined by tarantool_get_result_type()
    4 == result set of box.space.x:select() with signature = array+array
    5 == result set of SQL select|values, with "metadata" signature
    6 == result of SQL not select|values, with "row_count" signature
    7 == error with "Error: " signature (but maybe RESULT_TYPE_0 is error as well?)
    8 = result set from box.execute() so tarantool_tnt_reply.metadata != 0
  */
  #define RESULT_TYPE_0 0
  #define RESULT_TYPE_1 1
  #define RESULT_TYPE_2 2
  #define RESULT_TYPE_3 3
  #define RESULT_TYPE_4 4
  #define RESULT_TYPE_5 5
  #define RESULT_TYPE_6 6
  #define RESULT_TYPE_7 7
  #define RESULT_TYPE_8 8

  /* main_token_flags[] values. so far there are only sixteen but we expect there will be more. */
  #define TOKEN_FLAG_IS_RESERVED 1
  #define TOKEN_FLAG_IS_BLOCK_END 2
  #define TOKEN_FLAG_IS_ERROR 4
  #define TOKEN_FLAG_IS_FUNCTION 8
  #define TOKEN_FLAG_IS_START_STATEMENT 16
  #define TOKEN_FLAG_IS_START_CLAUSE 32
  #define TOKEN_FLAG_IS_START_SUBCLAUSE 64
  #define TOKEN_FLAG_IS_DATA_TYPE 128
  #define TOKEN_FLAG_IS_START_IN_COLUMN_LIST 256
  #define TOKEN_FLAG_IS_END_IN_COLUMN_LIST 512
  #define TOKEN_FLAG_IS_BINARY_PLUS_OR_MINUS 1024
  #define TOKEN_FLAG_IS_NOT_AFTER_SPACE 2048
  #define TOKEN_FLAG_IS_MAYBE_LUA 4096
  #define TOKEN_FLAG_IS_LUA 8192
  #define TOKEN_FLAG_IS_FLOW_CONTROL 16384
  #define TOKEN_FLAG_IS_DEBUGGABLE 32768
  #define TOKEN_FLAG_IS_DECLARE 65536
  #define TOKEN_FLAG_IS_PLSQL_DECLARE_SEMICOLON 131072
  //#define TOKEN_FLAG_IS_ASSIGNEE 262144
  #define TOKEN_FLAG_IS_NEW 262144

/* The enum for TOKEN_TYPE_LITERAL etc. was here, but moved outside MainWindow on 2019-02-26 */

/*
  TOKEN_LITERAL_FLAG is for passing required format to hparse_f_literal().
  Example: +5 is okay if we're looking for signed integer,
  but if we say hparse_f_literal(TOKEN_LITERAL_FLAG_UNSIGNED_INTEGER)
  then the only acceptable literals are unsigned integers.
  Todo: The expected will still say "[literal]", more general than needed.
  Todo: We aren't specific enough, we don't use this enough.
*/
#define TOKEN_LITERAL_FLAG_STRING               1
#define TOKEN_LITERAL_FLAG_SIGNED_INTEGER       2
#define TOKEN_LITERAL_FLAG_UNSIGNED_INTEGER     4
#define TOKEN_LITERAL_FLAG_INTEGER              (2+4)
#define TOKEN_LITERAL_FLAG_FLOAT                8
#define TOKEN_LITERAL_FLAG_NUMBER               (2+4+8)
#define TOKEN_LITERAL_FLAG_CONSTANT             16
#define TOKEN_LITERAL_FLAG_STRING_OR_NUMBER_OR_CONSTANT (1+2+4+8+16)
#define TOKEN_LITERAL_FLAG_INTRODUCER           32
#define TOKEN_LITERAL_FLAG_INTRODUCEABLE_STRING (1+32)
#define TOKEN_LITERAL_FLAG_USER                 64
#define TOKEN_LITERAL_FLAG_USER_STRING          (1+64)
#define TOKEN_LITERAL_FLAG_HOST                 128
#define TOKEN_LITERAL_FLAG_HOST_STRING          (1+128)
#define TOKEN_LITERAL_FLAG_ODBC                 256
#define TOKEN_LITERAL_FLAG_ODBC_STRING          (1+256)
#define TOKEN_LITERAL_FLAG_DATE                 512
#define TOKEN_LITERAL_FLAG_DATE_STRING          (1+512)
#define TOKEN_LITERAL_FLAG_ANY                  (1+2+4+8+16+32+64+128+256+512)

/*
  TOKEN_TYPE_... shows "what kind of token is it?" e.g. TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK.
  TOKEN_REFTYPE_... shows "what kind of object does the token refer to?"
  e.g. if it's identifier, is it a database identifier?
  We only pass something specific if we are sure that is what must follow.
  Beware: A "user" might be qualified within 'user'@'host' I guess that's a form of qualifier.
  Beware: there are enum values for "x or y" e.g. "user or role", "database or table", etc.
  TOKEN_REFTYPE_... values and must be in the same order.
  Todo: store these in main_token_reftypes[] to help hovering.
  Todo: knowing it's "column" doesn't help us yet with knowing: column of what?
        but eventually we can bring in lists of objects, and refer to them by number-within-the-list
  Todo: eventually we can be sure, after qualification is done, for a column (e.g. we've seen FROM)
  Todo: Get rid of enums that aren't actually used.
... And my plan is:
* Always pass reftype for hparse_f_accept and hparse_f_acceptn and hparse_f_expect
* If the pass is "[identifier]" then the expected list gets "[table identifier]", etc.
* Eventually, use this so we can auto-complete any object names
  (We'll have a local list of object names so we can store numbers.)
* Eventually, have reftypes for literals too -- again, meaning "what they refer to", not format
* Check: sometimes TOKEN_TYPE_IDENTIFIER_WITH_AT is not appropriate
* For LIMIT and OFFSET, the only possibilities are @variable and declared variable and parameter
* I'd also like to restrict what FETCH variable can be
* Whenever it is specific, IDENTIFIER_WITH_AT is not appropriate,
  and a maximum length is applicable such as MYSQL_MAX_IDENTIFIER_LENGTH.
* There is one case where we pass "[reserved function]" instead of "[identifier]".
*/

enum {
    TOKEN_REFTYPE_ANY,                 /* any kind, or it's irrelevant, or we don't care */
    TOKEN_REFTYPE_ALIAS_OF_COLUMN, /* or correlation */
    TOKEN_REFTYPE_ALIAS_OF_TABLE, /* or correlation */
    TOKEN_REFTYPE_ATTRIBUTE,
    TOKEN_REFTYPE_AUTO_INCREMENT,
    TOKEN_REFTYPE_CHANNEL,
    TOKEN_REFTYPE_CHARACTER_SET,
    TOKEN_REFTYPE_COLLATION,
    TOKEN_REFTYPE_COLUMN,
    TOKEN_REFTYPE_COLUMN_OR_USER_VARIABLE,
    TOKEN_REFTYPE_COLUMN_OR_VARIABLE,
    TOKEN_REFTYPE_COMMENT,
    TOKEN_REFTYPE_CONDITION_DEFINE,
    TOKEN_REFTYPE_CONDITION_REFER,
    TOKEN_REFTYPE_CONDITION_OR_CURSOR,
    TOKEN_REFTYPE_CONSTRAINT,
    TOKEN_REFTYPE_CURSOR_DEFINE,
    TOKEN_REFTYPE_CURSOR_REFER,
    TOKEN_REFTYPE_DATABASE, /* or schema */
    TOKEN_REFTYPE_DATABASE_OR_CONSTRAINT,
    TOKEN_REFTYPE_DATABASE_OR_EVENT,
    TOKEN_REFTYPE_DATABASE_OR_FUNCTION,
    TOKEN_REFTYPE_DATABASE_OR_FUNCTION_OR_PROCEDURE,
    TOKEN_REFTYPE_DATABASE_OR_FUNCTION_OR_VARIABLE,
    TOKEN_REFTYPE_DATABASE_OR_PACKAGE,
    TOKEN_REFTYPE_DATABASE_OR_PROCEDURE,
    TOKEN_REFTYPE_DATABASE_OR_SEQUENCE,
    TOKEN_REFTYPE_DATABASE_OR_TABLE,
    TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW,
    TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN,
    TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN_OR_FUNCTION,
    TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_VARIABLE_OR_FUNCTION,
    TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW_OR_FUNCTION_OR_COLUMN,
    TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW_OR_FUNCTION_OR_VARIABLE,
    TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN_OR_FUNCTION_OR_VARIABLE,
    TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW_OR_COLUMN_OR_FUNCTION_OR_VARIABLE,
    TOKEN_REFTYPE_DATABASE_OR_TRIGGER,
    TOKEN_REFTYPE_DATABASE_OR_VIEW,
    TOKEN_REFTYPE_DIRECTORY,
    TOKEN_REFTYPE_ENGINE,
    TOKEN_REFTYPE_EVENT,
    TOKEN_REFTYPE_FILE,
    TOKEN_REFTYPE_FUNCTION,
    TOKEN_REFTYPE_FUNCTION_OR_PROCEDURE,
    TOKEN_REFTYPE_FUNCTION_OR_VARIABLE,
    TOKEN_REFTYPE_HANDLER_ALIAS,
    TOKEN_REFTYPE_HOST,
    TOKEN_REFTYPE_INDEX,
    TOKEN_REFTYPE_INTRODUCER,
    TOKEN_REFTYPE_KEY_CACHE,
    TOKEN_REFTYPE_LABEL_DEFINE,
    TOKEN_REFTYPE_LABEL_REFER,
    TOKEN_REFTYPE_LENGTH,
    TOKEN_REFTYPE_PACKAGE,
    TOKEN_REFTYPE_PARAMETER_DEFINE,
    TOKEN_REFTYPE_PARAMETER_REFER,
    TOKEN_REFTYPE_PARSER,
    TOKEN_REFTYPE_PLUGIN,
    TOKEN_REFTYPE_PROCEDURE,
    /* plus TOKEN_REFTYPE_RESERVED_FUNCTION */
    TOKEN_REFTYPE_PARTITION,
    TOKEN_REFTYPE_PARTITION_NUMBER,
    TOKEN_REFTYPE_PASSWORD,
    TOKEN_REFTYPE_ROLE,
    TOKEN_REFTYPE_ROW,
    TOKEN_REFTYPE_ROW_OR_VARIABLE,
    TOKEN_REFTYPE_SAVEPOINT,
    TOKEN_REFTYPE_SCALE,
    TOKEN_REFTYPE_SEQUENCE,
    TOKEN_REFTYPE_SERVER,
    TOKEN_REFTYPE_SQLSTATE,
    TOKEN_REFTYPE_STATEMENT,
    TOKEN_REFTYPE_SUBPARTITION,
    TOKEN_REFTYPE_SWITCH_NAME,
    TOKEN_REFTYPE_TABLE,
    TOKEN_REFTYPE_TABLE_OR_COLUMN,
    TOKEN_REFTYPE_TABLE_OR_COLUMN_OR_FUNCTION,
    TOKEN_REFTYPE_TABLE_OR_COLUMN_OR_FUNCTION_OR_VARIABLE,
    TOKEN_REFTYPE_TABLE_OR_ROW,
    TOKEN_REFTYPE_TABLESPACE,
    TOKEN_REFTYPE_TRANSACTION,
    TOKEN_REFTYPE_TRIGGER,
    TOKEN_REFTYPE_USER,
    TOKEN_REFTYPE_USER_VARIABLE,
    TOKEN_REFTYPE_VARIABLE,         /* i.e. either USER_VARIABLE or DECLARED VARIABLE */
    TOKEN_REFTYPE_VARIABLE_DEFINE,
    TOKEN_REFTYPE_VARIABLE_REFER,
    TOKEN_REFTYPE_VIEW,
    TOKEN_REFTYPE_WINDOW_DEFINE,
    TOKEN_REFTYPE_WINDOW_REFER,
    TOKEN_REFTYPE_WITH_TABLE,
    TOKEN_REFTYPE_WRAPPER,
    TOKEN_REFTYPE_MAX
    /*
      In ocelotgui.h we say "assert(TOKEN_REFTYPE_MAX == 91);".
      If it blows, that means you changed the above enum list.
      Which is okay, but before you change the assert, make sure
      reftypewords list corresponds to the enum list!
    */
  };
};

#endif // MAINWINDOW_H


#ifdef DBMS_TARANTOOL
/*
  Tarantool comments
  ------------------

  Automatic field names. Every tuple is an array with possible sub-arrays.
  In standard SQL we'd designate with f[1] f[1][1] f[1][1][1].
  But we will prefer f_1 f_1_1 f_1_1 so it's compatible with MySQL.
  The letter "f" is arbitrary, it's #define TARANTOOL_FIELD_NAME_BASE.

  Todo: probable bug: a map of arrays will probably cause a crash.
*/

/* If you want field names to start with "foo" instead of "f", change TARANTOOL_FIELD_NAME_BASE. */
#define TARANTOOL_FIELD_NAME_BASE "f"

/* Names like f_1_1 are shorter than 64 characters, but we might have user-defined names. */

#define TARANTOOL_MAX_FIELD_NAME_LENGTH 64
#define TARANTOOL_BOX_INDEX_EQ 0
#define TARANTOOL_BOX_INDEX_ALL 2
#define TARANTOOL_BOX_INDEX_LT 3
#define TARANTOOL_BOX_INDEX_LE 4
#define TARANTOOL_BOX_INDEX_GE 5
#define TARANTOOL_BOX_INDEX_GT 6

#define ER_8372_INT 8372

#endif

#define TEXTEDITFRAME_CELL_TYPE_DETAIL 0
#define TEXTEDITFRAME_CELL_TYPE_HEADER 1
#define TEXTEDITFRAME_CELL_TYPE_DETAIL_EXTRA_RULE_1 2


#ifdef OLD_STUFF
/*****************************************************************************************************************************/
/* THE TEXTEDITFRAME WIDGET */
/* See comments containing the word TextEditFrame, in ResultGrid code. */

#ifndef TEXTEDITFRAME_H
#define TEXTEDITFRAME_H


class TextEditFrame : public QFrame
{
  Q_OBJECT

public:
  explicit TextEditFrame(QWidget *parent, ResultGrid *ancestor, unsigned int index);
  ~TextEditFrame();

  int border_size;
  int minimum_width;
  int minimum_height;
  ResultGrid *ancestor_result_grid_widget;
  unsigned int text_edit_frames_index;                 /* e.g. for text_edit_frames[5] this will contain 5 */
  int ancestor_grid_column_number;
  int ancestor_grid_result_row_number;
  unsigned int content_length;
  /* todo: check: could this be unsigned char cell_type instead of unsigned short int cell_type? */
  unsigned short int cell_type;                        /* detail or header or detail_extra_rule_1 */
  char content_field_value_flags; /* if detail, might be a copy of result_row_copy field_value_flag values */
  char *content_pointer; /* if detail, might point to result_row_copy */
  bool is_retrieved_flag;
  bool is_style_sheet_set_flag;
  /* todo: check: now that we have field_value_flags, can we get rid of is_image_flag? */
  bool is_image_flag;                    /* true if data type = blob and appropriate flag is on */

protected:
  void mousePressEvent(QMouseEvent *event);
  void mouseMoveEvent(QMouseEvent* event);
  void mouseReleaseEvent(QMouseEvent *event);
  void paintEvent(QPaintEvent *event);

private:
  int left_mouse_button_was_pressed;
  int widget_side;
  enum {LEFT= 1, RIGHT= 2, TOP= 3, BOTTOM= 4};
  bool comparer(QString opd1, QString opd2, QString opr, char field_value_flags);
  void style_sheet_setter(TextEditFrame *text_frame, TextEditWidget *text_edit);
};
#endif // TEXTEDITFRAME_H
#endif

#ifdef OLD_STUFF
/*********************************************************************************************************/
/* THE TEXTEDITWIDGET WIDGET */
/* subclassed QTextEdit so paintEvent can be caught, for use in result_grid */
/* also for focusoutEvent|focusInEvent, since eventfilter use would probably cost more */

#ifndef TEXTEDITWIDGET_H
#define TEXTEDITWIDGET_H
class TextEditWidget : public QTextEdit
{
  Q_OBJECT

public:
  explicit TextEditWidget(QWidget *parent);
  ~TextEditWidget();

  TextEditFrame *text_edit_frame_of_cell;

  void copy();
  void paste();

  void generate_update();
protected:
  void paintEvent(QPaintEvent *event);
  void keyPressEvent(QKeyEvent *event);
  void focusOutEvent(QFocusEvent *event);
  void focusInEvent(QFocusEvent *event);

  QString unstripper(QString value_to_unstrip);


};

#endif // TEXTEDITWIDGET_H
#endif

/*********************************************************************************************************/
/* THE ROW_FORM_BOX WIDGET */

/*
  Todo: Currently this is only used for connecting. And export dialog coming soon.
        But it should be very easy to use with result-table rows,
        either for vertical display or in response to a keystroke on ResultGrid.
*/

/*
  Todo: Settle minimum and maximum width of dialog box.
        The calculation of main_window_maximum_width has been helpful here.
        Settle maximum width of each item.

  If user hits Enter, that should get Cancel or OK working.

  error text= "password must be entered" | as returned from last attempt | nothing (File|Connect)
  invoke: at start / when user types CONNECT / When File|Connect ... no auto-restart
  Actually call myoptions_and_connect()!
  Re-order the items?
  Would QTextEdit be nicer? You'd have horizontal scroll bars if necessary. However, a password would still be QLineEdit
                            Right ... QTextEdit, and height = 2 lines if otherwise there would be overflow
  Use row_form_width[]!
  Think again about how tabs work: setTabChangesFocus(true) works, but now it's hard to put a tab in except with escaping.
  Make spacing between widgets smaller: see comments about "no effect" below.
*/

#ifndef ROW_FORM_BOX_H
#define ROW_FORM_BOX_H
class Row_form_box: public QDialog
{
  Q_OBJECT
public:
  QDialog *row_form_box;
  bool is_ok;

private:
  QLabel **label;
  QLineEdit **line_edit;
  QTextEdit **text_edit;
  QComboBox **combo_box_edit;
  QHBoxLayout **hbox_layout;
  QWidget **widget;
  QPushButton *button_for_cancel, *button_for_ok;
  QHBoxLayout *hbox_layout_for_ok_and_cancel;
  QVBoxLayout *main_layout;
  QWidget *widget_for_ok_and_cancel;
  MainWindow *copy_of_parent;
  QLabel *label_for_message;
  QScrollArea *scroll_area;
  QWidget *widget_with_main_layout;
  QVBoxLayout *upper_layout;
  QWidget *widget_for_size_hint;

  int column_count_copy;
  int *row_form_is_password_copy;
  QString *row_form_data_copy;
  Row_form_box *this_row_form_box;
  int width_for_size_hint, height_for_size_hint;

public:
Row_form_box(int column_count, QString *row_form_label,
             int *row_form_type,
             int *row_form_is_password, QString *row_form_data,
//             QString *row_form_width,
             QString row_form_title, QString row_form_message,
             MainWindow *parent): QDialog(parent)
{
  int i;
  this_row_form_box= this;
  copy_of_parent= parent;
  column_count_copy= column_count;
  row_form_is_password_copy= row_form_is_password;
  row_form_data_copy= row_form_data;
  main_layout= 0;
  label_for_message= 0;
  label= 0;
  line_edit= 0;
  text_edit= 0;
  combo_box_edit= 0;
  hbox_layout= 0;
  widget= 0;
  button_for_cancel= 0;
  button_for_ok= 0;
  hbox_layout_for_ok_and_cancel= 0;
  widget_for_ok_and_cancel= 0;
  scroll_area= 0;
  widget_with_main_layout= 0;
  upper_layout= 0;
  widget_for_size_hint= 0;

  label= new QLabel*[column_count];
  line_edit= new QLineEdit*[column_count];
  text_edit= new QTextEdit*[column_count];
  combo_box_edit= new QComboBox*[column_count];
  hbox_layout= new QHBoxLayout*[column_count];
  widget= new QWidget*[column_count];

  for (i= 0; i < column_count; ++i)
  {
    label[i]= 0;
    line_edit[i]= 0;
    text_edit[i]= 0;
    combo_box_edit[i]= 0;
    hbox_layout[i]= 0;
    widget[i]= 0;
  }
  is_ok= 0;
  int character_height, borders_height, component_height;

  parent->component_size_calc(&character_height, &borders_height);
  component_height= character_height + borders_height;
  /*
    Subsequently, for spacing between lines, I finally realized that it's not enough
    to do setSpacing + setContentsMargins for the QVBoxLayout, I have to do them
    for each QHBoxLayout as well.
  */
  main_layout= new QVBoxLayout();
  main_layout->setSpacing(0);
  main_layout->setContentsMargins(QMargins(0, 0, 0, 0));
  main_layout->setSizeConstraint(QLayout::SetFixedSize);  /* necessary, but I don't know why */
  label_for_message= new QLabel(row_form_message);
  main_layout->addWidget(label_for_message);
  for (i= 0; i < column_count; ++i)
  {
    hbox_layout[i]= new QHBoxLayout();
    //hbox_layout[i]->setSpacing(0);
    hbox_layout[i]->setContentsMargins(QMargins(2, 2, 2, 2));
    hbox_layout[i]->setSizeConstraint(QLayout::SetFixedSize);  /* necessary, but I don't know why */
    label[i]= new QLabel();
    label[i]->setStyleSheet(parent->ocelot_grid_header_style_string);
    label[i]->setMinimumHeight(component_height);
    label[i]->setText(row_form_label[i]);
    hbox_layout[i]->addWidget(label[i]);

    if (row_form_is_password[i] == 1)
    {
      line_edit[i]= new QLineEdit();
      line_edit[i]->setStyleSheet(parent->ocelot_grid_style_string);
      line_edit[i]->insert(row_form_data[i]);
      line_edit[i]->setEchoMode(QLineEdit::Password); /* maybe PasswordEchoOnEdit would be better */
      line_edit[i]->setMaximumHeight(component_height);
      line_edit[i]->setMinimumHeight(component_height);
      hbox_layout[i]->addWidget(line_edit[i]);
    }
    else if (row_form_is_password[i] == 0)
    {
      text_edit[i]= new QTextEdit();

      if ((row_form_type[i] & READONLY_FLAG) != 0)
      {
        text_edit[i]->setStyleSheet(parent->ocelot_grid_header_style_string);
        text_edit[i]->setReadOnly(true);
      }
      else
      {
        text_edit[i]->setStyleSheet(parent->ocelot_grid_style_string);
        text_edit[i]->setReadOnly(false);
      }
      text_edit[i]->setText(row_form_data[i]);
      text_edit[i]->setMaximumHeight(component_height);
      text_edit[i]->setMinimumHeight(component_height);
      text_edit[i]->setTabChangesFocus(true);
      /* The following line will work, but I'm undecided whether it's desirable. */
      //if ((row_form_type[i] & NUM_FLAG) != 0) text_edit[i]->setAlignment(Qt::AlignRight);
      hbox_layout[i]->addWidget(text_edit[i]);
    }
    else /* row_form_is_password[i] == 2 */
    {
      combo_box_edit[i]= new QComboBox();
      combo_box_edit[i]->setMaximumHeight(component_height);
      combo_box_edit[i]->setMinimumHeight(component_height);
      //combo_box_edit[i]->setTabChangesFocus(true);

      QStringList qs= parent->fake_statement(row_form_data[i]);
      for (int j= 0; j < qs.size(); ++j) combo_box_edit[i]->addItem(qs.at(j));

      combo_box_edit[i]->addItem("Wombat");
      hbox_layout[i]->addWidget(combo_box_edit[i]);
    }
    widget[i]= new QWidget();
    widget[i]->setLayout(hbox_layout[i]);
    main_layout->addWidget(widget[i]);
  }
  button_for_cancel= new QPushButton(menu_strings[menu_off + MENU_CANCEL], this);
  button_for_ok= new QPushButton(menu_strings[menu_off + MENU_OK], this);
  hbox_layout_for_ok_and_cancel= new QHBoxLayout();
  hbox_layout_for_ok_and_cancel->addWidget(button_for_cancel);
  hbox_layout_for_ok_and_cancel->addWidget(button_for_ok);
  widget_for_ok_and_cancel= new QWidget();
  widget_for_ok_and_cancel->setLayout(hbox_layout_for_ok_and_cancel);
  connect(button_for_ok, SIGNAL(clicked()), this, SLOT(handle_button_for_ok()));
  connect(button_for_cancel, SIGNAL(clicked()), this, SLOT(handle_button_for_cancel()));

  widget_with_main_layout= new QWidget();
  widget_with_main_layout->setLayout(main_layout);
  widget_with_main_layout->setMaximumHeight(200);
  scroll_area= new QScrollArea();
  scroll_area->setWidget(widget_with_main_layout);
  scroll_area->setWidgetResizable(true);

  upper_layout= new QVBoxLayout;
  upper_layout->addWidget(scroll_area);

  upper_layout->addWidget(widget_for_ok_and_cancel);

  /* Last-minute changes due to failure with Ubuntu 14.04 */
  /* Removing widget_for_size_hint */
  /* Removing QSize size_hint */
  /* Instead we'll use scroll bar always on */
  scroll_area->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
  scroll_area->show();
  width_for_size_hint= scroll_area->width() + 25;
  height_for_size_hint= scroll_area->height();


  //{
  //  widget_for_size_hint= new QDialog(this);
  //  widget_for_size_hint->setLayout(upper_layout);
  //  widget_for_size_hint->setWindowOpacity(0);                      /* perhaps unnecessary */
  //  widget_for_size_hint->show();
  //  width_for_size_hint= widget_for_size_hint->width()
  //                     + scroll_area->verticalScrollBar()->width()
  //                     + 5;
  //  height_for_size_hint= widget_for_size_hint->height();
  //  widget_for_size_hint->close();
  //}

  this->setLayout(upper_layout);
  this->setWindowTitle(row_form_title);
}


/*
  Row_form_box will have the wrong width if everything is default:
  about 20 pixels too short, as if it didn't expect a vertical scroll bar.
    I could make Qt do a better calculation by saying
    scroll_area->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
    but someday I'll want to use Row_form_box for purposes besides connect.
  Our solution is to make a not-to-be-really-used widget,
  widget_for_size_hint, with the same layout, and use its width,
  plus the width of the vertical scroll bar, plus 5 (5 is arbitrary).
  We delete widget_for_size_hint during garbage_collect, but hope deletion is automatic.
  Todo: setWindowOpacity(0) for widget_for_size_hint?
*/
QSize sizeHint() const
{
  return QSize(width_for_size_hint, height_for_size_hint);
}

private slots:

void handle_button_for_ok()
{
  for (int i= 0; i < column_count_copy; ++i)
  {
    if (this_row_form_box->row_form_is_password_copy[i] == 1) this_row_form_box->row_form_data_copy[i]= line_edit[i]->text();
    else if (this_row_form_box->row_form_is_password_copy[i] == 0) this_row_form_box->row_form_data_copy[i]= text_edit[i]->toPlainText();
    else this_row_form_box->row_form_data_copy[i]= combo_box_edit[i]->currentText();
  }
  is_ok= 1;
  garbage_collect();
  close();
}


void handle_button_for_cancel()
{
  garbage_collect();
  close();
}


/*
  I'm doing my own garbage collection. Maybe it's a bad idea but it's the way that I know.
  Objective: anything set up with "new", without a "this", must be deleted explicitly.
  Todo: fillup_garbage_collect+display_garbage_collect for result_grid aren't as well put together as this.
*/
void garbage_collect ()
{
  int i;
  if (label != 0)
  {
    for (i= 0; i < column_count_copy; ++i) if (label[i] != 0) delete label[i];
    delete [] label;
  }
  if (line_edit != 0)
  {
    for (i= 0; i < column_count_copy; ++i) if (line_edit[i] != 0) delete line_edit[i];
    delete [] line_edit;
  }
  if (text_edit != 0)
  {
    for (i= 0; i < column_count_copy; ++i) if (text_edit[i] != 0) delete text_edit[i];
    delete [] text_edit;
  }
  if (combo_box_edit != 0)
  {
    for (i= 0; i < column_count_copy; ++i) if (combo_box_edit[i] != 0) delete combo_box_edit[i];
    delete [] combo_box_edit;
  }
  if (hbox_layout != 0)
  {
    for (i= 0; i < column_count_copy; ++i) if (hbox_layout[i] != 0) delete hbox_layout[i];
    delete [] hbox_layout;
  }
  if (widget != 0)
  {
    for (i= 0; i < column_count_copy; ++i) if (widget[i] != 0) delete widget[i];
    delete [] widget;
  }
  if (button_for_cancel != 0) delete button_for_cancel;
  if (button_for_ok != 0) delete button_for_ok;
  if (hbox_layout_for_ok_and_cancel != 0) delete hbox_layout_for_ok_and_cancel;
  if (widget_for_ok_and_cancel != 0) delete widget_for_ok_and_cancel;
  if (label_for_message != 0) delete label_for_message;
  if (main_layout != 0) delete main_layout;
  if (widget_with_main_layout != 0) delete widget_with_main_layout;
  if (upper_layout != 0) delete upper_layout;
  if (scroll_area != 0) delete scroll_area;
  if (widget_for_size_hint != 0) delete widget_for_size_hint;
}

};

#endif // ROW_FORM_BOX_H

#ifndef TEXTEDITWIDGET2_H
#define TEXTEDITWIDGET2_H

/*
  This is for when we want to size a QTextEdit based on its initial content.
  Minimum width is passed. Maximum height is assumed = 500.
  I suppose I don't really have to say "explicit" but it's harmless.
*/

class TextEditWidget2 : public QTextEdit
{
  Q_OBJECT

public:

    int passed_minimum_width;

~TextEditWidget2()
{
}

explicit TextEditWidget2(QString the_text, QWidget *parent, int minimum_width) :
        QTextEdit(the_text, parent)
    {
      passed_minimum_width= minimum_width;
    }

QSize sizeHint() const
{
  QRect text_edit_rect;
  QFontMetrics fm= QFontMetrics(font());
  text_edit_rect= fm.boundingRect(
        0, /* int x = x coordinate within original rect */
        0, /* int y = y coordinate within original rect */
        passed_minimum_width, /* int width = r.width(), which we don't change */
        2000, /* int height = height, which is arbitrary big maximum */
        Qt::TextWordWrap + Qt::TextIncludeTrailingSpaces, /* int flags = (see comments before start of this routine) */
        toPlainText()); /* QString & text= cell contents */
  int n= text_edit_rect.height() + fm.lineSpacing();
  if (n > 500) n= 500;
  return QSize(passed_minimum_width, n);
}

};
#endif // TEXTEDITWIDGET2_H

/***********************************************************/
/* THE MESSAGE_BOX WIDGET */
/***********************************************************/

/*
  QMessageBox equivalent, but with scroll bars.
  (A simple QMessageBox has no scroll bars.)
  We need scroll bars for some Help displays especially if screen size is small.
  Pass: button text e.g. "ok" or "yes" or "no". Sometimes two buttons.
  Return: 1 if button_1 pushed (default). 2 if button_2 pushed. Or equivalents e.g. Alt+Y for Yes.
  Also for hparse_f_multi_block() errors that get too long.
  Re size: We pass width to Message_box which passes it on to TextEditWidg2. But it doesn't mean that we
           will never go outside the bounds of MainWindow. And maximum height is hardcoded = 500.
  Re font: We use the same font as the statement, which might be a good choice when the dialog
           is for a syntax error on the statement widget, but less good for Help -- for Help,
           the menu font might be a better choice. We only use font and not other style sheet
           settings, and assume that it's best if QTextEdit2 and QPushButton have the same font.
  Todo: size calculation as in Row_form_box.
  Todo: Earlier, this had to exist for the scroll bar to work:
        layout->setSizeConstraint(QLayout::SetFixedSize);
        See if you can figure out why.
  Todo: Guarantee that initial width is enough so that entire header is visible.
*/
#ifndef MESSAGE_BOX_H
#define MESSAGE_BOX_H

class Message_box: public QDialog
{
  Q_OBJECT

public:
  int result;
Message_box(QString the_title, QString the_text, int minimum_width,
            QString prompter, QString button_1_text, QString button_2_text, MainWindow *parent): QDialog(parent)
{
  result= 1;
  this->setFont(parent->get_font_from_style_sheet(parent->ocelot_statement_style_string));
  QScrollArea *scroll_area= new QScrollArea(this);
  // scroll_area->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded); This is default anyway.
  //scroll_area->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded); This is default anyway.
  QWidget *widget= new QWidget(this);
  scroll_area->setWidget(widget);
  scroll_area->setWidgetResizable(true);
  QVBoxLayout *layout= new QVBoxLayout(widget);
  TextEditWidget2 *text_edit= new TextEditWidget2(the_text, this, minimum_width);
  text_edit->setReadOnly(true);
  layout->addWidget(text_edit);
  QVBoxLayout *prompter_and_buttons_layout= new QVBoxLayout(widget);
  QWidget *prompter_and_buttons_widget= new QWidget(this);
  if (prompter > "")
  {
    QLabel *prompter_label= new QLabel(prompter, this);
    prompter_and_buttons_layout->addWidget(prompter_label);
  }
  QHBoxLayout *buttons_layout= new QHBoxLayout(widget);
  QWidget *buttons_widget= new QWidget(this);
  QPushButton *push_button_1= new QPushButton(this);
  push_button_1->setText("&"+button_1_text);
  buttons_layout->addWidget(push_button_1);
  push_button_1->setAutoDefault(true);
  connect(push_button_1, SIGNAL(clicked()), this, SLOT(handle_button_1()));
  if (button_2_text > "")
  {
    QPushButton *push_button_2= new QPushButton(this);
    push_button_2->setText("&"+button_2_text);
    buttons_layout->addWidget(push_button_2);
    push_button_2->setAutoDefault(false);
    connect(push_button_2, SIGNAL(clicked()), this, SLOT(handle_button_2()));
  }
  buttons_widget->setLayout(buttons_layout);
  prompter_and_buttons_layout->addWidget(buttons_widget);
  prompter_and_buttons_widget->setLayout(prompter_and_buttons_layout);
  layout->addWidget(prompter_and_buttons_widget);
  widget->setLayout(layout);
  this->setMinimumWidth(minimum_width);
  this->setWindowTitle(the_title);
  QHBoxLayout *dialog_layout= new QHBoxLayout(this);
  this->setLayout(dialog_layout);
  this->layout()->addWidget(scroll_area);
}

private slots:

void handle_button_1()
{
  result= 1;
  /* Skipping garbage collect this time. */
  close();
}

void handle_button_2()
{
  result= 2;
  /* Skipping garbage collect this time. */
  close();
}


};

#endif // MESSAGE_BOX_H

#ifndef COMPLETER_WIDGET_H
#define COMPLETER_WIDGET_H

/* See comments just before Completer_widget::construct() */

class Completer_widget: public QTextEdit
{
  Q_OBJECT

private:
  MainWindow *main_window;
  QTimer *timer;
  QStringList string_list;
  QStringList string_list_tooltips;
  int current_row;
  QList<int> token_type_list;
void copy_string_list();
void construct();
void show_wrapper();
void line_colors();
void set_current_row(int);

private slots:
void timer_expired();

protected:
void mousePressEvent(QMouseEvent *event);
void mouseDoubleClickEvent(QMouseEvent *event);

public:
void set_timer_interval();
void initialize();
void hide_wrapper();
void clear_wrapper();
int count_wrapper();
QString get_selected_item(QString *tool_tip);
void size_and_position_change();
void append_wrapper(QString token, QString hparse_token, int token_type, int flags, QString final_letter);
bool key_up_or_down(int);
void updater();
void timer_reset();

Completer_widget(MainWindow *m)
{
  main_window= m;
  construct();
}

~Completer_widget()
{
  ;
}

};

#endif // COMPLETER_WIDGET_H

#if (OCELOT_FIND_WIDGET == 1)
#ifndef FIND_WIDGET_H
#define FIND_WIDGET_H

/* See comments just before Find_widget::construct() */

class Find_widget: public QWidget
{
  Q_OBJECT

private:
  MainWindow *main_window;
  QHBoxLayout *layout;
  QToolButton *close_button;
  QLabel *find_label;
  QComboBox *combo_box;
  QToolButton *down_button;
  QToolButton *up_button;
  QToolButton *case_button;
  void construct();
  void action_find_widget_move(bool,bool);
  void enable_or_disable();

protected:
  void keyPressEvent(QKeyEvent *event);
private slots:
  void action_combo_box_text_changed(QString);
  void action_down_button_clicked();
  void action_up_button_clicked();
  void action_close_button_clicked();
  void action_case_button_clicked();
public:
  void find_widget_activate();

Find_widget(MainWindow *m)
{
  main_window= m;
  construct();
}

~Find_widget()
{
  ;
}

};

#endif
#endif

/***********************************************************/
/* The Low-Level DBMS calls */
/***********************************************************/

/*
  The functions that start with "ldbms_" are supposed to be low level.
  Eventually there might be "#if mysql ... #endif" code inside them.
  Eventually there might be a separate class with all dbms-related calls.
  But we're still a long way from having dbms-independent code here.
  We have these new lists, which are created when we make the grid and deleted when we stop:
    grid_column_dbms_sources[].       = obsolete
    grid_column_dbms_field_numbers[]. = obsolete
  The idea is that any column can be special, that is, can have a source other than
  the DBMS field. So far the only special column is the row number, experimentally.
*/

/* Dynamic load
* Why dynamic-loading at runtime:
  To get rid of the warning "no version information available"
  So that we don't necessarily depend on libmysqlclient -- someday we'll allow other connections.
  The mysql documentation specifically says to use LD_RUN_PATH for mysqlclient; Qt ignores that.
  On the other hand, this is a pretty convoluted wrapper -- probably there's a more standard way
  to do it.
  (I could have checked out Qt's DBMS wrappers, but preferred to learn something at the lower level.)
  Re: mysql_library_end + mysql_library_init versus mysql_server_end + mysql_server_init:
      supposedly mysql_server_* functions are deprecated since MySQL version 5.0.3, but
      I still ran into a recent MariaDB libmysqlclient that used them, therefore if
      initially we can't find mysql_library_* functions we look for mysql_server_* functions.
  Todo: check library version (not sure how I do that, though). Maybe mysql_client_version()?
  Todo: consider allowing library name as parameter e.g. --library=perconaserverclient.so'
  Todo: if error, error message should say what you looked for. if okay, say what you found.
  Todo: consider adding in ocelotgui.pro: /opt/mysql/lib /opt/mysql/lib/mysql /usr/sfw/lib
  Todo: consider executing mysql_config --libs and using what it returns
  Todo: MySQL 5.7 has libmysqlclient.so.20, maybe look for that before libmysqlclient.so.18

  Initiate with: ldbms *lmysql;
                 lmysql= new ldbms();
                 if (lmysql == NULL) ... (Failure is possible if library cannot be loaded.)
  Call with:     lmysql->ldbms_function();
*/

#ifndef LDBMS_H
#define LDBMS_H

enum ocelot_option
{
  OCELOT_OPTION_0=0, /* for ocelot_opt_connect_timeout */
  OCELOT_OPTION_1=1,  /* for ocelot_opt_compress */
  OCELOT_OPTION_2=2,  /* for ocelot_opt_named_pipe */
  OCELOT_OPTION_3=3,  /* for ocelot_init_command */
  OCELOT_OPTION_4=4,  /* for ocelot_read_default_file_as_utf8 */
  OCELOT_OPTION_5=5,  /* for ocelot_read_default_group_as_utf8 */
  OCELOT_OPTION_6=6,  /* for ocelot_set_charset_dir_as_utf8 */
  OCELOT_OPTION_7=7,  /* for ocelot_set_charset_name_as_utf8 */
  OCELOT_OPTION_8=8,  /* for ocelot_opt_local_infile */
  OCELOT_OPTION_9=9,  /* for ocelot_protocol_as_int */
  OCELOT_OPTION_10=10,  /* for ocelot_shared_memory_base_name_as_utf8 */
  OCELOT_OPTION_11=11,  /* for ocelot_opt_read_timeout */
  OCELOT_OPTION_12=12,  /* for ocelot_opt_write_timeout */
  OCELOT_OPTION_13=13,  /* unused. in MySQL, opt_use_result */
  OCELOT_OPTION_14=14,  /* unused. in MySQL, use_remote_connection */
  OCELOT_OPTION_15=15,  /* unused. in MySQL, use_embedded_connection */
  OCELOT_OPTION_16=16,  /* unused. in MySQL, opt_guess_connection */
  OCELOT_OPTION_17=17,  /* unused. in MySQL, set_client_ip */
  OCELOT_OPTION_18=18,  /* for ocelot_secure_auth */
  OCELOT_OPTION_19=19,  /* for ocelot_report_data_truncation */
  OCELOT_OPTION_20=20,  /* for ocelot_opt_reconnect */
  OCELOT_OPTION_21=21,  /* ocelot_opt_ssl_verify_server_cert */
  OCELOT_OPTION_22=22,  /* ocelot_plugin_dir_as_utf8 */
  OCELOT_OPTION_23=23,  /* for ocelot_default_auth_as_utf8 */
  OCELOT_OPTION_24=24,  /* for ocelot_opt_bind_as_utf8 */
  OCELOT_OPTION_25=25,  /* unused. in MySQL, ssl_key */
  OCELOT_OPTION_26=26,  /* unused. in MySQL, opt_ssl_cert */
  OCELOT_OPTION_27=27,  /* unused. in MySQL, opt_ssl_ca */
  OCELOT_OPTION_28=28,  /* unused. in MySQL, opt_ssl_capath */
  OCELOT_OPTION_29=29,  /* unused. in MySQL, opt_ssl_cipher */
  OCELOT_OPTION_30=30,  /* for ocelot_opt_ssl_crl_as_utf8 */
  OCELOT_OPTION_31=31,  /* for ocelot_opt_ssl_crlpath_as_utf8 */
  OCELOT_OPTION_32=32,  /* for ocelot_opt_connect_attr_reset */
  OCELOT_OPTION_33=33,  /* unused. in MySQL, connect_attr_add */
  OCELOT_OPTION_34=34,  /* for ocelot_opt_connect_attr_delete_as_utf8 */
  OCELOT_OPTION_35=35,  /* for ocelot_server_public_key_as_utf8 */
  OCELOT_OPTION_36=36,  /* for ocelot_enable_cleartext_plugin */
  OCELOT_OPTION_37=37,  /* for ocelot_opt_can_handle_expired_passwords */
  OCELOT_OPTION_38=38,  /* for ocelot_opt_ssl_enforce */
  OCELOT_OPTION_39=39,  /* unused. in MySQL, opt_max_allowed_packet */
  OCELOT_OPTION_40=40,  /* unused. in MySQL, opt_net_buffer_length */
  OCELOT_OPTION_41=41,  /* unused. in MySQL, opt_tls_version */
  OCELOT_OPTION_42=42,  /* in MySQL 5.7.11+, opt_ssl_mode */
  OCELOT_OPTION_5999=5999,  /*unused. In MariaDB, progress_callback */
  OCELOT_OPTION_6000=6000,  /* unused. In MariaDB, nonblock */
  OCELOT_OPTION_6001=6001  /* unused. in MariaDB, thread_specific_memory */
};

#ifndef HEADER_AES_H
#define AES_BLOCK_SIZE 16
typedef struct aes_key_st { unsigned char x[244]; } AES_KEY;
#endif

class ldbms : public QWidget
{
public:


  void *dlopen_handle;

#if (OCELOT_MYSQL_INCLUDE == 1)
  /* For Qt typedef example see http://doc.qt.io/qt-4.8/qlibrary.html#fileName-prop */

  typedef my_ulonglong    (*tmysql_affected_rows)(MYSQL *);
  typedef void            (*tmysql_close)        (MYSQL *);
  typedef void            (*tmysql_data_seek)    (MYSQL_RES *, my_ulonglong);
  typedef unsigned int    (*tmysql_errno)        (MYSQL *);
  typedef const char*     (*tmysql_error)        (MYSQL *);
  typedef MYSQL_FIELD*    (*tmysql_fetch_fields) (MYSQL_RES *);
  typedef unsigned long*  (*tmysql_fetch_lengths)(MYSQL_RES *);
  typedef MYSQL_ROW       (*tmysql_fetch_row)    (MYSQL_RES *);
  typedef void            (*tmysql_free_result)  (MYSQL_RES *);
  typedef const char*     (*tmysql_get_client_info) (void);
  typedef const char*     (*tmysql_get_host_info)(MYSQL *);
  typedef const char*     (*tmysql_info)         (MYSQL *);
  typedef MYSQL*          (*tmysql_init)         (MYSQL *);
  typedef void            (*tmysql_library_end)  (void);
  typedef int             (*tmysql_library_init) (int, char **, char **);
  typedef MY_BOOL         (*tmysql_more_results) (MYSQL *);
  typedef int             (*tmysql_next_result)  (MYSQL *);
  typedef unsigned int    (*tmysql_num_fields)   (MYSQL_RES *);
  typedef my_ulonglong    (*tmysql_num_rows)     (MYSQL_RES *);
  typedef int             (*tmysql_options)      (MYSQL *, enum ocelot_option, const char *);
  typedef int             (*tmysql_ping)         (MYSQL *);
  typedef int             (*tmysql_query)        (MYSQL *, const char *);
  typedef MYSQL*          (*tmysql_real_connect) (MYSQL *, const char *,
                                                  const char *,
                                                  const char *,
                                                  const char *,
                                                  unsigned int,
                                                  const char *,
                                                  unsigned long);
  typedef int             (*tmysql_real_query)   (MYSQL *, const char *, unsigned long);
  typedef int             (*tmysql_select_db)    (MYSQL *, const char *);
  typedef char*           (*tmysql_sqlstate)     (MYSQL *);
  typedef bool            (*tmysql_ssl_set)      (MYSQL *, const char *,
                                                  const char *,
                                                  const char *,
                                                  const char *,
                                                  const char *);
  typedef MYSQL_RES*      (*tmysql_store_result) (MYSQL *);
  typedef void            (*tmysql_thread_end)   (void);
  typedef unsigned int    (*tmysql_warning_count)(MYSQL *);
  typedef int             (*tAES_set_decrypt_key)(unsigned char *, int, AES_KEY *);
  typedef void            (*tAES_decrypt)        (unsigned char *, unsigned char *, AES_KEY *);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
  typedef uint32_t        (*tmp_decode_array)    (const char **data);
  typedef const char*     (*tmp_decode_bin)      (const char **data, uint32_t *len);
  //typedef uint32_t        (*tmp_decode_binl)     (const char **data);
  typedef bool            (*tmp_decode_bool)     (const char **data);
  typedef float           (*tmp_decode_float)    (const char **data);
  typedef double          (*tmp_decode_double)   (const char **data);
  typedef int64_t         (*tmp_decode_int)      (const char **data);
  typedef uint32_t        (*tmp_decode_map)      (const char **data);
  typedef void            (*tmp_decode_nil)      (const char **data);
  typedef uint64_t        (*tmp_decode_uint)     (const char **data);
  typedef const char*     (*tmp_decode_str)      (const char **data, uint32_t *len);
  typedef uint32_t        (*tmp_decode_strl)     (const char **data);
  typedef void            (*tmp_next)            (const char **data);
  typedef enum mp_type    (*tmp_typeof)          (const char c);
  typedef ssize_t         (*ttnt_auth)           (struct tnt_stream *, const char *, int, const char *, int);
  typedef ssize_t         (*ttnt_call)           (struct tnt_stream *, const char *, size_t, struct tnt_stream *);
  typedef void            (*ttnt_close)          (struct tnt_stream *);
  typedef int             (*ttnt_connect)        (struct tnt_stream *);
  typedef ssize_t         (*ttnt_eval)           (struct tnt_stream *, const char *, size_t, struct tnt_stream *);
  typedef ssize_t         (*ttnt_delete)         (struct tnt_stream *, uint32_t, uint32_t, tnt_stream *);
  typedef ssize_t         (*ttnt_execute)        (struct tnt_stream *, const char *, size_t, struct tnt_stream *);
  typedef ssize_t         (*ttnt_flush)          (struct tnt_stream *);
  typedef int             (*ttnt_get_indexno)    (struct tnt_stream *, int, const char *, size_t);
  typedef int             (*ttnt_get_spaceno)    (struct tnt_stream *, const char *, size_t);
  typedef void            (*ttnt_stream_free)    (struct tnt_stream *);
  typedef ssize_t         (*ttnt_insert)         (struct tnt_stream *, uint32_t, struct tnt_stream *);
  typedef tnt_stream*     (*ttnt_net)            (struct tnt_stream *);
  typedef tnt_stream*     (*ttnt_object)         (struct tnt_stream *);
  typedef ssize_t         (*ttnt_object_add_array)(struct tnt_stream *, uint32_t);
  typedef ssize_t         (*ttnt_object_add_nil) (struct tnt_stream *);
  typedef ssize_t         (*ttnt_object_add_int) (struct tnt_stream *, int64_t);
  typedef ssize_t         (*ttnt_object_add_str) (struct tnt_stream *, const char *, uint32_t);
  typedef ssize_t         (*ttnt_object_add_bin) (struct tnt_stream *, const void *, uint32_t);
  typedef ssize_t         (*ttnt_object_add_bool)(struct tnt_stream *, char);
  typedef ssize_t         (*ttnt_object_add_float)(struct tnt_stream *s, float);
  typedef ssize_t         (*ttnt_object_add_double)(struct tnt_stream *, double);
  typedef ssize_t         (*ttnt_object_container_close)(struct tnt_stream *);
  typedef ssize_t         (*ttnt_object_format)  (struct tnt_stream *, const char *, int);
  typedef int             (*ttnt_object_reset)   (struct tnt_stream *);
  typedef int             (*ttnt_reload_schema)  (struct tnt_stream *);
  typedef ssize_t         (*ttnt_replace)        (struct tnt_stream *, uint32_t, struct tnt_stream *);
  typedef int             (*ttnt_reply)          (struct tnt_reply *, char *, size_t, size_t *);
  typedef tnt_reply*      (*ttnt_reply_init)     (struct tnt_reply *);
  typedef void            (*ttnt_reply_free)     (struct tnt_reply *);
  typedef int64_t         (*ttnt_request_compile)(struct tnt_stream *, struct tnt_request *);
  typedef tnt_request*    (*ttnt_request_eval)   (struct tnt_request *);
  typedef tnt_request*    (*ttnt_request_call)   (struct tnt_request *);
  typedef int             (*ttnt_request_set_exprz) (struct tnt_request *, const char *);
  typedef int             (*ttnt_request_set_tuple) (struct tnt_request *, struct tnt_stream *);
  typedef ssize_t         (*ttnt_select)         (struct tnt_stream *, uint32_t, uint32_t, uint32_t, uint32_t, uint8_t, struct tnt_stream *);
  typedef int             (*ttnt_set)            (struct tnt_stream *, int, char *);
  typedef ssize_t         (*ttnt_update)         (struct tnt_stream *, uint32_t, uint32_t, struct tnt_stream *, struct tnt_stream *);
  typedef enum tnt_error  (*ttnt_error)          (struct tnt_stream *);
  typedef char*           (*ttnt_strerror)       (struct tnt_stream *);
#endif

#if (OCELOT_MYSQL_INCLUDE == 1)
  tmysql_affected_rows t__mysql_affected_rows;   /* libmysqlclient */
  tmysql_close t__mysql_close;
  tmysql_data_seek t__mysql_data_seek;
  tmysql_errno t__mysql_errno;
  tmysql_error t__mysql_error;
  tmysql_fetch_fields t__mysql_fetch_fields;
  tmysql_fetch_lengths t__mysql_fetch_lengths;
  tmysql_fetch_row t__mysql_fetch_row;
  tmysql_free_result t__mysql_free_result;
  tmysql_get_client_info t__mysql_get_client_info;
  tmysql_get_host_info t__mysql_get_host_info;
  tmysql_info t__mysql_info;
  tmysql_init t__mysql_init;
  tmysql_library_end t__mysql_library_end;
  tmysql_library_init t__mysql_library_init;
  tmysql_more_results t__mysql_more_results;
  tmysql_next_result t__mysql_next_result;
  tmysql_num_fields t__mysql_num_fields;
  tmysql_num_rows t__mysql_num_rows;
  tmysql_options t__mysql_options;
  tmysql_ping t__mysql_ping;
  tmysql_query t__mysql_query;
  tmysql_real_connect t__mysql_real_connect;
  tmysql_real_query t__mysql_real_query;
  tmysql_select_db t__mysql_select_db;
  tmysql_sqlstate t__mysql_sqlstate;
  tmysql_ssl_set t__mysql_ssl_set;
  tmysql_store_result t__mysql_store_result;
  tmysql_thread_end t__mysql_thread_end;
  tmysql_warning_count t__mysql_warning_count;
  tAES_set_decrypt_key t__AES_set_decrypt_key;
  tAES_decrypt t__AES_decrypt;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
  tmp_decode_array t__mp_decode_array;
  tmp_decode_bin t__mp_decode_bin;
  //tmp_decode_binl t__mp_decode_binl;
  tmp_decode_bool t__mp_decode_bool;
  tmp_decode_float t__mp_decode_float;
  tmp_decode_double t__mp_decode_double;
  tmp_decode_int t__mp_decode_int;
  tmp_decode_map t__mp_decode_map;
  tmp_decode_nil t__mp_decode_nil;
  tmp_decode_uint t__mp_decode_uint;
  tmp_decode_str t__mp_decode_str;
  tmp_decode_strl t__mp_decode_strl;
  tmp_next t__mp_next;
  tmp_typeof t__mp_typeof;
  ttnt_auth t__tnt_auth;
  ttnt_call t__tnt_call;
  ttnt_close t__tnt_close;
  ttnt_connect t__tnt_connect;
  ttnt_delete t__tnt_delete;
  ttnt_eval t__tnt_eval;
  ttnt_flush t__tnt_flush;
  ttnt_execute t__tnt_execute;
  ttnt_get_indexno t__tnt_get_indexno;
  ttnt_get_spaceno t__tnt_get_spaceno;
  ttnt_stream_free t__tnt_stream_free;
  ttnt_insert t__tnt_insert;
  ttnt_net t__tnt_net;
  ttnt_object t__tnt_object;
  ttnt_object_add_array t__tnt_object_add_array;
  ttnt_object_add_nil t__tnt_object_add_nil;
  ttnt_object_add_int t__tnt_object_add_int;
  ttnt_object_add_str t__tnt_object_add_str;
  ttnt_object_add_bin t__tnt_object_add_bin;
  ttnt_object_add_bool t__tnt_object_add_bool;
  ttnt_object_add_float t__tnt_object_add_float;
  ttnt_object_add_double t__tnt_object_add_double;
  ttnt_object_container_close t__tnt_object_container_close;
  ttnt_object_format t__tnt_object_format;
  ttnt_object_reset t__tnt_object_reset;
  ttnt_reload_schema t__tnt_reload_schema;
  ttnt_replace t__tnt_replace;
  ttnt_reply t__tnt_reply;
  ttnt_reply_init t__tnt_reply_init;
  ttnt_reply_free t__tnt_reply_free;
  ttnt_request_compile t__tnt_request_compile;
  ttnt_request_eval t__tnt_request_eval;
  ttnt_request_call t__tnt_request_call;
  ttnt_request_set_exprz t__tnt_request_set_exprz;
  ttnt_request_set_tuple t__tnt_request_set_tuple;
  ttnt_select t__tnt_select;
  ttnt_set t__tnt_set;
  ttnt_update t__tnt_update;
  ttnt_error t__tnt_error;
  ttnt_strerror t__tnt_strerror;
#endif

ldbms() : QWidget()
{
  return;
}

#define WHICH_LIBRARY_LIBMYSQLCLIENT 0
#define WHICH_LIBRARY_LIBCRYPTO 1
#define WHICH_LIBRARY_LIBMYSQLCLIENT18 2
#ifdef DBMS_TARANTOOL
#define WHICH_LIBRARY_LIBTARANTOOL 3
//#define WHICH_LIBRARY_LIBTARANTOOLNET 4
#endif
#define WHICH_LIBRARY_LIBMARIADBCLIENT 5
#define WHICH_LIBRARY_LIBMARIADB 6

/* Todo: suppressed unused parameter warning if OCELOT_STATIC_LIBRARY==1 */
void ldbms_get_library(QString ocelot_ld_run_path,
        int *is_library_loaded,           /* points to is_libXXX_loaded */
        void **library_handle,            /* points to libXXX_handle */
        QString *return_string,
        int which_library)                /* 0 = libmysqlclient. 1 = libcrypto, etc. */
{
#if (OCELOT_MYSQL_INCLUDE == 1)
#if (OCELOT_STATIC_LIBRARY==1)
    if ((which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) || (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) || (which_library == WHICH_LIBRARY_LIBMARIADBCLIENT) || (which_library == WHICH_LIBRARY_LIBMARIADB))
    {
      /* If we static-linked to .lib or .a we don't need to load. */
      /* OCELOT_STATIC_LIBRARY should be on for Windows but not (for now) Linux. */
      /* TODO: This should be controlled by ocelot_static_library = 1 */
      t__mysql_affected_rows= (tmysql_affected_rows) &mysql_affected_rows;
      t__mysql_close= (tmysql_close)  &mysql_close;
      t__mysql_data_seek= (tmysql_data_seek) &mysql_data_seek;
      t__mysql_errno= (tmysql_errno) &mysql_errno;
      t__mysql_error= (tmysql_error) &mysql_error;
      t__mysql_fetch_fields= (tmysql_fetch_fields) &mysql_fetch_fields;
      t__mysql_fetch_lengths= (tmysql_fetch_lengths) &mysql_fetch_lengths;
      t__mysql_fetch_row= (tmysql_fetch_row) &mysql_fetch_row;
      t__mysql_free_result= (tmysql_free_result) &mysql_free_result;
      t__mysql_get_client_info= (tmysql_get_client_info) &mysql_get_client_info;
      t__mysql_get_host_info= (tmysql_get_host_info) &mysql_get_host_info;
      t__mysql_info= (tmysql_info) &mysql_info;
      t__mysql_init= (tmysql_init) &mysql_init;
      t__mysql_library_end= (tmysql_library_end) &mysql_library_end;
      t__mysql_library_init= (tmysql_library_init) &mysql_library_init;
      t__mysql_more_results= (tmysql_more_results) &mysql_more_results;
      t__mysql_next_result= (tmysql_next_result) &mysql_next_result;
      t__mysql_num_fields= (tmysql_num_fields) &mysql_num_fields;
      t__mysql_num_rows= (tmysql_num_rows) &mysql_num_rows;
      t__mysql_options= (tmysql_options) &mysql_options;
      t__mysql_ping= (tmysql_ping) &mysql_ping;
      t__mysql_query= (tmysql_query) &mysql_query;
      t__mysql_real_connect= (tmysql_real_connect) &mysql_real_connect;
      t__mysql_real_query= (tmysql_real_query) &mysql_real_query;
      t__mysql_select_db= (tmysql_select_db) &mysql_select_db;
      t__mysql_sqlstate= (tmysql_sqlstate) &mysql_sqlstate;
      t__mysql_ssl_set= (tmysql_ssl_set) &mysql_ssl_set;
      t__mysql_store_result= (tmysql_store_result) &mysql_store_result;
      t__mysql_thread_end= (tmysql_thread_end) &mysql_thread_end;
      t__mysql_warning_count= (tmysql_warning_count) &mysql_warning_count;
      *is_library_loaded= 1;
      return;
    }
#endif
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

#if (OCELOT_THIRD_PARTY==1)
    /* If Tarantool we can use third_party.h we don't need to load. */
    /* OCELOT_THIRD_PARTY=1 should be on for Windows but maybe not for Linux. */
    /* TODO: This should be controlled by ocelot_third_party = 1 */
    if (which_library == WHICH_LIBRARY_LIBTARANTOOL)
    {
      t__mp_decode_array= (tmp_decode_array) &mp_decode_array;
      t__mp_decode_bin= (tmp_decode_bin) &mp_decode_bin;
      //t__mp_decode_binl= (tmp_decode_binl) ;
      t__mp_decode_bool= (tmp_decode_bool) &mp_decode_bool;
      t__mp_decode_float= (tmp_decode_float) &mp_decode_float;
      t__mp_decode_double= (tmp_decode_double) &mp_decode_double;
      t__mp_decode_int= (tmp_decode_int) &mp_decode_int;
      t__mp_decode_map= (tmp_decode_map) &mp_decode_map;
      t__mp_decode_nil= (tmp_decode_nil) &mp_decode_nil;
      t__mp_decode_uint= (tmp_decode_uint) &mp_decode_uint;
      t__mp_decode_str= (tmp_decode_str) &mp_decode_str;
      t__mp_decode_strl= (tmp_decode_strl) &mp_decode_strl;
      t__mp_next= (tmp_next) &mp_next;
      t__mp_typeof= (tmp_typeof) &mp_typeof;
      t__tnt_auth= (ttnt_auth) &tnt_auth;
      t__tnt_call= (ttnt_call) &tnt_call;
      t__tnt_close= (ttnt_close) &tnt_close;
      t__tnt_connect= (ttnt_connect) &tnt_connect;
      t__tnt_delete= (ttnt_delete) &tnt_delete;
      t__tnt_eval= (ttnt_eval) &tnt_eval;
      t__tnt_flush= (ttnt_flush) &tnt_flush;
      t__tnt_execute= (ttnt_execute) &tnt_execute;
      t__tnt_get_indexno= (ttnt_get_indexno) &tnt_get_indexno;
      t__tnt_get_spaceno= (ttnt_get_spaceno) &tnt_get_spaceno;
      t__tnt_stream_free= (ttnt_stream_free) &tnt_stream_free;
      t__tnt_insert= (ttnt_insert) &tnt_insert;
      t__tnt_net= (ttnt_net) &tnt_net;
      t__tnt_object= (ttnt_object) &tnt_object;
      t__tnt_object_add_array= (ttnt_object_add_array) &tnt_object_add_array;
      t__tnt_object_add_nil= (ttnt_object_add_nil) &tnt_object_add_nil;
      t__tnt_object_add_int= (ttnt_object_add_int) &tnt_object_add_int;
      t__tnt_object_add_str= (ttnt_object_add_str) &tnt_object_add_str;
      t__tnt_object_add_bin= (ttnt_object_add_bin) &tnt_object_add_bin;
      t__tnt_object_add_bool= (ttnt_object_add_bool) &tnt_object_add_bool;
      t__tnt_object_add_float= (ttnt_object_add_float) &tnt_object_add_float;
      t__tnt_object_add_double= (ttnt_object_add_double) &tnt_object_add_double;
      t__tnt_object_container_close= (ttnt_object_container_close) &tnt_object_container_close;
      t__tnt_object_format= (ttnt_object_format) &tnt_object_format;
      t__tnt_object_reset= (ttnt_object_reset) &tnt_object_reset;
      t__tnt_reload_schema= (ttnt_reload_schema) &tnt_reload_schema;
      t__tnt_replace= (ttnt_replace) &tnt_replace;
      t__tnt_reply= (ttnt_reply) &xtnt_reply;
      t__tnt_reply_free= (ttnt_reply_free) &tnt_reply_free;
      t__tnt_request_compile= (ttnt_request_compile) &tnt_request_compile;
      t__tnt_request_eval= (ttnt_request_eval) &tnt_request_eval;
      t__tnt_request_call= (ttnt_request_call) &tnt_request_call;
      t__tnt_request_set_exprz= (ttnt_request_set_exprz) &tnt_request_set_exprz;
      t__tnt_request_set_tuple= (ttnt_request_set_tuple) &tnt_request_set_tuple;
      t__tnt_reply_init= (ttnt_reply_init) &tnt_reply_init;
      t__tnt_select= (ttnt_select) &tnt_select;
      t__tnt_set= (ttnt_set) &tnt_set;
      t__tnt_update= (ttnt_update) &tnt_update;
      t__tnt_error= (ttnt_error) &xtnt_error;
      t__tnt_strerror= (ttnt_strerror) &tnt_strerror;
      *is_library_loaded= 1;
      return;
    }
#endif /* OCELOT_THIRD_PARTY==1 */

#ifdef OCELOT_OS_LINUX
    char *query;
    int query_len;
#endif
    QString error_string;

    /*
      What's with all the #ifdef OCELOT_OS_LINUX stuff?
      Originally I coded for QLibrary. For reasons I couldn't figure out,
      t__mysql_real_connect crashed. So I switched to dlopen().
      I suspect the ability to say RTLD_DEEPBIND | RTLD_NOW had something to do with it.
      WIthout RTLD_DEEPBIND it crashed though that might be an obsolete observation.
      But perhaps someday we'll want to revive QLibrary for other platforms.

      There is a description re finding libmysqlclient if one types Help | libmysqlclient.
    */

#ifdef OCELOT_OS_NONLINUX
  QLibrary lib;
#endif

    if (*is_library_loaded == 1)
    {
      /*
        Since this is called when we're re-connecting,
        I'd like to dclose() and dlopen() again in case library name has changed.
        But apparently dclose() is not reliable. So don't change library name, eh?
      */
      return;
    }
    if (*is_library_loaded == -2)
    {
      /* The last error was that we got the wrong library. Unrecoverable. */
      return;
    }
#ifdef OCELOT_OS_NONLINUX
#if (OCELOT_MYSQL_INCLUDE == 1)
    /* I don't know how Windows handles shared-library version numbers */
    if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) lib.setFileNameAndVersion("libmysql", 18);
    if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) lib.setFileName("libmysql");
    if (which_library == WHICH_LIBRARY_LIBCRYPTO) lib.setFileName("libeay32");
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
    if (which_library == WHICH_LIBRARY_LIBTARANTOOL) lib.setFileName("libtarantool");
    //if (which_library == WHICH_LIBRARY_LIBTARANTOOLNET) lib.setFileName("libtarantoolnet");
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
    if (which_library == WHICH_LIBRARY_LIBMARIADBCLIENT) lib.setFileName("libmariadbclient");
    if (which_library == WHICH_LIBRARY_LIBMARIADB) lib.setFileName("libmariadb");
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#endif
    /*
      Finding libmysqlclient
      I tried "qApp->addLibraryPath(ld_run_path);" but it failed.
      So first I'll try hard-coding lib() with strings from ld_run_path.
    */
    if (ocelot_ld_run_path != "")
    {
      QString ld_run_path_part;
      char *ld_run_path;
      int ld_run_path_len;
      int i= 0;
      int prev_i= 0;

      ld_run_path_len= ocelot_ld_run_path.toUtf8().size();         /* See comment "UTF8 Conversion" */
      ld_run_path= new char[ld_run_path_len + 1];
      memcpy(ld_run_path, ocelot_ld_run_path.toUtf8().constData(), ld_run_path_len + 1);
      ld_run_path[ld_run_path_len]= '\0';

      for (;;)
      {
        for (i= prev_i;; ++i)
        {
          if ((*(ld_run_path + i) == ';') || (*(ld_run_path + i) == '\0')) break;
        }
        ld_run_path_part= ld_run_path + prev_i;
        ld_run_path_part= ld_run_path_part.left(i - prev_i);
        ld_run_path_part= ld_run_path_part.trimmed();
        if (ld_run_path_part > "")
        {
#ifdef OCELOT_OS_LINUX
#if (OCELOT_MYSQL_INCLUDE == 1)
          if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) ld_run_path_part.append("/libmysqlclient.so.18");
          if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) ld_run_path_part.append("/libmysqlclient.so");
          if (which_library == WHICH_LIBRARY_LIBCRYPTO) ld_run_path_part.append("/libcrypto.so");
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
          if (which_library == WHICH_LIBRARY_LIBTARANTOOL) ld_run_path_part.append("/libtarantool.so");
          //if (which_library == WHICH_LIBRARY_LIBTARANTOOLNET) ld_run_path_part.append("/libtarantoolnet.so");
#endif
          query_len= ld_run_path_part.toUtf8().size();         /* See comment "UTF8 Conversion" */
          query= new char[query_len + 1];
          memcpy(query, ld_run_path_part.toUtf8().constData(), query_len + 1);
          query[query_len]= '\0';
          dlopen_handle= dlopen(query,  RTLD_DEEPBIND | RTLD_NOW);
          delete []query;
          if (dlopen_handle == 0) {*is_library_loaded= 0; error_string= dlerror(); }
          else *is_library_loaded= 1;
          *library_handle= dlopen_handle;
#endif //#ifdef OCELOT_OS_LINUX
#ifdef OCELOT_OS_NONLINUX
#if (OCELOT_MYSQL_INCLUDE == 1)
          if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) ld_run_path_part.append("/libmysqlclient");
          if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) ld_run_path_part.append("/libmysqlclient");
          if (which_library == WHICH_LIBRARY_LIBCRYPTO) ld_run_path_part.append("/libcrypto");
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
          if (which_library == WHICH_LIBRARY_LIBTARANTOOL) ld_run_path_part.append("/libtarantool");
          //if (which_library == WHICH_LIBRARY_LIBTARANTOOLNET) ld_run_path_part.append("/libtarantoolnet");
#endif
          lib.setFileName(ld_run_path_part);
          *is_library_loaded= lib.load();
          error_string= lib.errorString();
#endif //#ifdef OCELOT_OS_NONLINUX
          if (*is_library_loaded == 1) break;
        }
        if (*(ld_run_path + i) == '\0') break;
        prev_i= i + 1;
      }
      delete []ld_run_path;
    }

    /*
      If ld_run_path was passed, and we found nothing, return now. We want to check for libmysqlclient.so.18
      along run path first (regardless whether it's for libmysqlclient.so.18 or libmysqlclient.so)
    */
    if ((ocelot_ld_run_path != "") && (*is_library_loaded == 0)) return;

    /* If it wasn't found via LD_RUN_PATH, use defaults e.g. LD_LIBRARY_PATH */
    if (*is_library_loaded == 0)
    {
#ifdef OCELOT_OS_LINUX
#if (OCELOT_MYSQL_INCLUDE == 1)
      if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) dlopen_handle= dlopen("libmysqlclient.so.18",  RTLD_DEEPBIND | RTLD_NOW);
      if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) dlopen_handle= dlopen("libmysqlclient.so",  RTLD_DEEPBIND | RTLD_NOW);
      if (which_library == WHICH_LIBRARY_LIBCRYPTO) dlopen_handle= dlopen("libcrypto.so",  RTLD_DEEPBIND | RTLD_NOW);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
      if (which_library == WHICH_LIBRARY_LIBTARANTOOL) dlopen_handle= dlopen("libtarantool.so",  RTLD_DEEPBIND | RTLD_NOW);
      //if (which_library == WHICH_LIBRARY_LIBTARANTOOLNET) dlopen_handle= dlopen("libtarantoolnet.so",  RTLD_DEEPBIND | RTLD_NOW);
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
      if (which_library == WHICH_LIBRARY_LIBMARIADBCLIENT) dlopen_handle= dlopen("libmariadbclient.so",  RTLD_DEEPBIND | RTLD_NOW);
      if (which_library == WHICH_LIBRARY_LIBMARIADB) dlopen_handle= dlopen("libmariadb.so",  RTLD_DEEPBIND | RTLD_NOW);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
      if (dlopen_handle == 0) {*is_library_loaded= 0; error_string= dlerror(); }
      else *is_library_loaded= 1;
      *library_handle= dlopen_handle;
#endif //#ifdef OCELOT_OS_LINUX
#ifdef OCELOT_OS_NONLINUX
#if (OCELOT_MYSQL_INCLUDE == 1)
      if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) lib.setFileName("libmysql");
      if (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) lib.setFileName("libmysql");
      if (which_library == WHICH_LIBRARY_LIBCRYPTO) lib.setFileName("libeay32");
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
      if (which_library == WHICH_LIBRARY_LIBTARANTOOL) lib.setFileName("libtarantool");
      //if (which_library == WHICH_LIBRARY_LIBTARANTOOLNET) lib.setFileName("libtarantoolnet");
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
      if (which_library == WHICH_LIBRARY_LIBMARIADBCLIENT) lib.setFileName("libmariadbclient");
      if (which_library == WHICH_LIBRARY_LIBMARIADB) lib.setFileName("libmariadb");
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
      *is_library_loaded= lib.load();
      error_string= lib.errorString();
#endif //#ifdef OCELOT_OS_NONLINUX
    }

    if (*is_library_loaded == 0)
    {
      *return_string= error_string;
      return;
    }
    if (*is_library_loaded == 1)
    {
      QString s= "";
#ifdef OCELOT_OS_LINUX
#if (OCELOT_MYSQL_INCLUDE == 1)
      if ((which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) || (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) || (which_library == WHICH_LIBRARY_LIBMARIADBCLIENT) || (which_library == WHICH_LIBRARY_LIBMARIADB))
      {
        t__mysql_affected_rows= (tmysql_affected_rows) dlsym(dlopen_handle, "mysql_affected_rows"); if (dlerror() != 0) s.append("mysql_affected_rows ");
        t__mysql_close= (tmysql_close) dlsym(dlopen_handle, "mysql_close"); if (dlerror() != 0) s.append("mysql_close ");
        t__mysql_data_seek= (tmysql_data_seek) dlsym(dlopen_handle, "mysql_data_seek"); if (dlerror() != 0) s.append("mysql_data_seek ");
        t__mysql_errno= (tmysql_errno) dlsym(dlopen_handle, "mysql_errno"); if (dlerror() != 0) s.append("mysql_errno ");
        t__mysql_error= (tmysql_error) dlsym(dlopen_handle, "mysql_error"); if (dlerror() != 0) s.append("mysql_errorinit ");
        t__mysql_fetch_fields= (tmysql_fetch_fields) dlsym(dlopen_handle, "mysql_fetch_fields"); if (dlerror() != 0) s.append("mysql_fetch_fields ");
        t__mysql_fetch_lengths= (tmysql_fetch_lengths) dlsym(dlopen_handle, "mysql_fetch_lengths"); if (dlerror() != 0) s.append("mysql_fetch_lengths ");
        t__mysql_fetch_row= (tmysql_fetch_row) dlsym(dlopen_handle, "mysql_fetch_row"); if (dlerror() != 0) s.append("mysql_fetch_rows ");
        t__mysql_free_result= (tmysql_free_result) dlsym(dlopen_handle, "mysql_free_result"); if (dlerror() != 0) s.append("mysql_free_result ");
        t__mysql_get_client_info= (tmysql_get_client_info) dlsym(dlopen_handle, "mysql_get_client_info"); if (dlerror() != 0) s.append("mysql_get_client_info ");
        t__mysql_get_host_info= (tmysql_get_host_info) dlsym(dlopen_handle, "mysql_get_host_info"); if (dlerror() != 0) s.append("mysql_get_host_info ");
        t__mysql_info= (tmysql_info) dlsym(dlopen_handle, "mysql_info"); if (dlerror() != 0) s.append("mysql_info ");
        t__mysql_init= (tmysql_init) dlsym(dlopen_handle, "mysql_init"); if (dlerror() != 0) s.append("mysql_init ");
        {
          t__mysql_library_end= (tmysql_library_end) dlsym(dlopen_handle, "mysql_library_end");
          if (dlerror() != 0)
          {
            t__mysql_library_end= (tmysql_library_end) dlsym(dlopen_handle, "mysql_server_end");
            if (dlerror() != 0) s.append("mysql_library_end ");
          }
        }
        {
          t__mysql_library_init= (tmysql_library_init) dlsym(dlopen_handle, "mysql_library_init");
          if (dlerror() != 0)
          {
            t__mysql_library_init= (tmysql_library_init) dlsym(dlopen_handle, "mysql_server_init");
            if (dlerror() != 0) s.append("mysql_library_init ");
          }
        }
        t__mysql_more_results= (tmysql_more_results) dlsym(dlopen_handle, "mysql_more_results"); if (dlerror() != 0) s.append("mysql_more_results ");
        t__mysql_next_result= (tmysql_next_result) dlsym(dlopen_handle, "mysql_next_result"); if (dlerror() != 0) s.append("mysql_next_result ");
        t__mysql_num_fields= (tmysql_num_fields) dlsym(dlopen_handle, "mysql_num_fields"); if (dlerror() != 0) s.append("mysql_num_fields ");
        t__mysql_num_rows= (tmysql_num_rows) dlsym(dlopen_handle, "mysql_num_rows"); if (dlerror() != 0) s.append("mysql_num_rows ");
        t__mysql_options= (tmysql_options) dlsym(dlopen_handle, "mysql_options"); if (dlerror() != 0) s.append("mysql_options ");
        t__mysql_ping= (tmysql_ping) dlsym(dlopen_handle, "mysql_ping"); if (dlerror() != 0) s.append("mysql_ping ");
        t__mysql_query= (tmysql_query) dlsym(dlopen_handle, "mysql_query"); if (dlerror() != 0) s.append("mysql_query ");
        t__mysql_real_connect= (tmysql_real_connect) dlsym(dlopen_handle, "mysql_real_connect"); if (dlerror() != 0) s.append("mysql_real_connect ");
        t__mysql_real_query= (tmysql_real_query) dlsym(dlopen_handle, "mysql_real_query"); if (dlerror() != 0) s.append("mysql_real_query ");
        t__mysql_select_db= (tmysql_select_db) dlsym(dlopen_handle, "mysql_select_db"); if (dlerror() != 0) s.append("mysql_select_db ");
        t__mysql_sqlstate= (tmysql_sqlstate) dlsym(dlopen_handle, "mysql_sqlstate"); if (dlerror() != 0) s.append("mysql_sqlstate ");
        t__mysql_ssl_set= (tmysql_ssl_set) dlsym(dlopen_handle, "mysql_ssl_set"); if (dlerror() != 0) t__mysql_ssl_set= NULL;
        t__mysql_store_result= (tmysql_store_result) dlsym(dlopen_handle, "mysql_store_result"); if (dlerror() != 0) s.append("mysql_store_result ");
        t__mysql_thread_end= (tmysql_thread_end) dlsym(dlopen_handle, "mysql_thread_end"); if (dlerror() != 0) s.append("mysql_thread_end ");
        t__mysql_warning_count= (tmysql_warning_count) dlsym(dlopen_handle, "mysql_warning_count"); if (dlerror() != 0) s.append("mysql_warning_count ");
      }
      if (which_library == WHICH_LIBRARY_LIBCRYPTO)
      {
        t__AES_set_decrypt_key= (tAES_set_decrypt_key) dlsym(dlopen_handle, "AES_set_decrypt_key"); if (dlerror() != 0) s.append("AES_set_decrypt_key ");
        t__AES_decrypt= (tAES_decrypt) dlsym(dlopen_handle, "AES_decrypt"); if (dlerror() != 0) s.append("AES_decrypt ");
      }
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
      if (which_library == WHICH_LIBRARY_LIBTARANTOOL)
      {
        t__mp_decode_array= (tmp_decode_array) dlsym(dlopen_handle, "mp_decode_array"); if (dlerror() != 0) s.append("mp_decode_array ");
        t__mp_decode_bin= (tmp_decode_bin) dlsym(dlopen_handle, "mp_decode_bin"); if (dlerror() != 0) s.append("mp_decode_bin ");
        //t__mp_decode_binl= (tmp_decode_binl) dlsym(dlopen_handle, "mp_decode_binl)"); if (dlerror() != 0) s.append("mp_decode_binl ");
        t__mp_decode_bool= (tmp_decode_bool) dlsym(dlopen_handle, "mp_decode_bool"); if (dlerror() != 0) s.append("mp_decode_bool ");
        t__mp_decode_float= (tmp_decode_float) dlsym(dlopen_handle, "mp_decode_float"); if (dlerror() != 0) s.append("mp_decode_float ");
        t__mp_decode_double= (tmp_decode_double) dlsym(dlopen_handle, "mp_decode_double"); if (dlerror() != 0) s.append("mp_decode_double ");
        t__mp_decode_int= (tmp_decode_int) dlsym(dlopen_handle, "mp_decode_int"); if (dlerror() != 0) s.append("mp_decode_int ");
        t__mp_decode_map= (tmp_decode_map) dlsym(dlopen_handle, "mp_decode_map"); if (dlerror() != 0) s.append("mp_decode_map ");
        t__mp_decode_nil= (tmp_decode_nil) dlsym(dlopen_handle, "mp_decode_nil"); if (dlerror() != 0) s.append("mp_decode_nil ");
        t__mp_decode_uint= (tmp_decode_uint) dlsym(dlopen_handle, "mp_decode_uint"); if (dlerror() != 0) s.append("mp_decode_uint ");
        t__mp_decode_str= (tmp_decode_str) dlsym(dlopen_handle, "mp_decode_str"); if (dlerror() != 0) s.append("mp_decode_str ");
        t__mp_decode_strl= (tmp_decode_strl) dlsym(dlopen_handle, "mp_decode_strl"); if (dlerror() != 0) s.append("mp_decode_strl ");
        t__mp_next= (tmp_next) dlsym(dlopen_handle, "mp_next"); if (dlerror() != 0) s.append("mp_next ");
        t__mp_typeof= (tmp_typeof) dlsym(dlopen_handle, "mp_typeof"); if (dlerror() != 0) s.append("mp_typeof ");
        t__tnt_auth= (ttnt_auth) dlsym(dlopen_handle, "tnt_auth"); if (dlerror() != 0) s.append("tnt_auth ");
        t__tnt_call= (ttnt_call) dlsym(dlopen_handle, "tnt_call"); if (dlerror() != 0) s.append("tnt_call ");
        t__tnt_close= (ttnt_close) dlsym(dlopen_handle, "tnt_close"); if (dlerror() != 0) s.append("tnt_close ");
        t__tnt_connect= (ttnt_connect) dlsym(dlopen_handle, "tnt_connect"); if (dlerror() != 0) s.append("tnt_connect ");
        t__tnt_delete= (ttnt_delete) dlsym(dlopen_handle, "tnt_delete"); if (dlerror() != 0) s.append("tnt_delete");
        t__tnt_eval= (ttnt_eval) dlsym(dlopen_handle, "tnt_eval"); if (dlerror() != 0) s.append("tnt_eval ");
        t__tnt_flush= (ttnt_flush) dlsym(dlopen_handle, "tnt_flush"); if (dlerror() != 0) s.append("tnt_flush ");
        t__tnt_execute= (ttnt_execute) dlsym(dlopen_handle, "tnt_execute"); if (dlerror() != 0) s.append("tnt_execute ");
        t__tnt_get_indexno= (ttnt_get_indexno) dlsym(dlopen_handle, "tnt_get_indexno"); if (dlerror() != 0) s.append("tnt_get_indexno ");
        t__tnt_get_spaceno= (ttnt_get_spaceno) dlsym(dlopen_handle, "tnt_get_spaceno"); if (dlerror() != 0) s.append("tnt_get_spaceno ");
        t__tnt_stream_free= (ttnt_stream_free) dlsym(dlopen_handle, "tnt_stream_free"); if (dlerror() != 0) s.append("tnt_stream_Free ");
        t__tnt_insert= (ttnt_insert) dlsym(dlopen_handle, "tnt_insert"); if (dlerror() != 0) s.append("tnt_insert ");
        t__tnt_net= (ttnt_net) dlsym(dlopen_handle, "tnt_net"); if (dlerror() != 0) s.append("tnt_net ");
        t__tnt_object= (ttnt_object) dlsym(dlopen_handle, "tnt_object"); if (dlerror() != 0) s.append("tnt_object ");
        t__tnt_object_add_array= (ttnt_object_add_array) dlsym(dlopen_handle, "tnt_object_add_array"); if (dlerror() != 0) s.append("tnt_object_add_array ");
        t__tnt_object_add_nil= (ttnt_object_add_nil) dlsym(dlopen_handle, "tnt_object_add_nil"); if (dlerror() != 0) s.append("tnt_object_add_nil ");
        t__tnt_object_add_int= (ttnt_object_add_int) dlsym(dlopen_handle, "tnt_object_add_int"); if (dlerror() != 0) s.append("tnt_object_add_int ");
        t__tnt_object_add_str= (ttnt_object_add_str) dlsym(dlopen_handle, "tnt_object_add_str"); if (dlerror() != 0) s.append("tnt_object_add_str ");
        t__tnt_object_add_bin= (ttnt_object_add_bin) dlsym(dlopen_handle, "tnt_object_add_bin"); if (dlerror() != 0) s.append("tnt_object_add_bin ");
        t__tnt_object_add_bool= (ttnt_object_add_bool) dlsym(dlopen_handle, "tnt_object_add_bool"); if (dlerror() != 0) s.append("tnt_object_add_bool ");
        t__tnt_object_add_float= (ttnt_object_add_float) dlsym(dlopen_handle, "tnt_object_add_float"); if (dlerror() != 0) s.append("tnt_object_add_float ");
        t__tnt_object_add_double= (ttnt_object_add_double) dlsym(dlopen_handle, "tnt_object_add_double"); if (dlerror() != 0) s.append("tnt_object_add_double ");
        t__tnt_object_container_close= (ttnt_object_container_close) dlsym(dlopen_handle, "tnt_object_container_close"); if (dlerror() != 0) s.append("tnt_object_container_close ");
        t__tnt_object_format= (ttnt_object_format) dlsym(dlopen_handle, "tnt_object_format"); if (dlerror() != 0) s.append("tnt_object_format ");
        t__tnt_object_reset= (ttnt_object_reset) dlsym(dlopen_handle, "tnt_object_reset"); if (dlerror() != 0) s.append("tnt_object_reset ");
        t__tnt_reload_schema= (ttnt_reload_schema) dlsym(dlopen_handle, "tnt_reload_schema"); if (dlerror() != 0) s.append("tnt_reload_schema ");
        t__tnt_replace= (ttnt_replace) dlsym(dlopen_handle, "tnt_replace"); if (dlerror() != 0) s.append("tnt_replace ");
        t__tnt_reply= (ttnt_reply) dlsym(dlopen_handle, "tnt_reply"); if (dlerror() != 0) s.append("tnt_reply ");
        t__tnt_reply_free= (ttnt_reply_free) dlsym(dlopen_handle, "tnt_reply_free"); if (dlerror() != 0) s.append("tnt_reply_free ");
        t__tnt_request_compile= (ttnt_request_compile) dlsym(dlopen_handle, "tnt_request_compile"); if (dlerror() != 0) s.append("tnt_request_compile ");
        t__tnt_request_eval= (ttnt_request_eval) dlsym(dlopen_handle, "tnt_request_eval"); if (dlerror() != 0) s.append("tnt_request_eval ");
        t__tnt_request_call= (ttnt_request_call) dlsym(dlopen_handle, "tnt_request_call"); if (dlerror() != 0) s.append("tnt_request_call ");
        t__tnt_request_set_exprz= (ttnt_request_set_exprz) dlsym(dlopen_handle, "tnt_request_set_exprz"); if (dlerror() != 0) s.append("tnt_request_set_exprz ");
        t__tnt_request_set_tuple= (ttnt_request_set_tuple) dlsym(dlopen_handle, "tnt_request_set_tuple"); if (dlerror() != 0) s.append("tnt_request_set_tuple ");
        t__tnt_reply_init= (ttnt_reply_init) dlsym(dlopen_handle, "tnt_reply_init"); if (dlerror() != 0) s.append("tnt_reply_init ");
        t__tnt_select= (ttnt_select) dlsym(dlopen_handle, "tnt_select"); if (dlerror() != 0) s.append("tnt_select ");
        t__tnt_set= (ttnt_set) dlsym(dlopen_handle, "tnt_set"); if (dlerror() != 0) s.append("tnt_set ");
        t__tnt_update= (ttnt_update) dlsym(dlopen_handle, "tnt_update"); if (dlerror() != 0) s.append("tnt_update ");
        t__tnt_error= (ttnt_error) dlsym(dlopen_handle, "tnt_error"); if (dlerror() != 0) s.append("tnt_error ");
        t__tnt_strerror= (ttnt_strerror) dlsym(dlopen_handle, "tnt_strerror"); if (dlerror() != 0) s.append("tnt_strerror ");
      }
#endif
#endif //#ifdef OCELOT_OS_LINUX
#ifdef OCELOT_OS_NONLINUX
#if (OCELOT_MYSQL_INCLUDE == 1)
      if ((which_library == WHICH_LIBRARY_LIBMYSQLCLIENT18) || (which_library == WHICH_LIBRARY_LIBMYSQLCLIENT) || (which_library == WHICH_LIBRARY_LIBMARIADBCLIENT) || (which_library == WHICH_LIBRARY_LIBMARIADB))
      {
        if ((t__mysql_affected_rows= (tmysql_affected_rows) lib.resolve("mysql_affected_rows")) == 0) s.append("mysql_affected_rows ");
        if ((t__mysql_close= (tmysql_close) lib.resolve("mysql_close")) == 0) s.append("mysql_close ");
        if ((t__mysql_data_seek= (tmysql_data_seek) lib.resolve("mysql_data_seek")) == 0) s.append("mysql_data_seek ");
        if ((t__mysql_errno= (tmysql_errno) lib.resolve("mysql_errno")) == 0) s.append("mysql_errno ");
        if ((t__mysql_error= (tmysql_error) lib.resolve("mysql_error")) == 0) s.append("mysql_error ");
        if ((t__mysql_fetch_fields= (tmysql_fetch_fields) lib.resolve("mysql_fetch_fields")) == 0) s.append("mysql_fetch_fields ");
        if ((t__mysql_fetch_lengths= (tmysql_fetch_lengths) lib.resolve("mysql_fetch_lengths")) == 0) s.append("mysql_fetch_lengths ");
        if ((t__mysql_fetch_row= (tmysql_fetch_row) lib.resolve("mysql_fetch_row")) == 0) s.append("mysql_fetch_row ");
        if ((t__mysql_free_result= (tmysql_free_result) lib.resolve("mysql_free_result")) == 0) s.append("mysql_free_result ");
        if ((t__mysql_get_client_info= (tmysql_get_client_info) lib.resolve("mysql_get_client_info")) == 0) s.append("mysql_get_client_info ");
        if ((t__mysql_get_host_info= (tmysql_get_host_info) lib.resolve("mysql_get_host_info")) == 0) s.append("mysql_get_host_info ");
        if ((t__mysql_info= (tmysql_info) lib.resolve("mysql_info")) == 0) s.append("mysql_info ");
        if ((t__mysql_init= (tmysql_init) lib.resolve("mysql_init")) == 0) s.append("mysql_init ");
        {
          t__mysql_library_end= (tmysql_library_end) lib.resolve("mysql_library_end");
          if (t__mysql_library_end == 0)
          {
            t__mysql_library_end= (tmysql_library_end) lib.resolve("mysql_server_end");
            if (t__mysql_library_end == 0) s.append("mysql_library_end ");
          }
        }
        {
          t__mysql_library_init= (tmysql_library_init) lib.resolve("mysql_library_init");
          if (t__mysql_library_init == 0)
          {
            t__mysql_library_init= (tmysql_library_init) lib.resolve("mysql_server_init");
            if (t__mysql_library_init == 0) s.append("mysql_library_init ");
          }
        }
        if ((t__mysql_more_results= (tmysql_more_results) lib.resolve("mysql_more_results")) == 0) s.append("mysql_more_results ");
        if ((t__mysql_next_result= (tmysql_next_result) lib.resolve("mysql_next_result")) == 0) s.append("mysql_next_result ");
        if ((t__mysql_num_fields= (tmysql_num_fields) lib.resolve("mysql_num_fields")) == 0) s.append("mysql_num_fields ");
        if ((t__mysql_num_rows= (tmysql_num_rows) lib.resolve("mysql_num_rows")) == 0) s.append("mysql_num_rows ");
        if ((t__mysql_options= (tmysql_options) lib.resolve("mysql_options")) == 0) s.append("mysql_options ");
        if ((t__mysql_ping= (tmysql_ping) lib.resolve("mysql_ping")) == 0) s.append("mysql_ping ");
        if ((t__mysql_query= (tmysql_query) lib.resolve("mysql_query")) == 0) s.append("mysql_query ");
        if ((t__mysql_real_connect= (tmysql_real_connect) lib.resolve("mysql_real_connect")) == 0) s.append("mysql_real_connect ");
        if ((t__mysql_real_query= (tmysql_real_query) lib.resolve("mysql_real_query")) == 0) s.append("mysql_real_query ");
        if ((t__mysql_select_db= (tmysql_select_db) lib.resolve("mysql_select_db")) == 0) s.append("mysql_select_db ");
        if ((t__mysql_sqlstate= (tmysql_sqlstate) lib.resolve("mysql_sqlstate")) == 0) s.append("mysql_sqlstate ");
        if ((t__mysql_ssl_set= (tmysql_ssl_set) lib.resolve("mysql_ssl_set")) == 0) t__mysql_ssl_set= NULL;
        if ((t__mysql_store_result= (tmysql_store_result) lib.resolve("mysql_store_result")) == 0) s.append("mysql_store_result ");
        if ((t__mysql_thread_end= (tmysql_thread_end) lib.resolve("mysql_thread_end")) == 0) s.append("mysql_thread_end ");
        if ((t__mysql_warning_count= (tmysql_warning_count) lib.resolve("mysql_warning_count")) == 0) s.append("mysql_warning_count ");
      }
      if (which_library == WHICH_LIBRARY_LIBCRYPTO)
      {
        if ((t__AES_set_decrypt_key= (tAES_set_decrypt_key) lib.resolve("AES_set_decrypt_key")) == 0) s.append("AES_set_decrypt_key ");
        if ((t__AES_decrypt= (tAES_decrypt) lib.resolve("AES_decrypt")) == 0) s.append("AES_decrypt ");
      }
#endif //if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
      if (which_library == WHICH_LIBRARY_LIBTARANTOOL)
      {
         /* With Windows don't look for the Tarantool library, its code is in third_party.h */
      }
#endif
#endif //#ifdef OCELOT_OS_NONLINUX
      if (s > "")
      {
        {
          /* Unrecoverable error -- one or more names not found. Return the names. */
          *return_string= s;
          *is_library_loaded= -2;
          return;
          }
      }
    }
  }

#if (OCELOT_MYSQL_INCLUDE == 1)
  my_ulonglong ldbms_mysql_affected_rows(MYSQL *mysql)
  {
    return t__mysql_affected_rows(mysql);
  }

  void ldbms_mysql_close(MYSQL *mysql)
  {
    t__mysql_close(mysql);
  }

  void ldbms_mysql_data_seek(MYSQL_RES *result, my_ulonglong offset)
  {
    t__mysql_data_seek(result, offset);
  }

  unsigned int ldbms_mysql_errno(MYSQL *mysql)
  {
    return t__mysql_errno(mysql);
  }

  const char *ldbms_mysql_error(MYSQL *mysql)
  {
    return t__mysql_error(mysql);
  }

  MYSQL_FIELD *ldbms_mysql_fetch_fields(MYSQL_RES *result)
  {
    return t__mysql_fetch_fields(result);
  }

  unsigned long *ldbms_mysql_fetch_lengths(MYSQL_RES *result)
  {
    return t__mysql_fetch_lengths(result);
  }

  MYSQL_ROW ldbms_mysql_fetch_row(MYSQL_RES *result)
  {
    return t__mysql_fetch_row(result);
  }

  void ldbms_mysql_free_result(MYSQL_RES *result)
  {
    t__mysql_free_result(result);
  }

  const char *ldbms_mysql_get_client_info(void)
  {
    return t__mysql_get_client_info();
  }

  const char *ldbms_mysql_get_host_info(MYSQL *mysql)
  {
    return t__mysql_get_host_info(mysql);
  }

  const char *ldbms_mysql_info(MYSQL *mysql)
  {
    return t__mysql_info(mysql);
  }

  MYSQL *ldbms_mysql_init(MYSQL *mysql)
  {
    return t__mysql_init(mysql);
  }

  void ldbms_mysql_library_end()
  {
    t__mysql_library_end();
  }

  int ldbms_mysql_library_init(int argc, char **argv, char **groups)
  {
    return t__mysql_library_init(argc, argv, groups);
  }

  MY_BOOL ldbms_mysql_more_results(MYSQL *mysql)
  {
    return t__mysql_more_results(mysql);
  }

  int ldbms_mysql_next_result(MYSQL *mysql)
  {
    return t__mysql_next_result(mysql);
  }

  unsigned int ldbms_mysql_num_fields(MYSQL_RES *result)
  {
    return t__mysql_num_fields(result);
  }

  my_ulonglong ldbms_mysql_num_rows(MYSQL_RES *result)
  {
    return t__mysql_num_rows(result);
  }

  int ldbms_mysql_options(MYSQL *mysql, enum ocelot_option option, const char *arg)
  {
    return t__mysql_options(mysql, option, arg);
  }

  int ldbms_mysql_ping(MYSQL *mysql)
  {
    return t__mysql_ping(mysql);
  }

  int ldbms_mysql_query(MYSQL *mysql, const char *stmt_str)
  {
    return t__mysql_query(mysql, stmt_str);
  }

  MYSQL *ldbms_mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag)
  {
    return t__mysql_real_connect(mysql, host, user, passwd, db, port, unix_socket, client_flag);
  }

  /* This is not usually called from the main thread. Do not put a message box in this. */
  int ldbms_mysql_real_query(MYSQL *mysql, const char *stmt_str, unsigned long length)
  {
    return t__mysql_real_query(mysql, stmt_str, length);
  }

  int ldbms_mysql_select_db(MYSQL *mysql, const char *db)
  {
    return t__mysql_select_db(mysql, db);
  }

  const char *ldbms_mysql_sqlstate(MYSQL *mysql)
  {
    return t__mysql_sqlstate(mysql);
  }

  bool ldbms_mysql_ssl_set(MYSQL *mysql, const char *a, const char *b, const char *c, const char *d, const char *e)
  {
    if (t__mysql_ssl_set == NULL) return 0;
    return t__mysql_ssl_set(mysql, a, b, c, d, e);
  }

  MYSQL_RES *ldbms_mysql_store_result(MYSQL *mysql)
  {
    return t__mysql_store_result(mysql);
  }

  void ldbms_mysql_thread_end()
  {
    t__mysql_thread_end();
  }

  unsigned int ldbms_mysql_warning_count(MYSQL *mysql)
  {
    return t__mysql_warning_count(mysql);
  }

  int ldbms_AES_set_decrypt_key(unsigned char *a, int b, AES_KEY *c)
  {
    return t__AES_set_decrypt_key(a, b, c);
  }

  void ldbms_AES_decrypt(unsigned char *a, unsigned char *b, AES_KEY *c)
  {
    t__AES_decrypt(a, b, c);
  }
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

#ifdef DBMS_TARANTOOL
  uint32_t ldbms_mp_decode_array(const char **data)
  {
    return t__mp_decode_array(data);
  }
  const char* ldbms_mp_decode_bin(const char **data, uint32_t *len)
  {
    return t__mp_decode_bin(data,len);
  }
  //uint32_t ldbms_mp_decode_binl(const char **data)
  //{
  //  return t__mp_decode_binl(data);
  //}
  bool ldbms_mp_decode_bool(const char **data)
  {
    return t__mp_decode_bool(data);
  }
  float ldbms_mp_decode_float(const char **data)
  {
    return t__mp_decode_float(data);
  }
  double ldbms_mp_decode_double(const char **data)
  {
    return t__mp_decode_double(data);
  }
  int64_t ldbms_mp_decode_int(const char **data)
  {
    return t__mp_decode_int(data);
  }
  uint32_t ldbms_mp_decode_map(const char **data)
  {
    return t__mp_decode_map(data);
  }
  void ldbms_mp_decode_nil(const char **data)
  {
    return t__mp_decode_nil(data);
  }
  uint64_t ldbms_mp_decode_uint(const char **data)
  {
    return t__mp_decode_uint(data);
  }
  const char* ldbms_mp_decode_str(const char **data, uint32_t *len)
  {
    return t__mp_decode_str(data,len);
  }
  uint32_t ldbms_mp_decode_strl(const char **data)
  {
    return t__mp_decode_strl(data);
  }
  void ldbms_mp_next(const char **data)
  {
    return t__mp_next(data);
  }
  enum mp_type ldbms_mp_typeof(const char c)
  {
    return t__mp_typeof(c);
  }

  ssize_t ldbms_tnt_auth(struct tnt_stream *a, const char *b, int c, const char *d, int e)
  {
    return t__tnt_auth(a,b,c,d,e);
  }
  ssize_t ldbms_tnt_call(struct tnt_stream *a, const char *b, size_t c, struct tnt_stream *d)
  {
    return t__tnt_call(a,b,c,d);
  }
  void ldbms_tnt_close(struct tnt_stream *a)
  {
    t__tnt_close(a);
  }
  int ldbms_tnt_connect(struct tnt_stream *a)
  {
    return t__tnt_connect(a);
  }
  size_t ldbms_tnt_delete(struct tnt_stream *a, uint32_t b, uint32_t c, tnt_stream *d)
  {
    return t__tnt_delete(a,b,c,d);
  }
  ssize_t ldbms_tnt_eval(struct tnt_stream *a, const char *b, size_t c, struct tnt_stream *d)
  {
    return t__tnt_eval(a,b,c,d);
  }
  ssize_t ldbms_tnt_flush(struct tnt_stream *a)
  {
    return t__tnt_flush(a);
  }
  ssize_t ldbms_tnt_execute(struct tnt_stream *a, const char *b, size_t c, struct tnt_stream *d)
  {
    return t__tnt_execute(a,b,c,d);
  }
  int ldbms_tnt_get_indexno(struct tnt_stream *a, int b, const char *c, size_t d)
  {
    return t__tnt_get_indexno(a,b,c,d);
  }
  int ldbms_tnt_get_spaceno(struct tnt_stream *a, const char *b, size_t c)
  {
    return t__tnt_get_spaceno(a,b,c);
  }
  void ldbms_tnt_stream_free(struct tnt_stream *a)
  {
    t__tnt_stream_free(a);
  }
  ssize_t ldbms_tnt_insert(struct tnt_stream *a, uint32_t b, struct tnt_stream *c)
  {
    return t__tnt_insert(a,b,c);
  }
  tnt_stream* ldbms_tnt_net(tnt_stream *a)
  {
    return t__tnt_net(a);
  }
  tnt_stream* ldbms_tnt_object(tnt_stream *a)
  {
    return t__tnt_object(a);
  }
  ssize_t ldbms_tnt_object_add_array(tnt_stream *a, uint32_t b)
  {
    return t__tnt_object_add_array(a,b);
  }
  ssize_t ldbms_tnt_object_add_nil(tnt_stream *a)
  {
    return t__tnt_object_add_nil(a);
  }
  ssize_t ldbms_tnt_object_add_int(tnt_stream *a, int64_t b)
  {
    return t__tnt_object_add_int(a,b);
  }
  ssize_t ldbms_tnt_object_add_str(tnt_stream *a, const char *b, uint32_t c)
  {
    return t__tnt_object_add_str(a,b,c);
  }
  ssize_t ldbms_tnt_object_add_bin(tnt_stream *a, const char *b, uint32_t c)
  {
    return t__tnt_object_add_bin(a,b,c);
  }
  ssize_t ldbms_tnt_object_add_bool(tnt_stream *a, char b)
  {
    return t__tnt_object_add_bool(a,b);
  }
  ssize_t ldbms_tnt_object_add_float(tnt_stream *a, float b)
  {
    return t__tnt_object_add_float(a,b);
  }
  ssize_t ldbms_tnt_object_add_double(tnt_stream *a, double b)
  {
    return t__tnt_object_add_double(a,b);
  }
  ssize_t ldbms_tnt_object_container_close(tnt_stream *a)
  {
    return t__tnt_object_container_close(a);
  }
  ssize_t ldbms_tnt_object_format(struct tnt_stream *a, const char *b, int c)
  {
    return t__tnt_object_format(a,b,c);
  }
  int ldbms_tnt_object_reset(struct tnt_stream *a)
  {
    return t__tnt_object_reset(a);
  }
  int ldbms_tnt_reload_schema(struct tnt_stream *a)
  {
    return t__tnt_reload_schema(a);
  }
  ssize_t ldbms_tnt_replace(struct tnt_stream *a, uint32_t b, struct tnt_stream *c)
  {
    return t__tnt_replace(a,b,c);
  }
  int ldbms_ttnt_reply(struct tnt_reply *a, char *b, size_t c, size_t *d)
  {
    return t__tnt_reply(a,b,c,d);
  }
  void ldbms_tnt_reply_free(struct tnt_reply *a)
  {
    t__tnt_reply_free(a);
  }
  int64_t ldbms_tnt_request_compile(struct tnt_stream *a, struct tnt_request *b)
  {
    return t__tnt_request_compile(a,b);
  }
  struct tnt_request* ldbms_tnt_request_eval(struct tnt_request *a)
  {
    return t__tnt_request_eval(a);
  }
  struct tnt_request* ldbms_tnt_request_call(struct tnt_request *a)
  {
    return t__tnt_request_call(a);
  }
  int ldbms_tnt_request_set_exprz(struct tnt_request *a, const char *b)
  {
    return t__tnt_request_set_exprz(a,b);
  }
  int ldbms_tnt_request_set_tuple(struct tnt_request *a, struct tnt_stream *b)
  {
    return t__tnt_request_set_tuple(a,b);
  }
  struct tnt_reply* ldbms_tnt_reply_init(struct tnt_reply *a)
  {
    return t__tnt_reply_init(a);
  }
  ssize_t ldbms_tnt_select(struct tnt_stream *a, uint32_t b, uint32_t c, uint32_t d, uint32_t e, uint8_t f, struct tnt_stream *g)
  {
    return t__tnt_select(a,b,c,d,e,f,g);
  }
  int ldbms_tnt_set(struct tnt_stream *a, int b, char *c)
  {
    return t__tnt_set(a,b,c);
  }
  ssize_t ldbms_tnt_update(struct tnt_stream *a, uint32_t b, uint32_t c, struct tnt_stream *d, struct tnt_stream *e)
  {
    return t__tnt_update(a,b,c,d,e);
  }
  enum tnt_error ldbms_tnt_error(struct tnt_stream *a)
  {
    return t__tnt_error(a);
  }
  char* ldbms_tnt_strerror(struct tnt_stream *a)
  {
    return t__tnt_strerror(a);
  }
#endif
};

#endif // LDBMS_H

#define MAIN_WIDGET 0
#define HISTORY_WIDGET 1
#define GRID_WIDGET 2
#define STATEMENT_WIDGET 3
#define DEBUG_WIDGET 4
#define EXTRA_RULE_1 5


#ifndef RESULT_CHANGES_H
#define RESULT_CHANGES_H

/*
  If a user edits a cell, the value in the result set becomes temporarily obsolete.
  So for display refreshing we will look in Result_changes to see if we want the newer value.
  Assumption = there will be very few changes (if there are many then find() will be slow).
  Todo: This must be set up when we make a result set (in fillup?) and wiped when we garbage collect.
  But should the parent be Result_qtextedit, or ResultGrid?
*/

class Result_changes: public QWidget
{
  Q_OBJECT

private:

struct Rows_and_columns{
    unsigned int row_number;
    unsigned int column_number;
    QByteArray qba;
};

Result_qtextedit *result_qtextedit;
QList<Rows_and_columns> *rows_and_columns_list;

public:

Result_changes(Result_qtextedit *m)
{
  result_qtextedit= m;
  rows_and_columns_list= new QList<Rows_and_columns>;
}

void append(unsigned int row_number, unsigned int column_number, QByteArray *value)
{
  Rows_and_columns r;
  r.row_number= row_number;
  r.column_number= column_number;
  r.qba= *value;
  rows_and_columns_list->append(r);
}

QByteArray find(unsigned int row_number, unsigned int column_number)
{
  for (int i= rows_and_columns_list->size() - 1; i >= 0; --i)
  {
    Rows_and_columns r= rows_and_columns_list->at(i);
    if ((r.row_number == row_number)
      && (r.column_number == column_number))
    {
      return rows_and_columns_list->at(i).qba;
    }
  }
  return QByteArray(1, 0); /* Todo: I really would prefer to return with size 0 */
}

/* Todo: ? */
~Result_changes()
{
  delete rows_and_columns_list;
}

};
#endif

#ifndef RESULT_QTEXTEDIT_H
#define RESULT_QTEXTEDIT_H

/*
  Do not change class name "Result_qtextedit" without checking its uses e.g. in menu_edit_paste().
*/

class Result_qtextedit: public QTextEdit
{
  Q_OBJECT

private:

    /* unused */
    struct result_column {
       unsigned int max_column_width;               /* calculate based on max if no squeeze */
       unsigned int height_in_chars;
       unsigned int width_in_pixels;                /* calculate from width_in_chars at start or if font change */
       unsigned int field_number;                   /* field number in result set if it's in the result set */
       char *field_names_pointer;
       unsigned int v_length;                       /* length of field name */
       unsigned char flags;
       unsigned int min_width_in_pixels;
    };

  ResultGrid *result_grid;
  int qtextedit_drag_start_x; /* See comment = Dragging theory. */
  int qtextedit_drag_start_y;
  int qtextedit_drag_start_time;
  bool qtextedit_is_in_drag_for_column, qtextedit_is_in_drag_for_row;
  int qtextedit_column_number_at_drag_start_time;
  int qtextedit_grid_row_number_at_drag_start_time;
  int qtextedit_result_row_number_at_drag_start_time;

  /* Things that get set by cell_analyze(). Mostly pixels or points. */
  int qtextedit_block_count;       /* from document()->blockCount() */
  int qtextedit_columns_per_row;   /* # of defined columns + 1 for the thin-image column */
  int qtextedit_x;                 /* from event->x() (changed to event->pos().x() due to qt 6 change) */
  int qtextedit_y;                 /* from event->y() (changed to event->pos().y() due to qt 6 change) */
  int qtextedit_block_number;      /* what we calculate other things from */
  int qtextedit_grid_row_number;        /* row number, starts at 1, includes header row, within display */
  int qtextedit_result_row_number;      /* row number from result set, derived from qtextedit_grid_row_number */
  int qtextedit_column_number;     /* column number, starts at 1, includes thin image column */
  bool qtextedit_is_before_column; /* x is on a pixel that precedes qtextedit_column */
  bool qtextedit_is_before_row;    /* y is on a pixel that precedes qtextedit_row */
  int qtextedit_x_start;         /* start of the column that x is on */
  int qtextedit_x_end;           /* end of the column that x is on, border included (actual width = end - start) */
  int qtextedit_y_start;         /* start of the row that y is on */
  int qtextedit_y_end;           /* end of the row that y is on, border included (actual height = end - start) */
  QString qtextedit_cell_content;  /* cell contents. but if it's an image we get U+fffc or something like that */
                                   /* Actually this probably should be in locals */
  bool qtextedit_at_end;           /* If document doesn't fill result widget, this can become true */

  Result_changes *qtextedit_result_changes;

  void cell_analyze(int x, int y);
  void construct();
  int result_row_number_from_grid_row_number(int grid_row_number);
  int grid_row_number_from_result_row_number(int result_row_number);
//  int result_column_number_from_grid_column_number(int grid_row_number, int grid_column_number);
  QString unstripper(QString value_to_unstrip);
  void generate_update();
  QString to_plain_text();

private slots:
// e.g. void timer_expired();

public slots:
void menu_context_t(const QPoint & pos)
{
  menu_context_t_2(pos);
}

protected:
void changeEvent(QEvent *e);
void closeEvent(QCloseEvent *e);
void focusInEvent(QFocusEvent *e);
void focusOutEvent(QFocusEvent *e);
void hideEvent(QHideEvent *e);
void keyPressEvent(QKeyEvent *e);
void mouseDoubleClickEvent(QMouseEvent *e);
void mouseMoveEvent(QMouseEvent *e);
void mousePressEvent(QMouseEvent *e);
void mouseReleaseEvent(QMouseEvent *e);
void paintEvent(QPaintEvent *e);
void resizeEvent(QResizeEvent *e);
void showEvent(QShowEvent *e);

public:

void copy();  /* via menu_edit_copy() */
void cut();
void paste();
void undo();
void redo();
void selectAll();
void zoomIn();
void zoomOut();
void menu_context_t_2(const QPoint & pos);
int copy_html_cell(char *ocelot_grid_detail_numeric_column_start, char *ocelot_grid_detail_char_column_start,
                   char *tmp_pointer, char *result_pointer, char result_set_value_flags, int v_length, int cell_type,
                   int width, int height, QFont result_grid_font, int setting_max_width_of_a_char,
                   int passed_i, long unsigned int tmp_xrow, char *ocelot_grid_detail_char_column_end,
                   int *new_cell_height, unsigned int result_column_no);

Result_qtextedit(ResultGrid *m)
{
  result_grid= m;
  construct();
}

/* Todo: don't forget to delete [] grid_columns somewhere */
/* It might not be necessary to delete anything made in Result_qtextedit::construct(), but try anyway. */
~Result_qtextedit()
{
  delete qtextedit_result_changes;
}

};
#endif

/*********************************************************************************************************/

/* THE GRID WIDGET */
/*
  As of June 2021 major change:
  The default display, which is also the odbc_html=1 vertical=0 display, is an HTML 4 table.
  We allow dragging, width|height changing, changing cell background for "focus", images,
  cut/copy/paste, scrolling.
  Todo: allow change of setTextDirection() based on language or on client variable.
  Todo: see this re trail spaces: http://qt-project.org/doc/qt-4.8/qtextoption.html#Flag-enum
  Todo: although min(column width) = heading width, don't have to make text editable area that wide
  Todo: have to think what to do with control characters, e.g. for tabs should I have
        setTabChangesFocus(true), for others should I allow the effects or display specially.
  Todo: I used an eventfilter to detect scrolling because QScrollBar::valueChanged()
        failed, but someday I should find out why and retry. See vertical_scroll_bar_event().
  Todo: "new" operations should have nothrow checks.
  Todo: add even more junk about dontshowonscreen or opacity if there is flickering.
  Todo: Our wrap policy is like QTextOption::WrapAnywhere -- there could be a user-settable option for this
        if the preference was to wrap on word boundaries when possible. Could be difficult.
*/
/*
  Todo:
  These events can happen to a grid and force recalculation:
  QEvent::ContentsRectChange               The margins of the widget's content rect changed.
  QEvent::FontChange                       Widget's font has changed.
  QEvent::HideToParent                     a child widget has been hidden
  QEvent::Resize
  QEvent::ShowToParent                     a child widget has been shown
  QEvent::StyleChange                      I don't think this matters
  ... Also, user might resize columns or rows via dragging.
*/

/*
  this
    hbox_layout                QHBoxLayout
      grid_scroll_area         QScrollArea *
      grid_vertical_scroll_bar QScrollBar *
  client                       QWidget *
    grid_main_layout           QVBoxLayout
      html_text_edit           Result_qtextedit *

  Making the grid-cell QTextWidgets resizable was difficult.
  I couldn't get satisfactory results with QSplitter, and don't believe that satisfactory results would be possible.
  Finally a suggestion by Aleksey Osipov aliks-os@yandex.ru https://qt-project.org/wiki/Widget-moveable-and-resizeable
  inspired me. I didn't actually use the suggestion (my requirements are much simpler), but I realized that all one has to do is
  subclass a QFrame with a QTextEdit inside it, and put routines in for when the mouse is pressed|moved|released on
  the QFrame. In this implementation only right|left dragging of the subclassed QFrame, called TextEditFrame, is allowed.
  Todo: Mr Osipov had routines for resizing with keyboard control, and I should add that.
  Todo: up|down dragging, although vertical shrinking will not mean that more rows appear on the screen.
        Up|down dragging "works" now but is undocumented, and still needs fixes for:
          todo: minimum height (currently doesn't look right), bottom drag line size, bottom drag line color
  Todo: vertical resizing currently looks odd. I've read that "Correct place to do special layout management is overridden resizeEvent."
  Todo: test with a frame that has been scrolled horizontally so half of it is not visible, while there's a scoll bar.
  Todo: There can be a bit of flicker during drag though I doubt that anyone will care.
  Todo: BUG: If the QTextEdit gets a vertical scroll bar, then the horizontal cursor appears over the scroll bar,
        and dragging won't work. The problem is alleviated if border_size > 1. (Check: maybe this is fixed.)
  Todo: Initializing copy_of_ocelot_html etc. works around a problem but isn't adequate if user changes
        ocelot_html etc. to non-default values and then changes the font.
  Todo: Find out why cut-and-paste often fails. Maybe it's that selecting doesn't change colour or paintevent returns wrong.
  Re cursor shapes, see http://qt-project.org/doc/qt-4.8/qcursor.html#details
*/

/*
  The changes made by dragging are persistent as long as the result set is up.
*/

/*
  Note#1:
  For TextEditFrame's mouseMoveEvent we say setCursor to change the shape, as we should, to hint it's draggable.
  But http://qt-project.org/doc/qt-4.8/qwidget.html#cursor-prop says:
  "If no cursor has been set, or after a call to unsetCursor(), the parent's cursor is used."
  That affects the child QTextEdit when it touches the border, and it in turn has a child: the vertical scroll bar.
  Therefore there is also an explicit setCursor for the child QTextEdit.
*/

/*
  Re: how the grid is displayed
  The display is reasonably close to instant in most cases, even when there are thousands of rows.
  Mostly that's because there are only a few hundred widgets, regardless of result row count.
  We create a pool of cell widgets and a pool of row widgets, which only needs expanding if there are many many columns per row.
  When it comes time to display a cell, if it was previously used  for displaying a different row + column, we change it.
  There's some added complication if sql_more_results is true; in that case we make a copy of the contents of mysql_res.
  Actually I think sql_more_results is always true nowadays.
*/

#ifndef RESULTGRID_H
#define RESULTGRID_H

class ResultGrid: public QWidget
{
  Q_OBJECT
private:
  QWidget *client;
  QScrollArea *grid_scroll_area;
  int grid_vertical_scroll_bar_value;                            /* Todo: find out why this isn't defined as long unsigned */
public:
  QScrollBar *grid_vertical_scroll_bar;                          /* This might take over from the automatic scroll bar. */
  unsigned int result_column_count;
  long unsigned int result_row_count, grid_result_row_count;
//  long unsigned int *lengths;
  unsigned int *grid_column_widths;                         /* dynamic-sized list of widths */
  unsigned int *result_max_column_widths; /* chars not bytes */ /* dynamic-sized list of actual maximum widths in detail columns */
  unsigned int *grid_column_heights;                         /* dynamic-sized list of heights */
  unsigned char *grid_column_dbms_sources;                   /* dynamic-sized list of sources */
  unsigned short int *result_field_types;          /* dynamic-sized list of types */
  unsigned int *result_field_charsetnrs;           /* dynamic-sized list of character set numbers */
  unsigned int *result_field_flags;                /* dynamic-sized list of flags */
//  unsigned long result_row_number;                    /* row number in result set */
#if (OCELOT_MYSQL_INCLUDE == 1)
  MYSQL_ROW row;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  int is_paintable;
#ifdef OLD_STUFF
  unsigned int max_text_edit_frames_count;                       /* used for a strange error check during paint events */
#endif
  unsigned int grid_row_heights[1000];

  unsigned int result_grid_widget_max_height_in_lines;
#if (OCELOT_MYSQL_INCLUDE == 1)
  MYSQL_FIELD *mysql_fields;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef OLD_STUFF
  TextEditWidget **text_edit_widgets; /* Todo: consider using plaintext */ /* dynamic-sized list of pointers to QPlainTextEdit widgets */
  QHBoxLayout **text_edit_layouts;
  TextEditFrame **text_edit_frames;
#endif
  MYSQL_RES *grid_mysql_res;
  unsigned short ocelot_vertical_copy;
  unsigned short ocelot_result_grid_column_names_copy;
  unsigned short ocelot_client_side_functions_copy;
  char *result_set_copy;                                     /* gets a copy of mysql_res contents, if necessary */
  char **result_set_copy_rows;                               /* dynamic-sized list of result_set_copy row offsets, if necessary */
  char *result_field_names;                                  /* gets a copy of mysql_fields[].name */
  char *result_original_field_names;                         /* gets a copy of mysql_fields[].org_name */
  char *result_original_table_names;                         /* gets a copy of mysql_fields[].org_table */
  char *result_original_database_names;                      /* gets a copy of mysql_fields[].db */

  unsigned int gridx_column_count;
  long unsigned int gridx_row_count;
  char *gridx_field_names;                                   /* gets a copy of result_field_names */
  unsigned int *gridx_max_column_widths; /* chars not bytes */ /* gets a copy of result_max_column_widths */
  unsigned int *gridx_result_indexes;                        /* points to result_ lists */
  unsigned char *gridx_flags;                                /* 0 = normal, 1 = row counter */
  unsigned short int *gridx_field_types;                     /* gets a copy of result_field_types */

//  unsigned int grid_actual_grid_height_in_rows;
  unsigned int grid_actual_row_height_in_lines;
  /* ocelot_grid_height_of_highest_column will be between 1 and ocelot_grid_max_column_height_in_lines, * pixels-per-line */
  unsigned int max_height_of_a_char;
  unsigned int setting_max_width_of_a_char;                  /* changeable with settings_change_calc() */
  unsigned int setting_min_width_of_a_column;                /* changeable with settings_change_calc() */
  unsigned int setting_bearing;                              /* changeable with settings_change_calc() */

 QHBoxLayout *hbox_layout;

//  QHBoxLayout **grid_row_layouts;                               /* dynamic-sized list of pointers to rows' QHBoxLayout layouts */
//  QWidget **grid_row_widgets;                                   /* dynamic-sized list of pointers to rows' QWidget widgets */
  QVBoxLayout *grid_main_layout;                                   /* replaces QGridLayout *grid_layout */
  /* QWidget *grid_main_widget;  */                                /* replaces QGridLayout *grid_layout -- but we say "client" */

  MainWindow *copy_of_parent;
  int copy_of_connections_dbms;
  unsigned short int copy_of_ocelot_vertical;
  unsigned short int copy_of_ocelot_result_grid_column_names;
  unsigned short int copy_of_ocelot_batch;
  unsigned short int copy_of_ocelot_html;
  unsigned short int copy_of_ocelot_raw;
  unsigned short int copy_of_ocelot_xml;

  Result_qtextedit *html_text_edit;
  QTextEdit *batch_text_edit;

  int border_size;                                             /* used when calculating cell height + width */
  unsigned int ocelot_grid_max_desired_width_in_pixels;        /* used when calculating cell height + width */
  unsigned int ocelot_grid_max_column_height_in_lines;         /* used when calculating cell height + width */
  unsigned int grid_max_column_height_in_pixels;

  unsigned int setting_ocelot_grid_cell_drag_line_size_as_int; /* no longer used */
  unsigned int setting_ocelot_grid_cell_border_size_as_int;    /* changeable with settings_change_calc() */
  unsigned int setting_ocelot_grid_cell_width_as_int;
  QString ocelot_grid_text_color;
  QString ocelot_grid_background_color;
//  QString ocelot_grid_cell_drag_line_color;

#ifdef OLD_STUFF
  QString frame_color_setting;                                 /* based on drag line color */
#endif
  QFont result_grid_font;
  ldbms *lmysql;
  unsigned int scroll_bar_width;
  unsigned int scroll_bar_height;
  int result_grid_height_after_last_resize; /* not unsigned int because we might see it as -1 */
  int result_grid_width_after_last_resize;

  int result_grid_vertical_width_of_header;
  int result_grid_vertical_width_of_value;

  int focus_result_row_number, focus_column_number;

/* How many rows can fit on the screen? Take a guess for initialization. */
#define RESULT_GRID_WIDGET_INITIAL_HEIGHT 10

/* Use NULL_STRING when displaying a column value which is null. Length is sizeof(NULL_STRING) - 1. */
#define NULL_STRING "NULL"

/* During scan_rows we might set a flag e.g. if a column value is null */
#define FIELD_VALUE_FLAG_IS_ZERO 0
#define FIELD_VALUE_FLAG_IS_NULL 1
#define FIELD_VALUE_FLAG_IS_NUMBER 2
#define FIELD_VALUE_FLAG_IS_STRING 4
#define FIELD_VALUE_FLAG_IS_OTHER 8
#define FIELD_VALUE_FLAG_IS_IMAGE 16

/* Todo: Maybe it would be better to depend on setting_min_width_of_a_column */
#define MIN_WIDTH_IN_CHARS 3

ResultGrid(
//        MYSQL_RES *mysql_res,
        ldbms *passed_lmysql,
        MainWindow *parent,
        bool is_displayable): QWidget(parent)
{
  is_paintable= 0;

  /* todo: see if we can get rid of client and go direct to resultgrid */
  client= new QWidget(this);

  lmysql= passed_lmysql;

  copy_of_parent= parent;
#ifdef OLD_STUFF
  text_edit_widgets= 0;                                     /* all dynamic-sized items should be initially zero */
  text_edit_layouts= 0;
  text_edit_frames= 0;
#endif
  grid_column_widths= 0;                                    /* initializing for display_garbage_collect */
  result_max_column_widths= 0;
  grid_column_heights= 0;
  grid_column_dbms_sources= 0;
  result_field_types= 0;                                     /* initializing for fillup_garbage_collect */
  result_field_charsetnrs= 0;
  result_field_flags= 0;
  result_set_copy= 0;
  result_set_copy_rows= 0;
  result_field_names= 0;
  result_original_field_names= 0;
  result_original_table_names= 0;
  result_original_database_names= 0;
  gridx_field_names= 0;

  gridx_max_column_widths= 0;
  gridx_result_indexes= 0;
  gridx_flags= 0;
  gridx_field_types= 0;
  grid_vertical_scroll_bar= 0;
  grid_scroll_area= 0;
  /* grid_layout= 0; */
  hbox_layout= 0;
  //grid_row_layouts= 0;
  //grid_row_widgets= 0;
  grid_main_layout= 0;

  /* grid_main_widget= 0; */
  border_size= 1;                                          /* Todo: This actually has to depend on stylesheet */

  /* For some reason the next two lines were commented out. */
  result_row_count= 0;
  result_column_count= 0;
  grid_result_row_count= 0;
#ifdef OLD_STUFF
  max_text_edit_frames_count= 0;
#endif
  if (is_displayable == false)
  {
    grid_main_layout= 0;
    html_text_edit= NULL;
    batch_text_edit= NULL;
    return;
  }


  result_grid_widget_max_height_in_lines= RESULT_GRID_WIDGET_INITIAL_HEIGHT;

  /* We might say "new ResultGrid(0)" merely so we'd have ResultGrid in the middle spot in the layout-> */

  /* Create the cell pool. */
  /*
    Make the cells. Each cell is one QTextEdit (subclassed as TextEditWidget)
    within one QHBoxLayout within one TextEditFrame.
    Each TexteditFrame i.e. text_edit_frames[n] will be added to the scroll area.
  */
  /* Todo: say "(this)" a lot so automatic garbage collect will work. */
  grid_scroll_area= new QScrollArea(this);

  grid_scroll_area->setWidget(client);
  grid_scroll_area->setWidgetResizable(true);              /* Without this, the QTextEdit widget heights won't change */

  vertical_scroll_bar_construct(); /* grid_vertical_scroll_bar= new QScrollBar(this); etc. */

  /* setContentsMargins overrides style settings, I suppose. */
  /* Will setSpacing(0) keep scroll bar beside scroll area? Apparently not. Useless. */
  /* We could add a label with a line like the one below. That would be a header. Useless? */
  /* hbox_layout->addWidget(new QLabel("La La La", this)); */
  hbox_layout= new QHBoxLayout(this);
  /*
    An earlier comment about this area said:
    "The following line would make the grid_vertical_scroll_bar appear right beside the
    grid_scroll_area, but the scroll bars on the QTextEdit widgets would disappear. No good.
    hbox_layout->setSizeConstraint(QLayout::SetFixedSize);
       ... but that would be a reasonable thing to do if total width of all columns is less than widget width."
    But now, I'm not seeing that the scroll bars on the QTextEdit
    widgets disappear. If this wasn't here, it would be tough to prevent width expansion when columns
    don't fill the line. Even as it is, the amount of desperate kludging is something to behold, eh?
    Todo: calculate the width more accurately.
    Todo: Now the bloody thing won't get shrink! Need to get the signal for resizing.
  */
  /*
    int xxsize= 0 ;
    for (int xxcol= 0 ; xxcol<result_column_count; ++xxcol) xxsize+=grid_column_widths[xxcol] + 10;
    if (xxsize > (ocelot_grid_max_desired_width_in_pixels-50)) xxsize=ocelot_grid_max_desired_width_in_pixels-50;
    grid_scroll_area->setMinimumWidth(xxsize);
  */
  hbox_layout->setContentsMargins(0, 0, 0, 0);
  hbox_layout->setSpacing(0);
  /* html_text_edit + batch_text_edit exist always except during temporary delete in display_garbage_collect() */
  html_text_edit= new Result_qtextedit(this);
  batch_text_edit= new QTextEdit(this);

  hbox_layout->addWidget(grid_scroll_area);
//  hbox_layout->addWidget(html_text_edit);
//  html_text_edit->show();

  hbox_layout->addWidget(grid_vertical_scroll_bar);
  grid_vertical_scroll_bar->show();
  /* hbox_layout->setSizeConstraint(QLayout::SetFixedSize); */
  /*
    Strange but true: when we said "new QHBoxLayout(this)" that meant this already has a layout,
    so I suppose there is no need to say "setLayout(hbox_layout)" here.
  */
  /* setLayout(hbox_layout); */
  /* Can't recall why "grid_vertical_scroll_bar_value= 0;" was here -- it meant that
     after fontchange the rows were back at the start */
  /* grid_vertical_scroll_bar_value= 0; */
  /* grid_vertical_scroll_bar= grid_scroll_area->verticalScrollBar(); */

  /* Typically scroll_bar_width = 13.
     If there was an option to change it, we'd have to use
     a different way to find its width.
     Todo: move this, it doesn't need recalculation
     Todo: some people on a forum said height is 3 pixels too small.
  */
  scroll_bar_width= html_text_edit->style()->pixelMetric(QStyle::PM_ScrollBarExtent);
  scroll_bar_height= html_text_edit->style()->pixelMetric(QStyle::PM_ScrollBarExtent);

  /* This won't be correct until after resizeEvent() and after a real display of the resultgrid widget */
  result_grid_height_after_last_resize= -1;
  result_grid_width_after_last_resize= -1;

  /*
    Just a note for the archives ...
    Originally I had "grid_main_layout= new QVBoxLayout(client);" here.
    I didn't realize that caused the equivalent of client->setLayout(), apparently.
    So the later pseudo-assertion (checking if client->layout() != 0) happened. Don't need that.
  */
  grid_main_layout= new QVBoxLayout();
  grid_main_layout->setContentsMargins(QMargins(0, 0, 0, 0));   /* this overrides style settings, I suppose */

  grid_main_layout->setSpacing(0);                          /* ?? premature? */

  /* We used to say this but override it in some display functions */
  //grid_main_layout->setSizeConstraint(QLayout::SetFixedSize);  /* This ensures the grid columns have no spaces between them */
  grid_main_layout->setSizeConstraint(QLayout::SetMaximumSize);

//  grid_main_layout->addWidget(html_text_edit); /* Huh? This can't be right. */

  client->setLayout(grid_main_layout);

  /* 2018-10-08 Maybe this will finally fix the bug where initial cell height was too small? */
  // result_grid_font= this->font();
  result_grid_font= parent->get_font_from_style_sheet(parent->ocelot_grid_style_string);

  settings_change_calc();

  set_grid_max_column_height_in_pixels((parent->height() / 3) - 11);
#ifdef OLD_STUFF
  set_frame_color_setting();
#endif

  copy_of_ocelot_batch= copy_of_ocelot_html= copy_of_ocelot_raw= copy_of_ocelot_xml= 0;
}

/*
  Often an OCELOT_DATA_TYPE value is the same as a MYSQL_TYPE value, for example
  MYSQL_TYPE_LONG_BLOB=251 in mysql_com.h and #define OCELOT_DATA_TYPE_LONG_BLOG 251 here.
  But we have additional TEXT and BINARY types because we distinguish when charsetnr=63.
  DECIMAL and NEWDECIMAL are both DECIMAL. LONG is INT. INT24 is MEDIUMINT. LONGLONG is BIGINT.
  STRING is CHAR (only). VAR_STRING is VARCHAR (only). BLOB is BLOB (only).
  See also struct typer.
*/
#define OCELOT_DATA_TYPE_DECIMAL     0
#define OCELOT_DATA_TYPE_TINY        1
#define OCELOT_DATA_TYPE_SHORT       2
#define OCELOT_DATA_TYPE_LONG        3
#define OCELOT_DATA_TYPE_FLOAT       4
#define OCELOT_DATA_TYPE_DOUBLE      5
#define OCELOT_DATA_TYPE_NULL        6
#define OCELOT_DATA_TYPE_TIMESTAMP   7
#define OCELOT_DATA_TYPE_LONGLONG    8
#define OCELOT_DATA_TYPE_INT24       9
#define OCELOT_DATA_TYPE_DATE        10
#define OCELOT_DATA_TYPE_TIME        11
#define OCELOT_DATA_TYPE_DATETIME    12
#define OCELOT_DATA_TYPE_YEAR        13
//#define OCELOT_DATA_TYPE_NEWDATE     14
//#define OCELOT_DATA_TYPE_VARCHAR     15
#define OCELOT_DATA_TYPE_BIT         16
#define OCELOT_DATA_TYPE_JSON        245       /* new in MySQL 5.7. todo: don't ignore it */
#define OCELOT_DATA_TYPE_NEWDECIMAL  246
#define OCELOT_DATA_TYPE_ENUM        247
#define OCELOT_DATA_TYPE_SET         248
//#define OCELOT_DATA_TYPE_TINY_BLOB   249
//#define OCELOT_DATA_TYPE_MEDIUM_BLOB 250
//#define OCELOT_DATA_TYPE_LONG_BLOB   251
#define OCELOT_DATA_TYPE_BLOB        252
#define OCELOT_DATA_TYPE_VAR_STRING  253       /* i.e. VARCHAR or VARBINARY */
#define OCELOT_DATA_TYPE_STRING      254       /* i.e. CHAR or BINARY */
#define OCELOT_DATA_TYPE_GEOMETRY    255
#define OCELOT_DATA_TYPE_BINARY      10001
#define OCELOT_DATA_TYPE_VARBINARY   10002
#define OCELOT_DATA_TYPE_TEXT        10003
#define OCELOT_DATA_TYPE_SCALAR      12001     /* numbers > 12000 are Tarantool-specific */
#define OCELOT_DATA_TYPE_BOOLEAN     12002
#define OCELOT_DATA_TYPE_MAP         12003
#define OCELOT_DATA_TYPE_ARRAY       12004
#define OCELOT_DATA_TYPE_INTEGER     12005
#define OCELOT_DATA_TYPE_UNSIGNED    12006
#define OCELOT_DATA_TYPE_NUMBER      12007

/*
  Return true if what's at pointer has an image signature.
  We only do this for Tarantool, we set data type = OCELOT_DATA_TYPE_BLOB
  if the length is > 100 (arbitrary) and if the signature for .jpg or
  .png or .gif is at the start (not a reliable check but a false hit won't do a
  lot of harm). See wikipedia article = List of file signatures.
  We don't actually care except for extra_rule_1.
  We could do this check for MySQL/MariaDB too, but for them we simply
  look at the data type.
  Todo: check for other signatures, e.g. bmp.
*/
bool is_image_format(int length, char* pointer)
{
  unsigned char *p= (unsigned char*) pointer;
  if (length <= 100) return false;
  if ((*p == 0x89) && (*(p+1) == 0x50) && (*(p+2) == 0x4e))
    return true;
  if ((*p == 0xff) && (*(p+1) == 0xd8) && (*(p+2) == 0xff))
    return true;
  if ((memcmp(p,"GIF87a",6) == 0) || (memcmp(p,"GIF89a",6) == 0))
    return true;
  return false;
}

/*
  Return false if the display doesn't have a table that we can do fancy things with.
  Else Result_qtextedit overriding functions e.g. mouseMoveEvent() will get confused.
  Todo: Maybe part of this is unnecessary, display_batch uses batch_text_edit not html_text_edit.
*/
bool is_fancy()
{
  if ((result_row_count == 0) || (result_column_count == 0)) return false;
  if (html_text_edit == NULL) return false;
  if ((copy_of_ocelot_batch != 0)
   || (copy_of_ocelot_xml != 0)
   || (copy_of_ocelot_raw != 0))
    return false;
  return true;
}

/* Todo: not everything that calls fillup() calls fillup_garbage_collect() later, i.e. leak */
/* We call fillup() whenever there is a new result set to put up on the result grid widget. */
QString fillup(MYSQL_RES *mysql_res,
            //struct tnt_reply *tarantool_tnt_reply,
            int connections_dbms,
            //MainWindow *parent,
            ldbms *passed_lmysql,
            int ocelot_client_side_functions,
            unsigned int connection_number,
            bool is_for_display)
{
  /* TODO: put the copy_res_to_result stuff in a subsidiary private procedure. */
  lmysql= passed_lmysql;
  ocelot_client_side_functions_copy= ocelot_client_side_functions;

  grid_mysql_res= mysql_res;
#ifdef DBMS_TARANTOOL
  if (connections_dbms == DBMS_TARANTOOL)
  {
    result_row_count= copy_of_parent->tarantool_num_rows(connection_number);
    if (result_row_count == 0)
    {
      /* Tarantool has no columns if there are no rows. */
      /* Todo: this is no longer true, if type = 5 */
      result_column_count= 0; /* solves the crash? */
      return "OK";
    }
    result_column_count= copy_of_parent->tarantool_num_fields();
  }
  else
#endif
  {
#if (OCELOT_MYSQL_INCLUDE == 1)
    result_column_count= lmysql->ldbms_mysql_num_fields(grid_mysql_res);
    result_row_count= lmysql->ldbms_mysql_num_rows(grid_mysql_res);                /* this will be the height of the grid */
    mysql_fields= lmysql->ldbms_mysql_fetch_fields(grid_mysql_res);
#else
    ;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  }
  result_max_column_widths= new unsigned int[result_column_count];
  result_field_types= new unsigned short int[result_column_count];
  result_field_charsetnrs= new unsigned int[result_column_count];
  result_field_flags= new unsigned int[result_column_count];

#ifdef DBMS_TARANTOOL
  if (connections_dbms == DBMS_TARANTOOL)
  {
    QString result= copy_of_parent->tarantool_scan_rows(result_column_count, result_row_count,
              grid_mysql_res,
              &result_set_copy, &result_set_copy_rows,
              &result_max_column_widths);
    if (result != "OK")
    {
      fillup_garbage_collect();
      return result;
    }
  }
  else
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
    scan_rows(result_column_count, result_row_count,
              grid_mysql_res,
              &result_set_copy, &result_set_copy_rows,
              &result_max_column_widths);
#else
    {;}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
  if (connections_dbms == DBMS_TARANTOOL)
  {
    QString r;
    r= copy_of_parent->tarantool_scan_field_names("name", result_column_count, &result_field_names, is_for_display);
    if (r != "OK") return r;
    /* Next three scan_field_names calls are only needed if user will edit the result set */
    copy_of_parent->tarantool_scan_field_names("org_name", result_column_count, &result_original_field_names, is_for_display);
    copy_of_parent->tarantool_scan_field_names("org_table", result_column_count, &result_original_table_names, is_for_display);
    copy_of_parent->tarantool_scan_field_names("db", result_column_count, &result_original_database_names, is_for_display);
  }
  else
#endif
  {
#if (OCELOT_MYSQL_INCLUDE == 1)
    scan_field_names("name", result_column_count, &result_field_names);
    /* Next three scan_field_names calls are only needed if user will edit the result set */
    scan_field_names("org_name", result_column_count, &result_original_field_names);
    scan_field_names("org_table", result_column_count, &result_original_table_names);
    scan_field_names("db", result_column_count, &result_original_database_names);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  }
#ifdef DBMS_TARANTOOL
  /* Scan entire result set to determine if NUM_FLAG should go on. */
  /* TODO: maybe this is unnecessary now that we are checking numericness for each cell? */
  if (connections_dbms == DBMS_TARANTOOL)
  {
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      //result_field_types[i]= OCELOT_DATA_TYPE_VAR_STRING; replaced on 2021-01-03
      result_field_types[i]= copy_of_parent->field_type_list_all_rows[i];
      result_field_charsetnrs[i]= 83; /* utf8, utf8_bin */
      result_field_flags[i]= 0; /* todo: decide if it's numeric */
    }
    long unsigned int tmp_xrow;
    char *pointer= result_set_copy_rows[0];
    unsigned int v_length;
    for (tmp_xrow= 0; tmp_xrow < result_row_count; ++tmp_xrow)
    {
      for (unsigned int i= 0; i < result_column_count; ++i)
      {
        memcpy(&v_length, pointer, sizeof(unsigned int));
        char tmp_flag= *(pointer + sizeof(unsigned int));
        result_field_flags[i]|= tmp_flag;
        if (tmp_flag == FIELD_VALUE_FLAG_IS_STRING)
        {
          if (is_image_format(v_length, pointer + sizeof(unsigned int) + sizeof(char)))
          {
            result_field_flags[i]|= FIELD_VALUE_FLAG_IS_IMAGE;
          }
        }
        pointer+= v_length + sizeof(unsigned int) + sizeof(char);
      }
    }
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      if ((result_field_flags[i] & (FIELD_VALUE_FLAG_IS_NUMBER | FIELD_VALUE_FLAG_IS_STRING)) == FIELD_VALUE_FLAG_IS_NUMBER)
        result_field_flags[i]= NUM_FLAG;
      else
      {
        if ((result_field_flags[i] & FIELD_VALUE_FLAG_IS_IMAGE) != 0)
        {
          result_field_types[i]= OCELOT_DATA_TYPE_BLOB;
          result_field_charsetnrs[i]= 63;
        }
        result_field_flags[i]= 0;
      }
    }
  }
  else
#endif

  {
#if (OCELOT_MYSQL_INCLUDE == 1)
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      result_field_types[i]= mysql_fields[i].type;
      result_field_charsetnrs[i]= mysql_fields[i].charsetnr;
      result_field_flags[i]= mysql_fields[i].flags;
    }
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  }

  if (copy_of_parent->conditional_settings.count() > 0)
  {
    /* Todo: filter conditional_settings so for some frames we won't need to check every time */
  }

  /*
    At this point, we have:
      result_column_count, result_row_count
      result_set_copy, result_set_copy_rows,
      result_field_names,
      result_original_field_names, result_original_table_names, result_original_database_names,
      result_max_column_widths
      mysql_fields (which we should not use, but we do)
    From now on there should be no need to call mysql_ functions again for this result set.
    if is_for_display was true, we're ready to call display() now
  */
  copy_of_connections_dbms= connections_dbms; /* Todo: check: will I ever need this? */
  return "OK";
}

void switch_to_batch_text_edit()
{
  if (html_text_edit->isVisible() == true) html_text_edit->hide();
  if (batch_text_edit->isVisible() == false) batch_text_edit->show();
  if (grid_main_layout->indexOf(html_text_edit) != -1) grid_main_layout->removeWidget(html_text_edit);
  if (grid_main_layout->indexOf(batch_text_edit) == -1) grid_main_layout->addWidget(batch_text_edit);
}

void switch_to_html_text_edit()
{
  if (batch_text_edit->isVisible() == true) batch_text_edit->hide();
  if (html_text_edit->isVisible() == false) html_text_edit->show();
  if (grid_main_layout->indexOf(batch_text_edit) != -1) grid_main_layout->removeWidget(batch_text_edit);
  if (grid_main_layout->indexOf(html_text_edit) == -1) grid_main_layout->addWidget(html_text_edit);
}

/*
  For display with xml or batch or raw, i.e. not the usual (html). Just dump.
  Todo: Check: ocelot_html!=0 and ocelot_raw != 0 and ocelot_vertical != 0.
*/
void display_batch()
{
  switch_to_batch_text_edit(); /* so grid_main_layout has batch_text_edit and not html_text_edit */
  char ocelot_grid_table_start[896];
  char ocelot_grid_header_row_start[32];
  char ocelot_grid_header_row_end[32];
  char ocelot_grid_header_numeric_column_start[32];
  char ocelot_grid_header_numeric_column_end[32];
  char ocelot_grid_header_char_column_start[32];
  char ocelot_grid_header_char_column_end[32];
  char ocelot_grid_detail_row_start[32];
  char ocelot_grid_detail_row_end[32];
  char ocelot_grid_detail_numeric_column_start[32];
  char ocelot_grid_detail_numeric_column_end[32];
  char ocelot_grid_detail_char_column_start[320];
  char ocelot_grid_detail_char_column_end[32];
  char ocelot_grid_table_end[320];

  /* Todo: this should be done permanently, on persistent variables. */
  if (copy_of_ocelot_html != 0)
  {
    char html_border_color[32];
    char html_color[32];
    char html_background_color[32];
    char html_header_background_color[32];
    char html_font_family[32];
    char html_font_size[32];
    char html_font_style[32];
    char html_font_weight[32];
    char html_outer_color[32];
    int html_border_size;
    strcpy(html_border_color, copy_of_parent->ocelot_grid_cell_border_color.toUtf8());
    strcpy(html_color, copy_of_parent->ocelot_grid_text_color.toUtf8());
    strcpy(html_background_color, copy_of_parent->ocelot_grid_background_color.toUtf8());
    strcpy(html_header_background_color, copy_of_parent->ocelot_grid_header_background_color.toUtf8());
    strcpy(html_font_family, copy_of_parent->ocelot_grid_font_family.toUtf8());
    strcpy(html_font_size, copy_of_parent->ocelot_grid_font_size.toUtf8());
    strcpy(html_font_style, copy_of_parent->ocelot_grid_font_style.toUtf8());
    strcpy(html_font_weight, copy_of_parent->ocelot_grid_font_weight.toUtf8());
    strcpy(html_outer_color, copy_of_parent->ocelot_grid_outer_color.toUtf8());
    html_border_size= copy_of_parent->ocelot_grid_cell_border_size.toInt();
    sprintf(ocelot_grid_table_start, "<head><style type=text/css>"
            " th {"
            "border-color: %s; "
            "border-style: solid; "
            "padding-left: 1px; "
            "padding-right: 1px; "
            "color: %s; "
            "background-color: %s; "
            "font-family: %s; "
            "font-size: %spx; "
            "font-style: %s; "
            "font-weight: %s}"
            " td {"
            "border-color: %s; "
            "border-style: solid; "
            "padding-left: 1px; "
            "padding-right: 1px; "
            "color: %s; "
            "background-color: %s; "
            "font-family: %s; "
            "font-size: %spx; "
            "font-style: %s; "
            "font-weight: %s}"
            "</style></head><BODY><TABLE BORDER=%d>",
            html_border_color,
            html_color,
            html_header_background_color,
            html_font_family,
            html_font_size,
            html_font_style,
            html_font_weight,
            html_border_color,
            html_color,
            html_background_color,
            html_font_family,
            html_font_size,
            html_font_style,
            html_font_weight,
            html_border_size);
    strcpy(ocelot_grid_header_row_start, "<TR>");
    strcpy(ocelot_grid_header_row_end, "</TR>");
    strcpy(ocelot_grid_header_numeric_column_start, "<TH>");
    strcpy(ocelot_grid_header_numeric_column_end, "</TH>");
    strcpy(ocelot_grid_header_char_column_start, "<TH>");
    strcpy(ocelot_grid_header_char_column_end, "</TH>");
    strcpy(ocelot_grid_detail_row_start, "<TR>");
    strcpy(ocelot_grid_detail_row_end, "</TR>");
    strcpy(ocelot_grid_detail_numeric_column_start, "<TD align=\"right\">");
    strcpy(ocelot_grid_detail_numeric_column_end,"</TD>");
    strcpy(ocelot_grid_detail_char_column_start, "<TD>");
    strcpy(ocelot_grid_detail_char_column_end , "</TD>");
    strcpy(ocelot_grid_table_end, "</TABLE></BODY></HTML>");
  }
  else if (copy_of_ocelot_batch != 0)
  {
    strcpy(ocelot_grid_table_start, "");
    strcpy(ocelot_grid_header_row_start, "");
    strcpy(ocelot_grid_header_row_end, "\n");
    strcpy(ocelot_grid_header_numeric_column_start, "");
    strcpy(ocelot_grid_header_numeric_column_end, "\t");
    strcpy(ocelot_grid_header_char_column_start, "");
    strcpy(ocelot_grid_header_char_column_end, "\t");
    strcpy(ocelot_grid_detail_row_start, "");
    strcpy(ocelot_grid_detail_row_end, "\n");
    strcpy(ocelot_grid_detail_numeric_column_start, "");
    strcpy(ocelot_grid_detail_numeric_column_end, "\t");
    strcpy(ocelot_grid_detail_char_column_start, "");
    strcpy(ocelot_grid_detail_char_column_end , "\t");
    strcpy(ocelot_grid_table_end, "");
  }
  else /* copy_of_ocelot_xml != 0 */
  {
    strcpy(ocelot_grid_table_start, "<?xml version=\"1.0\"?>"
                                    "<resultset statement=\"");
    strcat(ocelot_grid_table_start, copy_of_parent->query_utf16_copy.toUtf8());
    strcat(ocelot_grid_table_start, "\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">");
    strcpy(ocelot_grid_header_row_start, "<row>");
    strcpy(ocelot_grid_header_row_end, "</row>");
    strcpy(ocelot_grid_header_numeric_column_start, "<field name=\"");
    strcpy(ocelot_grid_header_numeric_column_end, "</field>");
    strcpy(ocelot_grid_header_char_column_start, "<field name=\"");
    strcpy(ocelot_grid_header_char_column_end, "</field>");
    strcpy(ocelot_grid_detail_row_start, "<row>");
    strcpy(ocelot_grid_detail_row_end, "</row>");
    strcpy(ocelot_grid_detail_numeric_column_start, "<field name=\"");
    strcpy(ocelot_grid_detail_numeric_column_end, "</field>");
    strcpy(ocelot_grid_detail_char_column_start, "<field name=\"");
    strcpy(ocelot_grid_detail_char_column_end , "</field>");
    strcpy(ocelot_grid_table_end, "</resultset>");
  }
//  hide(); /* todo: I'm not sure whether this has a point while the kludges exist */
  //batch_text_edit->clear(); /* I'm sure this has a point while the kludges exist */

  grid_vertical_scroll_bar->setVisible(false);

  if ((result_row_count == 0) || (result_column_count == 0))
  {
    batch_text_edit->clear();
    batch_text_edit->insertPlainText("row_count == 0 or column_count == 0");
//    this->show();
//    client->show();
    return;
  }

  if (copy_of_ocelot_html == 0)
    batch_text_edit->setStyleSheet(copy_of_parent->ocelot_grid_style_string);
  /* Todo: next four lines could be done during the initial setup (well, not any more, because of the kludges) */
  batch_text_edit->setReadOnly(true);
  batch_text_edit->setAlignment(Qt::AlignTop | Qt::AlignLeft);
  batch_text_edit->setWordWrapMode(QTextOption::NoWrap);
  batch_text_edit->setFrameStyle(QFrame::NoFrame);
  long unsigned int tmp_xrow;
  char *pointer= result_set_copy_rows[0];
  unsigned int v_length, f_length;
  char *result_field_names_pointer;

  /*
    Todo: Adjust calculation for numeric columns, for escapes, for hex.
          It ought to be possible to do a single non-looping calculation.
 */
  unsigned int tmp_size= sizeof(char);

  if ((ocelot_result_grid_column_names_copy == 1)
   && (copy_of_ocelot_xml == 0))
  {
    tmp_size+= strlen(ocelot_grid_header_row_start);
    result_field_names_pointer= &result_field_names[0];
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      tmp_size+= strlen(ocelot_grid_header_char_column_start);
      memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
      tmp_size+= v_length;
      result_field_names_pointer+= v_length + sizeof(unsigned int);
      tmp_size+= strlen(ocelot_grid_header_char_column_end);
    }
    tmp_size+= strlen(ocelot_grid_header_row_end);
  }

  tmp_size+= strlen(ocelot_grid_table_start);
  for (tmp_xrow= 0; tmp_xrow < result_row_count; ++tmp_xrow)
  {
    result_field_names_pointer= &result_field_names[0];
    tmp_size+= strlen(ocelot_grid_detail_row_start);
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      if ((result_field_flags[i] & NUM_FLAG) != 0)
        tmp_size+= strlen(ocelot_grid_detail_numeric_column_start);
      else
        tmp_size+= strlen(ocelot_grid_detail_char_column_start);
      if (copy_of_ocelot_xml != 0)
      {
        memcpy(&f_length, result_field_names_pointer, sizeof(unsigned int));
        tmp_size+= f_length + 2;
        result_field_names_pointer+= f_length + sizeof(unsigned int);
      }
      memcpy(&v_length, pointer, sizeof(unsigned int));
      pointer+= sizeof(unsigned int) + sizeof(char);
      /* Todo: we only need v_length*1 unless it's img or hex or escaped */
      tmp_size+= v_length * 2;
      tmp_size+= strlen(ocelot_grid_detail_char_column_end);
      pointer+= v_length;
    }
    tmp_size+= strlen(ocelot_grid_detail_row_end);
  }
  tmp_size+= strlen(ocelot_grid_table_end);
  char *tmp;

  tmp= new char[tmp_size];
  char *tmp_pointer= &tmp[0];

  strcpy(tmp_pointer, ocelot_grid_table_start);
  tmp_pointer+= strlen(ocelot_grid_table_start);

  if ((ocelot_result_grid_column_names_copy == 1)
   && (copy_of_ocelot_xml == 0))
  {
    char *result_field_names_pointer;
    result_field_names_pointer= &result_field_names[0];
    strcpy(tmp_pointer, ocelot_grid_header_row_start);
    tmp_pointer+= strlen(ocelot_grid_header_row_start);
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      strcpy(tmp_pointer, ocelot_grid_header_char_column_start);
      tmp_pointer+= strlen(ocelot_grid_header_char_column_start);
      memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
      result_field_names_pointer+= sizeof(unsigned int);
      memcpy(tmp_pointer, result_field_names_pointer, v_length);
      tmp_pointer+= v_length;
      strcpy(tmp_pointer, ocelot_grid_header_char_column_end);
      tmp_pointer+= strlen(ocelot_grid_header_char_column_end);
      result_field_names_pointer+= v_length;
    }
    strcpy(tmp_pointer, ocelot_grid_header_row_end);
    tmp_pointer+= strlen(ocelot_grid_header_row_end);
  }
  pointer= result_set_copy_rows[0];
  for (tmp_xrow= 0; tmp_xrow < result_row_count; ++tmp_xrow)
  {
    result_field_names_pointer= &result_field_names[0];
    strcpy(tmp_pointer, ocelot_grid_detail_row_start);
    tmp_pointer+= strlen(ocelot_grid_detail_row_start);
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      if ((result_field_flags[i] & NUM_FLAG) != 0)
      {
        strcpy(tmp_pointer, ocelot_grid_detail_numeric_column_start);
        tmp_pointer+= strlen(ocelot_grid_detail_numeric_column_start);
      }
      else
      {
        strcpy(tmp_pointer, ocelot_grid_detail_char_column_start);
        tmp_pointer+= strlen(ocelot_grid_detail_char_column_start);
      }
      if (copy_of_ocelot_xml != 0)
      {
        memcpy(&f_length, result_field_names_pointer, sizeof(unsigned int));
        result_field_names_pointer+= sizeof(unsigned int);
        memcpy(tmp_pointer, result_field_names_pointer, f_length);
        tmp_pointer+= f_length;
        result_field_names_pointer+= f_length;
        strcpy(tmp_pointer, "\">");
        tmp_pointer+= 2;
      }
      memcpy(&v_length, pointer, sizeof(unsigned int));
      pointer+= sizeof(unsigned int) + sizeof(char);
      bool is_image_written= false;
      if ((copy_of_ocelot_html != 0) && (is_image(i) == true))
      {
        char img_type[4];
        set_img_type(pointer, v_length, img_type); /* so img_type = "" or "png" or "jpg" or "gif" */
        if (strcmp(img_type,"") != 0)
        {
          char *base64_tmp;
          base64_tmp= new char[(v_length * 4) / 3 + 16];
          QByteArray data= QByteArray::fromRawData(pointer, v_length);
          strcpy(base64_tmp, data.toBase64());
          memcpy(tmp_pointer, "<img src=\"data:image/", 21);
          tmp_pointer+= 21;
          memcpy(tmp_pointer, img_type, 3);
          tmp_pointer+= 3;
          memcpy(tmp_pointer, ";base64,", 8);
          tmp_pointer+= 8;
          memcpy(tmp_pointer, base64_tmp, strlen(base64_tmp));
          tmp_pointer+= strlen(base64_tmp);
          memcpy(tmp_pointer, "\"/>", 3);
          tmp_pointer+= 3;
          delete base64_tmp;
          is_image_written= true;
        }
      }
      if (is_image_written == false)
      {
        memcpy(tmp_pointer, pointer, v_length);
        tmp_pointer+= v_length;
      }
      strcpy(tmp_pointer, ocelot_grid_detail_char_column_end);
      tmp_pointer+= strlen(ocelot_grid_detail_char_column_end);
      pointer+= v_length;
    }
    strcpy(tmp_pointer, ocelot_grid_detail_row_end);
    tmp_pointer+= strlen(ocelot_grid_detail_row_end);
  }
  strcpy(tmp_pointer, ocelot_grid_table_end);
  tmp_pointer+= strlen(ocelot_grid_table_end);
  *tmp_pointer= '\0';

  /* Todo: This must be wrong. Surely ocelot_html is off if we're doing display_batch. */
  if ((copy_of_ocelot_html != 0) && (copy_of_ocelot_raw == 0))
  {
    batch_text_edit->setHtml(tmp);
  }
  else
  {
    batch_text_edit->insertPlainText(tmp);
  }
  batch_text_edit->moveCursor(QTextCursor::Start);
  batch_text_edit->ensureCursorVisible();

//  show();
//  client->show();
  delete [] tmp;
  return;
}


/*
  display(due_to)
  ---------------
  After fillup() we can do layout and fill cells or just print out, depending on user options.
  If due_to = 0, this is immediately after fillup().
  If due_to = 1, this is coming from a change_result_display choice
  If due_to = 2, this is for resize_or_font_change
  Todo: We get here twice because right after fillup() we call display(), but then
        resize_or_font_change() calls display() again.
        This is invisible because resize_or_font_change calls
        something first (?), but it's a silly waste of time.
        However, maybe it only happens for the first time I select.
  Todo: Bug:
        (start program with ocelot_batch == ocelot_html == 0)
        select * from information_schema.tables limit 10;
        SET ocelot_html = 1;
        select * from information_schema.tables limit 10;
        SET ocelot_html = 0;
        select * from information_schema.tables limit 10;
        the display is obscured, that is why in display() I say
        html_text_edit->hide();
        but why do I need it, if I've removed it from layout?
  Todo: Allow switch from one output to another. This does require
        having fillup() completely separate from display(), that part is now done.
        setSizeConstraint and setVerticalScrollBarPolicy should be
        reset if we change to non-batch display.
  Re copy_of items
    The idea is that copy_of variables will store what was there when we called with 0 or 1,
    therefore when we call with 2 the value will be what we had when we called with 0 or 1
    rather than something that might have been set later.
    Todo: ocelot_vertical_copy is a pointless duplication of copy_of_ocelot_vertical?
    Todo: ocelot_result_grid_column_names_copy is a pointless duplication of copy_of_ocelot_result_grid_column_names?
  Re display_html
    We should set the copy_of items even if we will call display_html etc., because we might change
    how result_display_html() works. But there are other items that we set at the start that,
    I think, we don't need to set since display_html() won't use them.
*/
void display(int due_to,
             unsigned short ocelot_vertical,
             unsigned short int ocelot_batch,
             unsigned short int ocelot_html,
             unsigned short int ocelot_raw,
             unsigned short int ocelot_xml,
             unsigned short ocelot_result_grid_column_names)
{
  (void)due_to;
#ifdef OLD_STUFF
  /* Some child widgets e.g. text_edit_frames[n] must not be visible because they'd receive paint events too soon. */
  hide();
#endif
//  if ((due_to == 0) || (due_to == 1))
  {
    display_garbage_collect();
    copy_result_to_gridx();
    /* Todo: no more grid_result_row_count, and copy_result_to_gridx already
       said what gridx_row_count is. */
    if (ocelot_vertical == 0) grid_result_row_count= gridx_row_count + 1;
    else grid_result_row_count= result_row_count * result_column_count;
    if (ocelot_vertical == 0)
    {
      gridx_row_count= grid_result_row_count + 1;
    }
    if (ocelot_vertical != 0)
    {
      gridx_row_count= result_row_count * result_column_count;
      gridx_column_count= 1;
      if (ocelot_result_grid_column_names != 0) ++gridx_column_count;
    }
    grid_column_widths= new unsigned int[gridx_column_count];
    grid_column_heights= new unsigned int[gridx_column_count];
    grid_column_dbms_sources= new unsigned char[gridx_column_count];
    copy_of_ocelot_vertical= ocelot_vertical;
    copy_of_ocelot_result_grid_column_names= ocelot_result_grid_column_names;
    copy_of_ocelot_batch= ocelot_batch;
    copy_of_ocelot_html= ocelot_html;
    copy_of_ocelot_raw= ocelot_raw;
    copy_of_ocelot_xml= ocelot_xml;
    ocelot_vertical_copy= ocelot_vertical;
    ocelot_result_grid_column_names_copy= ocelot_result_grid_column_names;
  }
  vertical_scroll_bar_initialize();

  if ((copy_of_ocelot_batch != 0)
   || (copy_of_ocelot_xml != 0)
   || (copy_of_ocelot_raw != 0))
  {
    display_batch();
  }
  else
  /* Since it's not ocelot_batch or ocelot_xml it must be ocelot_html */
  {
    grid_vertical_scroll_bar_value= -1; /* todo: check: is this alread in vertical_scroll_bar_initialize? */
    focus_result_row_number= focus_column_number= -1; /* i.e. no cell is in focus */
    prepare_for_display_html();
    display_html(0, 0);
  }
  return;

#ifdef OLD_STUFF

  grid_main_layout->setSizeConstraint(QLayout::SetFixedSize);  /* This ensures the grid columns have no spaces between them */
//  html_text_edit->hide();

  long unsigned int xrow;
  unsigned int xcol;
  MainWindow *parent= copy_of_parent;
  int connections_dbms= copy_of_connections_dbms;

  is_paintable= 0;

  ocelot_grid_text_color= parent->ocelot_grid_text_color;
  ocelot_grid_background_color= parent->ocelot_grid_background_color;
  /* setting_ocelot_grid_cell_drag_line_size_as_int= parent->ocelot_grid_cell_drag_line_size.toInt(); */
  /* ocelot_grid_cell_drag_line_color= parent->ocelot_grid_cell_drag_line_color; */

  //  grid_scroll_area= new QScrollArea(this);                                    /* Todo: see why parent can't be client */

  //  grid_scroll_area->verticalScrollBar()->setMaximum(gridx_row_count);
  //  grid_scroll_area->verticalScrollBar()->setSingleStep(1);
  //  grid_scroll_area->verticalScrollBar()->setPageStep(gridx_row_count / 10);    /* Todo; check if this could become 0 */
  grid_vertical_scroll_bar_value= -1;

  {
    unsigned int minimum_number_of_cells;
    minimum_number_of_cells= result_grid_widget_max_height_in_lines * gridx_column_count;
    pools_resize(row_pool_size, result_grid_widget_max_height_in_lines, cell_pool_size, minimum_number_of_cells);
    if (row_pool_size < result_grid_widget_max_height_in_lines) row_pool_size= result_grid_widget_max_height_in_lines;
    if (cell_pool_size < minimum_number_of_cells) cell_pool_size= minimum_number_of_cells;
  }
  /*
    Calculate desired width and height based on parent width and height.
     Desired max width in chars = width when created - width of scroll bar.
     Max height in lines = height when created - (height of scroll bar + height of header) / 4. minimum = 1.
     Todo: We're dividing height-when-created by 3 because we assume statement+history widgets are there, maybe they're not.
     Todo: max height could be greater if row count < 4, or maybe it should be user-settable.
     Todo: grid_vertical_scroll_bar->width() failed so I just guessed that I should subtract 3 char widths.
  */

  /* Todo: since grid_column_size_calc() recalculates max_height_of_a_char, don't bother with this. */

  QFont *pointer_to_font;
  pointer_to_font= &result_grid_font;
  QFontMetrics mm= QFontMetrics(*pointer_to_font);
  /* Todo: figure out why this says parent->width() rather than this->width() -- maybe "this" has no width yet? */
  ocelot_grid_max_desired_width_in_pixels= (parent->width() - (mm.boundingRect('W').width() * MIN_WIDTH_IN_CHARS));
  {
    /*
      Try to ensure we can fit at least header (if there is a header) plus one row.
      So there's a maximum number of lines per row.
      We assume (border height + horizontal scroll bar height) < 11 (todo: calculate them).
      We assume result grid height = height of main window / 3 (todo: calculate it).
    */
    int result_grid_height= (parent->height() / 3) - 11;
    int line_height= mm.lineSpacing();
    if ((copy_of_ocelot_result_grid_column_names == 1) && (copy_of_ocelot_vertical == 0))
        result_grid_height-= line_height;
    ocelot_grid_max_column_height_in_lines= result_grid_height / line_height;
    if (ocelot_grid_max_column_height_in_lines < 1) ocelot_grid_max_column_height_in_lines= 1;
  }

  //setting_ocelot_grid_cell_drag_line_size_as_int= copy_of_parent->ocelot_grid_cell_drag_line_size.toInt();
//  ocelot_grid_cell_drag_line_color= copy_of_parent->ocelot_grid_cell_drag_line_color;
  //setting_ocelot_grid_cell_border_size_as_int= copy_of_parent->ocelot_grid_cell_border_size.toInt();

  /*
    Making changes for all in the cell pool.
    Todo: This should only be done for new cells, or if something has changed e.g. font, drag line size.
          That's actually a bug, because the drag line color doesn't change immediately.
    todo: why the whole pool rather than just result-row_count + 1?
  */
  QFont *pointer_to_font_2;
  pointer_to_font_2= &result_grid_font;
  QFontMetrics fm= QFontMetrics(*pointer_to_font_2);
  /* Todo: see whether this loop could be shifted somewhere so it's not repeated for every fillup */
  for (xrow= 0; (xrow < gridx_row_count) && (xrow < result_grid_widget_max_height_in_lines); ++xrow)
  {
    for (unsigned int column_number= 0; column_number < gridx_column_count; ++column_number)
    {
      int ki= xrow * gridx_column_count + column_number;
      text_edit_widgets[ki]->setMinimumWidth(fm.boundingRect("W").width() * MIN_WIDTH_IN_CHARS);
      /* This line was replaced in December 2015 */
      //text_edit_widgets[ki]->setMinimumHeight(fm.height() * 2);
      text_edit_widgets[ki]->setMinimumHeight(fm.lineSpacing());
      text_edit_layouts[ki]->setContentsMargins(QMargins(0, 0, setting_ocelot_grid_cell_drag_line_size_as_int, setting_ocelot_grid_cell_drag_line_size_as_int));
      /*
        Change the color of the frame. Be specific that it's TextEditFrame, because you don't want the
        children e.g. the QTextEdit to inherit the color. TextEditFrame is a custom widget and therefore
        setStyleSheet is troublesome for most settings, but background-color should be okay, see
        http://stackoverflow.com/questions/7276330/qt-stylesheet-for-custom-widget.
      */

      //text_edit_frames[ki]->setStyleSheet(frame_color_setting);

      /* Todo: remove this line and test whether anything goes wrong. */
      text_edit_frames[ki]->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);   /* This doesn't seem to do anything */

      /* Todo: I'm not sure exactly where the following three lines should go. Consider moving them. */
      /*       I'm not sure they have any effect. I don't know why drag line and scroll bar width aren't added. */
      /* border_size and minimum_width and minimum_height are used by mouseMoveEvent */
      text_edit_frames[ki]->border_size= 10 + border_size;    /* Todo: should just be border_size!! */
      text_edit_frames[ki]->minimum_width= fm.boundingRect("W").width() * MIN_WIDTH_IN_CHARS + border_size;
      /* I used to say "fm.height() * 2 + border_size", but don't know why. That seems like too much. */
      text_edit_frames[ki]->minimum_height= fm.lineSpacing() + border_size * 2 + setting_ocelot_grid_cell_drag_line_size_as_int;
    }
  }

  /*
    For each cell:
      Set cell type = detail or header, depending on is_vertical + whether it's first row
      If header: indicate where header text is.
    Todo: this is just assuming top line is header, which is wrong now.
  */
  char *field_names_pointer;
  for (xrow= 0; (xrow < grid_result_row_count) && (xrow < result_grid_widget_max_height_in_lines); ++xrow)
  {
    field_names_pointer= gridx_field_names; /* unnecessary reset if copy_of_ocelot_vertical = 0 */
    for (unsigned int column_number= 0; column_number < gridx_column_count; ++column_number)
    {
      int ki= xrow * gridx_column_count + column_number;
      bool is_header= false;
      if (copy_of_ocelot_vertical != 0)
      {
        if (copy_of_ocelot_result_grid_column_names != 0)
        {
          if (column_number == 0) is_header= true;
        }
      }
      if ((copy_of_ocelot_vertical == 0) && (xrow == 0)) is_header= true;
      if (is_header == true)
      {
        memcpy(&(text_edit_frames[ki]->content_length), field_names_pointer, sizeof(unsigned int));
        field_names_pointer+= sizeof(unsigned int);
        text_edit_frames[ki]->content_pointer= field_names_pointer;
        field_names_pointer+= text_edit_frames[ki]->content_length;
        text_edit_frames[ki]->content_field_value_flags= 0;
        text_edit_frames[ki]->is_retrieved_flag= false;
        text_edit_frames[ki]->ancestor_grid_column_number= column_number;
        text_edit_frames[ki]->ancestor_grid_result_row_number= -1;          /* probably unnecessary */
        if (text_edit_frames[ki]->cell_type != TEXTEDITFRAME_CELL_TYPE_HEADER)
        {
          text_edit_frames[ki]->cell_type= TEXTEDITFRAME_CELL_TYPE_HEADER;
          text_edit_frames[ki]->is_style_sheet_set_flag= false;
        }
        text_edit_frames[ki]->is_image_flag= false;
        set_height(ki, text_edit_frames[ki]->width());
      }
      else
      {
        if (is_extra_rule_1(column_number) == true)
        {
          if (text_edit_frames[ki]->cell_type != TEXTEDITFRAME_CELL_TYPE_DETAIL_EXTRA_RULE_1)
          {
            text_edit_frames[ki]->cell_type= TEXTEDITFRAME_CELL_TYPE_DETAIL_EXTRA_RULE_1;
            text_edit_frames[ki]->is_style_sheet_set_flag= false;
          }
        }
        else
        {
          if (text_edit_frames[ki]->cell_type != TEXTEDITFRAME_CELL_TYPE_DETAIL)
          {
            text_edit_frames[ki]->cell_type= TEXTEDITFRAME_CELL_TYPE_DETAIL;
            text_edit_frames[ki]->is_style_sheet_set_flag= false;
          }
        }
      }
    }
  }
  //if (copy_of_ocelot_vertical != 0)
  //  grid_column_size_calc(setting_ocelot_grid_cell_border_size_as_int,
  //                      setting_ocelot_grid_cell_drag_line_size_as_int,
  //                      0); /* get grid_column_widths[] and grid_column_heights[] */

  if (copy_of_ocelot_vertical != 0)
  {
    /* TODO: Make sure considerations for horizontal are all considered for vertical. */
    /* We'll have to figure out the alignment etc. each time we get ready to display */
    unsigned int grid_row_number, text_edit_frame_index;
    for (grid_row_number= 0, text_edit_frame_index= 0;
         grid_row_number < result_grid_widget_max_height_in_lines;
         ++grid_row_number)
    {
      if (grid_row_number >= gridx_row_count) break;
      for (unsigned int mi= 0; mi < gridx_column_count; ++mi)
      {
        /* todo: test whether we really need to show always */
        text_edit_frames[text_edit_frame_index]->show();
        grid_row_layouts[grid_row_number]->addWidget(text_edit_frames[text_edit_frame_index], 0, Qt::AlignTop | Qt::AlignLeft);
        ++text_edit_frame_index;
      }
    }
    /* How many text_edit_frame widgets are we actually using? This assumes number-of-columns-per-row is fixed. */
    max_text_edit_frames_count= text_edit_frame_index;
  }
  else max_text_edit_frames_count= (grid_result_row_count) * gridx_column_count;

  /*
    grid detail rows
    While we're passing through, we also get max column lengths (in characters).
    Todo: Take into account: whether there were any nulls.
    Moved fill_detail_widgets() down from here 2020-06-25
    ... No, instead we call it twice.
    Todo: Do only what's necessary here! Don't repeat all fill_detail_widgets()!
    Todo: Decide whether is_paintable should stay on a while longer!
  */
  fill_detail_widgets(0, connections_dbms);                                        /* details */

  grid_vertical_scroll_bar_value= 0;

  /*
    We'll use the automatic scroll bar for small result sets,
    we'll use our own scroll bar for large ones.
    setValue() will cause eventfilter to call vertical_scroll_bar_event().
    But grid_vertical_scroll_bar_value == 0 so nothing will happen except slider movement.
    This section was changed on 2016-04-01.
  */
  if (grid_result_row_count <= result_grid_widget_max_height_in_lines)
  {
    grid_scroll_area->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    grid_vertical_scroll_bar->setVisible(false);
    grid_scroll_area->verticalScrollBar()->setValue(0);
  }
  else
  {
    grid_scroll_area->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    grid_vertical_scroll_bar->setVisible(true);
    grid_vertical_scroll_bar->setValue(0);
  }

  is_paintable= 1;
  if (copy_of_ocelot_vertical == 0)
  grid_column_size_calc(setting_ocelot_grid_cell_border_size_as_int,
                        setting_ocelot_grid_cell_drag_line_size_as_int,
                        ocelot_result_grid_column_names_copy,
                        connections_dbms); /* get grid_column_widths[] and grid_column_heights[] */

  /*
    grid_actual_grid_height_in_rows = # of rows that are actually showable at a time,
    = lesser of (grid_max_grid_height_in_lines/grid_max_row_height_in_lines, # of rows in result set + 1)
  */
  //grid_actual_grid_height_in_rows= gridx_row_count;
  //if (grid_actual_grid_height_in_rows > gridx_row_count + 1) grid_actual_grid_height_in_rows= gridx_row_count + 1;

  /* Put the QTextEdit widgets in a layout. Remember grid row 0 is for the header.
    Horizontal (default):
      Each row is [column_count] cells within one QHBoxLayout (grid_row_layout) within one widget.
    Vertical (if --vertical or \G):
      Each row is 2 cells within one QHBoxLayout (grid_row_layout) within one widget.
    grid_row_layout->setSizeConstraint(QLayout::SetMaximumSize) prevents gaps from forming during shrink.
    There's a "border", actually the visible part of TextEditFrame, on the cell's right.
    Drag it left to shrink the cell, drag it right to expand the cell.
    We do not resize cells on the left or right of the to-be-dragged cell, so expanding causes total row width to expand,
    possibly going beyond the original desired maximum width, possibly causing a horizontal scroll bar to appear.
    grid_row_layout->setSpacing(0) means the only thing separating cells is the "border".
  */
  if (copy_of_ocelot_vertical == 0)
  {
    for (long unsigned int xrow= 0; (xrow < grid_result_row_count) && (xrow < result_grid_widget_max_height_in_lines); ++xrow)
    {
      for (xcol= 0; xcol < gridx_column_count; ++xcol)
      {
        TextEditWidget *cell_text_edit_widget= text_edit_widgets[xrow * gridx_column_count + xcol];
        if ((xrow > 0) && (dbms_get_field_flag(xcol, connections_dbms) & NUM_FLAG)) text_align(cell_text_edit_widget, Qt::AlignRight);
        else text_align(cell_text_edit_widget, Qt::AlignLeft);
        if (text_edit_frames[xrow * gridx_column_count + xcol]->cell_type != TEXTEDITFRAME_CELL_TYPE_HEADER)
        {
          if (is_image(xcol) == true)
          {
            text_edit_frames[xrow * gridx_column_count + xcol]->is_image_flag= true;
          }
          else text_edit_frames[xrow * gridx_column_count + xcol]->is_image_flag= false;
        }
        /* Height border size = 1 due to setStyleSheet earlier; right border size is passed */
        if (xrow == 0)
        {
          int header_height= max_height_of_a_char
                           + setting_ocelot_grid_cell_border_size_as_int * 2
                           + setting_ocelot_grid_cell_drag_line_size_as_int;
          frame_resize(xrow * gridx_column_count + xcol, xcol, grid_column_widths[xcol], header_height);
        }
        else
        {
          frame_resize(xrow * gridx_column_count + xcol,  xcol, grid_column_widths[xcol], grid_column_heights[xcol]);
        }
        /* todo: test whether we really need to show always */
        text_edit_frames[xrow * gridx_column_count + xcol]->show();
        grid_row_layouts[xrow]->addWidget(text_edit_frames[xrow * gridx_column_count + xcol], 0, Qt::AlignTop | Qt::AlignLeft);
      }
    }
  }
  /* Moved fill_detail_widgets() down to here 2020-06-25 */
  fill_detail_widgets(0, connections_dbms);
  //  grid_main_layout->setSizeConstraint(QLayout::SetFixedSize);  /* This ensures the grid columns have no spaces between them */

  for (long unsigned int xrow= 0; (xrow < grid_result_row_count) && (xrow < result_grid_widget_max_height_in_lines); ++xrow)
  {
//    grid_row_widgets[xrow]->setLayout(grid_row_layouts[xrow]);
    grid_main_layout->addWidget(grid_row_widgets[xrow], 0, Qt::AlignTop | Qt::AlignLeft);
  }

//  client->setLayout(grid_main_layout);

  /* This doesn't work. Done too early? */
  /* client->setStyleSheet(copy_of_parent->ocelot_grid_style_string); */
  /*
    Before client->show(), client->height()=30 and height()=30.
    After client->show(), client->height()=something big e.g. 1098 and height()=30.
    But client = the grid itself rather than the result grid widget?
    Without client->show(), grid becomes blank after a font change.
    TODO: now grid becomes blank after a font change anyway! So I have to say show().
  */

  client->show();

  show();

//  grid_scroll_area->setWidget(client);
//  grid_scroll_area->setWidgetResizable(true);              /* Without this, the QTextEdit widget heights won't change */

  /* area->horizontalScrollBar()->setSingleStep(client->width() / 24); */ /* single-stepping seems pointless */
#endif
}

#ifdef OLD_STUFF
/*
  frame_resize() == Setting text_edit_frames[n] size.
  Called from: display() if vertical == 0 (initial),
               set_alignment_and_height() if vertical != 0 (always),
  Re scroll bar: we make most of the initial size calculations with the
                 assumption that scroll bar will be off, as it usually
                 will be, and since otherwise grid_column_size_calc()
                 becomes tremendously complicated. Here, if you know
                 the contents will fit, turn off the scroll bar.
  I think the width is of the frame; we want the width of the widget.
  Re: setVerticalScrollBarPolicy(). set_height() calls it too,
      so I think we only need to call it when we pull on a drag line.
*/
void frame_resize(int ki, int grid_col, int width, int height)
{
  (void) (grid_col);
  //unsigned int text_edit_width= width -
  //        (setting_ocelot_grid_cell_drag_line_size_as_int
  //         + setting_ocelot_grid_cell_border_size_as_int * 2);
  //unsigned int text_edit_height= height -
  //        (setting_ocelot_grid_cell_drag_line_size_as_int
  //         + setting_ocelot_grid_cell_border_size_as_int * 2);
  //unsigned int number_of_characters_per_line= text_edit_width / setting_max_width_of_a_char;
  //unsigned int number_of_lines= text_edit_height / max_height_of_a_char;
  //unsigned int number_of_characters_in_cell= number_of_characters_per_line
  //                                      * number_of_lines;
  /* TEST!! Remove temporarily! It's in set_height() now! */
  //if (number_of_characters_in_cell < gridx_max_column_widths[grid_col])
  //  text_edit_widgets[ki]->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
  //else
  //  text_edit_widgets[ki]->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
  text_edit_frames[ki]->setFixedSize(width, height);
  /* Todo: test if following 2 lines are redundant since setFixedSize does the job. */
  //text_edit_frames[ki]->setMaximumHeight(height);
  //text_edit_frames[ki]->setMinimumHeight(height);
}
#endif

#ifdef OLD_STUFF
/*
  Called from: TextEditFrame::mouseMoveEvent() if right drag line moved, so probable width change
  The call to get_column_height_in_pixels() is just so that vertical scroll bar might go on|off.
*/
void frame_resize_for_drag_right(int ki, int grid_col, int width, int height)
{
  get_column_height_in_pixels(ki, width, height);
  frame_resize(ki, grid_col, width, height);
}

/*
  Called from: TextEditFrame::mouseMoveEvent() if bottom drag line moved, so probable height change
  Unlike set_height(), we might not stop at the usual maximum height because we know the widget fits on the screen.
  If vertical is on, passed xrow will be 0 but pay no attention.
  todo: This is called for all visible rows -- but why? Why not just the row that the frame is in?
  todo: This changes grid_row_widgets so maybe other columns in the row will be truncated without a scroll bar.
  todo: It should be possible to change header height too but that is only working if vertical is on.
  todo: Change is not persistent, if you scroll the result set so row disappears, then come back, it's original height.
*/
void frame_resize_for_drag_bottom(long int xrow, int ki, int grid_col, int width, int height)
{
  (void) (grid_col);
  get_column_height_in_pixels(ki, width, height);
  if (copy_of_ocelot_vertical == 0) grid_row_widgets[xrow]->setFixedHeight(height);
  text_edit_frames[ki]->setFixedHeight(height);
}
#endif

/*
  The border color must differ from all background colors because mouseMoveEvent() finds column boundaries
  by looking for color changes.
  Todo: Make the difference smaller by adding or subtracting 1 at a time from final hex digit.
*/
QString get_border_color()
{
  QString tmp_border_color= copy_of_parent->ocelot_grid_cell_border_color;
  int i= 1;
  while ((tmp_border_color == copy_of_parent->ocelot_grid_background_color)
      || (tmp_border_color == copy_of_parent->ocelot_grid_header_background_color))
  {
    tmp_border_color= tmp_border_color.left(tmp_border_color.size() - 1)
                    + QString::number(i);
    ++i;
  }
  return tmp_border_color;
}

/*
  Let's see whether we can output a thin image at the start of every row.
  Suppose that the header and every row has a 1x1 black-and-white 73-byte .png changed to base64.
  Warning: make sure you don't end with \0.
  This was working okay with "if (h < 0 h= 1;" and "width=0" but sometimes the result was blank or too high.
  Todo: We account for this when allocating tmp size but should record exact calculated size.
  Todo: If it works, we can use it to force height iff it's greater.
  Todo: instead of h= 5 we should say h= minimum height, whatever that is. Maybe FONT_SIZE_MIN.
*/
int thin_image(char *tmp_pointer, const char *th_or_td, int height)
{
  char output_string[256];
  int h= height;
  if (h < 0) h= 5;
  sprintf(output_string, "<%s width=0><img width=0 height=%d src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQAAAAA3bvkkAAAAEElEQVR4nGJgAQAAAP//AwAABgAFV7+r1AAAAABJRU5ErkJggg==\"/></%s>",
          th_or_td, h, th_or_td);
  if (h < 10) strcat(output_string, " "); /* We can overwrite so must be sure that size is always the same */
  if (h < 100) strcat(output_string, " ");
  if (h < 1000) strcat(output_string, " ");
  memcpy(tmp_pointer, output_string, strlen(output_string));
  return strlen(output_string);
}

/*
  For --batch, avoid normal grid display. Result won't go to history.
  For --html, avoid normal grid display.
              Result will go to history.
              For --html --raw, result is dumped so user sees the markup.
              --html overrides --batch, i.e. we look at html first
              images are done as data URIs if png|jpg|gif
  We say setReadOnly() so edit won't generate update statement.
  We pay attention to --column-names and (sometimes) --raw, as well.
  Todo: BUG: If you reconnect with file|connect, and use a different
        setting for batch or html or raw, display is garbage.
  Todo: SET ocelot_batch = x; should be possible.
        It would not change the current result grid.
  Todo: going directly to a file should be possible too
  Todo: check what happens if row data contains "\n"
  Todo: pay attention to --vertical
  Todo: Do what you do for other displays, e.g. check for null
  Todo: look for --raw, currently we're just assuming it's true
        + we don't need to multiply size by 2 if --raw is off (?)
        Escape ' " \ nul tab newline =  \' \" \\ \0 \t \n
  Todo: we can also support --xml, I don't know whether
        it overrides --batch or whether it complements it somehow.
        also csv and msgpack and json
        also "--like-mysql-client"
        or SET ocelot_grid_format = {'fancy'|'html'|'xml'|'csv'|etc.}
  Todo: Setting should be possible with the syntax that's used for
        INTO OUTFILE
  Todo: I was getting
        QTextOdfWriter: unsupported paragraph alignment;  QFlags(0x20)
        if ^A (select all), ^C (Copy) on a large output.
        Specifying "...Qt::AlignLeft" solved it.
        But it might be nice to write a bug report for the Qt folks.
  Todo: it would take less memory and possibly display quicker if
        I only output when necessary, i.e. when user scrolls
  Todo: check: does it do any good to hide() first?
  Todo: callback to a local Lua function prior to display, for each row
  Todo: allow row update. and, if there's a change in one mode, show
        the changed row when modes are switched
  Todo: xml statement="" and field name="" contents lack escaping.
  Todo: "<" wrecks the cell, we need character entities
  Todo: If you remove "html_text_edit->setWordWrapMode(QTextOption::NoWrap);"
        the effect is interesting, it might be a desirable option.
*/
/*
  Eventually ...
                                                    csv     --html    --batch  --xml
    ocelot_grid_table_start                                 </TABLE>           $statement
    ocelot_grid_header_row_start                            <TR>
    ocelot_grid_header_row_end                      \n      </TR>      \n
    ocelot_grid_header_numeric_column_start                 <TH>
    ocelot_grid_header_numeric_column_end           ,       </TH>      tab
    ocelot_grid_header_char_column_start            "       <TH>
    ocelot_grid_header_char_column_end              ",      </TH>      tab
    ocelot_grid_detail_row_start                                               <row>
    ocelot_grid_detail_row_end                                                 </row>
    ocelot_grid_detail_numeric_column_start                 <TD>[<div ...>]
    ocelot_grid_detail_numeric_column_end           ,       </TD>[</div>]
    ocelot_grid_detail_char_column_start            "       <TD>               <field name="$field">
    ocelot_grid_detail_char_column_end              ",      </TD>              </field>
    ocelot_grid_table_end                                   </TABLE>
    ... up to 9 characters + \0
*/
/*
  Todo: the html style sheet
  For html, instead of html_text_edit->setStyleSheet(), we want to
  put css specifications in the html header. Example:
  <HTML><head><style type=text/css>table, th, td {border-color: black; border-style: solid; color: red; background-color: blue}</style></HEAD><BODY><TABLE BORDER=5>.
  Although copy_of_parent->ocelot_grid_style_string) has all the
  necessary information, it's the wrong format. Use:
  color = copy_of_parent->ocelot_grid_text_color;
  background-color = copy_of_parent->ocelot_grid_background_color;
  copy_of_parent->ocelot_grid_focus_cell_background_color; (no) (this is unimplemented anyway)
  copy_of_parent->ocelot_grid_header_background_color;

  font-family = copy_of_parent->ocelot_grid_font_family;
  font-size = copy_of_parent->ocelot_grid_font_size;
  font-style = copy_of_parent->ocelot_grid_font_style;
  font-weight = copy_of_parent->ocelot_grid_font_weight;

  border-color = copy_of_parent->ocelot_grid_cell_border_color;
  copy_of_parent->ocelot_grid_cell_drag_line_color; (no)
  copy_of_parent->ocelot_grid_border_size; (no)
  copy_of_parent->ocelot_grid_cell_border_size;
  copy_of_parent->ocelot_grid_cell_drag_line_size;
  Todo: I think hide() is unnecessary because the caller has already done it.
  Re  new_grid_vertical_scroll_bar_value: compare fill_detail_widgets() usage.
  We cannot let html_border_color be the same as any background color.
  We must say border-style: solid; otherwise we get two-tone when border_size > 1
     (someday look up: is default = groove? ridge? inset? outset?)
*/

/* shared */
char ocelot_grid_table_start[1896]; /* TODO: this can be too small if many conditionals */
char ocelot_grid_header_row_start[32];
char ocelot_grid_header_row_end[32];
char ocelot_grid_header_numeric_column_start[32];
char ocelot_grid_header_numeric_column_end[32];
char ocelot_grid_header_char_column_start[32];
char ocelot_grid_header_char_column_end[32];
char ocelot_grid_detail_row_start[32];
char ocelot_grid_detail_row_end[32];
char ocelot_grid_detail_numeric_column_start[320];
char ocelot_grid_detail_numeric_column_end[32];
char ocelot_grid_detail_char_column_start[320];
char ocelot_grid_detail_char_column_end[32];
char ocelot_grid_table_end[320];

void prepare_for_display_html()
{
    /* I'm not sure where this should go. It's really only good for size-change */
    /* Maybe this doesn't work anyway */
    /* Todo: since grid_column_size_calc() recalculates max_height_of_a_char, don't bother with this. */
    MainWindow *parent= copy_of_parent;
    QFont *pointer_to_font;
    pointer_to_font= &result_grid_font;
    QFontMetrics mm= QFontMetrics(*pointer_to_font);
    /* Todo: figure out why this says parent->width() rather than this->width() -- maybe "this" has no width yet? */
    ocelot_grid_max_desired_width_in_pixels= (parent->width() - (mm.boundingRect('W').width() * MIN_WIDTH_IN_CHARS));
    {
      /*
        Try to ensure we can fit at least header (if there is a header) plus one row.
        So there's a maximum number of lines per row.
        We assume (border height + horizontal scroll bar height) < 11 (todo: calculate them).
        We assume result grid height = height of main window / 3 (todo: calculate it).
      */
      int result_grid_height= (parent->height() / 3) - 11;
      int line_height= mm.lineSpacing();
      if ((copy_of_ocelot_result_grid_column_names == 1) && (copy_of_ocelot_vertical == 0))
          result_grid_height-= line_height;
      ocelot_grid_max_column_height_in_lines= result_grid_height / line_height;
      if (ocelot_grid_max_column_height_in_lines < 1) ocelot_grid_max_column_height_in_lines= 1;
    }
    /* This is so we know desired column widths for deciding whether to wrap in HTML cells */
    /* Todo: Check harder. Some things might not be initialized yet for this call. */
    /* Todo: We're not ready yet for ocelot_vertical != 0 */
    //if (copy_of_ocelot_html != 0)
    if ((result_row_count != 0) && (result_column_count != 0))
    {
      //if (copy_of_ocelot_vertical == 0)
      grid_column_size_calc(setting_ocelot_grid_cell_border_size_as_int,
                            setting_ocelot_grid_cell_drag_line_size_as_int,
                            ocelot_result_grid_column_names_copy,
                            copy_of_connections_dbms); /* get grid_column_widths[] and grid_column_heights[] */
    }
    /* Todo: this should be done permanently, on persistent variables. */
    //if (copy_of_ocelot_html != 0)
    {
      char html_border_color[32];
      char html_color[32];
      char html_background_color[32];
      char html_header_background_color[32];
      char html_font_family[32];
      char html_font_size[32];
      char html_font_style[32];
      char html_font_weight[32];
      char html_outer_color[32];
      int html_border_size;

      QString tmp_border_color= get_border_color();

      strcpy(html_border_color, tmp_border_color.toUtf8());
      strcpy(html_color, copy_of_parent->ocelot_grid_text_color.toUtf8());
      strcpy(html_background_color, copy_of_parent->ocelot_grid_background_color.toUtf8());
      strcpy(html_header_background_color, copy_of_parent->ocelot_grid_header_background_color.toUtf8());
      strcpy(html_font_family, copy_of_parent->ocelot_grid_font_family.toUtf8());
      strcpy(html_font_size, copy_of_parent->ocelot_grid_font_size.toUtf8());
      strcpy(html_font_style, copy_of_parent->ocelot_grid_font_style.toUtf8());
      strcpy(html_font_weight, copy_of_parent->ocelot_grid_font_weight.toUtf8());
      strcpy(html_outer_color, copy_of_parent->ocelot_grid_outer_color.toUtf8());

      html_border_size= copy_of_parent->ocelot_grid_cell_border_size.toInt();

      char tmp_div[512];
      {
        /* TEST!!! start: See whether we can change color, at least. HTML only! SHOULD BE IN A LOOP! */
        QString new_tooltip= "";
        QString new_style_sheet= copy_of_parent->ocelot_grid_style_string;
        QString new_cell_height= "";
        QString new_cell_width= "";
        bool result= conditional_setting_evaluate(
             0, /* cs_number */
             0, /* doesn't matter */
             0, /* doesn't matter */
             0, /* doesn't matter */
             0, /* doesn't matter */
             0, /* doesn't matter */
             TEXTEDITFRAME_CELL_TYPE_DETAIL, /* text_edit_frames[text_edit_frames_index]->cell_type, */
             copy_of_parent->ocelot_grid_style_string,          /* old_style_sheet */
             true,        /* is_always_true */
             &new_tooltip, &new_style_sheet, &new_cell_height, &new_cell_width);
        if (result == true)
        {
          strcpy(tmp_div, " .E0 {");                        /* for <div> */
          strcat(tmp_div, new_style_sheet.toUtf8());
          strcat(tmp_div, "} ");
        }
        else tmp_div[0]= '\0';
      }
      sprintf(ocelot_grid_table_start,"<HTML><HEAD><style type=text/css>"
              " %s "                                                /* tmp_div */
              " table {border-style: solid; background-color: %s; border-color: %s} "    /* html_border_color */
              " body {"
              "background-color: purple; "
              "color: %s; "                                         /* html_color */
              "font-family: '%s'; "                                 /* html_font_family */
              "font-size: %spt; "                                   /* html_font_size */
              "font-style: %s; "                                    /* html_font_style */
              "font-weight: %s}"                                    /* html_font_weight */
              " th {"
              "background-color: %s; "                              /* html_header_background_color */
              "}"
              " td {"
              "background-color: %s; "                              /* html_background_color */
              "}"
              "</style></HEAD><BODY bgcolor=%s><TABLE BORDER=%d blue>", /* html_border_size */
              tmp_div,
              html_border_color, /* table{background-color:...} will look like cell border color */
              html_border_color, /* table{border-color:...} will look like cell border color */
              html_color,        /* body {color} will be color of text in th and td */
              html_font_family,             /* body {font-family} */
              html_font_size,               /* body {font-size} */
              html_font_style,              /* body {font-style} */
              html_font_weight,             /* body {font-weight} */
              html_header_background_color, /* th {background-color} */
              html_background_color,        /* td {background-color} */
              html_outer_color,         /* body bgcolor */
              html_border_size);            /* table border size */
      strcpy(ocelot_grid_header_row_start, "<TR bgcolor=blue>");
      strcpy(ocelot_grid_header_row_end, "</TR>");
      strcpy(ocelot_grid_header_numeric_column_start, "<TH>");
      strcpy(ocelot_grid_header_numeric_column_end, "</TH>");
      strcpy(ocelot_grid_header_char_column_start, "<TH>");
      strcpy(ocelot_grid_header_char_column_end, "</TH>");
      strcpy(ocelot_grid_detail_row_start, "<TR>");
      strcpy(ocelot_grid_detail_row_end, "</TR>");
      strcpy(ocelot_grid_detail_numeric_column_start, "<TD align=\"right\">");
      strcpy(ocelot_grid_detail_numeric_column_end,"</TD>");
      /* TEST!!!! */
      strcpy(ocelot_grid_detail_char_column_start, "<TD width=    >");
      strcpy(ocelot_grid_detail_char_column_end , "</TD>");
      strcpy(ocelot_grid_table_end, "</TABLE></BODY></HTML>");
    }
//TEST!!    hide(); /* todo: I'm not sure whether this has a point while the kludges exist */
    //html_text_edit->clear(); /* I'm sure this has a point while the kludges exist */
    /*
      Kludge #1: if I don't delete html_text_edit and create it again, then after
      ocelot_html=1; big select; ocelot_html=0; big select; ocelot_html=1;big select;
      the horizontal scroll bar won't work.
      KLudge #2: without the show() and hide()s here, if I said
      SET ocelot_html=0; SELECT * FROM "_space"; SET ocelot_html=1; SELECT * FROM "_space";
      the vertical scroll bar was absent. I wish I knew why doing this can fix it.
      Kludge #3: with something other than SetMaximumSize later, this wil cause too-small window:
      SET ocelot_html=0; SELECT 5; SET ocelot_html=1; SELECT * FROM "_space";
      Kludge #4: If we don't break off early when row count or column count = 0, we will crash.
      But by doing so, we fail to add html or xml markup and we don't allow for message translation.
      I don't bother to say html_text_edit_hide() so this->show() makes it visible, momentarily.
      I think html_text_edit won't have trouble with paint events because it is an ordinary QTextEdit.
    */
    /*** Removed due to tests */
    //delete html_text_edit;
    //html_text_edit= new Result_qtextedit(this);
}

/*
  Called from display_html(). Return expected # of pixels in a column of a row.
              For a string: height of a line for the column's font, * #-of-<br>s
              For an image: getting QPixMap is slow but we'll only call this while display
                            (todo: someday calculate height from header, see comments before
                             set_max_column_width)
              ... but there might be an override due to a height specifier, which might be conditional
              ... see grid_row_heights[]
            + border-size * 2
            + 1 (mysteriously)
            + 1 (mysteriously, and the same + 1 that we used to calculate row_height elsewhere)
  Todo: Look for conditional settings.
  Todo: call this for header too, if it's decided that header can be multi-line.
  Todo: Should also look for grid heights[]
  Todo: Possibly boundingRect() would be more accurate, especially if someday word wrap is allowed.
*/
int column_height(unsigned int grid_row, int column_no, int v_length, char *value)
{
  (void)grid_row;
  char img_type[4];
  set_img_type(value, v_length, img_type); /* so img_type = "" or "png" or "jpg" or "gif" */
  if (img_type[0] != '\0')
  {
    QPixmap p= QPixmap();
    if (p.loadFromData((const uchar*) value,
                       v_length,
                       0,
                       Qt::AutoColor) == true)
    {
      /* Readable as an image. Not text. Not null. */
      return p.height();
    }
  }
  int column_width_in_chars= (grid_column_widths[column_no] / setting_max_width_of_a_char);
  int lines_in_cell= (v_length + (column_width_in_chars - 1)) / column_width_in_chars;
  if (lines_in_cell == 0) lines_in_cell= 1;
  int this_column_height= (lines_in_cell * max_height_of_a_char) + (setting_ocelot_grid_cell_border_size_as_int * 2) + 1 + 1;
  if (this_column_height < (int) grid_row_heights[column_no]) this_column_height= grid_row_heights[column_no];
  return this_column_height;
}

/*
  Re max_display_height: The results of cell_analyze() as for-the-moment are visible in tooltip
  show minimum y = 3 and first row's height is 1 or 2 more than later rows'
  height e.g. it's 23 if others are 21, which partly we can attribute to grid border size. So you see "- 4".
  Todo: maybe that's not always so, so do the size calculation as in cell_analyze() if you can.
  Re row_height: Again it's tooltip that shows I must have "+ 1 + 1" but I have no idea why.
                 I do the same in the column_height() function.
  Todo: eventually row_height + max_display_rows won't need to be calculated at this stage.
  Todo: result_grid_height_after_last_resize can change in ways that might not be anticipated.
  We know that it is wrong for the first display. Todo: check what happens if it's minimized.
*/
void get_row_height_and_max_display_height_and_max_grid_rows(int *row_height, int *max_display_height, int *max_grid_rows)
{
  *row_height= max_height_of_a_char + setting_ocelot_grid_cell_border_size_as_int * 2 + 1 + 1;
  *max_display_height= result_grid_height_after_last_resize;
  int wx= scroll_bar_width * 2; /* todo: should add width of the leftmost (sizer thin image) column, actually */
  for (int i= 0; i < (int) gridx_column_count; ++i) wx+= grid_column_widths[i]
                                              + setting_ocelot_grid_cell_border_size_as_int * 2
                                            + 1;
  if (wx >= (int) result_grid_width_after_last_resize)
      *max_display_height-= scroll_bar_height;
  (*max_display_height)-= 4;
  if (*max_display_height < *row_height * 2) *max_display_height= *row_height * 2;
  *max_grid_rows= *max_display_height / *row_height;
  if ((ocelot_vertical_copy == 1) && (ocelot_result_grid_column_names_copy == 1))
  {
    --(*max_grid_rows);
  }
  if (*max_grid_rows <= 0) *max_grid_rows= 1;
}

/*
  Todo: Ensure this isn't called for some irrelevant vertical scroll bar event.
        It seems that we're calling display_html multiple times, not once per select, find out why.
  Todo: We're calculating char[] size in advance and using strcpy() or memcpy().
        It would be lots simpler and safer to use a QString, but might be slower.
  Todo: Figure out how many rows you can fit. Straightforward but time-consuming. Mostly finished.
        Calculate max_display_height =
          viewport-height or widget height
          - height of a potential horizontal scroll bar (but don't subtract this if width < widget width)
            i.e. self.style().pixelMetric(qg.QStyle.PM_ScrollBarExtent)
            and frame if you ever decide to have a frame
            +3 say some folks in a forum
          - n pixels for luck
          -     width +=
        Calculate table_height =
          0
          For each row:
            + max_column_heights i.e. size of highest column as returned by column_height()
          If total max_column_heights > max_display_height after X rows, you want X - 1 rows.
          Exception: X cannot be 0, i.e. there is always at least 1 row. It can have its own scroll bar.
        You might have a bit of trouble if there is a font-change within the column, otherwise you should be accurate.
        Warning: if lineSpacing()==24 then max_height_of_a_char==26 and actual height seems to be 27
  Re result_grid_height_after_last_resize:
    It might be better to calculate height from Result_qtextedit::resizeEvent, it would probably be
    two pixels smaller than what comes out of ResultGrid::resizeEvent, but we don't change because there
    might be non-HTML stuff that depends on it. For some reason we might be calling display_html more than
    once, but we won't waste too much time if it's -1.
*/
void display_html(int new_grid_vertical_scroll_bar_value, int situation)
{
  if ((result_row_count == 0) || (result_column_count == 0))
  {
    switch_to_batch_text_edit();
    batch_text_edit->clear(); /* Todo: This is to avoid repeating the message. Possibly that's a bug. */
    batch_text_edit->insertPlainText("row_count == 0 or column_count == 0");
//    this->show();
//    client->show();
    return;
  }

  if (result_grid_height_after_last_resize < 0) return;

  switch_to_html_text_edit(); /* so grid_main_layout has html_text_edit and not batch_text_edit */

  if (copy_of_ocelot_vertical == 1) { display_html_html_vertical(new_grid_vertical_scroll_bar_value); return; }
  int row_height, max_display_height, max_grid_rows;
  get_row_height_and_max_display_height_and_max_grid_rows(&row_height, &max_display_height, &max_grid_rows);

  is_paintable= 0;

  /* TODO: IS THIS NECESSARY? IS IT IN THE RIGHT PLACE? */
//  html_text_edit->show();

  /* I SUSPECT THAT IF I HIDE CLIENT THEN SCROLLBAR WON'T WORK CORRECTLY WITH SLIDER */
  /* TODO: WHY WERE THESE THINGS HERE? */
//  this->show();
//  client->show();
//  client->hide();
//  this->hide();

//  grid_vertical_scroll_bar->setVisible(false); /* let it stay visible for tests */
//  grid_main_layout->addWidget(html_text_edit);

  long unsigned int tmp_result_row_number;
  char *result_set_pointer= result_set_copy_rows[new_grid_vertical_scroll_bar_value];
  unsigned int v_length /*, f_length */;
  char *result_field_names_pointer;

  /*
    For every column value we add size of possible overhead in <th> or <td> or <div>.
    Todo: It ought to be possible to do a single non-looping calculation.
 */
  unsigned int tmp_size= sizeof(char);

  unsigned int max_column_heights_total= 0;

  /* <TD></TD> might be replaced by <TD><div class="xx"></div></TD> which is 22 bytes */
  unsigned int extra_for_div= 0;
  if (copy_of_parent->conditional_settings.count() > 0) extra_for_div= 22;

  unsigned int grid_row= 0;

  if ((ocelot_result_grid_column_names_copy == 1)
   && (copy_of_ocelot_xml == 0))
  {
    /* todo: do a max_column_height calculation as you do for detail rows */
    tmp_size+= strlen(ocelot_grid_header_row_start);
    result_field_names_pointer= &result_field_names[0];
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      tmp_size+= strlen(ocelot_grid_header_char_column_start) + extra_for_div;
      memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
      tmp_size+= v_length;
      result_field_names_pointer+= v_length + sizeof(unsigned int);
      tmp_size+= strlen(ocelot_grid_header_char_column_end);
    }
    tmp_size+= strlen(ocelot_grid_header_row_end);
    max_column_heights_total= row_height;
    ++grid_row;
  }

  tmp_size+= strlen(ocelot_grid_table_start);

  //for (tmp_result_row_number= 0; tmp_result_row_number < result_row_count; ++tmp_result_row_number)
  for (tmp_result_row_number= new_grid_vertical_scroll_bar_value;
       (tmp_result_row_number < result_row_count) && (grid_row < (unsigned int) max_grid_rows);
       ++tmp_result_row_number, ++grid_row)
  {
    result_field_names_pointer= &result_field_names[0];
    tmp_size+= strlen(ocelot_grid_detail_row_start);
    int max_column_height= 0;
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      if ((result_field_flags[i] & NUM_FLAG) != 0)
        tmp_size+= strlen(ocelot_grid_detail_numeric_column_start) + extra_for_div;
      else
        tmp_size+= strlen(ocelot_grid_detail_char_column_start) + extra_for_div;
      tmp_size+= 12; /* for "width=xxxxx;" */
      memcpy(&v_length, result_set_pointer, sizeof(unsigned int));
      result_set_pointer+= sizeof(unsigned int) + sizeof(char);
      int this_column_height= column_height(grid_row, i, v_length, result_set_pointer);
      if (this_column_height > max_column_height) max_column_height= this_column_height;
      tmp_size+= v_length;
      tmp_size+= strlen(ocelot_grid_detail_char_column_end);
      result_set_pointer+= v_length;
    }
    tmp_size+= strlen(ocelot_grid_detail_row_end);
    max_column_heights_total+= max_column_height;
    if ((max_column_heights_total) >= (unsigned int) max_display_height)
    {
      /* Too many rows. There's no good justification for "+ 1" but it's harmless to display too few. */
      max_grid_rows= grid_row;
      if (max_grid_rows <= 0) max_grid_rows= 1;
      if ((max_grid_rows == 1) && (copy_of_ocelot_result_grid_column_names == 1)) max_grid_rows= 2;
      break;
    }
  }
  tmp_size+= strlen(ocelot_grid_table_end);
  char *tmp;

  /* *5 in case (a) we change & to &amp; (b) we add <br> (c) we use hex digits (d) we forgot something. */
  tmp_size= tmp_size * 5;

  /* +200 because thin_image */

  tmp_size+= 1000000; /* image paste experiment */

  tmp= new char[tmp_size];
  char *tmp_pointer= &tmp[0];

  char *tmp_pointer_before_thin_image_call; /* For the first column. Includes height which may need changing. */
  int new_cell_height; /* If this becomes positive, we have to rewrite at tmp_pointer_before_thin_image_call */

  strcpy(tmp_pointer, ocelot_grid_table_start);
  tmp_pointer+= strlen(ocelot_grid_table_start);

  if (ocelot_result_grid_column_names_copy == 1)
  {
    char *result_field_names_pointer;
    result_field_names_pointer= &result_field_names[0];
    strcpy(tmp_pointer, ocelot_grid_header_row_start);
    tmp_pointer+= strlen(ocelot_grid_header_row_start);
    tmp_pointer_before_thin_image_call= tmp_pointer;
    tmp_pointer+= thin_image(tmp_pointer, (const char*) "TH", 1);

    for (unsigned int result_column_no= 0; result_column_no < result_column_count; ++result_column_no)
    {
      memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
      result_field_names_pointer+= sizeof(unsigned int);

      //memcpy(tmp_pointer, result_field_names_pointer, v_length);
      //tmp_pointer+= v_length;
      tmp_pointer+= html_text_edit->copy_html_cell(ocelot_grid_header_char_column_start,
                                                    ocelot_grid_header_char_column_start,
                                                    tmp_pointer,
                                                    result_field_names_pointer,
                                                    FIELD_VALUE_FLAG_IS_STRING,
                                                    v_length,
                                                    TEXTEDITFRAME_CELL_TYPE_HEADER,
                                                    grid_column_widths[result_column_no],
                                                    max_height_of_a_char, /* todo: see if this is set */
                                                    result_grid_font,
                                                    setting_max_width_of_a_char,
                                                    result_column_no,
                                                    0, /* tmp_result_row_number */
                                                    ocelot_grid_header_char_column_end,
                                                    &new_cell_height,
                                                    result_column_no);
      result_field_names_pointer+= v_length;
    }
    strcpy(tmp_pointer, ocelot_grid_header_row_end);
    tmp_pointer+= strlen(ocelot_grid_header_row_end);
  }

  result_set_pointer= result_set_copy_rows[new_grid_vertical_scroll_bar_value];
  //unsigned int grid_row;
  for (tmp_result_row_number= new_grid_vertical_scroll_bar_value, grid_row= 1;
       (tmp_result_row_number < result_row_count) && (grid_row < (unsigned int) max_grid_rows);
       ++tmp_result_row_number, ++grid_row)
//  for (tmp_result_row_number= 0; tmp_result_row_number < result_row_count; ++tmp_result_row_number)
  {
    result_field_names_pointer= &result_field_names[0];
    strcpy(tmp_pointer, ocelot_grid_detail_row_start);
    tmp_pointer+= strlen(ocelot_grid_detail_row_start);
    tmp_pointer_before_thin_image_call= tmp_pointer;
    tmp_pointer+= thin_image(tmp_pointer, (const char*) "TD", grid_row_heights[grid_row]);
    for (unsigned int result_column_no= 0; result_column_no < result_column_count; ++result_column_no)
    {
      memcpy(&v_length, result_set_pointer, sizeof(unsigned int));
      char result_set_value_flags= *(result_set_pointer + sizeof(unsigned int));
      result_set_pointer+= sizeof(unsigned int) + sizeof(char);
      /* more "HTML only" stuff */
      tmp_pointer+= html_text_edit->copy_html_cell(ocelot_grid_detail_numeric_column_start,
                                                    ocelot_grid_detail_char_column_start,
                                                    tmp_pointer,
                                                    result_set_pointer,
                                                    result_set_value_flags,
                                                    v_length,
                                                    TEXTEDITFRAME_CELL_TYPE_DETAIL,
                                                    grid_column_widths[result_column_no],
                                                    grid_row_heights[grid_row],
                                                    result_grid_font,
                                                    setting_max_width_of_a_char,
                                                    result_column_no,
                                                    tmp_result_row_number,
                                                    ocelot_grid_detail_char_column_end,
                                                    &new_cell_height,
                                                    result_column_no);
      result_set_pointer+= v_length;

      if (new_cell_height > 0)
      {
        thin_image(tmp_pointer_before_thin_image_call, (const char*) "TD", new_cell_height); /* overwrite */
      }
    }
    strcpy(tmp_pointer, ocelot_grid_detail_row_end);
    tmp_pointer+= strlen(ocelot_grid_detail_row_end);
  }
  strcpy(tmp_pointer, ocelot_grid_table_end);
  tmp_pointer+= strlen(ocelot_grid_table_end);
  *tmp_pointer= '\0';

  if (situation == TOKEN_KEYWORD_OCELOT_EXPORT)
  {
    copy_of_parent->history_file_write("TEE", tmp, false);
  }
  else
  {
    html_text_edit->setHtml(tmp);
    html_text_edit->moveCursor(QTextCursor::Start);
    html_text_edit->ensureCursorVisible();
  }
  /* Beware, saying show() causes resize_or_font_change which calls display_html */
  {
//TEST!!    html_text_edit->show();
//TEST!!    show();
//TEST!!    client->show();
  }
  delete [] tmp;
  is_paintable= 1;
  return;
}

/*
  When is_vertical == 1 we have one line per column: [optional column heading] column value.
  Todo: This is only when copy_of_ocelot_html != 0. But size calculation for xml is similar.
  Todo: We're missing recent improvements in display_html(), e.g. re column_height().
*/
void display_html_html_vertical(int new_grid_vertical_scroll_bar_value)
{
  int row_height, max_display_height, max_grid_rows;
  get_row_height_and_max_display_height_and_max_grid_rows(&row_height, &max_display_height, &max_grid_rows);

  int new_cell_height; /* TODO: WE HAVE TO DO SOMETHING WITH THIS! */

  is_paintable= 0;

//  html_text_edit->show();

  long unsigned int result_row_number;
  char *result_set_pointer= result_set_copy_rows[new_grid_vertical_scroll_bar_value];
  unsigned int v_length, f_length;
  char *result_field_names_pointer;

  /*
    For every column value we add size of possible overhead in <th> or <td> or <div>.
    Todo: It ought to be possible to do a single non-looping calculation.
 */
  unsigned int tmp_size= sizeof(char);

  /* <TD></TD> might be replaced by <TD><div class="xx"></div></TD> which is 22 bytes */
  unsigned int extra_for_div= 0;
  /* We removed a check if copy_of_ocelot_html == 1 here */
  if (copy_of_parent->conditional_settings.count() > 0) extra_for_div= 22;
  if (ocelot_result_grid_column_names_copy == 1)
  {
    tmp_size+= strlen(ocelot_grid_header_row_start);
    result_field_names_pointer= &result_field_names[0];
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      tmp_size+= strlen(ocelot_grid_header_char_column_start) + extra_for_div;
      memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
      tmp_size+= v_length;
      result_field_names_pointer+= v_length + sizeof(unsigned int);
      tmp_size+= strlen(ocelot_grid_header_char_column_end);
    }
    tmp_size+= strlen(ocelot_grid_header_row_end);
  }
  tmp_size+= strlen(ocelot_grid_table_start);

  //for (result_row_number= 0; result_row_number < result_row_count; ++result_row_number)
  unsigned int grid_row;
  for (result_row_number= new_grid_vertical_scroll_bar_value, grid_row= 1;
       (result_row_number < result_row_count) && (grid_row < (unsigned int) max_grid_rows);
       ++result_row_number, ++grid_row)
  {
    result_field_names_pointer= &result_field_names[0];
    tmp_size+= strlen(ocelot_grid_detail_row_start);
    for (unsigned int result_column_no= 0; result_column_no < result_column_count; ++result_column_no)
    {
      if ((result_field_flags[result_column_no] & NUM_FLAG) != 0)
        tmp_size+= strlen(ocelot_grid_detail_numeric_column_start) + extra_for_div;
      else
        tmp_size+= strlen(ocelot_grid_detail_char_column_start) + extra_for_div;
      tmp_size+= 12; /* for "width=xxxxx;" */
//      if (copy_of_ocelot_xml != 0)
      {
        memcpy(&f_length, result_field_names_pointer, sizeof(unsigned int));
        tmp_size+= f_length + 2;
        result_field_names_pointer+= f_length + sizeof(unsigned int);
      }
      memcpy(&v_length, result_set_pointer, sizeof(unsigned int));

      result_set_pointer+= sizeof(unsigned int) + sizeof(char);
      tmp_size+= v_length;
      tmp_size+= strlen(ocelot_grid_detail_char_column_end);
      result_set_pointer+= v_length;
    }
    tmp_size+= strlen(ocelot_grid_detail_row_end);
  }
  tmp_size+= strlen(ocelot_grid_table_end);
  char *tmp;

  /* TEST!!!! * temporarily 50 */
  /* *5 in case (a) we change & to &amp; (b) we add <br> (c) we use hex digits (d) we forgot something. */
  tmp_size= tmp_size * 50;

  /* +200 because thin_image */

  tmp_size+= 1000000; /* image paste experiment */


  tmp= new char[tmp_size];
  char *tmp_pointer= &tmp[0];
  char *tmp_pointer_before_thin_image_call; /* For the first column. Includes height which may need changing. */


  strcpy(tmp_pointer, ocelot_grid_table_start);
  tmp_pointer+= strlen(ocelot_grid_table_start);

  result_set_pointer= result_set_copy_rows[new_grid_vertical_scroll_bar_value];
  //unsigned int grid_row;
  for (result_row_number= new_grid_vertical_scroll_bar_value, grid_row= 0;
       (result_row_number < result_row_count) && (grid_row < (unsigned int) max_grid_rows);
       ++result_row_number, grid_row+= result_column_count)
//  for (result_row_number= 0; result_row_number < result_row_count; ++result_row_number)
  {
    result_field_names_pointer= &result_field_names[0];

    for (unsigned int result_column_no= 0; result_column_no < result_column_count; ++result_column_no)
    {
//      if (copy_of_ocelot_xml != 0)
      strcpy(tmp_pointer, ocelot_grid_detail_row_start);
      tmp_pointer+= strlen(ocelot_grid_detail_row_start);
      tmp_pointer_before_thin_image_call= tmp_pointer;
      tmp_pointer+= thin_image(tmp_pointer, (const char*) "TD", grid_row_heights[grid_row + result_column_no]);

      /* EL KLUDGEO -- until we have a better calculation of grid_column_widths[] when vertical */
//      if (grid_column_widths[i] < 20) grid_column_widths[i]= 200;
      if (ocelot_result_grid_column_names_copy == 1)
      {
        memcpy(&f_length, result_field_names_pointer, sizeof(unsigned int));
        result_field_names_pointer+= sizeof(unsigned int);
        tmp_pointer+= html_text_edit->copy_html_cell(ocelot_grid_header_char_column_start,
                                                      ocelot_grid_header_char_column_start,
                                                      tmp_pointer,
                                                      result_field_names_pointer,
                                                      FIELD_VALUE_FLAG_IS_STRING,
                                                      f_length,
                                                      TEXTEDITFRAME_CELL_TYPE_HEADER,
                                                      result_grid_vertical_width_of_header,
                                                      max_height_of_a_char, /* todo: see if this is set */
                                                      result_grid_font,
                                                      setting_max_width_of_a_char,
                                                      0, /* grid_column_no */
                                                      result_row_number,
                                                      ocelot_grid_header_char_column_end,
                                                      &new_cell_height,
                                                      result_column_no);

        result_field_names_pointer+= f_length;
      }
      memcpy(&v_length, result_set_pointer, sizeof(unsigned int));
      char result_set_value_flags= *(result_set_pointer + sizeof(unsigned int));
      result_set_pointer+= sizeof(unsigned int) + sizeof(char);
      /* more "HTML only" stuff */
      tmp_pointer+= html_text_edit->copy_html_cell(ocelot_grid_detail_numeric_column_start,
                                                    ocelot_grid_detail_char_column_start,
                                                    tmp_pointer,
                                                    result_set_pointer,
                                                    result_set_value_flags,
                                                    v_length,
                                                    TEXTEDITFRAME_CELL_TYPE_DETAIL,
                                                    result_grid_vertical_width_of_value,
                                                    grid_row_heights[grid_row + result_column_no],
                                                    result_grid_font,
                                                    setting_max_width_of_a_char,
                                                    0 + ocelot_result_grid_column_names_copy, /* grid_column_no */
                                                    result_row_number,
                                                    ocelot_grid_detail_char_column_end,
                                                    &new_cell_height,
                                                    result_column_no);
      result_set_pointer+= v_length;
      if (new_cell_height > 0)
      {
        thin_image(tmp_pointer_before_thin_image_call, (const char*) "TD", new_cell_height); /* overwrite */
      }
      strcpy(tmp_pointer, ocelot_grid_detail_row_end);
      tmp_pointer+= strlen(ocelot_grid_detail_row_end);
    }
  }
  strcpy(tmp_pointer, ocelot_grid_table_end);
  tmp_pointer+= strlen(ocelot_grid_table_end);
  *tmp_pointer= '\0';

  /* removed "copy_of_ocelot_html != 0" here */
  if (copy_of_ocelot_raw == 0)
  {
    html_text_edit->setHtml(tmp);
  }
  else
  {
    html_text_edit->insertPlainText(tmp);
  }
  html_text_edit->moveCursor(QTextCursor::Start);
  html_text_edit->ensureCursorVisible();
//  html_text_edit->show();
//  show();
//  client->show();
  delete [] tmp;
  is_paintable= 1;
  return;
}

#ifdef DBMS_TARANTOOL
/* Given column name e.g. f_15_1 return number e.g. 15 */
int column_number(char *column_name, int *off)
{
  char tmp[10]= "";
  int tmp_offset= 0;
  int i= 0;
  for (;; ++i)
  {
    if (*(column_name + i) == '_') break;
    if (*(column_name + i) == '\0') return 0;
  }
  ++i;
  for (;; ++i)
  {
    if (*(column_name + i) == '_') break;
    if (*(column_name + i) == '\0') break;
    tmp[tmp_offset++]= *(column_name + i);
  }
  tmp[tmp_offset]= '\0';
  *off= i;
  return atoi(tmp);
}
#endif

#ifdef DBMS_TARANTOOL
/*
  Make a create statement for a CREATE TABLE ... SERVER table.
  We've done
) so we've done tarantool_scan_field_names()
  so we have result_field_names and result_column_count.
  If Lua statement was 'box.space.X:select()" we may have X's field names,
  in read_format_result.
  If the main connection is also Tarantool, then we make a primary key
  on the first one or two columns -- todo: these might not be the right
  columns, and I'm hoping Tarantool won't always have this requirement.
  Todo: max_column_widths might be unreliable if multibyte character.
  Todo: the assumption that when num_flag != 0 it's "INTEGER" is not always going to be best.
*/
int creates(QString create_table_statement, int connections_dbms_0, QString read_format_result)
{
  QString tmp;
  QString first_columns= "";
  char *result_field_names_pointer;
  char column_name[512 + 1];
  unsigned int v_length;

  tmp= create_table_statement;
  tmp.append("(");
  result_field_names_pointer= &result_field_names[0];
  for (unsigned int i= 0; i < result_column_count; ++i)
  {
    memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
    result_field_names_pointer+= sizeof(unsigned int);
    memcpy(column_name, result_field_names_pointer, v_length);
    column_name[v_length]= '\0';
    if (i != 0) tmp.append(",");
    char tmp_column_name_number[10];
    int off= 0;
    int c= column_number(column_name, &off);
    sprintf(tmp_column_name_number, "[%d]", c);
    int word_start, word_end;
    QString word= "";
    word_start= read_format_result.indexOf(tmp_column_name_number, 0);
    if (word_start != -1)
    {
      word_start+= strlen(tmp_column_name_number);
      word_end= read_format_result.indexOf("[", word_start);
      if (word_end == -1) word_end= read_format_result.size();
      word= read_format_result.mid(word_start, (word_end - word_start));
    }
    if (word != "")
    {
      char tmp_column_name[512];
      strcpy(tmp_column_name, word.toUtf8());
      strcat(tmp_column_name, column_name + off);
      strcpy(column_name, tmp_column_name);
    }
    tmp.append(column_name);
    if (i == 0) first_columns.append(column_name);
    if (i == 1) {first_columns.append(","); first_columns.append(column_name); }
    if ((result_field_flags[i] & NUM_FLAG) != 0)
    {
      tmp.append(" INTEGER ");
    }
    else
    {
      tmp.append(" VARCHAR(");
      tmp.append(QString::number(result_max_column_widths[i]));
      tmp.append(") ");
    }
    result_field_names_pointer+= v_length;
  }
  if (connections_dbms_0 == DBMS_TARANTOOL)
  {
    tmp.append(", PRIMARY KEY (");
    tmp.append(first_columns);
    tmp.append(")");
  }
  tmp.append(")");
  int result= copy_of_parent->execute_real_query(tmp, 0, &tmp); /* MYSQL_MAIN_CONNECTION */
  if (result != 0) return result;
  return result;
}
#endif

#ifdef DBMS_TARANTOOL
/* Make some insert statements for a remote subquery temporary table */
/*
  KLUDGE ALERT: A column in the first row might be non-numeric
  (field name) even though the field is numeric.
  This is supposed to be fixed soon. Meanwhile we put '' around it.
  What we're saying is "if it doesn't start with a digit then put
  quotes around it", which is close to absurd.
*/
int inserts(QString temporary_table_name)
{
  long unsigned int tmp_xrow;
  char *pointer= result_set_copy_rows[0];
  unsigned int v_length;
  QString tmp;
  QString s;
  char ctmp[1024];

  pointer= result_set_copy_rows[0];
  for (tmp_xrow= 0; tmp_xrow < result_row_count; ++tmp_xrow)
  {
    tmp= "INSERT INTO ";
    tmp.append(temporary_table_name);
    tmp.append(" VALUES (");
    for (unsigned int i= 0; i < result_column_count; ++i)
    {
      if (i > 0) tmp.append(",");
      memcpy(&v_length, pointer, sizeof(unsigned int));
      char tmp_flag= *(pointer + sizeof(unsigned int));
      pointer+= sizeof(unsigned int) + sizeof(char);
      if (tmp_flag == FIELD_VALUE_FLAG_IS_NULL)
      {
        tmp.append("NULL");
      }
      else if ((v_length > 0) && (*pointer >= '0') && (*pointer <= '9'))
      {
        memcpy(ctmp, pointer, v_length);
        ctmp[v_length]= '\0';
        tmp.append(ctmp);
      }
      else
      {
        tmp.append("'");
        memcpy(ctmp, pointer, v_length);
        ctmp[v_length]= '\0';
        tmp.append(ctmp);
        tmp.append("'");
      }
      pointer+= v_length;
    }
    tmp.append(");");
    int result= copy_of_parent->execute_real_query(tmp, 0, &tmp); /* MYSQL_MAIN_CONNECTION */
    if (result != 0) return result;
  }
  return 0;
}
#endif

/*
  Copy the result_ lists to gridx_lists.
  Originally the idea behind this was that we'd optionally add columns
  that weren't in the result set, like "row count" and (for vertical)
  "header". That's becoming obsolete now, because we change the result
  set copy if ocelot_client_side_functions_copy <> 0. So, perhaps,
  someday we will get rid of this step.
  The values are for a single detail row or single header row.
   gridx_field_names
   gridx_original_field_names
   gridx_original_table_names
   gridx_original_database_names
   gridx_max_column_widths
   gridx_flags                         header | refer to result _ lists
   gridx_field_types
   gridx_result_indexes                use as index for result_ lists
   gridx_column_count, gridx_row_count
   Todo: We rely on a bunch of gridx_* items. They should be in a single struct.
*/
void copy_result_to_gridx()
{
  unsigned int i, j;
  unsigned int v_lengths;
  char *result_field_names_pointer;
  char *gridx_field_names_pointer;

  /* todo: shouldn't this be only in display_garbage_collect()? */
  if (gridx_field_names != 0) { delete [] gridx_field_names; gridx_field_names= 0; }
  if (gridx_max_column_widths != 0) { delete [] gridx_max_column_widths; gridx_max_column_widths= 0; }
  if (gridx_result_indexes != 0) { delete [] gridx_result_indexes; gridx_result_indexes= 0; }
  if (gridx_flags != 0) { delete [] gridx_flags; gridx_flags= 0; }
  if (gridx_field_types != 0) { delete [] gridx_field_types; gridx_field_types= 0; }

  gridx_column_count= result_column_count;
  gridx_row_count= result_row_count;
  /* result_set_copy, result_set_copy_rows are left alone */

  /*
    First loop: find how much to allocate. Allocate. Second loop: fill in with pointers within allocated area.
  */

  result_field_names_pointer= &result_field_names[0];
  unsigned int total_size= 0;
  for (i= 0; i < result_column_count; ++i)
  {
    memcpy(&v_lengths, result_field_names_pointer, sizeof(unsigned int));
    total_size+= v_lengths + sizeof(unsigned int);
    result_field_names_pointer+= v_lengths + sizeof(unsigned int);
  }

  gridx_field_names= new char[total_size];                                  /* allocate */

  result_field_names_pointer= &result_field_names[0];
  gridx_field_names_pointer= &gridx_field_names[0];
  for (i= 0; i < result_column_count; ++i)
  {
    memcpy(&v_lengths, result_field_names_pointer, sizeof(unsigned int));
    memcpy(gridx_field_names_pointer, &v_lengths, sizeof(unsigned int));
    result_field_names_pointer+= sizeof(unsigned int);
    gridx_field_names_pointer+= sizeof(unsigned int);
    memcpy(gridx_field_names_pointer, result_field_names_pointer, v_lengths);
    result_field_names_pointer+= v_lengths;
    gridx_field_names_pointer+= v_lengths;
  }

  gridx_max_column_widths= new unsigned int[gridx_column_count];
  gridx_result_indexes= new unsigned int[gridx_column_count];
  gridx_flags= new unsigned char[gridx_column_count];
  gridx_field_types= new short unsigned int[gridx_column_count];
  j= 0;
  for (i= 0; i < result_column_count; ++i)
  {
    gridx_max_column_widths[j]= result_max_column_widths[i];
    gridx_result_indexes[j]= i;
    gridx_flags[j]= 0;
    gridx_field_types[j]= result_field_types[i];
    /* todo: following depends on MySQL quirks, should be done earlier */
    if ((result_field_charsetnrs[i] == 63) && (gridx_field_types[j] == OCELOT_DATA_TYPE_VAR_STRING)) gridx_field_types[j]= OCELOT_DATA_TYPE_VARBINARY;
    if ((result_field_charsetnrs[i] == 63) && (gridx_field_types[j] == OCELOT_DATA_TYPE_STRING)) gridx_field_types[j]= OCELOT_DATA_TYPE_BINARY;
    if ((result_field_charsetnrs[i] != 63) && (gridx_field_types[j] == OCELOT_DATA_TYPE_BLOB)) gridx_field_types[j]= OCELOT_DATA_TYPE_TEXT;
    ++j;
  }

  //result_field_names,
  //result_original_field_names, result_original_table_names, result_original_database_names,
}

/*
  Return true if extra_rule_1 is applicable for this column
*/
bool is_extra_rule_1(int col)
{
  QString condition= copy_of_parent->ocelot_extra_rule_1_condition;
  if (condition == "data_type LIKE '%BLOB'")
  {
    if (gridx_field_types[col] == OCELOT_DATA_TYPE_BLOB)
    {
      return true;
    }
  }
  if (condition == "data_type LIKE '%BINARY'")
  {
    if ((gridx_field_types[col] == OCELOT_DATA_TYPE_BINARY) || (gridx_field_types[col] == OCELOT_DATA_TYPE_VARBINARY))
    {
      return true;
    }
  }
  return false;
}

/*
  Return true if this column should be displayed as an image,
  that is, the image flag should be turned on.
*/
bool is_image(int col)
{
  QString display_as;
  display_as= copy_of_parent->ocelot_extra_rule_1_display_as;
  if (display_as == "image")
  {
    if (is_extra_rule_1(col) == true)
    {
      return true;
    }
  }
  return false;
}

/*
  Called from copy_to_history
  Given: UTF8 string, utf8 string length in bytes, column width in characters
  Return: QString, truncated or padded to match column_width
  This doesn't allow for Asian double-width characters
  (there's a Posix function for that but it might be bad on Windows).
  This does allow for Latin and Cyrillic, with or without accents.
  For calculating taking account of font and pixels, see
  grid_column_size_calc().
  Todo: What if there's a picture? Should BLOBs be shown as hex?
  Todo: Test with vertical.
  Todo: If there's a newline, column boundaries are smashed.
  Todo: convert to QString, fiddle, convert back ... not a fast way, eh?
*/
QByteArray history_padder(char *str, int length,
                       int column_width, char field_value_flags)
{
  QString s= QString::fromUtf8(str, length);
  int space_count= column_width - s.length();
  if (space_count <= 0) s= s.left(column_width);
  else
  {
    QString spaces= " ";
    if (field_value_flags == FIELD_VALUE_FLAG_IS_NUMBER)
      s= spaces.repeated(space_count) + s;
    else
      s= s + spaces.repeated(space_count);
  }
  QByteArray pcv= s.toUtf8();
  return pcv;
}

/*
  Move a limited part of a result set to history.
  We want to show what it looks like, but dumping the whole thing might waste time and space,
  so it's throttled by an ocelot_history variable that can be set to a small values:
  ocelot_history_max_row_count, default "0".
  This is called after preparing a result set in fillup(), and
  depends on fillup() results including max_column widths.
  Example output:
  +------+------+------------+
  | s1   | s2   | The Rain I |
  +------+------+------------+
  |    1 | A    |          0 |
  | NULL | NULL |          0 |
  +------+------+------------+
  The output is the same as what mysql client would display --
    left margin = 1, right margin = 1, left justify if number,
    content length = maximum actual length -- except that mysql
    client has minimum content length = 4 if column is nullable,
    and we don't bother with that, it looks like a flaw.
  Defined limits on column width and on number of columns are arbitrary.
  If changing this, remember to test ^P and ^N which depend on markup.
  Todo: this could be adapted for an alternate way to display the result grid.
  Warning: because history display is html we can show wrong for "<", so
           later history_markup_append() will change to character entities.
  Warning: making the copy bigger would slow down the way the Previous and Next keys work.
  Re file_name: this is NULL if we're really going to history, it's a filename if we're going to export.
  Remaining challenges with copy_to_history:
  * Names and max widths should depend on result_row stuff not gridx_max stuff
  * We should try to keep track of statements so we don't spend too much time going backwards.
  * The "8192" for vertical output is arbitrary. Max should be calculated.
  * Displaying an image as if it's a bunch of characters is a waste of time.
  Re "if (OCELOT_IMPORT_EXPORT == 1)":
    This is for DELIMITED stuff e.g. CSV. See comments before import_export_rule_set().
    Todo: our size calculation is unsafe, we must add sizes of terminated_by enclosed_by etc.
*/
#define HISTORY_COLUMN_MARGIN 1
#define HISTORY_MAX_COLUMN_WIDTH 65535
#define HISTORY_MAX_COLUMN_COUNT 65535
#define HISTORY_MAX_VERTICAL_COLUMN_WIDTH 8192
QString copy_to_history(long int ocelot_history_max_row_count,
                        unsigned short int is_vertical,
                        int connections_dbms,
                        char *file_name)
{
  long unsigned max_row_count= ocelot_history_max_row_count;

  if (max_row_count == 0) return "";

  /* Tarantool won't have picked up column headers if there are no rows */
  if ((result_row_count == 0) && (connections_dbms == DBMS_TARANTOOL))
    return "";

#if (OCELOT_IMPORT_EXPORT == 1)
  QByteArray escapers("");
  char escape_char= export_columns_escaped_by[0];
  char null_string[3];
  char *pointer_to_null_string;
  int length_of_null_string;
  int margin;
  if (file_name != NULL)
  {
    max_row_count= export_max_row_count;
    int e= 0;
    for (int i= 0; i < export_columns_enclosed_by.size(); ++i) escapers[e++]= export_columns_enclosed_by[i];
    for (int i= 0; i < export_columns_escaped_by.size(); ++i) escapers[e++]= export_columns_escaped_by[i];
    for (int i= 0; i < export_columns_terminated_by.size(); ++i) escapers[e++]= export_columns_terminated_by[i];
    for (int i= 0; i < export_lines_starting_by.size(); ++i) escapers[e++]= export_lines_starting_by[i];
    for (int i= 0; i < export_lines_terminated_by.size(); ++i) escapers[e++]= export_lines_terminated_by[i];
    null_string[0]= escape_char;
    null_string[1]= 'N';
    null_string[2]= '\0';
    length_of_null_string= 2;
    pointer_to_null_string= null_string;
    margin= export_margin;
  }
  else
  {
    length_of_null_string= strlen(NULL_STRING);
    pointer_to_null_string= (char *) NULL_STRING;
    margin= HISTORY_COLUMN_MARGIN;
  }
#endif

  unsigned int col;
  long unsigned int r;
  unsigned int length;
  unsigned int history_result_column_count;
  unsigned int *history_max_column_widths;
  unsigned long history_result_row_count;
  char *history_line= NULL;
  char *divider_line= NULL;
  char *pointer_to_history_line;
  unsigned int history_line_width;
  QString s;

  s= "";

  history_max_column_widths= 0;
  history_line= 0;

  /* TODO: See whether gridx_column_count was necessary */
  //if (gridx_column_count > HISTORY_MAX_COLUMN_COUNT) history_result_column_count= HISTORY_MAX_COLUMN_COUNT;
  //else history_result_column_count= gridx_column_count;
  if (result_column_count > HISTORY_MAX_COLUMN_COUNT) history_result_column_count= HISTORY_MAX_COLUMN_COUNT;
  else history_result_column_count= result_column_count;

  history_max_column_widths= new unsigned int[history_result_column_count];
  history_line_width= 2; /* sizeof('|') | sizeof('\n') */

  unsigned short column_names_copy= ocelot_result_grid_column_names_copy;
#if (OCELOT_IMPORT_EXPORT == 1)
  if (file_name != NULL) column_names_copy= export_column_names;
#endif
  unsigned int column_width;
  {
    char *pointer_to_field_names= result_field_names;
    unsigned int column_length;
    for (col= 0; col < history_result_column_count; ++col)
    {
      if (column_names_copy == 1)
      {
        memcpy(&column_length, pointer_to_field_names, sizeof(unsigned int));
        pointer_to_field_names+= sizeof(unsigned int);
        pointer_to_field_names+= column_length;
        column_width= column_length;
      }
      else column_width= 0;
      if (column_width < gridx_max_column_widths[col]) column_width= gridx_max_column_widths[col];
      if (column_width > HISTORY_MAX_COLUMN_WIDTH) column_width= HISTORY_MAX_COLUMN_WIDTH;
      history_max_column_widths[col]= column_width;
      history_line_width+= column_width + 1 + margin * 2;
    }
  }
  if (result_row_count > (unsigned long) max_row_count) history_result_row_count= max_row_count;
  else history_result_row_count= result_row_count;

  if (is_vertical == 1)
  {
    unsigned int longest_column_name_length= 0;
    unsigned int column_length;
    if (column_names_copy == 1)
    {
      char *pointer_to_field_names= result_field_names;
      for (col= 0; col < history_result_column_count; ++col)
      {
        memcpy(&column_length, pointer_to_field_names, sizeof(unsigned int));
        if (column_length > longest_column_name_length)
          longest_column_name_length= column_length;
        pointer_to_field_names+= sizeof(unsigned int);
        pointer_to_field_names+= column_length;
      }
    }
    history_line= new char[HISTORY_MAX_VERTICAL_COLUMN_WIDTH + 256];
    for (r= 0; r < history_result_row_count; ++r)
    {
      sprintf(history_line, "*************************** %ld. row ***************************\n", r + 1);
      s.append(history_line);
      char *row_pointer;
      unsigned int column_length;
      char flag;
      char *pointer_to_source;
      row_pointer= result_set_copy_rows[r];
      char *pointer_to_field_names= result_field_names;
      for (col= 0; col < history_result_column_count; ++col)
      {
        pointer_to_history_line= history_line;
        memcpy(&column_length, pointer_to_field_names, sizeof(unsigned int));
        pointer_to_field_names+= sizeof(unsigned int);
        if (longest_column_name_length > column_length)
        {
          memset(pointer_to_history_line, ' ', longest_column_name_length - column_length);
          pointer_to_history_line+= longest_column_name_length - column_length;
        }
        memcpy(pointer_to_history_line, pointer_to_field_names, column_length);
        pointer_to_field_names+= column_length;
        pointer_to_history_line+= column_length;
        *(pointer_to_history_line++)= ':';
        *(pointer_to_history_line++)= ' ';
        memcpy(&column_length, row_pointer, sizeof(unsigned int));
        flag= *(row_pointer + sizeof(unsigned int));
        row_pointer+= sizeof(unsigned int) + sizeof(char);
        if ((flag & FIELD_VALUE_FLAG_IS_NULL) != 0)
        {
          length= length_of_null_string;
          pointer_to_source= pointer_to_null_string;
        }
        else
        {
          length= column_length;
          pointer_to_source= row_pointer;
        }
        if (length > HISTORY_MAX_VERTICAL_COLUMN_WIDTH) length= HISTORY_MAX_VERTICAL_COLUMN_WIDTH;
        memcpy(pointer_to_history_line, pointer_to_source, length);
        row_pointer+= column_length;
        pointer_to_history_line+= length;
        *(pointer_to_history_line)= '\n'; *(pointer_to_history_line + 1)= '\0';
        s.append(history_line);
      }
    }
    return s;
  }
  /* Assume detail line but not divider line might contain 4-byte chars */
  history_line= new char[(history_line_width*4) + 2];
  divider_line= new char[history_line_width + 2];

  {
    char *pointer_to_divider_line;
    pointer_to_divider_line= divider_line;
    *(pointer_to_divider_line++)= '+';
    for (col= 0; col < history_result_column_count; ++col)
    {
      memset(pointer_to_divider_line, '-',
             history_max_column_widths[col] + margin * 2);
      pointer_to_divider_line+=
             history_max_column_widths[col] + margin * 2;
      *(pointer_to_divider_line++)= '+';
    }
    /* Todo: Consider: maybe if file_name != NULL divider_line should end with export_lines_terminated_by? */
    *(pointer_to_divider_line)= '\n'; *(pointer_to_divider_line + 1)= '\0';
  }
  if (column_names_copy == 1)
  {
    char *pointer_to_field_names= result_field_names;
    unsigned int column_length;
#if (OCELOT_IMPORT_EXPORT == 1)
  if (file_name != NULL)
  {
    if (export_divider == 1) copy_of_parent->history_file_write("TEE", divider_line, false);
  }
  else
    s.append(divider_line);
#else
  s.append(divider_line);
#endif
    pointer_to_history_line= history_line;
    *(pointer_to_history_line++)= '|';
    QByteArray pcv; /* padded column value */
    for (col= 0; col < history_result_column_count; ++col)
    {
      memset(pointer_to_history_line, ' ', margin);
      pointer_to_history_line+= margin;
      memcpy(&column_length, pointer_to_field_names, sizeof(unsigned int));
      pointer_to_field_names+= sizeof(unsigned int);
      pcv= history_padder(pointer_to_field_names, column_length,
                     history_max_column_widths[col], 0);
      memcpy(pointer_to_history_line, pcv, pcv.size());
      pointer_to_field_names+= column_length;
      pointer_to_history_line+= pcv.size();
      memset(pointer_to_history_line, ' ', margin);
      pointer_to_history_line+= margin;
      *(pointer_to_history_line++)= '|';
    }
    *(pointer_to_history_line)= '\n'; *(pointer_to_history_line + 1)= '\0';
#if (OCELOT_IMPORT_EXPORT == 1)
    if (file_name != NULL)
      copy_of_parent->history_file_write("TEE", history_line, false);
    else
#endif
    s.append(history_line);
  }
  pointer_to_history_line= history_line;
#if (OCELOT_IMPORT_EXPORT == 1)
  if (file_name != NULL)
  {
    if (export_divider == 1) copy_of_parent->history_file_write("TEE", divider_line, false);
  }
  else
    s.append(divider_line);
#else
  s.append(divider_line);
#endif
  for (r= 0; r < history_result_row_count; ++r)
  {
    char *row_pointer;
    unsigned int column_length;
    char field_value_flags;
    char *pointer_to_source;
    pointer_to_history_line= history_line;
    row_pointer= result_set_copy_rows[r];
#if (OCELOT_IMPORT_EXPORT == 1)
    if (file_name != NULL)
    {
      strcpy(pointer_to_history_line, export_lines_starting_by.constData());
      pointer_to_history_line+= export_lines_starting_by.size();
    }
    else
#endif
    *(pointer_to_history_line++)= '|';
    QByteArray pcv; /* padded column value */
    for (col= 0; col < history_result_column_count; ++col)
    {
      memcpy(&column_length, row_pointer, sizeof(unsigned int));
      field_value_flags= *(row_pointer + sizeof(unsigned int));
      row_pointer+= sizeof(unsigned int) + sizeof(char);
#if (OCELOT_IMPORT_EXPORT == 1)
      bool is_to_be_enclosed= true;
      if ((export_columns_optionally == true) && ((field_value_flags & FIELD_VALUE_FLAG_IS_STRING) == 0))
        is_to_be_enclosed= false;
#endif
      if ((field_value_flags & FIELD_VALUE_FLAG_IS_NULL) != 0)
      {
        length= length_of_null_string;
        pointer_to_source= pointer_to_null_string;
      }
      else
      {
        length= column_length;
        pointer_to_source= row_pointer;
      }
      memset(pointer_to_history_line, ' ', margin);
      pointer_to_history_line+= margin;
#if (OCELOT_IMPORT_EXPORT == 1)
      if ((file_name != NULL) && (export_padding == 0))
        pcv= QByteArray(pointer_to_source, length);
      else
        pcv= history_padder(pointer_to_source, length,
                     history_max_column_widths[col], field_value_flags);
#endif
#if (OCELOT_IMPORT_EXPORT == 1)
      if ((file_name != NULL) && (is_to_be_enclosed == true))
      {
        strcpy(pointer_to_history_line, export_columns_enclosed_by.constData());
        pointer_to_history_line+= export_columns_enclosed_by.size();
      }
#endif
      if ((file_name != NULL) && ((field_value_flags & FIELD_VALUE_FLAG_IS_NULL) == 0))
      {
        for (int j= 0; j< pcv.size(); ++j)
        {
          char c= pcv[j];
          /* Warning: if we allowed non-ASCII characters we'd have to allow for multi-byte here. */
          if (c == 0x00) {*(pointer_to_history_line++)= escape_char; *(pointer_to_history_line++)= '0'; }
          else if (escapers.contains(c))
          {
            *(pointer_to_history_line++)= escape_char; *(pointer_to_history_line++)= c;
          }
          else *(pointer_to_history_line++)= c;
        }
      }
      else
      {
        memcpy(pointer_to_history_line, pcv, pcv.size());
        pointer_to_history_line+= pcv.size();
      }
      memset(pointer_to_history_line, ' ', margin);
      pointer_to_history_line+= margin;
#if (OCELOT_IMPORT_EXPORT == 1)
      if (file_name != NULL)
      {
        if (is_to_be_enclosed == true)
        {
          strcpy(pointer_to_history_line, export_columns_enclosed_by.constData());
          pointer_to_history_line+= export_columns_enclosed_by.size();
        }
        if ((col < (history_result_column_count - 1)) || (export_last == 1))
        {
          strcpy(pointer_to_history_line, export_columns_terminated_by.constData());
          pointer_to_history_line+= export_columns_terminated_by.size();
        }
      }
      else
#endif
      *(pointer_to_history_line++)= '|';
      row_pointer+= column_length;
    }
#if (OCELOT_IMPORT_EXPORT == 1)
    if ((file_name != NULL) && (export_type != TOKEN_KEYWORD_DEFAULT))
    {
      strcpy(pointer_to_history_line, export_lines_terminated_by.constData());
    }
    else
#endif
    {
      *(pointer_to_history_line)= '\n'; *(pointer_to_history_line + 1)= '\0'; }
#if (OCELOT_IMPORT_EXPORT == 1)
    if ((file_name != NULL) && (export_type != TOKEN_KEYWORD_DEFAULT))
    {
      copy_of_parent->history_file_write("TEE", history_line, false);
    }
    else
#endif
    {
      s.append(history_line);
    }
  }
#if (OCELOT_IMPORT_EXPORT == 1)
  if (file_name != NULL)
  {
    if (export_divider == 1) copy_of_parent->history_file_write("TEE", divider_line, false);
  }
  else
    s.append(divider_line);
#else
  s.append(divider_line);
#endif
  if (history_line != 0) delete [] history_line;
  if (divider_line != 0) delete [] divider_line;
  if (history_max_column_widths != 0) delete [] history_max_column_widths;
  return s;
}

/* Called from ocelot_column_size_calc() or copy_html_cell() */
/* Todo: if it's "default" I'm not sure what to do. */
int get_cell_width_or_height_as_int(QString cell_width_or_height_as_qstring, int min)
{
  int cell_width_or_height_as_int;
  char tmp[64];
  strcpy(tmp, cell_width_or_height_as_qstring.toUtf8());
  cell_width_or_height_as_int= cell_width_or_height_as_qstring.toInt();
  //if (cell_width_or_height_as_int > 0)
  {
    if (cell_width_or_height_as_int > 1000) cell_width_or_height_as_int= 1000; /* arbitrary maximum */
    if (cell_width_or_height_as_int < min) cell_width_or_height_as_int= min; /* arbitrary minimum */
  }
  return cell_width_or_height_as_int;
}


/*
  Thoughts about ocelot_vertical
  ------------------------------

  This is a row with headings-at-top.
  +-------+---------+-----------+
  |  A    |   B     |   C       |
  +-------+---------+-----------+
  | 1111  | 2222    | 3333      |
  +-------+---------+-----------+
  This is the same row with headings-at-left.
  +-------+---------------------+
  | A     |  1111               |
  | B     |  2222               |
  | C     |  3333               |
  +-------+---------------------+
  Headings-at-top is default.
  Headings-at-left is what you get with \G.
  There could also be a menu item to "pivot".
  ? Should the right edge be ragged if headings-at-left?

  Other headings settings:
    Headings suppressed
    Heading width maximum (lines)
    Heading height maximum (lines)

  ? Re-use text_edit_frames[].

  But, for this test, all we'll do is
  put up one row.
  Todo: expandable widgets (drag lines again?)
  Todo: stretch factors?
  Todo: scroll bar
  Todo: sometimes you don't want width(), you want frameGeometry().width()
*/

/*
  Re grid_row_heights
  The height can be "default",
  or changed by SET ocelot_grid_cell_height=n;
  or changed by SET ocelot_grid_cell_height=n WHERE condition;
  or changed by dragging.
  We've said grid_rows_heights[1000] but in fact it should just be the max number of rows in the display.
  Todo: reset whenever there is scrolling so any changes due to dragging are negated.
        (to preserve changes due to dragging we'd have to have an item for every row in the result set).
  Flaw: we have no way to change the height after we output the columns, do we?
*/

/*
  grid_column_size_calc()
  Given column lengths in characters, calculate widths+heights in pixels.
  We aren't using defined width -- we went through the rows earlier and
  know what the maximum actual width is for each column.
  So let's give each column exactly what it needs, and perform a
  "squeeze" (reducing big columns) until the rows will fit, or until
  there's nothing more that can be squeezed. The text_edit_frame will
  be wider+higher than the text_edit_widget because it also has the
  drag line and the border.
  In order to support drag lines and variable-height columns, we have to
  calculate cell sizes ourselves. There were surprise difficulties:
  * Qt will decide there isn't enough space in a cell even if the
    total character-widths and/or character-heights would fit; the
    only solution that I found was to turn off the horizontal and
    vertical scrolls "Qt::ScrollBarAlwaysOff)", and turn the vertical
    scroll bar back on "Qt::ScrollBarAsNeeded)" only when our own
  * Qt has a left margin setting which I didn't know about, see the line
    text_edit_widgets[i_cp]->document()->setDocumentMargin(0);
  * There are bugs for some Qt versions and platforms.
     Mono fonts seem to be more susceptible. Perhaps outline-versus-bitmap is a hint too.
     Courier New is particularly awful, and we don't seem to be the only ones who've noticed, see
     https://bitbucket.org/equalsraf/vim-qt/issues/59/undercurl-underline-or-even-underscore-not
     Incomprehensibly, sometimes leading and descent can be negative.
     See also https://bugreports.qt.io/browse/QTBUG-15974 (didn't help).
  Todo: For italic|oblique we double the width, but for some fonts
        e.g. Ubuntu mono it's not necessary. Discourage italic|oblique.
  Todo: There has to be some maximum size, perhaps a user setting.
  Todo: If contents are not plaintext, HTML can cause chaos. We allow
        HTML because its effects might be what users want to see, for
        example "select '<i>HELLO</i>';" really shows in italics. But
        our calculator won't detect markup that changes character sizes.
  Todo: The calculator won't detect line feeds or other control
        characters, which change height. But I'm not worried about
        <cr>, it should only cause an elider.
  Todo: Allow expansion if ctrl-+.
  Todo: All calculations are for text. Images work, but that's luck.
  Todo: Maximum line width and maximum lines per row aren't user settable.
  Todo: We calculate column width based on the width of 'W'. For fixed
        fonts this is of course correct since all characters have the
        same width. But for non-fixed fonts, if the column is numeric,
        we know that there is no wide character like 'W' so we can
        calculate a smaller maximum character width, but beware of 'NULL'.
        And for non-fixed fonts, maybe some obscure non-Latin characters
        are wider than 'W'.
  Todo: Depending on font() may be wrong because font() is only what
        was requested not what is actual, so things might be more reliable
        if we used fontInfo() then created a font based on that and then
        used QFontMetrics.
  Todo: Allow different cells to have different fonts.
  Todo: Sometimes we recalculate after font change, but not always.
        Therefore sometimes font change will cause an existing grid
        to look ugly, and users can only fix it by redoing the query.
  Todo: see if some non-fixed-font characters are wider than "W".
  Todo: Our minimum width is the header width, or, when the header width
        is short|unstated, the width of one character + the width of a
        vertical scroll bar (which we assume is always the same).
        Maybe there should be a user-settable minimum column width.
        Or there should be a minimum for the sake of elide.
  Todo: Header height calculation should differ from ordinary-row height
        calculation, but shouldn't be done in a different place.
  Todo: Japanese kanji, size 40, Ubuntu mono, needed another pixel,
        has no top margin i.e. it hugs the top border.
  Todo: if you ever do Windows or Mac OS, you'll have to revisit this.
  Re ocelot_grid_cell_width:
    This is undocumented but one can say SET ocelot_grid_cell_width='number' (otherwise it's 'default').
    If it's in a sensible range, all cells should have that width except ones with longer column names.
    If it's 'max' we don't squeeze.
    Similar for ocelot_grid_cell_height.
  Todo: Maybe instead of max_desired_width_in_pixels we should be looking at result_grid_width_after_last_resize
*/
void grid_column_size_calc(int setting_ocelot_grid_cell_border_size_as_int,
                           int setting_ocelot_grid_cell_drag_line_size_as_int,
                           unsigned short int is_using_column_names,
                           int connections_dbms)
{
  unsigned int i;
  /* unsigned int tmp_column_lengths[MAX_COLUMNS]; */
  unsigned int sum_tmp_column_lengths;
  unsigned int sum_amount_reduced;
  unsigned int necessary_reduction;
  unsigned int amount_being_reduced;
  unsigned int max_reduction;
  QFont *pointer_to_font;
  int cell_width_as_int;
  pointer_to_font= &result_grid_font;

  /* 2020-07-01 Some calculations here were replaced by settings_change_calc() */

  QFontMetrics mm= QFontMetrics(*pointer_to_font);

  /* max_height_of_a_char= mm.lineSpacing(); didn't work */
  max_height_of_a_char= abs(mm.leading()) + abs(mm.ascent()) + abs(mm.descent());


  cell_width_as_int= get_cell_width_or_height_as_int(copy_of_parent->ocelot_grid_cell_width, character_count_to_pixel_count(MIN_WIDTH_IN_CHARS));
  if ((cell_width_as_int > 0)
   && (QString::compare("default", copy_of_parent->ocelot_grid_cell_width, Qt::CaseInsensitive) != 0))
  {
    for (i= 0; i < gridx_column_count; ++i) grid_column_widths[i]= cell_width_as_int;
    /* Todo: This does nothing about about vertical */
  }
  else
  {

    sum_tmp_column_lengths= 0;

    /*
      The first approximation
      Take it that grid_column_widths[i] = max actual column width.
      If this is good enough, then grid_row_heights[i] = 1 char
      and column width = grid_column_widths[i] chars.
    */
    for (i= 0; i < gridx_column_count; ++i)
    {
      if ((is_using_column_names != 0) && (i < result_column_count))
      {
        /* probably this->mysql_fields[i].name_length */
        grid_column_widths[i]= 0;
        char tmp[1024];
        unsigned int l= dbms_get_field_name_length(i, connections_dbms);
        strncpy(tmp, dbms_get_field_name(i, connections_dbms).toUtf8(), l);
        set_max_column_width(l, tmp, &grid_column_widths[i]);
        //grid_column_widths[i]= dbms_get_field_name_length(i, connections_dbms);
      }
      else grid_column_widths[i]= 1;
      /*
        For some reason -- I never figured it out -- if column width < MIN_WIDTH_IN_CHARS
        and there is a drag line, the drag line disappears.
        If vertical != 0 I compensate for too-short contents a different way.
      */
      if ((grid_column_widths[i] < MIN_WIDTH_IN_CHARS) && (setting_ocelot_grid_cell_drag_line_size_as_int > 0))
        grid_column_widths[i]= MIN_WIDTH_IN_CHARS;
      if (grid_column_widths[i] < gridx_max_column_widths[i]) grid_column_widths[i]= gridx_max_column_widths[i]; /* fields[i].length */
      grid_column_widths[i]= grid_column_widths[i] * setting_max_width_of_a_char
                             + setting_bearing
                             + setting_ocelot_grid_cell_border_size_as_int * 2;
      sum_tmp_column_lengths+= grid_column_widths[i];
    }

    /*
      The Squeeze
      This cuts the widths of the really long columns, it might loop several times.
      This is a strong attempt to reduce to the user-settable maximum, but if we have to override it, we do.
      Cannot squeeze to less than header length
    */
    sum_amount_reduced= 1;

    if (copy_of_parent->ocelot_grid_cell_width != "max")
    {
      while ((sum_tmp_column_lengths > ocelot_grid_max_desired_width_in_pixels) && (sum_amount_reduced > 0))
      {
        necessary_reduction= sum_tmp_column_lengths - ocelot_grid_max_desired_width_in_pixels;
        necessary_reduction-= necessary_reduction % setting_max_width_of_a_char;
        sum_amount_reduced= 0;
        for (i= 0; i < gridx_column_count; ++i)
        {
          unsigned int min_width;
          QString s_header= dbms_get_field_name(i, connections_dbms);
          min_width= get_column_width_in_pixels(s_header, true, false);
          if (grid_column_widths[i] <= min_width) continue;
          max_reduction= grid_column_widths[i] - min_width;
          max_reduction-= max_reduction % setting_max_width_of_a_char;
          if (grid_column_widths[i] >= (sum_tmp_column_lengths / gridx_column_count))
          {
            amount_being_reduced= grid_column_widths[i] / 2;
            amount_being_reduced-= amount_being_reduced % setting_max_width_of_a_char;
            if (amount_being_reduced > necessary_reduction) amount_being_reduced= necessary_reduction;
            if (amount_being_reduced > max_reduction) amount_being_reduced= max_reduction;
            grid_column_widths[i]= grid_column_widths[i] - amount_being_reduced;
            sum_amount_reduced+= amount_being_reduced;
            necessary_reduction-= amount_being_reduced;
            sum_tmp_column_lengths-= amount_being_reduced;
          }
          if (necessary_reduction <= setting_max_width_of_a_char) break; /* todo: consider making this "< 10" */
        }
      }
    }
  }
  grid_actual_row_height_in_lines= 1;
#ifdef OLD_STUFF
  /*
    Each column's height = (gridx_max_column_widths[i] i.e. actual max) / grid_column_widths[i] rounded up.
    If that's greater than the user-defined maximum, reduce to user-defined maximum
    The QTextEdit will get a vertical scroll bar if there's an overflow,
  */

  for (i= 0; i < gridx_column_count; ++i)
  {
    grid_column_heights[i]= (gridx_max_column_widths[i] * setting_max_width_of_a_char) / grid_column_widths[i]; /* mysql_fields[i].length */
    if ((grid_column_heights[i] * grid_column_widths[i]) < (gridx_max_column_widths[i] * setting_max_width_of_a_char))
    {
      ++grid_column_heights[i];
    }
    if (grid_column_heights[i] == 0) ++grid_column_heights[i];
    if (grid_column_heights[i] > ocelot_grid_max_column_height_in_lines) grid_column_heights[i]= ocelot_grid_max_column_height_in_lines;
    if (grid_column_heights[i] > grid_actual_row_height_in_lines) grid_actual_row_height_in_lines= grid_column_heights[i];
  }

  /* Warning: header_height is also calculated like this but in a different place. */
  for (i= 0; i < gridx_column_count; ++i)
  {
    grid_column_heights[i]= (grid_column_heights[i] * max_height_of_a_char)
                            + setting_ocelot_grid_cell_border_size_as_int * 2
                            + setting_ocelot_grid_cell_drag_line_size_as_int;
  }
#endif
  /* TODO: This is supposed to be only for # of rows in the grid */
  int cell_height_as_int;
  cell_height_as_int= get_cell_width_or_height_as_int(copy_of_parent->ocelot_grid_cell_height, max_height_of_a_char);
  if (cell_height_as_int > 0)
  {
    for (i= 0; i < 1000; ++i) grid_row_heights[i]= cell_height_as_int;
    /* Todo: This does nothing about vertical */
  }

  grid_column_size_calc_vertical(is_using_column_names, connections_dbms);
}

/*
  The variant of grid_column_size_calc() that we use if ocelot_vertical == 1.
  We should have called grid_column_size_calc() earlier and we won't change what that produced.
  But we now need, for HTML at least, only two widths:
  header_width = based on width of longest field name, can be 0 if is_using_column_names == 0
  value_width = based on width of longest column value
  Squeezing will be simpler, I hope.
  I no longer care about border_size or drag_line_size.
  Set result_grid_vertical_width_of_header, result_grid_vertical_width_of_value.
*/
void grid_column_size_calc_vertical(
                           unsigned short int is_using_column_names,
                           int connections_dbms)
{
  unsigned int i;
  unsigned int sum_tmp_column_lengths;
  sum_tmp_column_lengths= 0;
  result_grid_vertical_width_of_header= 0;
  if (is_using_column_names != 0)
  {
    for (i= 0; i < result_column_count; ++i)
    {
      /* probably this->mysql_fields[i].name_length */
      unsigned int width_of_field_name_i= 0;
      char tmp[1024]; /* todo: should be max_field_name_size but I'm not positive that's been checked yet */
      unsigned int l= dbms_get_field_name_length(i, connections_dbms);
      strncpy(tmp, dbms_get_field_name(i, connections_dbms).toUtf8(), l);
      set_max_column_width(l, tmp, &width_of_field_name_i);
      if (width_of_field_name_i > (unsigned int) result_grid_vertical_width_of_header) result_grid_vertical_width_of_header= width_of_field_name_i;
    }
  }
  result_grid_vertical_width_of_value= 0;
  for (i= 0; i < result_column_count; ++i)
  {
    int width_of_field_value_i= 0;
    if (result_max_column_widths[i] < MIN_WIDTH_IN_CHARS) width_of_field_value_i= MIN_WIDTH_IN_CHARS;
    else width_of_field_value_i= gridx_max_column_widths[i];
    if (width_of_field_value_i > result_grid_vertical_width_of_value) result_grid_vertical_width_of_value= width_of_field_value_i;
  }
  result_grid_vertical_width_of_header= character_count_to_pixel_count(result_grid_vertical_width_of_header);
  result_grid_vertical_width_of_value= character_count_to_pixel_count(result_grid_vertical_width_of_value);
  sum_tmp_column_lengths= result_grid_vertical_width_of_header + result_grid_vertical_width_of_value;
  if (sum_tmp_column_lengths > ocelot_grid_max_desired_width_in_pixels)
  {
    result_grid_vertical_width_of_header= (result_grid_vertical_width_of_header * ocelot_grid_max_desired_width_in_pixels) / sum_tmp_column_lengths;
    result_grid_vertical_width_of_value= (result_grid_vertical_width_of_value * ocelot_grid_max_desired_width_in_pixels) / sum_tmp_column_lengths ;
  }
  if (result_grid_vertical_width_of_header < character_count_to_pixel_count(MIN_WIDTH_IN_CHARS))
    result_grid_vertical_width_of_header= character_count_to_pixel_count(MIN_WIDTH_IN_CHARS);
  if (result_grid_vertical_width_of_value < character_count_to_pixel_count(MIN_WIDTH_IN_CHARS))
    result_grid_vertical_width_of_value= character_count_to_pixel_count(MIN_WIDTH_IN_CHARS);
}

#if (OCELOT_MYSQL_INCLUDE == 1)
/*
  Make a copy of mysql_res.
    It's insane that I have to make a copy of what was in mysql_res, = result_set_copy.
    But things get complicated if there are multiple result sets i.e. if mysql_more_results is true.
    Also, after the copy, we're less (or not at all?) dependent on calls to MySQL functions.
  For each column, we have: (unsigned int) length, (char) unused or null flag, (char[n]) contents.
  We want max actual length too.
*/
void scan_rows(unsigned int p_result_column_count,
               unsigned int p_result_row_count,
               MYSQL_RES *p_mysql_res,
               char **p_result_set_copy,
               char ***p_result_set_copy_rows,
               unsigned int **p_result_max_column_widths)
{
  unsigned long int v_r;
  unsigned int i;
  MYSQL_ROW v_row;
  unsigned long *v_lengths;
//  unsigned int ki;

  for (i= 0; i < p_result_column_count; ++i) (*p_result_max_column_widths)[i]= 0;

  /*
    First loop: find how much to allocate. Allocate. Second loop: fill in with pointers within allocated area.
  */
  unsigned int total_size= 0;
  char *result_set_copy_pointer;
  lmysql->ldbms_mysql_data_seek(p_mysql_res, 0);
  for (v_r= 0; v_r < p_result_row_count; ++v_r)                                /* first loop */
  {
    v_row= lmysql->ldbms_mysql_fetch_row(p_mysql_res);
    v_lengths= lmysql->ldbms_mysql_fetch_lengths(p_mysql_res);
    for (i= 0; i < p_result_column_count; ++i)
    {
//      ki= (v_r + 1) * result_column_count + i;
      if ((v_row == 0) || (v_row[i] == 0))
      {
        total_size+= sizeof(unsigned int) + sizeof(char);
        //total_size+= sizeof(NULL_STRING) - 1;
      }
      else
      {
        if ((ocelot_client_side_functions_copy == 1)
         && (v_lengths[i] == sizeof("row_number() over ()") - 1)
         && (strncasecmp(v_row[i], "row_number() over ()", v_lengths[i]) == 0))
        {
          total_size+= sizeof(unsigned int) + sizeof(char);
          char tmp[16];
          sprintf(tmp, "%ld", v_r + 1);
          total_size+= strlen(tmp);
        }
        else
        {
          total_size+= sizeof(unsigned int) + sizeof(char);
          total_size+= v_lengths[i];
        }
      }
    }
  }
  *p_result_set_copy= new char[total_size];                                              /* allocate */
  *p_result_set_copy_rows= new char*[p_result_row_count];
  result_set_copy_pointer= *p_result_set_copy;
  lmysql->ldbms_mysql_data_seek(p_mysql_res, 0);

  for (v_r= 0; v_r < p_result_row_count; ++v_r)                                 /* second loop */
  {
    (*p_result_set_copy_rows)[v_r]= result_set_copy_pointer;
    v_row= lmysql->ldbms_mysql_fetch_row(p_mysql_res);
    v_lengths= lmysql->ldbms_mysql_fetch_lengths(p_mysql_res);
    for (i= 0; i < p_result_column_count; ++i)
    {
      if ((v_row == 0) || (v_row[i] == 0))
      {
        if (sizeof(NULL_STRING) - 1 > (*p_result_max_column_widths)[i]) (*p_result_max_column_widths)[i]= sizeof(NULL_STRING) - 1;
        memset(result_set_copy_pointer, 0, sizeof(unsigned int));
        *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_NULL;
        result_set_copy_pointer+= sizeof(unsigned int) + sizeof(char);
      }
      else
      {

        if ((ocelot_client_side_functions_copy == 1)
         && (v_lengths[i] == sizeof("row_number() over ()") - 1)
         && (strncasecmp(v_row[i], "row_number() over ()", v_lengths[i]) == 0))
        {
          char tmp[16];
          sprintf(tmp, "%ld", v_r + 1);
          unsigned int v_length= strlen(tmp);
          //if (v_length > (*p_result_max_column_widths)[i]) (*p_result_max_column_widths)[i]= v_length;
          set_max_column_width(v_length, tmp, (&(*p_result_max_column_widths)[i]));
          memcpy(result_set_copy_pointer, &v_length, sizeof(unsigned int));
          *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_ZERO;
          result_set_copy_pointer+= sizeof(unsigned int) + sizeof(char);
          memcpy(result_set_copy_pointer, tmp, v_length);
          result_set_copy_pointer+= v_length;
        }
        else
        {
          //if (v_lengths[i] > (*p_result_max_column_widths)[i]) (*p_result_max_column_widths)[i]= v_lengths[i];
          set_max_column_width(v_lengths[i], v_row[i], (&(*p_result_max_column_widths)[i]));
          memcpy(result_set_copy_pointer, &v_lengths[i], sizeof(unsigned int));
          *(result_set_copy_pointer + sizeof(unsigned int))= FIELD_VALUE_FLAG_IS_ZERO;
          result_set_copy_pointer+= sizeof(unsigned int) + sizeof(char);
          memcpy(result_set_copy_pointer, v_row[i], v_lengths[i]);
          result_set_copy_pointer+= v_lengths[i];
        }
      }
    }
  }
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

/*
  Pass: pointer to + length of a field in the result set, plus char[4] img_type.
  Do: put in img_type: "" or "png" or "jpg" or "gif".
*/
void set_img_type(const char *pointer, unsigned int v_length, char *img_type)
{
  img_type[0]= '\0';
  if (v_length > 4)
  {
    if (strncmp(pointer,"\x89PNG",4) == 0) strcpy(img_type, "png");
    else if (strncmp(pointer,"\xFF\xD8",2) == 0) strcpy(img_type, "jpg");
    else if (strncmp(pointer,"GIF",3) == 0) strcpy(img_type, "gif");
    /* to: try BMP? check with loadFromData()? */
  }
}

/*
  How many UTF-8 characters are there, maximum?
  This is more important for a width calculation than length in bytes.
  The following doesn't do a great job -- I wanted to get it right for
  Latin special characters and Greek or Cyrillic or other alphabets --
  so it misses combining characters and it mishandles Chinese|Japanese
  characters which sometimes are wide. Essentially the algorithm is:
  count all the ASCII and continuation bytes, don't count leading bytes.
  Don't bother if the length can't be greater than the current maximum.
  Re images:
    We're assuming that anything starting with png|jpg|gif header is png_jpg_gif (which might be wrong).
    We're assuming that any png_jpg_gif should be displayed as an image (which might be wrong).
    We're assuming that a 50-character width is better than v_length (which is arbitrary).
    We're assuming that it's not wide enough then Qt will widen it.
    Todo: one better way would be to let the user specify a number other than 50.
    Todo: one better way would be to figure out the width and height in pixels from the image's header.
     https://stackoverflow.com/questions/16724849/how-do-i-extract-the-width-and-height-of-a-png-from-looking-at-the-header-in-obj
     https://stackoverflow.com/questions/18264357/how-to-get-the-width-height-of-jpeg-file-without-using-library
     https://stackoverflow.com/questions/41670780/how-to-get-the-gif-image-size-dimensions-from-byte-array-in-as3/41672182
  Todo: we're not doing this if vertical!
  Todo: The "++i;" in this code exists so that 3-byte UTF-8 will
        result in double-wide, which seems okay for Japanese kanji.
        But it's ridiculous! Surely many 3-byte UTF-8 characters
        (U+0800 and beyond) are not double-wide, surely some
        2-byte UTF-8 characters are double-wide. For details see
        http://unicode.org/reports/tr11/, http://www.unicode.org/Public/5.2.0/ucd/EastAsianWidth.txt,
        http://stackoverflow.com/questions/3634627/how-to-know-the-preferred-display-width-in-columns-of-unicode-characters
*/
void set_max_column_width(unsigned int v_length,
                         const char *result_set_copy_pointer,
                         unsigned int *p_result_max_column_width)
{
  if (v_length <= *p_result_max_column_width) return;
  unsigned int j= v_length;
  char img_type[4];
  set_img_type(result_set_copy_pointer, v_length, img_type); /* so img_type = "" or "png" or "jpg" or "gif" */
  if (img_type[0] != '\0') j= 50;
  else
  {
    for (unsigned int i= 0; i < v_length; ++i)
    {
      if (( *(result_set_copy_pointer + i)   & 0xc0) == 0x80)
      {
        --j;
        ++i;
      }
    }
  }
  if (j > *p_result_max_column_width) *p_result_max_column_width= j;
}

#if (OCELOT_MYSQL_INCLUDE == 1)
/*
  Using the same technique as in scan_rows, make a copy of field names.

  Todo: This (length,data,length,data,length,data...) is a bad way to
  store because we have to scan X entries in order to find field X name.
  This would be better: (pointer,pointer,pointer,...data,data,data...).

  MYSQL_FIELD has: name, org_name, org_table, db. We only need name for result set
  display, but we need the others if user edits the result set (see TextEditWidget::keyPressEvent).
  Todo: we could try going through the token list to find this out, but it's tough
  to watch for AS clauses + UNIONs + expressions + which-field-is-which-table, and
  I'm not sure what would occur when the SELECT is inside a stored procedure.
*/
void scan_field_names(
               const char *which_field,
               unsigned int p_result_column_count,
               char **p_result_field_names)
{
  unsigned int i;
  unsigned int v_lengths;

  /*
    First loop: find how much to allocate. Allocate. Second loop: fill in with pointers within allocated area.
  */
  unsigned int total_size= 0;
  char *result_field_names_pointer;

  for (i= 0; i < p_result_column_count; ++i)                                /* first loop */
  {
      total_size+= sizeof(unsigned int);
      if (strcmp(which_field, "name") == 0) total_size+= mysql_fields[i].name_length;
      else if (strcmp(which_field, "org_name") == 0) total_size+= mysql_fields[i].org_name_length;
      else if (strcmp(which_field, "org_table") == 0) total_size+= mysql_fields[i].org_table_length;
      else /* if (strcmp(which_field, "db") == 0) */ total_size+= mysql_fields[i].db_length;
  }
  *p_result_field_names= new char[total_size];                               /* allocate */

  result_field_names_pointer= *p_result_field_names;
  for (i= 0; i < p_result_column_count; ++i)                                 /* second loop */
  {
    if (strcmp(which_field, "name") == 0) v_lengths= mysql_fields[i].name_length;
    else if (strcmp(which_field, "org_name") == 0) v_lengths= mysql_fields[i].org_name_length;
    else if (strcmp(which_field, "org_table") == 0) v_lengths= mysql_fields[i].org_table_length;
    else /* if (strcmp(which_field, "db") == 0) */ v_lengths= mysql_fields[i].db_length;
    memcpy(result_field_names_pointer, &v_lengths, sizeof(unsigned int));
    result_field_names_pointer+= sizeof(unsigned int);
    if (strcmp(which_field, "name") == 0) memcpy(result_field_names_pointer, mysql_fields[i].name, v_lengths);
    else if (strcmp(which_field, "org_name") == 0) memcpy(result_field_names_pointer, mysql_fields[i].org_name, v_lengths);
    else if (strcmp(which_field, "org_table") == 0) memcpy(result_field_names_pointer, mysql_fields[i].org_table, v_lengths);
    else /* if (strcmp(which_field, "db") == 0) */ memcpy(result_field_names_pointer, mysql_fields[i].db, v_lengths);
    result_field_names_pointer+= v_lengths;
  }
}
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

#ifdef OLD_STUFF
/*
   Set alignment and height of a cell.
   Todo: There's a terrible amount of duplication:
   We only call this if vertical != 0.
   We call at start and every time we scroll.
   We allow width to vary but we don't allow it to be more than half of result grid width.
   Todo: pass flags so I don't have to check so many field types
   Todo: the name is bad, now we set width here too
*/
int set_alignment_and_height(int text_edit_frames_index, unsigned int grid_row, int field_type,
                              bool is_header, int maximum_width)
{
  TextEditWidget *cell_text_edit_widget= text_edit_widgets[text_edit_frames_index];
  /* Todo: probably MySQL should be done the same way as Tarantool, no need to check field_type */
  /* Todo: maybe it would be better to check content_field_value_flags & FIELD_VALUE_FLAG_IS_NUMBER */
  if ((field_type <= OCELOT_DATA_TYPE_DOUBLE)
   || (field_type == OCELOT_DATA_TYPE_NEWDECIMAL)
   || (field_type == OCELOT_DATA_TYPE_LONGLONG)
   || (field_type == OCELOT_DATA_TYPE_INT24))
    text_align(cell_text_edit_widget, Qt::AlignRight);
  else text_align(cell_text_edit_widget, Qt::AlignLeft);
  QString s;
  if (text_edit_frames[text_edit_frames_index]->content_pointer == 0) /* or check content_field_value_flags */
  {
    s= QString::fromUtf8(NULL_STRING, sizeof(NULL_STRING) - 1);
  }
  else s= QString::fromUtf8(text_edit_frames[text_edit_frames_index]->content_pointer, text_edit_frames[text_edit_frames_index]->content_length);
  int width= get_column_width_in_pixels(s, is_header, text_edit_frames[text_edit_frames_index]->is_image_flag);

  /* Test: will we override? */
  QString new_tooltip= "";
  QString new_style_sheet= copy_of_parent->ocelot_grid_style_string;
  QString new_cell_height= "";
  QString new_cell_width= "";
  int returned_cs_number= 0;
  bool result= conditional_setting_evaluate_till_true(
       text_edit_frames[text_edit_frames_index]->ancestor_grid_column_number,
       text_edit_frames[text_edit_frames_index]->ancestor_grid_result_row_number,
       text_edit_frames[text_edit_frames_index]->content_pointer,
       text_edit_frames[text_edit_frames_index]->content_length,
       text_edit_frames[text_edit_frames_index]->cell_type,
       &new_tooltip, &new_style_sheet, &new_cell_height, &new_cell_width, &returned_cs_number);
  if (result == true)
  {
    if (new_cell_width.toInt() > 0)
    {
      width= new_cell_width.toInt();
    }
  }

  if (width > maximum_width) width= maximum_width;

  text_edit_frames[text_edit_frames_index]->setFixedWidth(width);

  /* Height border size = 1 due to setStyleSheet earlier; right border size is passed */
//  if (xrow == 0)
//  {
//    int header_height= max_height_of_a_char
//                     + setting_ocelot_grid_cell_border_size_as_int * 2
//                     + setting_ocelot_grid_cell_drag_line_size_as_int;
//    if (setting_ocelot_grid_cell_drag_line_size_as_int > 0) header_height+= max_height_of_a_char;
//    text_edit_frames[xrow * gridx_column_count + col]->setFixedSize(grid_column_widths[col], header_height);
//    text_edit_frames[xrow * gridx_column_count + col]->setMaximumHeight(header_height);
//    text_edit_frames[xrow * gridx_column_count + col]->setMinimumHeight(header_height);
//  }
//  else
  {
    //int this_width;
    //if (grid_col == 0)
    //{
    //  /* Todo: this should be based on QFontMetrics, 20 is so arbitrary */
    //  this_width= (20) * (text_edit_frames[ki]->content_length + 1);
    //}
    //else
    //this_width= grid_column_widths[grid_col];
    //frame_resize(text_edit_frames_index, grid_col, this_width, grid_column_heights[grid_col]);

    if ((result == true) && (new_cell_height > ""))
    {
      text_edit_frames[text_edit_frames_index]->setFixedHeight(new_cell_height.toInt());
      grid_row_widgets[grid_row]->setFixedHeight(new_cell_height.toInt());
    }
    else
    {
      int h= set_height(text_edit_frames_index, width);
      grid_row_widgets[grid_row]->setFixedHeight(h);
    }
  }

  return width;
}
#endif

#ifdef OLD_STUFF
/*
  Set height of a cell.
  Before we display we proportionally allocate column widths, they stay the same.
  But column height varies with text length and \n, Asian long characters, html.
  We use a Qt routine which effectively handles "given text and width, return height".
  If height > maximum i.e. grid_max_column_height_in_pixels:
    Set to maximum and turn on vertical scrollbar i.e. Qt::ScrollBarAlwaysOn.
    So clicking resultgrid vertical scroll bar goes up/down per row,
    but finer movement can be done on a cell's vertical scroll bar.
    See frame_resize() for how it can be done.
  I think height < minimum i.e. line height is impossible since we start with line height.
  We don't change text_edit_widgets[], it seems to adjust automatically.
  We change grid_row_widgets[] later, to the height of the highest text_edit_frame.
  text_edit_frame[] is QFrame.
  Re: With font size > 32, select "id", "owner", "name" from "_space" limit 1;
      has not enough height by 1 or 2 pixels, if family = Chandas | Jamrul | Khmer OS | Umpush.
      And has missing drag lines if Abyssinica SIL | Carlito | DejaVu Math Tex Gyre.
      The hight problem happens because height within result grid is too high.
      It disappears if you detach result grid and make result grid larger.
  Re italic|oblique: As the Qt manual says, boundingRect() can ignore a font's
     leftBearing and rightBearing, so it might calculate that there are N characters on a
     line but at display time there are N-minus-1 characters on a line. Therefore, add "W"
     for every line that height indicates, and repeat. Todo: any better ideas?
  Re width. What we pass is text_edit_frames[...]->width()) not text_edit_widgets[...].width().
     So what we can actually fit is passed frame width - (border width * 2 + drag line width).
  Todo: see set_alignment_and_height, we probably don't need both functions.
  Todo: flags could include Qt::TextWordWrap QT::TextDontClip etc. if we specified thus.
  Todo: are you sure you know the width? Maybe you should be using max column widths?
        (or maybe not, because there can be dragging)
  TODO: We should use a similar trick for column width when we make the initial calculation.
        If it's a header, then width calculation should be based on the trick. But for rows,
        it would take too long. Unless we based on a sampling.
  Todo: Find out why "text_edit_frames[ki]->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);" did nothing
  Todo: Should is_paintable still be off?
  Todo: Test: what if string length exceeds the maximum?
  Todo: Test: Kanji with large font. Seems okay now.
  Todo: Notice assumption that setting_ocelot_grid_cell_border_size_as_int is current. Is that correct?
        No. When we change border_size and drag_line_size, we do not immediately adjust
        as we do for changes in size or font
        (Border and drag line are taken into account correctly for the next time we select)
  TODO: SELECT '<font color="red" size="+10">Big Red Text</font>' AS x;
        won't see the size change (probably same problem with <big> etc.).
        because Qt font metrics are based on result_grid_font only.
        "Red" is okay. Turning off HTML can be done with <pre> but maybe there's a better way.
  Todo: Beware images i.e. is_image_flag == true.
  Todo: This is good for headers too because
        () scrollbar might still be on for the cell, we don't clear until we get here
        () if it contains \n then we want it to have a scroll bar, but its maximum is 1 line
        We say max heading height is 1 line, that's arbitrary.
        Bug: I can make the scroll bar appear, but cannot scroll unless I drag.
             Or, if header width > 3, I can scroll.
  Todo: The "for (int i= 0; i < 2; ++i)" loop for italics might not be necessary.
  Todo: Rules differ for vertical != 0.
*/
int get_column_height_in_pixels(unsigned int text_edit_frames_index, int width, int copy_of_grid_max_column_height_in_pixels)
{
  unsigned int height;
  QFontMetrics result_grid_font_metrics= QFontMetrics(result_grid_font);
  if (text_edit_frames[text_edit_frames_index]->is_image_flag)
  {
    height= 2000; /* arbitrary big maximum */
  }
  else
  {
    QRect r;
    r= text_edit_frames[text_edit_frames_index]->rect();
    QString s;

    if (text_edit_frames[text_edit_frames_index]->content_pointer == 0) /* or check content_field_value_flags */
    {
      s= QString::fromUtf8(NULL_STRING, sizeof(NULL_STRING) - 1);
    }
    else s= QString::fromUtf8(text_edit_frames[text_edit_frames_index]->content_pointer, text_edit_frames[text_edit_frames_index]->content_length);
    int text_edit_widget_width= width - (setting_ocelot_grid_cell_border_size_as_int * 2 + setting_ocelot_grid_cell_drag_line_size_as_int);
    QRect r2;
    /* Saying i < 1 instead of i < 2 disables the kludge for italic. Maybe we won't need it. */
    for (int i= 0; i < 2; ++i)
    {
      r2= result_grid_font_metrics.boundingRect(
          0, /* int x = x coordinate within original rect */
          0, /* int y = y coordinate within original rect */
          text_edit_widget_width, /* int width = r.width(), which we don't change */
          2000, /* int height = height, which is arbitrary big maximum */
          Qt::TextWrapAnywhere + Qt::TextIncludeTrailingSpaces, /* int flags = (see comments before start of this routine) */
          s); /* QString & text= cell contents */
      if (result_grid_font.style() == QFont::StyleNormal) break;
      int n= r2.height() / result_grid_font_metrics.lineSpacing();
      s= s + QString("W").repeated(n);
    }

    height= r2.height() + setting_ocelot_grid_cell_border_size_as_int * 2 + setting_ocelot_grid_cell_drag_line_size_as_int;
  }
  unsigned int max_column_height_in_pixels;
  if ((text_edit_frames[text_edit_frames_index]->cell_type == TEXTEDITFRAME_CELL_TYPE_HEADER)
   && (ocelot_vertical_copy == 0))
  {
    max_column_height_in_pixels= result_grid_font_metrics.lineSpacing();
  }
  else
  {
    max_column_height_in_pixels= copy_of_grid_max_column_height_in_pixels;
  }
  if (height > max_column_height_in_pixels)
  {
    height= max_column_height_in_pixels;
    text_edit_widgets[text_edit_frames_index]->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
  }
  else
    text_edit_widgets[text_edit_frames_index]->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
  return height;
}
#endif

#ifdef OLD_STUFF
/*
  Todo: possible better names: set_column_height_in_pixels, set_cell_height_in_points
*/
int set_height(unsigned int text_edit_frames_index, int width)
{
  int height= get_column_height_in_pixels(text_edit_frames_index,
                                          width,
                                          grid_max_column_height_in_pixels);

  text_edit_frames[text_edit_frames_index]->setFixedHeight(height);
  //text_edit_widgets[text_edit_frames_index]->setFixedHeight(height);

  //TextEditWidget *text_edit= text_edit_frames[text_edit_frames_index]->findChild<TextEditWidget *>();
  //text_edit_widgets[text_edit_frames_index]->setFixedHeight(nn - 20);
  return height;
}
#endif

/*
  Get column width in pixels.
  Use boundingRect() as you did for set_height() but this time column width isn't fixed.
  I plan to use this for header width calculation.
  The question is: how many pixels do we need to fit this string in a cell,
  given current result_grid_font and border and drag line?
  We do not check maximum size here.
  Re images: They have no characters so there's no point getting a font and checking width that way.
             I could make a QPixMap and call loadFromData() then ask width() but fear that's slow.
             So for them I just return an arbitrary big value and assume they will be clipped
             depending on result grid size.
  Todo: See if it's okay to use this for detail rows.
        Answers would be better but I worry that it would be slow.
  Todo: What you really need is:
        Use the trick for set_max_column_width().
        Divide by width("W") which should be okay because later you'll multiply by width("W").
        Or: max_column_widths should be in pixels.
            The thing that's stopping me is I'm not sure whether we recalculate for font changes.
        Or: for a particular UTF8 character, decide if it's double-width by calling width().
*/
int get_column_width_in_pixels(QString s, bool is_header, bool is_image_flag)
{
  if (is_image_flag) return 2000; /* arbitrary big maximum */
  QFontMetrics result_grid_font_metrics= QFontMetrics(result_grid_font);
  QRect r2= result_grid_font_metrics.boundingRect(
                                   0, /* int x = x coordinate within original rect */
                                   0, /* int y = y coordinate within original rect */
                                   2000, /* int width = width, which we can change */
                                   2000, /* int height = height, which is arbitrary big maximum */
                                   Qt::TextWrapAnywhere + Qt::TextIncludeTrailingSpaces, /* int flags = (see comments before start of this routine) */
                                   s); /* QString & text= cell contents */
  unsigned int min_width= r2.width();

  /* Kludge alert. It's a mystery, but above min-width calculation sometimes isn't enough.
     However, increasing it should be okay if this is a detail cell and vertical != 0. */
  int really_minimal= character_count_to_pixel_count(1);
  if ((ocelot_vertical_copy != 0) && (is_header == false) && (min_width < (unsigned int) character_count_to_pixel_count(MIN_WIDTH_IN_CHARS)))
    really_minimal= character_count_to_pixel_count(MIN_WIDTH_IN_CHARS);

  if (min_width < really_minimal + scroll_bar_width + 1)
  {
    min_width= really_minimal + scroll_bar_width + 1;
  }

  min_width+= setting_ocelot_grid_cell_border_size_as_int * 2
              + setting_ocelot_grid_cell_drag_line_size_as_int;
  return min_width;
}


#ifdef OLD_STUFF
/*
  Put lengths and pointers in text_edit_frames.
  Set a flag to say "not retrieved yet", that happens at paint time.
  Todo: make a copy if there are multiple result sets.
  Todo: this points directly to a mysql_res row, ignoring the earlier clever ideas in dbms_get_field_value().
*/
/* The big problem is that setVerticalSpacing(0) goes awry if I use hide(). */
/* Todo: Think whether there's a chance that, while somebody scroll to the end,
   the hide() comes too late, i.e. a paint might occur for an invalid row.
   Maybe show() should be delayed until after hide(), or painting should be prevented for a while. */

void fill_detail_widgets(int new_grid_vertical_scroll_bar_value, int connections_dbms)
{
  unsigned int i;
  unsigned int text_edit_frames_index;
  unsigned int grid_row;
  int first_row;
  char *row_pointer;

  first_row= new_grid_vertical_scroll_bar_value;

  if (ocelot_vertical_copy != 0)
  {
    unsigned int result_column_number; /* i.e. column number in result set, not column number in grid */
    first_row= new_grid_vertical_scroll_bar_value / result_column_count;
    result_column_number= new_grid_vertical_scroll_bar_value % result_column_count;
    unsigned int new_content_length= 0;
    row_pointer= result_set_copy_rows[first_row];
    for (unsigned int j= 0; ; ++j)
    {
      memcpy(&new_content_length, row_pointer, sizeof(unsigned int));
      row_pointer+= sizeof(unsigned int) + sizeof(char);
      if (j >= result_column_number) break;
      row_pointer+= new_content_length;
    }

    /* now row_pointer -> result column, and each subsequent result column is a grid row */
    //grid_row= first_row;

    grid_row= 0;
    result_row_number= first_row;

    for (;;)
    {
      unsigned int v_lengths= 0;

      text_edit_frames_index= grid_row * gridx_column_count;
      unsigned int o_text_edit_frames_index= text_edit_frames_index;

      /* result_column_number is still known */
      //if (ocelot_client_side_functions_copy != 0)                         /* include row#? */
      //{
      //  text_edit_frames[text_edit_frames_index]->content_length= 0;
      //  text_edit_frames[text_edit_frames_index]->content_field_value_flags= 0;
      //  text_edit_frames[text_edit_frames_index]->content_pointer= 0;
      //  text_edit_frames[text_edit_frames_index]->is_retrieved_flag= false;
      //  text_edit_frames[text_edit_frames_index]->ancestor_grid_column_number= result_column_number;
      //  text_edit_frames[text_edit_frames_index]->ancestor_grid_result_row_number= result_row_number;
      //  text_edit_frames[text_edit_frames_index]->is_image_flag= false;
      //  ++text_edit_frames_index;
      //}
      if (ocelot_result_grid_column_names_copy != 0)               /* include column header? */
      {
        char *result_field_names_pointer= &result_field_names[0];
        for (unsigned int mi= 0; ; ++mi)
        {
          memcpy(&v_lengths, result_field_names_pointer, sizeof(unsigned int));
          result_field_names_pointer+= sizeof(unsigned int);
          if (mi >= result_column_number) break;
          result_field_names_pointer+= v_lengths;
        }
        text_edit_frames[text_edit_frames_index]->content_length= v_lengths;
        text_edit_frames[text_edit_frames_index]->content_pointer= result_field_names_pointer;
        text_edit_frames[text_edit_frames_index]->content_field_value_flags= 0;
        text_edit_frames[text_edit_frames_index]->is_retrieved_flag= false;
        text_edit_frames[text_edit_frames_index]->ancestor_grid_column_number= result_column_number;
        text_edit_frames[text_edit_frames_index]->ancestor_grid_result_row_number= result_row_number;
        text_edit_frames[text_edit_frames_index]->is_image_flag= false;
        ++text_edit_frames_index;
      }
      text_edit_frames[text_edit_frames_index]->content_length= new_content_length; /* include value. */
      char field_value_flags= *(row_pointer - 1);
      text_edit_frames[text_edit_frames_index]->content_field_value_flags= field_value_flags;
      if (field_value_flags == FIELD_VALUE_FLAG_IS_NULL)
      {
        text_edit_frames[text_edit_frames_index]->content_pointer= 0;
      }
      else text_edit_frames[text_edit_frames_index]->content_pointer= row_pointer;
      text_edit_frames[text_edit_frames_index]->is_retrieved_flag= false;
      text_edit_frames[text_edit_frames_index]->ancestor_grid_column_number= result_column_number;
      text_edit_frames[text_edit_frames_index]->ancestor_grid_result_row_number= result_row_number;
      if (is_extra_rule_1(result_column_number) == true)
      {
        if (text_edit_frames[text_edit_frames_index]->cell_type == TEXTEDITFRAME_CELL_TYPE_DETAIL)
        {
          text_edit_frames[text_edit_frames_index]->cell_type= TEXTEDITFRAME_CELL_TYPE_DETAIL_EXTRA_RULE_1;
          text_edit_frames[text_edit_frames_index]->is_style_sheet_set_flag= false;
        }
      }
      else
      {
        if (text_edit_frames[text_edit_frames_index]->cell_type == TEXTEDITFRAME_CELL_TYPE_DETAIL_EXTRA_RULE_1)
        {
          text_edit_frames[text_edit_frames_index]->cell_type= TEXTEDITFRAME_CELL_TYPE_DETAIL;
          text_edit_frames[text_edit_frames_index]->is_style_sheet_set_flag= false;
        }
      }
      if (is_image(result_column_number) == true)
      {
        text_edit_frames[text_edit_frames_index]->is_image_flag= true;
      }
      else text_edit_frames[text_edit_frames_index]->is_image_flag= false;

      int column_number_within_gridx= 0;

      if (ocelot_result_grid_column_names_copy != 0) gridx_max_column_widths[column_number_within_gridx++]= v_lengths;

      if (*(row_pointer - 1) == FIELD_VALUE_FLAG_IS_NULL)
      {
        gridx_max_column_widths[column_number_within_gridx]= sizeof(NULL_STRING) - 1;
      }
      else gridx_max_column_widths[column_number_within_gridx]= new_content_length;
      grid_column_size_calc(setting_ocelot_grid_cell_border_size_as_int,
                            setting_ocelot_grid_cell_drag_line_size_as_int,
                            0,
                            connections_dbms); /* get grid_column_widths[] and grid_column_heights[] */
      column_number_within_gridx= 0;
      //if (ocelot_client_side_functions_copy != 0)
      //{
      //  set_alignment_and_height(o_text_edit_frames_index + column_number_within_gridx,
      //                           column_number_within_gridx, -- but nowadays we pass grid_row not this
      //                           OCELOT_DATA_TYPE_SHORT);
      //  text_edit_frames[o_text_edit_frames_index + column_number_within_gridx]->show();
      //  ++column_number_within_gridx;
      //}
      int maximum_width= ocelot_grid_max_desired_width_in_pixels / 2;
      if (ocelot_result_grid_column_names_copy != 0)
      {
        int w= set_alignment_and_height(o_text_edit_frames_index + column_number_within_gridx,
                                 grid_row,
                                 OCELOT_DATA_TYPE_STRING,
                                 true, maximum_width);
        /* todo: shouldn't maximum width allow for spacing between cells? */
        maximum_width= ocelot_grid_max_desired_width_in_pixels - w;
        text_edit_frames[o_text_edit_frames_index + column_number_within_gridx]->show();
        ++column_number_within_gridx;
      }
      set_alignment_and_height(o_text_edit_frames_index + column_number_within_gridx,
                               grid_row,
                               result_field_types[result_column_number],
                               false, maximum_width);

      text_edit_frames[o_text_edit_frames_index + column_number_within_gridx]->show();
      ++result_column_number;
      ++grid_row;
      if (result_column_number == result_column_count)
      {
        ++result_row_number;
        result_column_number= 0;
      }
      if (result_row_number >= result_row_count) break;
      if (grid_row >= result_grid_widget_max_height_in_lines) break;
      row_pointer+= new_content_length;
      memcpy(&new_content_length, row_pointer, sizeof(unsigned int));
      row_pointer+= sizeof(unsigned int) + sizeof(unsigned char);
    }
    //for (text_edit_frames_index= text_edit_frames_index + 1; text_edit_frames_index < max_text_edit_frames_count; ++text_edit_frames_index) text_edit_frames[text_edit_frames_index]->hide();
  }

  else /* if ocelot_vertical_copy == 0 */
  {
    if (ocelot_result_grid_column_names_copy != 0)
    {
      int h= get_column_height_in_pixels(0, 5000, grid_max_column_height_in_pixels);
      grid_row_widgets[0]->setFixedHeight(h);
    }
    for (result_row_number= first_row, grid_row= 1;
         (result_row_number < result_row_count) && (grid_row < result_grid_widget_max_height_in_lines);
         ++result_row_number, ++grid_row)
    {
      row_pointer= result_set_copy_rows[result_row_number];
//      lengths= lmysql->ldbms_mysql_fetch_lengths(grid_mysql_res);
      for (i= 0; i < gridx_column_count; ++i)
      {
        text_edit_frames_index= grid_row * gridx_column_count + i;
        if (gridx_flags[i] == 1)        /* row number? */
        {
          text_edit_frames[text_edit_frames_index]->content_length= 0;
          text_edit_frames[text_edit_frames_index]->content_pointer= 0;
          text_edit_frames[text_edit_frames_index]->content_field_value_flags= FIELD_VALUE_FLAG_IS_NUMBER;
        }
        else
        {
          memcpy(&(text_edit_frames[text_edit_frames_index]->content_length), row_pointer, sizeof(unsigned int));
          row_pointer+= sizeof(unsigned int) + sizeof(char);
          char field_value_flags= *(row_pointer - 1);
          text_edit_frames[text_edit_frames_index]->content_field_value_flags= field_value_flags;
          if (field_value_flags == FIELD_VALUE_FLAG_IS_NULL)
          {
            text_edit_frames[text_edit_frames_index]->content_pointer= 0;
          }
          else text_edit_frames[text_edit_frames_index]->content_pointer= row_pointer;
          row_pointer+= text_edit_frames[text_edit_frames_index]->content_length;
        }
        set_height(text_edit_frames_index, text_edit_frames[text_edit_frames_index]->width());
        text_edit_frames[text_edit_frames_index]->is_retrieved_flag= false;
        text_edit_frames[text_edit_frames_index]->ancestor_grid_column_number= i;
        text_edit_frames[text_edit_frames_index]->ancestor_grid_result_row_number= result_row_number;
        text_edit_frames[text_edit_frames_index]->show();
      }
      /* Make row height = height of highest cell ... remember to do it differently if vertical != 0! */
      int highest_height= 0;
      for (i= 0; i < gridx_column_count; ++i)
      {
        text_edit_frames_index= grid_row * gridx_column_count + i;
        if (highest_height < text_edit_frames[text_edit_frames_index]->height())
          highest_height= text_edit_frames[text_edit_frames_index]->height();
      }
      grid_row_widgets[grid_row]->setFixedHeight(highest_height);
    }
  }
  /* todo: maybe what we really want is to hide as far as # of used rows, which may be < max */
  for (grid_row= grid_row; grid_row < result_grid_widget_max_height_in_lines; ++grid_row) /* so if scroll bar goes past end we won't see these */
  {
    for (i= 0; i < gridx_column_count; ++i)
    {
      text_edit_frames_index= grid_row * gridx_column_count + i;
      text_edit_frames[text_edit_frames_index]->hide();
    }
  }
}
#endif

/*
  We don't know exactly the maximum number of lines that will fit
  on a grid widget, but we can guess based on the height of the
  grid widget divided by the height of one line in a text edit widget.
  This affects: the size of the row pool (it must be >= the number
  of lines), the decision what kind of vertical scroll bar to use,
  and the number of detail widgets that we will fill with data.
  Two things can affect the calculation:
  (1) Height of result_grid_table_widget[i] can change, at start,
      or due to squeezing by statement + history widgets, or due
      to user action if the widget is detached. resizeEvent() sees that.
      If the number of lines increases, resize + display again.
  (2) Height of the text edit widget can change, set_all_style_sheets()
      sees that. For either increase or decrease, resize + display again.
  We're making the over-cautious assumption that it will be necessary to assign
  1 texteditframe for 1 line. In fact a texteditframe is always bigger than a line.
  We try to avoid recalculating just because user shifts by a few pixels.
  display_html() should not show() because that would cause a call to here, we'd loop
  Todo: what about copy_of_ocelot_raw?
*/
void resize_or_font_change(int height_of_grid_widget, bool is_resize)
{
  if (html_text_edit == NULL) return; /* ?? this should be impossible */
  set_grid_max_column_height_in_pixels(this->height());
  if ((copy_of_ocelot_batch != 0)
   || (copy_of_ocelot_html != 0)
   || (copy_of_ocelot_html == 0)
   || (copy_of_ocelot_xml != 0))
  {
    if ((copy_of_ocelot_batch != 0) || (copy_of_ocelot_xml != 0))
      html_text_edit->setStyleSheet(copy_of_parent->ocelot_grid_style_string);
    else
    {
//      if (is_resize == false)
      if (is_fancy() == true)
      {
        /* Todo: this shouldn't be 0, it should be current scrollbar value */
        prepare_for_display_html();
        display_html(grid_vertical_scroll_bar->value(), 0);
      }
    }
    return;
  }
//  QFont tmp_font= this->font();
  QFontMetrics mm= QFontMetrics(this->font());
  unsigned int height_of_line= mm.lineSpacing();
  unsigned int max_height_in_lines= height_of_grid_widget / height_of_line;
  if ((max_height_in_lines * height_of_line) < (unsigned int) height_of_grid_widget) ++ max_height_in_lines;
  if ((is_resize == false)
   || (max_height_in_lines > result_grid_widget_max_height_in_lines))
  {
    result_grid_widget_max_height_in_lines= max_height_in_lines;
    if (result_set_copy != 0)  /* see fillup_garbage_collect() comment */
    {
      display(2, 0, 0, 0, 0, 0, 0);
      this->show(); /* Todo: I think this is not necessary */
    }
  }
}

/*
  We want to redo the display but are confident that font and size are not changing.
  So far the only times we call are for: mousePressEvent (which changes focus background color).
*/
void color_change()
{
  display_html(grid_vertical_scroll_bar->value(), 0);
}

/*
  Set grid_max_column_height which is a permanently-available calculated maximum in pixels.
  We call this from from resize_or_font_change(), which should mean
  (a) we know that result grid size is current,
  (b) we know that result_grid_font may not be current but will be used in later paint jobs.
  We also call this when creating, but in that case result grid size is not really known
  and result_grid_font is still the parent's font.
  The rule should simply be that no single row + header row (which is one line)
  can exceed the size of the result grid, until we have a user-specified maximum.
  We use this in set_height(), where the idea is that you can't make a column higher
  than the maximum, so the cell will need a vertical scroll bar.
  Todo: In display, we set int result_grid_height= (parent->height() / 3) - 11;
        then   ocelot_grid_max_column_height_in_lines= result_grid_height / line_height;
        This supersedes those calculations so we can stop using them.
  Todo: Decide: Do we mean maximum for text_edit_widget or do we mean maximum for text_edit_frame?
  Todo: ocelot_grid_max_column_height_in_lines could be user-settable but overridable.
  Todo: It should be impossible to resize result grid to < 11 or < line size * 2, eh?
  Todo: Initially we call with result_grid_height == 0 but that is temporary.
  Todo: Make sure we call this whenever we change result_grid_font. Put the change in this function?
*/
void set_grid_max_column_height_in_pixels(int result_grid_height)
{
  QFontMetrics mm= QFontMetrics(result_grid_font);
  int height_of_line= mm.lineSpacing();
  int new_height= result_grid_height - (height_of_line * 2);
  if (new_height < height_of_line) new_height= height_of_line;
  grid_max_column_height_in_pixels= new_height;
}


/*
  Resize of grid widget. This could be called from eventfilter instead.
  Warning: changes in statement widget can cause this to be invoked.
  Warning: result_grid_height is not stable or useful until after there's been a display.
*/
void resizeEvent(QResizeEvent *event)
{
  result_grid_height_after_last_resize= event->size().height();
  result_grid_width_after_last_resize= event->size().width();
  if (result_grid_height_after_last_resize != event->oldSize().height())
  {
    resize_or_font_change(result_grid_height_after_last_resize, true);
  }
}


/*
  Called from eventfilter
  "    if (event->type() == QEvent::FontChange) return (result_grid_table_widget->fontchange_event());"
  Todo: This never happens, set_all_style_sheets() gets called for font change.
*/
int fontchange_event()
{
//  QFont tmp_font=this->font();
//  put_widgets_in_layouts(&tmp_font);
  return 1;
}


/*
  Called from eventfilter
  "    if (event->type() == QEvent::Show) return (result_grid_table_widget->show_event());"
  This is the more appropriate place to decide about the vertical scroll bar because now height is known.
  Todo: catch QEvent::Resize() too!! (maybe this is obsolete, we have void resizeEvent() above.
*/
bool show_event()
{
//  vertical_bar_show_as_needed();

  return false;           /* We want the show to happen so pass it on */
}


/*
  Called from eventfilter if and only if result_row_count > result_grid_widget_max_height_in_lines
  There is also an automatic show-as-needed scroll bar, which will come on if scrolling is inevitable for a smaller result set.
  But vertical_scroll_bar_event() is only for the non-automatic vertical scroll bar.
  Initially grid_vertical_scroll_bar_value == -1, it's checked so that we don't paint the initial display twice.
  Todo: Nothing happens if I click and hold, I have to click and release and hold.
  Some possible event types: 17 Show, 78 UpdateLater, 12 Paint, 5 MouseMove, 129 HoverMove, 110 ToolTip,
                             3 MouseButtonRelease, 18 Hide, 11 Leave, 25 WindowDeactivate, 128 HoverLeave
                             But if we call display_html() we miss 1 Timer, 2 MouseButtonPress
  Todo: I don't see why is_fancy is needed since I guess is only around for html.
*/

bool vertical_scroll_bar_event(QEvent *event, int connections_dbms)
{
  (void)connections_dbms;
  int new_value;
  /* It's impossible to get here if the scroll bar is hidden, but it happens. Well, maybe only for "turning it off" events. */
  if (grid_vertical_scroll_bar->isVisible() == false)
  {
    return false;
  }
  if (event->type() == QEvent::Show)
  {
    return false;
  }

  new_value= grid_vertical_scroll_bar->value();

  if (new_value != grid_vertical_scroll_bar_value)
  {
    /* Todo: See whether is_paintable is important for batch etc. */
    /* Eventually display_html() will replace everything */
//    if (grid_vertical_scroll_bar_value == -1) return false;
    if ((is_paintable != 1) || (grid_vertical_scroll_bar_value == -1))
    {
      grid_vertical_scroll_bar_value= new_value;
      return false;
    }
    if (is_fancy() == true) /* was: if (copy_of_ocelot_html == 1) */
    {
      display_html(new_value, 0);
      this->update();      /* not sure if we need to update both this and client, but it should be harmless*/
      client->update();
      grid_vertical_scroll_bar->update();
    }
    else
    {
#ifdef OLD_STUFF
      fill_detail_widgets(new_value, connections_dbms);
#endif
      this->update();      /* not sure if we need to update both this and client, but it should be harmless*/
      client->update();
    }
    grid_vertical_scroll_bar_value= new_value;
    /* TEST!!!! */
    return false;
  }
  return false;
}

/*
  Call when making the vertical bar scroll bar, which always happens when we make a ResultGrid.
  We'll call r->grid_vertical_scroll_bar->installEventFilter(this); from MainWindow.
  Todo: Anything special for destruct?
*/
void vertical_scroll_bar_construct()
{
  grid_vertical_scroll_bar= new QScrollBar(this);
  grid_vertical_scroll_bar->setSingleStep(1);
  grid_vertical_scroll_bar->setPageStep(1);
  grid_vertical_scroll_bar->setMinimum(0);
  grid_vertical_scroll_bar->setMouseTracking(true);
}

/*
  Call when there is a new result set to display.
  We don't want setValue(0) to cause display_html() yet so we set grid_vertical_scroll_bar_value= -1;
*/
void vertical_scroll_bar_initialize()
{
  if ((copy_of_ocelot_batch != 0)
   || (copy_of_ocelot_xml != 0)
   || (copy_of_ocelot_raw != 0))
  {
    grid_vertical_scroll_bar->hide();
    return;
  }
  grid_vertical_scroll_bar_value= -1;
  if (ocelot_vertical_copy == 0)
  {
    grid_vertical_scroll_bar->setMaximum(result_row_count - 1);
    if (result_row_count <= 1) grid_vertical_scroll_bar->hide();
    else grid_vertical_scroll_bar->show();
  }
  else
  {
    grid_vertical_scroll_bar->setMaximum(grid_result_row_count - 1);
    if (grid_result_row_count <= 1) grid_vertical_scroll_bar->hide();
    else grid_vertical_scroll_bar->show();
  }
  grid_vertical_scroll_bar->setValue(0);
}

#ifdef OLD_STUFF
/*
  If a result grid text_edit_widget is a number + not header, call with alignment_flag == Qt::AlighRight.
  Otherwise call with alignment_flag == Qt::AlignLeft.
  Do not assume it's left-aligned otherwise; there's a pool.
  Beware: if you only setAlignment, you lose wrapping, as a side effect of setDefaultTextOption (?)
  Todo: take into account whether it's a right-to-left character set like Arabic or Hebrew.
  Todo: check whether it's actually necessary to setAlignment for text_edit_widget too.
  Todo: check what happens to wrapping if it's a number, I read somewhere that's a problem.
  Todo: some other types e.g. BLOBs might also need special handling.
  Todo: user-settable option rather than WrapAnywhere.
  Todo: check that the effect is immediate, not deferred to the next time resultgrid comes up.
  ? For some reason this used to be:
    void text_align(QTextEdit *cell_text_edit_widget, enum Qt::AlignmentFlag alignment_flag)
*/
void text_align(TextEditWidget *cell_text_edit_widget, enum Qt::AlignmentFlag alignment_flag)
{
  enum Qt::AlignmentFlag a;
  /* Following should only be needed for Tarantool/NoSQL or Tarantool/SQL scalar */
  /* But maybe we should do it for all Tarantool and for MySQL/MariaDB, it probably works */
  /* Override what was passed, we will depend on the cell's field_value_flags */
  if ((dbms_version_mask & FLAG_VERSION_TARANTOOL) != 0)
  {
    char field_value_flags= cell_text_edit_widget->text_edit_frame_of_cell->content_field_value_flags;
    if (field_value_flags == FIELD_VALUE_FLAG_IS_NUMBER) a= Qt::AlignRight;
    else a= Qt::AlignLeft;
  }
  else a= alignment_flag;
  QTextOption to;
  to.setAlignment(a);
  to.setWrapMode(QTextOption::WrapAnywhere);
  cell_text_edit_widget->document()->setDefaultTextOption(to);
  cell_text_edit_widget->setAlignment(a);
}
#endif

/*
  We'll do our own garbage collecting for non-Qt items.
  fillup_garbage_collect for anything made with "new " in fillup() or fillup() subsidiaries.
  display_garbage_collect for anything made with "new " in display() or display() subsidiaries.
  Todo: make sure Qt items have parents where possible so that "delete result_grid_table_widget"
        takes care of them.
  Why we clear() text_edit_widgets:
    If the text is big blobs, and you start with default i.e. ocelot_display_blob_as_image = false,
    then you switch to ocelot_display_blob_as_image = true,
    it is much slower then if you start with ocelot_display_blob_as_image = true.
    Clearing alleviates the problem.
    It would be faster to use max_table_edit_widgets_count not cell_pool_size but that crashes.
    Perhaps it would be better to clear only if current size > (some minimum)?
  Warning: we check if (result_set_copy == 0) to ensure there's a result.
*/
void fillup_garbage_collect()
{
  if (result_field_types != 0) { delete [] result_field_types; result_field_types= 0; }
  if (result_field_charsetnrs != 0) { delete [] result_field_charsetnrs; result_field_charsetnrs= 0; }
  if (result_field_flags != 0) { delete [] result_field_flags; result_field_flags= 0; }
  if (result_set_copy != 0) { delete [] result_set_copy; result_set_copy= 0; }
  if (result_set_copy_rows != 0) { delete [] result_set_copy_rows; result_set_copy_rows= 0; }
  if (result_field_names != 0) { delete [] result_field_names; result_field_names= 0; }
  if (result_original_field_names != 0) { delete [] result_original_field_names; result_original_field_names= 0; }
  if (result_original_table_names != 0) { delete [] result_original_table_names; result_original_table_names= 0; }
  if (result_original_database_names != 0) { delete [] result_original_database_names; result_original_database_names= 0; }
  if (result_max_column_widths != 0) { delete [] result_max_column_widths; result_max_column_widths= 0; }
}

void display_garbage_collect()
{
  if (grid_column_widths != 0) { delete [] grid_column_widths; grid_column_widths= 0; }
  if (grid_column_heights != 0) { delete [] grid_column_heights; grid_column_heights= 0; }
  if (grid_column_dbms_sources != 0) { delete [] grid_column_dbms_sources; grid_column_dbms_sources= 0; }
  if (gridx_field_names != 0) { delete [] gridx_field_names; gridx_field_names= 0; }
  if (gridx_max_column_widths != 0) { delete [] gridx_max_column_widths; gridx_max_column_widths= 0; }
  if (gridx_result_indexes != 0) { delete [] gridx_result_indexes; gridx_result_indexes= 0; }
  if (gridx_flags != 0) { delete [] gridx_flags; gridx_flags= 0; }
  if (gridx_field_types != 0) { delete [] gridx_field_types; gridx_field_types= 0; }
  if (html_text_edit != NULL) delete html_text_edit;
  html_text_edit= new Result_qtextedit(this);
  if (batch_text_edit != NULL) delete batch_text_edit;
  batch_text_edit= new QTextEdit(this);
}

#ifdef OLD_STUFF
void set_frame_color_setting()
{
  setting_ocelot_grid_cell_drag_line_size_as_int= copy_of_parent->ocelot_grid_cell_drag_line_size.toInt();
  ocelot_grid_cell_drag_line_color= copy_of_parent->ocelot_grid_cell_drag_line_color;
  frame_color_setting= "TextEditFrame{background-color: ";
  frame_color_setting.append(ocelot_grid_cell_drag_line_color);
  //frame_color_setting.append(";border: 0px");              /* TEST !! */
  frame_color_setting.append("}");
}
#endif

/*
  Setting the parent should affect the children.
  But we don't want all text_edit_frames and text_edit_widgets to change because that is slow.
  Let us set a flag which causes change at paint time. with setStyleSheet(copy_of_parent->ocelot_grid_header_style_string);
  This gets called just after we change colors + fonts with the dialog box, so we know
  the new style string, and to get its font we used to create a temporary QTextEdit,
  but nowadays we get font with a function that figures it out from the style sheet syntax.
*/
void set_all_style_sheets(QString new_ocelot_grid_style_string,
                          QString new_ocelot_grid_cell_drag_line_size,
                          int caller,
                          bool is_result_grid_font_changed)
{
  (void)(new_ocelot_grid_cell_drag_line_size);
  if ((copy_of_ocelot_batch != 0)
#ifdef OLD_STUFF
   || (copy_of_ocelot_html != 0)
#endif
   || (copy_of_ocelot_xml != 0))
  {
    resize_or_font_change(this->height(), false);
    return;
  }
  result_grid_font= copy_of_parent->get_font_from_style_sheet(new_ocelot_grid_style_string);

  //unsigned int i_h;

  //setting_ocelot_grid_cell_drag_line_size_as_int= new_ocelot_grid_cell_drag_line_size.toInt();
  setting_ocelot_grid_cell_drag_line_size_as_int= 0;
  settings_change_calc();
#ifdef OLD_STUFF
  set_frame_color_setting();
  for (i_h= 0; i_h < cell_pool_size; ++i_h)
  {
    text_edit_frames[i_h]->is_style_sheet_set_flag= false;
    //text_edit_widgets[ki]->setMinimumWidth(fm.width("W") * MIN_WIDTH_IN_CHARS);
    //text_edit_widgets[ki]->setMinimumHeight(fm.height() * 2);
    /* todo: skip following line if setting_ocelot_grid_cell_drag_line_size_as_int did not change */
    text_edit_layouts[i_h]->setContentsMargins(QMargins(0, 0, setting_ocelot_grid_cell_drag_line_size_as_int, setting_ocelot_grid_cell_drag_line_size_as_int));
  }
#endif
  /* todo: is "caller" redundant? if it's 0, then font change is false? */
  /* todo: this shouldn't be just is_result_grid_font_changed, it should be any changed. */
  if ((caller == 1) && (is_result_grid_font_changed))
  {
    resize_or_font_change(this->height(), false);
  }
}

/*
  settings_change_calc()
  called from set_all_style_sheets()
  Calculate setting_max_width_of_a_char and setting_min_width_of_a_column.
  We should call this during initialization or settings change (of font or drag line or border).
  Assume settings apply for all grid columns so don't need to call for every column.
  width() is deprecated in Qt 5.13.
  Assume we know result_grid_font, setting_ocelot_grid_cell_border_size_as_int,
    setting_ocelot_grid_cell_drag_line_size_as_int, scroll_bar_width.
  The maximum width is based on boundingRect() since width() is deprecated in Qt 5.13.
  Choosing "W" is good enough for western alphabets, some Asian characters may be wider
  but in that case we will end up with a higher column see set_height().
  Assume there might be a vertical scroll bar, although perhaps it isn't possible if
  there is no drag line and no column could overflow the maximum number of lines.
  Do not increase if result_grid_fonts.italic()=true, that should be taken care of now.
  Return true if the results mean that repaint should occur (but I guess we ignore that now).
  Re bearing:
    width of 1 char * 3) - (width of 3 chars) = amount we'll add to column width
    abs(result_grid_font_metrics.leftBearing('W')) + abs(result_grid_font_metrics.rightBearing('W'))
    gives a similar result but for some reason it can be off, I trust boundingRect more.
    We no longer use horizontalAdvance.
    I'm no sure whether letterSpacing ever matters.
*/
void settings_change_calc()
{
  setting_ocelot_grid_cell_drag_line_size_as_int= 0; /* This should always be 0, we'll soon get rid of it */
  setting_ocelot_grid_cell_width_as_int= copy_of_parent->ocelot_grid_cell_width.toInt();
  setting_ocelot_grid_cell_border_size_as_int= copy_of_parent->ocelot_grid_cell_border_size.toInt();

  QFontMetrics result_grid_font_metrics= QFontMetrics(result_grid_font);
  QRect r2_1= result_grid_font_metrics.boundingRect(
                                   0, /* int x = x coordinate within original rect */
                                   0, /* int y = y coordinate within original rect */
                                   2000, /* int width = r.width(), which we don't change */
                                   2000, /* int height = height, which is arbitrary big maximum */
                                   0, /* int flags = (see comments before start of this routine) */
                                   "W"); /* QString & text= cell contents */
  int setting_max_width_of_1_char_times_3= r2_1.width() * 3;
  QRect r2_3= result_grid_font_metrics.boundingRect(
                                   0, /* int x = x coordinate within original rect */
                                   0, /* int y = y coordinate within original rect */
                                   2000, /* int width = r.width(), which we don't change */
                                   2000, /* int height = height, which is arbitrary big maximum */
                                   0, /* int flags = (see comments before start of this routine) */
                                   "WWW"); /* QString & text= cell contents */
  int setting_max_width_of_3_chars= r2_3.width();
  setting_bearing= ((setting_max_width_of_1_char_times_3) - setting_max_width_of_3_chars) / 3;
  setting_max_width_of_a_char= (setting_max_width_of_3_chars - setting_bearing) / 3;
  if (setting_bearing > 0) ++setting_bearing;
  setting_min_width_of_a_column= character_count_to_pixel_count(1)
                         + scroll_bar_width + 1
                         + setting_ocelot_grid_cell_border_size_as_int * 2;
  return;

  /* The following calculations used to exist in grid_column_size_calc(). Are they obsolete? */
  //pointer_to_font= &result_grid_font;

  /* Calculate with rounding up because of inter-character spacing. */
  //QFontMetrics mm= QFontMetrics(*pointer_to_font);
  //setting_max_width_of_a_char= mm.width("WWWW") / 4;
  //if ((max_width_of_a_char * 4) < (unsigned int) mm.width("WWWW")) ++setting_max_width_of_a_char;

  /*
     For italic|oblique I sometimes need zero extra pixels, but I
     sometimes need an incredible number of extra pixels.
     abs(qfm.rightBearing('W')) + abs(qfm.leftBearing('W')) is not enough
     Todo: try again to reduce, meanwhile document: don't use italics.
  */
  //if (pointer_to_font->italic() == true)
  //{
  //  setting_max_width_of_a_char*= 2;
  //}

  /* (pointer_to_font->fixedPitch() always == false, I don't know why */
  //if (mm.width("WWWWWWWWWW") != mm.width("I- 1a!~:wX"))
  //{
  //  ++setting_max_width_of_a_char;
  //}
}

/*
  Call this whenever you want to calculate the width of a column.
*/
int character_count_to_pixel_count(int character_count)
{
  return (character_count * setting_max_width_of_a_char) + setting_bearing;
}

///*
//  If (row height * result_row_count) > ResultGrid widget height) we need a vertical scroll bar.
//  Todo: I'm not sure whether this is adequate if there's a horizontal scroll bar.
//  Todo: I'm not sure whether this is adequate if there's a widget header.
//  Todo: I'm not sure whether the calculation should involve result_row_count  + 1 (to include the header).
//  Todo: Call this not only when show, but also if font change, column/row size change, resize.
//  Todo: Look for a bug! I noticed that vertical scroll bar was missing after a font change. Didn't repeat.
//*/
//void vertical_bar_show_as_needed()
//{
//  int h;
//
//  h= 0;
//  if (result_row_count > 1) h+= grid_height_of_highest_column_in_pixels * result_row_count;
//  if (h > height()) grid_vertical_scroll_bar->show();
//  else  grid_vertical_scroll_bar->hide();
//}

//unsigned int dbms_get_field_length(unsigned int column_number)
//{
//  QString s;
//  unsigned int dbms_field_number;
//
//  dbms_field_number= grid_column_dbms_field_numbers[column_number];
//  /* The defined length is mysql_fields[dbms_field_number].length. We prefer actual max length which usually is shorter. */
//  return gridx_max_column_widths[dbms_field_number];
//}


unsigned int dbms_get_field_flag(unsigned int column_number, int connections_dbms)
{
  (void) connections_dbms; /* suppress "unused parameter" warning */
  return result_field_flags[column_number];
}

QString dbms_get_field_name(unsigned int column_number, int connections_dbms)
{
  (void) connections_dbms; /* suppress "unused parameter" warning */
  char *result_field_names_pointer;
  unsigned int v_lengths;
  result_field_names_pointer= &result_field_names[0];
  for (unsigned int i= 0; i < column_number; ++i)
  {
    memcpy(&v_lengths, result_field_names_pointer, sizeof(unsigned int));
    result_field_names_pointer+= v_lengths + sizeof(unsigned int);
  }
  memcpy(&v_lengths, result_field_names_pointer, sizeof(unsigned int));
  result_field_names_pointer+= sizeof(unsigned int);
  return result_field_names_pointer;
}


unsigned int dbms_get_field_name_length(unsigned int column_number, int connections_dbms)
{
  (void) connections_dbms; /* suppress "unused parameter" warning */
  char *result_field_names_pointer;
  unsigned int v_lengths;
  result_field_names_pointer= &result_field_names[0];
  for (unsigned int i= 0; i < column_number; ++i)
  {
    memcpy(&v_lengths, result_field_names_pointer, sizeof(unsigned int));
    result_field_names_pointer+= v_lengths + sizeof(unsigned int);
  }
  memcpy(&v_lengths, result_field_names_pointer, sizeof(unsigned int));
  return v_lengths;
}


//QString dbms_get_field_value(int row_number, unsigned int column_number)
//{
//  QString s;
//  unsigned int dbms_field_number;
//
//  if (grid_column_dbms_sources[column_number] == DBMS_SOURCE_IS_MYSQL_FIELD)
//  {
//    dbms_field_number= grid_column_dbms_field_numbers[column_number];
//    return row[dbms_field_number];
//  }
//  if (grid_column_dbms_sources[column_number] == DBMS_SOURCE_IS_ROW_NUMBER)
//  {
//    s= QString::number(row_number);
//    return s;
//  }
//  return ""; /* to avoid "control reaches end of non-void function" warning */
//}

/*
  Deleting ResultGrid
  This probably will never be called explicitly, but if MainWindow parent is deleted when
  the program ends, we'll get here.
  Todo: check if above comment is still true now if we remove tabs
  Todo: why not display_garbage_collect()?
*/
~ResultGrid()
{
  fillup_garbage_collect();
}


/*
  If opd2 is inside 'quotes', then string comparison. Else int comparison.
  todo: when to exclude images?
  todo: it's variable when we'll see nulls
  todo: your idea of row number seems wrong, you're getting the display's row not the result set's row
  todo: remove this, it's all in ResultGrid now
*/
bool comparer(
        QString opd1,
        QString opd2,
        QString opr,                /* = or >= or > or <= or < or <> or == or != or IS NULL or LIKE */
        char field_value_flags)     /* FIELD_VALUE_FLAG_IS_NULL FIELD_VALUE_FLAG_IS_IMAGE etc. */
{
  if ((field_value_flags & FIELD_VALUE_FLAG_IS_NULL) != 0)
  {
    return (opr == "IS");
  }
  if (opd2.mid(0, 1) == "'")
  {
    QString opd1_str= opd1.toUpper();
    QString opd2_str= opd2.mid(1, opd2.size() - 2).toUpper();
    if ((opr == "=") || (opr == "==")) return (opd1_str == opd2_str);
    if (opr == ">=") return (opd1_str >= opd2_str);
    if (opr == ">") return (opd1_str > opd2_str);
    if (opr == "<=") return (opd1_str <= opd2_str);
    if (opr == "<") return (opd1_str < opd2_str);
    if ((opr == "<>") || (opr == "!=")) return (opd1_str != opd2_str);
#if (QT_VERSION >= 0x50000)
    if (opr == "REGEXP")
    {
      QRegularExpression re(opd2_str);
      QRegularExpressionMatch match= re.match(opd1_str);
      return match.hasMatch();
    }
#endif
    return false;
  }
  else
  {
    int opd1_int= opd1.toInt();
    int opd2_int= opd2.toInt();
    if ((opr == "=") || (opr == "==")) return (opd1_int == opd2_int);
    if (opr == ">=") return (opd1_int >= opd2_int);
    if (opr == ">") return (opd1_int > opd2_int);
    if (opr == "<=") return (opd1_int <= opd2_int);
    if (opr == "<") return (opd1_int < opd2_int);
    if ((opr == "<>") || (opr == "!=")) return (opd1_int != opd2_int);
    return false;
  }
  return false;
}


/*
  Usually use the style sheet default or style sheet from SET statements, which may be conditional.
  Note: If there are conditions then we aren't checking is_style_sheet_set_flag,
        we are checking whether background color is different after evaluating the condition.
        This seems to avoid earlier bugs but it's checking conditions more often than necessary.
        Maybe speed up by doing something clever with is_retrieved_flag.
        Maybe speed up by making canonical version with fixed lengths so there's no need to call tokenize.
  Row number should mean result row number, same as grid row number unless scroll bar value > 0.
  Column number should mean result column number, same as grid column number unless vertical=1.
  Todo: We clear conditional_settings before inserting, so temporarily there can't be more than one.
  Todo: Call SELECT * FROM "_vindex"; then call it again. Second time, there are calls to setStyleSheet(). Why?
  Todo: You are splitting into separate statements if there are carriage returns, as is typical with SET.
         It's somewhere in get_next_statement_in_string().
  Todo: Allow viewing conditional statements
  Todo: Allow clearing all conditional statements
  Todo: Allow setup of conditional statements in Settings menu
  Todo: SET ocelot_grid_background_color='blue', ocelot_grid_color='red' WHERE row = 5 AND column_name REGEX 'x';
  Todo: More comparands e.g. COLUMN_TYPE = 'binary'.
  Todo: font-family might have [foundry] in brackets, it should be in ''s, though I didn't notice a problem
*/
#define MAX_CONDITIONAL_STATEMENT_TOKENS 100 /* todo: this is a duplicate of what's defined in MainWindow */
bool conditional_setting_evaluate(int cs_number,
                                  int cs_column_number,           /* e.g. text_frame->ancestor_grid_column_number */
                                  int cs_result_row_number,       /* e.g. text_frame->ancestor_grid_result_row_number */
                                  char *cs_content_pointer,       /* e.g. text_frame->content_pointer */
                                  char cs_content_flags,
                                  unsigned int cs_content_length, /* e.g. text_frame->content_length */
                                  unsigned short int cs_cell_type,  /* e.g. text_frame->cell_type */
                                  QString old_style_sheet,
                                  bool is_always_true,
                                  QString *cs_new_tooltip,        /* return */
                                  QString *cs_new_style_sheet,    /* return */
                                  QString *cs_new_cell_height,    /* return */
                                  QString *cs_new_cell_width)     /* return */
{
  if (cs_cell_type != TEXTEDITFRAME_CELL_TYPE_DETAIL) return false; /* Temporary till we handle headers */
  ResultGrid *rg= this;
  MainWindow *mw= rg->copy_of_parent;
  if (mw->conditional_settings.count() <= cs_number) return false; /* unnecessary */
  {
    int token_offsets[MAX_CONDITIONAL_STATEMENT_TOKENS];
    int token_lengths[MAX_CONDITIONAL_STATEMENT_TOKENS];
    int i= cs_number;
    {
      QString text= mw->conditional_settings.at(i);
      mw->tokenize(text.data(),
               text.size(),
               &token_lengths[0], &token_offsets[0], MAX_CONDITIONAL_STATEMENT_TOKENS - 1,
              (QChar*)"33333", 2, "", 1);
      int token_index= 4; /* We're sure that WHERE comes after SET ocelot_grid_background|text_color='...' */
      while ((token_lengths[token_index] != 5) || (text.mid(token_offsets[token_index], 5) != "WHERE")) ++token_index;
      bool result;
      if (is_always_true == true)
      {
        result= true;
      }
      else
      {
        result= false;
        QString next_clause_start= "WHERE";
        bool is_skippable= false;
        for (;;)
        {
          if ((next_clause_start == "AND") && (result == false)) is_skippable= true;
          else if ((next_clause_start == "OR") && (result == true)) is_skippable= true;
          else is_skippable= false;
          QString target= text.mid(token_offsets[token_index + 1], token_lengths[token_index + 1]);
          QString opr= text.mid(token_offsets[token_index + 2], token_lengths[token_index + 2]);
          QString value= text.mid(token_offsets[token_index + 3], token_lengths[token_index + 3]);
          next_clause_start= text.mid(token_offsets[token_index + 4], token_lengths[token_index + 4]);
          if (is_skippable == false)
          {
            if (target == "COLUMN_NAME")
            {
              char *result_field_names_pointer= &rg->result_field_names[0];
              unsigned int v_length;
              for (unsigned int i= 0; i < rg->result_column_count; ++i)
              {
                memcpy(&v_length, result_field_names_pointer, sizeof(unsigned int));
                result_field_names_pointer+= sizeof(unsigned int);
                if (i == (unsigned int) cs_column_number)
                {
                  QString s= QString(QByteArray(result_field_names_pointer, v_length));
                  result= comparer(s, value, opr, 0);
                  break;
                }
                result_field_names_pointer+= v_length;
              }
            }
            if (target == "COLUMN_NUMBER")
            {
              result= comparer(QString::number(cs_column_number + 1), value, opr, 0);
            }
            if (target == "COLUMN_TYPE")
            {
              int a= cs_column_number;
              char *b= mw->typer_to_keyword(rg->result_field_types[a]);
              result= comparer(b, value, opr, 0);
            }
            if (target == "ROW_NUMBER")
            {
              int crn= cs_result_row_number;
              if (ocelot_result_grid_column_names_copy == 1) ++crn;
              result= comparer(QString::number(crn), value, opr, 0);
            }
            if (target == "VALUE")
            {
              {
                QString s= QString(QByteArray(cs_content_pointer, cs_content_length));
                /* passing text_frame->content_field_value_flags didn't seem to be working consistently */
                /* but *(text_frame->content_pointer + text_frame->content_length) causes crashing */
                result= comparer(s, value, opr, cs_content_flags);
              }
            }
          }
          if (next_clause_start == ";") break;
          token_index= token_index + 4; /* it's AND | OR, continue, but next condition might be skippable */
          continue;
        }
      }
      QString new_style_sheet= old_style_sheet;
      if (result == true)
      {
        for (int target_index= 1;; target_index+= 4)
        {
          int k;
          QString setting_value= text.mid(token_offsets[target_index + 2], token_lengths[target_index + 2]);
          if (setting_value.mid(0, 1) == "'") setting_value= setting_value.mid(1, setting_value.size() - 2);
          QString setting= text.mid(token_offsets[target_index], token_lengths[target_index]);
          if (setting == "OCELOT_GRID_BACKGROUND_COLOR") k= new_style_sheet.indexOf("background-color:") + 17;
          else if (setting == "OCELOT_GRID_TEXT_COLOR") k= new_style_sheet.indexOf("color:") + 6;
          else if (setting == "OCELOT_GRID_FONT_SIZE")
          {
            k= new_style_sheet.indexOf("font-size:") + 10;
            setting_value= setting_value + "pt";
          }
//          else if (setting == "OCELOT_GRID_FOCUS_CELL_BACKGROUND_COLOR") /* Todo: Don't do this */
//          {
//            k= new_style_sheet.indexOf("border:") + 7;
//            k= new_style_sheet.indexOf(" ", k) + 1;
//            k= new_style_sheet.indexOf(" ", k) + 1;
//          }
          else if (setting == "OCELOT_GRID_FONT_STYLE") k= new_style_sheet.indexOf("font-style:") + 11;
          else if (setting == "OCELOT_GRID_FONT_WEIGHT") k= new_style_sheet.indexOf("font-weight:") + 12;
          else if (setting == "OCELOT_GRID_FONT_FAMILY") k= new_style_sheet.indexOf("font-family:") + 12;
//          else if (setting == "OCELOT_GRID_BORDER_SIZE") /* now we only use ocelot_grid_cell_border_size */
//          {
//            k= new_style_sheet.indexOf("border:") + 7;
//            setting_value= setting_value + "px";
//          }
          else if (setting == "OCELOT_GRID_TOOLTIP")
          {
            *cs_new_tooltip= setting_value; /* caller can say setTooltip */
            continue;
          }
          else if (setting == "OCELOT_GRID_CELL_HEIGHT")
          {
            *cs_new_cell_height= setting_value; /* caller can change */
            continue;
          }
          else if (setting == "OCELOT_GRID_CELL_WIDTH")
          {
            *cs_new_cell_width= setting_value; /* caller can change */
            continue;
          }
          else break;
          int l;
//          if (setting == "OCELOT_GRID_BORDER_SIZE") l= new_style_sheet.indexOf(" ", k + 1);
//          else
            l= new_style_sheet.indexOf(";", k + 1);
          if (l == -1) l= new_style_sheet.size();
          new_style_sheet.replace(k, l - k, setting_value);
        }
        *cs_new_style_sheet= new_style_sheet; /* caller can say setstylesheet */
        return true; /* We only have evaluated one condition! But caller might call again. */
      }
      else
      {
        ;
      }
    }
  }
  return false;
}

/* Evaluate conditional settings until one is true (return true), or none are true (return false) */
/* If not HTML we could continue after true and pass result style string to the next iteration. But, no. */
bool conditional_setting_evaluate_till_true(
                                  int cs_column_number,           /* i.e. result set column number */
                                  int cs_result_row_number,       /* e.g. text_frame->ancestor_grid_result_row_number */
                                  char *cs_content_pointer,       /* e.g. text_frame->content_pointer */
                                  char cs_content_flags,          /* e.g. FIELD_VALUE_FLAG_IS_NULL */
                                  unsigned int cs_content_length, /* e.g. text_frame->content_length */
                                  unsigned short int cs_cell_type,  /* e.g. text_frame->cell_type */
                                  QString *cs_new_tooltip,        /* return */
                                  QString *cs_new_style_sheet,    /* return */
                                  QString *cs_new_cell_height,    /* return */
                                  QString *cs_new_cell_width,     /* return */
                                  int *returned_cs_number)        /* return */
{
  ResultGrid *rg= this;
  MainWindow *mw= rg->copy_of_parent;
  QString old_style_sheet= mw->ocelot_grid_style_string;
  bool result;
  for (int i= 0; i < mw->conditional_settings.count(); ++i)
  {
    result= conditional_setting_evaluate(i,
    cs_column_number,           /* e.g. text_frame->ancestor_grid_column_number */
    cs_result_row_number,              /* e.g. text_frame->ancestor_grid_result_row_number */
    cs_content_pointer,       /* e.g. text_frame->content_pointer */
    cs_content_flags,
    cs_content_length, /* e.g. text_frame->content_length */
    cs_cell_type,  /* e.g. text_frame->cell_type */
    old_style_sheet,
    false,
    cs_new_tooltip,        /* return */
    cs_new_style_sheet,    /* return */
    cs_new_cell_height,    /* return */
    cs_new_cell_width);     /* return */
    if (result == true)
    {
      *returned_cs_number= i;
      return true;
    }
  }
  *returned_cs_number= -1;
  return false;
}


public slots:

private:
};
#endif // RESULTGRID_H


/*********************************************************************************************************/

/* The Statement Widget */

/*
  A small part of the code for the statement widget was copied from
  http://qt-project.org/doc/qt-4.8/widgets-codeeditor-codeeditor-h.html
  so the original copyright notice and BSD-license provisions are reproduced
  at the start of ocelotgui.cpp, applicable solely to what was copied.
*/

/* CodeEditor is actually used for both the statement widget and the debug widgets. */

#ifndef CODEEDITOR_H
#define CODEEDITOR_H

class QPaintEvent;
class QResizeEvent;
class QSize;
class QWidget;

class prompt_class;

class CodeEditor : public QPlainTextEdit
{
    Q_OBJECT

public:
    CodeEditor(MainWindow *parent= 0);

    void prompt_widget_paintevent(QPaintEvent *event);
    int prompt_width_calculate();
    QString prompt_translate(int line_number);
    int prompt_translate_k(QString s, int i);
    unsigned int statement_count;                                            /* used if "prompt \c ..." */
#if (OCELOT_MYSQL_DEBUGGER == 1)
    unsigned int block_number;                                               /* current line number, base 0 */
    bool is_debug_widget;
#endif
    QString dbms_version; /* Set to "" at start, select version() at connect, maybe display in prompt. */
    QString dbms_database;/* Set to "" at start, select database() at connect, maybe display in prompt. */
    QString dbms_port;/* Set to "" at start, select @@port at connect, maybe display in prompt. */
    QString dbms_current_user;/* Set to "" at start, select current_user() at connect, maybe display in prompt. */
    QString dbms_current_user_without_host;/* Set to "" at start, select current_user() at connect, maybe display in prompt. */
    QString dbms_host; /* Set to "" at start, mysql_get_host_info() at connect, maybe display in prompt. */
    int dbms_connection_id; /* Set to connection_id() at connect */
    QString delimiter; /* Set to ";" at start, can be changed with "delimiter //" etc. */
    QString result; /* What gets appended to history after statement executeion, e.g. error message */
    qint64 start_time; /* when statement started, in milliseconds since the epoch */

    /*
      The prompt is a read-only widget that
      appears on the left margin of statement_edit_widget.
      Mostly it's controlled by the "PROMPT" command.
      Font is same as main font for statement_edit_widget.
      It looks better if the font is fixed width.
      There is an assumption that prompts are latin1.
      PROMPT client statement decides whether there are line numbers.
    */

        QColor statement_edit_widget_left_bgcolor;                    /* suggestion = Qt::lightGray. */
        QColor statement_edit_widget_left_treatment1_textcolor;       /* suggestion = Qt::black */
        QString statement_edit_widget_left_treatment1_prompt_text;    /* suggestions = "     >" or "" */

        QString prompt_default;                     /* = "mysql>" -- or is it "\N [\d]>"? */
        QString prompt_as_input_by_user;            /* = What the user input with latest PROMPT statement, or prompt_default */
        /* QString prompt_translated;     */             /* = prompt_as_input_by_user, but with some \s converted for ease of parse */
        QString prompt_current;                     /* = latest result of prompt_reform() */
        MainWindow *main_window;

public slots:
    void update_prompt_width(int newBlockCount);
    void highlightCurrentLine();

protected:
    void resizeEvent(QResizeEvent *event);

private slots:

    void update_prompt(const QRect &, int);

private:
    QWidget *prompt_widget;

void mousePressEvent(QMouseEvent *event)
{
  main_window->completer_widget->hide_wrapper();
  QPlainTextEdit::mousePressEvent(event);
}

/*
   Here is where we show a tooltip help hint e.g. "reserved keyword"
   if the user hovers with the mouse over a statement_edit_widget word.
   Beware: there is more than one CodeEditor.
   We only did setMouseTracking for statement_edit_widget.
   But make sure we're right.
   Beware: This won't work unless we're parsing.
   text= statement_edit_widget->toPlainText(); but maybe I won't care.
   Todo: Consider: QToolTip::showText() instead of setToolTip()
         (it would cause immediate change but might be distracting).
         (it would allow us to cntrol duration with ocelot_completer_timeout)
*/
void mouseMoveEvent(QMouseEvent *event)
{
  if (((main_window->ocelot_statement_syntax_checker.toInt()) & FLAG_FOR_HIGHLIGHTS)
   && (main_window->main_token_max_count > 0)
   && (main_window->statement_edit_widget == this))
  {
    QPoint i= event->pos();
    QTextCursor c= this->cursorForPosition(i);
    int p= c.position();
    QString s= "";
    for (int i= 0; main_window->main_token_lengths[i] != 0; ++i)
    {
      int offset= main_window->main_token_offsets[i];
      if (offset > p) break;
      int length= main_window->main_token_lengths[i];
      if ((offset <= p) && ((offset+length) > p))
      {
        s= main_window->token_reftype(i, true, main_window->main_token_types[i], main_window->main_token_reftypes[i]);
        break;
      }
    }
    this->setToolTip(s);
  }
  /* We probably don't need to say this. */
  QPlainTextEdit::mouseMoveEvent(event);
  }
};

class prompt_class : public QWidget
{
public:
  prompt_class(CodeEditor *editor) : QWidget(editor)
  {
    codeEditor= editor;
  }

  QSize sizeHint() const
  {
    return QSize(codeEditor->prompt_width_calculate(), 0);
  }

protected:
  void paintEvent(QPaintEvent *event)
  {
    codeEditor->prompt_widget_paintevent(event);
  }

private:
  CodeEditor *codeEditor;


};

#endif // CODEEDITOR_H

/*********************************************************************************************************/
/* THE QSCROLLAREAWITHSIZE WIDGET */

/*
  It's really really really hard to make a dialog box have a good size
  if it might scroll. With this subclass I can give a size hint when creating.
  Alas the Height hint tends to be ignored. (Todo: find out why.)
  It also tends to be ignored if I try sizeHint() for the Settings dialog box.
  The workaround is to check main_window_maximum_width later.
*/

#ifndef QSCROLLAREAWITHSIZE_H
#define QSCROLLAREAWITHSIZE_H
class QScrollAreaWithSize : public QScrollArea
{

public:
  int settings_width, settings_height;

QScrollAreaWithSize(int width, int height)
{
  settings_width= width;
  settings_height= height;
}

virtual QSize sizeHint() const
{
  return QSize(settings_width, settings_height);
}

};
#endif // QSCROLLAREAWITHSIZE_H

/*********************************************************************************************************/
/* THE QCOMBOBOXINSETTINGS WIDGET */
/* QComboBox::hidePopup() needs to be overridden in Settings calls so we can reset example. */
#ifndef QCOMBOBOXINSETTINGS_H
#define QCOMBOBOXINSETTINGS_H
class QComboBoxInSettings : public QComboBox
{
public:
//  void hidePopup() override;
  void hidePopup()
  {
    QComboBox::hidePopup();
    emit highlighted(-1);
  }
};
#endif // QCOMBOBOXINSETTINGS_H

/*********************************************************************************************************/
/* THE SETTINGS WIDGET */

#ifndef SETTINGS_H
#define SETTINGS_H
class Settings: public QDialog
{
  Q_OBJECT
public:
  QDialog *settings;
/*
private slots:
  void handle_combo_box_1(int);
  void handle_combo_box_for_color_pick_0();
  void handle_combo_box_for_color_pick_1();
  void handle_combo_box_for_color_pick_2();
  void handle_combo_box_for_color_pick_3();
  void handle_combo_box_for_color_pick_4();
  void handle_combo_box_for_color_pick_5();
  void handle_combo_box_for_color_pick_6();
  void handle_combo_box_for_color_pick_7();
  void handle_combo_box_for_color_pick_8();
  void handle_combo_box_for_color_pick_9();
  void handle_combo_box_for_color_pick_10();
  void handle_combo_box_for_font_name_change(); etc.
*/

private:
  QString actual_font_family;
  QString actual_font_size;
  QString actual_font_style;
  QString actual_font_weight;


  QVBoxLayout *main_layout;
  QWidget *widget_3, *widget_for_font_dialog;
  QHBoxLayout *hbox_layout_3, *hbox_layout_for_font_dialog;
  QPushButton *button_for_cancel, *button_for_ok;
  QLabel *widget_font_label;
  /* New Font Dialog */
  QComboBoxInSettings *combo_box_for_font_name;
  QComboBoxInSettings *combo_box_for_font_size;
  QLabel *text_for_font_example;
  /* New Font Dialog end */
  QWidget *widget_for_color[11];
  QHBoxLayout *hbox_layout_for_color[11];
  QLabel *label_for_color[11];
  QLabel *label_for_color_rgb[11];
  QLabel *label_for_font_dialog;

  QWidget *widget_for_syntax_checker;
  QLabel *label_for_syntax_checker;
  QComboBox *combo_box_for_syntax_checker;
  QHBoxLayout *hbox_layout_for_syntax_checker;

  QWidget *widget_for_max_row_count;
  QLabel *label_for_max_row_count;
  QSpinBox *spin_box_for_max_row_count;
  QHBoxLayout *hbox_layout_for_max_row_count;

  QWidget *widget_for_size[3];
  QHBoxLayout *hbox_layout_for_size[3];
  QLabel *label_for_size[3];
  QComboBox *combo_box_for_size[3];

  QWidget *widget_for_detached;
  QLabel *label_for_detached;
  QComboBox *combo_box_for_detached;
  QHBoxLayout *hbox_layout_for_detached;

  QWidget *widget_for_html_effects;
  QLabel *label_for_html_effects;
  QComboBox *combo_box_for_html_effects;
  QHBoxLayout *hbox_layout_for_html_effects;

  QWidget *widget_for_top, *widget_for_left, *widget_for_width, *widget_for_height;
  QLabel *label_for_top, *label_for_left, *label_for_width, *label_for_height;
  QComboBox *combo_box_for_top, *combo_box_for_left, *combo_box_for_width, *combo_box_for_height;

  QComboBox *combo_box_for_color_pick[11];
  QLabel *label_for_color_show[11];
  MainWindow *copy_of_parent;

  /* current_widget = MAIN_WIDGET | HISTORY_WIDGET | GRID_WIDGET | STATEMENT_WIDGET | etc. */
  int current_widget;

  QString menu_strings_menu_font_copy; /* Kludge, see Settings() comment */

/* Following might be too short for some new language in ostrings.h */
#define MAX_COLOR_NAME_WIDTH 24

#define FONT_SIZE_MAX 72
#define FONT_SIZE_MIN 6
#define FONT_SIZE_ZOOM_INCREMENT 1

/*
  Font Comments (all observations about how-to-do-font-settings should go here)
  Re weights:
    QFontDatabase and QFontDialog() sometimes disagree.
    We stopped using QFontDialog() in ocelotgui 1.5.
    In Qt version 6.x the QFont enums change: https://doc.qt.io/qt-6/gui-changes-qt6.html#qfont
    Our fontweightsvalues list has common names, alternate names, qt numbers, css numbers.
    Common names might not be the same as names that QFontDatabase returns in styles().
    Sometimes family contains weight (erroneously?) e.g. "Ubuntu Light", they probably mean "Ubuntu Condensed".
    Our style is always [nothing] | italic | oblique, derived from QFontDatabase.styles()
    Our weight is always fontweightsvalues that is closest to QFontDatabase::weights().
    (We also allow users to enter css numbers via SET.)
    Therefore what we show in the combo box often differs from what QFontDatabase or QFontDialog() show.
    But they are more consistent with each other and with css.
    See also the comments for canonical_font_family()
    Warning: "normal" can refer to QFont::StyleNormal (style) or to QFont::Normal (weight)
    Example: if QFontDatabase says family = "x", style = "light Italic" we show "x - light italic"
    Todo: we're using setFont and setItemData. Since elsewhere we use style sheets this is inconsistent.
    Todo: To make the initial display quicker, populate at first with only one item.
          Then, if mousePressEvent or something equivalent happens, populate fully.
    Todo: Get size of current font (i.e. "this"?) for the Settings dialog box
          For QFont(const QString &family, int pointSize = -1, int weight = -1, bool italic = false)
          We want pointSize of the dialog box font, weight + italic of the actual font.
    Todo: indicate if fixed pitch font
    Todo: SET statements match Settings
  Re sizes:
    In our experience QFontDatabase returns the same list regardless of famile or style, around 18 options.
    So we make the list once for all suggested sizes. If somehow (e.g. via SET) an unsuggested size comes up,
    we pick the nearest.

  Re desired behaviour:
    * There is an label with an example of text in current basic colors and fonts.
      If user navigates and changes highlighting, change the example. But revert to currentIndex() setting
      if user closes the QComboBox (that's why we had to subclass the name and size comboboxes)
    * Weight can be either a name or a qt number or a css number. We might try to distinguish qt number
      from css number by value, which means we won't recognize qt number = 100, we think that's css.
      If there's somehow a change to an unknown weight value, consider it "normal"
      Re Qt Version 5.6+ https://doc.qt.io/qt-5/qfont.html#Weight-enum:
      We want to compile on earlier versions so we don't use the enums but we use the values.
*/

/*
  Called from: Settings
  Pass: &combo_box_for_top|left|width|height or &combo_box_for_default
  Pass: current value
  Fill the box with defaults.
  Point to current value
*/
void combo_box_filler(QComboBox **addr_of_combo_box, QString current_value, bool is_for_default)
{
  int i_of_current_value;
  QString c= current_value.toLower();
  if (is_for_default)
  {
    (*addr_of_combo_box)->addItem("no");
    (*addr_of_combo_box)->addItem("yes");
  }
  else
  {
    (*addr_of_combo_box)->addItem("default");
    for (int i= 0; i <= 1500; i+= 10) (*addr_of_combo_box)->addItem(QString::number(i));
  }
  i_of_current_value= (*addr_of_combo_box)->findText(c);
  if (i_of_current_value == -1)
  {    (*addr_of_combo_box)->addItem(c);
    i_of_current_value= (*addr_of_combo_box)->findText(c);
  }
  (*addr_of_combo_box)->setCurrentIndex(i_of_current_value);
}

/*
  Pass: a combo_box_for_font_name item, which looks like family - weight [style]
  Return: family, weight, style
  Todo: There's another way: you could use QFontDatabase to get the weight given family and style,
        then whatever's left over must be the style. Apparently it's omitted if it's default though.
  Todo: There are some odd styles like "roman" and "book" in QFontDatabase, I don't know how to handle them.
*/
void combo_box_for_font_name_parse(QString name, QString *family, QString *weight, QString *style)
{
  QString family_candidate, weight_and_style_candidate, style_candidate, weight_candidate;
  name= name.toLower();
  int i_of_hyphen= name.indexOf(" - ");
  family_candidate= name.left(i_of_hyphen);

  weight_and_style_candidate= name.right(name.size() - (i_of_hyphen + 3));
  int i_of_space= weight_and_style_candidate.indexOf(" ");
  if (i_of_space == -1)
  {
    if ((weight_and_style_candidate == "italic") || (weight_and_style_candidate == "oblique"))
    {
      /* Todo: maybe regular? */
      weight_candidate= "normal"; /* huh? I guess it would be default weight, whatever that would be */
      style_candidate= weight_and_style_candidate;
    }
    else
    {
      weight_candidate= weight_and_style_candidate;
      style_candidate= "normal"; /* huh?  I guess it should be default style, whatever that would be */
    }
  }
  else
  {
    weight_candidate= weight_and_style_candidate.left(i_of_space);
    style_candidate= weight_and_style_candidate.right(weight_and_style_candidate.size() - (i_of_space + 1));
  }

  *family= family_candidate;
  *weight= weight_candidate;
  *style= style_candidate;

}

/*
  Pass: QFontDatabase-style family and style
  Return: our-style family and weight and style (family doesn't need to change). or ""
*/
int qt_style_to_our_style(QString qt_family, QString qt_style, QString *our_weight, QString *our_style)
{
  QFontDatabase font_database;
  int qt_weight= font_database.weight(qt_family, qt_style);
  if (qt_weight == -1) return -1;
  *our_weight= copy_of_parent->canonical_font_weight(QString::number(qt_weight));
  if (qt_style.contains("italic", Qt::CaseInsensitive)) *our_style= "italic";
  else if (qt_style.contains("oblique", Qt::CaseInsensitive)) *our_style= "oblique";
  else *our_style= "normal";
  return 0;
}

/*
  Populate Settings combo box for font name.
  See: Font comments
*/
int combo_box_for_font_name_filler(QString actual_font_family, QString actual_font_style, QString actual_font_weight)
{
  QFontDatabase font_database;
  combo_box_for_font_name->clear();

  //int this_font_point_size= this->font().pointSize();
  //QFont font(actual_font_family, this_font_point_size);
  //combo_box_for_font_name->setFont(font);

  QStringList font_families= font_database.families();

  int font_family_index= 0;
  int font_family_index_of_first_match= 0;
  int maximum_width= 0;
  for (int i= 0; i < font_families.size(); ++i)
  {
    bool is_match_found= false;
    QStringList font_styles= font_database.styles(font_families.at(i));
    QString our_weight, our_style;

    if (font_families.at(i) == actual_font_family) font_family_index_of_first_match= font_family_index;

    for (int j= 0; j < font_styles.size(); ++j)
    {
      qt_style_to_our_style(font_families.at(i), font_styles.at(j), &our_weight, &our_style);
      QString name= font_families.at(i) + " - " + our_weight + " " + our_style;

      combo_box_for_font_name->addItem(name);
      if (name.size() > maximum_width) maximum_width= name.size();

      //QString family, weight, style;
      //combo_box_for_font_name_parse(name, &family, &weight, &style);
      /* Next few lines would display item in item's font but I think they are too slow. */
      //bool is_italic= false;
      //if ((our_style == "italic") || (our_style == "oblique")) is_italic= true;
      //int fwi= copy_of_parent->fontweights_index_via_chars(weight);
      //QFont qf(family, this_font_point_size, fontweightsvalues[fwi].qt_number, is_italic);
      //combo_box_for_font_name->setItemData(font_family_index, qf, Qt::FontRole);
      if (font_families.at(i) == actual_font_family)
      {
        QString our_weight, our_style;
        qt_style_to_our_style(font_families.at(i), font_styles.at(j), &our_weight, &our_style);
        if ((our_weight == actual_font_weight) && (our_style == actual_font_style))
        {
          combo_box_for_font_name->setCurrentIndex(font_family_index);
          is_match_found= true;
        }
      }
      ++font_family_index;
    }
    if ((font_families.at(i) == actual_font_family) && (is_match_found == false))
    {
      /* family matches but weight|style. add a new entry if qfontinfo says it's possible. else use at(0) */
      bool italic= false;
      if (actual_font_style != "normal") italic= true;
      int fwi_a= copy_of_parent->fontweights_index_via_chars(actual_font_weight);
      int font_weight_as_int= fontweightsvalues[fwi_a].qt_number; /* e.g. if weight "300" we get 25 */
      QFont qf= QFont(font_families.at(i), -1, font_weight_as_int, italic);
      QFontInfo qfi= QFontInfo(qf);
      int fwi_o= copy_of_parent->fontweights_index_via_qt_number(qfi.weight());
      if (fwi_a == fwi_o)
      {
        QString name= font_families.at(i) + " - " + actual_font_weight + " " + actual_font_style;
        combo_box_for_font_name->addItem(name);
        combo_box_for_font_name->setCurrentIndex(font_family_index);
        ++font_family_index;
      }
      else combo_box_for_font_name->setCurrentIndex(font_family_index_of_first_match);
    }


  }
  return maximum_width;
}

/*
  Settings example on the right side of the font hbox
  Called initially or from the handlers for change of the first two colors, or change of the font.
  todo: border-color would be possible too
  todo: take size into account but with a scroll bar
  todo: remove margin
  todo: since we have an example, the time-consuming name combo box might be always the same font now
  todo: read-only so tab skips over it? or allow edit? or allow cut-and-paste?
  todo: check: is it safe to call this due to connect with color combo box before we know all values?
  Todo: let user change "Example" to an identifier and then show identifier highlight colour
  Todo: Or, show all highlight possibilities (and then we really need a scroll bar)
*/
void text_for_font_example_filler(QString text_color, QString background_color, QString font_family, QString font_style, QString font_weight, QString font_size)
{
  if (font_size.right(2) == "pt") font_size= font_size.left(font_size.size() - 2);
  text_for_font_example->setText("Example");
  QString style_sheet;
  copy_of_parent->make_one_style_string(&style_sheet,
                        text_color,
                        background_color,
                        "1",
                        "red",
                        font_family,
                        font_size,
                        font_style,
                        font_weight,
                        false);
  text_for_font_example->setStyleSheet(style_sheet);
}

void combo_box_for_font_size_filler(QString actual_font_size)
{
  QFontDatabase font_database;

  QStringList font_families= font_database.families();
  QList<int> big_list;

  big_list.clear();
  for (int i= 0; i < font_families.size(); ++i)
  {
    QStringList font_styles= font_database.styles(font_families.at(i));
    for (int j= 0; j < font_styles.size(); ++j)
    {
      QList<int> point_sizes= font_database.pointSizes(font_families.at(i), font_styles.at(j));
      for (int k= 0; k < point_sizes.count(); ++k)
      {
        int k_item= point_sizes.at(k);
        int l= 0;
        for (; l < big_list.count(); ++l)
        {
          if (k_item == big_list.at(l)) break;
          if (k_item < big_list.at(l)) { big_list.insert(l, k_item); break; }
        }
        if (l >= big_list.count()) big_list.append(k_item);
      }
    }
  }
  for (int i= 0; i < big_list.size(); ++i)
  {
    int j= big_list.at(i);
    if ((j < FONT_SIZE_MIN) || (j > FONT_SIZE_MAX)) continue;
    QString s= QString::number(j) + "pt";
    combo_box_for_font_size->addItem(s);
  }
  int actual_font_size_as_int= actual_font_size.toInt();
  font_size_index_set(actual_font_size_as_int);

}

/* TODO: probably some memory is leaking. I don't say "(this)" every time I say "new". */
public:
Settings(int passed_widget_number, MainWindow *parent): QDialog(parent)
{
  /*
    KLUDGE ALERT: menu_strings_menu_font_copy is a kludge.
    Windows build fails if menu_strings[menu_off + MENU_FONT] appears
    in label_for_font_dialog_set_text, or if MENU_FONT is used at all.
    Change the assert in ocelotgui.cpp if MENU_FONT changes in ostrings.h.
  */
  menu_strings_menu_font_copy= menu_strings[menu_off + 93];

  int settings_width, settings_height;

  /* settings = new QWidget(this); ... this might come later */

  copy_of_parent= parent;                                /* handle_button_for_ok() might use this */
  current_widget= passed_widget_number;

  /* Copy the parent's settings. They'll be copied back to the parent, possibly changed, if the user presses OK. */
  copy_of_parent->new_ocelot_menu_text_color= copy_of_parent->ocelot_menu_text_color;
  copy_of_parent->new_ocelot_menu_background_color= copy_of_parent->ocelot_menu_background_color;
  copy_of_parent->new_ocelot_menu_border_color= copy_of_parent->ocelot_menu_border_color;
  copy_of_parent->new_ocelot_menu_font_family= copy_of_parent->ocelot_menu_font_family;
  copy_of_parent->new_ocelot_menu_font_size= copy_of_parent->ocelot_menu_font_size;
  copy_of_parent->new_ocelot_menu_font_style= copy_of_parent->ocelot_menu_font_style;
  copy_of_parent->new_ocelot_menu_font_weight= copy_of_parent->ocelot_menu_font_weight;

  copy_of_parent->new_ocelot_history_text_color= copy_of_parent->ocelot_history_text_color;
  copy_of_parent->new_ocelot_history_background_color= copy_of_parent->ocelot_history_background_color;
  copy_of_parent->new_ocelot_history_border_color= copy_of_parent->ocelot_history_border_color;
  copy_of_parent->new_ocelot_history_font_family= copy_of_parent->ocelot_history_font_family;
  copy_of_parent->new_ocelot_history_font_size= copy_of_parent->ocelot_history_font_size;
  copy_of_parent->new_ocelot_history_font_style= copy_of_parent->ocelot_history_font_style;
  copy_of_parent->new_ocelot_history_font_weight= copy_of_parent->ocelot_history_font_weight;
  copy_of_parent->new_ocelot_history_max_row_count= copy_of_parent->ocelot_history_max_row_count;
  copy_of_parent->new_ocelot_history_height= copy_of_parent->ocelot_history_height;
  copy_of_parent->new_ocelot_history_left= copy_of_parent->ocelot_history_left;
  copy_of_parent->new_ocelot_history_top= copy_of_parent->ocelot_history_top;
  copy_of_parent->new_ocelot_history_width= copy_of_parent->ocelot_history_width;
  copy_of_parent->new_ocelot_history_detached= copy_of_parent->ocelot_history_detached;

  copy_of_parent->new_ocelot_grid_text_color= copy_of_parent->ocelot_grid_text_color;
  copy_of_parent->new_ocelot_grid_background_color= copy_of_parent->ocelot_grid_background_color;
  copy_of_parent->new_ocelot_grid_focus_cell_background_color= copy_of_parent->ocelot_grid_focus_cell_background_color;
  copy_of_parent->new_ocelot_grid_header_background_color= copy_of_parent->ocelot_grid_header_background_color;
  copy_of_parent->new_ocelot_grid_font_family= copy_of_parent->ocelot_grid_font_family;
  copy_of_parent->new_ocelot_grid_font_size= copy_of_parent->ocelot_grid_font_size;
  copy_of_parent->new_ocelot_grid_font_style= copy_of_parent->ocelot_grid_font_style;
  copy_of_parent->new_ocelot_grid_font_weight= copy_of_parent->ocelot_grid_font_weight;
  copy_of_parent->new_ocelot_grid_cell_border_color= copy_of_parent->ocelot_grid_cell_border_color;
  copy_of_parent->new_ocelot_grid_outer_color= copy_of_parent->ocelot_grid_outer_color;
//  copy_of_parent->new_ocelot_grid_border_size= copy_of_parent->ocelot_grid_border_size;
  copy_of_parent->new_ocelot_grid_cell_border_size= copy_of_parent->ocelot_grid_cell_border_size;
  copy_of_parent->new_ocelot_grid_cell_width= copy_of_parent->ocelot_grid_cell_width;
  copy_of_parent->new_ocelot_grid_cell_height= copy_of_parent->ocelot_grid_cell_height;
//  copy_of_parent->new_ocelot_grid_cell_drag_line_size= copy_of_parent->ocelot_grid_cell_drag_line_size;
  copy_of_parent->new_ocelot_grid_height= copy_of_parent->ocelot_grid_height;
  copy_of_parent->new_ocelot_grid_left= copy_of_parent->ocelot_grid_left;
  copy_of_parent->new_ocelot_grid_top= copy_of_parent->ocelot_grid_top;
  copy_of_parent->new_ocelot_grid_width= copy_of_parent->ocelot_grid_width;
  copy_of_parent->new_ocelot_grid_html_effects= copy_of_parent->ocelot_grid_html_effects;
  copy_of_parent->new_ocelot_grid_detached= copy_of_parent->ocelot_grid_detached;

  copy_of_parent->new_ocelot_extra_rule_1_text_color= copy_of_parent->ocelot_extra_rule_1_text_color;
  copy_of_parent->new_ocelot_extra_rule_1_background_color= copy_of_parent->ocelot_extra_rule_1_background_color;
  copy_of_parent->new_ocelot_extra_rule_1_condition= copy_of_parent->ocelot_extra_rule_1_condition;
  copy_of_parent->new_ocelot_extra_rule_1_display_as= copy_of_parent->ocelot_extra_rule_1_display_as;

  copy_of_parent->new_ocelot_statement_text_color= copy_of_parent->ocelot_statement_text_color;
  copy_of_parent->new_ocelot_statement_background_color= copy_of_parent->ocelot_statement_background_color;
  copy_of_parent->new_ocelot_statement_border_color= copy_of_parent->ocelot_statement_border_color;
  copy_of_parent->new_ocelot_statement_font_family= copy_of_parent->ocelot_statement_font_family;
  copy_of_parent->new_ocelot_statement_font_size= copy_of_parent->ocelot_statement_font_size;
  copy_of_parent->new_ocelot_statement_font_style= copy_of_parent->ocelot_statement_font_style;
  copy_of_parent->new_ocelot_statement_font_weight= copy_of_parent->ocelot_statement_font_weight;
  copy_of_parent->new_ocelot_statement_highlight_literal_color= copy_of_parent->ocelot_statement_highlight_literal_color;
  copy_of_parent->new_ocelot_statement_highlight_identifier_color= copy_of_parent->ocelot_statement_highlight_identifier_color;
  copy_of_parent->new_ocelot_statement_highlight_comment_color= copy_of_parent->ocelot_statement_highlight_comment_color;
  copy_of_parent->new_ocelot_statement_highlight_operator_color= copy_of_parent->ocelot_statement_highlight_operator_color;
  copy_of_parent->new_ocelot_statement_highlight_keyword_color= copy_of_parent->ocelot_statement_highlight_keyword_color;
  copy_of_parent->new_ocelot_statement_prompt_background_color= copy_of_parent->ocelot_statement_prompt_background_color;
  copy_of_parent->new_ocelot_statement_highlight_current_line_color= copy_of_parent->ocelot_statement_highlight_current_line_color;
  copy_of_parent->new_ocelot_statement_highlight_function_color= copy_of_parent->ocelot_statement_highlight_function_color;
  copy_of_parent->new_ocelot_statement_syntax_checker= copy_of_parent->ocelot_statement_syntax_checker;
  copy_of_parent->new_ocelot_statement_height= copy_of_parent->ocelot_statement_height;
  copy_of_parent->new_ocelot_statement_left= copy_of_parent->ocelot_statement_left;
  copy_of_parent->new_ocelot_statement_top= copy_of_parent->ocelot_statement_top;
  copy_of_parent->new_ocelot_statement_width= copy_of_parent->ocelot_statement_width;
  copy_of_parent->new_ocelot_statement_detached= copy_of_parent->ocelot_statement_detached;

  copy_of_parent->new_ocelot_debug_height= copy_of_parent->ocelot_debug_height;
  copy_of_parent->new_ocelot_debug_left= copy_of_parent->ocelot_debug_left;
  copy_of_parent->new_ocelot_debug_top= copy_of_parent->ocelot_debug_top;
  copy_of_parent->new_ocelot_debug_width= copy_of_parent->ocelot_debug_width;
  copy_of_parent->new_ocelot_debug_detached= copy_of_parent->ocelot_debug_detached;
  {
    QString s;
    if (current_widget == MAIN_WIDGET) s= menu_strings[menu_off + MENU_SETTINGS_FOR_MENU];
    if (current_widget == HISTORY_WIDGET) s= menu_strings[menu_off + MENU_SETTINGS_FOR_HISTORY];
    if (current_widget == GRID_WIDGET) s= menu_strings[menu_off + MENU_SETTINGS_FOR_GRID];
    if (current_widget == STATEMENT_WIDGET) s= menu_strings[menu_off + MENU_SETTINGS_FOR_STATEMENT];
#if (OCELOT_MYSQL_DEBUGGER == 1)
    if (current_widget == DEBUG_WIDGET) s= menu_strings[menu_off + MENU_SETTINGS_FOR_DEBUG];
#endif
    if (current_widget == EXTRA_RULE_1) s= menu_strings[menu_off + MENU_SETTINGS_FOR_EXTRA_RULE_1];
    setWindowTitle(s);                                                /* affects "this"] */
  }

  /* Todo: following calculation should actually be width of largest tr(label) + approximately 5. */
  int label_for_color_width= this->fontMetrics().boundingRect("W").width();
#if (OCELOT_MYSQL_DEBUGGER == 1)
if (current_widget != DEBUG_WIDGET)
#endif
{
  /* Hboxes for foreground, background, and highlights */

  /* Icons for all the colors. Todo: dynamic size. I expect about 150. */
  QPixmap pixmaps[512];
  QIcon icons[512];
  int i_of_icons;
  for (i_of_icons= 0; i_of_icons < copy_of_parent->q_color_list.size() / 2; ++i_of_icons)
  {
    pixmaps[i_of_icons]= QPixmap(100, 100);
    pixmaps[i_of_icons].fill(QColor(copy_of_parent->q_color_list[(i_of_icons * 2) + 1]));
    icons[i_of_icons]= pixmaps[i_of_icons];
  }

  for (int ci= 0; ci < 11; ++ci)
  {
    widget_for_color[ci]= new QWidget(this);
    label_for_color[ci]= new QLabel();
    label_for_color_rgb[ci]= new QLabel();
    combo_box_for_color_pick[ci]= new QComboBox(this);
    {
      /*
        When theme = CleanLooks or GTK+, the non-editable combobox's list view has no scroll bar.
        Finding the problem and putting in this one-line solution took 20 man-hours.
      */
      combo_box_for_color_pick[ci]->view()->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
      int i_44;
      for (i_44= 0; i_44 < copy_of_parent->q_color_list.size() / 2; ++i_44)
      {
        combo_box_for_color_pick[ci]->addItem(icons[i_44], copy_of_parent->q_color_list[(i_44 * 2)]);
      }
    }

    label_for_color_show[ci]= new QLabel(this);
    set_widget_values(ci);
    label_for_color[ci]->setFixedWidth(label_for_color_width * MAX_COLOR_NAME_WIDTH);
    //label_for_color_rgb[ci]->setFixedWidth(label_for_color_width * 12);
    label_for_color_rgb[ci]->setFixedWidth(this->fontMetrics().boundingRect("LightGoldenrodYellow").width());
    //label_for_color_show[ci]->setEnabled(false);
    label_for_color_show[ci]->setMinimumWidth(40);
    hbox_layout_for_color[ci]= new QHBoxLayout();
    hbox_layout_for_color[ci]->addWidget(label_for_color[ci]);
    hbox_layout_for_color[ci]->addWidget(label_for_color_rgb[ci]);
    hbox_layout_for_color[ci]->addWidget(label_for_color_show[ci]);
    hbox_layout_for_color[ci]->addWidget(combo_box_for_color_pick[ci]);
    widget_for_color[ci]->setLayout(hbox_layout_for_color[ci]);
  }
  connect(combo_box_for_color_pick[0], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_0(int)));
  connect(combo_box_for_color_pick[1], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_1(int)));
  connect(combo_box_for_color_pick[2], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_2(int)));
  connect(combo_box_for_color_pick[3], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_3(int)));
  connect(combo_box_for_color_pick[4], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_4(int)));
  connect(combo_box_for_color_pick[5], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_5(int)));
  connect(combo_box_for_color_pick[6], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_6(int)));
  connect(combo_box_for_color_pick[7], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_7(int)));
  connect(combo_box_for_color_pick[8], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_8(int)));
  connect(combo_box_for_color_pick[9], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_9(int)));
  connect(combo_box_for_color_pick[10],SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_color_pick_10(int)));

  widget_font_label= new QLabel("");

  /* Hbox -- the font picker */

  widget_for_font_dialog= new QWidget(this);

  label_for_font_dialog= new QLabel(this);
  label_for_font_dialog_set_text();

  hbox_layout_for_font_dialog= new QHBoxLayout();
  hbox_layout_for_font_dialog->addWidget(label_for_font_dialog);
  /* New font dialog start */
  {
    {

      if (current_widget == STATEMENT_WIDGET)
      {
        actual_font_family= copy_of_parent->connect_stripper(copy_of_parent->new_ocelot_statement_font_family, false);
        actual_font_size= copy_of_parent->new_ocelot_statement_font_size;
        actual_font_style= copy_of_parent->new_ocelot_statement_font_style;
        actual_font_weight= copy_of_parent->new_ocelot_statement_font_weight;
      }
      if (current_widget == GRID_WIDGET)
      {
        actual_font_family= copy_of_parent->connect_stripper(copy_of_parent->new_ocelot_grid_font_family, false);
        actual_font_size= copy_of_parent->new_ocelot_grid_font_size;
        actual_font_style= copy_of_parent->new_ocelot_grid_font_style;
        actual_font_weight= copy_of_parent->new_ocelot_grid_font_weight;
      }
      if (current_widget == HISTORY_WIDGET)
      {
        actual_font_family= copy_of_parent->connect_stripper(copy_of_parent->new_ocelot_history_font_family, false);
        actual_font_size= copy_of_parent->new_ocelot_history_font_size;
        actual_font_style= copy_of_parent->new_ocelot_history_font_style;
        actual_font_weight= copy_of_parent->new_ocelot_history_font_weight;
      }
      if (current_widget == MAIN_WIDGET)
      {
        actual_font_family= copy_of_parent->connect_stripper(copy_of_parent->new_ocelot_menu_font_family, false);
        actual_font_size= copy_of_parent->new_ocelot_menu_font_size;
        actual_font_style= copy_of_parent->new_ocelot_menu_font_style;
        actual_font_weight= copy_of_parent->new_ocelot_menu_font_weight;
      }
      /* todo: what if it's extra widget? */

      combo_box_for_font_name= new QComboBoxInSettings(); /* Should I say "this"? */
      combo_box_for_font_name->view()->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);

      int maximum_width= combo_box_for_font_name_filler(actual_font_family, actual_font_style, actual_font_weight);
      QString maximum_value= QString("X").repeated(maximum_width);
      /* Todo: what you really need is width(maximum # of characters) + scroll bar width */
      //combo_box_for_font_name->setFixedWidth(this->fontMetrics().boundingRect(maximum_value).width());

      combo_box_for_font_size= new QComboBoxInSettings();
      combo_box_for_font_size_filler(actual_font_size);
      maximum_value= "9999pt"; /* Todo: this does use scroll bar width but can still be too small */
      combo_box_for_font_size->setFixedWidth(this->fontMetrics().boundingRect(maximum_value).width()
                                             + style()->pixelMetric(QStyle::PM_ScrollBarExtent)
                                             + 4);

      text_for_font_example= new QLabel();
      handle_combo_box_for_any_highlighted(-1, -1); /* to fill in the example widget initially */

      hbox_layout_for_font_dialog->addWidget(combo_box_for_font_name);
      hbox_layout_for_font_dialog->addWidget(combo_box_for_font_size);
      hbox_layout_for_font_dialog->addWidget(text_for_font_example);
    }

    //hbox_layout_for_font_dialog->addWidget(combo_box_for_font_size);
    connect(combo_box_for_font_name, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_font_name_change(int)));
    connect(combo_box_for_font_name, SIGNAL(highlighted(int)), this, SLOT(handle_combo_box_for_font_name_highlighted(int)));
    connect(combo_box_for_font_size, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_font_size_change(int)));
    connect(combo_box_for_font_size, SIGNAL(highlighted(int)), this, SLOT(handle_combo_box_for_font_size_highlighted(int)));

  }
  /* New font dialog end */
  widget_for_font_dialog->setLayout(hbox_layout_for_font_dialog);

  if (current_widget == STATEMENT_WIDGET)
  {
    widget_for_syntax_checker= new QWidget(this);
    label_for_syntax_checker= new QLabel(menu_strings[menu_off + MENU_SYNTAX_CHECKER]);
    combo_box_for_syntax_checker= new QComboBox();
    combo_box_for_syntax_checker->setFixedWidth(label_for_color_width * 3);
    for (int cj= 0; cj <= 3; ++cj) combo_box_for_syntax_checker->addItem(QString::number(cj));
    combo_box_for_syntax_checker->setCurrentIndex(copy_of_parent->new_ocelot_statement_syntax_checker.toInt());
    hbox_layout_for_syntax_checker= new QHBoxLayout();
    hbox_layout_for_syntax_checker->addWidget(label_for_syntax_checker);
    hbox_layout_for_syntax_checker->addWidget(combo_box_for_syntax_checker);
    widget_for_syntax_checker->setLayout(hbox_layout_for_syntax_checker);
    connect(combo_box_for_syntax_checker, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_syntax_check(int)));
  }

  if (current_widget == HISTORY_WIDGET)
  {
    widget_for_max_row_count= new QWidget(this);
    label_for_max_row_count= new QLabel(menu_strings[menu_off + MENU_MAX_ROW_COUNT]);
    spin_box_for_max_row_count= new QSpinBox();
    spin_box_for_max_row_count->setFixedWidth(label_for_color_width * 5);
    spin_box_for_max_row_count->setMaximum(99999);
    spin_box_for_max_row_count->setMinimum(0);
    spin_box_for_max_row_count->setValue(copy_of_parent->ocelot_history_max_row_count.toInt());
    spin_box_for_max_row_count->setButtonSymbols( QAbstractSpinBox::NoButtons);
    hbox_layout_for_max_row_count= new QHBoxLayout();
    hbox_layout_for_max_row_count->addWidget(label_for_max_row_count);
    hbox_layout_for_max_row_count->addWidget(spin_box_for_max_row_count);
    widget_for_max_row_count->setLayout(hbox_layout_for_max_row_count);
    connect(spin_box_for_max_row_count, SIGNAL(valueChanged(int)), this, SLOT(handle_spin_box_for_max_row_count(int)));
  }

  if (current_widget == GRID_WIDGET)
  {
    /* int label_for_size_width= this->fontMetrics().boundingRect("W").width(); */
    for (int ci= 0; ci < 3; ++ci)
    {
      widget_for_size[ci]= new QWidget(this);
      if (ci == 0) label_for_size[ci]= new QLabel(menu_strings[menu_off + MENU_GRID_CELL_HEIGHT]);
      if (ci == 1) label_for_size[ci]= new QLabel(menu_strings[menu_off + MENU_GRID_CELL_BORDER_SIZE]);
      if (ci == 2) label_for_size[ci]= new QLabel(menu_strings[menu_off + MENU_GRID_CELL_WIDTH]);
      combo_box_for_size[ci]= new QComboBox();
      if (ci == 0)
      {
        combo_box_for_size[ci]->setFixedWidth(label_for_color_width * 10);
        QString current_value= copy_of_parent->ocelot_grid_cell_height;
        combo_box_filler(&combo_box_for_size[0], current_value, false);
        label_for_size[ci]->setFixedWidth(label_for_color_width * MAX_COLOR_NAME_WIDTH);
      }
      if (ci == 1)
      {
        combo_box_for_size[ci]->setFixedWidth(label_for_color_width * 3);
        for (int cj= 0; cj < 10; ++cj) combo_box_for_size[ci]->addItem(QString::number(cj));
        label_for_size[ci]->setFixedWidth(label_for_color_width * MAX_COLOR_NAME_WIDTH);
      }
      if (ci == 2)
      {
        combo_box_for_size[ci]->setFixedWidth(label_for_color_width * 10);
        QString current_value= copy_of_parent->ocelot_grid_cell_width;
        combo_box_filler(&combo_box_for_size[2], current_value, false);
        label_for_size[ci]->setFixedWidth(label_for_color_width * MAX_COLOR_NAME_WIDTH);
      }

      // if (ci == 0) combo_box_filler should handle this
      if (ci == 1) combo_box_for_size[1]->setCurrentIndex(copy_of_parent->new_ocelot_grid_cell_border_size.toInt());
      // if (ci == 2) combo_box_filler() should handle this
      hbox_layout_for_size[ci]= new QHBoxLayout();
      hbox_layout_for_size[ci]->addWidget(label_for_size[ci]);
      hbox_layout_for_size[ci]->addWidget(combo_box_for_size[ci]);
      widget_for_size[ci]->setLayout(hbox_layout_for_size[ci]);
    }

    connect(combo_box_for_size[0], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_size_0(int)));
    connect(combo_box_for_size[1], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_size_1(int)));
    connect(combo_box_for_size[2], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_size_2(int)));

  }
}
if (current_widget == GRID_WIDGET)
{
  QString current_value;
  widget_for_html_effects= new QWidget(this);
  label_for_html_effects= new QLabel(menu_strings[menu_off + MENU_GRID_HTML_EFFECTS]);
  combo_box_for_html_effects= new QComboBox();
  current_value= copy_of_parent->ocelot_grid_html_effects;
  combo_box_filler(&combo_box_for_html_effects, current_value, true);
  hbox_layout_for_html_effects= new QHBoxLayout();
  hbox_layout_for_html_effects->addWidget(label_for_html_effects);
  hbox_layout_for_html_effects->addWidget(combo_box_for_html_effects);
  widget_for_html_effects->setLayout(hbox_layout_for_html_effects);
  connect(combo_box_for_html_effects, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_html_effects(int)));
}

  if ((current_widget == HISTORY_WIDGET) || (current_widget == GRID_WIDGET)
   || (current_widget == STATEMENT_WIDGET) || (current_widget == DEBUG_WIDGET))
  {
    QString current_value;

    widget_for_detached= new QWidget(this);
    label_for_detached= new QLabel(menu_strings[menu_off + MENU_DETACHED]);
    combo_box_for_detached= new QComboBox();
    if (current_widget == HISTORY_WIDGET)
      current_value= copy_of_parent->ocelot_history_detached;
    else if (current_widget == GRID_WIDGET)
      current_value= copy_of_parent->ocelot_grid_detached;
    else if (current_widget == STATEMENT_WIDGET)
      current_value= copy_of_parent->ocelot_statement_detached;
    else
      current_value= copy_of_parent->ocelot_debug_detached;
    combo_box_filler(&combo_box_for_detached, current_value, true);
    hbox_layout_for_detached= new QHBoxLayout();
    hbox_layout_for_detached->addWidget(label_for_detached);
    hbox_layout_for_detached->addWidget(combo_box_for_detached);
    widget_for_detached->setLayout(hbox_layout_for_detached);
    connect(combo_box_for_detached, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_detached(int)));

    widget_for_top= new QWidget(this);
    label_for_top= new QLabel(menu_strings[menu_off + MENU_TOP]);
    combo_box_for_top= new QComboBox();
    if (current_widget == HISTORY_WIDGET)
      current_value= copy_of_parent->ocelot_history_top;
    else if (current_widget == GRID_WIDGET)
      current_value= copy_of_parent->ocelot_grid_top;
    else if (current_widget == STATEMENT_WIDGET)
      current_value= copy_of_parent->ocelot_statement_top;
    else
      current_value= copy_of_parent->ocelot_debug_top;
    combo_box_filler(&combo_box_for_top, current_value, false);
    hbox_layout_for_detached->addWidget(label_for_top);
    hbox_layout_for_detached->addWidget(combo_box_for_top);
    connect(combo_box_for_top, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_top(int)));

    widget_for_left= new QWidget(this);
    label_for_left= new QLabel(menu_strings[menu_off + MENU_LEFT]);
    combo_box_for_left= new QComboBox();
    if (current_widget == HISTORY_WIDGET)
      current_value= copy_of_parent->ocelot_history_left;
    else if (current_widget == GRID_WIDGET)
      current_value= copy_of_parent->ocelot_grid_left;
    else if (current_widget == STATEMENT_WIDGET)
      current_value= copy_of_parent->ocelot_statement_left;
    else
      current_value= copy_of_parent->ocelot_debug_left;
    combo_box_filler(&combo_box_for_left, current_value, false);
    hbox_layout_for_detached->addWidget(label_for_left);
    hbox_layout_for_detached->addWidget(combo_box_for_left);
    connect(combo_box_for_left, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_left(int)));

    widget_for_width= new QWidget(this);
    label_for_width= new QLabel(menu_strings[menu_off + MENU_WIDTH]);
    combo_box_for_width= new QComboBox;
    if (current_widget == HISTORY_WIDGET)
      current_value= copy_of_parent->ocelot_history_width;
    else if (current_widget == GRID_WIDGET)
      current_value= copy_of_parent->ocelot_grid_width;
    else if (current_widget == STATEMENT_WIDGET)
      current_value= copy_of_parent->ocelot_statement_width;
    else
      current_value= copy_of_parent->ocelot_debug_width;
    combo_box_filler(&combo_box_for_width, current_value, false);
    hbox_layout_for_detached->addWidget(label_for_width);
    hbox_layout_for_detached->addWidget(combo_box_for_width);
    connect(combo_box_for_width, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_width(int)));

    widget_for_height= new QWidget(this);
    label_for_height= new QLabel(menu_strings[menu_off + MENU_HEIGHT]);
    combo_box_for_height= new QComboBox;
    if (current_widget == HISTORY_WIDGET)
      current_value= copy_of_parent->ocelot_history_height;
    else if (current_widget == GRID_WIDGET)
      current_value= copy_of_parent->ocelot_grid_height;
    else if (current_widget == STATEMENT_WIDGET)
      current_value= copy_of_parent->ocelot_statement_height;
    else
      current_value= copy_of_parent->ocelot_debug_height;
    combo_box_filler(&combo_box_for_height, current_value, false);
    hbox_layout_for_detached->addWidget(label_for_height);
    hbox_layout_for_detached->addWidget(combo_box_for_height);
    connect(combo_box_for_height, SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_height(int)));
  }
  if (current_widget == EXTRA_RULE_1)
  {
    widget_for_size[0]= new QWidget(this);
    label_for_size[0]= new QLabel(menu_strings[menu_off + MENU_CONDITION]);
    combo_box_for_size[0]= new QComboBox();
    //combo_box_for_size[0]->setFixedWidth(label_for_color_width * 30);
/*
    I'd like to be specific, but until there's a lot of time to spare,
    let's go with just two options: LIKE '%BLOB' and LIKE '%BINARY'.
    combo_box_for_size[0]->addItem("");
    combo_box_for_size[0]->addItem("data_type = 'BIT'");
    combo_box_for_size[0]->addItem("data_type = 'TINYINT'");
    combo_box_for_size[0]->addItem("data_type = 'SMALLINT'");
    combo_box_for_size[0]->addItem("data_type = 'MEDIUMINT'");
    combo_box_for_size[0]->addItem("data_type = 'INT'");
    combo_box_for_size[0]->addItem("data_type = 'BIGINT'");
    combo_box_for_size[0]->addItem("data_type = 'DECIMAL'");
    combo_box_for_size[0]->addItem("data_type = 'NUMERIC'");
    combo_box_for_size[0]->addItem("data_type = 'FLOAT'");
    combo_box_for_size[0]->addItem("data_type = 'DOUBLE'");
    combo_box_for_size[0]->addItem("data_type = 'DATE'");
    combo_box_for_size[0]->addItem("data_type = 'DATETIME'");
    combo_box_for_size[0]->addItem("data_type = 'TIMESTAMP'");
    combo_box_for_size[0]->addItem("data_type = 'TIME'");
    combo_box_for_size[0]->addItem("data_type = 'CHAR'");
    combo_box_for_size[0]->addItem("data_type = 'VARCHAR'");
    combo_box_for_size[0]->addItem("data_type = 'BINARY'");
    combo_box_for_size[0]->addItem("data_type = 'VARBINARY'");
    combo_box_for_size[0]->addItem("data_type = 'TINYBLOB'");
    combo_box_for_size[0]->addItem("data_type = 'TINYTEXT'");
    combo_box_for_size[0]->addItem("data_type = 'BLOB'");
    combo_box_for_size[0]->addItem("data_type = 'TEXT'");
    combo_box_for_size[0]->addItem("data_type = 'MEDIUMBLOB'");
    combo_box_for_size[0]->addItem("data_type = 'MEDIUMTEXT'");
    combo_box_for_size[0]->addItem("data_type = 'LONGBLOB'");
    combo_box_for_size[0]->addItem("data_type = 'LONGTEXT'");
    combo_box_for_size[0]->addItem("data_type = 'ENUM'");
    combo_box_for_size[0]->addItem("data_type = 'SET'");
*/
    combo_box_for_size[0]->addItem("");
    combo_box_for_size[0]->addItem("data_type LIKE '%BLOB'");
    combo_box_for_size[0]->addItem("data_type LIKE '%BINARY'");
    //label_for_size[0]->setFixedWidth(label_for_color_width * 30);    
    combo_box_for_size[0]->setCurrentIndex(combo_box_for_size[0]->findText(copy_of_parent->new_ocelot_extra_rule_1_condition));

    hbox_layout_for_size[0]= new QHBoxLayout();
    hbox_layout_for_size[0]->addWidget(label_for_size[0]);
    hbox_layout_for_size[0]->addWidget(combo_box_for_size[0]);
    widget_for_size[0]->setLayout(hbox_layout_for_size[0]);
    connect(combo_box_for_size[0], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_size_0(int)));
    widget_for_size[1]= new QWidget(this);
    label_for_size[1]= new QLabel(menu_strings[menu_off + MENU_DISPLAY_AS]);
    combo_box_for_size[1]= new QComboBox();
    //combo_box_for_size[1]->setFixedWidth(label_for_color_width * 30);
    combo_box_for_size[1]->addItem("char");
    combo_box_for_size[1]->addItem("image");
    //combo_box_for_size[1]->addItem("hex");
    //combo_box_for_size[1]->addItem("number");
    //label_for_size[1]->setFixedWidth(label_for_color_width * 30);
    combo_box_for_size[1]->setCurrentIndex(combo_box_for_size[1]->findText(copy_of_parent->new_ocelot_extra_rule_1_display_as));
    hbox_layout_for_size[1]= new QHBoxLayout();
    hbox_layout_for_size[1]->addWidget(label_for_size[1]);
    hbox_layout_for_size[1]->addWidget(combo_box_for_size[1]);
    widget_for_size[1]->setLayout(hbox_layout_for_size[1]);
    connect(combo_box_for_size[1], SIGNAL(currentIndexChanged(int)), this, SLOT(handle_combo_box_for_size_1(int)));
  }
  /* The Cancel and OK buttons */
  widget_3= new QWidget(this);
  button_for_cancel= new QPushButton(menu_strings[menu_off + MENU_CANCEL], this);
  button_for_ok= new QPushButton(menu_strings[menu_off + MENU_OK], this);
  /* I have no idea why SLOT(accept() and SLOT(reject() cause crashes. The crashes can be worked around. */
  connect(button_for_ok, SIGNAL(clicked()), this, SLOT(handle_button_for_ok()));
  connect(button_for_cancel, SIGNAL(clicked()), this, SLOT(handle_button_for_cancel()));
  hbox_layout_3= new QHBoxLayout();
  hbox_layout_3->addWidget(button_for_cancel);
  hbox_layout_3->addWidget(button_for_ok);
  widget_3->setLayout(hbox_layout_3);
  /* Put the HBoxes in a VBox */
  main_layout= new QVBoxLayout();
#if (OCELOT_MYSQL_DEBUGGER == 1)
  if (current_widget != DEBUG_WIDGET)
#endif
  {
    for (int ci= 0; ci < 11; ++ci) main_layout->addWidget(widget_for_color[ci]);
    main_layout->addWidget(widget_font_label);
    main_layout->addWidget(widget_for_font_dialog);
    if (current_widget == STATEMENT_WIDGET) main_layout->addWidget(widget_for_syntax_checker);
    if (current_widget == GRID_WIDGET) for (int ci= 0; ci < 3; ++ci) main_layout->addWidget(widget_for_size[ci]);
    if (current_widget == HISTORY_WIDGET)
      main_layout->addWidget(widget_for_max_row_count);
  }
  if (current_widget == GRID_WIDGET)
  {
    main_layout->addWidget(widget_for_html_effects);
  }
  if ((current_widget == HISTORY_WIDGET) || (current_widget == GRID_WIDGET)
   || (current_widget == STATEMENT_WIDGET) || (current_widget == DEBUG_WIDGET))
  {
    main_layout->addWidget(widget_for_detached);
    //main_layout->addWidget(widget_for_top);
    //main_layout->addWidget(widget_for_left);
    //main_layout->addWidget(widget_for_width);
    //main_layout->addWidget(widget_for_height);
  }
  if (current_widget == EXTRA_RULE_1) main_layout->addWidget(widget_for_size[0]);
  if (current_widget == EXTRA_RULE_1) main_layout->addWidget(widget_for_size[1]);
  main_layout->addWidget(widget_3);
  if (current_widget != DEBUG_WIDGET) handle_combo_box_1(current_widget);
  /*
    If one merely says
    this->setLayout(main_layout);
    that almost always works because the dialog box fits within the
    typical screen area. But if it doesn't, e.g. 640x480 display, we need a scroll bar.
    Additional problem: sizeHint() seems to work for horizontal but not for vertical,
    which is why the setMinimumHeight line exists.
  */
  this->setLayout(main_layout);
  main_layout->activate();
  settings_width= this->width() + 20; /* todo: 20 is arbitrary */
  settings_height= this->height() + 20; /* todo: 20 is arbitrary */
  QWidget *widget_with_main_layout= new QWidget();
  widget_with_main_layout->setLayout(main_layout);
  QScrollAreaWithSize *scroll_area= new QScrollAreaWithSize(settings_width, settings_height);
  scroll_area->setWidget(widget_with_main_layout);
  QHBoxLayout *scroll_area_layout= new QHBoxLayout();
  scroll_area_layout->addWidget(widget_with_main_layout);
  scroll_area->setLayout(scroll_area_layout);
  scroll_area->setWidgetResizable(true);
  QHBoxLayout *upper_layout= new QHBoxLayout();
  upper_layout->addWidget(scroll_area);
  setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
  //if (parent->main_window_maximum_width > settings_width) setMinimumWidth(settings_width);
  if (parent->main_window_maximum_height > settings_height) setMinimumHeight(settings_height);
  setLayout(upper_layout);
}

private:

/* We call set_widget_values() when we're doing "new Settings" (in which case current_widget == what-was-passed) */
void set_widget_values(int ci)
{
  QString color_type;
  QString color_name;

  if (current_widget == STATEMENT_WIDGET)
  {
    switch (ci)
    {
    case 0: { color_type= menu_strings[menu_off + MENU_STATEMENT_TEXT_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_text_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 1: { color_type= menu_strings[menu_off + MENU_STATEMENT_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 2: { color_type= menu_strings[menu_off + MENU_STATEMENT_HIGHLIGHT_LITERAL_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_highlight_literal_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 3: { color_type= menu_strings[menu_off + MENU_STATEMENT_HIGHLIGHT_IDENTIFIER_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_highlight_identifier_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 4: { color_type= menu_strings[menu_off + MENU_STATEMENT_HIGHLIGHT_COMMENT_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_highlight_comment_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 5: { color_type= menu_strings[menu_off + MENU_STATEMENT_HIGHLIGHT_OPERATOR_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_highlight_operator_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 6: { color_type= menu_strings[menu_off + MENU_STATEMENT_HIGHLIGHT_KEYWORD_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_highlight_keyword_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 7: { color_type= menu_strings[menu_off + MENU_STATEMENT_PROMPT_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_prompt_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 8: { color_type= menu_strings[menu_off + MENU_STATEMENT_BORDER_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_border_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 9: { color_type= menu_strings[menu_off + MENU_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_highlight_current_line_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 10:{ color_type= menu_strings[menu_off + MENU_STATEMENT_HIGHLIGHT_FUNCTION_COLOR];
              color_name= copy_of_parent->new_ocelot_statement_highlight_function_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    }
  }
  if (current_widget == GRID_WIDGET)
  {
    switch (ci)
    {
    case 0: { color_type= menu_strings[menu_off + MENU_GRID_TEXT_COLOR];
              color_name= copy_of_parent->new_ocelot_grid_text_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 1: { color_type= menu_strings[menu_off + MENU_GRID_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_grid_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 2: { color_type= menu_strings[menu_off + MENU_GRID_CELL_BORDER_COLOR];
              color_name= copy_of_parent->new_ocelot_grid_cell_border_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 3: { color_type= menu_strings[menu_off + MENU_GRID_OUTER_COLOR];
              color_name= copy_of_parent->new_ocelot_grid_outer_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 7: { color_type= menu_strings[menu_off + MENU_GRID_HEADER_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_grid_header_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 8: { color_type= menu_strings[menu_off + MENU_GRID_FOCUS_CELL_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_grid_focus_cell_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    }
  }
  if (current_widget == EXTRA_RULE_1)
  {
    switch (ci)
    {
    case 0: { color_type= menu_strings[menu_off + MENU_GRID_TEXT_COLOR];
              color_name= copy_of_parent->new_ocelot_extra_rule_1_text_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 1: { color_type= menu_strings[menu_off + MENU_GRID_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_extra_rule_1_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    }
  }
  if (current_widget == HISTORY_WIDGET)
  {
    switch (ci)
    {
    case 0: { color_type= menu_strings[menu_off + MENU_HISTORY_TEXT_COLOR];
              color_name= copy_of_parent->new_ocelot_history_text_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 1: { color_type= menu_strings[menu_off + MENU_HISTORY_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_history_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 8: { color_type= menu_strings[menu_off + MENU_HISTORY_BORDER_COLOR];
              color_name= copy_of_parent->new_ocelot_history_border_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    }
  }
  if (current_widget == MAIN_WIDGET)
  {
    switch (ci)
    {
    case 0: { color_type= menu_strings[menu_off + MENU_MENU_TEXT_COLOR];
              color_name= copy_of_parent->new_ocelot_menu_text_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 1: { color_type= menu_strings[menu_off + MENU_MENU_BACKGROUND_COLOR];
              color_name= copy_of_parent->new_ocelot_menu_background_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    case 8: { color_type= menu_strings[menu_off + MENU_MENU_BORDER_COLOR];
              color_name= copy_of_parent->new_ocelot_menu_border_color;
              color_name= copy_of_parent->canonical_color_name(color_name);
              break; }
    }
  }
  label_for_color[ci]->setText(color_type);
  //label_for_color_rgb[ci]->setText(color_name);
  int cli;
  /* Todo: This is a very roundabout way to get the color index. */
  cli= q_color_list_index(copy_of_parent->rgb_to_color(color_name));
  combo_box_for_color_pick[ci]->setCurrentIndex(cli);
  label_for_color_rgb[ci]->setText(combo_box_for_color_pick[ci]->currentText());
  QString sss= "border: 1px solid black; background-color: ";
  sss.append(copy_of_parent->qt_color(color_name));
  label_for_color_show[ci]->setStyleSheet(sss);
}


private:
/*
  Todo: Only statement has highlights (I suppose the other controls
  could have highlights too, but regard that as a low priority todo).
  I tried setEnabled(false|true) but think hide|show looks better.
*/
void handle_combo_box_1(int i)
{
  int ci;
  QString color_type;

  current_widget= i;

  for (ci= 0; ci < 11; ++ci) set_widget_values(ci);
  if (i == STATEMENT_WIDGET)
  {
    color_type= menu_strings[menu_off + MENU_STATEMENT_PROMPT_BACKGROUND_COLOR]; /* necessary even though set_widget_values() does it */
    label_for_color[7]->setText(color_type);
//    for (ci= 2; ci < 11 ; ++ci)
//    {
//      label_for_color[ci]->show();
//      label_for_color_rgb[ci]->show();
//      label_for_color_show[ci]->show();
//      combo_box_for_color_pick[ci]->show();
//    }
  }

  /*
    This is a change for version 1.5.
    Instead of hiding/showing color components, we assume show() and remove widgets that have the components
    i.e. label_for_color[] label_for_color_rgb[] label_for_color_show[] combo_box_for_color_pick[] aren't
    addressed by the box they are in -- widget_for_color[] -- goes out if main_layout if it's not needed.
  */
  if (i == GRID_WIDGET)
  {
    color_type= menu_strings[menu_off + MENU_GRID_HEADER_BACKGROUND_COLOR];  /* necessary even though set_widget_values() does it */
    label_for_color[7]->setText(color_type);
    widget_for_color[4]->hide();
    widget_for_color[5]->hide();
    widget_for_color[6]->hide();
    widget_for_color[9]->hide();
    widget_for_color[10]->hide();
    main_layout->removeWidget(widget_for_color[4]);
    main_layout->removeWidget(widget_for_color[5]);
    main_layout->removeWidget(widget_for_color[6]);
    main_layout->removeWidget(widget_for_color[9]);
    main_layout->removeWidget(widget_for_color[10]);
  }
  if (i == EXTRA_RULE_1)
  {
    for (ci= 2; ci < 11; ++ci)
    {
      widget_for_color[ci]->hide();
      main_layout->removeWidget(widget_for_color[ci]);
    }
    widget_font_label->hide();
    label_for_font_dialog->hide();
    combo_box_for_font_name->hide();
    combo_box_for_font_size->hide();
    text_for_font_example->hide();
  }
  if ((i == HISTORY_WIDGET) || (i == MAIN_WIDGET))
  {
    widget_for_color[2]->hide();
    widget_for_color[3]->hide();
    widget_for_color[4]->hide();
    widget_for_color[5]->hide();
    widget_for_color[6]->hide();
    widget_for_color[7]->hide();
    widget_for_color[9]->hide();
    widget_for_color[10]->hide();
    main_layout->removeWidget(widget_for_color[2]);
    main_layout->removeWidget(widget_for_color[3]);
    main_layout->removeWidget(widget_for_color[4]);
    main_layout->removeWidget(widget_for_color[5]);
    main_layout->removeWidget(widget_for_color[6]);
    main_layout->removeWidget(widget_for_color[7]);
    main_layout->removeWidget(widget_for_color[9]);
    main_layout->removeWidget(widget_for_color[10]);
  }
}

void label_for_font_dialog_set_text()
{
  QString s_for_label_for_font_dialog= menu_strings_menu_font_copy;
  if (current_widget == STATEMENT_WIDGET)
  {
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_statement_font_family);
    s_for_label_for_font_dialog.append(" ");
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_statement_font_size);
    s_for_label_for_font_dialog.append("pt");
    if (QString::compare(copy_of_parent->new_ocelot_statement_font_weight, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_statement_font_weight);
    }
    if (QString::compare(copy_of_parent->new_ocelot_statement_font_style, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_statement_font_style);
    }
  }

  if (current_widget == GRID_WIDGET)
  {
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_grid_font_family);
    s_for_label_for_font_dialog.append(" ");
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_grid_font_size);
    s_for_label_for_font_dialog.append("pt");
    if (QString::compare(copy_of_parent->new_ocelot_grid_font_weight, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_grid_font_weight);
    }
    if (QString::compare(copy_of_parent->new_ocelot_grid_font_style, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_grid_font_style);
    }
  }

  if (current_widget == HISTORY_WIDGET)
  {
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_history_font_family);
    s_for_label_for_font_dialog.append(" ");
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_history_font_size);
    s_for_label_for_font_dialog.append("pt");
    if (QString::compare(copy_of_parent->new_ocelot_history_font_weight, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_history_font_weight);
    }
    if (QString::compare(copy_of_parent->new_ocelot_history_font_style, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_history_font_style);
    }
  }

  if (current_widget == MAIN_WIDGET)
  {
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_menu_font_family);
    s_for_label_for_font_dialog.append(" ");
    s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_menu_font_size);
    s_for_label_for_font_dialog.append("pt");
    if (QString::compare(copy_of_parent->new_ocelot_menu_font_weight, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_menu_font_weight);
    }
    if (QString::compare(copy_of_parent->new_ocelot_menu_font_style, "normal") != 0)
    {
      s_for_label_for_font_dialog.append(" ");
      s_for_label_for_font_dialog.append(copy_of_parent->new_ocelot_menu_font_style);
    }
  }

  label_for_font_dialog->setText(s_for_label_for_font_dialog);
}


private slots:

/* If user clicks OK, end. The caller will move changed "new" settings to non-new. */
void handle_button_for_ok()
{
  done(QDialog::Accepted); /* i.e. close() but return Accepted */
}


/* If user clicks Cancel, don't do anything, and end. */
void handle_button_for_cancel()
{
  done(QDialog::Rejected); /* i.e. close() but return Rejected */
}


/*
  For all the handle_combo_box_for_color_pick slots:
  We no longer use QColorDialog dialog box, instead there's a QComboBox.
  Why I didn't like QColorDialog ...
    For the "name:" control: if I typed in SkyBlue, it echoed as rrggbb,
    if I typed in Silver, it did nothing, and there was no clear list
    of what color names were available. For the other controls: I thought
    brightness/hue etc., and the color wheel, would put off intimidate users
    since they're not obvious and I expect typical users want names
    rather than numbers.
  The QComboBox for color picking gets around those problems but ...
  Todo: Make sure garbage_collect is working
  Todo: The Settings menu item  itself does not have the font or colors declared by settings menu
  Todo: There surely isn't any need for the blank lines -- so it's not a matter of "hide()", you just don't create
  Todo: You need to look harder at what Tab settings are (it's hard to see what the focus is for the combobox items
*/
void handle_combo_box_for_color_pick_0(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[0]->itemText(item_number);
    copy_of_parent->new_ocelot_statement_text_color= new_color;
    label_for_color_rgb[0]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[0]->setStyleSheet(s);
  }
  if (current_widget == GRID_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[0]->itemText(item_number);
    copy_of_parent->new_ocelot_grid_text_color= new_color;
    label_for_color_rgb[0]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[0]->setStyleSheet(s);
  }
  if (current_widget == EXTRA_RULE_1)
  {
    QString new_color= combo_box_for_color_pick[0]->itemText(item_number);
    copy_of_parent->new_ocelot_extra_rule_1_text_color= new_color;
    label_for_color_rgb[0]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[0]->setStyleSheet(s);
  }
  if (current_widget == HISTORY_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[0]->itemText(item_number);
    copy_of_parent->new_ocelot_history_text_color= new_color;
    label_for_color_rgb[0]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[0]->setStyleSheet(s);
  }
  if (current_widget == MAIN_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[0]->itemText(item_number);
    copy_of_parent->new_ocelot_menu_text_color= new_color;
    label_for_color_rgb[0]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[0]->setStyleSheet(s);
  }

  text_for_font_example_filler(label_for_color_rgb[0]->text(),
                               label_for_color_rgb[1]->text(),
                               actual_font_family,
                               actual_font_style,
                               actual_font_weight,
                               actual_font_size);

}


void handle_combo_box_for_color_pick_1(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[1]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_background_color= new_color;
    label_for_color_rgb[1]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[1]->setStyleSheet(s);
  }
  if (current_widget == GRID_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[1]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_grid_background_color= new_color;
    label_for_color_rgb[1]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[1]->setStyleSheet(s);
  }
  if (current_widget == EXTRA_RULE_1)
  {
    QString new_color= combo_box_for_color_pick[1]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_extra_rule_1_background_color= new_color;
    label_for_color_rgb[1]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[1]->setStyleSheet(s);
  }
  if (current_widget == HISTORY_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[1]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_history_background_color= new_color;
    label_for_color_rgb[1]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[1]->setStyleSheet(s);
  }
  if (current_widget == MAIN_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[1]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_menu_background_color= new_color;
    label_for_color_rgb[1]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[1]->setStyleSheet(s);
  }

  text_for_font_example_filler(label_for_color_rgb[0]->text(),
                               label_for_color_rgb[1]->text(),
                               actual_font_family,
                               actual_font_style,
                               actual_font_weight,
                               actual_font_size);

}

void handle_combo_box_for_color_pick_2(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[2]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_highlight_literal_color= new_color;
    label_for_color_rgb[2]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[2]->setStyleSheet(s);
  }

  if (current_widget == GRID_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[2]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_grid_cell_border_color= new_color;
    label_for_color_rgb[2]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[2]->setStyleSheet(s);
  }
}


void handle_combo_box_for_color_pick_3(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[3]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_highlight_identifier_color= new_color;
    label_for_color_rgb[3]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[3]->setStyleSheet(s);
  }

  if (current_widget == GRID_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[3]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_grid_outer_color= new_color;
    label_for_color_rgb[3]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[3]->setStyleSheet(s);
  }
}


void handle_combo_box_for_color_pick_4(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[4]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_highlight_comment_color= new_color;
    label_for_color_rgb[4]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[4]->setStyleSheet(s);
  }
}


void handle_combo_box_for_color_pick_5(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[5]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_highlight_operator_color= new_color;
    label_for_color_rgb[5]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[5]->setStyleSheet(s);
  }
}


void handle_combo_box_for_color_pick_6(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[6]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_highlight_keyword_color= new_color;
    label_for_color_rgb[6]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[6]->setStyleSheet(s);
  }
}


void handle_combo_box_for_color_pick_7(int item_number)
{
 if (current_widget == STATEMENT_WIDGET)
 {
   QString new_color= combo_box_for_color_pick[7]->itemText(item_number);
   new_color= copy_of_parent->canonical_color_name(new_color);
   copy_of_parent->new_ocelot_statement_prompt_background_color= new_color;
   label_for_color_rgb[7]->setText(copy_of_parent->rgb_to_color(new_color));
   QString s= "border: 1px solid black; background-color: ";
   s.append(copy_of_parent->qt_color(new_color));
   label_for_color_show[7]->setStyleSheet(s);
  }
  if (current_widget == GRID_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[7]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_grid_header_background_color= new_color;
    label_for_color_rgb[7]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[7]->setStyleSheet(s);
  }
}


void handle_combo_box_for_color_pick_8(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[8]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_border_color= new_color;
    label_for_color_rgb[8]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[8]->setStyleSheet(s);
  }
  if (current_widget == GRID_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[8]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_grid_focus_cell_background_color= new_color;
    label_for_color_rgb[8]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[8]->setStyleSheet(s);
  }
  if (current_widget == HISTORY_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[8]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_history_border_color= new_color;
    label_for_color_rgb[8]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[8]->setStyleSheet(s);
  }
  if (current_widget == MAIN_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[8]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_menu_border_color= new_color;
    label_for_color_rgb[8]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[8]->setStyleSheet(s);
  }
}


void handle_combo_box_for_color_pick_9(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[9]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_highlight_current_line_color= new_color;
    label_for_color_rgb[9]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[9]->setStyleSheet(s);
  }
}


void handle_combo_box_for_color_pick_10(int item_number)
{
  if (current_widget == STATEMENT_WIDGET)
  {
    QString new_color= combo_box_for_color_pick[10]->itemText(item_number);
    new_color= copy_of_parent->canonical_color_name(new_color);
    copy_of_parent->new_ocelot_statement_highlight_function_color= new_color;
    label_for_color_rgb[10]->setText(copy_of_parent->rgb_to_color(new_color));
    QString s= "border: 1px solid black; background-color: ";
    s.append(copy_of_parent->qt_color(new_color));
    label_for_color_show[10]->setStyleSheet(s);
  }
}

void handle_combo_box_for_font_any_change()
{
  QString *family= NULL;
  QString *size= NULL;
  QString *style= NULL;
  QString *weight= NULL;
  if (current_widget == STATEMENT_WIDGET)
  {
    family= &(copy_of_parent->new_ocelot_statement_font_family);
    size= &(copy_of_parent->new_ocelot_statement_font_size);
    style= &(copy_of_parent->new_ocelot_statement_font_style);
    weight= &(copy_of_parent->new_ocelot_statement_font_weight);
  }
  if (current_widget == GRID_WIDGET)
  {
    family= &(copy_of_parent->new_ocelot_grid_font_family);
    size= &(copy_of_parent->new_ocelot_grid_font_size);
    style= &(copy_of_parent->new_ocelot_grid_font_style);
    weight= &(copy_of_parent->new_ocelot_grid_font_weight);
  }
  if (current_widget == HISTORY_WIDGET)
  {
    family= &(copy_of_parent->new_ocelot_history_font_family);
    size= &(copy_of_parent->new_ocelot_history_font_size);
    style= &(copy_of_parent->new_ocelot_history_font_style);
    weight= &(copy_of_parent->new_ocelot_history_font_weight);
  }
  if (current_widget == MAIN_WIDGET)
  {
    family= &(copy_of_parent->new_ocelot_menu_font_family);
    size= &(copy_of_parent->new_ocelot_menu_font_size);
    style= &(copy_of_parent->new_ocelot_menu_font_style);
    weight= &(copy_of_parent->new_ocelot_menu_font_weight);
  }
  /* todo: just pass family, weight, style. no need for candidates */
  QString family_candidate, weight_candidate, style_candidate;
  combo_box_for_font_name_parse(combo_box_for_font_name->currentText(),
                                &family_candidate,
                                &weight_candidate,
                                &style_candidate);
  *family= family_candidate;
  *style= style_candidate;

  *weight= weight_candidate;

  QString ctu= combo_box_for_font_size->currentText();
  *size= ctu.left(ctu.size() - 2);

  text_for_font_example_filler(label_for_color_rgb[0]->text(),
                               label_for_color_rgb[1]->text(),
                               family_candidate,
                               style_candidate,
                               weight_candidate,
                               combo_box_for_font_size->currentText());
}

/*
  User changed one of the font dialog settings: name - weight style.
  Warning: something can return -1 if size was specified in pixels (whatever that means).
  We might set up so weight is either "bold" or "normal" but I don't want to contradict e.g. "Ubuntu Bold".
*/
void handle_combo_box_for_font_name_change(int i)
{
  (void)i;
  /* Hmm, won't this cause us to call handle_combo_box_for_any_change()? */
  QString family_candidate, weight_candidate, style_candidate;
  combo_box_for_font_name_parse(combo_box_for_font_name->currentText(),
                                &family_candidate,
                                &weight_candidate,
                                &style_candidate);
  handle_combo_box_for_font_any_change();
}

/* set combo_box_for_fontsize currentIndex = what's closest to actual size (might not be exact) */
void font_size_index_set(int actual_font_size_as_int)
{
  int index_of_closest_match= 0;
  {
    QString s;
    for (int j= 0; j < combo_box_for_font_size->count(); ++j)
    {
      int curr_as_int;
      s= combo_box_for_font_size->itemText(j);
      curr_as_int= s.left(s.size() - 2).toInt();
      int prev_as_int;
      if (j == 0) prev_as_int= -99999;
      else
      {
        s= combo_box_for_font_size->itemText(j - 1);
        prev_as_int= s.left(s.size() - 2).toInt();
      }
      bool is_between= false;
      if ((actual_font_size_as_int > prev_as_int) && (actual_font_size_as_int <= curr_as_int)) is_between= true;
      if (j == combo_box_for_font_size->count() - 1) is_between= true;
      if (is_between == true)
      {
        int diff_from_prev= actual_font_size_as_int - prev_as_int;
        int diff_from_curr= curr_as_int - actual_font_size_as_int;
        if (diff_from_prev < diff_from_curr)
        {
          index_of_closest_match= j - 1;
          break;
        }
        else
        {
          index_of_closest_match= j;
          break;
        }
      }
    }
  }
  combo_box_for_font_size->setCurrentIndex(index_of_closest_match);
}

/* User change one of the font dialog settings: size. */
void handle_combo_box_for_font_size_change(int i)
{
  if (i == -1) return; /* -1 can happen if box is cleared */
  handle_combo_box_for_font_any_change();
}

void handle_combo_box_for_any_highlighted(int i_of_font_name, int i_of_font_size)
{
  if (i_of_font_name == -1) i_of_font_name= combo_box_for_font_name->currentIndex();
  if (i_of_font_size == -1) i_of_font_size= combo_box_for_font_size->currentIndex();
  QString family_candidate, weight_candidate, style_candidate;
  QString text_of_font_name= combo_box_for_font_name->itemText(i_of_font_name);
  combo_box_for_font_name_parse(text_of_font_name,
                                &family_candidate,
                                &weight_candidate,
                                &style_candidate);
  QString text_of_font_size= combo_box_for_font_size->itemText(i_of_font_size);
  text_for_font_example_filler(label_for_color_rgb[0]->text(),
                               label_for_color_rgb[1]->text(),
                               family_candidate,
                               style_candidate,
                               weight_candidate,
                               text_of_font_size);
}

void handle_combo_box_for_font_name_highlighted(int i)
{
  handle_combo_box_for_any_highlighted(i, -1);
}

void handle_combo_box_for_font_size_highlighted(int i)
{
  handle_combo_box_for_any_highlighted(-1, i);
}

void handle_combo_box_for_syntax_check(int i)
{
  if (current_widget == STATEMENT_WIDGET)
    copy_of_parent->new_ocelot_statement_syntax_checker= QString::number(i);
}

void handle_spin_box_for_max_row_count(int i)
{
  if (current_widget == HISTORY_WIDGET)
    copy_of_parent->new_ocelot_history_max_row_count= QString::number(i);
}

void handle_combo_box_for_detached(int item_number)
{
  QString q= combo_box_for_detached->itemText(item_number);
  if (current_widget == HISTORY_WIDGET)
    copy_of_parent->new_ocelot_history_detached= q;
  else if (current_widget == GRID_WIDGET)
    copy_of_parent->new_ocelot_grid_detached= q;
  else if (current_widget == STATEMENT_WIDGET)
    copy_of_parent->new_ocelot_statement_detached= q;
  else
    copy_of_parent->new_ocelot_debug_detached= q;
}

void handle_combo_box_for_html_effects(int item_number)
{
  QString q= combo_box_for_detached->itemText(item_number);
  copy_of_parent->new_ocelot_grid_html_effects= q;
}

void handle_combo_box_for_top(int item_number)
{
  QString q= combo_box_for_top->itemText(item_number);
  if (current_widget == HISTORY_WIDGET)
    copy_of_parent->new_ocelot_history_top= q;
  else if (current_widget == GRID_WIDGET)
    copy_of_parent->new_ocelot_grid_top= q;
  else if (current_widget == STATEMENT_WIDGET)
    copy_of_parent->new_ocelot_statement_top= q;
  else
    copy_of_parent->new_ocelot_debug_top= q;
}

void handle_combo_box_for_left(int item_number)
{
  QString q= combo_box_for_left->itemText(item_number);
  if (current_widget == HISTORY_WIDGET)
    copy_of_parent->new_ocelot_history_left= q;
  else if (current_widget == GRID_WIDGET)
    copy_of_parent->new_ocelot_grid_left= q;
  else if (current_widget == STATEMENT_WIDGET)
    copy_of_parent->new_ocelot_statement_left= q;
  else
    copy_of_parent->new_ocelot_debug_left= q;
}

void handle_combo_box_for_width(int item_number)
{
  QString q= combo_box_for_width->itemText(item_number);
  if (current_widget == HISTORY_WIDGET)
    copy_of_parent->new_ocelot_history_width= q;
  else if (current_widget == GRID_WIDGET)
    copy_of_parent->new_ocelot_grid_width= q;
  else if (current_widget == STATEMENT_WIDGET)
    copy_of_parent->new_ocelot_statement_width= q;
  else
    copy_of_parent->new_ocelot_debug_width= q;
}

void handle_combo_box_for_height(int item_number)
{
  QString q= combo_box_for_height->itemText(item_number);
  if (current_widget == HISTORY_WIDGET)
    copy_of_parent->new_ocelot_history_height= q;
  else if (current_widget == GRID_WIDGET)
    copy_of_parent->new_ocelot_grid_height= q;
  else if (current_widget == STATEMENT_WIDGET)
    copy_of_parent->new_ocelot_statement_height= q;
  else
    copy_of_parent->new_ocelot_debug_height= q;
}

void handle_combo_box_for_size_0(int i)
{
  if (current_widget == GRID_WIDGET)
    copy_of_parent->new_ocelot_grid_cell_height= combo_box_for_size[0]->itemText(i);
  if (current_widget == EXTRA_RULE_1)
    copy_of_parent->new_ocelot_extra_rule_1_condition= combo_box_for_size[0]->itemText(i);
}


void handle_combo_box_for_size_1(int i)
{
  if (current_widget == GRID_WIDGET)
    copy_of_parent->new_ocelot_grid_cell_border_size= QString::number(i);
  if (current_widget == EXTRA_RULE_1)
    copy_of_parent->new_ocelot_extra_rule_1_display_as= combo_box_for_size[1]->itemText(i);
}


void handle_combo_box_for_size_2(int item_number)
{
  QString q= combo_box_for_size[2]->itemText(item_number);
  copy_of_parent->new_ocelot_grid_cell_width= q;
}


/* See comment that begins with the words "Font comments" */
int get_font_weight_as_qfont_weight(QString font_weight_string)
{
  int i= copy_of_parent->fontweights_index_via_chars(font_weight_string);
  if (i != -1) return fontweightsvalues[i].qt_number;
  return QFont::Normal; /* This should never happen */
}

QFont::Style get_font_style_as_qfont_style(QString font_style_string)
{
  if (QString::compare(font_style_string, "italic", Qt::CaseInsensitive) == 0) return QFont::StyleItalic;
  if (QString::compare(font_style_string, "oblique", Qt::CaseInsensitive) == 0) return QFont::StyleOblique;
  return QFont::StyleNormal;
}

/*
  Given color name, return index.
  Todo: It can be tricky, if color name isn't in the current language.
*/
int q_color_list_index(QString color_name_string)
{
//  char color_name_string_as_utf8[64];
//  int color_name_string_len;

//  color_name_string_len= color_name_string.size();             /* See comment "UTF8 Conversion" */
//  memcpy(color_name_string_as_utf8, color_name_string.toUtf8().constData(), color_name_string_len);
//  color_name_string_as_utf8[color_name_string_len]= '\0';

  for (int i= 0; i < copy_of_parent->q_color_list.size(); i+= 2)
  {
    if (QString::compare(color_name_string, copy_of_parent->q_color_list[i], Qt::CaseInsensitive) == 0) return i / 2;
    if (QString::compare(color_name_string, copy_of_parent->q_color_list[i + 1], Qt::CaseInsensitive) == 0) return i / 2;
  }
  //return (i - 1) / 2;
  return 0;  /* TEST! */
}

};
#endif // SETTINGS_H

/* QThread::msleep is protected in qt 4.8. so you have to say QThread48::msleep */
#ifndef QTHREAD48_H
#define QTHREAD48_H
class QThread48 : public QThread
{
public:
  static void msleep(int ms)
  {
    QThread::msleep(ms);
  }
};
#endif // QTHREAD48_H

/* QTabWidget:tabBar is protected in qt 4.8. so you have to say QTabWidget48::tabBar */

#ifndef QTABWIDGET48_H
#define QTABWIDGET48_H

class QTabWidget48 : public QTabWidget
{
public:
  QTabWidget48(QWidget *w = 0) : QTabWidget(w){}

public:
  QTabBar *tabBar() const
  {
    return QTabWidget::tabBar();
  }
};

#endif // QTABWIDGET48_H

/* THE PARSEPOP WIDGET */

//#ifndef QPARSEPOP_H
//#define QPARSEPOP_H
//class QPopper : public QTextEdit
//{
//
//public:
//  int settings_width, settings_height;
//
//QParsePop(int width, int height)
//{
//  settings_width= width;
//  settings_height= height;
//}
//
//virtual QSize sizeHint() const
//{
//  return QSize(settings_width, settings_height);
//}
//
//};
//#endif // QPARSEPOP_H

/*****************************************************************************************************************************/
/* THE TEXTEDITHISTORY WIDGET */

/* Subclass of QTextEditWidget used for history_edit_widget */

/*
   Events That Go To Detached Windows
   When we detach a widget by calling setWindowFlags(Qt::Window),
   it becomes independent so relevant events no longer go through
   MainWindow::eventFilter. Therefore each has its own event filter,
   to redirect events to MainWindow::eventFilter.
*/

/* Todo:
   It's unfortunate that a click on the main menu changes the focus.
   Several attempts have been made to fix this, e.g.
   the detached widget gets its own copy of the menu,
   focus-change events are intercepted and ignored.
   But nothing went well.
*/

#ifndef TEXTEDITHISTORY_H
#define TEXTEDITHISTORY_H

class TextEditHistory : public QTextEdit
{
  Q_OBJECT

public:

  MainWindow *main_window;

  TextEditHistory(MainWindow *parent) : QTextEdit(parent)
  {
    main_window= parent;
  }

  /* TODO: Following line caused an incomprehensible error. Removed temporarily. */
  /* Hmm. Maybe because we can call it for widgets that aren't subclasses of QTextEdit? */
  /* Notice there are other classes in this file where we use ~ without problem. */
  /* Watch for other classes where we fail to specify a destructor. */
  //~TextEditHistory();

public:
void detach_start()
{
  installEventFilter(this);
}
void detach_stop()
{
  removeEventFilter(this);
}

bool eventFilter(QObject *obj, QEvent *event)
{
  return main_window->eventfilter_function(obj, event);
}

};
#endif // TEXTEDITHISTORY_H

#ifndef XSETTINGS_H
#define XSETTINGS_H
class XSettings : public QWidget
{
  Q_OBJECT

/*
 This could be a separate .h file.
 For variables whose names begin with "ocelot_".
*/

/*
  For e.g. SET ocelot_statement_text_color='red'; or ocelotgui --statement_text_color='red'
  Call with e.g. ocelot_variable_set(TOKEN_KEYWORD_STATEMENT_TEXT_COLOR, text.mid(sub_token_offsets[3], sub_token_lengths[3])
  We used to have a lot of repetitive code here, now it's reduced.
  Todo: if debug compile, check that nobody changed keywords -- just put something in a comment?
  Todo: __attribute__((packed)) if gcc, but maybe it's enough to put char stuff at the end
  Todo: if compiled with debug, we need asserts at start to check that qstring_target addresses match token strings.
  Todo: in the original, we were doing nothing with ocelot_vertical, so it needs an extra look.
  Todo: Make sure ocelot_horizontal and ocelot_htmlraw, which have no variables, actually cause the changes.
  Todo: Check whether there has actually been a style change.
  Todo: For grid's set_all_style_sheets, we only redo existing display if there has been a font change.
  Todo: ocelot_grid_border_size isn't on the settings menu (well, we're not going to bother with it anyway)
  Todo: merge with Settings class?
*/

private:
#define OCELOT_VARIABLE_FLAG_SET_COLOR          0x01
#define OCELOT_VARIABLE_FLAG_SET_FONT           0x02
#define OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY    0x12
#define OCELOT_VARIABLE_FLAG_SET_FONT_STYLE     0x22
#define OCELOT_VARIABLE_FLAG_SET_FONT_SIZE      0x42
#define OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT    0x82
#define OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT    1
#define OCELOT_VARIABLE_ENUM_SET_FOR_GRID         2
#define OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY      3
#define OCELOT_VARIABLE_ENUM_SET_FOR_MENU         4
#define OCELOT_VARIABLE_ENUM_SET_FOR_EXTRA_RULE_1 5
#define OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT     6
#define OCELOT_VARIABLES_SIZE 126

struct ocelot_variable_keywords {
  QString *qstring_target;                /* e.g. &ocelot_statement_text_color */
  short unsigned int *int_target;         /* e.g. NULL */
  int maximum;                            /* e.g. -1 because it's not an int target */
  unsigned char flags_style;              /* e.g. OCELOT_VARIABLE_FLAG_SET_COLOR */
  unsigned char enums_for;                /* e.g. OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT */
  unsigned short int k_i;                 /* keyword_index */
};

ocelot_variable_keywords *ocelot_variables;
MainWindow *main_window;
int ocelot_variables_create();

int ocelot_variable_offset(int keyword_index)
{
  for (int i= 0; i < OCELOT_VARIABLES_SIZE; ++i)
  {
    if (ocelot_variables[i].k_i == keyword_index) return i;
  }
  return -1;
}

public:

XSettings(MainWindow *parent)
{
  main_window= parent;
#ifndef NDEBUG
  int v_size;
  ocelot_variables= new ocelot_variable_keywords[TOKEN_KEYWORD__UTF8MB4]; /* just to get ocelot_variables_size */
  v_size= ocelot_variables_create();
  delete[] ocelot_variables;
  assert(v_size == OCELOT_VARIABLES_SIZE);
#endif //NDEBUG
  ocelot_variables= new ocelot_variable_keywords[OCELOT_VARIABLES_SIZE]; /* permanent */
  ocelot_variables_create();
}

int ocelot_variable_set(int keyword_index, QString new_value);
bool ocelot_variable_is_color(int keyword);
bool ocelot_variable_is_font_weight(int keyword);
bool ocelot_variable_is_font_style(int keyword);
bool ocelot_variable_is_font_family(int keyword);
int ocelot_variables_size();
~XSettings();

};
#endif //#ifndef XSETTINGS_H

#endif // OCELOTGUI_H

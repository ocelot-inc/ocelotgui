/* Copyright (c) 2024 by Peter Gulutzan. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
*/

#ifndef OCELOTGUI_H
#define OCELOTGUI_H

/* If you tell CMakeLists.txt -DOCELOT_MYSQL_INCLUDE=0, you can't access MySQL/MariaDB. Of course default is 1 and recommended. */
#ifndef OCELOT_MYSQL_INCLUDE
#define OCELOT_MYSQL_INCLUDE 1
#endif

/* if you don't tell CMakeLists.txt -DOCELOT_QWT_INCLUDE=1, you can't access qwt. In this case default is 0. */
/* Bringing in the Qwt library was an experiment, it worked, but it isn't necessary so 0 is recommended. */
#ifndef OCELOT_QWT_INCLUDE
#define OCELOT_QWT_INCLUDE 0
#endif

/* Chart and QChart don't coexist. */
#if (OCELOT_QWT_INCLUDE == 1)
#define OCELOT_CHART 0
#endif

#define OCELOT_CHART_OR_QCHART (OCELOT_CHART | OCELOT_QWT_INCLUDE)

/* The debugger is integrated now, but "if (OCELOT_MYSQL_DEBUGGER = 1)" directives help to delineate code that is debugger-specific. */
#ifndef OCELOT_MYSQL_DEBUGGER
#define OCELOT_MYSQL_DEBUGGER OCELOT_MYSQL_INCLUDE
#endif

/* To remove most of the code related to Edit|Find feature if you don't need it, set OCELOT_FIND_WIDGET 0 */
#ifndef OCELOT_FIND_WIDGET
#define OCELOT_FIND_WIDGET 1
#endif

/* To remove most of the code related to SET ocelot_import|ocelot_export, set OCELOT_IMPORT_EXPORT 0 */
#ifndef OCELOT_IMPORT_EXPORT
#define OCELOT_IMPORT_EXPORT 1
#endif

/* To remove most of the code related to object explorer, #define OCELOT_EXPLORER 0 */
#ifndef OCELOT_EXPLORER
#define OCELOT_EXPLORER 1
#endif

/* To remove most of the code related to erdiagram, #define OCELOT_ERDIAGRAM 0 */
#ifndef OCELOT_ERDIAGRAM
#define OCELOT_ERDIAGRAM 1
#endif

/* To remove most of the code related to chart, #define OCELOT_CHART 0 */
#ifndef OCELOT_CHART
#define OCELOT_CHART 1
#define OCELOT_CHART_EVENTFILTER 0 /* for some diagnostics. normally 0. */
#endif

/* To remove most of the code related to extender, #define OCELOT_EXTENDER 0 */
#ifndef OCELOT_EXTENDER
#if (OCELOT_MYSQL_INCLUDE == 1)
#define OCELOT_EXTENDER 1
#else
#define OCELOT_EXTENDER 0
#endif
#endif

/* To remove most of the code related to plugin, #define OCELOT_PLUGIN 0 */
#ifndef OCELOT_PLUGIN
#define OCELOT_PLUGIN 1
#endif

/* To remove the way that dialogs are handled in ocelotgui 2.5, #define OCELOT_DIALOG 0 */
#ifndef OCELOT_DIALOG
#define OCELOT_DIALOG 1
#endif

/* To remove handling of Javascript literals in MySQL 9.0+, #define OCELOT_JAVASCRIPT 0 */
#ifndef OCELOT_JAVASCRIPT
#define OCELOT_JAVASCRIPT 1
#endif

#if (OCELOT_MYSQL_INCLUDE == 0)
typedef struct
{
  int not_really_mysql_res;
} MYSQL_RES;
#endif //#if (OCELOT_MYSQL_INCLUDE == 0)

/*
  Predefined OS macro
  I depend on https://sourceforge.net/p/predef/wiki/OperatingSystems/
  Also useful are Q_OS_... declarations in http://doc.qt.io/qt-5/qtglobal.html
  but they're not known until we do Qt includes, later.
  (So far, only ostrings.h has been #included.)
  See also ./CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp
  which checks for __CYGWIN__ and __MINGW32__.
  OCELOT_OS_LINUX is for Linux-specific code, actually tested on Linux
  OCELOT_OS_NONLINUX is for Qt-specific code, seems to work on Windows
  The idea is that, if we support more platforms, we'll add more
  e.g. OCELOT_OS_OPENBSD.
  With OCELOT_OS_FREEBSD we can build but haven't checked all the places
  where we check if it's nonlinux (which is also true if FreeBSD is true),
  so runtime failures are likely. Update: some fixes were tried on 2024-06-09.
  "__linux" and "linux" are obsolete, someday we'll stop looking for them
  Todo: we also check Q_OS_LINUX or Q_OS_FREEBSD Qt macros. Stop doing so?
*/
#if defined(__linux__) || defined(__linux) || defined(linux)
#define OCELOT_OS_LINUX
#else
#define OCELOT_OS_NONLINUX
#endif
#if defined(__FreeBSD__)
#define OCELOT_OS_FREEBSD
#endif

/* See comments before action_options_detach_history_widget */
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
#define IS_WAYLAND_POSSIBLE 1
#else
#define IS_WAYLAND_POSSIBLE 0
#endif

/* Copy of https://github.com/pgfindlib/pgfindlib.h */
#ifndef OCELOT_PGFINDLIB
#if defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD)
#define OCELOT_PGFINDLIB 1
#include "pgfindlib.h"
#endif
#else
#define OCELOT_PGFINDLIB 0
#endif

/*
  The possible DBMS values.
  These are related to ocelot_dbms values.
  --ocelot_dbms='mysql' is default. (unless cmake . -DDEFAULT_OPTION=something else)
  --ocelot_dbms='mariadb' is non-default but officially supported.
  --ocelot_dbms='tarantool' is non-default but should work.
  If we start as MySQL but then connect to MariaDB, or vice versa,
  it's okay because we change to what we connected to.
  If --ocelot_dbms='tarantool', connection must be to a Tarantool server.
  Before defining for a new version, check set_dbms_version_mask().
  In set_dbms_version_mask we set for the version and for lower versions,
  e.g. if it's MySQL 5.6 we set both FLAG_VERSION_MYSQL_5_5 and
  FLAG_VERSION_MYSQL_5_6.
  Currently the biggest flag value is 2097152 which is 2^21.
  Note: We often define the same number for different versions, for example for MySQL 5.5 and MySQL 5.6 it's 1,
        but if it's really necessary to distinguish versions we can use separate numbers, we have 32 bits.
  Note: MySQL 5.5 reached end-of-life in 2018, says https://endoflife.software/applications/databases/mysql
        so starting with ocelotgui 1.8 we treat it as the same as MySQL 5.6.
  Note: MariaDB 5.5 reached end-of-life in 2018, says https://endoflife.date/mariadb
        so starting with ocelotgui 1.8 we treat it as the same as MariaDB 10.0
  Note: We have a separate flag names for MariaDB 10.7 and 10.9 but the number is the same as for MariaDB 10.10
  Note: Tarantool 2.x + Tarantool 2.8 + Tarantool 2.9 all set FLAG_VERSION_TARANTOOL_2_7, we don't distinguish.
  Note: Tarantool 2.10 + Tarantool 2.11 all set FLAG_VERSION_TARANTOOL_2_10, we don't distinguish.
  Note: FLAG_VERSION_TARANTOOL_3_0 is currently the same as FLAG_VERSION_TARANTOOL_2_11 since our behaviour is the same.
  Note: Tarantool 3. any kind sets VERSION_TARANTOOL_3_0, we don't distinguish.
  Note: MySQL/MariaDB share values e.g. FLAG_VERSION_MARIADB_11_0 and FLAG_VERSION_TARANTOOL_2_10 both are 1048576.
        So we have to distinguish by checking what's being connected as well as what flag value matches.
        For example in hparse.h we say things like "if ((hparse_dbms_mask & flag_version) == 0) return 0;"
*/
#define DBMS_MYSQL 1
#define DBMS_MARIADB 2
#define DBMS_TARANTOOL 3
#define FLAG_VERSION_MYSQL_5_5      1
#define FLAG_VERSION_MYSQL_5_6      1
#define FLAG_VERSION_MYSQL_5_7      2
#define FLAG_VERSION_MYSQL_5_ALL    (FLAG_VERSION_MYSQL_5_5 | FLAG_VERSION_MYSQL_5_6 | FLAG_VERSION_MYSQL_5_7)
#define FLAG_VERSION_MYSQL_8_0      4
#define FLAG_VERSION_MYSQL_8_0_31   8
#define FLAG_VERSION_MYSQL_8_1      8
#define FLAG_VERSION_MYSQL_8_2      8
#define FLAG_VERSION_MYSQL_8_3      8
#define FLAG_VERSION_MYSQL_8_4      536870912
#define FLAG_VERSION_MYSQL_8_ALL    (FLAG_VERSION_MYSQL_8_0 | FLAG_VERSION_MYSQL_8_0_31 | FLAG_VERSION_MYSQL_8_1 | FLAG_VERSION_MYSQL_8_2 | FLAG_VERSION_MYSQL_8_3 | FLAG_VERSION_MYSQL_8_4)
#define FLAG_VERSION_MYSQL_9_0      1073741824
#define FLAG_VERSION_MYSQL_9_1      1073741824
#define FLAG_VERSION_MYSQL_9_2      1073741824
#define FLAG_VERSION_MYSQL_9_3      2147483648
#define FLAG_VERSION_MYSQL_9_ALL    (FLAG_VERSION_MYSQL_9_0 | FLAG_VERSION_MYSQL_9_1 | FLAG_VERSION_MYSQL_9_2 | FLAG_VERSION_MYSQL_9_3)
#define FLAG_VERSION_MYSQL_ALL      (FLAG_VERSION_MYSQL_5_ALL | FLAG_VERSION_MYSQL_8_ALL | FLAG_VERSION_MYSQL_9_ALL)
#define FLAG_VERSION_MARIADB_5_5    16
#define FLAG_VERSION_MARIADB_10_0   16
#define FLAG_VERSION_MARIADB_10_1   32
#define FLAG_VERSION_MARIADB_10_2_2 64
#define FLAG_VERSION_MARIADB_10_2_3 128
#define FLAG_VERSION_MARIADB_10_3   256
#define FLAG_VERSION_MARIADB_10_5   512
#define FLAG_VERSION_MARIADB_10_6   512
#define FLAG_VERSION_MARIADB_10_7   512
#define FLAG_VERSION_MARIADB_10_8   512
#define FLAG_VERSION_MARIADB_10_9   512
#define FLAG_VERSION_MARIADB_10_10  512
#define FLAG_VERSION_MARIADB_10_11  512
#define FLAG_VERSION_MARIADB_10_ALL (FLAG_VERSION_MARIADB_10_0 | FLAG_VERSION_MARIADB_10_1 | FLAG_VERSION_MARIADB_10_2_2 | FLAG_VERSION_MARIADB_10_2_3 | FLAG_VERSION_MARIADB_10_3 | FLAG_VERSION_MARIADB_10_7 | FLAG_VERSION_MARIADB_10_9 | FLAG_VERSION_MARIADB_10_10 | FLAG_VERSION_MARIADB_10_11)
#define FLAG_VERSION_MARIADB_11_0   1048576
#define FLAG_VERSION_MARIADB_11_1   2097152
#define FLAG_VERSION_MARIADB_11_2   4194304
#define FLAG_VERSION_MARIADB_11_3   8388608
#define FLAG_VERSION_MARIADB_11_4   8388608
#define FLAG_VERSION_MARIADB_11_5   16777216
#define FLAG_VERSION_MARIADB_11_6   33554432
#define FLAG_VERSION_MARIADB_11_7   67108864
#define FLAG_VERSION_MARIADB_11_8   67108864
#define FLAG_VERSION_MARIADB_11_ALL (FLAG_VERSION_MARIADB_11_0 | FLAG_VERSION_MARIADB_11_1 | FLAG_VERSION_MARIADB_11_2| FLAG_VERSION_MARIADB_11_4| FLAG_VERSION_MARIADB_11_5| FLAG_VERSION_MARIADB_11_6| FLAG_VERSION_MARIADB_11_7| FLAG_VERSION_MARIADB_11_8)
#define FLAG_VERSION_MARIADB_12_0   268435456
#define FLAG_VERSION_MARIADB_ALL    (FLAG_VERSION_MARIADB_5_5 | FLAG_VERSION_MARIADB_10_ALL | FLAG_VERSION_MARIADB_11_ALL | FLAG_VERSION_MARIADB_12_0)
#define FLAG_VERSION_MYSQL_OR_MARIADB_ALL (FLAG_VERSION_MYSQL_ALL | FLAG_VERSION_MARIADB_ALL)
#define FLAG_VERSION_TARANTOOL      1024
#define FLAG_VERSION_LUA            2048
#define FLAG_VERSION_PLSQL          4096
#define FLAG_VERSION_SET_OPTION         8192
#define FLAG_VERSION_CONNECT_OPTION     16384
#define FLAG_VERSION_OPTION             (FLAG_VERSION_SET_OPTION | FLAG_VERSION_CONNECT_OPTION)
#define FLAG_VERSION_TARANTOOL_2_2  32768
#define FLAG_VERSION_TARANTOOL_2_3  65536
#define FLAG_VERSION_LUA_OUTPUT       131072
#define FLAG_VERSION_TARANTOOL_2_4    262144
#define FLAG_VERSION_TARANTOOL_2_7    262144
#define FLAG_VERSION_TARANTOOL_2_10   1048576
#define FLAG_VERSION_TARANTOOL_2_11   2097152
#define FLAG_VERSION_TARANTOOL_3_0    FLAG_VERSION_TARANTOOL_2_11
#define FLAG_VERSION_TARANTOOL_ALL    (FLAG_VERSION_TARANTOOL | FLAG_VERSION_TARANTOOL_2_2 | FLAG_VERSION_TARANTOOL_2_3 | FLAG_VERSION_TARANTOOL_2_4 | FLAG_VERSION_TARANTOOL_2_7 | FLAG_VERSION_TARANTOOL_2_10  | FLAG_VERSION_TARANTOOL_2_11 | FLAG_VERSION_TARANTOOL_3_0)
#define FLAG_VERSION_ALL (FLAG_VERSION_MYSQL_ALL | FLAG_VERSION_MARIADB_ALL | FLAG_VERSION_TARANTOOL_ALL)
#define FLAG_VERSION_ALL_OR_LUA (FLAG_VERSION_ALL | FLAG_VERSION_LUA)
#define FLAG_VERSION_DEFAULT (FLAG_VERSION_MYSQL_OR_MARIADB_ALL)
#define FLAG_VERSION_CONDITIONAL 524288
/* Note: If adding support for a new version of any server, check set_dbms_version_mask(). */

/*
  Tarantool datetime support will only matter if Tarantool version >= 2.10 and datetimes are actually in use.
  If checking for datetime is unnecessary, change this line to #define TARANTOOL_DATETIMES 0" to save space.
*/
#ifdef DBMS_TARANTOOL
#define TARANTOOL_DATETIMES 1
#else
#define FLAG_VERSION_DATETIMES 0
#endif

#include <assert.h>
#include <stdint.h>

/*
  Decide whether to use static-linked library for use with MySQL/MariaDB.
  Builders can say cmake . -DOCELOT_STATIC_LIBRARY=1 to use.
  They will have to deliberately add an appropriate library when they
  build, probably libmariadb.a.
  Otherwise OCELOT_STATIC_LIBRARY=0 on Linux|FreeBSD, OCELOT_STATIC_LIBRARY=1 on Windows.
*/
#ifndef OCELOT_STATIC_LIBRARY
#ifdef OCELOT_OS_LINUX
#define OCELOT_STATIC_LIBRARY 0
#endif
#ifdef OCELOT_OS_FREEBSD
#define OCELOT_STATIC_LIBRARY 0
#endif
#ifndef OCELOT_STATIC_LIBRARY
#define OCELOT_STATIC_LIBRARY 1
#endif
#endif

/*
  Decide whether to #include third_party.h for use with Tarantool.
  Mostly third_party.h has tarantool-c source modified for Windows.
  By default it is included for both Windows and Linux starting with ocelotgui 1.0.7.
  To say it is not included, either build with cmake . -DOCELOT_THIRD_PARTY=0
  or change the lines below to say "#define OCELOT_THIRD_PARTY 0".
  If it is not included, then:
  (if you only connect to MariaDB / MySQL) it doesn't matter, we never use it
  (if you start with --ocelot_dbms=tarantool) ocelotgui will load libtarantool.so.
  On Windows there is no libtarantool.so.
  On Linux libtarantool.so is easily acquired by installing and building from
  tarantool-c, and actually it's probably better to use libtarantool.so because
  it may contain bug fixes or enhancements, so it's actually good on Linux to not include third_party.h.
  We only include it on Linux so that the code base on Linux and Windows will be the same.
  Todo: I've never tried to find libtarantool.so on FreeBSD.
*/
#ifndef OCELOT_THIRD_PARTY
#ifdef OCELOT_OS_LINUX
#define OCELOT_THIRD_PARTY 1
#endif
#ifdef OCELOT_OS_NONLINUX
#ifdef OCELOT_OS_FREEBSD
#define OCELOT_THIRD_PARTY 1
#else
#define OCELOT_THIRD_PARTY 1
#endif
#endif
#endif


/*
  When building Qt + libmariadb.a on Windows we have to exclude mysql_server_end + mysql_library_end + mysql_get_client_info.
  We don't have Q_OS_WIN32 yet but this should establish we're calling from MinGW-64 with 32-bit.
  If we can't call mysql_get-client_info then we don't really know Connector/C version number so we'll assume 3.3.8.
   #I've seen a claim that this is unnecessary and I can use .lib as long as it's 32-bit, but I didn't try that.
   #Read https://stackoverflow.com/questions/11793370/how-can-i-convert-a-vsts-lib-to-a-mingw-a
   #Read "generating an import library for a dll"
   #Read https://code.google.com/archive/p/lib2a/
   #Read Ocelot's README.
*/
#define MINGW_MARIADB 0
#ifdef _WIN32
#if (OCELOT_STATIC_LIBRARY == 1)
#undef MINGW_MARIADB
#define MINGW_MARIADB 1
#endif
#endif

enum {                                        /* possible returns from token_type() */
  TOKEN_TYPE_LITERAL_WITH_SINGLE_QUOTE= 1, /* starts with ' or N' or X' or B' */
  TOKEN_TYPE_LITERAL_WITH_DOUBLE_QUOTE= 2, /* starts with " */
  TOKEN_TYPE_LITERAL_WITH_DIGIT= 3,        /* starts with 0-9 */
  TOKEN_TYPE_LITERAL_WITH_BRACKET= 4,      /* starts with [[, Lua only */
  TOKEN_TYPE_LITERAL_WITH_BRACE= 5,        /* starts with { */ /* obsolete? */
  TOKEN_TYPE_LITERAL= 5,
  TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK= 6,  /* starts with ` */
  TOKEN_TYPE_IDENTIFIER_WITH_DOUBLE_QUOTE= 7, /* starts with " and hparse_ansi_quote=true */
  TOKEN_TYPE_IDENTIFIER_WITH_AT= 8,        /* starts with @ */
  TOKEN_TYPE_IDENTIFIER= 8,
  TOKEN_TYPE_COMMENT_WITH_SLASH = 9,        /* starts with / * or * / */
  TOKEN_TYPE_COMMENT_WITH_OCTOTHORPE= 10,   /* starts with # */
  TOKEN_TYPE_COMMENT_WITH_MINUS= 11,        /* starts with -- */
  TOKEN_TYPE_OPERATOR= 12,                 /* starts with < > = ! etc. */
  TOKEN_TYPE_OTHER= 13,                    /* identifier? keyword? */
  /* The TOKEN_KEYWORD_... numbers must match the strvalues list for tokens_to_keywords(). */
  TOKEN_KEYWORDS_START= TOKEN_TYPE_OTHER + 1,
  TOKEN_KEYWORD_QUESTIONMARK= TOKEN_KEYWORDS_START, /* ocelotgui keyword */
    TOKEN_KEYWORD_ABORT,
    TOKEN_KEYWORD_ABORT_SOURCE_ON_ERROR,
    TOKEN_KEYWORD_ABS,
    TOKEN_KEYWORD_ACCESSIBLE,
    TOKEN_KEYWORD_ACOS,
    TOKEN_KEYWORD_ACTION,
    TOKEN_KEYWORD_ADD,
    TOKEN_KEYWORD_ADDDATE,
    TOKEN_KEYWORD_ADDTIME,
    TOKEN_KEYWORD_ADD_MONTHS,
    TOKEN_KEYWORD_AES_DECRYPT,
    TOKEN_KEYWORD_AES_ENCRYPT,
    TOKEN_KEYWORD_AFTER,
    TOKEN_KEYWORD_AGAINST,
    TOKEN_KEYWORD_ALGORITHM,
    TOKEN_KEYWORD_ALL,
    TOKEN_KEYWORD_ALTER,
    TOKEN_KEYWORD_ALWAYS,
    TOKEN_KEYWORD_ANALYZE,
    TOKEN_KEYWORD_AND,
    TOKEN_KEYWORD_ANY,
    TOKEN_KEYWORD_ANY_VALUE,
    TOKEN_KEYWORD_APPEND, /* no longer used */
    TOKEN_KEYWORD_AREA,
    TOKEN_KEYWORD_ARRAY,
    TOKEN_KEYWORD_AS,
    TOKEN_KEYWORD_ASBINARY,
    TOKEN_KEYWORD_ASC,
    TOKEN_KEYWORD_ASCII,
    TOKEN_KEYWORD_ASENSITIVE,
    TOKEN_KEYWORD_ASIN,
    TOKEN_KEYWORD_ASTEXT,
    TOKEN_KEYWORD_ASWKB,
    TOKEN_KEYWORD_ASWKT,
    TOKEN_KEYWORD_ASYMMETRIC_DECRYPT,
    TOKEN_KEYWORD_ASYMMETRIC_DERIVE,
    TOKEN_KEYWORD_ASYMMETRIC_ENCRYPT,
    TOKEN_KEYWORD_ASYMMETRIC_SIGN,
    TOKEN_KEYWORD_ASYMMETRIC_VERIFY,
    TOKEN_KEYWORD_ATAN,
    TOKEN_KEYWORD_ATAN2,
    TOKEN_KEYWORD_ATOMIC,
    TOKEN_KEYWORD_ATTACH,
    TOKEN_KEYWORD_ATTRIBUTE,
    TOKEN_KEYWORD_AUTOINCREMENT,
        TOKEN_KEYWORD_AUTO_REHASH,
        TOKEN_KEYWORD_AUTO_VERTICAL_OUTPUT,
    TOKEN_KEYWORD_AVG,
    TOKEN_KEYWORD_BACKGROUND,
    TOKEN_KEYWORD_BACKUP_ADMIN,
    TOKEN_KEYWORD_BAR,
    TOKEN_KEYWORD_BATCH,
    TOKEN_KEYWORD_BECOMES,
    TOKEN_KEYWORD_BEFORE,
    TOKEN_KEYWORD_BEGIN,
    TOKEN_KEYWORD_BENCHMARK,
    TOKEN_KEYWORD_BETWEEN,
    TOKEN_KEYWORD_BFILE,
    TOKEN_KEYWORD_BIGINT,
    TOKEN_KEYWORD_BIN,
    TOKEN_KEYWORD_BINARY,
    TOKEN_KEYWORD_BINARY_DOUBLE,
    TOKEN_KEYWORD_BINARY_FLOAT,
    TOKEN_KEYWORD_BINARY_MODE,
    TOKEN_KEYWORD_BIND,
    TOKEN_KEYWORD_BIND_ADDRESS,
    TOKEN_KEYWORD_BINLOG,
    TOKEN_KEYWORD_BINLOG_ADMIN,
    TOKEN_KEYWORD_BINLOG_GTID_POS,
    TOKEN_KEYWORD_BIT,
    TOKEN_KEYWORD_BIT_AND,
    TOKEN_KEYWORD_BIT_COUNT,
    TOKEN_KEYWORD_BIT_LENGTH,
    TOKEN_KEYWORD_BIT_OR,
    TOKEN_KEYWORD_BIT_XOR,
    TOKEN_KEYWORD_BLOB,
    TOKEN_KEYWORD_BODY,
    TOKEN_KEYWORD_BOOL,
    TOKEN_KEYWORD_BOOLEAN,
    TOKEN_KEYWORD_BOTH,
    TOKEN_KEYWORD_BREAK,
    TOKEN_KEYWORD_BUFFER,
    TOKEN_KEYWORD_BUSY_TIMEOUT,
    TOKEN_KEYWORD_BY,
    TOKEN_KEYWORD_CALL,
    TOKEN_KEYWORD_CASCADE,
    TOKEN_KEYWORD_CASE,
    TOKEN_KEYWORD_CAST,
    TOKEN_KEYWORD_CATALOG,
    TOKEN_KEYWORD_CEIL,
    TOKEN_KEYWORD_CEILING,
    TOKEN_KEYWORD_CENTROID,
    TOKEN_KEYWORD_CHANGE,
    TOKEN_KEYWORD_CHAR,
    TOKEN_KEYWORD_CHARACTER,
    TOKEN_KEYWORD_CHARACTER_LENGTH,

    TOKEN_KEYWORD_CHARACTER_SETS_DIR,


    TOKEN_KEYWORD_CHARSET,
    TOKEN_KEYWORD_CHART,
    TOKEN_KEYWORD_CHAR_LENGTH,
    TOKEN_KEYWORD_CHECK,
    TOKEN_KEYWORD_CHR,
    TOKEN_KEYWORD_CLEAR,
    TOKEN_KEYWORD_CLOB,
    TOKEN_KEYWORD_CLOSE,
    TOKEN_KEYWORD_COALESCE,
    TOKEN_KEYWORD_COERCIBILITY,
    TOKEN_KEYWORD_COLLATE,
    TOKEN_KEYWORD_COLLATION,
    TOKEN_KEYWORD_COLLATION_LIST,
    TOKEN_KEYWORD_COLUMN,
    TOKEN_KEYWORD_COLUMNS,
    TOKEN_KEYWORD_COLUMN_ADD,
    TOKEN_KEYWORD_COLUMN_CHECK,
    TOKEN_KEYWORD_COLUMN_CREATE,
    TOKEN_KEYWORD_COLUMN_DELETE,
    TOKEN_KEYWORD_COLUMN_EXISTS,
    TOKEN_KEYWORD_COLUMN_GET,
    TOKEN_KEYWORD_COLUMN_JSON,
    TOKEN_KEYWORD_COLUMN_LIST,
    TOKEN_KEYWORD_COLUMN_NAME,
    TOKEN_KEYWORD_COLUMN_NAMES,
    TOKEN_KEYWORD_COLUMN_NUMBER,
    TOKEN_KEYWORD_COLUMN_TYPE,
    TOKEN_KEYWORD_COLUMN_TYPE_INFO,

    TOKEN_KEYWORD_COMMA,
    TOKEN_KEYWORD_COMMENT,
        TOKEN_KEYWORD_COMMENTS,
    TOKEN_KEYWORD_COMMIT,
    TOKEN_KEYWORD_COMPACT,
    TOKEN_KEYWORD_COMPRESS,
    TOKEN_KEYWORD_COMPRESSED,
    TOKEN_KEYWORD_COMPRESSION,
    TOKEN_KEYWORD_CONCAT,
    TOKEN_KEYWORD_CONCAT_WS,
    TOKEN_KEYWORD_CONDITION,
    TOKEN_KEYWORD_CONFLICT,
    TOKEN_KEYWORD_CONNECT,
    TOKEN_KEYWORD_CONNECTION,
    TOKEN_KEYWORD_CONNECTION_ADMIN,
        TOKEN_KEYWORD_CONNECTION_ID,
    TOKEN_KEYWORD_CONNECT_ATTR_DELETE,
    TOKEN_KEYWORD_CONNECT_ATTR_RESET,
    TOKEN_KEYWORD_CONNECT_EXPIRED_PASSWORD,
    TOKEN_KEYWORD_CONNECT_TIMEOUT,

    TOKEN_KEYWORD_CONSTRAINT,
    TOKEN_KEYWORD_CONTAINS,
    TOKEN_KEYWORD_CONTINUE,
    TOKEN_KEYWORD_CONV,
    TOKEN_KEYWORD_CONVERT,
    TOKEN_KEYWORD_CONVERT_TZ,
    TOKEN_KEYWORD_CONVEXHULL,
    TOKEN_KEYWORD_COS,
    TOKEN_KEYWORD_COT,
    TOKEN_KEYWORD_COUNT,
    TOKEN_KEYWORD_CRC32,
    TOKEN_KEYWORD_CRC32C,
    TOKEN_KEYWORD_CREATE,
    TOKEN_KEYWORD_CREATE_ASYMMETRIC_PRIV_KEY,
    TOKEN_KEYWORD_CREATE_ASYMMETRIC_PUB_KEY,
    TOKEN_KEYWORD_CREATE_DH_PARAMETERS,
    TOKEN_KEYWORD_CREATE_DIGEST,
    TOKEN_KEYWORD_CROSS,
    TOKEN_KEYWORD_CROSSES,
    TOKEN_KEYWORD_CUBE,
    TOKEN_KEYWORD_CUME_DIST,
    TOKEN_KEYWORD_CURDATE,
    TOKEN_KEYWORD_CURRENT,
    TOKEN_KEYWORD_CURRENT_DATE,
    TOKEN_KEYWORD_CURRENT_ROLE,
    TOKEN_KEYWORD_CURRENT_TIME,
    TOKEN_KEYWORD_CURRENT_TIMESTAMP,
    TOKEN_KEYWORD_CURRENT_USER,
    TOKEN_KEYWORD_CURSOR,
    TOKEN_KEYWORD_CURTIME,
    TOKEN_KEYWORD_CYCLE,
    TOKEN_KEYWORD_DATABASE,
    TOKEN_KEYWORD_DATABASES,
    TOKEN_KEYWORD_DATE,
    TOKEN_KEYWORD_DATEDIFF,
    TOKEN_KEYWORD_DATETIME,
    TOKEN_KEYWORD_DATE_ADD,
    TOKEN_KEYWORD_DATE_FORMAT,
    TOKEN_KEYWORD_DATE_SUB,
    TOKEN_KEYWORD_DAY,
    TOKEN_KEYWORD_DAYNAME,
    TOKEN_KEYWORD_DAYOFMONTH,
    TOKEN_KEYWORD_DAYOFWEEK,
    TOKEN_KEYWORD_DAYOFYEAR,
    TOKEN_KEYWORD_DAY_HOUR,
    TOKEN_KEYWORD_DAY_MICROSECOND,
    TOKEN_KEYWORD_DAY_MINUTE,
    TOKEN_KEYWORD_DAY_SECOND,
    TOKEN_KEYWORD_DEALLOCATE,
    TOKEN_KEYWORD_DEBUG,
    TOKEN_KEYWORD_DEBUG_CHECK,
    TOKEN_KEYWORD_DEBUG_INFO,
    TOKEN_KEYWORD_DEC,
    TOKEN_KEYWORD_DECIMAL,
    TOKEN_KEYWORD_DECLARE,
    TOKEN_KEYWORD_DECODE,
    TOKEN_KEYWORD_DECODE_HISTOGRAM,
    TOKEN_KEYWORD_DEFAULT,
    TOKEN_KEYWORD_DEFAULTS_EXTRA_FILE,
    TOKEN_KEYWORD_DEFAULTS_FILE,
    TOKEN_KEYWORD_DEFAULTS_GROUP_SUFFIX,
    TOKEN_KEYWORD_DEFAULT_AUTH,
    TOKEN_KEYWORD_DEFAULT_CHARACTER_SET,
    TOKEN_KEYWORD_DEFERRABLE,
    TOKEN_KEYWORD_DEFERRED,
    TOKEN_KEYWORD_DEGREES,
    TOKEN_KEYWORD_DELAYED,
    TOKEN_KEYWORD_DELETE,
    TOKEN_KEYWORD_DELIMITER,
    TOKEN_KEYWORD_DENSE_RANK,
    TOKEN_KEYWORD_DESC,
    TOKEN_KEYWORD_DESCRIBE,
    TOKEN_KEYWORD_DES_DECRYPT,
    TOKEN_KEYWORD_DES_ENCRYPT,
    TOKEN_KEYWORD_DETACH,
    TOKEN_KEYWORD_DETERMINISTIC,
    TOKEN_KEYWORD_DIMENSION,
    TOKEN_KEYWORD_DIRECTORY,
    TOKEN_KEYWORD_DISJOINT,
    TOKEN_KEYWORD_DISTANCE,
    TOKEN_KEYWORD_DISTINCT,
    TOKEN_KEYWORD_DISTINCTROW,
    TOKEN_KEYWORD_DIV,
    TOKEN_KEYWORD_DIVIDER,
    TOKEN_KEYWORD_DO,
    TOKEN_KEYWORD_DOUBLE,
    TOKEN_KEYWORD_DROP,
    TOKEN_KEYWORD_DUAL,
    TOKEN_KEYWORD_DUPLICATE,
    TOKEN_KEYWORD_DYNAMIC,
    TOKEN_KEYWORD_EACH,
    TOKEN_KEYWORD_EDIT,
    TOKEN_KEYWORD_EGO,
    TOKEN_KEYWORD_ELSE,
    TOKEN_KEYWORD_ELSEIF,
    TOKEN_KEYWORD_ELSIF,
    TOKEN_KEYWORD_ELT,
    TOKEN_KEYWORD_EMPTY,
    TOKEN_KEYWORD_ENABLE,
        TOKEN_KEYWORD_ENABLE_CLEARTEXT_PLUGIN,
    TOKEN_KEYWORD_ENCLOSED,
    TOKEN_KEYWORD_ENCODE,
    TOKEN_KEYWORD_ENCRYPT,
    TOKEN_KEYWORD_ENCRYPTION_KEY_ADMIN,
    TOKEN_KEYWORD_END,
    TOKEN_KEYWORD_ENDPOINT,
    TOKEN_KEYWORD_ENGINE,
    TOKEN_KEYWORD_ENUM,
    TOKEN_KEYWORD_ENVELOPE,
    TOKEN_KEYWORD_EQUALS,
    TOKEN_KEYWORD_ERDIAGRAM, /* we used to have TOKEN_KEYWORD_ERROR here but no longer use it */
    TOKEN_KEYWORD_ESCAPE,
    TOKEN_KEYWORD_ESCAPED,
    TOKEN_KEYWORD_EVENT,
    TOKEN_KEYWORD_EXAMINED,
    TOKEN_KEYWORD_EXCEPT,
    TOKEN_KEYWORD_EXCEPTION,
    TOKEN_KEYWORD_EXCHANGE,
    TOKEN_KEYWORD_EXCLUSIVE,
    TOKEN_KEYWORD_EXECUTE,
    TOKEN_KEYWORD_EXISTS,
    TOKEN_KEYWORD_EXIT,
    TOKEN_KEYWORD_EXP,
    TOKEN_KEYWORD_EXPANSION,
    TOKEN_KEYWORD_EXPLAIN,
    TOKEN_KEYWORD_EXPORT,
    TOKEN_KEYWORD_EXPORT_SET,
    TOKEN_KEYWORD_EXTERIORRING,
    TOKEN_KEYWORD_EXTRACT,
    TOKEN_KEYWORD_EXTRACTVALUE,
    TOKEN_KEYWORD_FAIL,
    TOKEN_KEYWORD_FALSE,
    TOKEN_KEYWORD_FEDERATED,
    TOKEN_KEYWORD_FETCH,
    TOKEN_KEYWORD_FIELD,
    TOKEN_KEYWORD_FIELDS,
    TOKEN_KEYWORD_FILE,
    TOKEN_KEYWORD_FIND_IN_SET,
    TOKEN_KEYWORD_FIREWALL_ADMIN,
    TOKEN_KEYWORD_FIREWALL_USER,
    TOKEN_KEYWORD_FIRST,
    TOKEN_KEYWORD_FIRST_VALUE,
    TOKEN_KEYWORD_FIXED,
    TOKEN_KEYWORD_FLOAT,
    TOKEN_KEYWORD_FLOAT4,
    TOKEN_KEYWORD_FLOAT8,
    TOKEN_KEYWORD_FLOOR,
    TOKEN_KEYWORD_FLUSH,
    TOKEN_KEYWORD_FOLLOWING,
    TOKEN_KEYWORD_FOLLOWS,
    TOKEN_KEYWORD_FOR,
    TOKEN_KEYWORD_FORCE,
    TOKEN_KEYWORD_FOREIGN,
    TOKEN_KEYWORD_FOREIGN_KEY_LIST,
    TOKEN_KEYWORD_FORMAT,
    TOKEN_KEYWORD_FORMAT_BYTES,
    TOKEN_KEYWORD_FORMAT_PICO_TIME,
    TOKEN_KEYWORD_FOUND,
    TOKEN_KEYWORD_FOUND_ROWS,
    TOKEN_KEYWORD_FROM,
    TOKEN_KEYWORD_FROM_BASE64,
    TOKEN_KEYWORD_FROM_DAYS,
    TOKEN_KEYWORD_FROM_UNIXTIME,
    TOKEN_KEYWORD_FULL,
    TOKEN_KEYWORD_FULLTEXT,
    TOKEN_KEYWORD_FUNCTION,
    TOKEN_KEYWORD_GENERAL,
    TOKEN_KEYWORD_GENERATED,
    TOKEN_KEYWORD_GEOMCOLLFROMTEXT,
    TOKEN_KEYWORD_GEOMCOLLFROMWKB,
    TOKEN_KEYWORD_GEOMETRY,
    TOKEN_KEYWORD_GEOMETRYCOLLECTION,
    TOKEN_KEYWORD_GEOMETRYCOLLECTIONFROMTEXT,
    TOKEN_KEYWORD_GEOMETRYCOLLECTIONFROMWKB,
    TOKEN_KEYWORD_GEOMETRYFROMTEXT,
    TOKEN_KEYWORD_GEOMETRYFROMWKB,
    TOKEN_KEYWORD_GEOMETRYN,
    TOKEN_KEYWORD_GEOMETRYTYPE,
    TOKEN_KEYWORD_GEOMFROMTEXT,
    TOKEN_KEYWORD_GEOMFROMWKB,
    TOKEN_KEYWORD_GET,
    TOKEN_KEYWORD_GET_FORMAT,
    TOKEN_KEYWORD_GET_LOCK,
    TOKEN_KEYWORD_GLENGTH,
    TOKEN_KEYWORD_GLOBAL,
    TOKEN_KEYWORD_GO,
    TOKEN_KEYWORD_GOTO,
    TOKEN_KEYWORD_GRANT,
    TOKEN_KEYWORD_GREATEST,
    TOKEN_KEYWORD_GROUP,
    TOKEN_KEYWORD_GROUPING,
    TOKEN_KEYWORD_GROUPS,
    TOKEN_KEYWORD_GROUP_CONCAT,
    TOKEN_KEYWORD_GROUP_REPLICATION_ADMIN,
    TOKEN_KEYWORD_GTID_SUBSET,
    TOKEN_KEYWORD_GTID_SUBTRACT,
    TOKEN_KEYWORD_HANDLER,
    TOKEN_KEYWORD_HAVING,
    TOKEN_KEYWORD_HELP,
    TOKEN_KEYWORD_HEX,
    TOKEN_KEYWORD_HIGH_PRIORITY,
    TOKEN_KEYWORD_HISTFILE,
    TOKEN_KEYWORD_HISTIGNORE,
    TOKEN_KEYWORD_HOST,

    TOKEN_KEYWORD_HOUR,
    TOKEN_KEYWORD_HOUR_MICROSECOND,
    TOKEN_KEYWORD_HOUR_MINUTE,
    TOKEN_KEYWORD_HOUR_SECOND,
        TOKEN_KEYWORD_HTML,
    TOKEN_KEYWORD_IDENTIFIER,
    TOKEN_KEYWORD_IF,
    TOKEN_KEYWORD_IFNULL,
    TOKEN_KEYWORD_IGNORE,
        TOKEN_KEYWORD_IGNORE_SPACES,
    TOKEN_KEYWORD_IMMEDIATE,
    TOKEN_KEYWORD_IMPORT, /* unused */
    TOKEN_KEYWORD_IN,
    TOKEN_KEYWORD_INDEX,
    TOKEN_KEYWORD_INDEXED,
    TOKEN_KEYWORD_INDEX_INFO,
    TOKEN_KEYWORD_INDEX_LIST,
    TOKEN_KEYWORD_INET4,
    TOKEN_KEYWORD_INET6,
    TOKEN_KEYWORD_INET6_ATON,
    TOKEN_KEYWORD_INET6_NTOA,
    TOKEN_KEYWORD_INET_ATON,
    TOKEN_KEYWORD_INET_NTOA,
    TOKEN_KEYWORD_INFILE,
    TOKEN_KEYWORD_INITIALLY,
        TOKEN_KEYWORD_INIT_COMMAND,
    TOKEN_KEYWORD_INNER,
    TOKEN_KEYWORD_INOUT,
    TOKEN_KEYWORD_INSENSITIVE,
    TOKEN_KEYWORD_INSERT,
    TOKEN_KEYWORD_INSTALL,
    TOKEN_KEYWORD_INSTEAD,
    TOKEN_KEYWORD_INSTR,
    TOKEN_KEYWORD_INT,
    TOKEN_KEYWORD_INT1,
    TOKEN_KEYWORD_INT2,
    TOKEN_KEYWORD_INT3,
    TOKEN_KEYWORD_INT4,
    TOKEN_KEYWORD_INT8,
    TOKEN_KEYWORD_INTEGER,
    TOKEN_KEYWORD_INTERIORRINGN,
    TOKEN_KEYWORD_INTERSECT,
    TOKEN_KEYWORD_INTERSECTS,
    TOKEN_KEYWORD_INTERVAL,
    TOKEN_KEYWORD_INTO,
    TOKEN_KEYWORD_IO_AFTER_GTIDS,
    TOKEN_KEYWORD_IO_BEFORE_GTIDS,
    TOKEN_KEYWORD_IS,
    TOKEN_KEYWORD_ISCLOSED,
    TOKEN_KEYWORD_ISEMPTY,
    TOKEN_KEYWORD_ISNULL,
    TOKEN_KEYWORD_ISSIMPLE,
    TOKEN_KEYWORD_IS_FREE_LOCK,
    TOKEN_KEYWORD_IS_IPV4,
    TOKEN_KEYWORD_IS_IPV4_COMPAT,
    TOKEN_KEYWORD_IS_IPV4_MAPPED,
    TOKEN_KEYWORD_IS_IPV6,
    TOKEN_KEYWORD_IS_USED_LOCK,
    TOKEN_KEYWORD_ITERATE,
    TOKEN_KEYWORD_JAVASCRIPT,
    TOKEN_KEYWORD_JOIN,
    TOKEN_KEYWORD_JSON,
    TOKEN_KEYWORD_JSON_APPEND,
    TOKEN_KEYWORD_JSON_ARRAY,
    TOKEN_KEYWORD_JSON_ARRAYAGG,
    TOKEN_KEYWORD_JSON_ARRAY_APPEND,
    TOKEN_KEYWORD_JSON_ARRAY_INSERT,
    TOKEN_KEYWORD_JSON_ARRAY_INTERSECT,
    TOKEN_KEYWORD_JSON_COMPACT,
    TOKEN_KEYWORD_JSON_CONTAINS,
    TOKEN_KEYWORD_JSON_CONTAINS_PATH,
    TOKEN_KEYWORD_JSON_DEPTH,
    TOKEN_KEYWORD_JSON_DETAILED,
    TOKEN_KEYWORD_JSON_EQUALS,
    TOKEN_KEYWORD_JSON_EXISTS,
    TOKEN_KEYWORD_JSON_EXTRACT,
    TOKEN_KEYWORD_JSON_INSERT,
    TOKEN_KEYWORD_JSON_KEYS,
    TOKEN_KEYWORD_JSON_KEY_VALUE,
    TOKEN_KEYWORD_JSON_LENGTH,
    TOKEN_KEYWORD_JSON_LOOSE,
    TOKEN_KEYWORD_JSON_MERGE,
    TOKEN_KEYWORD_JSON_MERGE_PATCH,
    TOKEN_KEYWORD_JSON_MERGE_PRESERVE,
    TOKEN_KEYWORD_JSON_NORMALIZE,
    TOKEN_KEYWORD_JSON_OBJECT,
    TOKEN_KEYWORD_JSON_OBJECTAGG,
    TOKEN_KEYWORD_JSON_OBJECT_FILTER_KEYS,
    TOKEN_KEYWORD_JSON_OBJECT_TO_ARRAY,
    TOKEN_KEYWORD_JSON_OVERLAPS,
    TOKEN_KEYWORD_JSON_PRETTY,
    TOKEN_KEYWORD_JSON_QUERY,
    TOKEN_KEYWORD_JSON_QUOTE,
    TOKEN_KEYWORD_JSON_REMOVE,
    TOKEN_KEYWORD_JSON_REPLACE,
    TOKEN_KEYWORD_JSON_SCHEMA_VALID,
    TOKEN_KEYWORD_JSON_SCHEMA_VALIDATION_REPORT,
    TOKEN_KEYWORD_JSON_SEARCH,
    TOKEN_KEYWORD_JSON_SET,
    TOKEN_KEYWORD_JSON_STORAGE_FREE,
    TOKEN_KEYWORD_JSON_STORAGE_SIZE,
    TOKEN_KEYWORD_JSON_TABLE,
    TOKEN_KEYWORD_JSON_TYPE,
    TOKEN_KEYWORD_JSON_UNQUOTE,
    TOKEN_KEYWORD_JSON_VALID,
    TOKEN_KEYWORD_JSON_VALUE,
    TOKEN_KEYWORD_JULIANDAY,
    TOKEN_KEYWORD_KDF,
    TOKEN_KEYWORD_KEY,
    TOKEN_KEYWORD_KEYS,
    TOKEN_KEYWORD_KEYWORD,
    TOKEN_KEYWORD_KILL,
    TOKEN_KEYWORD_LAG,
    TOKEN_KEYWORD_LANGUAGE,
    TOKEN_KEYWORD_LAST,
    TOKEN_KEYWORD_LASTVAL,
    TOKEN_KEYWORD_LAST_DAY,
    TOKEN_KEYWORD_LAST_INSERT_ID,
    TOKEN_KEYWORD_LAST_VALUE,
    TOKEN_KEYWORD_LATERAL,
    TOKEN_KEYWORD_LCASE,
        TOKEN_KEYWORD_LD_RUN_PATH,
    TOKEN_KEYWORD_LEAD,
    TOKEN_KEYWORD_LEADING,
    TOKEN_KEYWORD_LEAST,
    TOKEN_KEYWORD_LEAVE,
    TOKEN_KEYWORD_LEFT,
    TOKEN_KEYWORD_LENGTH,
    TOKEN_KEYWORD_LEVEL,
    TOKEN_KEYWORD_LIBRARY,
    TOKEN_KEYWORD_LIKE,
    TOKEN_KEYWORD_LIMIT,
    TOKEN_KEYWORD_LINE,
    TOKEN_KEYWORD_LINEAR,
    TOKEN_KEYWORD_LINEFROMTEXT,
    TOKEN_KEYWORD_LINEFROMWKB,
    TOKEN_KEYWORD_LINES,
    TOKEN_KEYWORD_LINESTRING,
    TOKEN_KEYWORD_LINESTRINGFROMTEXT,
    TOKEN_KEYWORD_LINESTRINGFROMWKB,
        TOKEN_KEYWORD_LINE_NUMBERS,
    TOKEN_KEYWORD_LITERAL,
    TOKEN_KEYWORD_LN,
    TOKEN_KEYWORD_LOAD,
    TOKEN_KEYWORD_LOAD_FILE,
    TOKEN_KEYWORD_LOCAL,
    TOKEN_KEYWORD_LOCALTIME,
    TOKEN_KEYWORD_LOCALTIMESTAMP,
        TOKEN_KEYWORD_LOCAL_INFILE,
    TOKEN_KEYWORD_LOCATE,
    TOKEN_KEYWORD_LOCK,
    TOKEN_KEYWORD_LOG,
    TOKEN_KEYWORD_LOG10,
    TOKEN_KEYWORD_LOG2,
    TOKEN_KEYWORD_LOGFILE,
        TOKEN_KEYWORD_LOGIN_PATH,
    TOKEN_KEYWORD_LONG,
    TOKEN_KEYWORD_LONGBLOB,
    TOKEN_KEYWORD_LONGTEXT,
    TOKEN_KEYWORD_LOOP,
    TOKEN_KEYWORD_LOWER,
    TOKEN_KEYWORD_LOW_PRIORITY,
    TOKEN_KEYWORD_LPAD,
    TOKEN_KEYWORD_LTRIM,
    TOKEN_KEYWORD_LUA,
    TOKEN_KEYWORD_MAKEDATE,
    TOKEN_KEYWORD_MAKETIME,
    TOKEN_KEYWORD_MAKE_SET,
    TOKEN_KEYWORD_MANUAL,
    TOKEN_KEYWORD_MAP,
    TOKEN_KEYWORD_MARGIN, /* export */
    TOKEN_KEYWORD_MASTER_BIND,
    TOKEN_KEYWORD_MASTER_HEARTBEAT_PERIOD,
    TOKEN_KEYWORD_MASTER_POS_WAIT,
    TOKEN_KEYWORD_MASTER_SSL_VERIFY_SERVER_CERT,
    TOKEN_KEYWORD_MATCH,
    TOKEN_KEYWORD_MAX,
    TOKEN_KEYWORD_MAXVALUE,
        TOKEN_KEYWORD_MAX_ALLOWED_PACKET,
        TOKEN_KEYWORD_MAX_JOIN_SIZE,
    TOKEN_KEYWORD_MAX_ROW_COUNT, /* export */
    TOKEN_KEYWORD_MBRCONTAINS,
    TOKEN_KEYWORD_MBRCOVEREDBY,
    TOKEN_KEYWORD_MBRCOVERS,
    TOKEN_KEYWORD_MBRDISJOINT,
    TOKEN_KEYWORD_MBREQUAL,
    TOKEN_KEYWORD_MBREQUALS,
    TOKEN_KEYWORD_MBRINTERSECTS,
    TOKEN_KEYWORD_MBROVERLAPS,
    TOKEN_KEYWORD_MBRTOUCHES,
    TOKEN_KEYWORD_MBRWITHIN,
    TOKEN_KEYWORD_MD5,
    TOKEN_KEYWORD_MEDIAN,
    TOKEN_KEYWORD_MEDIUMBLOB,
    TOKEN_KEYWORD_MEDIUMINT,
    TOKEN_KEYWORD_MEDIUMTEXT,
    TOKEN_KEYWORD_MEMBER,
    TOKEN_KEYWORD_MICROSECOND,
    TOKEN_KEYWORD_MID,
    TOKEN_KEYWORD_MIDDLEINT,
    TOKEN_KEYWORD_MIN,
    TOKEN_KEYWORD_MINUS,
    TOKEN_KEYWORD_MINUTE,
    TOKEN_KEYWORD_MINUTE_MICROSECOND,
    TOKEN_KEYWORD_MINUTE_SECOND,
    TOKEN_KEYWORD_MINVALUE,
    TOKEN_KEYWORD_MLINEFROMTEXT,
    TOKEN_KEYWORD_MLINEFROMWKB,
    TOKEN_KEYWORD_MOD,
    TOKEN_KEYWORD_MODE,
    TOKEN_KEYWORD_MODIFIES,
    TOKEN_KEYWORD_MONTH,
    TOKEN_KEYWORD_MONTHNAME,
    TOKEN_KEYWORD_MPOINTFROMTEXT,
    TOKEN_KEYWORD_MPOINTFROMWKB,
    TOKEN_KEYWORD_MPOLYFROMTEXT,
    TOKEN_KEYWORD_MPOLYFROMWKB,
    TOKEN_KEYWORD_MULTILINESTRING,
    TOKEN_KEYWORD_MULTILINESTRINGFROMTEXT,
    TOKEN_KEYWORD_MULTILINESTRINGFROMWKB,
    TOKEN_KEYWORD_MULTIPOINT,
    TOKEN_KEYWORD_MULTIPOINTFROMTEXT,
    TOKEN_KEYWORD_MULTIPOINTFROMWKB,
    TOKEN_KEYWORD_MULTIPOLYGON,
    TOKEN_KEYWORD_MULTIPOLYGONFROMTEXT,
    TOKEN_KEYWORD_MULTIPOLYGONFROMWKB,
        TOKEN_KEYWORD_NAMED_COMMANDS,
    TOKEN_KEYWORD_NAMES,
    TOKEN_KEYWORD_NAME_CONST,
    TOKEN_KEYWORD_NATURAL,
    TOKEN_KEYWORD_NATURAL_SORT_KEY,
    TOKEN_KEYWORD_NCHAR,
        TOKEN_KEYWORD_NET_BUFFER_LENGTH,
    TOKEN_KEYWORD_NEWLINE,
    TOKEN_KEYWORD_NEXT,
    TOKEN_KEYWORD_NEXTVAL,
    TOKEN_KEYWORD_NIL,
    TOKEN_KEYWORD_NO,
    TOKEN_KEYWORD_NONE,
    TOKEN_KEYWORD_NOPAGER,
    TOKEN_KEYWORD_NOT,
    TOKEN_KEYWORD_NOTEE,
    TOKEN_KEYWORD_NOTNULL,
    TOKEN_KEYWORD_NOW,
    TOKEN_KEYWORD_NOWARNING,
        TOKEN_KEYWORD_NO_AUTO_REHASH,
        TOKEN_KEYWORD_NO_BEEP,
    TOKEN_KEYWORD_NO_DEFAULTS,
    TOKEN_KEYWORD_NO_NAMED_COMMANDS,
    TOKEN_KEYWORD_NO_TEE,
    TOKEN_KEYWORD_NO_WRITE_TO_BINLOG,
    TOKEN_KEYWORD_NTH_VALUE,
    TOKEN_KEYWORD_NTILE,
    TOKEN_KEYWORD_NULL,
    TOKEN_KEYWORD_NULLIF,
    TOKEN_KEYWORD_NULLS,
    TOKEN_KEYWORD_NUM,
    TOKEN_KEYWORD_NUMBER,
    TOKEN_KEYWORD_NUMERIC,
    TOKEN_KEYWORD_NUMGEOMETRIES,
    TOKEN_KEYWORD_NUMINTERIORRINGS,
    TOKEN_KEYWORD_NUMPOINTS,
    TOKEN_KEYWORD_NVARCHAR2,
    TOKEN_KEYWORD_OCELOT_BATCH,
    TOKEN_KEYWORD_OCELOT_CLIENT_SIDE_FUNCTIONS,
    TOKEN_KEYWORD_OCELOT_COMPLETER_TIMEOUT,
        TOKEN_KEYWORD_OCELOT_DBMS,
    TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED,
    TOKEN_KEYWORD_OCELOT_DEBUG_HEIGHT,
    TOKEN_KEYWORD_OCELOT_DEBUG_LEFT,
    TOKEN_KEYWORD_OCELOT_DEBUG_TOP,
    TOKEN_KEYWORD_OCELOT_DEBUG_WIDTH,

    TOKEN_KEYWORD_OCELOT_EXPLORER_ACTION,
    TOKEN_KEYWORD_OCELOT_EXPLORER_APPLICABLE_DBMSS,
    TOKEN_KEYWORD_OCELOT_EXPLORER_APPLICABLE_TYPES,
    TOKEN_KEYWORD_OCELOT_EXPLORER_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED,
    TOKEN_KEYWORD_OCELOT_EXPLORER_ENABLED,
    TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_FAMILY,
    TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_SIZE,
    TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_STYLE,
    TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_WEIGHT,
    TOKEN_KEYWORD_OCELOT_EXPLORER_HEIGHT,
    TOKEN_KEYWORD_OCELOT_EXPLORER_LEFT,
    TOKEN_KEYWORD_OCELOT_EXPLORER_SHORTCUT,
    TOKEN_KEYWORD_OCELOT_EXPLORER_TEXT,
    TOKEN_KEYWORD_OCELOT_EXPLORER_TEXT_COLOR,
    TOKEN_KEYWORD_OCELOT_EXPLORER_TOP,
    TOKEN_KEYWORD_OCELOT_EXPLORER_VISIBLE,
    TOKEN_KEYWORD_OCELOT_EXPLORER_WIDTH,
    TOKEN_KEYWORD_OCELOT_EXPORT,
    TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_CONDITION,
    TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_DISPLAY_AS,
    TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_TEXT_COLOR,
    TOKEN_KEYWORD_OCELOT_GRID_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_COLOR,
    TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_SIZE,
    TOKEN_KEYWORD_OCELOT_GRID_CELL_HEIGHT,
    TOKEN_KEYWORD_OCELOT_GRID_CELL_WIDTH,
    TOKEN_KEYWORD_OCELOT_GRID_CHART,
    TOKEN_KEYWORD_OCELOT_GRID_DETACHED,
    TOKEN_KEYWORD_OCELOT_GRID_FOCUS_CELL_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_GRID_FONT_FAMILY,
    TOKEN_KEYWORD_OCELOT_GRID_FONT_SIZE,
    TOKEN_KEYWORD_OCELOT_GRID_FONT_STYLE,
    TOKEN_KEYWORD_OCELOT_GRID_FONT_WEIGHT,
    TOKEN_KEYWORD_OCELOT_GRID_HEADER_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_GRID_HEIGHT,
    TOKEN_KEYWORD_OCELOT_GRID_HTML_EFFECTS,
    TOKEN_KEYWORD_OCELOT_GRID_LEFT,
    TOKEN_KEYWORD_OCELOT_GRID_OUTER_COLOR,
    TOKEN_KEYWORD_OCELOT_GRID_TABS,
    TOKEN_KEYWORD_OCELOT_GRID_TEXT_COLOR,
    TOKEN_KEYWORD_OCELOT_GRID_TOOLTIP,
    TOKEN_KEYWORD_OCELOT_GRID_TOP,
    TOKEN_KEYWORD_OCELOT_GRID_WIDTH,
    TOKEN_KEYWORD_OCELOT_HISTFILEFLAGS,
    TOKEN_KEYWORD_OCELOT_HISTFILESIZE,
    TOKEN_KEYWORD_OCELOT_HISTORY_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_HISTORY_BORDER_COLOR,
    TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED,
    TOKEN_KEYWORD_OCELOT_HISTORY_FONT_FAMILY,
    TOKEN_KEYWORD_OCELOT_HISTORY_FONT_SIZE,
    TOKEN_KEYWORD_OCELOT_HISTORY_FONT_STYLE,
    TOKEN_KEYWORD_OCELOT_HISTORY_FONT_WEIGHT,
    TOKEN_KEYWORD_OCELOT_HISTORY_HEIGHT,
    TOKEN_KEYWORD_OCELOT_HISTORY_LEFT,
    TOKEN_KEYWORD_OCELOT_HISTORY_MAX_ROW_COUNT,
    TOKEN_KEYWORD_OCELOT_HISTORY_TEXT_COLOR,
    TOKEN_KEYWORD_OCELOT_HISTORY_TOP,
    TOKEN_KEYWORD_OCELOT_HISTORY_WIDTH,
    TOKEN_KEYWORD_OCELOT_HISTSIZE,
    TOKEN_KEYWORD_OCELOT_HORIZONTAL,
    TOKEN_KEYWORD_OCELOT_HTML,
    TOKEN_KEYWORD_OCELOT_HTMLRAW,
    TOKEN_KEYWORD_OCELOT_IMPORT, /* if OCELOT_IMPORT_EXPORT == 1 */ /* unused */
    TOKEN_KEYWORD_OCELOT_LANGUAGE,
    TOKEN_KEYWORD_OCELOT_LOG_LEVEL,
    TOKEN_KEYWORD_OCELOT_MAX_CONDITIONS,
    TOKEN_KEYWORD_OCELOT_MENU_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_MENU_BORDER_COLOR,
    TOKEN_KEYWORD_OCELOT_MENU_FONT_FAMILY,
    TOKEN_KEYWORD_OCELOT_MENU_FONT_SIZE,
    TOKEN_KEYWORD_OCELOT_MENU_FONT_STYLE,
    TOKEN_KEYWORD_OCELOT_MENU_FONT_WEIGHT,
    TOKEN_KEYWORD_OCELOT_MENU_TEXT_COLOR,
    TOKEN_KEYWORD_OCELOT_QUERY,
    TOKEN_KEYWORD_OCELOT_RAW,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_AUTOCOMPLETE, /* KEYWORD_OCELOT_SHORTCUT_* items are obsolete, remove in next version */
    TOKEN_KEYWORD_OCELOT_SHORTCUT_BATCH,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_BREAKPOINT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_BAR,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_LINE,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_NONE,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_PIE,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_CLEAR,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_CONNECT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_CONTINUE,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_COPY,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_CUT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_DEBUG_EXIT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_EXECUTE,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_EXIT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_FIND,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_FORMAT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_NEXT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_PREVIOUS,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_HORIZONTAL,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_HTML,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_HTMLRAW,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_INFORMATION,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_KILL,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT_WINDOW,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_PASTE,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_PREVIOUS_WINDOW,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_RAW,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_REDO,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_CALL_STACK,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_SERVER_VARIABLES,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_USER_VARIABLES,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_VARIABLES,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_SELECT_ALL,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_STEP,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_UNDO,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_VERTICAL,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_XML,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMIN,
    TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMOUT,
    TOKEN_KEYWORD_OCELOT_STATEMENT_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_BORDER_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED,
    TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_FAMILY,
    TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_SIZE,
    TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_STYLE,
    TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_WEIGHT,
    TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_CLAUSE_INDENT,
    TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_RULE,
    TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_STATEMENT_INDENT,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HEIGHT,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_COMMENT_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_FUNCTION_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_IDENTIFIER_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_KEYWORD_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_LITERAL_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_OPERATOR_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_LEFT,
    TOKEN_KEYWORD_OCELOT_STATEMENT_PROMPT_BACKGROUND_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_SYNTAX_CHECKER,
    TOKEN_KEYWORD_OCELOT_STATEMENT_TEXT_COLOR,
    TOKEN_KEYWORD_OCELOT_STATEMENT_TOP,
    TOKEN_KEYWORD_OCELOT_STATEMENT_WIDTH,
    TOKEN_KEYWORD_OCELOT_VERTICAL,
    TOKEN_KEYWORD_OCELOT_XML,
    TOKEN_KEYWORD_OCT,
    TOKEN_KEYWORD_OCTET_LENGTH,
    TOKEN_KEYWORD_OF,
    TOKEN_KEYWORD_OFF,
    TOKEN_KEYWORD_OFFSET,
    TOKEN_KEYWORD_OJ,
    TOKEN_KEYWORD_OLD_PASSWORD,
    TOKEN_KEYWORD_ON,
        TOKEN_KEYWORD_ONE_DATABASE,
    TOKEN_KEYWORD_ONLY,
    TOKEN_KEYWORD_OPEN,
    TOKEN_KEYWORD_OPERATOR,
    TOKEN_KEYWORD_OPTIMIZE,
    TOKEN_KEYWORD_OPTIMIZER_COSTS,
    TOKEN_KEYWORD_OPTION,
    TOKEN_KEYWORD_OPTIONALLY,
    TOKEN_KEYWORD_OR,
    TOKEN_KEYWORD_ORD,
    TOKEN_KEYWORD_ORDER,
    TOKEN_KEYWORD_OUT,
    TOKEN_KEYWORD_OUTER,
    TOKEN_KEYWORD_OUTFILE,
    TOKEN_KEYWORD_OVER,
    TOKEN_KEYWORD_OVERLAPS,
    TOKEN_KEYWORD_PACKAGE,
    TOKEN_KEYWORD_PAD, /* export */
    TOKEN_KEYWORD_PAGER,
    TOKEN_KEYWORD_PARALLEL,
    TOKEN_KEYWORD_PARSER_TRACE,
    TOKEN_KEYWORD_PARTIAL,
    TOKEN_KEYWORD_PARTITION,
    TOKEN_KEYWORD_PASSWORD,
    TOKEN_KEYWORD_PERCENTILE_CONT,
    TOKEN_KEYWORD_PERCENTILE_DISC,
    TOKEN_KEYWORD_PERCENT_RANK,
    TOKEN_KEYWORD_PERIOD,
    TOKEN_KEYWORD_PERIOD_ADD,
    TOKEN_KEYWORD_PERIOD_DIFF,
    TOKEN_KEYWORD_PERSIST,
    TOKEN_KEYWORD_PERSIST_ONLY,
    TOKEN_KEYWORD_PERSIST_RO_VARIABLES_ADMIN,
    TOKEN_KEYWORD_PI,
    TOKEN_KEYWORD_PIE,
    TOKEN_KEYWORD_PIPE,
    TOKEN_KEYWORD_PLAN,
    TOKEN_KEYWORD_PLUGINS,
        TOKEN_KEYWORD_PLUGIN_DIR,
    TOKEN_KEYWORD_POINT,
    TOKEN_KEYWORD_POINTFROMTEXT,
    TOKEN_KEYWORD_POINTFROMWKB,
    TOKEN_KEYWORD_POINTN,
    TOKEN_KEYWORD_POLYFROMTEXT,
    TOKEN_KEYWORD_POLYFROMWKB,
    TOKEN_KEYWORD_POLYGON,
    TOKEN_KEYWORD_POLYGONFROMTEXT,
    TOKEN_KEYWORD_POLYGONFROMWKB,
        TOKEN_KEYWORD_PORT,
    TOKEN_KEYWORD_POSITION,
    TOKEN_KEYWORD_POW,
    TOKEN_KEYWORD_POWER,
    TOKEN_KEYWORD_PRAGMA,
    TOKEN_KEYWORD_PRECEDES,
    TOKEN_KEYWORD_PRECISION,
    TOKEN_KEYWORD_PREPARE,
    TOKEN_KEYWORD_PRETTY, /* unused */
    TOKEN_KEYWORD_PRIMARY,
    TOKEN_KEYWORD_PRINT,
    TOKEN_KEYWORD_PRINTF,
        TOKEN_KEYWORD_PRINT_DEFAULTS,
    TOKEN_KEYWORD_PROCEDURE,
    TOKEN_KEYWORD_PROCESS,
    TOKEN_KEYWORD_PROMPT,
        TOKEN_KEYWORD_PROTOCOL,
    TOKEN_KEYWORD_PROXY,
    TOKEN_KEYWORD_PURGE,
    TOKEN_KEYWORD_QUALIFY,
    TOKEN_KEYWORD_QUARTER,
    TOKEN_KEYWORD_QUERY,
        TOKEN_KEYWORD_QUICK,
    TOKEN_KEYWORD_QUIT,
    TOKEN_KEYWORD_QUOTE,
    TOKEN_KEYWORD_RADIANS,
    TOKEN_KEYWORD_RAISE,
    TOKEN_KEYWORD_RAND,
    TOKEN_KEYWORD_RANDOM,
    TOKEN_KEYWORD_RANDOMBLOB,
    TOKEN_KEYWORD_RANDOM_BYTES,
    TOKEN_KEYWORD_RANGE,
    TOKEN_KEYWORD_RANK,
    TOKEN_KEYWORD_RAW,
    TOKEN_KEYWORD_READ,
    TOKEN_KEYWORD_READS,
    TOKEN_KEYWORD_READ_DEFAULT_FILE,
    TOKEN_KEYWORD_READ_DEFAULT_GROUP,
    TOKEN_KEYWORD_READ_ONLY,
    TOKEN_KEYWORD_READ_TIMEOUT,
    TOKEN_KEYWORD_READ_WRITE,
    TOKEN_KEYWORD_REAL,
    TOKEN_KEYWORD_REBUILD,
        TOKEN_KEYWORD_RECONNECT,
    TOKEN_KEYWORD_RECURSIVE,
    TOKEN_KEYWORD_REDOFILE,
    TOKEN_KEYWORD_REDUNDANT,
    TOKEN_KEYWORD_REFERENCES,
    TOKEN_KEYWORD_REFRESH,
    TOKEN_KEYWORD_REGEXP,
    TOKEN_KEYWORD_REGEXP_INSTR,
    TOKEN_KEYWORD_REGEXP_REPLACE,
    TOKEN_KEYWORD_REGEXP_SUBSTR,
    TOKEN_KEYWORD_REHASH,
    TOKEN_KEYWORD_RELEASE,
    TOKEN_KEYWORD_RELEASE_ALL_LOCKS,
    TOKEN_KEYWORD_RELEASE_LOCK,
    TOKEN_KEYWORD_RELOAD,
    TOKEN_KEYWORD_RENAME,
    TOKEN_KEYWORD_REORGANIZE,
    TOKEN_KEYWORD_REPAIR,
    TOKEN_KEYWORD_REPEAT,
    TOKEN_KEYWORD_REPLACE,
    TOKEN_KEYWORD_REPLICA,
    TOKEN_KEYWORD_REPLICAS,
    TOKEN_KEYWORD_REPLICATION,
    TOKEN_KEYWORD_REPLICATION_SLAVE_ADMIN,
        TOKEN_KEYWORD_REPORT_DATA_TRUNCATION,
    TOKEN_KEYWORD_REQUIRE,
    TOKEN_KEYWORD_RESET,
    TOKEN_KEYWORD_RESETCONNECTION,
    TOKEN_KEYWORD_RESIGNAL,
    TOKEN_KEYWORD_RESOURCE_GROUP_ADMIN,
    TOKEN_KEYWORD_RESOURCE_GROUP_USER,
    TOKEN_KEYWORD_RESTRICT,
    TOKEN_KEYWORD_RETURN,
    TOKEN_KEYWORD_RETURNS,
    TOKEN_KEYWORD_REVERSE,
    TOKEN_KEYWORD_REVOKE,
    TOKEN_KEYWORD_RIGHT,
    TOKEN_KEYWORD_RLIKE,
    TOKEN_KEYWORD_ROLE,
    TOKEN_KEYWORD_ROLE_ADMIN,
    TOKEN_KEYWORD_ROLLBACK,
    TOKEN_KEYWORD_ROUND,
    TOKEN_KEYWORD_ROW,
    TOKEN_KEYWORD_ROWNUM,
    TOKEN_KEYWORD_ROWS,
    TOKEN_KEYWORD_ROWTYPE,
    TOKEN_KEYWORD_ROW_COUNT,
    TOKEN_KEYWORD_ROW_NUMBER,
    TOKEN_KEYWORD_RPAD,
    TOKEN_KEYWORD_RTRIM,
        TOKEN_KEYWORD_SAFE_UPDATES,
    TOKEN_KEYWORD_SAVEPOINT,
    TOKEN_KEYWORD_SCALAR,
    TOKEN_KEYWORD_SCHEMA,
    TOKEN_KEYWORD_SCHEMAS,
    TOKEN_KEYWORD_SECOND,
    TOKEN_KEYWORD_SECOND_MICROSECOND,
        TOKEN_KEYWORD_SECURE_AUTH,
    TOKEN_KEYWORD_SECURITY,
    TOKEN_KEYWORD_SEC_TO_TIME,
    TOKEN_KEYWORD_SELECT,
        TOKEN_KEYWORD_SELECT_LIMIT,
    TOKEN_KEYWORD_SEMICOLON,
    TOKEN_KEYWORD_SENSITIVE,
    TOKEN_KEYWORD_SEPARATOR,
    TOKEN_KEYWORD_SEQSCAN,
    TOKEN_KEYWORD_SEQUENCE,
    TOKEN_KEYWORD_SERIAL,
    TOKEN_KEYWORD_SERVER,
        TOKEN_KEYWORD_SERVER_PUBLIC_KEY,
    TOKEN_KEYWORD_SESSION,
    TOKEN_KEYWORD_SESSION_USER,
    TOKEN_KEYWORD_SET,
    TOKEN_KEYWORD_SETVAL,
    TOKEN_KEYWORD_SET_USER_ID,
    TOKEN_KEYWORD_SFORMAT,
    TOKEN_KEYWORD_SHA,
    TOKEN_KEYWORD_SHA1,
    TOKEN_KEYWORD_SHA2,
    TOKEN_KEYWORD_SHARED,
        TOKEN_KEYWORD_SHARED_MEMORY_BASE_NAME,
    TOKEN_KEYWORD_SHOW,
        TOKEN_KEYWORD_SHOW_WARNINGS,
    TOKEN_KEYWORD_SHUTDOWN,
        TOKEN_KEYWORD_SIGINT_IGNORE,
    TOKEN_KEYWORD_SIGN,
    TOKEN_KEYWORD_SIGNAL,
    TOKEN_KEYWORD_SIGNED,
        TOKEN_KEYWORD_SILENT,
    TOKEN_KEYWORD_SIMPLE,
    TOKEN_KEYWORD_SIN,
    TOKEN_KEYWORD_SLAVE,
    TOKEN_KEYWORD_SLEEP,
    TOKEN_KEYWORD_SLOW,
    TOKEN_KEYWORD_SMALLINT,
        TOKEN_KEYWORD_SOCKET,
    TOKEN_KEYWORD_SONAME,
    TOKEN_KEYWORD_SOUNDEX,
    TOKEN_KEYWORD_SOURCE,
    TOKEN_KEYWORD_SPACE,
    TOKEN_KEYWORD_SPATIAL,
    TOKEN_KEYWORD_SPECIFIC,
    TOKEN_KEYWORD_SQL,
    TOKEN_KEYWORD_SQLEXCEPTION,
    TOKEN_KEYWORD_SQLSTATE,
    TOKEN_KEYWORD_SQLWARNING,
    TOKEN_KEYWORD_SQL_BIG_RESULT,
    TOKEN_KEYWORD_SQL_CALC_FOUND_ROWS,
    TOKEN_KEYWORD_SQL_COMPOUND_SELECT_LIMIT,
    TOKEN_KEYWORD_SQL_DEFAULT_ENGINE,
    TOKEN_KEYWORD_SQL_SMALL_RESULT,
    TOKEN_KEYWORD_SQRT,
    TOKEN_KEYWORD_SRID,
    TOKEN_KEYWORD_SSL,
    TOKEN_KEYWORD_SSL_CA,
    TOKEN_KEYWORD_SSL_CAPATH,
    TOKEN_KEYWORD_SSL_CERT,
    TOKEN_KEYWORD_SSL_CIPHER,
    TOKEN_KEYWORD_SSL_CRL,
    TOKEN_KEYWORD_SSL_CRLPATH,
    TOKEN_KEYWORD_SSL_KEY,
    TOKEN_KEYWORD_SSL_MODE,
    TOKEN_KEYWORD_SSL_VERIFY,
    TOKEN_KEYWORD_SSL_VERIFY_SERVER_CERT,
    TOKEN_KEYWORD_START,
    TOKEN_KEYWORD_STARTING,
    TOKEN_KEYWORD_STARTPOINT,
    TOKEN_KEYWORD_STATEMENT,
    TOKEN_KEYWORD_STATS,
    TOKEN_KEYWORD_STATUS,
    TOKEN_KEYWORD_STD,
    TOKEN_KEYWORD_STDDEV,
    TOKEN_KEYWORD_STDDEV_POP,
    TOKEN_KEYWORD_STDDEV_SAMP,
    TOKEN_KEYWORD_STDOUT,
    TOKEN_KEYWORD_STOP,
    TOKEN_KEYWORD_STORED,
    TOKEN_KEYWORD_STRAIGHT_JOIN,
    TOKEN_KEYWORD_STRCMP,
    TOKEN_KEYWORD_STRFTIME,
    TOKEN_KEYWORD_STRING,
    TOKEN_KEYWORD_STRING_TO_VECTOR,
    TOKEN_KEYWORD_STR_TO_DATE,
    TOKEN_KEYWORD_ST_AREA,
    TOKEN_KEYWORD_ST_ASBINARY,
    TOKEN_KEYWORD_ST_ASGEOJSON,
    TOKEN_KEYWORD_ST_ASTEXT,
    TOKEN_KEYWORD_ST_ASWKB,
    TOKEN_KEYWORD_ST_ASWKT,
    TOKEN_KEYWORD_ST_BOUNDARY,
    TOKEN_KEYWORD_ST_BUFFER,
    TOKEN_KEYWORD_ST_BUFFER_STRATEGY,
    TOKEN_KEYWORD_ST_CENTROID,
    TOKEN_KEYWORD_ST_CONTAINS,
    TOKEN_KEYWORD_ST_CONVEXHULL,
    TOKEN_KEYWORD_ST_CROSSES,
    TOKEN_KEYWORD_ST_DIFFERENCE,
    TOKEN_KEYWORD_ST_DIMENSION,
    TOKEN_KEYWORD_ST_DISJOINT,
    TOKEN_KEYWORD_ST_DISTANCE,
    TOKEN_KEYWORD_ST_DISTANCE_SPHERE,
    TOKEN_KEYWORD_ST_ENDPOINT,
    TOKEN_KEYWORD_ST_ENVELOPE,
    TOKEN_KEYWORD_ST_EQUALS,
    TOKEN_KEYWORD_ST_EXTERIORRING,
    TOKEN_KEYWORD_ST_GEOHASH,
    TOKEN_KEYWORD_ST_GEOMCOLLFROMTEXT,
    TOKEN_KEYWORD_ST_GEOMCOLLFROMTXT,
    TOKEN_KEYWORD_ST_GEOMCOLLFROMWKB,
    TOKEN_KEYWORD_ST_GEOMETRYCOLLECTIONFROMTEXT,
    TOKEN_KEYWORD_ST_GEOMETRYCOLLECTIONFROMWKB,
    TOKEN_KEYWORD_ST_GEOMETRYFROMTEXT,
    TOKEN_KEYWORD_ST_GEOMETRYFROMWKB,
    TOKEN_KEYWORD_ST_GEOMETRYN,
    TOKEN_KEYWORD_ST_GEOMETRYTYPE,
    TOKEN_KEYWORD_ST_GEOMFROMGEOJSON,
    TOKEN_KEYWORD_ST_GEOMFROMTEXT,
    TOKEN_KEYWORD_ST_GEOMFROMWKB,
    TOKEN_KEYWORD_ST_INTERIORRINGN,
    TOKEN_KEYWORD_ST_INTERSECTION,
    TOKEN_KEYWORD_ST_INTERSECTS,
    TOKEN_KEYWORD_ST_ISCLOSED,
    TOKEN_KEYWORD_ST_ISEMPTY,
    TOKEN_KEYWORD_ST_ISRING,
    TOKEN_KEYWORD_ST_ISSIMPLE,
    TOKEN_KEYWORD_ST_ISVALID,
    TOKEN_KEYWORD_ST_LATFROMGEOHASH,
    TOKEN_KEYWORD_ST_LENGTH,
    TOKEN_KEYWORD_ST_LINEFROMTEXT,
    TOKEN_KEYWORD_ST_LINEFROMWKB,
    TOKEN_KEYWORD_ST_LINESTRINGFROMTEXT,
    TOKEN_KEYWORD_ST_LINESTRINGFROMWKB,
    TOKEN_KEYWORD_ST_LONGFROMGEOHASH,
    TOKEN_KEYWORD_ST_MAKEENVELOPE,
    TOKEN_KEYWORD_ST_MLINEFROMTEXT,
    TOKEN_KEYWORD_ST_MLINEFROMWKB,
    TOKEN_KEYWORD_ST_MPOINTFROMTEXT,
    TOKEN_KEYWORD_ST_MPOINTFROMWKB,
    TOKEN_KEYWORD_ST_MPOLYFROMTEXT,
    TOKEN_KEYWORD_ST_MPOLYFROMWKB,
    TOKEN_KEYWORD_ST_MULTILINESTRINGFROMTEXT,
    TOKEN_KEYWORD_ST_MULTILINESTRINGFROMWKB,
    TOKEN_KEYWORD_ST_MULTIPOINTFROMTEXT,
    TOKEN_KEYWORD_ST_MULTIPOINTFROMWKB,
    TOKEN_KEYWORD_ST_MULTIPOLYGONFROMTEXT,
    TOKEN_KEYWORD_ST_MULTIPOLYGONFROMWKB,
    TOKEN_KEYWORD_ST_NUMGEOMETRIES,
    TOKEN_KEYWORD_ST_NUMINTERIORRING,
    TOKEN_KEYWORD_ST_NUMINTERIORRINGS,
    TOKEN_KEYWORD_ST_NUMPOINTS,
    TOKEN_KEYWORD_ST_OVERLAPS,
    TOKEN_KEYWORD_ST_POINTFROMGEOHASH,
    TOKEN_KEYWORD_ST_POINTFROMTEXT,
    TOKEN_KEYWORD_ST_POINTFROMWKB,
    TOKEN_KEYWORD_ST_POINTN,
    TOKEN_KEYWORD_ST_POINTONSURFACE,
    TOKEN_KEYWORD_ST_POLYFROMTEXT,
    TOKEN_KEYWORD_ST_POLYFROMWKB,
    TOKEN_KEYWORD_ST_POLYGONFROMTEXT,
    TOKEN_KEYWORD_ST_POLYGONFROMWKB,
    TOKEN_KEYWORD_ST_RELATE,
    TOKEN_KEYWORD_ST_SIMPLIFY,
    TOKEN_KEYWORD_ST_SRID,
    TOKEN_KEYWORD_ST_STARTPOINT,
    TOKEN_KEYWORD_ST_SYMDIFFERENCE,
    TOKEN_KEYWORD_ST_TOUCHES,
    TOKEN_KEYWORD_ST_UNION,
    TOKEN_KEYWORD_ST_VALIDATE,
    TOKEN_KEYWORD_ST_WITHIN,
    TOKEN_KEYWORD_ST_X,
    TOKEN_KEYWORD_ST_Y,
    TOKEN_KEYWORD_SUBDATE,
    TOKEN_KEYWORD_SUBSTR,
    TOKEN_KEYWORD_SUBSTRING,
    TOKEN_KEYWORD_SUBSTRING_INDEX,
    TOKEN_KEYWORD_SUBTIME,
    TOKEN_KEYWORD_SUM,
    TOKEN_KEYWORD_SUPER,
    TOKEN_KEYWORD_SYSDATE,
        TOKEN_KEYWORD_SYSLOG,
    TOKEN_KEYWORD_SYSTEM,
    TOKEN_KEYWORD_SYSTEM_TIME,
    TOKEN_KEYWORD_SYSTEM_USER,
    TOKEN_KEYWORD_SYSTEM_VARIABLES_ADMIN,
    TOKEN_KEYWORD_SYS_GUID,
    TOKEN_KEYWORD_TAB,
    TOKEN_KEYWORD_TABLE,
    TOKEN_KEYWORD_TABLES,
    TOKEN_KEYWORD_TABLESAMPLE,
    TOKEN_KEYWORD_TABLESPACE,
    TOKEN_KEYWORD_TABLE_INFO,
    TOKEN_KEYWORD_TAN,
    TOKEN_KEYWORD_TEE,
    TOKEN_KEYWORD_TEMP,
    TOKEN_KEYWORD_TEMPORARY,
    TOKEN_KEYWORD_TERMINATED,
    TOKEN_KEYWORD_TEXT,
    TOKEN_KEYWORD_THEN,
    TOKEN_KEYWORD_TIES,
    TOKEN_KEYWORD_TIME,
    TOKEN_KEYWORD_TIMEDIFF,
    TOKEN_KEYWORD_TIMESTAMP,
    TOKEN_KEYWORD_TIMESTAMPADD,
    TOKEN_KEYWORD_TIMESTAMPDIFF,
    TOKEN_KEYWORD_TIME_FORMAT,
    TOKEN_KEYWORD_TIME_TO_SEC,
    TOKEN_KEYWORD_TINYBLOB,
    TOKEN_KEYWORD_TINYINT,
    TOKEN_KEYWORD_TINYTEXT,
    TOKEN_KEYWORD_TO,
    TOKEN_KEYWORD_TOUCHES,
    TOKEN_KEYWORD_TO_BASE64,
    TOKEN_KEYWORD_TO_CHAR,
    TOKEN_KEYWORD_TO_DAYS,
    TOKEN_KEYWORD_TO_SECONDS,
    TOKEN_KEYWORD_TRAILING,
    TOKEN_KEYWORD_TRANSACTION,
    TOKEN_KEYWORD_TRIGGER,
    TOKEN_KEYWORD_TRIM,
    TOKEN_KEYWORD_TRUE,
    TOKEN_KEYWORD_TRUNCATE,
    TOKEN_KEYWORD_TYPE,
    TOKEN_KEYWORD_TYPEOF,
    TOKEN_KEYWORD_UCASE,
    TOKEN_KEYWORD_UNBOUNDED,
        TOKEN_KEYWORD_UNBUFFERED,
    TOKEN_KEYWORD_UNCOMPRESS,
    TOKEN_KEYWORD_UNCOMPRESSED_LENGTH,
    TOKEN_KEYWORD_UNDO,
    TOKEN_KEYWORD_UNHEX,
    TOKEN_KEYWORD_UNICODE,
    TOKEN_KEYWORD_UNINSTALL,
    TOKEN_KEYWORD_UNION,
    TOKEN_KEYWORD_UNIQUE,
    TOKEN_KEYWORD_UNIX_TIMESTAMP,
    TOKEN_KEYWORD_UNKNOWN,
    TOKEN_KEYWORD_UNLOCK,
    TOKEN_KEYWORD_UNSIGNED,
    TOKEN_KEYWORD_UNTIL,
    TOKEN_KEYWORD_UPDATE,
    TOKEN_KEYWORD_UPDATEXML,
    TOKEN_KEYWORD_UPPER,
    TOKEN_KEYWORD_USAGE,
    TOKEN_KEYWORD_USE,
    TOKEN_KEYWORD_USER,
        TOKEN_KEYWORD_USE_RESULT,
    TOKEN_KEYWORD_USING,
    TOKEN_KEYWORD_UTC_DATE,
    TOKEN_KEYWORD_UTC_TIME,
    TOKEN_KEYWORD_UTC_TIMESTAMP,
    TOKEN_KEYWORD_UUID,
    TOKEN_KEYWORD_UUID_SHORT,
    TOKEN_KEYWORD_UUID_V4,
    TOKEN_KEYWORD_UUID_V7,
    TOKEN_KEYWORD_VACUUM,
    TOKEN_KEYWORD_VALIDATE_PASSWORD_STRENGTH,
    TOKEN_KEYWORD_VALIDATION,
    TOKEN_KEYWORD_VALUE,
    TOKEN_KEYWORD_VALUES,
    TOKEN_KEYWORD_VARBINARY,
    TOKEN_KEYWORD_VARCHAR,
    TOKEN_KEYWORD_VARCHAR2,
    TOKEN_KEYWORD_VARCHARACTER,
    TOKEN_KEYWORD_VARIANCE,
    TOKEN_KEYWORD_VARYING,
    TOKEN_KEYWORD_VAR_POP,
    TOKEN_KEYWORD_VAR_SAMP,
    TOKEN_KEYWORD_VECTOR,
    TOKEN_KEYWORD_VECTOR_DIM,
    TOKEN_KEYWORD_VECTOR_TO_STRING,
    TOKEN_KEYWORD_VEC_DISTANCE,
        TOKEN_KEYWORD_VERBOSE,
    TOKEN_KEYWORD_VERSION,
    TOKEN_KEYWORD_VERSIONING,
    TOKEN_KEYWORD_VERSION_TOKEN_ADMIN,
        TOKEN_KEYWORD_VERTICAL,
    TOKEN_KEYWORD_VIEW,
    TOKEN_KEYWORD_VIRTUAL,
        TOKEN_KEYWORD_WAIT,
    TOKEN_KEYWORD_WAIT_FOR_EXECUTED_GTID_SET,
    TOKEN_KEYWORD_WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS,
    TOKEN_KEYWORD_WARNINGS,
    TOKEN_KEYWORD_WEEK,
    TOKEN_KEYWORD_WEEKDAY,
    TOKEN_KEYWORD_WEEKOFYEAR,
    TOKEN_KEYWORD_WEIGHT_STRING,
    TOKEN_KEYWORD_WHEN,
    TOKEN_KEYWORD_WHENEVER,
    TOKEN_KEYWORD_WHERE,
    TOKEN_KEYWORD_WHILE,
    TOKEN_KEYWORD_WINDOW,
    TOKEN_KEYWORD_WITH,
    TOKEN_KEYWORD_WITHIN,
    TOKEN_KEYWORD_WITHOUT,
    TOKEN_KEYWORD_WRITE,
        TOKEN_KEYWORD_WRITE_TIMEOUT,
    TOKEN_KEYWORD_X,
    TOKEN_KEYWORD_XA,
    TOKEN_KEYWORD_XA_RECOVER_ADMIN,
        TOKEN_KEYWORD_XML,
    TOKEN_KEYWORD_XOR,
    TOKEN_KEYWORD_Y,
    TOKEN_KEYWORD_YEAR,
    TOKEN_KEYWORD_YEARWEEK,
    TOKEN_KEYWORD_YEAR_MONTH,
    TOKEN_KEYWORD_ZEROFILL,
    TOKEN_KEYWORD__ARMSCII8,
    TOKEN_KEYWORD__ASCII,
    TOKEN_KEYWORD__BIG5,
    TOKEN_KEYWORD__BINARY,
    TOKEN_KEYWORD__CP1250,
    TOKEN_KEYWORD__CP1251,
    TOKEN_KEYWORD__CP1256,
    TOKEN_KEYWORD__CP1257,
    TOKEN_KEYWORD__CP850,
    TOKEN_KEYWORD__CP852,
    TOKEN_KEYWORD__CP866,
    TOKEN_KEYWORD__CP932,
    TOKEN_KEYWORD__DEC8,
    TOKEN_KEYWORD__EUCJPMS,
    TOKEN_KEYWORD__EUCKR,
    TOKEN_KEYWORD__FILENAME,
    TOKEN_KEYWORD__GB18030,
    TOKEN_KEYWORD__GB2312,
    TOKEN_KEYWORD__GBK,
    TOKEN_KEYWORD__GEOSTD8,
    TOKEN_KEYWORD__GREEK,
    TOKEN_KEYWORD__HEBREW,
    TOKEN_KEYWORD__HP8,
    TOKEN_KEYWORD__KEYBCS2,
    TOKEN_KEYWORD__KOI8R,
    TOKEN_KEYWORD__KOI8U,
    TOKEN_KEYWORD__LATIN1,
    TOKEN_KEYWORD__LATIN2,
    TOKEN_KEYWORD__LATIN5,
    TOKEN_KEYWORD__LATIN7,
    TOKEN_KEYWORD__MACCE,
    TOKEN_KEYWORD__MACROMAN,
    TOKEN_KEYWORD__SJIS,
    TOKEN_KEYWORD__SWE7,
    TOKEN_KEYWORD__TIS620,
    TOKEN_KEYWORD__UCS2,
    TOKEN_KEYWORD__UJIS,
    TOKEN_KEYWORD__UTF16,
    TOKEN_KEYWORD__UTF16LE,
    TOKEN_KEYWORD__UTF32,
    TOKEN_KEYWORD__UTF8,
    TOKEN_KEYWORD__UTF8MB4,
#if (OCELOT_MYSQL_DEBUGGER == 1)
  TOKEN_KEYWORD_DEBUG_BREAKPOINT = TOKEN_KEYWORD__UTF8MB4 + 1,
  TOKEN_KEYWORD_DEBUG_CLEAR= TOKEN_KEYWORD_DEBUG_BREAKPOINT + 1,
  TOKEN_KEYWORD_DEBUG_CONTINUE= TOKEN_KEYWORD_DEBUG_CLEAR + 1,
  TOKEN_KEYWORD_DEBUG_DEBUG= TOKEN_KEYWORD_DEBUG_CONTINUE + 1,
  TOKEN_KEYWORD_DEBUG_DELETE= TOKEN_KEYWORD_DEBUG_DEBUG + 1,
  TOKEN_KEYWORD_DEBUG_EXECUTE= TOKEN_KEYWORD_DEBUG_DELETE + 1,
  TOKEN_KEYWORD_DEBUG_EXIT= TOKEN_KEYWORD_DEBUG_EXECUTE + 1,
  TOKEN_KEYWORD_DEBUG_INFORMATION= TOKEN_KEYWORD_DEBUG_EXIT + 1,
  TOKEN_KEYWORD_DEBUG_INSTALL= TOKEN_KEYWORD_DEBUG_INFORMATION + 1,
  TOKEN_KEYWORD_DEBUG_LEAVE= TOKEN_KEYWORD_DEBUG_INSTALL + 1,
  TOKEN_KEYWORD_DEBUG_NEXT= TOKEN_KEYWORD_DEBUG_LEAVE + 1,
  TOKEN_KEYWORD_DEBUG_REFRESH= TOKEN_KEYWORD_DEBUG_NEXT + 1,
  TOKEN_KEYWORD_DEBUG_SET= TOKEN_KEYWORD_DEBUG_REFRESH + 1,
  TOKEN_KEYWORD_DEBUG_SETUP= TOKEN_KEYWORD_DEBUG_SET + 1,
  TOKEN_KEYWORD_DEBUG_SKIP= TOKEN_KEYWORD_DEBUG_SETUP + 1,
  TOKEN_KEYWORD_DEBUG_SOURCE= TOKEN_KEYWORD_DEBUG_SKIP + 1,
  TOKEN_KEYWORD_DEBUG_STEP= TOKEN_KEYWORD_DEBUG_SOURCE + 1,
  TOKEN_KEYWORD_DEBUG_TBREAKPOINT= TOKEN_KEYWORD_DEBUG_STEP + 1,
#endif
  TOKEN_TYPE_KEYWORD,  /* generic, lots of keywords have this */
  TOKEN_KEYWORD_BEGIN_WORK,         /* some non-reserved keywords */
  TOKEN_KEYWORD_ROLLBACK_IN_ROLLBACK_TO,
  TOKEN_KEYWORD_BEGIN_XA,
  TOKEN_KEYWORD_CASE_IN_CASE_EXPRESSION,
  TOKEN_KEYWORD_END_IN_CASE_EXPRESSION,
  TOKEN_KEYWORD_IF_IN_IF_EXPRESSION,
  TOKEN_KEYWORD_IF_IN_IF_EXISTS,
  TOKEN_KEYWORD_REPEAT_IN_REPEAT_EXPRESSION,
  TOKEN_KEYWORD_HELP_IN_CLIENT,
  TOKEN_KEYWORD_DO_LUA,
  TOKEN_KEYWORD_FOR_IN_FOR_STATEMENT,
  TOKEN_KEYWORD_END_IN_CREATE_STATEMENT,
  TOKEN_TYPE_DELIMITER
};

/*
  Sorted list of keywords.
  If you change this, you must also change bsearch parameters and change TOKEN_KEYWORD list.
  We consider introducers e.g. _UTF8 to be equivalent to reserved words.
  Some keywords e.g. "OCELOT_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR" are long,
  therefore MAX_KEYWORD_LENGTH is a big number, that causes some space waste.
*/
/*
  I got tired of repeating
  if (QString::compare(text.mid(main_token_offsets[0], main_token_lengths[0]), "SELECT", Qt::CaseInsensitive) == 0) ...
  so switched to maintaining a permanent list.
  Two compiler-dependent assumptions: bsearch() exists, and char* can be converted to unsigned long.
  Alphabetic order, and upper case because bsearch() calls strcmp().
  Placeholders at the start are so that strvalues[TOKEN_KEYWORD_QUESTIONMARK] will be 14.
*/
/* TODO: you don't need to calculate index, it's strvalues[...].token_keyword. */
/* Todo: use "const" and "static" more often */

/* Do not change this #define without seeing its use in e.g. initial_asserts(). */
#define KEYWORD_LIST_SIZE 1287
#define MAX_KEYWORD_LENGTH 46
struct keywords {
   char  chars[MAX_KEYWORD_LENGTH];
   uint32_t reserved_flags; /* was unsigned int till 20250422 */
   uint32_t built_in_function_flags; /* was unsigned int till 20250422 */
   unsigned short int token_keyword;
};
static const struct keywords strvalues[]=
    {
      {"\ba", 0, 0, 0}, /* 0 placeholder */
      {"\bb", 0, 0, 0}, /* 1 placeholder */
      {"\bc", 0, 0, 0}, /* 2 placeholder */
      {"\bd", 0, 0, 0}, /* 3 placeholder */
      {"\be", 0, 0, 0}, /* 4 placeholder */
      {"\bf", 0, 0, 0}, /* 5 placeholder */
      {"\bg", 0, 0, 0}, /* 6 placeholder */
      {"\bh", 0, 0, 0}, /* 7 placeholder */
      {"\bi", 0, 0, 0}, /* 8 placeholder */
      {"\bj", 0, 0, 0}, /* 9 placeholder */
      {"\bk", 0, 0, 0}, /* 10 placeholder */
      {"\bl", 0, 0, 0}, /* 11 placeholder */
      {"\bm", 0, 0, 0}, /* 12 placeholder */
      {"\bn", 0, 0, 0}, /* 13 placeholder */
      {"?", 0, 0, TOKEN_KEYWORD_QUESTIONMARK}, /* ocelotgui keyword, although tokenize() regards it as an operator */
      {"ABORT", 0, 0, TOKEN_KEYWORD_ABORT},
        {"ABORT_SOURCE_ON_ERROR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_ABORT_SOURCE_ON_ERROR},
      {"ABS", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_ABS},
      {"ACCESSIBLE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_ACCESSIBLE},
      {"ACOS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ACOS},
      {"ACTION", 0, 0, TOKEN_KEYWORD_ACTION},
      {"ADD", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_ADD},
      {"ADDDATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ADDDATE},
      {"ADDTIME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ADDTIME},
      {"ADD_MONTHS", 0, FLAG_VERSION_PLSQL, TOKEN_KEYWORD_ADD_MONTHS},
      {"AES_DECRYPT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_AES_DECRYPT},
      {"AES_ENCRYPT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_AES_ENCRYPT},
      {"AFTER", 0, 0, TOKEN_KEYWORD_AFTER},
      {"AGAINST", 0, 0, TOKEN_KEYWORD_AGAINST},
      {"ALGORITHM", 0, 0, TOKEN_KEYWORD_ALGORITHM},
      {"ALL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ALL},
      {"ALTER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ALTER},
      {"ALWAYS", 0, 0, TOKEN_KEYWORD_ALWAYS},
      {"ANALYZE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ANALYZE},
      {"AND", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_AND},
      {"ANY", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ANY},
      {"ANY_VALUE", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_ANY_VALUE},
      {"APPEND", 0, 0, TOKEN_KEYWORD_APPEND},
      {"AREA", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_AREA}, /* deprecated in MySQL 5.7.6 */
      {"ARRAY", 0, 0, TOKEN_KEYWORD_ARRAY},
      {"AS", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_AS},
      {"ASBINARY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ASBINARY}, /* deprecated in MySQL 5.7.6 */
      {"ASC", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ASC},
      {"ASCII", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ASCII},
      {"ASENSITIVE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ASENSITIVE},
      {"ASIN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ASIN},
      {"ASTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ASTEXT}, /* deprecated in MySQL 5.7.6 */
      {"ASWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ASWKB}, /* deprecated in MySQL 5.7.6 */
      {"ASWKT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ASWKT}, /* deprecated in MySQL 5.7.6 */
      {"ASYMMETRIC_DECRYPT", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_ASYMMETRIC_DECRYPT},
      {"ASYMMETRIC_DERIVE", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_ASYMMETRIC_DERIVE},
      {"ASYMMETRIC_ENCRYPT", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_ASYMMETRIC_ENCRYPT},
      {"ASYMMETRIC_SIGN", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_ASYMMETRIC_SIGN},
      {"ASYMMETRIC_VERIFY", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_ASYMMETRIC_VERIFY},
      {"ATAN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ATAN},
      {"ATAN2", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ATAN2},
      {"ATOMIC", 0, 0, TOKEN_KEYWORD_ATOMIC},
      {"ATTACH", 0, 0, TOKEN_KEYWORD_ATTACH},
      {"ATTRIBUTE", 0, 0, TOKEN_KEYWORD_ATTRIBUTE},
      {"AUTOINCREMENT", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_AUTOINCREMENT},
        {"AUTO_REHASH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_AUTO_REHASH},
        {"AUTO_VERTICAL_OUTPUT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_AUTO_VERTICAL_OUTPUT},
      {"AVG", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_AVG},
      {"BACKGROUND", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_BACKGROUND},
          {"BACKUP_ADMIN", 0, 0, TOKEN_KEYWORD_BACKUP_ADMIN},
      {"BAR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_BAR},
        {"BATCH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_BATCH},
    {"BECOMES", 0, 0, TOKEN_KEYWORD_BECOMES},  /* for format rule */
      {"BEFORE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_BEFORE},
      {"BEGIN", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_BEGIN},
      {"BENCHMARK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BENCHMARK},
      {"BETWEEN", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_BETWEEN},
      {"BFILE", 0, 0, TOKEN_KEYWORD_BFILE},
      {"BIGINT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_BIGINT},
      {"BIN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BIN},
      {"BINARY", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_BINARY},
      {"BINARY_DOUBLE", 0, 0, TOKEN_KEYWORD_BINARY_DOUBLE},
      {"BINARY_FLOAT", 0, 0, TOKEN_KEYWORD_BINARY_FLOAT},
        {"BINARY_MODE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_BINARY_MODE},
        {"BIND", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_BIND},
        {"BIND_ADDRESS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_BIND_ADDRESS},
      {"BINLOG", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BINLOG},
          {"BINLOG_ADMIN", 0, 0, TOKEN_KEYWORD_BINLOG_ADMIN},
          {"BINLOG_GTID_POS", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BINLOG_GTID_POS},
      {"BIT", 0, 0, TOKEN_KEYWORD_BIT},
      {"BIT_AND", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BIT_AND},
      {"BIT_COUNT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BIT_COUNT},
      {"BIT_LENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BIT_LENGTH},
      {"BIT_OR", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BIT_OR},
      {"BIT_XOR", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BIT_XOR},
      {"BLOB", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_BLOB},
      {"BODY", FLAG_VERSION_PLSQL, 0, TOKEN_KEYWORD_BODY},
      {"BOOL", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_BOOL},
      {"BOOLEAN", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_BOOLEAN},
      {"BOTH", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_BOTH},
      {"BREAK", FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_BREAK},
      {"BUFFER", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_BUFFER}, /* deprecated in MySQL 5.7.6 */
      {"BUSY_TIMEOUT", 0, 0, TOKEN_KEYWORD_BUSY_TIMEOUT},
      {"BY", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_BY},
      {"CALL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CALL},
      {"CASCADE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_CASCADE},
      {"CASE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CASE},
      {"CAST", FLAG_VERSION_TARANTOOL, FLAG_VERSION_ALL, TOKEN_KEYWORD_CAST},
      {"CATALOG", FLAG_VERSION_MARIADB_12_0, FLAG_VERSION_ALL, TOKEN_KEYWORD_CATALOG},
      {"CEIL", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CEIL},
      {"CEILING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CEILING},
      {"CENTROID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CENTROID}, /* deprecated in MySQL 5.7.6 */
      {"CHANGE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_CHANGE},
      {"CHAR", FLAG_VERSION_ALL, FLAG_VERSION_ALL, TOKEN_KEYWORD_CHAR},
      {"CHARACTER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CHARACTER},
      {"CHARACTER_LENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CHARACTER_LENGTH},
        {"CHARACTER_SETS_DIR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_CHARACTER_SETS_DIR},
      {"CHARSET", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CHARSET},  /* + ocelotgui keyword */
      {"CHART", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_CHART},
      {"CHAR_LENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CHAR_LENGTH},
      {"CHECK", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CHECK},
      {"CHR", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_CHR},
      {"CLEAR", 0, 0, TOKEN_KEYWORD_CLEAR}, /* ocelotgui keyword */
      {"CLOB", 0, 0, TOKEN_KEYWORD_CLOB},
      {"CLOSE", 0, 0, TOKEN_KEYWORD_CLOSE},
      {"COALESCE", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_COALESCE},
      {"COERCIBILITY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_COERCIBILITY},
      {"COLLATE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_COLLATE},
      {"COLLATION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_COLLATION},
      {"COLLATION_LIST", 0, 0, TOKEN_KEYWORD_COLLATION_LIST},
      {"COLUMN", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_COLUMN},
      {"COLUMNS", 0, 0, TOKEN_KEYWORD_COLUMNS},
      {"COLUMN_ADD", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_ADD},
      {"COLUMN_CHECK", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_CHECK},
      {"COLUMN_CREATE", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_CREATE},
      {"COLUMN_DELETE", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_DELETE},
      {"COLUMN_EXISTS", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_EXISTS},
      {"COLUMN_GET", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_GET},
      {"COLUMN_JSON", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_JSON},
      {"COLUMN_LIST", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_COLUMN_LIST},
      {"COLUMN_NAME", 0, 0, TOKEN_KEYWORD_COLUMN_NAME},
      {"COLUMN_NAMES", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_COLUMN_NAMES},
      {"COLUMN_NUMBER", 0, 0, TOKEN_KEYWORD_COLUMN_NUMBER},
      {"COLUMN_TYPE", 0, 0, TOKEN_KEYWORD_COLUMN_TYPE},
      {"COLUMN_TYPE_INFO", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_COLUMN_TYPE_INFO},
      {"COMMA", 0, 0, TOKEN_KEYWORD_COMMA}, /* for format rule */
      {"COMMENT", 0, 0, TOKEN_KEYWORD_COMMENT},
        {"COMMENTS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_COMMENTS},
      {"COMMIT", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_COMMIT},
      {"COMPACT", 0, 0, TOKEN_KEYWORD_COMPACT},
      {"COMPRESS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_OPTION, TOKEN_KEYWORD_COMPRESS},
      {"COMPRESSED", 0, 0, TOKEN_KEYWORD_COMPRESSED},
      {"COMPRESSION", 0, 0, TOKEN_KEYWORD_COMPRESSION},
      {"CONCAT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONCAT},
      {"CONCAT_WS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONCAT_WS},
      {"CONDITION", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CONDITION},
      {"CONFLICT", 0, 0, TOKEN_KEYWORD_CONFLICT},
      {"CONNECT", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_CONNECT}, /* ocelotgui keyword */
      {"CONNECTION", 0, 0, TOKEN_KEYWORD_CONNECTION},
          {"CONNECTION_ADMIN", 0, 0, TOKEN_KEYWORD_CONNECTION_ADMIN},
      {"CONNECTION_ID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONNECTION_ID},
        {"CONNECT_ATTR_DELETE", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_CONNECT_ATTR_DELETE},
        {"CONNECT_ATTR_RESET", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_CONNECT_ATTR_RESET},
        {"CONNECT_EXPIRED_PASSWORD", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_CONNECT_EXPIRED_PASSWORD},
        {"CONNECT_TIMEOUT", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_CONNECT_TIMEOUT},
      {"CONSTRAINT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CONSTRAINT},
      {"CONTAINS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONTAINS}, /* deprecated in MySQL 5.7.6 */
      {"CONTINUE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_CONTINUE},
      {"CONV", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONV},
      {"CONVERT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONVERT},
      {"CONVERT_TZ", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONVERT_TZ},
      {"CONVEXHULL", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CONVEXHULL}, /* deprecated in MySQL 5.7.6 */
      {"COS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_COS},
      {"COT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_COT},
      {"COUNT", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_COUNT},
      {"CRC32", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CRC32},
      {"CRC32C", 0, FLAG_VERSION_MARIADB_10_8, TOKEN_KEYWORD_CRC32C},
      {"CREATE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CREATE},
      {"CREATE_ASYMMETRIC_PRIV_KEY", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_CREATE_ASYMMETRIC_PRIV_KEY},
      {"CREATE_ASYMMETRIC_PUB_KEY", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_CREATE_ASYMMETRIC_PUB_KEY},
      {"CREATE_DH_PARAMETERS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CREATE_DH_PARAMETERS},
      {"CREATE_DIGEST", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CREATE_DIGEST},
      {"CROSS", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CROSS},
      {"CROSSES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CROSSES}, /* deprecated in MySQL 5.7.6 */
      {"CUBE", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_CUBE},
      {"CUME_DIST", FLAG_VERSION_MYSQL_8_0, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_2_2, TOKEN_KEYWORD_CUME_DIST},
      {"CURDATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CURDATE},
      {"CURRENT", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_CURRENT},
      {"CURRENT_DATE", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CURRENT_DATE},
      {"CURRENT_ROLE", FLAG_VERSION_MARIADB_10_0, 0, TOKEN_KEYWORD_CURRENT_ROLE},
      {"CURRENT_TIME", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CURRENT_TIME},
      {"CURRENT_TIMESTAMP", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CURRENT_TIMESTAMP},
      {"CURRENT_USER", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CURRENT_USER},
      {"CURSOR", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_CURSOR},
      {"CURTIME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_CURTIME},
      {"CYCLE", 0, 0, TOKEN_KEYWORD_CYCLE},
      {"DATABASE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_OPTION, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DATABASE},
      {"DATABASES", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DATABASES},
      {"DATE", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_DATE},
      {"DATEDIFF", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DATEDIFF},
      {"DATETIME", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_DATETIME},
      {"DATE_ADD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DATE_ADD},
      {"DATE_FORMAT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DATE_FORMAT},
      {"DATE_SUB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DATE_SUB},
      {"DAY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DAY},
      {"DAYNAME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DAYNAME},
      {"DAYOFMONTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DAYOFMONTH},
      {"DAYOFWEEK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DAYOFWEEK},
      {"DAYOFYEAR", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DAYOFYEAR},
      {"DAY_HOUR", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DAY_HOUR},
      {"DAY_MICROSECOND", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DAY_MICROSECOND},
      {"DAY_MINUTE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DAY_MINUTE},
      {"DAY_SECOND", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DAY_SECOND},
      {"DEALLOCATE", 0, 0, TOKEN_KEYWORD_DEALLOCATE},
    {"DEBUG", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DEBUG},
    {"DEBUG_CHECK", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_DEBUG_CHECK},
    {"DEBUG_INFO", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DEBUG_INFO},
      {"DEC", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DEC},
      {"DECIMAL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DECIMAL},
      {"DECLARE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DECLARE},
      {"DECODE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DECODE},
      {"DECODE_HISTOGRAM", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_DECODE_HISTOGRAM},
      {"DEFAULT", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DEFAULT},
    {"DEFAULTS_EXTRA_FILE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DEFAULTS_EXTRA_FILE},
    {"DEFAULTS_FILE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DEFAULTS_FILE},
    {"DEFAULTS_GROUP_SUFFIX", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DEFAULTS_GROUP_SUFFIX},
    {"DEFAULT_AUTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DEFAULT_AUTH},
    {"DEFAULT_CHARACTER_SET", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DEFAULT_CHARACTER_SET},
      {"DEFERRABLE", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_DEFERRABLE},
      {"DEFERRED", 0, 0, TOKEN_KEYWORD_DEFERRED},
      {"DEGREES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DEGREES},
      {"DELAYED", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DELAYED},
      {"DELETE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DELETE},
      {"DELIMITER", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_DELIMITER}, /* ocelotgui keyword */
      {"DENSE_RANK", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_TARANTOOL, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_2_2, TOKEN_KEYWORD_DENSE_RANK},
      {"DESC", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DESC},
      {"DESCRIBE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DESCRIBE},
      {"DES_DECRYPT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DES_DECRYPT}, /* deprecated in MySQL 5.7.6 */
      {"DES_ENCRYPT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DES_ENCRYPT}, /* deprecated in MySQL 5.7.6 */
      {"DETACH", 0, 0, TOKEN_KEYWORD_DETACH},
      {"DETERMINISTIC", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DETERMINISTIC},
      {"DIMENSION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DIMENSION}, /* deprecated in MySQL 5.7.6 */
      {"DIRECTORY", 0, 0, TOKEN_KEYWORD_DIRECTORY},
      {"DISJOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DISJOINT}, /* deprecated in MySQL 5.7.6 */
      {"DISTANCE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_DISTANCE}, /* deprecated in MySQL 5.7.6 */
      {"DISTINCT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DISTINCT},
      {"DISTINCTROW", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DISTINCTROW},
      {"DIV", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DIV},
      {"DIVIDER", 0, 0, TOKEN_KEYWORD_DIVIDER},
      {"DO", FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_DO},
      {"DOUBLE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DOUBLE},
      {"DROP", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_DROP},
      {"DUAL", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_DUAL},
      {"DUPLICATE", 0, 0, TOKEN_KEYWORD_DUPLICATE},
      {"DYNAMIC", 0, 0, TOKEN_KEYWORD_DYNAMIC},
      {"EACH", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_EACH},
      {"EDIT", 0, 0, TOKEN_KEYWORD_EDIT}, /* ocelotgui keyword */
      {"EGO", 0, 0, TOKEN_KEYWORD_EGO}, /* ocelotgui keyword */
      {"ELSE", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_ELSE},
      {"ELSEIF", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_ELSEIF},
      {"ELSIF", FLAG_VERSION_PLSQL, 0, TOKEN_KEYWORD_ELSIF},
      {"ELT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ELT},
    {"EMPTY", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_EMPTY},
      {"ENABLE", 0, 0, TOKEN_KEYWORD_ENABLE},
        {"ENABLE_CLEARTEXT_PLUGIN", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_ENABLE_CLEARTEXT_PLUGIN},
      {"ENCLOSED", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_ENCLOSED},
      {"ENCODE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ENCODE},
      {"ENCRYPT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ENCRYPT}, /* deprecated in MySQL 5.7.6 */
          {"ENCRYPTION_KEY_ADMIN", 0, 0, TOKEN_KEYWORD_ENCRYPTION_KEY_ADMIN},
      {"END", FLAG_VERSION_TARANTOOL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_END},
      {"ENDPOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ENDPOINT}, /* deprecated in MySQL 5.7.6 */
      {"ENGINE", FLAG_VERSION_TARANTOOL_2_3, 0, TOKEN_KEYWORD_ENGINE},
      {"ENUM", 0, 0, TOKEN_KEYWORD_ENUM},
      {"ENVELOPE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ENVELOPE}, /* deprecated in MySQL 5.7.6 */
      {"EQUALS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_EQUALS}, /* deprecated in MySQL 5.7.6 */
      {"ERDIAGRAM", 0, 0, TOKEN_KEYWORD_ERDIAGRAM},
      {"ESCAPE", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_ESCAPE},
      {"ESCAPED", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_ESCAPED},
      {"EVENT", 0, 0, TOKEN_KEYWORD_EVENT},
      {"EXAMINED", 0, 0, TOKEN_KEYWORD_EXAMINED},
      {"EXCEPT", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_TARANTOOL|FLAG_VERSION_MARIADB_10_3, 0, TOKEN_KEYWORD_EXCEPT},
      {"EXCEPTION", 0, 0, TOKEN_KEYWORD_EXCEPTION},
      {"EXCHANGE", 0, 0, TOKEN_KEYWORD_EXCHANGE},
      {"EXCLUSIVE", 0, 0, TOKEN_KEYWORD_EXCLUSIVE},
      {"EXECUTE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_EXECUTE},
      {"EXISTS", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_EXISTS},
      {"EXIT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_EXIT},
      {"EXP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_EXP},
      {"EXPANSION", 0, 0, TOKEN_KEYWORD_EXPANSION},
      {"EXPLAIN", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_EXPLAIN},
      {"EXPORT", 0, 0, TOKEN_KEYWORD_EXPORT},
      {"EXPORT_SET", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_EXPORT_SET},
      {"EXTERIORRING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_EXTERIORRING}, /* deprecated in MySQL 5.7.6 */
      {"EXTRACT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_EXTRACT},
      {"EXTRACTVALUE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_EXTRACTVALUE},
      {"FAIL", 0, 0, TOKEN_KEYWORD_FAIL},
      {"FALSE", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_FALSE},
      {"FEDERATED", 0, 0, TOKEN_KEYWORD_FEDERATED},
      {"FETCH", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_FETCH},
      {"FIELD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FIELD},
      {"FIELDS", 0, 0, TOKEN_KEYWORD_FIELDS},
      {"FILE", 0, 0, TOKEN_KEYWORD_FILE},
      {"FIND_IN_SET", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FIND_IN_SET},
          {"FIREWALL_ADMIN", 0, 0, TOKEN_KEYWORD_FIREWALL_ADMIN},
          {"FIREWALL_USER", 0, 0, TOKEN_KEYWORD_FIREWALL_USER},
      {"FIRST", 0, 0, TOKEN_KEYWORD_FIRST}, /* MariaDB 10.2 nonreserved */
      {"FIRST_VALUE", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_FIRST_VALUE}, /* MariaDB 10.2 nonreserved -- or, maybe not in MariaDB 10.2*/
      {"FIXED", 0, 0, TOKEN_KEYWORD_FIXED},
      {"FLOAT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_FLOAT},
      {"FLOAT4", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_FLOAT4},
      {"FLOAT8", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_FLOAT8},
      {"FLOOR", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FLOOR},
      {"FLUSH", 0, 0, TOKEN_KEYWORD_FLUSH},
      {"FOLLOWING", FLAG_VERSION_MARIADB_10_2_2, 0, TOKEN_KEYWORD_FOLLOWING},
      {"FOLLOWS", FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, 0, TOKEN_KEYWORD_FOLLOWS},
      {"FOR", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_FOR},
      {"FORCE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_FORCE},
      {"FOREIGN", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_FOREIGN},
      {"FOREIGN_KEY_LIST", 0, 0, TOKEN_KEYWORD_FOREIGN_KEY_LIST},
      {"FORMAT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FORMAT},
      {"FORMAT_BYTES", 0, FLAG_VERSION_MARIADB_11_8, TOKEN_KEYWORD_FORMAT_BYTES},
      {"FORMAT_PICO_TIME", 0, FLAG_VERSION_MARIADB_11_0, TOKEN_KEYWORD_FORMAT_PICO_TIME},
      {"FOUND", 0, 0, TOKEN_KEYWORD_FOUND},
      {"FOUND_ROWS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FOUND_ROWS},
      {"FROM", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_FROM},
      {"FROM_BASE64", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FROM_BASE64},
      {"FROM_DAYS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FROM_DAYS},
      {"FROM_UNIXTIME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_FROM_UNIXTIME},
      {"FULL", 0, 0, TOKEN_KEYWORD_FULL},
      {"FULLTEXT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_FULLTEXT},
      {"FUNCTION", FLAG_VERSION_MYSQL_8_0 | FLAG_VERSION_TARANTOOL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_FUNCTION},
      {"GENERAL", 0, 0, TOKEN_KEYWORD_GENERAL},
      {"GENERATED", FLAG_VERSION_MYSQL_5_7, 0, TOKEN_KEYWORD_GENERATED},
      {"GEOMCOLLFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMCOLLFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"GEOMCOLLFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMCOLLFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"GEOMETRY", 0, 0, TOKEN_KEYWORD_GEOMETRY},
      {"GEOMETRYCOLLECTION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMETRYCOLLECTION},
      {"GEOMETRYCOLLECTIONFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMETRYCOLLECTIONFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"GEOMETRYCOLLECTIONFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMETRYCOLLECTIONFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"GEOMETRYFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMETRYFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"GEOMETRYFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMETRYFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"GEOMETRYN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMETRYN}, /* deprecated in MySQL 5.7.6 */
      {"GEOMETRYTYPE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMETRYTYPE}, /* deprecated in MySQL 5.7.6 */
      {"GEOMFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMFROMTEXT},/* deprecated in MySQL 5.7.6 */
      {"GEOMFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GEOMFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"GET", FLAG_VERSION_TARANTOOL | FLAG_VERSION_MYSQL_5_6, 0, TOKEN_KEYWORD_GET},
      {"GET_FORMAT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GET_FORMAT},
      {"GET_LOCK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GET_LOCK},
      {"GLENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GLENGTH}, /* deprecated in MySQL 5.7.6 */
      {"GLOBAL", 0, 0, TOKEN_KEYWORD_GLOBAL},
      {"GO", 0, 0, TOKEN_KEYWORD_GO}, /* ocelotgui keyword */
      {"GOTO", FLAG_VERSION_LUA|FLAG_VERSION_PLSQL, 0, TOKEN_KEYWORD_GOTO},
      {"GRANT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_GRANT},
      {"GREATEST", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_TARANTOOL_2_3, TOKEN_KEYWORD_GREATEST},
      {"GROUP", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_GROUP},
    {"GROUPING", FLAG_VERSION_MYSQL_8_0, FLAG_VERSION_MYSQL_8_0, TOKEN_KEYWORD_GROUPING},
    {"GROUPS", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_GROUPS},
      {"GROUP_CONCAT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GROUP_CONCAT},
          {"GROUP_REPLICATION_ADMIN", 0, 0, TOKEN_KEYWORD_GROUP_REPLICATION_ADMIN},
      {"GTID_SUBSET", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GTID_SUBSET},
      {"GTID_SUBTRACT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_GTID_SUBTRACT},
      {"HANDLER", 0, 0, TOKEN_KEYWORD_HANDLER},
      {"HAVING", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_HAVING},
      {"HELP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_HELP}, /* ocelotgui keyword */
      {"HEX", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_HEX},
      {"HIGH_PRIORITY", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_HIGH_PRIORITY},
    {"HISTFILE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_HISTFILE},
    {"HISTIGNORE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_HISTIGNORE},
    {"HOST", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_HOST},
      {"HOUR", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_HOUR},
      {"HOUR_MICROSECOND", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_HOUR_MICROSECOND},
      {"HOUR_MINUTE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_HOUR_MINUTE},
      {"HOUR_SECOND", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_HOUR_SECOND},
        {"HTML", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_HTML},
      {"IDENTIFIER", 0, 0, TOKEN_KEYWORD_IDENTIFIER}, /* for format rule */
      {"IF", FLAG_VERSION_ALL | FLAG_VERSION_LUA, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IF},
      {"IFNULL", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_IFNULL},
      {"IGNORE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_IGNORE},
        {"IGNORE_SPACES", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_IGNORE_SPACES},
      {"IMMEDIATE", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_IMMEDIATE},
      {"IMPORT", 0, 0, TOKEN_KEYWORD_IMPORT}, /* unused */
      {"IN", FLAG_VERSION_ALL | FLAG_VERSION_LUA, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IN},
      {"INDEX", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_INDEX},
      {"INDEXED", 0, 0, TOKEN_KEYWORD_INDEXED},
      {"INDEX_INFO", 0, 0, TOKEN_KEYWORD_INDEX_INFO},
      {"INDEX_LIST", 0, 0, TOKEN_KEYWORD_INDEX_LIST},
      {"INET4", 0, 0, TOKEN_KEYWORD_INET4}, /* MariaDB 10.11 */
      {"INET6", 0, 0, TOKEN_KEYWORD_INET6}, /* MariaDB 10.5 */
      {"INET6_ATON", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INET6_ATON},
      {"INET6_NTOA", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INET6_NTOA},
      {"INET_ATON", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INET_ATON},
      {"INET_NTOA", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INET_NTOA},
      {"INFILE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_INFILE},
      {"INITIALLY", 0, 0, TOKEN_KEYWORD_INITIALLY},
        {"INIT_COMMAND", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_INIT_COMMAND},
      {"INNER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_INNER},
      {"INOUT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_INOUT},
      {"INSENSITIVE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_INSENSITIVE},
      {"INSERT", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INSERT},
      {"INSTALL", 0, 0, TOKEN_KEYWORD_INSTALL},
      {"INSTEAD", 0, 0, TOKEN_KEYWORD_INSTEAD},
      {"INSTR", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_INSTR},
      {"INT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_INT},
      {"INT1", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_INT1},
      {"INT2", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_INT2},
      {"INT3", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_INT3},
      {"INT4", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_INT4},
      {"INT8", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_INT8},
      {"INTEGER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_INTEGER},
      {"INTERIORRINGN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INTERIORRINGN}, /* deprecated in MySQL 5.7.6 */
      {"INTERSECT", FLAG_VERSION_MYSQL_8_0_31|FLAG_VERSION_TARANTOOL|FLAG_VERSION_MARIADB_10_3, 0, TOKEN_KEYWORD_INTERSECT},
      {"INTERSECTS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INTERSECTS}, /* deprecated in MySQL 5.7.6 */
      {"INTERVAL", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_INTERVAL},
      {"INTO", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_INTO},
      {"IO_AFTER_GTIDS", FLAG_VERSION_MYSQL_5_6, 0, TOKEN_KEYWORD_IO_AFTER_GTIDS},
      {"IO_BEFORE_GTIDS", FLAG_VERSION_MYSQL_5_6, 0, TOKEN_KEYWORD_IO_BEFORE_GTIDS},
      {"IS", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_IS},
      {"ISCLOSED", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ISCLOSED}, /* deprecated in MySQL 5.7.6 */
      {"ISEMPTY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ISEMPTY}, /* deprecated in MySQL 5.7.6 */
      {"ISNULL", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_ISNULL},
      {"ISSIMPLE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ISSIMPLE}, /* deprecated in MySQL 5.7.6 */
      {"IS_FREE_LOCK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IS_FREE_LOCK},
      {"IS_IPV4", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IS_IPV4},
      {"IS_IPV4_COMPAT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IS_IPV4_COMPAT},
      {"IS_IPV4_MAPPED", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IS_IPV4_MAPPED},
      {"IS_IPV6", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IS_IPV6},
      {"IS_USED_LOCK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_IS_USED_LOCK},
      {"ITERATE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ITERATE},
      {"JAVASCRIPT", 0, 0, TOKEN_KEYWORD_JAVASCRIPT},
      {"JOIN", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_JOIN},
      {"JSON", 0, 0, TOKEN_KEYWORD_JSON},
      {"JSON_APPEND", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_APPEND},
      {"JSON_ARRAY", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_ARRAY},
      {"JSON_ARRAYAGG", 0, FLAG_VERSION_MARIADB_10_5, TOKEN_KEYWORD_JSON_ARRAYAGG},
      {"JSON_ARRAY_APPEND", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_ARRAY_APPEND},
      {"JSON_ARRAY_INSERT", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_ARRAY_INSERT},
      {"JSON_ARRAY_INTERSECT", 0, FLAG_VERSION_MARIADB_11_2, TOKEN_KEYWORD_JSON_ARRAY_INTERSECT},
      {"JSON_COMPACT", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_JSON_COMPACT},
      {"JSON_CONTAINS", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_CONTAINS},
      {"JSON_CONTAINS_PATH", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_CONTAINS_PATH},
      {"JSON_DEPTH", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_JSON_DEPTH},
      {"JSON_DETAILED", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_JSON_DETAILED},
      {"JSON_EQUALS", 0, FLAG_VERSION_MARIADB_10_7, TOKEN_KEYWORD_JSON_EQUALS},
      {"JSON_EXISTS", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_JSON_EXISTS},
      {"JSON_EXTRACT", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_EXTRACT},
      {"JSON_INSERT", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_INSERT},
      {"JSON_KEYS", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_JSON_KEYS},
      {"JSON_KEY_VALUE", 0, FLAG_VERSION_MARIADB_11_2, TOKEN_KEYWORD_JSON_KEY_VALUE},
      {"JSON_LENGTH", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_JSON_LENGTH},
      {"JSON_LOOSE", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_JSON_LOOSE},
      {"JSON_MERGE", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_MERGE},
      {"JSON_MERGE_PATCH", 0, FLAG_VERSION_MYSQL_8_0 | FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_JSON_MERGE_PATCH},
      {"JSON_MERGE_PRESERVE", 0, FLAG_VERSION_MYSQL_8_0 | FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_JSON_MERGE_PRESERVE},
      {"JSON_NORMALIZE", 0, FLAG_VERSION_MARIADB_10_7, TOKEN_KEYWORD_JSON_NORMALIZE},
      {"JSON_OBJECT", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_OBJECT},
      {"JSON_OBJECTAGG", 0, FLAG_VERSION_MARIADB_10_5, TOKEN_KEYWORD_JSON_OBJECTAGG},
      {"JSON_OBJECT_FILTER_KEYS", 0, FLAG_VERSION_MARIADB_11_2, TOKEN_KEYWORD_JSON_OBJECT_FILTER_KEYS},
      {"JSON_OBJECT_TO_ARRAY", 0, FLAG_VERSION_MARIADB_11_2, TOKEN_KEYWORD_JSON_OBJECT_TO_ARRAY},
      {"JSON_OVERLAPS", 0, FLAG_VERSION_MYSQL_8_0 | FLAG_VERSION_MARIADB_10_9, TOKEN_KEYWORD_JSON_OVERLAPS},
      {"JSON_PRETTY", 0, FLAG_VERSION_MYSQL_8_0 | FLAG_VERSION_MARIADB_10_5, TOKEN_KEYWORD_JSON_PRETTY},
      {"JSON_QUERY", 0, FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_QUERY},
      {"JSON_QUOTE", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_QUOTE},
      {"JSON_REMOVE", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_3 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_REMOVE},
      {"JSON_REPLACE", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_3 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_REPLACE},
      {"JSON_SCHEMA_VALID", 0, FLAG_VERSION_MYSQL_8_0 | FLAG_VERSION_MARIADB_11_1, TOKEN_KEYWORD_JSON_SCHEMA_VALID},
      {"JSON_SCHEMA_VALIDATION_REPORT", 0, FLAG_VERSION_MYSQL_8_0, TOKEN_KEYWORD_JSON_SCHEMA_VALIDATION_REPORT},
      {"JSON_SEARCH", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_JSON_SEARCH},
      {"JSON_SET", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_3 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_SET},
      {"JSON_STORAGE_FREE", 0, FLAG_VERSION_MYSQL_8_0, TOKEN_KEYWORD_JSON_STORAGE_FREE},
      {"JSON_STORAGE_SIZE", 0, FLAG_VERSION_MYSQL_8_0, TOKEN_KEYWORD_JSON_STORAGE_SIZE},
      {"JSON_TABLE", FLAG_VERSION_MYSQL_8_0 | FLAG_VERSION_MARIADB_10_6, FLAG_VERSION_MYSQL_8_0 | FLAG_VERSION_MARIADB_10_6, TOKEN_KEYWORD_JSON_TABLE},
      {"JSON_TYPE", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_3 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_TYPE},
      {"JSON_UNQUOTE", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_JSON_UNQUOTE},
      {"JSON_VALID", 0, FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3 | FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JSON_VALID},
      {"JSON_VALUE", 0, FLAG_VERSION_MYSQL_8_0 | FLAG_VERSION_MARIADB_10_2_3, TOKEN_KEYWORD_JSON_VALUE},
      {"JULIANDAY", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_JULIANDAY},
      {"KDF", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_KDF},
      {"KEY", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_KEY},
      {"KEYS", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_KEYS},
      {"KEYWORD", 0, 0, TOKEN_KEYWORD_KEYWORD}, /* for format rule */
      {"KILL", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_KILL},
      {"LAG", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_3, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_LAG}, /* MariaDB 10.2 nonreserved -- or, maybe not in MariaDB 10.2 */
      {"LANGUAGE", 0, 0, TOKEN_KEYWORD_LANGUAGE},
      {"LAST", 0, 0, TOKEN_KEYWORD_LAST}, /* MariaDB 10.2 nonreserved */
      {"LASTVAL", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_LASTVAL},
      {"LAST_DAY", FLAG_VERSION_MARIADB_10_0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_LAST_DAY},
      {"LAST_INSERT_ID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LAST_INSERT_ID},
      {"LAST_VALUE", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_LAST_VALUE}, /* MariaDB 10.2 nonreserved */
      {"LATERAL", FLAG_VERSION_MYSQL_8_0_31, 0, TOKEN_KEYWORD_LATERAL}, /* MySQL 8.0.2 manual said reserved, it wasn't, but is now */
      {"LCASE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LCASE},
        {"LD_RUN_PATH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_LD_RUN_PATH},
      {"LEAD", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_3, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_LEAD}, /* MariaDB 10.2 nonreserved -- or, maybe not in MariaDB 10.2 */
      {"LEADING", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_LEADING},
      {"LEAST", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_TARANTOOL_2_3, TOKEN_KEYWORD_LEAST},
      {"LEAVE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_LEAVE},
      {"LEFT", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LEFT},
      {"LENGTH", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_LENGTH},
      {"LEVEL", 0, 0, TOKEN_KEYWORD_LEVEL},
      {"LIBRARY", FLAG_VERSION_MYSQL_9_3, 0, TOKEN_KEYWORD_LIBRARY},
      {"LIKE", FLAG_VERSION_ALL, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_LIKE},
      {"LIMIT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_LIMIT},
      {"LINE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_LINE},
      {"LINEAR", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LINEAR},
      {"LINEFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LINEFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"LINEFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LINEFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"LINES", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LINES},
      {"LINESTRING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LINESTRING},
      {"LINESTRINGFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LINESTRINGFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"LINESTRINGFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LINESTRINGFROMWKB},   /* deprecated in MySQL 5.7.6 */
        {"LINE_NUMBERS", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_LINE_NUMBERS},
      {"LITERAL", 0, 0, TOKEN_KEYWORD_LITERAL}, /* for format rule */
      {"LN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LN},
      {"LOAD", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LOAD},
      {"LOAD_FILE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LOAD_FILE},
      {"LOCAL", FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_LOCAL},
      {"LOCALTIME", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LOCALTIME},
      {"LOCALTIMESTAMP", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LOCALTIMESTAMP},
        {"LOCAL_INFILE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_LOCAL_INFILE},
      {"LOCATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LOCATE},
      {"LOCK", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LOCK},
      {"LOG", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LOG},
      {"LOG10", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LOG10},
      {"LOG2", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LOG2},
      {"LOGFILE", 0, 0, TOKEN_KEYWORD_LOGFILE},
        {"LOGIN_PATH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_LOGIN_PATH},
      {"LONG", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LONG},
      {"LONGBLOB", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LONGBLOB},
      {"LONGTEXT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LONGTEXT},
      {"LOOP", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_LOOP},
      {"LOWER", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_LOWER},
      {"LOW_PRIORITY", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_LOW_PRIORITY},
      {"LPAD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_LPAD},
      {"LTRIM", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_LTRIM},
      {"LUA", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_LUA},
      {"MAKEDATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MAKEDATE},
      {"MAKETIME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MAKETIME},
      {"MAKE_SET", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MAKE_SET},
      {"MANUAL", FLAG_VERSION_MYSQL_8_4, 0, TOKEN_KEYWORD_MANUAL},
      {"MAP", 0, 0, TOKEN_KEYWORD_MAP},
      {"MARGIN", 0, 0, TOKEN_KEYWORD_MARGIN}, /* export */
      {"MASTER_BIND", FLAG_VERSION_MYSQL_5_6, 0, TOKEN_KEYWORD_MASTER_BIND},
      {"MASTER_HEARTBEAT_PERIOD", 0, 0, TOKEN_KEYWORD_MASTER_HEARTBEAT_PERIOD},
      {"MASTER_POS_WAIT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MASTER_POS_WAIT},
      {"MASTER_SSL_VERIFY_SERVER_CERT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MASTER_SSL_VERIFY_SERVER_CERT},
      {"MATCH", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_MATCH},
      {"MAX", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_MAX},
      {"MAXVALUE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MAXVALUE},
    {"MAX_ALLOWED_PACKET", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_MAX_ALLOWED_PACKET},
    {"MAX_JOIN_SIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_MAX_JOIN_SIZE},
      {"MAX_ROW_COUNT", 0, 0, TOKEN_KEYWORD_MAX_ROW_COUNT}, /* export */
      {"MBRCONTAINS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBRCONTAINS},
      {"MBRCOVEREDBY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBRCOVEREDBY},
      {"MBRCOVERS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBRCOVERS},
      {"MBRDISJOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBRDISJOINT},
      {"MBREQUAL", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBREQUAL}, /* deprecated in MySQL 5.7.6 */
      {"MBREQUALS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBREQUALS},
      {"MBRINTERSECTS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBRINTERSECTS},
      {"MBROVERLAPS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBROVERLAPS},
      {"MBRTOUCHES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBRTOUCHES},
      {"MBRWITHIN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MBRWITHIN},
      {"MD5", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MD5},
      {"MEDIAN", FLAG_VERSION_MARIADB_10_3, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_MEDIAN}, /* MariaDB 10.3.3 */
      {"MEDIUMBLOB", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MEDIUMBLOB},
      {"MEDIUMINT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MEDIUMINT},
      {"MEDIUMTEXT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MEDIUMTEXT},
      {"MEMBER", 0, 0, TOKEN_KEYWORD_MEMBER}, /* not highlighted as function though MySQL calls it one */
      {"MICROSECOND", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MICROSECOND},
      {"MID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MID},
      {"MIDDLEINT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MIDDLEINT},
      {"MIN", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_MIN},
      {"MINUS", FLAG_VERSION_PLSQL, 0, TOKEN_KEYWORD_MINUS},
      {"MINUTE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MINUTE},
      {"MINUTE_MICROSECOND", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MINUTE_MICROSECOND},
      {"MINUTE_SECOND", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MINUTE_SECOND},
      {"MINVALUE", 0, 0, TOKEN_KEYWORD_MINVALUE},
      {"MLINEFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MLINEFROMTEXT},  /* deprecated in MySQL 5.7.6 */
      {"MLINEFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MLINEFROMWKB},  /* deprecated in MySQL 5.7.6 */
      {"MOD", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MOD},
      {"MODE", 0, 0, TOKEN_KEYWORD_MODE},
      {"MODIFIES", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_MODIFIES},
      {"MONTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MONTH},
      {"MONTHNAME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MONTHNAME},
      {"MPOINTFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MPOINTFROMTEXT},  /* deprecated in MySQL 5.7.6 */
      {"MPOINTFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MPOINTFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"MPOLYFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MPOLYFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"MPOLYFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MPOLYFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"MULTILINESTRING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTILINESTRING},
      {"MULTILINESTRINGFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTILINESTRINGFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"MULTILINESTRINGFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTILINESTRINGFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"MULTIPOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTIPOINT},
      {"MULTIPOINTFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTIPOINTFROMTEXT},  /* deprecated in MySQL 5.7.6 */
      {"MULTIPOINTFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTIPOINTFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"MULTIPOLYGON", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTIPOLYGON},
      {"MULTIPOLYGONFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTIPOLYGONFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"MULTIPOLYGONFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_MULTIPOLYGONFROMWKB}, /* deprecated in MySQL 5.7.6 */
        {"NAMED_COMMANDS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_NAMED_COMMANDS},
      {"NAMES", 0, 0, TOKEN_KEYWORD_NAMES},
      {"NAME_CONST", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_NAME_CONST},
      {"NATURAL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_NATURAL},
      {"NATURAL_SORT_KEY", 0, FLAG_VERSION_MARIADB_10_7, TOKEN_KEYWORD_NATURAL_SORT_KEY},
      {"NCHAR", 0, 0, TOKEN_KEYWORD_NCHAR},
        {"NET_BUFFER_LENGTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_NET_BUFFER_LENGTH},
      {"NEWLINE", 0, 0, TOKEN_KEYWORD_NEWLINE}, /* for format rule */
      {"NEXT", 0, 0, TOKEN_KEYWORD_NEXT},
      {"NEXTVAL", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_NEXTVAL},
      {"NIL", FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_NIL},
      {"NO", 0, 0, TOKEN_KEYWORD_NO},
      {"NONE", 0, 0, TOKEN_KEYWORD_NONE},
      {"NOPAGER", 0, 0, TOKEN_KEYWORD_NOPAGER}, /* ocelotgui keyword */
      {"NOT", FLAG_VERSION_TARANTOOL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_NOT},
      {"NOTEE", 0, 0, TOKEN_KEYWORD_NOTEE}, /* ocelotgui keyword */
      {"NOTNULL", 0, 0, TOKEN_KEYWORD_NOTNULL},
      {"NOW", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_NOW},
      {"NOWARNING", 0, 0, TOKEN_KEYWORD_NOWARNING}, /* ocelotgui keyword */
        {"NO_AUTO_REHASH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_NO_AUTO_REHASH},
    {"NO_BEEP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_NO_BEEP},
    {"NO_DEFAULTS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_NO_DEFAULTS},
    {"NO_NAMED_COMMANDS", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_NO_NAMED_COMMANDS},
    {"NO_TEE", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_NO_TEE},
      {"NO_WRITE_TO_BINLOG", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_NO_WRITE_TO_BINLOG},
      {"NTH_VALUE", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_3, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_NTH_VALUE}, /* MariaDB 10.2 nonreserved -- or, maybe not in MariaDB 10.2 */
      {"NTILE", FLAG_VERSION_MYSQL_8_0, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_2_2, TOKEN_KEYWORD_NTILE},
      {"NULL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_NULL},
      {"NULLIF", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_NULLIF},
      {"NULLS", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_NULLS}, /* MariaDB 10.2 nonreserved  -- or, maybe not in MariaDB 10.2 */
      {"NUM", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_NUM},
      {"NUMBER", FLAG_VERSION_TARANTOOL_2_2, 0, TOKEN_KEYWORD_NUMBER},
      {"NUMERIC", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_NUMERIC},
      {"NUMGEOMETRIES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_NUMGEOMETRIES}, /* deprecated in MySQL 5.7.6 */
      {"NUMINTERIORRINGS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_NUMINTERIORRINGS}, /* deprecated in MySQL 5.7.6 */
      {"NUMPOINTS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_NUMPOINTS}, /* deprecated in MySQL 5.7.6 */
      {"NVARCHAR2", 0, 0, TOKEN_KEYWORD_NVARCHAR2},

    {"OCELOT_BATCH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_BATCH},
    {"OCELOT_CLIENT_SIDE_FUNCTIONS", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_OCELOT_CLIENT_SIDE_FUNCTIONS},
    {"OCELOT_COMPLETER_TIMEOUT", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_OCELOT_COMPLETER_TIMEOUT},
    {"OCELOT_DBMS", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_OCELOT_DBMS},
    {"OCELOT_DEBUG_DETACHED", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_DEBUG_DETACHED},
    {"OCELOT_DEBUG_HEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_DEBUG_HEIGHT},
    {"OCELOT_DEBUG_LEFT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_DEBUG_LEFT},
    {"OCELOT_DEBUG_TOP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_DEBUG_TOP},
    {"OCELOT_DEBUG_WIDTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_DEBUG_WIDTH},

    {"OCELOT_EXPLORER_ACTION", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_ACTION},
    {"OCELOT_EXPLORER_APPLICABLE_DBMSS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_APPLICABLE_DBMSS},
    {"OCELOT_EXPLORER_APPLICABLE_TYPES", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_APPLICABLE_TYPES},
    {"OCELOT_EXPLORER_BACKGROUND_COLOR", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_BACKGROUND_COLOR},
    {"OCELOT_EXPLORER_DETACHED", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_DETACHED},
    {"OCELOT_EXPLORER_ENABLED", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_ENABLED},
    {"OCELOT_EXPLORER_FONT_FAMILY", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_FAMILY},
    {"OCELOT_EXPLORER_FONT_SIZE", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_SIZE},
    {"OCELOT_EXPLORER_FONT_STYLE", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_STYLE},
    {"OCELOT_EXPLORER_FONT_WEIGHT", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_FONT_WEIGHT},
    {"OCELOT_EXPLORER_HEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_HEIGHT},
    {"OCELOT_EXPLORER_LEFT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_LEFT},
    {"OCELOT_EXPLORER_SHORTCUT", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_SHORTCUT},
    {"OCELOT_EXPLORER_TEXT", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_TEXT},
    {"OCELOT_EXPLORER_TEXT_COLOR", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_TEXT_COLOR},
    {"OCELOT_EXPLORER_TOP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_TOP},
    {"OCELOT_EXPLORER_VISIBLE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_VISIBLE},
    {"OCELOT_EXPLORER_WIDTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXPLORER_WIDTH},
    {"OCELOT_EXPORT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXPORT}, /* if OCELOT_IMPORT_EXPORT == 1 */
    {"OCELOT_EXTRA_RULE_1_BACKGROUND_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_BACKGROUND_COLOR},
    {"OCELOT_EXTRA_RULE_1_CONDITION", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_CONDITION},
    {"OCELOT_EXTRA_RULE_1_DISPLAY_AS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_DISPLAY_AS},
    {"OCELOT_EXTRA_RULE_1_TEXT_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_EXTRA_RULE_1_TEXT_COLOR},
    {"OCELOT_GRID_BACKGROUND_COLOR", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_GRID_BACKGROUND_COLOR},
    {"OCELOT_GRID_CELL_BORDER_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_COLOR},
    {"OCELOT_GRID_CELL_BORDER_SIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_CELL_BORDER_SIZE},
    {"OCELOT_GRID_CELL_HEIGHT", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_GRID_CELL_HEIGHT},
    {"OCELOT_GRID_CELL_WIDTH", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_GRID_CELL_WIDTH},
    {"OCELOT_GRID_CHART", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_GRID_CHART},
    {"OCELOT_GRID_DETACHED", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_DETACHED},
    {"OCELOT_GRID_FOCUS_CELL_BACKGROUND_COLOR", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_GRID_FOCUS_CELL_BACKGROUND_COLOR},
    {"OCELOT_GRID_FONT_FAMILY", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_GRID_FONT_FAMILY},
    {"OCELOT_GRID_FONT_SIZE", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_GRID_FONT_SIZE},
    {"OCELOT_GRID_FONT_STYLE", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_GRID_FONT_STYLE},
    {"OCELOT_GRID_FONT_WEIGHT", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_GRID_FONT_WEIGHT},
    {"OCELOT_GRID_HEADER_BACKGROUND_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_HEADER_BACKGROUND_COLOR},
    {"OCELOT_GRID_HEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_HEIGHT},
    {"OCELOT_GRID_HTML_EFFECTS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_HTML_EFFECTS},
    {"OCELOT_GRID_LEFT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_LEFT},
    {"OCELOT_GRID_OUTER_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_OUTER_COLOR},
    {"OCELOT_GRID_TABS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_TABS},
    {"OCELOT_GRID_TEXT_COLOR", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_GRID_TEXT_COLOR},
    {"OCELOT_GRID_TOOLTIP", FLAG_VERSION_OPTION|FLAG_VERSION_CONDITIONAL, 0, TOKEN_KEYWORD_OCELOT_GRID_TOOLTIP},
    {"OCELOT_GRID_TOP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_TOP},
    {"OCELOT_GRID_WIDTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_GRID_WIDTH},
    {"OCELOT_HISTFILEFLAGS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTFILEFLAGS},
    {"OCELOT_HISTFILESIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTFILESIZE},
    {"OCELOT_HISTORY_BACKGROUND_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_BACKGROUND_COLOR},
    {"OCELOT_HISTORY_BORDER_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_BORDER_COLOR},
    {"OCELOT_HISTORY_DETACHED", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_DETACHED},
    {"OCELOT_HISTORY_FONT_FAMILY", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_FAMILY},
    {"OCELOT_HISTORY_FONT_SIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_SIZE},
    {"OCELOT_HISTORY_FONT_STYLE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_STYLE},
    {"OCELOT_HISTORY_FONT_WEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_FONT_WEIGHT},
    {"OCELOT_HISTORY_HEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_HEIGHT},
    {"OCELOT_HISTORY_LEFT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_LEFT},
    {"OCELOT_HISTORY_MAX_ROW_COUNT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_MAX_ROW_COUNT},
    {"OCELOT_HISTORY_TEXT_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_TEXT_COLOR},
    {"OCELOT_HISTORY_TOP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_TOP},
    {"OCELOT_HISTORY_WIDTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTORY_WIDTH},
    {"OCELOT_HISTSIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HISTSIZE},
    {"OCELOT_HORIZONTAL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HORIZONTAL},
    {"OCELOT_HTML", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HTML},
    {"OCELOT_HTMLRAW", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_HTMLRAW},
    {"OCELOT_IMPORT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_IMPORT}, /* if OCELOT_IMPORT_EXPORT == 1 */ /* unused */
    {"OCELOT_LANGUAGE", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_OCELOT_LANGUAGE},
    {"OCELOT_LOG_LEVEL", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_OCELOT_LOG_LEVEL},
    {"OCELOT_MAX_CONDITIONS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_MAX_CONDITIONS},
    {"OCELOT_MENU_BACKGROUND_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_MENU_BACKGROUND_COLOR},
    {"OCELOT_MENU_BORDER_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_MENU_BORDER_COLOR},
    {"OCELOT_MENU_FONT_FAMILY", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_MENU_FONT_FAMILY},
    {"OCELOT_MENU_FONT_SIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_MENU_FONT_SIZE},
    {"OCELOT_MENU_FONT_STYLE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_MENU_FONT_STYLE},
    {"OCELOT_MENU_FONT_WEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_MENU_FONT_WEIGHT},
    {"OCELOT_MENU_TEXT_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_MENU_TEXT_COLOR},
    {"OCELOT_QUERY", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_QUERY},
    {"OCELOT_RAW", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_RAW},
    {"OCELOT_SHORTCUT_AUTOCOMPLETE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_AUTOCOMPLETE},
    {"OCELOT_SHORTCUT_BATCH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_BATCH},
    {"OCELOT_SHORTCUT_BREAKPOINT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_BREAKPOINT},
    {"OCELOT_SHORTCUT_CHART_BAR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_BAR},
    {"OCELOT_SHORTCUT_CHART_LINE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_LINE},
    {"OCELOT_SHORTCUT_CHART_NONE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_NONE},
    {"OCELOT_SHORTCUT_CHART_PIE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_CHART_PIE},
    {"OCELOT_SHORTCUT_CLEAR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_CLEAR},
    {"OCELOT_SHORTCUT_CONNECT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_CONNECT},
    {"OCELOT_SHORTCUT_CONTINUE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_CONTINUE},
    {"OCELOT_SHORTCUT_COPY", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_COPY},
    {"OCELOT_SHORTCUT_CUT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_CUT},
    {"OCELOT_SHORTCUT_DEBUG_EXIT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_DEBUG_EXIT},
    {"OCELOT_SHORTCUT_EXECUTE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_EXECUTE},
    {"OCELOT_SHORTCUT_EXIT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_EXIT},
    {"OCELOT_SHORTCUT_FIND", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_FIND},
    {"OCELOT_SHORTCUT_FORMAT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_FORMAT},
    {"OCELOT_SHORTCUT_HISTORY_MARKUP_NEXT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_NEXT},
    {"OCELOT_SHORTCUT_HISTORY_MARKUP_PREVIOUS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_HISTORY_MARKUP_PREVIOUS},
    {"OCELOT_SHORTCUT_HORIZONTAL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_HORIZONTAL},
    {"OCELOT_SHORTCUT_HTML", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_HTML},
    {"OCELOT_SHORTCUT_HTMLRAW", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_HTMLRAW},
    {"OCELOT_SHORTCUT_INFORMATION", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_INFORMATION},
    {"OCELOT_SHORTCUT_KILL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_KILL},
    {"OCELOT_SHORTCUT_NEXT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT},
    {"OCELOT_SHORTCUT_NEXT_WINDOW", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_NEXT_WINDOW},
    {"OCELOT_SHORTCUT_PASTE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_PASTE},
    {"OCELOT_SHORTCUT_PREVIOUS_WINDOW", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_PREVIOUS_WINDOW},
    {"OCELOT_SHORTCUT_RAW", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_RAW},
    {"OCELOT_SHORTCUT_REDO", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_REDO},
    {"OCELOT_SHORTCUT_REFRESH_CALL_STACK", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_CALL_STACK},
    {"OCELOT_SHORTCUT_REFRESH_SERVER_VARIABLES", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_SERVER_VARIABLES},
    {"OCELOT_SHORTCUT_REFRESH_USER_VARIABLES", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_USER_VARIABLES},
    {"OCELOT_SHORTCUT_REFRESH_VARIABLES", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_REFRESH_VARIABLES},
    {"OCELOT_SHORTCUT_SELECT_ALL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_SELECT_ALL},
    {"OCELOT_SHORTCUT_STEP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_STEP},
    {"OCELOT_SHORTCUT_UNDO", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_UNDO},
    {"OCELOT_SHORTCUT_VERTICAL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_VERTICAL},
    {"OCELOT_SHORTCUT_XML", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_XML},
    {"OCELOT_SHORTCUT_ZOOMIN", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMIN},
    {"OCELOT_SHORTCUT_ZOOMOUT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_SHORTCUT_ZOOMOUT},
    {"OCELOT_STATEMENT_BACKGROUND_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_BACKGROUND_COLOR},
    {"OCELOT_STATEMENT_BORDER_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_BORDER_COLOR},
    {"OCELOT_STATEMENT_DETACHED", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_DETACHED},
    {"OCELOT_STATEMENT_FONT_FAMILY", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_FAMILY},
    {"OCELOT_STATEMENT_FONT_SIZE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_SIZE},
    {"OCELOT_STATEMENT_FONT_STYLE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_STYLE},
    {"OCELOT_STATEMENT_FONT_WEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FONT_WEIGHT},
    {"OCELOT_STATEMENT_FORMAT_CLAUSE_INDENT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_CLAUSE_INDENT},
    {"OCELOT_STATEMENT_FORMAT_RULE", 0, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_RULE},
    {"OCELOT_STATEMENT_FORMAT_STATEMENT_INDENT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_FORMAT_STATEMENT_INDENT},
    {"OCELOT_STATEMENT_HEIGHT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HEIGHT},
    {"OCELOT_STATEMENT_HIGHLIGHT_COMMENT_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_COMMENT_COLOR},
    {"OCELOT_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR},
    {"OCELOT_STATEMENT_HIGHLIGHT_FUNCTION_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_FUNCTION_COLOR},
    {"OCELOT_STATEMENT_HIGHLIGHT_IDENTIFIER_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_IDENTIFIER_COLOR},
    {"OCELOT_STATEMENT_HIGHLIGHT_KEYWORD_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_KEYWORD_COLOR},
    {"OCELOT_STATEMENT_HIGHLIGHT_LITERAL_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_LITERAL_COLOR},
    {"OCELOT_STATEMENT_HIGHLIGHT_OPERATOR_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_HIGHLIGHT_OPERATOR_COLOR},
    {"OCELOT_STATEMENT_LEFT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_LEFT},
    {"OCELOT_STATEMENT_PROMPT_BACKGROUND_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_PROMPT_BACKGROUND_COLOR},
    {"OCELOT_STATEMENT_SYNTAX_CHECKER", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_SYNTAX_CHECKER},
    {"OCELOT_STATEMENT_TEXT_COLOR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_TEXT_COLOR},
    {"OCELOT_STATEMENT_TOP", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_TOP},
    {"OCELOT_STATEMENT_WIDTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_STATEMENT_WIDTH},
    {"OCELOT_VERTICAL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_VERTICAL},
    {"OCELOT_XML", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_OCELOT_XML},

      {"OCT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_OCT},
      {"OCTET_LENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_OCTET_LENGTH},
      {"OF", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_OF},
      {"OFF", 0, 0, TOKEN_KEYWORD_OFF},
      {"OFFSET", FLAG_VERSION_MARIADB_10_1, 0, TOKEN_KEYWORD_OFFSET},
      {"OJ", 0, 0, TOKEN_KEYWORD_OJ},
      {"OLD_PASSWORD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_OLD_PASSWORD},
      {"ON", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ON},
        {"ONE_DATABASE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_ONE_DATABASE},
      {"ONLY", 0, 0, TOKEN_KEYWORD_ONLY},
      {"OPEN", 0, 0, TOKEN_KEYWORD_OPEN},
      {"OPERATOR", 0, 0, TOKEN_KEYWORD_OPERATOR}, /* for format rule */
      {"OPTIMIZE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_OPTIMIZE},
      {"OPTIMIZER_COSTS", FLAG_VERSION_MYSQL_5_7, 0, TOKEN_KEYWORD_OPTIMIZER_COSTS},
      {"OPTION", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_OPTION},
      {"OPTIONALLY", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_OPTIONALLY},
      {"OR", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_OR},
      {"ORD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ORD},
      {"ORDER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_ORDER},
      {"OUT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_OUT},
      {"OUTER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_OUTER},
      {"OUTFILE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_OUTFILE},
      {"OVER", FLAG_VERSION_MYSQL_8_0 | FLAG_VERSION_TARANTOOL | FLAG_VERSION_MARIADB_10_2_2, 0, TOKEN_KEYWORD_OVER},
      {"OVERLAPS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_OVERLAPS}, /* deprecated in MySQL 5.7.6 */
      {"PACKAGE", FLAG_VERSION_PLSQL, 0, TOKEN_KEYWORD_PACKAGE},
      {"PAD", 0, 0, TOKEN_KEYWORD_PAD}, /* export */
      {"PAGER", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_PAGER}, /* ocelotgui keyword */
      {"PARALLEL", FLAG_VERSION_MYSQL_8_4, 0, TOKEN_KEYWORD_PARALLEL},
      {"PARSER_TRACE", 0, 0, TOKEN_KEYWORD_PARSER_TRACE},
      {"PARTIAL", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_PARTIAL},
      {"PARTITION", FLAG_VERSION_TARANTOOL | FLAG_VERSION_MYSQL_5_6 | FLAG_VERSION_MARIADB_10_0, 0, TOKEN_KEYWORD_PARTITION},
      {"PASSWORD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_OPTION, TOKEN_KEYWORD_PASSWORD}, /* deprecated in MySQL 5.7.6 */
      {"PERCENTILE_CONT", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_PERCENTILE_CONT}, /* MariaDB 10.2 nonreserved -- or, maybe not in MariaDB 10.2 */
      {"PERCENTILE_DISC", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_PERCENTILE_DISC}, /* MariaDB 10.2 nonreserved -- or, maybe not in MariaDB 10.2 */
      {"PERCENT_RANK", FLAG_VERSION_MYSQL_8_0, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_2_2, TOKEN_KEYWORD_PERCENT_RANK},
      {"PERIOD", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_PERIOD},
      {"PERIOD_ADD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_PERIOD_ADD},
      {"PERIOD_DIFF", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_PERIOD_DIFF},
    {"PERSIST", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_PERSIST},
    {"PERSIST_ONLY", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_PERSIST_ONLY},
          {"PERSIST_RO_VARIABLES_ADMIN", 0, 0, TOKEN_KEYWORD_PERSIST_RO_VARIABLES_ADMIN},
      {"PI", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_PI},
      {"PIE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_PIE},
        {"PIPE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_PIPE},
      {"PLAN", 0, 0, TOKEN_KEYWORD_PLAN},
      {"PLUGINS", 0, 0, TOKEN_KEYWORD_PLUGINS},
        {"PLUGIN_DIR", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_PLUGIN_DIR},
      {"POINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POINT},
      {"POINTFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POINTFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"POINTFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POINTFROMWKB}, /* deprecated in MySQL 5.7.6 */
      {"POINTN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POINTN}, /* deprecated in MySQL 5.7.6 */
      {"POLYFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POLYFROMTEXT},
      {"POLYFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POLYFROMWKB}, /* deprecated in MySQL 5.7 */
      {"POLYGON", 0, 0, TOKEN_KEYWORD_POLYGON},
      {"POLYGONFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POLYGONFROMTEXT}, /* deprecated in MySQL 5.7.6 */
      {"POLYGONFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POLYGONFROMWKB}, /* deprecated in MySQL 5.7.6 */
        {"PORT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_PORT},
      {"POSITION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POSITION},
      {"POW", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POW},
      {"POWER", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_POWER},
      {"PRAGMA", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_PRAGMA},
      {"PRECEDES", FLAG_VERSION_MYSQL_5_7 | FLAG_VERSION_MARIADB_10_2_3, 0, TOKEN_KEYWORD_PRECEDES},
      {"PRECISION", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_PRECISION},
      {"PREPARE", 0, 0, TOKEN_KEYWORD_PREPARE},
      {"PRETTY", 0, 0, TOKEN_KEYWORD_PRETTY}, /* unused */
      {"PRIMARY", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_PRIMARY},
      {"PRINT", 0, 0, TOKEN_KEYWORD_PRINT}, /* ocelotgui keyword */
      {"PRINTF", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_PRINTF},
        {"PRINT_DEFAULTS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_PRINT_DEFAULTS},
      {"PROCEDURE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_PROCEDURE},
      {"PROCESS", 0, 0, TOKEN_KEYWORD_PROCESS},
      {"PROMPT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_PROMPT}, /* ocelotgui keyword */
        {"PROTOCOL", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_PROTOCOL},
      {"PROXY", 0, 0, TOKEN_KEYWORD_PROXY},
      {"PURGE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_PURGE},
      {"QUALIFY", FLAG_VERSION_MYSQL_8_4, 0, TOKEN_KEYWORD_QUALIFY},
      {"QUARTER", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_QUARTER},
      {"QUERY", 0, 0, TOKEN_KEYWORD_QUERY},
        {"QUICK", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_QUICK},
      {"QUIT", 0, 0, TOKEN_KEYWORD_QUIT}, /* ocelotgui keyword */
      {"QUOTE", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_QUOTE},
      {"RADIANS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_RADIANS},
      {"RAISE", FLAG_VERSION_PLSQL, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_RAISE},
      {"RAND", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_RAND},
      {"RANDOM", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_RANDOM},
      {"RANDOMBLOB", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_RANDOMBLOB},
      {"RANDOM_BYTES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_RANDOM_BYTES},
      {"RANGE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_RANGE},
      {"RANK", FLAG_VERSION_MYSQL_8_0, FLAG_VERSION_MYSQL_8_0 | FLAG_VERSION_TARANTOOL | FLAG_VERSION_MARIADB_10_2_2, TOKEN_KEYWORD_RANK},
      {"RAW", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_RAW},
      {"READ", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_READ},
      {"READS", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_READS},
    {"READ_DEFAULT_FILE", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_READ_DEFAULT_FILE},
    {"READ_DEFAULT_GROUP", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_READ_DEFAULT_GROUP},
      {"READ_ONLY", 0, 0, TOKEN_KEYWORD_READ_ONLY},
    {"READ_TIMEOUT", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_READ_TIMEOUT},
      {"READ_WRITE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_READ_WRITE},
      {"REAL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_REAL},
      {"REBUILD", 0, 0, TOKEN_KEYWORD_REBUILD},
        {"RECONNECT", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_RECONNECT},
      {"RECURSIVE", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_2_2|FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_RECURSIVE},
    {"REDOFILE", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_REDOFILE},
      {"REDUNDANT", 0, 0, TOKEN_KEYWORD_REDUNDANT},
      {"REFERENCES", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_REFERENCES},
      {"REFRESH", 0, 0, TOKEN_KEYWORD_REFRESH},
      {"REGEXP", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_REGEXP},
      {"REGEXP_INSTR", 0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_REGEXP_INSTR},
      {"REGEXP_REPLACE", 0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_REGEXP_REPLACE},
      {"REGEXP_SUBSTR", 0, FLAG_VERSION_MARIADB_10_0, TOKEN_KEYWORD_REGEXP_SUBSTR},
      {"REHASH", 0, 0, TOKEN_KEYWORD_REHASH}, /* ocelotgui keyword */
      {"RELEASE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_RELEASE},
      {"RELEASE_ALL_LOCKS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_RELEASE_ALL_LOCKS},
      {"RELEASE_LOCK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_RELEASE_LOCK},
      {"RELOAD", 0, 0, TOKEN_KEYWORD_RELOAD},
      {"RENAME", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_RENAME},
      {"REORGANIZE", 0, 0, TOKEN_KEYWORD_REORGANIZE},
      {"REPAIR", 0, 0, TOKEN_KEYWORD_REPAIR},
      {"REPEAT", FLAG_VERSION_ALL | FLAG_VERSION_LUA, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_REPEAT},
      {"REPLACE", FLAG_VERSION_ALL, FLAG_VERSION_ALL, TOKEN_KEYWORD_REPLACE},
      {"REPLICA", 0, 0, TOKEN_KEYWORD_REPLICA},
      {"REPLICAS", 0, 0, TOKEN_KEYWORD_REPLICAS},
      {"REPLICATION", 0, 0, TOKEN_KEYWORD_REPLICATION},
          {"REPLICATION_SLAVE_ADMIN", 0, 0, TOKEN_KEYWORD_REPLICATION_SLAVE_ADMIN},
        {"REPORT_DATA_TRUNCATION", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_REPORT_DATA_TRUNCATION},
      {"REQUIRE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_REQUIRE},
      {"RESET", 0, 0, TOKEN_KEYWORD_RESET},
      {"RESETCONNECTION", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_RESETCONNECTION},
      {"RESIGNAL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_RESIGNAL},
          {"RESOURCE_GROUP_ADMIN", 0, 0, TOKEN_KEYWORD_RESOURCE_GROUP_ADMIN},
          {"RESOURCE_GROUP_USER", 0, 0, TOKEN_KEYWORD_RESOURCE_GROUP_USER},
      {"RESTRICT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_RESTRICT},
      {"RETURN", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_RETURN},
      {"RETURNS", 0, 0, TOKEN_KEYWORD_RETURNS},
      {"REVERSE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_REVERSE},
      {"REVOKE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_REVOKE},
      {"RIGHT", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_RIGHT},
      {"RLIKE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_RLIKE},
      {"ROLE", 0, 0, TOKEN_KEYWORD_ROLE},
          {"ROLE_ADMIN", 0, 0, TOKEN_KEYWORD_ROLE_ADMIN},
      {"ROLLBACK", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_ROLLBACK},
      {"ROUND", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_ROUND},
      {"ROW", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_ROW},
      {"ROWNUM", 0, FLAG_VERSION_MARIADB_10_6, TOKEN_KEYWORD_ROWNUM},
      {"ROWS", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_ROWS},
      {"ROWTYPE", FLAG_VERSION_PLSQL, 0, TOKEN_KEYWORD_ROWTYPE},
      {"ROW_COUNT", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_ROW_COUNT},
      {"ROW_NUMBER", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_TARANTOOL, FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_MARIADB_10_2_2, TOKEN_KEYWORD_ROW_NUMBER},
      {"RPAD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_RPAD},
      {"RTRIM", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_RTRIM},
        {"SAFE_UPDATES", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SAFE_UPDATES},
      {"SAVEPOINT", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_SAVEPOINT},
      {"SCALAR", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_SCALAR},
      {"SCHEMA", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SCHEMA},
      {"SCHEMAS", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SCHEMAS},
      {"SECOND", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SECOND},
      {"SECOND_MICROSECOND", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SECOND_MICROSECOND},
        {"SECURE_AUTH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SECURE_AUTH},
      {"SECURITY", 0, 0, TOKEN_KEYWORD_SECURITY},
      {"SEC_TO_TIME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SEC_TO_TIME},
      {"SELECT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_SELECT},
        {"SELECT_LIMIT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SELECT_LIMIT},
      {"SEMICOLON", 0, 0, TOKEN_KEYWORD_SEMICOLON}, /* for format rule */
      {"SENSITIVE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_SENSITIVE},
      {"SEPARATOR", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SEPARATOR},
      {"SEQSCAN", FLAG_VERSION_TARANTOOL_2_11, 0, TOKEN_KEYWORD_SEQSCAN},
      {"SEQUENCE", 0, 0, TOKEN_KEYWORD_SEQUENCE},
      {"SERIAL", 0, 0, TOKEN_KEYWORD_SERIAL},
      {"SERVER", 0, 0, TOKEN_KEYWORD_SERVER},
        {"SERVER_PUBLIC_KEY", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SERVER_PUBLIC_KEY},
      {"SESSION", FLAG_VERSION_TARANTOOL_2_4, 0, TOKEN_KEYWORD_SESSION},
      {"SESSION_USER", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SESSION_USER},
      {"SET", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_SET},
      {"SETVAL", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_SETVAL},
          {"SET_USER_ID", 0, 0, TOKEN_KEYWORD_SET_USER_ID},
      {"SFORMAT", 0, FLAG_VERSION_MARIADB_10_7, TOKEN_KEYWORD_SFORMAT},
      {"SHA", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SHA},
      {"SHA1", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SHA1},
      {"SHA2", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SHA2},
      {"SHARED", 0, 0, TOKEN_KEYWORD_SHARED},
        {"SHARED_MEMORY_BASE_NAME", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SHARED_MEMORY_BASE_NAME},
      {"SHOW", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SHOW},
        {"SHOW_WARNINGS", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SHOW_WARNINGS},
      {"SHUTDOWN", 0, 0, TOKEN_KEYWORD_SHUTDOWN},
        {"SIGINT_IGNORE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SIGINT_IGNORE},
      {"SIGN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SIGN},
      {"SIGNAL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_SIGNAL},
      {"SIGNED", 0, 0, TOKEN_KEYWORD_SIGNED},
        {"SILENT", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_SILENT},
      {"SIMPLE", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_SIMPLE},
      {"SIN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SIN},
      {"SLAVE", 0, 0, TOKEN_KEYWORD_SLAVE},
      {"SLEEP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SLEEP},
      {"SLOW", 0, 0, TOKEN_KEYWORD_SLOW},
      {"SMALLINT", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_SMALLINT},
        {"SOCKET", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SOCKET},
      {"SONAME", 0, 0, TOKEN_KEYWORD_SONAME},
      {"SOUNDEX", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SOUNDEX},
      {"SOURCE", 0, 0, TOKEN_KEYWORD_SOURCE}, /* ocelotgui keyword */
      {"SPACE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SPACE},
      {"SPATIAL", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SPATIAL},
      {"SPECIFIC", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_SPECIFIC},
      {"SQL", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_SQL},
      {"SQLEXCEPTION", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SQLEXCEPTION},
      {"SQLSTATE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SQLSTATE},
      {"SQLWARNING", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SQLWARNING},
      {"SQL_BIG_RESULT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SQL_BIG_RESULT},
      {"SQL_CALC_FOUND_ROWS", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SQL_CALC_FOUND_ROWS},
      {"SQL_COMPOUND_SELECT_LIMIT", 0, 0, TOKEN_KEYWORD_SQL_COMPOUND_SELECT_LIMIT},
      {"SQL_DEFAULT_ENGINE", 0, 0, TOKEN_KEYWORD_SQL_DEFAULT_ENGINE},
      {"SQL_SMALL_RESULT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_SQL_SMALL_RESULT},
      {"SQRT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SQRT},
      {"SRID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SRID},
      {"SSL", FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL},
    {"SSL_CA", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_CA},
    {"SSL_CAPATH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_CAPATH},
    {"SSL_CERT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_CERT},
    {"SSL_CIPHER", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_CIPHER},
    {"SSL_CRL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_CRL},
    {"SSL_CRLPATH", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_CRLPATH},
    {"SSL_KEY", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_KEY},
    {"SSL_MODE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SSL_MODE},
    {"SSL_VERIFY", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_SSL_VERIFY},
    {"SSL_VERIFY_SERVER_CERT", FLAG_VERSION_SET_OPTION, 0, TOKEN_KEYWORD_SSL_VERIFY_SERVER_CERT},
          {"START", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_START},
      {"STARTING", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_STARTING},
      {"STARTPOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_STARTPOINT}, /* deprecated in MySQL 5.7.6 */
      {"STATEMENT", 0, 0, TOKEN_KEYWORD_STATEMENT},
      {"STATS", 0, 0, TOKEN_KEYWORD_STATS},
      {"STATUS", 0, 0, TOKEN_KEYWORD_STATUS}, /* ocelotgui keyword */
      {"STD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_STD},
      {"STDDEV", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_STDDEV},
      {"STDDEV_POP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_STDDEV_POP},
      {"STDDEV_SAMP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_STDDEV_SAMP},
      {"STDOUT", 0, 0, TOKEN_KEYWORD_STDOUT},
      {"STOP", 0, 0, TOKEN_KEYWORD_STOP},
      {"STORED", FLAG_VERSION_MYSQL_5_7, 0, TOKEN_KEYWORD_STORED},
      {"STRAIGHT_JOIN", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_STRAIGHT_JOIN},
      {"STRCMP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_STRCMP},
      {"STRFTIME", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_STRFTIME},
      {"STRING", FLAG_VERSION_TARANTOOL_2_2, 0, TOKEN_KEYWORD_STRING},
      {"STRING_TO_VECTOR", 0, FLAG_VERSION_MYSQL_9_0, TOKEN_KEYWORD_STRING_TO_VECTOR},
      {"STR_TO_DATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_STR_TO_DATE},
      {"ST_AREA", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_AREA},
      {"ST_ASBINARY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ASBINARY},
      {"ST_ASGEOJSON", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ASGEOJSON},
      {"ST_ASTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ASTEXT},
      {"ST_ASWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ASWKB},
      {"ST_ASWKT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ASWKT},
      {"ST_BOUNDARY", 0, FLAG_VERSION_MARIADB_10_1, TOKEN_KEYWORD_ST_BOUNDARY},
      {"ST_BUFFER", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_BUFFER},
      {"ST_BUFFER_STRATEGY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_BUFFER_STRATEGY},
      {"ST_CENTROID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_CENTROID},
      {"ST_CONTAINS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_CONTAINS},
      {"ST_CONVEXHULL", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_CONVEXHULL},
      {"ST_CROSSES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_CROSSES},
      {"ST_DIFFERENCE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_DIFFERENCE},
      {"ST_DIMENSION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_DIMENSION},
      {"ST_DISJOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_DISJOINT},
      {"ST_DISTANCE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_DISTANCE},
      {"ST_DISTANCE_SPHERE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_DISTANCE_SPHERE},
      {"ST_ENDPOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ENDPOINT},
      {"ST_ENVELOPE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ENVELOPE},
      {"ST_EQUALS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_EQUALS},
      {"ST_EXTERIORRING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_EXTERIORRING},
      {"ST_GEOHASH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOHASH},
      {"ST_GEOMCOLLFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMCOLLFROMTEXT},
      {"ST_GEOMCOLLFROMTXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMCOLLFROMTXT},
      {"ST_GEOMCOLLFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMCOLLFROMWKB},
      {"ST_GEOMETRYCOLLECTIONFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMETRYCOLLECTIONFROMTEXT},
      {"ST_GEOMETRYCOLLECTIONFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMETRYCOLLECTIONFROMWKB},
      {"ST_GEOMETRYFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMETRYFROMTEXT},
      {"ST_GEOMETRYFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMETRYFROMWKB},
      {"ST_GEOMETRYN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMETRYN},
      {"ST_GEOMETRYTYPE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMETRYTYPE},
      {"ST_GEOMFROMGEOJSON", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMFROMGEOJSON},
      {"ST_GEOMFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMFROMTEXT},
      {"ST_GEOMFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_GEOMFROMWKB},
      {"ST_INTERIORRINGN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_INTERIORRINGN},
      {"ST_INTERSECTION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_INTERSECTION},
      {"ST_INTERSECTS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_INTERSECTS},
      {"ST_ISCLOSED", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ISCLOSED},
      {"ST_ISEMPTY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ISEMPTY},
      {"ST_ISRING", 0, FLAG_VERSION_MARIADB_10_1, TOKEN_KEYWORD_ST_ISRING},
      {"ST_ISSIMPLE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ISSIMPLE},
      {"ST_ISVALID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_ISVALID},
      {"ST_LATFROMGEOHASH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_LATFROMGEOHASH},
      {"ST_LENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_LENGTH},
      {"ST_LINEFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_LINEFROMTEXT},
      {"ST_LINEFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_LINEFROMWKB},
      {"ST_LINESTRINGFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_LINESTRINGFROMTEXT},
      {"ST_LINESTRINGFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_LINESTRINGFROMWKB},
      {"ST_LONGFROMGEOHASH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_LONGFROMGEOHASH},
      {"ST_MAKEENVELOPE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MAKEENVELOPE},
      {"ST_MLINEFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MLINEFROMTEXT},
      {"ST_MLINEFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MLINEFROMWKB},
      {"ST_MPOINTFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MPOINTFROMTEXT},
      {"ST_MPOINTFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MPOINTFROMWKB},
      {"ST_MPOLYFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MPOLYFROMTEXT},
      {"ST_MPOLYFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MPOLYFROMWKB},
      {"ST_MULTILINESTRINGFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MULTILINESTRINGFROMTEXT},
      {"ST_MULTILINESTRINGFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MULTILINESTRINGFROMWKB},
      {"ST_MULTIPOINTFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MULTIPOINTFROMTEXT},
      {"ST_MULTIPOINTFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MULTIPOINTFROMWKB},
      {"ST_MULTIPOLYGONFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MULTIPOLYGONFROMTEXT},
      {"ST_MULTIPOLYGONFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_MULTIPOLYGONFROMWKB},
      {"ST_NUMGEOMETRIES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_NUMGEOMETRIES},
      {"ST_NUMINTERIORRING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_NUMINTERIORRING},
      {"ST_NUMINTERIORRINGS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_NUMINTERIORRINGS},
      {"ST_NUMPOINTS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_NUMPOINTS},
      {"ST_OVERLAPS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_OVERLAPS},
      {"ST_POINTFROMGEOHASH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POINTFROMGEOHASH},
      {"ST_POINTFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POINTFROMTEXT},
      {"ST_POINTFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POINTFROMWKB},
      {"ST_POINTN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POINTN},
      {"ST_POINTONSURFACE", 0, FLAG_VERSION_MARIADB_10_1, TOKEN_KEYWORD_ST_POINTONSURFACE},
      {"ST_POLYFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POLYFROMTEXT},
      {"ST_POLYFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POLYFROMWKB},
      {"ST_POLYGONFROMTEXT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POLYGONFROMTEXT},
      {"ST_POLYGONFROMWKB", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_POLYGONFROMWKB},
      {"ST_RELATE", 0, FLAG_VERSION_MARIADB_10_1, TOKEN_KEYWORD_ST_RELATE},
      {"ST_SIMPLIFY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_SIMPLIFY},
      {"ST_SRID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_SRID},
      {"ST_STARTPOINT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_STARTPOINT},
      {"ST_SYMDIFFERENCE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_SYMDIFFERENCE},
      {"ST_TOUCHES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_TOUCHES},
      {"ST_UNION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_UNION},
      {"ST_VALIDATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_VALIDATE},
      {"ST_WITHIN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_WITHIN},
      {"ST_X", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_X},
      {"ST_Y", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_ST_Y},
      {"SUBDATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SUBDATE},
      {"SUBSTR", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_SUBSTR},
      {"SUBSTRING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SUBSTRING},
      {"SUBSTRING_INDEX", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SUBSTRING_INDEX},
      {"SUBTIME", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SUBTIME},
      {"SUM", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_SUM},
      {"SUPER", 0, 0, TOKEN_KEYWORD_SUPER},
      {"SYSDATE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SYSDATE},
        {"SYSLOG", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_SYSLOG},
      {"SYSTEM", FLAG_VERSION_MYSQL_8_0|FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_SYSTEM}, /* ocelotgui keyword */
      {"SYSTEM_TIME", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_SYSTEM_TIME},
      {"SYSTEM_USER", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_SYSTEM_USER},
          {"SYSTEM_VARIABLES_ADMIN", 0, 0, TOKEN_KEYWORD_SYSTEM_VARIABLES_ADMIN},
      {"SYS_GUID", 0, FLAG_VERSION_PLSQL, TOKEN_KEYWORD_SYS_GUID},
      {"TAB", 0, 0, TOKEN_KEYWORD_TAB}, /* for format rule */
      {"TABLE", FLAG_VERSION_ALL | FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_TABLE},
      {"TABLES", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_TABLES},
      {"TABLESAMPLE", FLAG_VERSION_MYSQL_8_4, 0, TOKEN_KEYWORD_TABLESAMPLE},
      {"TABLESPACE", 0, 0, TOKEN_KEYWORD_TABLESPACE},
      {"TABLE_INFO", 0, 0, TOKEN_KEYWORD_TABLE_INFO},
      {"TAN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TAN},
      {"TEE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_TEE}, /* ocelotgui keyword */
      {"TEMP", 0, 0, TOKEN_KEYWORD_TEMP},
      {"TEMPORARY", 0, 0, TOKEN_KEYWORD_TEMPORARY},
      {"TERMINATED", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_TERMINATED},
      {"TEXT", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_TEXT},
      {"THEN", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_THEN},
      {"TIES", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_TIES},
      {"TIME", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_TIME},
      {"TIMEDIFF", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TIMEDIFF},
      {"TIMESTAMP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TIMESTAMP},
      {"TIMESTAMPADD", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TIMESTAMPADD},
      {"TIMESTAMPDIFF", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TIMESTAMPDIFF},
      {"TIME_FORMAT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TIME_FORMAT},
      {"TIME_TO_SEC", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TIME_TO_SEC},
      {"TINYBLOB", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_TINYBLOB},
      {"TINYINT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_TINYINT},
      {"TINYTEXT", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_TINYTEXT},
      {"TO", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_TO},
      {"TOUCHES", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TOUCHES}, /* deprecated in MySQL 5.7.6 */
      {"TO_BASE64", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TO_BASE64},
      {"TO_CHAR", 0, FLAG_VERSION_PLSQL, TOKEN_KEYWORD_TO_CHAR},
      {"TO_DAYS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TO_DAYS},
      {"TO_SECONDS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TO_SECONDS},
      {"TRAILING", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_TRAILING},
      {"TRANSACTION", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_TRANSACTION},
      {"TRIGGER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_TRIGGER},
      {"TRIM", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_TRIM},
      {"TRUE", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_TRUE},
      {"TRUNCATE", FLAG_VERSION_TARANTOOL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_TRUNCATE},
      {"TYPE", 0, 0, TOKEN_KEYWORD_TYPE},
      {"TYPEOF", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_TYPEOF},
      {"UCASE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UCASE},
      {"UNBOUNDED", 0, 0, TOKEN_KEYWORD_UNBOUNDED},
        {"UNBUFFERED", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_UNBUFFERED},
      {"UNCOMPRESS", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UNCOMPRESS},
      {"UNCOMPRESSED_LENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UNCOMPRESSED_LENGTH},
      {"UNDO", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_UNDO},
      {"UNHEX", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UNHEX},
      {"UNICODE", 0, FLAG_VERSION_TARANTOOL, TOKEN_KEYWORD_UNICODE},
      {"UNINSTALL", 0, 0, TOKEN_KEYWORD_UNINSTALL},
      {"UNION", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_UNION},
      {"UNIQUE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_UNIQUE},
      {"UNIX_TIMESTAMP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UNIX_TIMESTAMP},
      {"UNKNOWN", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_UNKNOWN},
      {"UNLOCK", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_UNLOCK},
      {"UNSIGNED", FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_TARANTOOL_2_2, 0, TOKEN_KEYWORD_UNSIGNED},
      {"UNTIL", FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_UNTIL},
      {"UPDATE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_UPDATE},
      {"UPDATEXML", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UPDATEXML},
      {"UPPER", 0, FLAG_VERSION_ALL, TOKEN_KEYWORD_UPPER},
      {"USAGE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_USAGE},
      {"USE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_USE}, /* ocelotgui keyword, also reserved word */
      {"USER", FLAG_VERSION_TARANTOOL | FLAG_VERSION_OPTION, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_USER},
        {"USE_RESULT", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_USE_RESULT},
      {"USING", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_USING},
      {"UTC_DATE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UTC_DATE},
      {"UTC_TIME", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UTC_TIME},
      {"UTC_TIMESTAMP", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UTC_TIMESTAMP},
      {"UUID", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UUID},
      {"UUID_SHORT", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_UUID_SHORT},
      {"UUID_V4", 0, FLAG_VERSION_MARIADB_11_7, TOKEN_KEYWORD_UUID_V4},
      {"UUID_V7", 0, FLAG_VERSION_MARIADB_11_7, TOKEN_KEYWORD_UUID_V7},
      {"VACUUM", 0, 0, TOKEN_KEYWORD_VACUUM},
      {"VALIDATE_PASSWORD_STRENGTH", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_VALIDATE_PASSWORD_STRENGTH},
      {"VALIDATION", 0, 0, TOKEN_KEYWORD_VALIDATION},
      {"VALUE", 0, 0, TOKEN_KEYWORD_VALUE},
      {"VALUES", FLAG_VERSION_ALL, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_VALUES},
      {"VARBINARY", FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_TARANTOOL_2_2, 0, TOKEN_KEYWORD_VARBINARY},
      {"VARCHAR", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_VARCHAR},
      {"VARCHAR2", 0, 0, TOKEN_KEYWORD_VARCHAR2},
      {"VARCHARACTER", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_VARCHARACTER},
      {"VARIANCE", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_VARIANCE},
      {"VARYING", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_VARYING},
      {"VAR_POP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_VAR_POP},
      {"VAR_SAMP", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_VAR_SAMP},
      {"VECTOR", FLAG_VERSION_MARIADB_11_7 | FLAG_VERSION_MYSQL_9_0, 0, TOKEN_KEYWORD_VECTOR},
      {"VECTOR_DIM", 0, FLAG_VERSION_MYSQL_9_0, TOKEN_KEYWORD_VECTOR_DIM},
      {"VECTOR_TO_STRING", 0, FLAG_VERSION_MYSQL_9_0, TOKEN_KEYWORD_VECTOR_TO_STRING},
      {"VEC_DISTANCE", 0, FLAG_VERSION_MARIADB_11_8, TOKEN_KEYWORD_VEC_DISTANCE},
        {"VERBOSE", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_VERBOSE},
      {"VERSION", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL | FLAG_VERSION_OPTION, TOKEN_KEYWORD_VERSION},
      {"VERSIONING", 0, FLAG_VERSION_MARIADB_10_3, TOKEN_KEYWORD_VERSIONING},
          {"VERSION_TOKEN_ADMIN", 0, 0, TOKEN_KEYWORD_VERSION_TOKEN_ADMIN},
        {"VERTICAL", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_VERTICAL},
      {"VIEW", FLAG_VERSION_TARANTOOL, 0, TOKEN_KEYWORD_VIEW},
      {"VIRTUAL", FLAG_VERSION_MYSQL_5_7, 0, TOKEN_KEYWORD_VIRTUAL},
        {"WAIT", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_WAIT},
      {"WAIT_FOR_EXECUTED_GTID_SET", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_WAIT_FOR_EXECUTED_GTID_SET},
      {"WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", 0, FLAG_VERSION_MYSQL_ALL, TOKEN_KEYWORD_WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS},
      {"WARNINGS", 0, 0, TOKEN_KEYWORD_WARNINGS}, /* ocelotgui keyword */
      {"WEEK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_WEEK},
      {"WEEKDAY", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_WEEKDAY},
      {"WEEKOFYEAR", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_WEEKOFYEAR},
      {"WEIGHT_STRING", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_WEIGHT_STRING},
      {"WHEN", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_WHEN},
      {"WHENEVER", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_WHENEVER},
      {"WHERE", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_WHERE},
      {"WHILE", FLAG_VERSION_ALL | FLAG_VERSION_LUA, 0, TOKEN_KEYWORD_WHILE},
    {"WINDOW", FLAG_VERSION_MYSQL_8_0, 0, TOKEN_KEYWORD_WINDOW},
      {"WITH", FLAG_VERSION_ALL, 0, TOKEN_KEYWORD_WITH},
      {"WITHIN", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_WITHIN}, /* deprecated in MySQL 5.7.6 */
      {"WITHOUT", 0, 0, TOKEN_KEYWORD_WITHOUT},
      {"WRITE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_WRITE},
        {"WRITE_TIMEOUT", FLAG_VERSION_CONNECT_OPTION, 0, TOKEN_KEYWORD_WRITE_TIMEOUT},
      {"X", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_X}, /* deprecated in MySQL 5.7.6 */
      {"XA", 0, 0, TOKEN_KEYWORD_XA},
          {"XA_RECOVER_ADMIN", 0, 0, TOKEN_KEYWORD_XA_RECOVER_ADMIN},
        {"XML", FLAG_VERSION_OPTION, 0, TOKEN_KEYWORD_XML},
      {"XOR", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_XOR},
      {"Y", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_Y}, /* deprecated in MySQL 5.7.6 */
      {"YEAR", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_YEAR},
      {"YEARWEEK", 0, FLAG_VERSION_MYSQL_OR_MARIADB_ALL, TOKEN_KEYWORD_YEARWEEK},
      {"YEAR_MONTH", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_YEAR_MONTH},
      {"ZEROFILL", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD_ZEROFILL},
      {"_ARMSCII8", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__ARMSCII8},
      {"_ASCII", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__ASCII},
      {"_BIG5", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__BIG5},
      {"_BINARY", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__BINARY},
      {"_CP1250", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP1250},
      {"_CP1251", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP1251},
      {"_CP1256", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP1256},
      {"_CP1257", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP1257},
      {"_CP850", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP850},
      {"_CP852", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP852},
      {"_CP866", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP866},
      {"_CP932", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__CP932},
      {"_DEC8", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__DEC8},
      {"_EUCJPMS", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__EUCJPMS},
      {"_EUCKR", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__EUCKR},
      {"_FILENAME", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__FILENAME},
      {"_GB18030", FLAG_VERSION_MYSQL_5_7, 0, TOKEN_KEYWORD__GB18030},
      {"_GB2312", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__GB2312},
      {"_GBK", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__GBK},
      {"_GEOSTD8", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__GEOSTD8},
      {"_GREEK", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__GREEK},
      {"_HEBREW", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__HEBREW},
      {"_HP8", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__HP8},
      {"_KEYBCS2", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__KEYBCS2},
      {"_KOI8R", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__KOI8R},
      {"_KOI8U", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__KOI8U},
      {"_LATIN1", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__LATIN1},
      {"_LATIN2", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__LATIN2},
      {"_LATIN5", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__LATIN5},
      {"_LATIN7", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__LATIN7},
      {"_MACCE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__MACCE},
      {"_MACROMAN", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__MACROMAN},
      {"_SJIS", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__SJIS},
      {"_SWE7", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__SWE7},
      {"_TIS620", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__TIS620},
      {"_UCS2", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__UCS2},
      {"_UJIS", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__UJIS},
      {"_UTF16", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__UTF16},
      {"_UTF16LE", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__UTF16LE},
      {"_UTF32", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__UTF32},
      {"_UTF8", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__UTF8},
      {"_UTF8MB4", FLAG_VERSION_MYSQL_OR_MARIADB_ALL, 0, TOKEN_KEYWORD__UTF8MB4}
    };

/* For talk about fontweightsvalues see "Font comments" */

struct fontweights {
   char  chars[12];
   char  alternate_chars[12];
   unsigned int qt_number;
   unsigned int css_number;
};
static const struct fontweights fontweightsvalues[]=
  {
    {"thin", "", 0, 100}, /* QFont::Thin */
    {"extralight", "", 12, 200}, /* QFont::ExtraLight */ /* though an Internet site says extralight is 250 */
    /* Ubuntu Light is 18 but an Internet site says the css value is 200 */
    {"light", "", 25, 300}, /* QFont::Light */
    /* "semilight" would be between light and book says an Internet site */
    /* URW Gothic Book is 45 and an Internet site says book=350 */
    {"normal", "regular", 50, 400}, /* QFont::Normal */
    {"medium", "dark", 57, 500}, /* QFont::Medium */
    {"demibold", "demi", 63, 600}, /* QFont::DemiBold */ /* todo: should we allow for aka semibold? */
    {"bold", "", 75, 700}, /* QFont::Bold */
    {"extrabold", "ultrabold", 81, 800}, /* QFont::ExtraBold */
    {"black", "heavy", 87, 900},   /* QFont::Black */ /* alternate_chars == "heavy" might be wrong */
    {"extrablack", "ultrablack", 93, 950}, /* no enum but documented for Qt 6.x so I guessed 93 */
  };
#define FONTWEIGHTSVALUES_SIZE 10 /* # of entries in fontweightsvalues */

#if (TARANTOOL_DATETIMES != 0)
/*
  timezone_strings and timezone_ids are lists that we need if datetime tzindex != 0.
  Their values correspond to timezones.h but we ignore ZONE_ABBREV...TZ_AMBIGUOUS and ZONE_ALIAS.
  The lists must be in the same order, e.g. timezones.h says the id of Europe/Moscow is 947 and Europe/Moscow is the
  first thing in timezone_strongs therefore timezone_ids[0] must be 947 and have sizeof("Europe/Moscow")-1.
  We search timezone_ids sequentially therefore we put at the start of the lists the timezones that we think
  will be more common -- if it's 947 Europe/Moscow we find it immediately, but if it's Africa/Abidjan we scan
  many index_ids before finding it. Our focus is saving space, not saving time, because we think hardly anyone
  will have Tarantool datetimes with index_ids.
  Increase MAX_TIMEZONE_NAME_LENGTH if adding a new string with length >= 32.
  If you think a different order is desirable it's okay to re-order both lists.
*/
#define MAX_TIMEZONE_NAME_LENGTH 32
static const char timezone_strings[]="\
Europe/Moscow\
Europe/Kaliningrad\
Europe/Samara\
Europe/Saratov\
Europe/Simferopol\
Europe/Ulyanovsk\
Europe/Uzhgorod\
Europe/Volgograd\
Asia/Barnaul\
Asia/Irkutsk\
Asia/Kamchatka\
Asia/Krasnoyarsk\
Asia/Magadan\
Asia/Novokuznetsk\
Asia/Novosibirsk\
Asia/Omsk\
Asia/Oral\
Asia/Sakhalin\
Asia/Tomsk\
Asia/Vladivostok\
Asia/Yakutsk\
Asia/Yekaterinburg\
Europe/Minsk\
Europe/Kiev\
Asia/Bangkok\
Asia/Jakarta\
Asia/Kuala_Lumpur\
Asia/Singapore\
America/Argentina/Buenos_Aires\
America/Chicago\
America/Denver\
America/Detroit\
America/Edmonton\
America/Halifax\
America/Los_Angeles\
America/Mexico_City\
America/Moncton\
America/Phoenix\
America/New_York\
America/Regina\
America/Sao_Paulo\
America/Thunder_Bay\
America/Toronto\
America/Vancouver\
America/Winnipeg\
Asia/Seoul\
Asia/Shanghai\
Asia/Tokyo\
Australia/Sydney\
Europe/Amsterdam\
Europe/Athens\
Europe/Belgrade\
Europe/Berlin\
Europe/Brussels\
Europe/Bucharest\
Europe/Lisbon\
Europe/London\
Europe/Madrid\
Europe/Paris\
Europe/Prague\
Europe/Riga\
Europe/Rome\
Europe/Vienna\
Europe/Warsaw\
A\
B\
C\
D\
E\
F\
G\
H\
I\
K\
L\
M\
N\
O\
P\
Q\
R\
S\
T\
U\
V\
W\
X\
Y\
Z\
GT\
KT\
ST\
UT\
WT\
AFT\
AoE\
ART\
AZT\
BNT\
BOT\
BRT\
BTT\
CAT\
CCT\
CET\
CIT\
CKT\
CLT\
COT\
CVT\
CXT\
EAT\
EET\
EGT\
FET\
FJT\
FKT\
FNT\
GET\
GFT\
GMT\
GYT\
HAA\
HAC\
HAE\
HAP\
HAR\
HAT\
HDT\
HKT\
HLV\
HNA\
HNC\
HNE\
HNP\
HNR\
HNT\
HST\
ICT\
IOT\
JST\
KGT\
KIT\
KST\
MCK\
MDT\
MEZ\
MHT\
MMT\
MSD\
MSK\
MUT\
MVT\
MYT\
NCT\
NDT\
NFT\
NPT\
NRT\
NST\
NUT\
OEZ\
PDT\
PET\
PGT\
PHT\
PKT\
PWT\
RET\
SBT\
SCT\
SGT\
SRT\
TFT\
TJT\
TKT\
TLT\
TMT\
TOT\
TRT\
TVT\
UTC\
UYT\
UZT\
VET\
VUT\
WDT\
WET\
WEZ\
WFT\
WGT\
WIB\
WIT\
ACDT\
ACST\
AEDT\
AEST\
AKDT\
AKST\
ALMT\
AMDT\
ANAT\
AQTT\
AWDT\
AWST\
AZOT\
AZST\
BDST\
BRST\
CAST\
CEDT\
CEST\
CHOT\
ChST\
CHUT\
CIST\
CLDT\
CLST\
DAVT\
DDUT\
EADT\
EAST\
ECST\
EDST\
EEDT\
EEST\
EGST\
FJDT\
FJST\
FKDT\
GALT\
GAMT\
GILT\
HADT\
HAST\
HOVT\
IRDT\
IRKT\
KOST\
KRAT\
KUYT\
LHDT\
LHST\
LINT\
MAGT\
MART\
MAWT\
MDST\
MESZ\
NFDT\
NOVT\
NZDT\
NZST\
OESZ\
OMST\
ORAT\
PDST\
PETT\
PHOT\
PMDT\
PMST\
PONT\
QYZT\
ROTT\
SAKT\
SAMT\
SAST\
SRET\
SYOT\
TAHT\
TOST\
ULAT\
UYST\
VLAT\
VOST\
WAKT\
WAST\
WEDT\
WEST\
WESZ\
WGST\
WITA\
YAKT\
YAPT\
YEKT\
ACWST\
ANAST\
AZODT\
CHADT\
CHAST\
CHODT\
CHOST\
CIDST\
EASST\
EFATE\
HOVDT\
HOVST\
IRKST\
KRAST\
MAGST\
NACDT\
NACST\
NAEDT\
NAEST\
NAMDT\
NAMST\
NAPDT\
NAPST\
NOVST\
OMSST\
PETST\
SAMST\
ULAST\
VLAST\
WARST\
YAKST\
YEKST\
CHODST\
HOVDST\
Africa/Abidjan\
Africa/Algiers\
Africa/Bissau\
Africa/Cairo\
Africa/Casablanca\
Africa/Ceuta\
Africa/El_Aaiun\
Africa/Johannesburg\
Africa/Juba\
Africa/Khartoum\
Africa/Lagos\
Africa/Maputo\
Africa/Monrovia\
Africa/Nairobi\
Africa/Ndjamena\
Africa/Sao_Tome\
Africa/Tripoli\
Africa/Tunis\
Africa/Windhoek\
America/Adak\
America/Anchorage\
America/Araguaina\
America/Argentina/Catamarca\
America/Argentina/Cordoba\
America/Argentina/Jujuy\
America/Argentina/La_Rioja\
America/Argentina/Mendoza\
America/Argentina/Rio_Gallegos\
America/Argentina/Salta\
America/Argentina/San_Juan\
America/Argentina/San_Luis\
America/Argentina/Tucuman\
America/Argentina/Ushuaia\
America/Asuncion\
America/Bahia\
America/Bahia_Banderas\
America/Barbados\
America/Belem\
America/Belize\
America/Boa_Vista\
America/Bogota\
America/Boise\
America/Cambridge_Bay\
America/Campo_Grande\
America/Cancun\
America/Caracas\
America/Cayenne\
America/Chihuahua\
America/Costa_Rica\
America/Cuiaba\
America/Danmarkshavn\
America/Dawson\
America/Dawson_Creek\
America/Eirunepe\
America/El_Salvador\
America/Fort_Nelson\
America/Fortaleza\
America/Glace_Bay\
America/Goose_Bay\
America/Grand_Turk\
America/Guatemala\
America/Guayaquil\
America/Guyana\
America/Havana\
America/Hermosillo\
America/Indiana/Indianapolis\
America/Indiana/Knox\
America/Indiana/Marengo\
America/Indiana/Petersburg\
America/Indiana/Tell_City\
America/Indiana/Vevay\
America/Indiana/Vincennes\
America/Indiana/Winamac\
America/Inuvik\
America/Iqaluit\
America/Jamaica\
America/Juneau\
America/Kentucky/Louisville\
America/Kentucky/Monticello\
America/La_Paz\
America/Lima\
America/Maceio\
America/Managua\
America/Manaus\
America/Martinique\
America/Matamoros\
America/Mazatlan\
America/Menominee\
America/Merida\
America/Metlakatla\
America/Miquelon\
America/Monterrey\
America/Montevideo\
America/Nipigon\
America/Nome\
America/Noronha\
America/North_Dakota/Beulah\
America/North_Dakota/Center\
America/North_Dakota/New_Salem\
America/Nuuk\
America/Ojinaga\
America/Panama\
America/Pangnirtung\
America/Paramaribo\
America/Port-au-Prince\
America/Porto_Velho\
America/Puerto_Rico\
America/Punta_Arenas\
America/Rainy_River\
America/Rankin_Inlet\
America/Recife\
America/Resolute\
America/Rio_Branco\
America/Santarem\
America/Santiago\
America/Santo_Domingo\
America/Scoresbysund\
America/Sitka\
America/St_Johns\
America/Swift_Current\
America/Tegucigalpa\
America/Thule\
America/Tijuana\
America/Whitehorse\
America/Yakutat\
America/Yellowknife\
Antarctica/Casey\
Antarctica/Davis\
Antarctica/Macquarie\
Antarctica/Mawson\
Antarctica/Palmer\
Antarctica/Rothera\
Antarctica/Troll\
Antarctica/Vostok\
Asia/Almaty\
Asia/Amman\
Asia/Anadyr\
Asia/Aqtau\
Asia/Aqtobe\
Asia/Ashgabat\
Asia/Atyrau\
Asia/Baghdad\
Asia/Baku\
Asia/Beirut\
Asia/Bishkek\
Asia/Brunei\
Asia/Chita\
Asia/Choibalsan\
Asia/Colombo\
Asia/Damascus\
Asia/Dhaka\
Asia/Dili\
Asia/Dubai\
Asia/Dushanbe\
Asia/Famagusta\
Asia/Gaza\
Asia/Hebron\
Asia/Ho_Chi_Minh\
Asia/Hong_Kong\
Asia/Hovd\
Asia/Jayapura\
Asia/Jerusalem\
Asia/Kabul\
Asia/Karachi\
Asia/Kathmandu\
Asia/Khandyga\
Asia/Kolkata\
Asia/Kuching\
Asia/Macau\
Asia/Makassar\
Asia/Manila\
Asia/Nicosia\
Asia/Pontianak\
Asia/Pyongyang\
Asia/Qatar\
Asia/Qostanay\
Asia/Qyzylorda\
Asia/Riyadh\
Asia/Samarkand\
Asia/Srednekolymsk\
Asia/Taipei\
Asia/Tashkent\
Asia/Tbilisi\
Asia/Tehran\
Asia/Thimphu\
Asia/Ulaanbaatar\
Asia/Urumqi\
Asia/Ust-Nera\
Asia/Yangon\
Asia/Yerevan\
Atlantic/Azores\
Atlantic/Bermuda\
Atlantic/Canary\
Atlantic/Cape_Verde\
Atlantic/Faroe\
Atlantic/Madeira\
Atlantic/Reykjavik\
Atlantic/South_Georgia\
Atlantic/Stanley\
Australia/Adelaide\
Australia/Brisbane\
Australia/Broken_Hill\
Australia/Darwin\
Australia/Eucla\
Australia/Hobart\
Australia/Lindeman\
Australia/Lord_Howe\
Australia/Melbourne\
Australia/Perth\
Etc/GMT\
Etc/UTC\
Europe/Andorra\
Europe/Astrakhan\
Europe/Budapest\
Europe/Chisinau\
Europe/Copenhagen\
Europe/Dublin\
Europe/Gibraltar\
Europe/Helsinki\
Europe/Istanbul\
Europe/Kirov\
Europe/Luxembourg\
Europe/Malta\
Europe/Monaco\
Europe/Oslo\
Europe/Sofia\
Europe/Stockholm\
Europe/Tallinn\
Europe/Tirane\
Europe/Vilnius\
Europe/Zaporozhye\
Europe/Zurich\
Indian/Chagos\
Indian/Christmas\
Indian/Cocos\
Indian/Kerguelen\
Indian/Mahe\
Indian/Maldives\
Indian/Mauritius\
Indian/Reunion\
Pacific/Apia\
Pacific/Auckland\
Pacific/Bougainville\
Pacific/Chatham\
Pacific/Chuuk\
Pacific/Easter\
Pacific/Efate\
Pacific/Fakaofo\
Pacific/Fiji\
Pacific/Funafuti\
Pacific/Galapagos\
Pacific/Gambier\
Pacific/Guadalcanal\
Pacific/Guam\
Pacific/Honolulu\
Pacific/Kanton\
Pacific/Kiritimati\
Pacific/Kosrae\
Pacific/Kwajalein\
Pacific/Majuro\
Pacific/Marquesas\
Pacific/Nauru\
Pacific/Niue\
Pacific/Norfolk\
Pacific/Noumea\
Pacific/Pago_Pago\
Pacific/Palau\
Pacific/Pitcairn\
Pacific/Pohnpei\
Pacific/Port_Moresby\
Pacific/Rarotonga\
Pacific/Tahiti\
Pacific/Tarawa\
Pacific/Tongatapu\
Pacific/Wake\
Pacific/Wallis";

struct __attribute__((__packed__)) timezone_ids {
  short int timezone_id;
  unsigned char timezone_string_length;
};
static const struct timezone_ids timezone_olson[]=
{
{947,sizeof("Europe/Moscow")-1},
{937,sizeof("Europe/Kaliningrad")-1},
{953,sizeof("Europe/Samara")-1},
{954,sizeof("Europe/Saratov")-1},
{955,sizeof("Europe/Simferopol")-1},
{960,sizeof("Europe/Ulyanovsk")-1},
{961,sizeof("Europe/Uzhgorod")-1},
{964,sizeof("Europe/Volgograd")-1},
{833,sizeof("Asia/Barnaul")-1},
{851,sizeof("Asia/Irkutsk")-1},
{856,sizeof("Asia/Kamchatka")-1},
{861,sizeof("Asia/Krasnoyarsk")-1},
{865,sizeof("Asia/Magadan")-1},
{869,sizeof("Asia/Novokuznetsk")-1},
{870,sizeof("Asia/Novosibirsk")-1},
{871,sizeof("Asia/Omsk")-1},
{872,sizeof("Asia/Oral")-1},
{879,sizeof("Asia/Sakhalin")-1},
{891,sizeof("Asia/Tomsk")-1},
{895,sizeof("Asia/Vladivostok")-1},
{896,sizeof("Asia/Yakutsk")-1},
{898,sizeof("Asia/Yekaterinburg")-1},
{945,sizeof("Europe/Minsk")-1},
{938,sizeof("Europe/Kiev")-1},
{832,sizeof("Asia/Bangkok")-1},
{852,sizeof("Asia/Jakarta")-1},
{862,sizeof("Asia/Kuala_Lumpur")-1},
{883,sizeof("Asia/Singapore")-1},
{694,sizeof("America/Argentina/Buenos_Aires")-1},
{720,sizeof("America/Chicago")-1},
{727,sizeof("America/Denver")-1},
{728,sizeof("America/Detroit")-1},
{729,sizeof("America/Edmonton")-1},
{740,sizeof("America/Halifax")-1},
{759,sizeof("America/Los_Angeles")-1},
{769,sizeof("America/Mexico_City")-1},
{771,sizeof("America/Moncton")-1},
{786,sizeof("America/Phoenix")-1},
{774,sizeof("America/New_York")-1},
{794,sizeof("America/Regina")-1},
{800,sizeof("America/Sao_Paulo")-1},
{807,sizeof("America/Thunder_Bay")-1},
{809,sizeof("America/Toronto")-1},
{810,sizeof("America/Vancouver")-1},
{812,sizeof("America/Winnipeg")-1},
{881,sizeof("Asia/Seoul")-1},
{882,sizeof("Asia/Shanghai")-1},
{890,sizeof("Asia/Tokyo")-1},
{919,sizeof("Australia/Sydney")-1},
{922,sizeof("Europe/Amsterdam")-1},
{925,sizeof("Europe/Athens")-1},
{926,sizeof("Europe/Belgrade")-1},
{927,sizeof("Europe/Berlin")-1},
{928,sizeof("Europe/Brussels")-1},
{929,sizeof("Europe/Bucharest")-1},
{940,sizeof("Europe/Lisbon")-1},
{941,sizeof("Europe/London")-1},
{943,sizeof("Europe/Madrid")-1},
{949,sizeof("Europe/Paris")-1},
{950,sizeof("Europe/Prague")-1},
{951,sizeof("Europe/Riga")-1},
{952,sizeof("Europe/Rome")-1},
{962,sizeof("Europe/Vienna")-1},
{965,sizeof("Europe/Warsaw")-1},
{1,sizeof("A")-1},
{2,sizeof("B")-1},
{3,sizeof("C")-1},
{4,sizeof("D")-1},
{5,sizeof("E")-1},
{6,sizeof("F")-1},
{7,sizeof("G")-1},
{8,sizeof("H")-1},
{9,sizeof("I")-1},
{10,sizeof("K")-1},
{11,sizeof("L")-1},
{12,sizeof("M")-1},
{13,sizeof("N")-1},
{14,sizeof("O")-1},
{15,sizeof("P")-1},
{16,sizeof("Q")-1},
{17,sizeof("R")-1},
{18,sizeof("S")-1},
{19,sizeof("T")-1},
{20,sizeof("U")-1},
{21,sizeof("V")-1},
{22,sizeof("W")-1},
{23,sizeof("X")-1},
{24,sizeof("Y")-1},
{25,sizeof("Z")-1},
{64,sizeof("GT")-1},
{80,sizeof("KT")-1},
{104,sizeof("ST")-1},
{112,sizeof("UT")-1},
{120,sizeof("WT")-1},
{131,sizeof("AFT")-1},
{133,sizeof("AoE")-1},
{134,sizeof("ART")-1},
{136,sizeof("AZT")-1},
{145,sizeof("BNT")-1},
{146,sizeof("BOT")-1},
{147,sizeof("BRT")-1},
{149,sizeof("BTT")-1},
{152,sizeof("CAT")-1},
{153,sizeof("CCT")-1},
{155,sizeof("CET")-1},
{156,sizeof("CIT")-1},
{157,sizeof("CKT")-1},
{158,sizeof("CLT")-1},
{159,sizeof("COT")-1},
{161,sizeof("CVT")-1},
{162,sizeof("CXT")-1},
{168,sizeof("EAT")-1},
{171,sizeof("EET")-1},
{172,sizeof("EGT")-1},
{176,sizeof("FET")-1},
{177,sizeof("FJT")-1},
{178,sizeof("FKT")-1},
{179,sizeof("FNT")-1},
{184,sizeof("GET")-1},
{185,sizeof("GFT")-1},
{186,sizeof("GMT")-1},
{188,sizeof("GYT")-1},
{192,sizeof("HAA")-1},
{193,sizeof("HAC")-1},
{194,sizeof("HAE")-1},
{195,sizeof("HAP")-1},
{196,sizeof("HAR")-1},
{197,sizeof("HAT")-1},
{198,sizeof("HDT")-1},
{199,sizeof("HKT")-1},
{200,sizeof("HLV")-1},
{201,sizeof("HNA")-1},
{202,sizeof("HNC")-1},
{203,sizeof("HNE")-1},
{204,sizeof("HNP")-1},
{205,sizeof("HNR")-1},
{206,sizeof("HNT")-1},
{207,sizeof("HST")-1},
{208,sizeof("ICT")-1},
{210,sizeof("IOT")-1},
{216,sizeof("JST")-1},
{224,sizeof("KGT")-1},
{225,sizeof("KIT")-1},
{226,sizeof("KST")-1},
{232,sizeof("MCK")-1},
{233,sizeof("MDT")-1},
{234,sizeof("MEZ")-1},
{235,sizeof("MHT")-1},
{236,sizeof("MMT")-1},
{237,sizeof("MSD")-1},
{238,sizeof("MSK")-1},
{240,sizeof("MUT")-1},
{241,sizeof("MVT")-1},
{242,sizeof("MYT")-1},
{248,sizeof("NCT")-1},
{249,sizeof("NDT")-1},
{250,sizeof("NFT")-1},
{251,sizeof("NPT")-1},
{252,sizeof("NRT")-1},
{253,sizeof("NST")-1},
{254,sizeof("NUT")-1},
{256,sizeof("OEZ")-1},
{264,sizeof("PDT")-1},
{265,sizeof("PET")-1},
{266,sizeof("PGT")-1},
{267,sizeof("PHT")-1},
{268,sizeof("PKT")-1},
{270,sizeof("PWT")-1},
{272,sizeof("RET")-1},
{280,sizeof("SBT")-1},
{281,sizeof("SCT")-1},
{282,sizeof("SGT")-1},
{283,sizeof("SRT")-1},
{288,sizeof("TFT")-1},
{289,sizeof("TJT")-1},
{290,sizeof("TKT")-1},
{291,sizeof("TLT")-1},
{292,sizeof("TMT")-1},
{293,sizeof("TOT")-1},
{294,sizeof("TRT")-1},
{295,sizeof("TVT")-1},
{296,sizeof("UTC")-1},
{297,sizeof("UYT")-1},
{298,sizeof("UZT")-1},
{304,sizeof("VET")-1},
{305,sizeof("VUT")-1},
{313,sizeof("WDT")-1},
{314,sizeof("WET")-1},
{315,sizeof("WEZ")-1},
{316,sizeof("WFT")-1},
{317,sizeof("WGT")-1},
{318,sizeof("WIB")-1},
{319,sizeof("WIT")-1},
{328,sizeof("ACDT")-1},
{329,sizeof("ACST")-1},
{331,sizeof("AEDT")-1},
{332,sizeof("AEST")-1},
{333,sizeof("AKDT")-1},
{334,sizeof("AKST")-1},
{335,sizeof("ALMT")-1},
{336,sizeof("AMDT")-1},
{338,sizeof("ANAT")-1},
{339,sizeof("AQTT")-1},
{340,sizeof("AWDT")-1},
{341,sizeof("AWST")-1},
{342,sizeof("AZOT")-1},
{343,sizeof("AZST")-1},
{344,sizeof("BDST")-1},
{345,sizeof("BRST")-1},
{352,sizeof("CAST")-1},
{354,sizeof("CEDT")-1},
{355,sizeof("CEST")-1},
{356,sizeof("CHOT")-1},
{357,sizeof("ChST")-1},
{358,sizeof("CHUT")-1},
{359,sizeof("CIST")-1},
{360,sizeof("CLDT")-1},
{361,sizeof("CLST")-1},
{368,sizeof("DAVT")-1},
{369,sizeof("DDUT")-1},
{376,sizeof("EADT")-1},
{377,sizeof("EAST")-1},
{378,sizeof("ECST")-1},
{379,sizeof("EDST")-1},
{380,sizeof("EEDT")-1},
{381,sizeof("EEST")-1},
{382,sizeof("EGST")-1},
{384,sizeof("FJDT")-1},
{385,sizeof("FJST")-1},
{386,sizeof("FKDT")-1},
{392,sizeof("GALT")-1},
{393,sizeof("GAMT")-1},
{394,sizeof("GILT")-1},
{400,sizeof("HADT")-1},
{401,sizeof("HAST")-1},
{402,sizeof("HOVT")-1},
{408,sizeof("IRDT")-1},
{409,sizeof("IRKT")-1},
{416,sizeof("KOST")-1},
{417,sizeof("KRAT")-1},
{418,sizeof("KUYT")-1},
{424,sizeof("LHDT")-1},
{425,sizeof("LHST")-1},
{426,sizeof("LINT")-1},
{432,sizeof("MAGT")-1},
{433,sizeof("MART")-1},
{434,sizeof("MAWT")-1},
{435,sizeof("MDST")-1},
{436,sizeof("MESZ")-1},
{440,sizeof("NFDT")-1},
{441,sizeof("NOVT")-1},
{442,sizeof("NZDT")-1},
{443,sizeof("NZST")-1},
{448,sizeof("OESZ")-1},
{449,sizeof("OMST")-1},
{450,sizeof("ORAT")-1},
{456,sizeof("PDST")-1},
{457,sizeof("PETT")-1},
{458,sizeof("PHOT")-1},
{459,sizeof("PMDT")-1},
{460,sizeof("PMST")-1},
{461,sizeof("PONT")-1},
{464,sizeof("QYZT")-1},
{472,sizeof("ROTT")-1},
{480,sizeof("SAKT")-1},
{481,sizeof("SAMT")-1},
{482,sizeof("SAST")-1},
{483,sizeof("SRET")-1},
{484,sizeof("SYOT")-1},
{488,sizeof("TAHT")-1},
{489,sizeof("TOST")-1},
{496,sizeof("ULAT")-1},
{497,sizeof("UYST")-1},
{504,sizeof("VLAT")-1},
{505,sizeof("VOST")-1},
{512,sizeof("WAKT")-1},
{513,sizeof("WAST")-1},
{514,sizeof("WEDT")-1},
{515,sizeof("WEST")-1},
{516,sizeof("WESZ")-1},
{517,sizeof("WGST")-1},
{518,sizeof("WITA")-1},
{520,sizeof("YAKT")-1},
{521,sizeof("YAPT")-1},
{522,sizeof("YEKT")-1},
{528,sizeof("ACWST")-1},
{529,sizeof("ANAST")-1},
{530,sizeof("AZODT")-1},
{536,sizeof("CHADT")-1},
{537,sizeof("CHAST")-1},
{538,sizeof("CHODT")-1},
{539,sizeof("CHOST")-1},
{540,sizeof("CIDST")-1},
{544,sizeof("EASST")-1},
{545,sizeof("EFATE")-1},
{552,sizeof("HOVDT")-1},
{553,sizeof("HOVST")-1},
{560,sizeof("IRKST")-1},
{568,sizeof("KRAST")-1},
{576,sizeof("MAGST")-1},
{584,sizeof("NACDT")-1},
{585,sizeof("NACST")-1},
{586,sizeof("NAEDT")-1},
{587,sizeof("NAEST")-1},
{588,sizeof("NAMDT")-1},
{589,sizeof("NAMST")-1},
{590,sizeof("NAPDT")-1},
{591,sizeof("NAPST")-1},
{592,sizeof("NOVST")-1},
{600,sizeof("OMSST")-1},
{608,sizeof("PETST")-1},
{616,sizeof("SAMST")-1},
{624,sizeof("ULAST")-1},
{632,sizeof("VLAST")-1},
{640,sizeof("WARST")-1},
{648,sizeof("YAKST")-1},
{649,sizeof("YEKST")-1},
{656,sizeof("CHODST")-1},
{664,sizeof("HOVDST")-1},
{672,sizeof("Africa/Abidjan")-1},
{673,sizeof("Africa/Algiers")-1},
{674,sizeof("Africa/Bissau")-1},
{675,sizeof("Africa/Cairo")-1},
{676,sizeof("Africa/Casablanca")-1},
{677,sizeof("Africa/Ceuta")-1},
{678,sizeof("Africa/El_Aaiun")-1},
{679,sizeof("Africa/Johannesburg")-1},
{680,sizeof("Africa/Juba")-1},
{681,sizeof("Africa/Khartoum")-1},
{682,sizeof("Africa/Lagos")-1},
{683,sizeof("Africa/Maputo")-1},
{684,sizeof("Africa/Monrovia")-1},
{685,sizeof("Africa/Nairobi")-1},
{686,sizeof("Africa/Ndjamena")-1},
{687,sizeof("Africa/Sao_Tome")-1},
{688,sizeof("Africa/Tripoli")-1},
{689,sizeof("Africa/Tunis")-1},
{690,sizeof("Africa/Windhoek")-1},
{691,sizeof("America/Adak")-1},
{692,sizeof("America/Anchorage")-1},
{693,sizeof("America/Araguaina")-1},
{695,sizeof("America/Argentina/Catamarca")-1},
{696,sizeof("America/Argentina/Cordoba")-1},
{697,sizeof("America/Argentina/Jujuy")-1},
{698,sizeof("America/Argentina/La_Rioja")-1},
{699,sizeof("America/Argentina/Mendoza")-1},
{700,sizeof("America/Argentina/Rio_Gallegos")-1},
{701,sizeof("America/Argentina/Salta")-1},
{702,sizeof("America/Argentina/San_Juan")-1},
{703,sizeof("America/Argentina/San_Luis")-1},
{704,sizeof("America/Argentina/Tucuman")-1},
{705,sizeof("America/Argentina/Ushuaia")-1},
{706,sizeof("America/Asuncion")-1},
{707,sizeof("America/Bahia")-1},
{708,sizeof("America/Bahia_Banderas")-1},
{709,sizeof("America/Barbados")-1},
{710,sizeof("America/Belem")-1},
{711,sizeof("America/Belize")-1},
{712,sizeof("America/Boa_Vista")-1},
{713,sizeof("America/Bogota")-1},
{714,sizeof("America/Boise")-1},
{715,sizeof("America/Cambridge_Bay")-1},
{716,sizeof("America/Campo_Grande")-1},
{717,sizeof("America/Cancun")-1},
{718,sizeof("America/Caracas")-1},
{719,sizeof("America/Cayenne")-1},
{721,sizeof("America/Chihuahua")-1},
{722,sizeof("America/Costa_Rica")-1},
{723,sizeof("America/Cuiaba")-1},
{724,sizeof("America/Danmarkshavn")-1},
{725,sizeof("America/Dawson")-1},
{726,sizeof("America/Dawson_Creek")-1},
{730,sizeof("America/Eirunepe")-1},
{731,sizeof("America/El_Salvador")-1},
{732,sizeof("America/Fort_Nelson")-1},
{733,sizeof("America/Fortaleza")-1},
{734,sizeof("America/Glace_Bay")-1},
{735,sizeof("America/Goose_Bay")-1},
{736,sizeof("America/Grand_Turk")-1},
{737,sizeof("America/Guatemala")-1},
{738,sizeof("America/Guayaquil")-1},
{739,sizeof("America/Guyana")-1},
{741,sizeof("America/Havana")-1},
{742,sizeof("America/Hermosillo")-1},
{743,sizeof("America/Indiana/Indianapolis")-1},
{744,sizeof("America/Indiana/Knox")-1},
{745,sizeof("America/Indiana/Marengo")-1},
{746,sizeof("America/Indiana/Petersburg")-1},
{747,sizeof("America/Indiana/Tell_City")-1},
{748,sizeof("America/Indiana/Vevay")-1},
{749,sizeof("America/Indiana/Vincennes")-1},
{750,sizeof("America/Indiana/Winamac")-1},
{751,sizeof("America/Inuvik")-1},
{752,sizeof("America/Iqaluit")-1},
{753,sizeof("America/Jamaica")-1},
{754,sizeof("America/Juneau")-1},
{755,sizeof("America/Kentucky/Louisville")-1},
{756,sizeof("America/Kentucky/Monticello")-1},
{757,sizeof("America/La_Paz")-1},
{758,sizeof("America/Lima")-1},
{760,sizeof("America/Maceio")-1},
{761,sizeof("America/Managua")-1},
{762,sizeof("America/Manaus")-1},
{763,sizeof("America/Martinique")-1},
{764,sizeof("America/Matamoros")-1},
{765,sizeof("America/Mazatlan")-1},
{766,sizeof("America/Menominee")-1},
{767,sizeof("America/Merida")-1},
{768,sizeof("America/Metlakatla")-1},
{770,sizeof("America/Miquelon")-1},
{772,sizeof("America/Monterrey")-1},
{773,sizeof("America/Montevideo")-1},
{775,sizeof("America/Nipigon")-1},
{776,sizeof("America/Nome")-1},
{777,sizeof("America/Noronha")-1},
{778,sizeof("America/North_Dakota/Beulah")-1},
{779,sizeof("America/North_Dakota/Center")-1},
{780,sizeof("America/North_Dakota/New_Salem")-1},
{781,sizeof("America/Nuuk")-1},
{782,sizeof("America/Ojinaga")-1},
{783,sizeof("America/Panama")-1},
{784,sizeof("America/Pangnirtung")-1},
{785,sizeof("America/Paramaribo")-1},
{787,sizeof("America/Port-au-Prince")-1},
{788,sizeof("America/Porto_Velho")-1},
{789,sizeof("America/Puerto_Rico")-1},
{790,sizeof("America/Punta_Arenas")-1},
{791,sizeof("America/Rainy_River")-1},
{792,sizeof("America/Rankin_Inlet")-1},
{793,sizeof("America/Recife")-1},
{795,sizeof("America/Resolute")-1},
{796,sizeof("America/Rio_Branco")-1},
{797,sizeof("America/Santarem")-1},
{798,sizeof("America/Santiago")-1},
{799,sizeof("America/Santo_Domingo")-1},
{801,sizeof("America/Scoresbysund")-1},
{802,sizeof("America/Sitka")-1},
{803,sizeof("America/St_Johns")-1},
{804,sizeof("America/Swift_Current")-1},
{805,sizeof("America/Tegucigalpa")-1},
{806,sizeof("America/Thule")-1},
{808,sizeof("America/Tijuana")-1},
{811,sizeof("America/Whitehorse")-1},
{813,sizeof("America/Yakutat")-1},
{814,sizeof("America/Yellowknife")-1},
{815,sizeof("Antarctica/Casey")-1},
{816,sizeof("Antarctica/Davis")-1},
{817,sizeof("Antarctica/Macquarie")-1},
{818,sizeof("Antarctica/Mawson")-1},
{819,sizeof("Antarctica/Palmer")-1},
{820,sizeof("Antarctica/Rothera")-1},
{821,sizeof("Antarctica/Troll")-1},
{822,sizeof("Antarctica/Vostok")-1},
{823,sizeof("Asia/Almaty")-1},
{824,sizeof("Asia/Amman")-1},
{825,sizeof("Asia/Anadyr")-1},
{826,sizeof("Asia/Aqtau")-1},
{827,sizeof("Asia/Aqtobe")-1},
{828,sizeof("Asia/Ashgabat")-1},
{829,sizeof("Asia/Atyrau")-1},
{830,sizeof("Asia/Baghdad")-1},
{831,sizeof("Asia/Baku")-1},
{834,sizeof("Asia/Beirut")-1},
{835,sizeof("Asia/Bishkek")-1},
{836,sizeof("Asia/Brunei")-1},
{837,sizeof("Asia/Chita")-1},
{838,sizeof("Asia/Choibalsan")-1},
{839,sizeof("Asia/Colombo")-1},
{840,sizeof("Asia/Damascus")-1},
{841,sizeof("Asia/Dhaka")-1},
{842,sizeof("Asia/Dili")-1},
{843,sizeof("Asia/Dubai")-1},
{844,sizeof("Asia/Dushanbe")-1},
{845,sizeof("Asia/Famagusta")-1},
{846,sizeof("Asia/Gaza")-1},
{847,sizeof("Asia/Hebron")-1},
{848,sizeof("Asia/Ho_Chi_Minh")-1},
{849,sizeof("Asia/Hong_Kong")-1},
{850,sizeof("Asia/Hovd")-1},
{853,sizeof("Asia/Jayapura")-1},
{854,sizeof("Asia/Jerusalem")-1},
{855,sizeof("Asia/Kabul")-1},
{857,sizeof("Asia/Karachi")-1},
{858,sizeof("Asia/Kathmandu")-1},
{859,sizeof("Asia/Khandyga")-1},
{860,sizeof("Asia/Kolkata")-1},
{863,sizeof("Asia/Kuching")-1},
{864,sizeof("Asia/Macau")-1},
{866,sizeof("Asia/Makassar")-1},
{867,sizeof("Asia/Manila")-1},
{868,sizeof("Asia/Nicosia")-1},
{873,sizeof("Asia/Pontianak")-1},
{874,sizeof("Asia/Pyongyang")-1},
{875,sizeof("Asia/Qatar")-1},
{876,sizeof("Asia/Qostanay")-1},
{877,sizeof("Asia/Qyzylorda")-1},
{878,sizeof("Asia/Riyadh")-1},
{880,sizeof("Asia/Samarkand")-1},
{884,sizeof("Asia/Srednekolymsk")-1},
{885,sizeof("Asia/Taipei")-1},
{886,sizeof("Asia/Tashkent")-1},
{887,sizeof("Asia/Tbilisi")-1},
{888,sizeof("Asia/Tehran")-1},
{889,sizeof("Asia/Thimphu")-1},
{892,sizeof("Asia/Ulaanbaatar")-1},
{893,sizeof("Asia/Urumqi")-1},
{894,sizeof("Asia/Ust-Nera")-1},
{897,sizeof("Asia/Yangon")-1},
{899,sizeof("Asia/Yerevan")-1},
{900,sizeof("Atlantic/Azores")-1},
{901,sizeof("Atlantic/Bermuda")-1},
{902,sizeof("Atlantic/Canary")-1},
{903,sizeof("Atlantic/Cape_Verde")-1},
{904,sizeof("Atlantic/Faroe")-1},
{905,sizeof("Atlantic/Madeira")-1},
{906,sizeof("Atlantic/Reykjavik")-1},
{907,sizeof("Atlantic/South_Georgia")-1},
{908,sizeof("Atlantic/Stanley")-1},
{909,sizeof("Australia/Adelaide")-1},
{910,sizeof("Australia/Brisbane")-1},
{911,sizeof("Australia/Broken_Hill")-1},
{912,sizeof("Australia/Darwin")-1},
{913,sizeof("Australia/Eucla")-1},
{914,sizeof("Australia/Hobart")-1},
{915,sizeof("Australia/Lindeman")-1},
{916,sizeof("Australia/Lord_Howe")-1},
{917,sizeof("Australia/Melbourne")-1},
{918,sizeof("Australia/Perth")-1},
{920,sizeof("Etc/GMT")-1},
{921,sizeof("Etc/UTC")-1},
{923,sizeof("Europe/Andorra")-1},
{924,sizeof("Europe/Astrakhan")-1},
{930,sizeof("Europe/Budapest")-1},
{931,sizeof("Europe/Chisinau")-1},
{932,sizeof("Europe/Copenhagen")-1},
{933,sizeof("Europe/Dublin")-1},
{934,sizeof("Europe/Gibraltar")-1},
{935,sizeof("Europe/Helsinki")-1},
{936,sizeof("Europe/Istanbul")-1},
{939,sizeof("Europe/Kirov")-1},
{942,sizeof("Europe/Luxembourg")-1},
{944,sizeof("Europe/Malta")-1},
{946,sizeof("Europe/Monaco")-1},
{948,sizeof("Europe/Oslo")-1},
{956,sizeof("Europe/Sofia")-1},
{957,sizeof("Europe/Stockholm")-1},
{958,sizeof("Europe/Tallinn")-1},
{959,sizeof("Europe/Tirane")-1},
{963,sizeof("Europe/Vilnius")-1},
{966,sizeof("Europe/Zaporozhye")-1},
{967,sizeof("Europe/Zurich")-1},
{968,sizeof("Indian/Chagos")-1},
{969,sizeof("Indian/Christmas")-1},
{970,sizeof("Indian/Cocos")-1},
{971,sizeof("Indian/Kerguelen")-1},
{972,sizeof("Indian/Mahe")-1},
{973,sizeof("Indian/Maldives")-1},
{974,sizeof("Indian/Mauritius")-1},
{975,sizeof("Indian/Reunion")-1},
{976,sizeof("Pacific/Apia")-1},
{977,sizeof("Pacific/Auckland")-1},
{978,sizeof("Pacific/Bougainville")-1},
{979,sizeof("Pacific/Chatham")-1},
{980,sizeof("Pacific/Chuuk")-1},
{981,sizeof("Pacific/Easter")-1},
{982,sizeof("Pacific/Efate")-1},
{983,sizeof("Pacific/Fakaofo")-1},
{984,sizeof("Pacific/Fiji")-1},
{985,sizeof("Pacific/Funafuti")-1},
{986,sizeof("Pacific/Galapagos")-1},
{987,sizeof("Pacific/Gambier")-1},
{988,sizeof("Pacific/Guadalcanal")-1},
{989,sizeof("Pacific/Guam")-1},
{990,sizeof("Pacific/Honolulu")-1},
{991,sizeof("Pacific/Kanton")-1},
{992,sizeof("Pacific/Kiritimati")-1},
{993,sizeof("Pacific/Kosrae")-1},
{994,sizeof("Pacific/Kwajalein")-1},
{995,sizeof("Pacific/Majuro")-1},
{996,sizeof("Pacific/Marquesas")-1},
{997,sizeof("Pacific/Nauru")-1},
{998,sizeof("Pacific/Niue")-1},
{999,sizeof("Pacific/Norfolk")-1},
{1000,sizeof("Pacific/Noumea")-1},
{1001,sizeof("Pacific/Pago_Pago")-1},
{1002,sizeof("Pacific/Palau")-1},
{1003,sizeof("Pacific/Pitcairn")-1},
{1004,sizeof("Pacific/Pohnpei")-1},
{1005,sizeof("Pacific/Port_Moresby")-1},
{1006,sizeof("Pacific/Rarotonga")-1},
{1007,sizeof("Pacific/Tahiti")-1},
{1008,sizeof("Pacific/Tarawa")-1},
{1009,sizeof("Pacific/Tongatapu")-1},
{1010,sizeof("Pacific/Wake")-1},
{1011,sizeof("Pacific/Wallis")-1},
{0,0}, /* end of list */
};
#endif

/*
  result_type values, determined by tarantool_get_result_type()
  4 == result set of box.space.x:select() with signature = array+array
  5 == result set of SQL select|values, with "metadata" signature
  6 == result of SQL not select|values, with "row_count" signature
  7 == error with "Error: " signature (but maybe RESULT_TYPE_0 is error as well?)
  8 = result set from box.execute() so tarantool_tnt_reply.metadata != 0
*/
#define RESULT_TYPE_0 0
#define RESULT_TYPE_1 1
#define RESULT_TYPE_2 2
#define RESULT_TYPE_3 3
#define RESULT_TYPE_4 4
#define RESULT_TYPE_5 5
#define RESULT_TYPE_6 6
#define RESULT_TYPE_7 7
#define RESULT_TYPE_8 8

/* main_token_flags[] values. so far there are only sixteen but we expect there will be more. */
#define TOKEN_FLAG_IS_RESERVED 1
#define TOKEN_FLAG_IS_BLOCK_END 2
#define TOKEN_FLAG_IS_ERROR 4
#define TOKEN_FLAG_IS_FUNCTION 8
#define TOKEN_FLAG_IS_START_STATEMENT 16
#define TOKEN_FLAG_IS_START_CLAUSE 32
#define TOKEN_FLAG_IS_START_SUBCLAUSE 64
#define TOKEN_FLAG_IS_DATA_TYPE 128
#define TOKEN_FLAG_IS_START_IN_COLUMN_LIST 256
#define TOKEN_FLAG_IS_END_IN_COLUMN_LIST 512
#define TOKEN_FLAG_IS_BINARY_PLUS_OR_MINUS 1024
#define TOKEN_FLAG_IS_NOT_AFTER_SPACE 2048
#define TOKEN_FLAG_IS_MAYBE_LUA 4096
#define TOKEN_FLAG_IS_LUA 8192
#define TOKEN_FLAG_IS_FLOW_CONTROL 16384
#define TOKEN_FLAG_IS_DEBUGGABLE 32768
#define TOKEN_FLAG_IS_DECLARE 65536
#define TOKEN_FLAG_IS_PLSQL_DECLARE_SEMICOLON 131072
//#define TOKEN_FLAG_IS_ASSIGNEE 262144
#define TOKEN_FLAG_IS_NEW 262144
#if (OCELOT_EXTENDER == 1)
/* Todo: try to re-use flag values from above list, where you're sure there can never be ambiguity */
#define TOKEN_FLAG_SEMISELECT_1 524288
#define TOKEN_FLAG_SEMISELECT_2 1048576
#define TOKEN_FLAG_IS_SEMISELECT TOKEN_FLAG_SEMISELECT_1
#define TOKEN_FLAG_IS_SEMISELECT_MID TOKEN_FLAG_SEMISELECT_2
#define TOKEN_FLAG_IS_SEMISELECT_END (TOKEN_FLAG_SEMISELECT_1 | TOKEN_FLAG_SEMISELECT_2)
#define TOKEN_FLAG_IS_SEMISELECT_ALL (TOKEN_FLAG_SEMISELECT_1 | TOKEN_FLAG_SEMISELECT_2)
#endif

/* The enum for TOKEN_TYPE_LITERAL etc. was here, but moved outside MainWindow on 2019-02-26 */

/*
TOKEN_LITERAL_FLAG is for passing required format to hparse_f_literal().
Example: +5 is okay if we're looking for signed integer,
but if we say hparse_f_literal(TOKEN_LITERAL_FLAG_UNSIGNED_INTEGER)
then the only acceptable literals are unsigned integers.
Todo: The expected will still say "[literal]", more general than needed.
Todo: We aren't specific enough, we don't use this enough.
Todo: Some values aren't used.
Warning: Some things e.g. TOKEN_LITERAL_FLAG_STRING_ID are not included in TOKEN_LITERAL_FLAG_ANY
*/
#define TOKEN_LITERAL_FLAG_STRING               1
#define TOKEN_LITERAL_FLAG_SIGNED_INTEGER       2
#define TOKEN_LITERAL_FLAG_UNSIGNED_INTEGER     4
#define TOKEN_LITERAL_FLAG_INTEGER              (2+4)
#define TOKEN_LITERAL_FLAG_FLOAT                8
#define TOKEN_LITERAL_FLAG_NUMBER               (2+4+8)
#define TOKEN_LITERAL_FLAG_CONSTANT             16
#define TOKEN_LITERAL_FLAG_STRING_OR_NUMBER_OR_CONSTANT (1+2+4+8+16)
#define TOKEN_LITERAL_FLAG_INTRODUCER           32
#define TOKEN_LITERAL_FLAG_INTRODUCEABLE_STRING (1+32)
#define TOKEN_LITERAL_FLAG_USER                 64
#define TOKEN_LITERAL_FLAG_USER_STRING          (1+64)
#define TOKEN_LITERAL_FLAG_HOST                 128
#define TOKEN_LITERAL_FLAG_HOST_STRING          (1+128)
#define TOKEN_LITERAL_FLAG_ODBC                 256
#define TOKEN_LITERAL_FLAG_ODBC_STRING          (1+256)
#define TOKEN_LITERAL_FLAG_DATE                 512
#define TOKEN_LITERAL_FLAG_DATE_STRING          (1+512)
#define TOKEN_LITERAL_FLAG_UUID                 1024
#define TOKEN_LITERAL_FLAG_MAP                  2048
#define TOKEN_LITERAL_FLAG_ID_STRING            4096
#define TOKEN_LITERAL_FLAG_LIBRARY_STRING        8192
#define TOKEN_LITERAL_FLAG_MENU_TITLE_STRING    16384
#define TOKEN_LITERAL_FLAG_MENU_ITEM_STRING     32768
#define TOKEN_LITERAL_FLAG_ACTION_STRING        65536
#define TOKEN_LITERAL_FLAG_KEYSEQUENCE_STRING   131072
#define TOKEN_LITERAL_FLAG_ANY                  (1+2+4+8+16+32+64+128+256+512+1024+2048)

/*
TOKEN_TYPE_... shows "what kind of token is it?" e.g. TOKEN_TYPE_IDENTIFIER_WITH_BACKTICK.
TOKEN_REFTYPE_... shows "what kind of object does the token refer to?"
e.g. if it's identifier, is it a database identifier?
We only pass something specific if we are sure that is what must follow.
Beware: A "user" might be qualified within 'user'@'host' I guess that's a form of qualifier.
Beware: there are enum values for "x or y" e.g. "user or role", "database or table", etc.
TOKEN_REFTYPE_... values and must be in the same order.
Todo: store these in main_token_reftypes[] to help hovering.
Todo: knowing it's "column" doesn't help us yet with knowing: column of what?
      but eventually we can bring in lists of objects, and refer to them by number-within-the-list
Todo: eventually we can be sure, after qualification is done, for a column (e.g. we've seen FROM)
Todo: Get rid of enums that aren't actually used.
... And my plan is:
* Always pass reftype for hparse_f_accept and hparse_f_acceptn and hparse_f_expect
* If the pass is "[identifier]" then the expected list gets "[table identifier]", etc.
* Eventually, use this so we can auto-complete any object names
(We'll have a local list of object names so we can store numbers.)
* Eventually, have reftypes for literals too -- again, meaning "what they refer to", not format
* Check: sometimes TOKEN_TYPE_IDENTIFIER_WITH_AT is not appropriate
* For LIMIT and OFFSET, the only possibilities are @variable and declared variable and parameter
* I'd also like to restrict what FETCH variable can be
* Whenever it is specific, IDENTIFIER_WITH_AT is not appropriate,
and a maximum length is applicable such as MYSQL_MAX_IDENTIFIER_LENGTH.
* There is one case where we pass "[reserved function]" instead of "[identifier]".
*/

enum {
  TOKEN_REFTYPE_ANY,                 /* any kind, or it's irrelevant, or we don't care */
  TOKEN_REFTYPE_ALIAS_OF_COLUMN, /* or correlation */
  TOKEN_REFTYPE_ALIAS_OF_TABLE, /* or correlation */
  TOKEN_REFTYPE_ATTRIBUTE,
  TOKEN_REFTYPE_AUTO_INCREMENT,
  TOKEN_REFTYPE_CHANNEL,
  TOKEN_REFTYPE_CHARACTER_SET,
  TOKEN_REFTYPE_COLLATION,
  TOKEN_REFTYPE_COLUMN,
  TOKEN_REFTYPE_COLUMN_OR_USER_VARIABLE,
  TOKEN_REFTYPE_COLUMN_OR_VARIABLE,
  TOKEN_REFTYPE_COMMENT,
  TOKEN_REFTYPE_CONDITION_DEFINE,
  TOKEN_REFTYPE_CONDITION_REFER,
  TOKEN_REFTYPE_CONDITION_OR_CURSOR,
  TOKEN_REFTYPE_CONSTRAINT,
  TOKEN_REFTYPE_CURSOR_DEFINE,
  TOKEN_REFTYPE_CURSOR_REFER,
  TOKEN_REFTYPE_DATABASE, /* or schema */
  TOKEN_REFTYPE_DATABASE_OR_CONSTRAINT,
  TOKEN_REFTYPE_DATABASE_OR_EVENT,
  TOKEN_REFTYPE_DATABASE_OR_FUNCTION,
  TOKEN_REFTYPE_DATABASE_OR_FUNCTION_OR_PROCEDURE,
  TOKEN_REFTYPE_DATABASE_OR_FUNCTION_OR_VARIABLE,
  TOKEN_REFTYPE_DATABASE_OR_PACKAGE,
  TOKEN_REFTYPE_DATABASE_OR_PROCEDURE,
  TOKEN_REFTYPE_DATABASE_OR_SEQUENCE,
  TOKEN_REFTYPE_DATABASE_OR_TABLE,
  TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW,
  TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN,
  TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN_OR_FUNCTION,
  TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_VARIABLE_OR_FUNCTION,
  TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW_OR_FUNCTION_OR_COLUMN,
  TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW_OR_FUNCTION_OR_VARIABLE,
  TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_COLUMN_OR_FUNCTION_OR_VARIABLE,
  TOKEN_REFTYPE_DATABASE_OR_TABLE_OR_ROW_OR_COLUMN_OR_FUNCTION_OR_VARIABLE,
  TOKEN_REFTYPE_DATABASE_OR_TRIGGER,
  TOKEN_REFTYPE_DATABASE_OR_VIEW,
  TOKEN_REFTYPE_DIRECTORY,
  TOKEN_REFTYPE_ENGINE,
  TOKEN_REFTYPE_EVENT,
  TOKEN_REFTYPE_FILE,
  TOKEN_REFTYPE_FUNCTION,
  TOKEN_REFTYPE_FUNCTION_OR_PROCEDURE,
  TOKEN_REFTYPE_FUNCTION_OR_VARIABLE,
  TOKEN_REFTYPE_HANDLER_ALIAS,
  TOKEN_REFTYPE_HOST,
  TOKEN_REFTYPE_INDEX,
  TOKEN_REFTYPE_INTRODUCER,
  TOKEN_REFTYPE_KEY_CACHE,
  TOKEN_REFTYPE_LABEL_DEFINE,
  TOKEN_REFTYPE_LABEL_REFER,
  TOKEN_REFTYPE_LENGTH,
  TOKEN_REFTYPE_PACKAGE,
  TOKEN_REFTYPE_PARAMETER_DEFINE,
  TOKEN_REFTYPE_PARAMETER_REFER,
  TOKEN_REFTYPE_PARSER,
  TOKEN_REFTYPE_PLUGIN,
  TOKEN_REFTYPE_PROCEDURE,
  /* plus TOKEN_REFTYPE_RESERVED_FUNCTION */
  TOKEN_REFTYPE_PARTITION,
  TOKEN_REFTYPE_PARTITION_NUMBER,
  TOKEN_REFTYPE_PASSWORD,
  TOKEN_REFTYPE_ROLE,
  TOKEN_REFTYPE_ROW,
  TOKEN_REFTYPE_ROW_OR_VARIABLE,
  TOKEN_REFTYPE_SAVEPOINT,
  TOKEN_REFTYPE_SCALE,
  TOKEN_REFTYPE_SEQUENCE,
  TOKEN_REFTYPE_SERVER,
  TOKEN_REFTYPE_SQLSTATE,
  TOKEN_REFTYPE_STATEMENT,
  TOKEN_REFTYPE_SUBPARTITION,
  TOKEN_REFTYPE_SWITCH_NAME,
  TOKEN_REFTYPE_SYSTEM,
  TOKEN_REFTYPE_TABLE,
  TOKEN_REFTYPE_TABLE_OR_COLUMN,
  TOKEN_REFTYPE_TABLE_OR_COLUMN_OR_FUNCTION,
  TOKEN_REFTYPE_TABLE_OR_COLUMN_OR_FUNCTION_OR_VARIABLE,
  TOKEN_REFTYPE_TABLE_OR_ROW,
  TOKEN_REFTYPE_TABLESPACE,
  TOKEN_REFTYPE_TRANSACTION,
  TOKEN_REFTYPE_TRIGGER,
  TOKEN_REFTYPE_USER,
  TOKEN_REFTYPE_USER_VARIABLE,
  TOKEN_REFTYPE_VARIABLE,         /* i.e. either USER_VARIABLE or DECLARED VARIABLE */
  TOKEN_REFTYPE_VARIABLE_DEFINE,
  TOKEN_REFTYPE_VARIABLE_REFER,
  TOKEN_REFTYPE_VIEW,
  TOKEN_REFTYPE_WINDOW_DEFINE,
  TOKEN_REFTYPE_WINDOW_REFER,
  TOKEN_REFTYPE_WITH_TABLE,
  TOKEN_REFTYPE_WRAPPER,
  TOKEN_REFTYPE_MAX
  /*
    In ocelotgui.cpp we say "assert(TOKEN_REFTYPE_MAX == 92);".
    If it blows, that means you changed the above enum list.
    Which is okay, but before you change the assert, make sure
    reftypewords list corresponds to the enum list!
  */
};

/* Use NULL_STRING when displaying a column value which is null. Length is sizeof(NULL_STRING) - 1. */
#define NULL_STRING "NULL"

/* During scan_rows we might set a flag e.g. if a column value is null */
#define FIELD_VALUE_FLAG_IS_ZERO 0
#define FIELD_VALUE_FLAG_IS_NULL 1
                                #define FIELD_VALUE_FLAG_IS_NUMBER 2
#define FIELD_VALUE_FLAG_IS_STRING 4
#define FIELD_VALUE_FLAG_IS_OTHER 8
#define FIELD_VALUE_FLAG_IS_IMAGE 16

/*
  Often an OCELOT_DATA_TYPE value is the same as a MYSQL_TYPE value, for example
  MYSQL_TYPE_LONG_BLOB=251 in mysql_com.h and #define OCELOT_DATA_TYPE_LONG_BLOB 251 here.
  But we have additional TEXT and BINARY types because we distinguish when charsetnr=63.
  DECIMAL and NEWDECIMAL are both DECIMAL. LONG is INT. INT24 is MEDIUMINT. LONGLONG is BIGINT.
  STRING is CHAR (only). VAR_STRING is VARCHAR (only). BLOB is BLOB (only).
  See also struct typer.
*/
#define OCELOT_DATA_TYPE_DECIMAL     0
#define OCELOT_DATA_TYPE_TINY        1
#define OCELOT_DATA_TYPE_SHORT       2
#define OCELOT_DATA_TYPE_LONG        3
#define OCELOT_DATA_TYPE_FLOAT       4
#define OCELOT_DATA_TYPE_DOUBLE      5
#define OCELOT_DATA_TYPE_NULL        6
#define OCELOT_DATA_TYPE_TIMESTAMP   7
#define OCELOT_DATA_TYPE_LONGLONG    8
#define OCELOT_DATA_TYPE_INT24       9
#define OCELOT_DATA_TYPE_DATE        10
#define OCELOT_DATA_TYPE_TIME        11
#define OCELOT_DATA_TYPE_DATETIME    12
#define OCELOT_DATA_TYPE_YEAR        13
//#define OCELOT_DATA_TYPE_NEWDATE     14
//#define OCELOT_DATA_TYPE_VARCHAR     15
#define OCELOT_DATA_TYPE_BIT         16
#define OCELOT_DATA_TYPE_JSON        245       /* new in MySQL 5.7. todo: don't ignore it */
#define OCELOT_DATA_TYPE_NEWDECIMAL  246
#define OCELOT_DATA_TYPE_ENUM        247
#define OCELOT_DATA_TYPE_SET         248
#define OCELOT_DATA_TYPE_TINY_BLOB   249
#define OCELOT_DATA_TYPE_MEDIUM_BLOB 250
#define OCELOT_DATA_TYPE_LONG_BLOB   251
#define OCELOT_DATA_TYPE_BLOB        252
#define OCELOT_DATA_TYPE_VAR_STRING  253       /* i.e. VARCHAR or VARBINARY */
#define OCELOT_DATA_TYPE_STRING      254       /* i.e. CHAR or BINARY */
#define OCELOT_DATA_TYPE_GEOMETRY    255
#define OCELOT_DATA_TYPE_BINARY      10001
#define OCELOT_DATA_TYPE_VARBINARY   10002
#define OCELOT_DATA_TYPE_TEXT        10003
#define OCELOT_DATA_TYPE_SCALAR      12001     /* numbers > 12000 are Tarantool-specific */
#define OCELOT_DATA_TYPE_BOOLEAN     12002
#define OCELOT_DATA_TYPE_MAP         12003
#define OCELOT_DATA_TYPE_ARRAY       12004
#define OCELOT_DATA_TYPE_INTEGER     12005
#define OCELOT_DATA_TYPE_UNSIGNED    12006
#define OCELOT_DATA_TYPE_NUMBER      12007

struct connect_arguments {
  char * host_as_utf8;   /* --host=s */
  /* Connect arguments and options */
  //  char* ca.host_as_utf8;                  /* --host=s */
  char* database_as_utf8;              /* --database=s */
  char* user_as_utf8;                  /* --user=s */
  char* password_as_utf8;              /* --password[=s] */
  unsigned short port;        /* --port=n */
  char* unix_socket_as_utf8;           /* --socket=s */
  unsigned int protocol_as_int;        /* --protocol=s for MYSQL_OPT_PROTOCOL */
  char* init_command_as_utf8;          /* --init_command=s for MYSQL_INIT_COMMAND */
  /* Connect arguments below this point are minor and many are unsupported. */
  unsigned short abort_source_on_error;   /* --abort_source_on_error (MariaDB) */
  unsigned short auto_rehash;             /* --auto_rehash */
  unsigned short auto_vertical_output;    /* --auto_vertical_output */
  unsigned short batch;                   /* --batch */
  unsigned short binary_mode;             /* --binary_mode */
  /* QString bind_address */                        /* --bind_address=s */
  char* set_charset_dir_as_utf8;         /* --character_sets_dir=s for MYSQL_SET_CHARSET_DIR */
  unsigned short result_grid_column_names;/* --column_names */
  unsigned short column_type_info;        /* --column_type_info */
  unsigned short comments;               /* --comments */
  unsigned short opt_compress;           /* --compress for MYSQL_OPT_COMPRESS */
  unsigned long int opt_connect_timeout;  /* --connect_timeout = n for MYSQL_OPT_CONNECT_TIMEOUT */
  /* QString debug */                               /* --debug[=s] */
  unsigned short debug_check;             /* --debug_check */
  unsigned short debug_info;              /* --debug_info */
  char* default_auth_as_utf8;      /* --default_auth=s for MYSQL_DEFAULT_AUTH */
  char* set_charset_name_as_utf8;  /* --default_character_set=s for MYSQL_SET_CHARSET_NAME */
  /* exists as QString */                    /* --defaults_extra_file=s */
  /* exists as QString */                    /* --defaults_file=s */
  /* exists as QString */                    /* --defaults_group_suffix=s */
  /* exists as QString */                    /* --delimiter=s */
  unsigned short enable_cleartext_plugin;  /* --enable_cleartext_plugin for MYSQL_ENABLE_CLEARTEXT_PLUGIN */
  /* QString execute */               /* --execute=s */
  unsigned short force;     /* --force */
  unsigned short help;      /* --help */
  unsigned char history_hist_file_is_open; /* was bool */
  unsigned char history_hist_file_is_copied; /* was bool */
  /* exists as QString */                    /* --histfile=s */
  /* exists as QString */                    /* --histignore=s */
  unsigned short html;      /* --html */
  unsigned short ignore_spaces;  /* --ignore_spaces */
  /* QString ld_run_path */                /* --ld_run_path=s */
  unsigned short line_numbers;   /* --line_numbers */
  unsigned short opt_local_infile;    /* --local_infile[=n]  for MYSQL_OPT_LOCAL_INFILE */
  /* QString login_path */            /* --login_path=s */
  unsigned short int log_level;          /* --ocelot_log_level */
  unsigned short int max_conditions;
  unsigned long int max_allowed_packet_arg; /* --max_allowed_packet=n */
  unsigned long int max_join_size; /* --max_join_size = n */
  unsigned short named_commands;         /* --named_commands */
  unsigned long int net_buffer_length_arg; /* --net_buffer_length=n */
  unsigned short no_beep;                /* --no_beep */
  unsigned short no_defaults;            /* --no_defaults */
  /* QString dbms */
  unsigned short one_database;           /* --one-database */
  /* QString pager */                              /* --pager[=s] */
  unsigned short pipe;                   /* --pipe */
  char* plugin_dir_as_utf8;        /* --plugin_dir=s for MYSQL_PLUGIN_DIR */
  unsigned short print_defaults;   /* --print_defaults */
  /* QString prompt */                       /* --prompt=s */
  unsigned char prompt_is_default; /* was bool */
  unsigned short quick;            /* --quick */
  unsigned short raw;              /* --raw */
  unsigned int opt_reconnect;      /* --reconnect for MYSQL_OPT_RECONNECT */                                           /* --reconnect */
  unsigned short safe_updates;           /* --safe-updates or --i-am-a-dummy */
  unsigned short secure_auth;             /* --secure_auth for MYSQL_SECURE_AUTH (default=true if version >= 5.6.5) */
  unsigned long int select_limit;  /* --select_limit = n */
  char* server_public_key_as_utf8; /* --server_public_key=s for MYSQL_SERVER_PUBLIC_KEY */
  char* shared_memory_base_name_as_utf8; /* --shared_memory_base_name=s for MYSQL_SHARED_MEMORY_BASE_NAME */
  unsigned short history_includes_warnings; /* --show_warnings include warning(s) returned from statement? default = no. */
  unsigned short sigint_ignore;          /* --sigint_ignore */
  unsigned short silent;                 /* --silent */
  char* opt_ssl_as_utf8;           /* --ssl for CONNECT */
  char* opt_ssl_ca_as_utf8;        /* --ssl-ca for MYSQL_OPT_SSL_CA */
  char* opt_ssl_capath_as_utf8;    /* --ssl-capath for MYSQL_OPT_SSL_CAPATH. */
  char* opt_ssl_cert_as_utf8;      /* --ssl-cert for MYSQL_OPT_SSL_CERT */
  char* opt_ssl_cipher_as_utf8;    /* --ssl-cipher for MYSQL_OPT_SSL_CIPHER */
  char* opt_ssl_crl_as_utf8;       /*  --ssl-crl for MYSQL_OPT_SSL_CRL */
  char* opt_ssl_crlpath_as_utf8;   /* --ssl-crlpath for MYSQL_OPT_SSL_CRLPATH */
  char* opt_ssl_key_as_utf8;       /* --ssl-key for MYSQL_OPT_SSL_KEY */
  char* opt_ssl_mode_as_utf8;      /* --ssl-mode for MYSQL_OPT_SSL_MODE */
  unsigned short int opt_ssl_verify_server_cert;  /* --ssl-verify-server-cert for MYSQL_OPT_SSL_VERIFY_SERVER_CERT. --ssl-verify-server-cert (5.7) */
  unsigned short syslog;           /* --syslog (5.7) */
  unsigned short table;            /* --table */
  unsigned char history_tee_file_is_open; /* was bool */     /* --tee for tee  ... arg=history_tee_file_name*/
  unsigned short unbuffered;       /* --unbuffered */
  unsigned short verbose;          /* --verbose */
  unsigned short version;          /* --version */
  unsigned short vertical;               /* --vertical */
  unsigned short wait;                   /* --wait ... actually this does nothing */
  unsigned short xml;                    /* --xml */
  unsigned short bar;                    /* unused */
  unsigned short line;                   /* unused */
  unsigned short pie;                    /* unused */
  /*
    For MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS + --connect-expired-password.
    mysql client has this off by default, but ocelotgui has it on by default
    so to turn it off say ocelotgui --skip_connect_expired_password
  */
  unsigned short opt_can_handle_expired_passwords;
  /* Some items we allow, which are not available in mysql client */
  char* opt_bind_as_utf8;              /* for MYSQL_OPT_BIND */
  char* opt_connect_attr_delete_as_utf8;  /* for MYSQL_OPT_CONNECT_ATTR_DELETE */
  unsigned short int opt_connect_attr_reset; /* for MYSQL_OPT_CONNECT_ATTR_RESET */
  char* read_default_file_as_utf8; /* for MYSQL_READ_DEFAULT_FILE */
  char* read_default_group_as_utf8;/* for MYSQL_READ_DEFAULT_GROUP */
  unsigned int opt_read_timeout;          /* for MYSQL_OPT_READ_TIMEOUT */
  unsigned short int report_data_truncation; /* for MYSQL_REPORT_DATA_TRUNCATION */
  unsigned short int opt_use_result; /* for MYSQL_OPT_USE_RESULT */
  /* It's easy to increase grid_tabs so more multi results are seen but don't make it ridiculous. */
  unsigned short int grid_tabs;
  unsigned short int grid_actual_tabs; /* Todo: move this, it's not an option. */
  unsigned short int client_side_functions;
  unsigned short int completer_timeout;
  char shortcut_connect[80];
  char shortcut_exit[80];
  char shortcut_undo[80];
  char shortcut_redo[80];
  char shortcut_cut[80];
  char shortcut_copy[80];
  char shortcut_paste[80];
  char shortcut_select_all[80];
  char shortcut_history_markup_previous[80];
  char shortcut_history_markup_next[80];
  char shortcut_format[80];
  char shortcut_zoomin[80];
  char shortcut_zoomout[80];
  char shortcut_autocomplete[80];
  char shortcut_find[80];
  char shortcut_execute[80];
  char shortcut_kill[80];
  char shortcut_next_window[80];
  char shortcut_previous_window[80];
#if (OCELOT_MYSQL_DEBUGGER == 1)
  char shortcut_breakpoint[80];
  char shortcut_continue[80];
  char shortcut_next[80];
  char shortcut_step[80];
  char shortcut_clear[80];
  char shortcut_debug_exit[80];
  char shortcut_information[80];
  char shortcut_refresh_server_variables[80];
  char shortcut_refresh_user_variables[80];
  char shortcut_refresh_variables[80];
  char shortcut_refresh_call_stack[80];
#endif
  char shortcut_batch[80];
  char shortcut_chart_bar[80];
  char shortcut_chart_line[80];
  char shortcut_chart_none[80];
  char shortcut_chart_pie[80];
  char shortcut_horizontal[80];
  char shortcut_html[80];
  char shortcut_htmlraw[80];
  char shortcut_raw[80];
  char shortcut_vertical[80];
  char shortcut_xml[80];
  /* Some items we allow, but the reasons we allow them are lost in the mists of time */
  /* I gather that one is supposed to read the charset file. I don't think we do. */
  unsigned short opt_named_pipe;          /* for MYSQL_OPT_NAMED_PIPE */
  unsigned int opt_write_timeout; /* for MYSQL_OPT_WRITE_TIMEOUT */
  unsigned char detach_history_widget; /* was bool */
  unsigned char detach_result_grid_widget; /* was bool */
#if (OCELOT_MYSQL_DEBUGGER == 1)
  unsigned char detach_debug_widget; /* WAs bool */
#endif
  unsigned char detach_statement_edit_widget; /* was bool */
#if (OCELOT_EXPLORER == 1)
  unsigned char detach_explorer_widget; /* was bool */
#endif
};

#if (OCELOT_PLUGIN == 1)
/* Possible values of the name when calling a plugin. */
#define PLUGIN_AT_PROGRAM_START 0
#define PLUGIN_MAKE_MENU 1
#define PLUGIN_BEFORE_INSERT 2
#define PLUGIN_REAL_QUERY 3 /* almost immediately before passing (char*) dbms_query to the server */
#define PLUGIN_ERROR_MESSAGE 4
#define PLUGIN_EXECUTE_ONE_STATEMENT 5
#define PLUGIN_TEXT_CHANGED 6
#define PLUGIN_FILLUP 7
#define PLUGIN_DISPLAY_HTML 8
#define PLUGIN_MENU_ACTION 9
#define PLUGIN_ALL 10
#define PLUGIN_MAX 10
#define PLUGIN_MENU_CHOICE -1

/* Possible values that a plugin can return */
/* Todo: we might need more values for: skip, ignore, not-ok, not-ok-and-replaced */
#define PLUGIN_RETURN_OK 0
#define PLUGIN_RETURN_OK_AND_REPLACED 1 /* plugin returns this on if it has set a new value in replacer_buffer */
#define PLUGIN_RETURN_SKIP 2

#if (OCELOT_PLUGIN == 1)
struct plugin_keywords {
   char chars[24];
   unsigned short int token_keyword;
};

static const struct plugin_keywords plugin_strvalues[]=
   {
     {"at_program_start",  PLUGIN_AT_PROGRAM_START},
     {"make_menu", PLUGIN_MAKE_MENU},
     {"before_insert",  PLUGIN_BEFORE_INSERT},
     {"real_query", PLUGIN_REAL_QUERY},
     {"error_message", PLUGIN_ERROR_MESSAGE},
     {"execute_one_statement", PLUGIN_EXECUTE_ONE_STATEMENT},
     {"text_changed", PLUGIN_TEXT_CHANGED},
     {"fillup", PLUGIN_FILLUP},
     {"display_html", PLUGIN_DISPLAY_HTML},
     {"menu_action", PLUGIN_MENU_ACTION},
     {"all", PLUGIN_ALL}
};
#endif

struct plugin_pass {
  int type; /* e.g. PLUGIN_AT_PROGRAM_START */
  struct connect_arguments *ca;
  char id[32];
  char *query;
  char *error_message;
  int replacer_buffer_length;
  char *replacer_buffer;
  /* Lots of room to add more! */
  /* good idea to include plugin version number */
  char *result_set_copy;
  long unsigned int result_row_count;
  unsigned int result_column_count;
  char *display;
  int subtype;
};

#endif

/* Everything before this can be included in either a a .c or .cpp program. For everything after this, must be .cpp. */
#ifdef __cplusplus

#ifndef MAINWINDOW_H
#define MAINWINDOW_H

/* All Qt includes go here. Most of them could be handled by just saying "#include <QtWidgets>". */
#include <QAbstractItemView>
#ifdef _WIN32
#include <QApplication>
#endif
#include <QBuffer>             /* only needed for pasting pixmaps to QByteArray */
#include <QClipboard>
#include <QComboBox>
#include <QDateTime>
#include <QDialog>
#include <QDir>
#include <QElapsedTimer>        /* only needed for log(), and even for that it's not needed much */
#include <QFrame>
#include <QHBoxLayout>
#include <QLabel>
#include <QSpinBox>
#ifdef _WIN32
#include <QLibrary>
#endif
//#include <QLibraryInfo>
#include <QLineEdit>
#include <QMainWindow>
#include <QMessageBox>
#include <QPainter>
#include <QPlainTextEdit>
#include <QPushButton>
#include <QScrollArea>
#include <QScrollBar>
#include <QTextBlock>
#include <QTextEdit>
#include <QThread>
#include <QTimer>
//#include <QWidget>
#include <QTextStream>
#if (QT_VERSION >= 0x50000)
#include <QGuiApplication>
#include <QScreen>
#include <QRegularExpression>
#else
#include <QDesktopWidget>
#endif
#if (OCELOT_FIND_WIDGET == 1)
#include <QToolButton>
#endif
#if (OCELOT_IMPORT_EXPORT == 1)
#include <QActionGroup>
#endif


/* QRegExp is unavailable in Qt 6. Todo: We have never tested the replacement QRegularExpression code. */
#if (QT_VERSION < 0x60000)
#include <QRegExp>
#endif

#if (OCELOT_IMPORT_EXPORT == 1)
#endif

#if (OCELOT_MYSQL_INCLUDE == 1)
/*
  Several possible include paths for mysql.h are hard coded in ocelotgui.pro.
  CMakeLists.txt has a similar list but can be overridden with -DMYSQL_INCLUDE_DIR or -DOCELOT_MYSQL_INCLUDE.
  If mysql_config --help says /usr/include/mysql one can say #include <mysql/mysql.h> but that's not general.
*/
#include <mysql.h>
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)

/*
  my_bool might not be in mysql.h due to https://bugs.mysql.com/bug.php?id=85131
  MariaDB: my_bool STDCALL mysql_more_results(MYSQL *mysql);
  MySQL:   bool STDCALL mysql_more_results(MYSQL *mysql);
  I cannot use ifndef to see whether my_bool was used, it is a typedef.
  So I will use MY_BOOL instead of my_bool or bool, for mysql_more_results.
*/
typedef char MY_BOOL;

/* Strangely MYSQL_PORT might not be brought in by #include <mysql.h> */
/* Now in MariaDB there's a MARIADB_PORT, but it's 3306 anyway. */
#ifndef MYSQL_PORT
#define MYSQL_PORT 3306
#endif

/*
  Linux-specific:
  We use dlopen() when opening libmysqlclient.so and libcrypto.so, therefore include dlfcn.h.
  We use dlinfo() to find the libmysqlclient file name for help|about, therefore include link.h.
  We use readlink() when checking if histfile links to dev/null, therefore include unistd.h.
  We use getpwuid() when getting password, therefore include pwd.h.
  We use pthread_create() for debug and kill, therefore include pthread.h.
  We use stat() to see if a configuration file is world-writable, therefore include stat.h.
  Todo: There was no error when I didn't do this for FreeBSD. Is it using Qt library and surviving?
*/
#if (defined(OCELOT_OS_LINUX) || defined(OCELOT_OS_FREEBSD))
#include <dlfcn.h>
#if (OCELOT_STATIC_LIBRARY == 0)
#include <link.h>
#endif
#include <unistd.h>
#include <pwd.h>
#include <pthread.h>
#include <sys/stat.h>
#endif

#if (OCELOT_QWT_INCLUDE == 1)
#include <qwt/qwt_column_symbol.h>
#include <qwt/qwt_legend.h>
#include <qwt/qwt_painter.h>
#include <qwt/qwt_plot.h>
#include <qwt/qwt_plot_canvas.h>
#include <qwt/qwt_plot_curve.h>
#include <qwt/qwt_plot_layout.h>
#include <qwt/qwt_plot_multi_barchart.h>
#include <qwt/qwt_scale_widget.h>
//A#include <qwt/qwt_symbol.h>
//A#include <qwt/qwt_thermo.h>
#endif

#if (OCELOT_IMPORT_EXPORT == 1)
struct export_settings {
  int type; /* e.g. 0 | TOKEN_KEYWORD_TEXT | TOKEN_KEYWORD_TABLE | TOKEN_KEYWORD_HTML etc. */
  QString file_name;
  QByteArray columns_terminated_by;
  QByteArray columns_enclosed_by;
  bool columns_optionally;
  QByteArray columns_escaped_by;
  QByteArray lines_starting_by;
  QByteArray lines_terminated_by;
  long unsigned max_row_count;
  bool column_names;
  bool query;
  bool row_count;
  short int margin;
  bool pad;
  bool last;  /* not user-changeable yet *//* does last column get a terminated-by? */
  bool divider;  /* not user-changeable yet *//* divider line e.g. +---+---+? */
  QByteArray if_null;
  QByteArray replace_string, with_string;
  QByteArray if_file_exists;
};
#endif

#if (OCELOT_EXPLORER == 1)
struct explorer_items {   /* This struct definition is for MainWindow and ResultGrid */
  QByteArray object_type; /* e.g. 'T' or 'C' */
  QByteArray schema_name; /* e.g. table_schema */
  QByteArray object_name; /* e.g. table name */
  QByteArray part_name;   /* e.g. column name */
  QByteArray part_type;   /* e.g. column type */
  QByteArray part_extra;  /* e.g. column_name of an index */ /* TODO: Not it isn't! Is it ever used? */
  char flags;             /* e.g. EXPLORER_FLAG_MIN != 0 if minimized "S" or "T" or "V" */
  int display_row_number; /* number within the display. equals -1 if skippable */
};
struct explorer_items_fk {   /* For ERDiagram */
  QByteArray schema_name;
  QByteArray table_name;
  QByteArray column_name;
  QByteArray ordinal_position;
  QByteArray referenced_table_name;
  QByteArray referenced_column_name;
  QByteArray constraint_name;
};
#endif

#ifdef DBMS_TARANTOOL

#if (OCELOT_THIRD_PARTY==1)
#include "third_party.h"
#else
#include <math.h>
/*
  Definitions of tnt_opt_type and tnt_reply are taken from tarantool-c.
  Although there is no copyright, there is a request for an AS IS notice (which is done)
*/
  enum tnt_opt_type {
          TNT_OPT_URI,
          TNT_OPT_TMOUT_CONNECT,
          TNT_OPT_TMOUT_RECV,
          TNT_OPT_TMOUT_SEND,
          TNT_OPT_SEND_CB,
          TNT_OPT_SEND_CBV,
          TNT_OPT_SEND_CB_ARG,
          TNT_OPT_SEND_BUF,
          TNT_OPT_RECV_CB,
          TNT_OPT_RECV_CB_ARG,
          TNT_OPT_RECV_BUF
  };
  struct tnt_reply {
          int alloc;
          uint64_t bitmap;
          const char *buf;
          size_t buf_size;
          uint64_t code;
          uint64_t sync;
          uint64_t schema_id;
          const char *error;
          const char *error_end;
          const char *data;
          const char *data_end;
          const char *metadata; /* new */
          const char *metadata_end; /* new */
          const char *sqlinfo; /* new */
          const char *sqlinfo_end; /* new */
  };
  /* Amazing but true: write_request was silently added after release! */
  struct tnt_stream {
          int alloc; /*!< Allocation mark */
          ssize_t (*write)(struct tnt_stream *s, const char *buf, size_t size); /*!< write to buffer function */
          ssize_t (*writev)(struct tnt_stream *s, struct iovec *iov, int count); /*!< writev function */
          ssize_t (*write_request)(struct tnt_stream *s, struct tnt_request *r, uint64_t *sync); /*!< write request function */
          ssize_t (*read)(struct tnt_stream *s, char *buf, size_t size); /*!< read from buffer function */
          int (*read_reply)(struct tnt_stream *s, struct tnt_reply *r); /*!< read reply from buffer */
          void (*free)(struct tnt_stream *s); /*!< free custom buffer types (destructor) */
          void *data; /*!< subclass data */
          uint32_t wrcnt; /*!< count of write operations */
          uint64_t reqid; /*!< request id of current operation */
  };

  enum  	mp_type {
    MP_NIL = 0, MP_UINT, MP_INT, MP_STR,
    MP_BIN, MP_ARRAY, MP_MAP, MP_BOOL,
    MP_FLOAT, MP_DOUBLE, MP_EXT
  };
  /**
   * \brief Request types
   */
  enum tnt_request_t {
      TNT_OP_SELECT = 1,
      TNT_OP_INSERT = 2,
      TNT_OP_REPLACE = 3,
      TNT_OP_UPDATE = 4,
      TNT_OP_DELETE = 5,
      TNT_OP_CALL = 6,
      TNT_OP_AUTH = 7,
      TNT_OP_EVAL = 8,
      TNT_OP_UPSERT = 9,
      TNT_OP_PING = 64,
      TNT_OP_JOIN = 65,
      TNT_OP_SUBSCRIBE = 66
  };
  /**
   * \brief Iterator types
   */
  enum tnt_iterator_t {
      TNT_ITER_EQ = 0,
      TNT_ITER_REQ,
      TNT_ITER_ALL,
      TNT_ITER_LT,
      TNT_ITER_LE,
      TNT_ITER_GE,
      TNT_ITER_GT,
      TNT_ITER_BITS_ALL_SET,
      TNT_ITER_BITS_ANY_SET,
      TNT_ITER_BITS_ALL_NOT_SET,
      TNT_ITER_OVERLAP,
      TNT_ITER_NEIGHBOR,
  };
  struct tnt_request {
      struct {
          uint32_t sync; /*!< Request sync id. Generated when encoded */
          enum tnt_request_t type; /*!< Request type */
      } hdr; /*!< fields for header */
      uint32_t space_id; /*!< Space number */
      uint32_t index_id; /*!< Index number */
      uint32_t offset; /*!< Offset for select */
      uint32_t limit; /*!< Limit for select */
      enum tnt_iterator_t iterator; /*!< Iterator for select */
      /* Search key, proc name or eval expression */
      const char *key; /*!< Pointer for
                * key for select/update/delete,
                * procedure  for call,
                * expression for eval,
                * operations for upsert
                */
      const char *key_end;
      struct tnt_stream *key_object; /*!< Pointer for key object
                      * if allocated inside requests
                      * functions
                      */
      const char *tuple; /*!< Pointer for
                  * tuple for insert/replace,
                  * ops for update
                  * default tuple for upsert,
                  * args for eval/call
                  */
      const char *tuple_end;
      struct tnt_stream *tuple_object; /*!< Pointer for tuple object
                        * if allocated inside requests
                        * functions
                        */
      int index_base; /*!< field offset for UPDATE */
      int alloc; /*!< allocation mark */
  };
  enum tnt_error {
      TNT_EOK, /*!< Everything is OK */
      TNT_EFAIL, /*!< Fail */
      TNT_EMEMORY, /*!< Memory allocation failed */
      TNT_ESYSTEM, /*!< System error */
      TNT_EBIG, /*!< Buffer is too big */
      TNT_ESIZE, /*!< Bad buffer size */
      TNT_ERESOLVE, /*!< gethostbyname(2) failed */
      TNT_ETMOUT, /*!< Operation timeout */
      TNT_EBADVAL, /*!< Bad argument (value) */
      TNT_ELOGIN, /*!< Failed to login */
      TNT_LAST /*!< Not an error */
  };
#endif

#endif

/* Flags used for row_form_box. NUM_FLAG is also defined in mysql include, with same value. */
#define READONLY_FLAG 1
#define NUM_FLAG 32768

/*
  Most ocelot_ variables are in ocelotgui.cpp but if one is required by ocelotgui.h, say so here.
  Weirdly, ocelotgui.h is included in two places, ocelotgui.pro + ocelotgui.cpp,
  so say 'static' if you do that.
*/

/*
  Names of ostrings.h variables and pseudo-constants include:
  extern const char *menu_strings[];
  MENU_STATEMENT_TEXT_COLOR MENU_STATEMENT_BACKGROUND_COLOR MENU_STATEMENT_HIGHLIGHT_LITERAL_COLOR
  MENU_STATEMENT_HIGHLIGHT_IDENTIFIER_COLOR MENU_STATEMENT_HIGHLIGHT_COMMENT_COLOR MENU_STATEMENT_HIGHLIGHT_OPERATOR_COLOR
  MENU_STATEMENT_HIGHLIGHT_KEYWORD_COLOR MENU_STATEMENT_PROMPT_BACKGROUND_COLOR MENU_STATEMENT_BORDER_COLOR
  MENU_STATEMENT_HIGHLIGHT_CURRENT_LINE_COLOR MENU_STATEMENT_HIGHLIGHT_FUNCTION_COLOR MENU_GRID_TEXT_COLOR
  MENU_GRID_BACKGROUND_COLOR MENU_GRID_CELL_BORDER_COLOR MENU_GRID_OUTER_COLOR MENU_GRID_HEADER_BACKGROUND_COLOR
  MENU_GRID_FOCUS_CELL_BACKGROUND_COLOR MENU_GRID_CELL_HEIGHT MENU_GRID_CELL_BORDER_SIZE MENU_GRID_CELL_WIDTH
  MENU_GRID_TEXT_COLOR MENU_GRID_BACKGROUND_COLOR MENU_HISTORY_TEXT_COLOR MENU_HISTORY_BACKGROUND_COLOR
  MENU_HISTORY_BORDER_COLOR MENU_MENU_TEXT_COLOR MENU_MENU_BACKGROUND_COLOR MENU_MENU_BORDER_COLOR
  MENU_FONT MENU_MAX_ROW_COUNT MENU_SYNTAX_CHECKER MENU_DETACHED MENU_TOP MENU_LEFT MENU_WIDTH MENU_HEIGHT
  MENU_CONDITION MENU_DISPLAY_AS MENU_CANCEL MENU_OK MENU_SETTINGS_FOR_MENU MENU_SETTINGS_FOR_HISTORY
  MENU_SETTINGS_FOR_GRID MENU_SETTINGS_FOR_STATEMENT MENU_SETTINGS_FOR_DEBUG MENU_SETTINGS_FOR_EXTRA_RULE_1
  MENU_SETTINGS_FOR_EXPLORER MENU_GRID_HTML_EFFECTS (was for font dialog, but since version 1.5 we don't call QFontDialog)
*/
//extern unsigned int menu_off;

//extern unsigned int dbms_version_mask;

#if (OCELOT_IMPORT_EXPORT == 1)
//extern struct export_settings main_exports;
#endif

namespace Ui
{
class MainWindow;
}

QT_BEGIN_NAMESPACE
//class QAction;
//class QLabel;
//class QMenu;
//class QMenuBar;
//class QComboBox;
//class QPushButton;
//class QTextEdit;
//class QPlainTextEdit;
//class QScrollArea;
//class QVBoxLayout;
class CodeEditor;
class ResultGrid;
class Settings;
class QComboBoxInSettings;
#ifdef OLD_STUFF
class TextEditFrame;
class TextEditWidget;
#endif
class QScrollAreaWithSize;
class QThread48;
class QTabWidget48;
class TextEditHistory;
class TextEditWidget2;
class XSettings;
class Completer_widget;
class C_widget;
class Messagebox_flash;
#if (OCELOT_FIND_WIDGET == 1)
class Find_widget;
#endif
class Result_qtextedit;
class Result_changes;
#if (OCELOT_EXPLORER == 1)
class Small_dialog_box;
class Context_menu;
#endif
#if (OCELOT_CHART == 1)
class Chart;
#endif
#if (OCELOT_QWT_INCLUDE == 1)
class QChart;
#endif
#if (OCELOT_PLUGIN == 1)
class Plugin;
#endif

QT_END_NAMESPACE

class MainWindow : public QMainWindow
{
  Q_OBJECT

public:
  explicit MainWindow(int argc, char *argv[], QWidget *parent= 0);
  ~MainWindow();

  /*
    Client variables
    Client variables can be changed via Settings menu or via SET statements.
    Client variables have the prefix 'ocelot_'.
    Every client variable has an item on the Settings menu,
    and most may be changed with the SET statement. For example,
    ocelot_grid_outer_color is on menu item Settings | Grid Widget,
    SET ocelot_grid_outer_color = value; will change.
    The important thing is: if it's changed on the Settings menu, then
    a SET statement is generated, so that can be saved and replayed.
    Naming convention: ocelot_ + settings-menu-item + object + color|size|font.
    Todo: (unlikely) pass it on to the server, without interfering with ordinary SET statements.
    Todo: use keywords.
    Todo: allow SET ocelot_... = DEFAULT
    Todo: need a more flexible parser, eventually.
    Todo: should it be optional whether such statements go to history?
    Todo: do not consider it an error if you're not connected but it's a SET statement
    Todo: make sure it's a valid setting
    Todo: pay attention to the delimiter
    Todo: what should happen if the SET fails?
    Todo: isValid() check
    Todo: rename the Settings menu items and let the prompts match the names
    Todo: there is also  Qt way to save current settings, maybe it's another option
    Todo: menu item = "save settings" which would put a file in ~/ocelot.ini or ~/.my.cnf
    Todo: a single big setting
    Todo: a comment e.g. / *! OCELOT CLIENT * / meaning do not pass to server
    Problem: you cannot muck statement itself because menu might be changed while statement is up
    See also: Client variables that can be changed with the Settings widget
    Todo: Shouldn't client variables be in statement widget?
    Todo: (bug) If I change grid color or font weight or font style
          via the settings menu, the effect is immediate. But if I change
          them by executing SET ..., the effect is delayed, until the
          next time I type something or bring up a menu. I believe this
          is happening because going to settings menu will invalidate the
          grid widget area so it gets repainted; however, explicitly
          saying update() or repaint() solves nothing -- only hide()
          and show() force the widget change to be immediate.
          For other widgets I have kludged around similar problems,
          but I fear that I'm repainting multiple times unnecessarily.
  */
  QString ocelot_statement_text_color, new_ocelot_statement_text_color;
  QString ocelot_statement_background_color, new_ocelot_statement_background_color;
  QString ocelot_statement_border_color, new_ocelot_statement_border_color;
  QString ocelot_statement_font_family, new_ocelot_statement_font_family;
  QString ocelot_statement_font_size, new_ocelot_statement_font_size;
  QString ocelot_statement_font_style, new_ocelot_statement_font_style;
  QString ocelot_statement_font_weight, new_ocelot_statement_font_weight;
  QString ocelot_statement_highlight_literal_color, new_ocelot_statement_highlight_literal_color;
  QString ocelot_statement_highlight_identifier_color, new_ocelot_statement_highlight_identifier_color;
  QString ocelot_statement_highlight_comment_color, new_ocelot_statement_highlight_comment_color;
  QString ocelot_statement_highlight_operator_color, new_ocelot_statement_highlight_operator_color;
  QString ocelot_statement_highlight_keyword_color, new_ocelot_statement_highlight_keyword_color;
  QString ocelot_statement_prompt_background_color, new_ocelot_statement_prompt_background_color;
  QString ocelot_statement_highlight_current_line_color, new_ocelot_statement_highlight_current_line_color;
  QString ocelot_statement_highlight_function_color, new_ocelot_statement_highlight_function_color;
  QString ocelot_statement_syntax_checker, new_ocelot_statement_syntax_checker;
  QString ocelot_statement_style_string;
  QString ocelot_statement_format_statement_indent;
  QString ocelot_statement_format_clause_indent;
  QString ocelot_statement_format_rule;
  QString ocelot_statement_height, new_ocelot_statement_height;
  QString ocelot_statement_left, new_ocelot_statement_left;
  QString ocelot_statement_top, new_ocelot_statement_top;
  QString ocelot_statement_width, new_ocelot_statement_width;
  QString ocelot_statement_detached, new_ocelot_statement_detached;
  QString ocelot_debug_height, new_ocelot_debug_height;
  QString ocelot_debug_left, new_ocelot_debug_left;
  QString ocelot_debug_top, new_ocelot_debug_top;
  QString ocelot_debug_width, new_ocelot_debug_width;
  QString ocelot_debug_detached, new_ocelot_debug_detached;
/* if (OCELOT_EXPLORER == 1) */
  QString ocelot_explorer_style_string;
  QString ocelot_explorer_height, new_ocelot_explorer_height;
  QString ocelot_explorer_left, new_ocelot_explorer_left;
  QString ocelot_explorer_top, new_ocelot_explorer_top;
  QString ocelot_explorer_width, new_ocelot_explorer_width;
  QString ocelot_explorer_detached, new_ocelot_explorer_detached;
  QString ocelot_explorer_visible, new_ocelot_explorer_visible;
  QString ocelot_explorer_sort, new_ocelot_explorer_sort; /* todo: make changeable on command line like others */
  QString ocelot_explorer_query, new_ocelot_explorer_query;
  QString ocelot_explorer_text_color, new_ocelot_explorer_text_color;
  QString ocelot_explorer_background_color, new_ocelot_explorer_background_color;
  QString ocelot_explorer_font_family, new_ocelot_explorer_font_family;
  QString ocelot_explorer_font_size, new_ocelot_explorer_font_size;
  QString ocelot_explorer_font_style, new_ocelot_explorer_font_style;
  QString ocelot_explorer_font_weight, new_ocelot_explorer_font_weight;
/* endif */
  QString ocelot_grid_text_color, new_ocelot_grid_text_color;
  QString ocelot_grid_background_color, new_ocelot_grid_background_color;
  QString ocelot_grid_focus_cell_background_color, new_ocelot_grid_focus_cell_background_color;
  QString ocelot_grid_header_background_color, new_ocelot_grid_header_background_color;
  QString ocelot_grid_font_family, new_ocelot_grid_font_family;
  QString ocelot_grid_font_size, new_ocelot_grid_font_size;
  QString ocelot_grid_font_style, new_ocelot_grid_font_style;
  QString ocelot_grid_font_weight, new_ocelot_grid_font_weight;
  QString ocelot_grid_cell_border_color, new_ocelot_grid_cell_border_color;
  QString ocelot_grid_outer_color, new_ocelot_grid_outer_color;
  QString ocelot_grid_cell_border_size, new_ocelot_grid_cell_border_size;
//  QString ocelot_grid_cell_drag_line_size, new_ocelot_grid_cell_drag_line_size; /* no longer used */
  QString ocelot_grid_cell_height, new_ocelot_grid_cell_height;
  QString ocelot_grid_cell_width, new_ocelot_grid_cell_width;
  QString ocelot_grid_style_string;
  QString ocelot_grid_header_style_string;
  QString ocelot_grid_height, new_ocelot_grid_height;
  QString ocelot_grid_left, new_ocelot_grid_left;
  QString ocelot_grid_top, new_ocelot_grid_top;
  QString ocelot_grid_width, new_ocelot_grid_width;
  QString ocelot_grid_html_effects, new_ocelot_grid_html_effects;
  QString ocelot_grid_detached, new_ocelot_grid_detached;
  QString ocelot_grid_chart, new_ocelot_grid_chart;
  QString ocelot_extra_rule_1_background_color, new_ocelot_extra_rule_1_background_color;
  QString ocelot_extra_rule_1_text_color, new_ocelot_extra_rule_1_text_color;
  QString ocelot_extra_rule_1_condition, new_ocelot_extra_rule_1_condition;
  QString ocelot_extra_rule_1_display_as, new_ocelot_extra_rule_1_display_as;
  QString ocelot_extra_rule_1_style_string;
  QString ocelot_history_text_color, new_ocelot_history_text_color;
  QString ocelot_history_background_color, new_ocelot_history_background_color;
  QString ocelot_history_border_color, new_ocelot_history_border_color;
  QString ocelot_history_font_family, new_ocelot_history_font_family;
  QString ocelot_history_font_size, new_ocelot_history_font_size;
  QString ocelot_history_font_style, new_ocelot_history_font_style;
  QString ocelot_history_font_weight, new_ocelot_history_font_weight;
  QString ocelot_history_style_string;
  QString ocelot_history_height, new_ocelot_history_height;
  QString ocelot_history_left, new_ocelot_history_left;
  QString ocelot_history_top, new_ocelot_history_top;
  QString ocelot_history_width, new_ocelot_history_width;
  QString ocelot_history_max_row_count, new_ocelot_history_max_row_count;
  QString ocelot_history_detached, new_ocelot_history_detached;
  QString ocelot_histfileflags;
  QString ocelot_histfilesize;
  QString ocelot_histsize;
  QString ocelot_menu_text_color, new_ocelot_menu_text_color;
  QString ocelot_menu_background_color, new_ocelot_menu_background_color;
  QString ocelot_menu_border_color, new_ocelot_menu_border_color;
  QString ocelot_menu_font_family, new_ocelot_menu_font_family;
  QString ocelot_menu_font_size, new_ocelot_menu_font_size;
  QString ocelot_menu_font_style, new_ocelot_menu_font_style;
  QString ocelot_menu_font_weight, new_ocelot_menu_font_weight;
  QString ocelot_menu_style_string;
  QString ocelot_explorer_action;
  QString ocelot_explorer_text;

  QStringList conditional_settings;

  QString ocelot_language;

  /* Strings for CONNECT. Some of these will be converted e.g. ocelot_host to ocelot_host_as_utf8 */
  QString ocelot_histignore;
  QString ocelot_host;
  QString ocelot_database;
  QString ocelot_user;
  QString ocelot_password;
  QString ocelot_unix_socket;
  QString ocelot_default_auth;
  QString ocelot_init_command;
  QString ocelot_opt_bind;
  QString ocelot_bind_address; /* Todo: check: is this the same as ocelot_opt_bind? */
  QString ocelot_opt_connect_attr_delete;
  QString ocelot_debug;
  QString ocelot_execute;
  QString ocelot_ld_run_path;
  QString ocelot_login_path;
  QString ocelot_opt_lua;
  QString ocelot_opt_ssl;
  QString ocelot_opt_ssl_ca;
  QString ocelot_opt_ssl_capath;
  QString ocelot_opt_ssl_cert;
  QString ocelot_opt_ssl_cipher;
  QString ocelot_opt_ssl_crl;
  QString ocelot_opt_ssl_crlpath;
  QString ocelot_opt_ssl_key;
  QString ocelot_opt_ssl_mode;
  QString ocelot_pager;
  QString ocelot_plugin_dir;
  QString ocelot_read_default_file;
  QString ocelot_read_default_group;
  QString ocelot_server_public_key;
  QString ocelot_set_charset_dir;
  QString ocelot_set_charset_name;           /* was: ocelot_default_character_set */
  QString ocelot_shared_memory_base_name;
  QString ocelot_protocol;
  //unsigned short ocelot_no_defaults;         /* for CONNECT */
  QString ocelot_defaults_file;              /* for CONNECT */
  QString ocelot_defaults_extra_file;        /* for CONNECT */
  QString ocelot_defaults_group_suffix;
  QString ocelot_prompt;
  QString ocelot_opt_ssl_verify;
  QString options_files_read;

  QList<QString> q_color_list;
  QString q_color_list_name(QString rgb_name);
  QString qt_color(QString);
  QString rgb_to_color(QString);
  QString canonical_color_name(QString);
  void assign_names_for_colors();
  QString canonical_font_weight(QString);
  int fontweights_index_via_chars(QString);
  int fontweights_index_via_qt_number(int);
  int fontweights_index_via_css_number(int);
  QString canonical_font_family(QString,QString*);
  QString canonical_font_style(QString,QString);
  QString connect_stripper(QString value_to_strip, bool strip_doublets_flag);
  QString connect_unstripper(QString value_to_unstrip);
  /* Following were moved from 'private:', merely so all client variables could be together. Cannot be used with SET. */

  QString ocelot_dbms;                    /* for CONNECT */
  unsigned int ocelot_grid_max_row_lines;          /* ?? should be unsigned long? */
  /* unsigned int ocelot_grid_max_desired_width_in_chars; */

  QString history_markup_statement_start;    /* for markup */
  QString history_markup_statement_end;      /* for markup */
  QString history_markup_prompt_start;       /* for markup */
  QString history_markup_prompt_end;         /* for markup */
  QString history_markup_result;             /* for markup */
  QString history_markup_entity;             /* for markup */

  QString ocelot_history_tee_file_name;      /* see comment=tee+hist */
  QFile ocelot_history_tee_file;             /* see comment=tee+hist */
  QString ocelot_history_hist_file_name;     /* see comment=tee+hist */
  QFile ocelot_history_hist_file;            /* see comment=tee+hist */
  CodeEditor *statement_edit_widget;

  int position_for_redo;
  int chars_added_for_redo;
  int chars_removed_for_redo;

  QStringList tarantool_statements_in_begin;

  struct menu_function_struct {
    QString name;
    bool is_plugin;
    void (MainWindow::*p_method)(bool);/* e.g. &MainWindow::file_connect */
    int *func; /* this presumably will be useful for a C plugin */
  };
#define MENU_SPEC_TYPE_MENU 0
#define MENU_SPEC_TYPE_MENUITEM 1
#define MENU_SPEC_TYPE_SUBMENU 2
#define MENU_SPEC_TYPE_SEPARATOR 4
  struct menu_spec_struct {
      QString id; /* names an action e.g. "file_connect" (by convention it matches method name) */ /* or names a menu */
      int menu_type; /* 0=menu, 1=menu_item; 2=menu_item containing submenu; 3=submenu_item; 4=separator */
      QString menu_title;  /* e.g. "File' */
      QString menu_item;   /* e.g. "Connect" */
      QString submenu_item;/* unused */
      QString shortcut;    /* e.g. "" */
      QString menu_name;   /* e.g. "menu_file" */ /* better name = upper_id? or id_of_menu? */
      QMenu *qmenu;
      QAction *qaction;      /* filled in after qAction* new() */
      QString action;      /* = name associated with p_method void (MainWindow::*p_method)(bool);, can be / defaults to same as id */
      QString shortcut_default; /* what to use if user enters "default" */
      int keyword; /* e.g. TOKEN_KEYWORD_SHORTCUT_UNDO, though that should eventually become obsolete */
      QString reserved; /* unused */
  };
  QList<struct menu_function_struct> menu_function_struct_list;
  QList<struct menu_spec_struct> menu_spec_struct_list;
  QList<QMenu> menu_spec_menu_list;
  void menu_spec_make_function(); void menu_spec_make_menu(); void menu_spec_reset_menu();
  int menu_spec_insert_one(QString id, QString menu_name, QString menuitem_name, QString action);
  QMenu* menu_spec_add_menu(int i); QAction *menu_spec_add_action(int i, QMenu *qmenu);
#if (QT_VERSION >= 0x50000)
  void menu_about_to_show();
#endif
//  void menu_spec_set_addresses();
  QMenu* menu_spec_find_menu(QString menu_name);
  int menu_spec_find_id(QString id);
  int menu_spec_delete_via_id(QString id);
  QAction* menu_spec_find_action(QString action_name);
  void menu_set_enabled(QString menu_id, bool is_enable_or_disable);
  int main_window_maximum_width;
  int main_window_maximum_height;

  struct widgets_struct {
    QString main_class;
    QString subclass;
    QString subsubclass;
    QString subcontrol;
    QString state;
    QString properties;
  };
  QList<struct widgets_struct> wsl;

  void component_size_calc(int *character_height, int *borders_height);
  QFont get_font_from_style_sheet(QString style_string);
  QString get_color_from_style_sheet(QString style_string);
  QString get_background_color_from_style_sheet(QString style_string);
#if (OCELOT_DIALOG == 1)
  void set_dialog_style_sheet(); void enact_dialog_style_sheet();
#endif
  void set_dbms_version_mask(QString, int);
  int next_i(int, int);
  int next_i_v(int, int, int token_types[], int token_lengths[]);
  bool get_sql_mode(int who_is_calling, QString text, bool is_in_hparse, int start_token_number);
  QString get_doc_path(QString);
  void hparse_f_nexttoken();
  void hparse_f_next_nexttoken();
  void hparse_f_error();
  bool hparse_f_is_equal(QString,QString);
  bool hparse_f_is_special_verb(int);
  int hparse_f_accept(unsigned int,unsigned char,int,QString);
  //int hparse_f_accept_key(int);
  int hparse_f_acceptn(int,QString,int);
  int hparse_f_acceptf(int pass_number, QString replacee);
  int hparse_f_accept_in_set(unsigned int,QStringList, int *i_of_matched);
  int hparse_f_accept_slave_or_replica(unsigned int flag_version);
  int hparse_f_accept_slaves_or_replicas(unsigned int flag_version);
  /* void hparse_f_expected_initialize(); Removed 2024-07-23 */
  void hparse_f_expected_clear();
  int hparse_f_expected_exact(int reftype);
  void hparse_f_expected_append(QString token, unsigned char reftype, int proposed_type);
  void hparse_f_expected_append_endquote(QString token);
  QString hparse_f_token_to_appendee(QString,int,char);
  int hparse_f_expect(unsigned int,unsigned char,int,QString);
  int hparse_f_literal(unsigned char,unsigned int,int);
  int hparse_f_default(int,bool);
  int hparse_f_user_or_role_name(int);
  int hparse_f_character_set_name();
  int hparse_f_collation_name();
  int hparse_f_qualified_name_with_star();
  int hparse_f_qualified_name_of_object(unsigned int,int,int);
  int hparse_f_qualified_name_of_object_with_star(int,int);
  int hparse_f_e_to_reftype(int);
  int hparse_f_accept_qualifier(unsigned int,unsigned char,int,QString);
  bool hparse_f_is_identifier(int);
  bool hparse_f_is_variable(int, int);
  int hparse_f_qualified_name_of_operand(unsigned int,bool,bool,bool);
  int hparse_f_table_references();
  void hparse_f_table_escaped_table_reference();
  int hparse_f_table_reference(int);
  int hparse_f_table_factor();
  int hparse_f_table_json_table(); int hparse_f_table_json_table_columns();
  int hparse_f_table_join_table();
  int hparse_f_table_join_condition();
  void hparse_f_table_index_hint_list();
  int hparse_f_table_index_hint();
  int hparse_f_table_index_list();
  void hparse_f_portion(int);
  int hparse_f_comp_op();
  void hparse_f_opr_1(int,int),hparse_f_opr_2(int,int),hparse_f_opr_3(int,int),hparse_f_opr_4(int,int);
  void hparse_f_opr_5(int,int),hparse_f_opr_6(int,int),hparse_f_opr_7(int,int);
  void hparse_f_opr_8(int,int);
  void hparse_f_opr_9(int,int);
  void hparse_f_opr_10(int,int);
  void hparse_f_opr_11(int,int);
  void hparse_f_opr_12(int,int);
  void hparse_f_opr_13(int,int);
  void hparse_f_opr_14(int,int);
  void hparse_f_opr_15(int,int);
  void hparse_f_opr_16(int,int);
  void hparse_f_opr_17(int,int);
  void hparse_f_opr_18(int,int);
  void hparse_f_over(int,int);
  int hparse_f_over_start(int);
  int hparse_f_over_end();
  void hparse_f_function_arguments(QString);
  int hparse_f_expression_list(int);
  void hparse_f_parenthesized_value_list();
  void hparse_f_parameter_list(int);
  void hparse_f_parenthesized_expression();
  void hparse_f_parenthesized_multi_expression(int*);
  void hparse_f_bracketed_multi_expression();
  int hparse_f_simple_value(bool is_value_required, bool is_row_required);
  void hparse_f_like_or_where();
  void hparse_f_from_or_like_or_where();
  void hparse_f_infile_or_outfile();
  void hparse_f_show_columns();
  void hparse_f_if_exists();
  void hparse_f_if_not_exists();
  void hparse_f_indexes_or_keys();
  void hparse_f_alter_or_create_clause(int,unsigned int*,bool*,bool*);
  int hparse_f_semicolon_and_or_delimiter(int);
  int hparse_f_explainable_statement(int,int);
  void hparse_f_statement(int);
  void hparse_f_pseudo_statement(int);
  void hparse_f_is_global_or_persist(bool *,bool *);
  void hparse_f_assignment(int,int,bool,bool);
  void hparse_f_alter_table();
  int hparse_f_character_set();
  int hparse_f_index_if_exists(unsigned int);
  int hparse_f_not_ignored(bool is_compulsory);
  void hparse_f_alter_database();
  void hparse_f_alter_specification();
  void hparse_f_characteristics(int object_type);
  int hparse_f_characteristic_language(int);
  int hparse_f_as_javascript();
  int hparse_f_algorithm_or_lock();
  void hparse_f_definer();
  void hparse_f_character_set_or_collate();
  int hparse_f_length(bool, bool,bool);
  void hparse_f_enum_or_set();
  int hparse_f_data_type(int);
  void hparse_f_reference_option();
  int hparse_f_reference_definition();
  int hparse_f_create_definition(int);
  int hparse_f_default_clause(int);
  int hparse_f_current_timestamp();
  void hparse_f_column_definition(int last_word);
  void hparse_f_comment(int extra);
  void hparse_f_column_list(int,int);
  void hparse_f_engine();
  void hparse_f_table_or_partition_options(int);
  void hparse_f_yesno();
  void hparse_f_partition_options();
  void hparse_f_partition_or_subpartition(int);
  void hparse_f_partition_or_subpartition_definition(int);
  int hparse_f_partition_list(bool, bool);
  void hparse_f_algorithm();
  void hparse_f_sql();
  void hparse_f_for_channel(unsigned int);
  void hparse_f_interval_quantity(int);
  void hparse_f_alter_or_create_event(int);
  void hparse_f_alter_or_create_sequence(int);
  void hparse_f_alter_or_create_server(int);
  void hparse_f_require(int,bool,bool);
  void hparse_f_user_specification_list(int who_is_calling);
  int hparse_f_identified();
  void hparse_f_create_database();
  void hparse_f_create_package(bool);
  void hparse_f_create_function_clauses();
  void hparse_f_create_procedure_clauses();
  int hparse_f_index_column_expecter();
  void hparse_f_index_columns(int,bool,bool,bool,bool);
  void hparse_f_alter_or_create_view();
  int hparse_f_analyze_or_optimize(int,int*);
  void hparse_f_install();
  void hparse_f_call();
  void hparse_f_call_arguments();
  void hparse_f_commit_or_rollback();
  int is_token_priv(int);
  void hparse_f_explain_or_describe(int);
  int hparse_f_explain_format();
  void hparse_f_grant_or_revoke(int,bool*);
  void hparse_f_insert_or_replace();
  void hparse_f_conflict_clause();
  void hparse_f_conflict_algorithm();
  void hparse_f_condition_information_item_name();
  int hparse_f_signal_or_resignal(int,int);
  int hparse_f_into(int);
  void hparse_f_with_clause(int,bool);
  int hparse_f_values(bool);
  int hparse_f_unionize(bool);
#if (OCELOT_EXTENDER == 1)
  bool hparse_f_is_extender_ok();
#endif
  bool hparse_f_is_query(bool);
  int hparse_f_query(int,bool,bool,bool);
  int hparse_f_select(bool,bool);
  int hparse_f_select_part_2(bool);
  int hparse_f_late_select_clauses(bool,int);
  int hparse_f_deep_query(int,bool,bool);
  void hparse_f_where();
  void hparse_f_window_spec(bool);
  int hparse_f_order_by(int);
  int hparse_f_limit(int);
  void hparse_f_block(int, int);
  bool hparse_f_is_in_compound();
  int hparse_f_plsql_condition(int);
  void hparse_f_declare(int, int);
  int hparse_f_declare_plsql(int);
  int hparse_f_recover_if_error(bool,QString);
  void hparse_f_lua_blocklist(int,int);
  void hparse_f_lua_blockseries(int,int,bool);
  int hparse_f_lua_block(int,int,bool);
  int hparse_f_lua_funcname();
  int hparse_f_lua_varlist();
  int hparse_f_lua_var();
  int hparse_f_lua_namelist();
  int hparse_f_lua_explist();
  int hparse_f_lua_exp();
  int hparse_f_lua_prefixexp();
  int hparse_f_lua_functioncall();
  int hparse_f_lua_args();
  int hparse_f_lua_function();
  int hparse_f_lua_funcbody();
  int hparse_f_lua_parlist();
  int hparse_f_lua_tableconstructor();
  int hparse_f_lua_fieldlist();
  int hparse_f_lua_field();
  int hparse_f_lua_fieldsep();
  int hparse_f_lua_name();
  int hparse_f_lua_name_equivalent();
  int hparse_f_lua_number();
  int hparse_f_lua_string();
  int hparse_f_lua_oprlist();
  int hparse_f_lua_literal();
  void hparse_f_lua_opr_1(int);
  void hparse_f_lua_opr_2(int);
  void hparse_f_lua_opr_3(int);
  void hparse_f_lua_opr_4(int);
  void hparse_f_lua_opr_5(int);
  void hparse_f_lua_opr_6(int);
  void hparse_f_lua_opr_7(int);
  void hparse_f_lua_opr_8(int,int);
  void hparse_f_lua_opr_9(int,int);
  void hparse_f_lua_opr_10(int,int);
  void hparse_f_lua_opr_11(int,int);
  void hparse_f_lua_opr_12(int,int);
  void hparse_f_lua_opr_13(int,int);
  void hparse_f_lua_opr_14(int,int);
  void hparse_f_lua_opr_15(int,int);
  void hparse_f_lua_opr_16(int,int);
  void hparse_f_lua_opr_17(int,int);
  void hparse_f_lua_opr_18(int,int);
  int hparse_f_lua_accept_dotted(unsigned int,unsigned char,int,QString);
  QString hparse_f_label(int *);
  int hparse_f_find_define(int,int,int,bool);
  void hparse_f_cursors(int);
  int hparse_f_variables(int*);
  void msgBoxClosed(QAbstractButton*);
  void hparse_f_multi_block(QString text);
  int i_of_elementary_statement();
  QString hparse_f_pre_rehash_search(int reftype);
  bool hparse_f_is_rehash_searchable(int);
  int hparse_f_backslash_command(bool);
  void hparse_f_other(int);
#if (OCELOT_IMPORT_EXPORT == 1)
  int hparse_f_client_set_export();
#endif
  int hparse_f_client_set_rule();
  int hparse_f_client_set_query();
  int hparse_pick_from_list(QStringList);
  int hparse_f_client_set();
  int hparse_f_client_statement();
  void hparse_f_parse_hint_line_create();
  bool hparse_f_is_nosql(QString);
  void hparse_f_variables_append(int i_of_statement_start, QString text, unsigned char reftype);
  void log(const char*,int);
  void extra_result_set(int, unsigned short int);
  int execute_real_query(QString, int, const QString *);
  int execute_ocelot_query(QString, int, const QString *, bool *, QString *, unsigned int *);
  void fillup_prepare();
#ifdef DBMS_TARANTOOL
  void tparse_f_factor();
  void tparse_f_term();
  void tparse_f_expression();
  void tparse_f_restricted_expression();
  void tparse_f_indexed_condition(int);
  void tparse_f_statement();
  void tparse_f_assignment();
  void tparse_f_block(int);
  void tparse_f_program(QString text);
#endif
#ifdef DBMS_TARANTOOL
  /* todo: field_name_list_all_rows* stuff could be cleared sometimes, or could be in ResultGrid */
  QStringList field_name_list_all_rows;
  QList<int> field_name_list_all_rows_count;
  QList<char*> field_name_list_all_rows_address;
  QList<int> field_type_list_all_rows;
  QString tarantool_add_return(QString);
  const char *tarantool_result_set_init(int,long unsigned int *,int *);
  const char *tarantool_result_set_init_select(long unsigned int *, int, int);

  long unsigned int tarantool_num_rows(unsigned int connection_number);
  unsigned int tarantool_num_fields();
  int tarantool_num_fields_recursive(const char **tarantool_tnt_reply_data,
                                     char *field_name,
                                     int field_number_within_array,
                                     QStringList *field_name_list,
                                     QList<int> *field_name_list_count,
                                     QList<char*> *field_name_list_address,
                                     int field_type_upper);
  QString tarantool_scan_rows(unsigned int p_result_column_count,
                 unsigned int p_result_row_count,
                 MYSQL_RES *p_mysql_res,
                 char **p_result_set_copy,
                 char ***p_result_set_copy_rows,
                 unsigned int **p_result_max_column_widths);
  QString tarantool_scan_field_names(
                 const char *which_field,
                 unsigned int p_result_column_count,
                 char **p_result_field_names,
                 bool is_for_display);
  int create_table_server(QString, bool *, unsigned int, unsigned int);
  QString tarantool_read_format(QString);
#endif
  QVBoxLayout *main_layout;
  QString token_reftype(int i, bool, int, char);
  QString get_font_style_as_string(QFont);

  Completer_widget *completer_widget= NULL;
  C_widget *c_widget= NULL;


#if (OCELOT_IMPORT_EXPORT == 1)
  QByteArray to_byte_array(QString);
  void export_defaults(int passed_type, struct export_settings *exports);
  QString import_export_rule_set(QString text);
  void export_set_checked();
#endif
  int read_file(int keyword, QString file_name, QString table_name);
#if (OCELOT_MYSQL_INCLUDE ==1)
  QByteArray read_file_skip(QByteArray, int, char *, int, QFile *, int *);
  int read_file_line_skip(char *, int, char *, int, char *, int *);
#endif
#if (OCELOT_EXPLORER == 1)
  int explorer_refresh_caller(char *);
  int explorer_refresh(char *);
  void explorer_show_after_change();
  //int explorer_qsort_compare(const void * a, const void * b);
  void explorer_sort();
  bool explorer_query();
  QStringList explorer_text_list();
  void explorer_close();
  void explorer_context_menu(QPoint &pos);
#endif

/* Crashing bug:
  Following as far as action_options_xml were all moved out of slots on 2024-04-25
  then crashes were happening in places that didn't seem related e.g. hparse_f_accept().
  I think I figured it out: it's because action_settings_statement_edit_widget_text_changed is a slot.
  Before moving again, I examines code to establish that there no other MainWindow things that are slots.
  But if it's seen again, it might be because something else is a slot.
*/
  void action_file_connect(bool is_checked);
  void action_file_connect_once(QString);
  void action_file_exit(bool is_checked);
#if (OCELOT_IMPORT_EXPORT == 1)
  QStringList fake_statement(QString fake_statement_text);
  int action_file_export_function(int import_or_export, int);
  const char *bool_to_string(bool input);
  bool string_to_bool(QString input);
  QString action_file_export_function_value(QString input);
  QString action_file_export_function_clause(QString,QString);
  QString action_file_export_function_clause_i(QString,int);
  QString action_file_export_function_clause_b(QString,bool);
  void action_file_export_text(bool is_checked);
  void action_file_export_table(bool is_checked);
  void action_file_export_html(bool is_checked);
  void action_file_export_none(bool is_checked);
#endif
  void action_run_execute(bool is_checked);
  int action_execute(int);
  void action_run_kill(bool is_checked);
  void action_help_about(bool is_checked);
  void action_help_the_manual(bool is_checked);
#if (OCELOT_MYSQL_INCLUDE == 1)
  void action_help_libmysqlclient(bool is_checked);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  void action_help_settings(bool is_checked);

  QTextCharFormat get_format_of_current_token(int token_type, int token_flags, QString mid_next_token);
  void action_undo();
  void action_redo();
  void menu_activations(QObject*, QEvent::Type);
  void action_edit_format(bool is_checked);
  int statement_format_rule_set(QString text);
  QString statement_format_rule_apply(QString, int, unsigned char, unsigned int, int*, int*, int*);
  void action_change_one_setting(QString old_setting, QString new_setting, int keyword_index);
  void action_change_one_setting_execute(QString text);
  void action_settings_menu(bool is_checked);
  void action_settings_history(bool is_checked);
  void action_settings_grid(bool is_checked);
  void action_settings_statement(bool is_checked);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  void action_settings_debug(bool is_checked);
#endif
#if (OCELOT_EXPLORER == 1)
  void action_settings_explorer(bool is_checked);
#endif
  void action_settings_extra_rule_1(bool is_checked);
  void action_edit_previous_statement(bool is_checked);
  void action_edit_next_statement(bool is_checked);
  void action_options_detach_history_widget(bool is_checked);
  void action_options_detach_grid_widget(bool is_checked);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  void action_options_detach_debug_widget(bool is_checked);
#endif
#if (OCELOT_EXPLORER == 1)
  void action_options_detach_explorer_widget(bool is_checked);
#endif
  void action_options_detach_statement_widget(bool is_checked); void detach_widget(int widget_type, bool is_checked);
  void action_options_next_window(bool is_checked);
  void action_options_previous_window(bool is_checked);
  void action_options_change_result_display(QString);
  void action_options_bar(bool is_checked);
  void action_options_batch(bool is_checked);
  void action_options_horizontal(bool is_checked);
  void action_options_html(bool is_checked);
  void action_options_htmlraw(bool is_checked);
  void action_options_line(bool is_checked);
  void action_options_none(bool is_checked);
  void action_options_pie(bool is_checked);
  void action_options_raw(bool is_checked);
  void action_options_vertical(bool is_checked);
  void action_options_xml(bool is_checked);

#if (OCELOT_MYSQL_DEBUGGER == 1)
  int debug_mdbug_install_sql(MYSQL *mysql, char *x); /* the only routine in install_sql.cpp */
  int debug_parse_statement(QString text,
                             char *returned_command_string,
                             int *index_of_number_1,
                             int *index_of_number_2);
  int debug_error(char *text);
//  void action_debug_install();
  void debug_install_go();
//  void action_debug_setup();
  void debug_setup_go(QString text);
  void debug_setup_mysql_proc_insert();
//  void action_debug_debug();
  void debug_debug_go(QString text);
  void action_debug_breakpoint(bool is_checked);
  void debug_breakpoint_or_clear_go(int statement_type, QString text);
  void action_debug_mousebuttonpress(QEvent *event, int which_debug_widget_index);
  void action_debug_continue(bool is_checked);
//  void action_debug_leave();
  void debug_skip_go();
  void debug_source_go();
  void debug_set_go(QString text);
  void debug_other_go(QString text);
  void action_debug_next(bool is_checked);
//  void action_debug_skip();
  void action_debug_step(bool is_checked);
  void action_debug_clear(bool is_checked);
//  void action_debug_delete();
  void debug_delete_go();
  void debug_execute_go();
  void action_debug_exit(bool is_checked);
  void debug_exit_go(int flagger);
  void debug_delete_tab_widgets();
  void action_debug_information(bool is_checked);
  void action_debug_refresh_server_variables(bool is_checked);
  void action_debug_refresh_user_variables(bool is_checked);
  void action_debug_refresh_variables(bool is_checked);
  void action_debug_refresh_call_stack(bool is_checked);
#endif
  int shortcut_set(int, QString);
  int menu_set_via_id(QString, QString, QString); int shortcut_set_via_keyword(int, QString);
  void action_edit_undo(bool is_checked);
  void action_edit_redo(bool is_checked);
  void action_edit_cut(bool is_checked);
  void action_edit_copy(bool is_checked);
  void action_edit_paste(bool is_checked);
  void action_edit_select_all(bool is_checked);
  void action_edit_zoomin(bool is_checked);
  void action_edit_zoomout(bool is_checked);
  void action_edit_autocomplete(bool is_checked);
  bool menu_edit_autocomplete();
#if (OCELOT_FIND_WIDGET == 1)
  void action_edit_find(bool is_checked);
#endif
  bool eventfilter_function(QObject *obj, QEvent *event);

//  int typer_to_ocelot_data_type(char *s); /* exists in ocelotgui.cpp but is commented out */
  char *typer_to_keyword(unsigned int); /* todo: check: why are some things in "public slots" not "public"? */

public slots: /* todo: check if should be private */
  void action_settings_statement_edit_widget_text_changed(int,int,int);
  void initialize_after_main_window_show();
#if (OCELOT_MYSQL_DEBUGGER == 1)
  void action_debug_timer_status();
#endif
  void menu_spec_action_all(bool is_checked); /* the slot for every menu item */
  void action_i(int i, bool is_checked);
  void menu_context(const QPoint &);
  void copy_available(bool yes_no);

protected:
  bool eventFilter(QObject *obj, QEvent *ev);
  void resizeEvent(QResizeEvent *ev);

private:
public:
  Ui::MainWindow *ui;
  void put_message_in_result(QString);
private:
  int history_markup_previous_or_next();
  void initialize_widget_history();
  int result_grid_add_tab();
  void initialize_widget_statement();
#if (OCELOT_EXPLORER == 1)
  void initialize_widget_explorer();
  void initialize_widget_explorer_after_connect();
#endif
  void action_edit_zoominorout(int);
#if (OCELOT_MYSQL_DEBUGGER == 1)
  void debug_menu_enable_or_disable(int statement_type);
  void create_widget_debug();
  int debug_information_status(char *last_command);
  int debug_call_xxxmdbug_command(const char *command);
  void debug_highlight_line();
  void debug_maintain_prompt(int action, int debug_widget_index, int line_number);
  QString debug_privilege_check(int statement_type);
#endif
  void main_token_new(int), main_token_push(), main_token_pop();
  void create_menu(); void fill_menu_1(); void fill_menu_2();
  int menu_item(int key_of_menu_or_menu_item, QMenu* qmenu_of_menu, QAction *qaction_of_menu_item);
  int rehash_scan(char *, QString alternate_query); int rehash_scan_for_tarantool(char *, QString alternate_query);
  void rehash_garbage_collect();
  void rehash_scan_one_space(int space_number);
  QString rehash_search(QString table_name, char *search_string, int reftype,
                        QString hparse_token,
                        bool is_exact_required,
                        QString specific_schema,
                        QStringList specified_list);
  void rehash_get_database_name(char *);
#if (OCELOT_EXTENDER == 1)
  int extender_scan(char *error_or_ok_message, QString alternate_query, QString *select_statement, QString semiselect_part_2, int offset_of_into, int innodb_status_count);
  unsigned short int extender_result_data_type(unsigned short int result_field_type);
  QString extender_flattener(QString column_value);
#endif
  void widget_sizer();
  QString get_delimiter(QString,QString,int);
  QString detached_value(QString);
  QString rect_value(QString);
  int execute_client_statement(QString text, int *additional_result);
  QString dbms_name();
  bool is_context_menu_name(int token_type);
  void prompt_default();
  int conditional_settings_insert(QString text);
  void put_diagnostics_in_result(unsigned int, unsigned int);
/* Signal passed to put_diagnostics_in_result, 0 unless execute_ocelot_query happened and added its own message */
#define DIAGNOSTIC_0 0
#define DIAGNOSTIC_1 1
#define DIAGNOSTIC_2 2
/* Return from execute_client_statement to be compared with ecs_return */
#define EC_0 0
#define EC_1 1
#define EC_2 2
#define EC_3 3
#define EC_4 4
#define EC_5 5

  void make_and_put_message_in_result(unsigned int, int, char*);
  void make_and_put_open_message_in_result(unsigned int, int, QString);
  void make_and_append_message_in_result(unsigned int, int, char*);
  unsigned int get_ocelot_protocol_as_int(QString s);
//  int options_and_connect(char *host, char *database, char *user, char *password, char *tmp_init_command,
//                       char *tmp_plugin_dir, char *tmp_default_auth, char *unix_socket, unsigned int connection_number);

  void connect_mysql_options_2(int w_argc, char *argv[]);
  void connect_read_command_line(int argc, char *argv[]);
  void connect_read_my_cnf(const char *file_name, int is_mylogin_cnf);
  QStringList my_cnf_groups_list();
  int connect_readmylogin(QFile&, unsigned char *);
  //int connect_readmylogin(FILE *, unsigned char *);
  void connect_set_variable(QString token0, QString token1, QString token2);
  void connect_make_statement();
  long to_long(QString token);
  QString get_version();
  void print_version();
  void print_help();
  void print_defaults(int is_called_from_print_help);
  int setup_mysql_real_query(char*,char*);
  int setup_routine_list(QString);
  int setup_find(QString,QString);
  int setup_generate(int);
  int setup_generate_icc_process_user_command_r_server_variables();
  int setup_append(QString, QString, int);
  int setup_generate_routine_entry_parameter(QString);
  int setup_generate_starter(QString, QString, QString, QString);
  void setup_generate_ender();
  int setup_generate_statements(int, QString, int);
  int setup_initialize_variables();
  int setup_get_setup_group_name(int);
  QString setup_add_delimiters(QString);
  int setup_insert_into_statements(QString,int);
  int setup_insert_into_variables_user_variables(QString,int);
  int setup_create_setup_log_table();
  int setup_internal(QString);
  int setup_drop_routines();
  void setup_cleanup();
  int setup_set_session_sql_mode(QString);
  int setup_generate_icc_core();
  int setup_generate_statements_debuggable(int, int, int, QString, int, int);
  int setup_generate_label(int, QString, int);
  int setup_row_type(int);
  bool typer_is_int(int);
  int setup_determine_what_variables_are_in_scope(int, QString, bool);
  int setup_generate_statement_text(int, QString, int, int);
  int setup_generate_statement_text_as_is(int, QString, int);
  void copy_options_to_main_window();
  void delete_utf8_copies();
  void copy_connect_strings_to_utf8(); /* in effect, copy options from main_window */
#if (OCELOT_MYSQL_INCLUDE == 1)
  int the_connect(unsigned int connection_number);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  int the_connect_2(); /* intended replacement for the_connect() */
  //my_bool get_one_option(int optid, const struct my_option *opt __attribute__((unused)),char *argument);
  void connect_init(int connection_number);
  void set_current_colors_and_font(QFont);
  QFont get_fixed_font();

public:
  void make_style_strings();
  void make_one_style_string(QString *style_string, QString text_color, QString background_color, QString border_size, QString border_color, QString font_family, QString font_size, QString font_style, QString font_weight, bool is_menu);
private:
  //void create_the_manual_widget();
  int get_next_statement_in_string(int passed_main_token_number, int *returned_begin_count, bool);
  int make_statement_ready_to_send(QString, char *, int, int);
  void remove_statement(QString);
  int action_execute_one_statement(QString text);

  void history_markup_make_strings();
  void history_markup_append(QString result_set_for_history, bool is_interactive);
  void tee_export(QString);
  QString history_markup_copy_for_history(QString);
  int history_file_start(QString, QString, QString *r);        /* see comment=tee+hist */
public:
  void history_file_write(QString, QString, bool);       /* see comment=tee+hist */
  void history_file_stop(QString);                 /* see comment=tee+hist */
private:
  void history_file_to_history_widget();           /* see comment=tee+hist */
  int history_line(char *);
public:
  void statement_edit_widget_setstylesheet();
  void tokenize(QChar *text, int text_length, int *token_lengths, int *token_offsets, int max_tokens, QChar *version, int passed_comment_behaviour, QString special_token, int minus_behaviour);
private:
  bool is_statement_complete(QString);
  void message_box(QString the_title, QString the_text);

  void clf(QString);
  int clf_block(QString, int, QString*);
  bool clf_internal_select(int, QString, QString *);
  bool clfdw(QString, QString*);
  bool clfds(QString, int, QString, QString, QString*);
  void clf_dump_whitespace(QString, QString*);
  QString clf_label(QString, QString);
  bool clf_set(QString, QString, QString*);
  QString clf_v(const QString, int, int);
  QString clf_indent(QString*);
  bool clf_find_handler(QString, QString*, QString, int, int);
  int clf_find_begin(int);
  bool clf_handler_list(QString, int, int, QString*);
  QString clf_handler_name(int);
  bool clf_check_reference(QString, int, int, QString*);
  void clf_handler_end(int, QString*);
  bool clf_make_sql_execute_starter_and_ender(QString, QString*);
  void clf_make_sql_execute_function(QString*);
/*
  ocelot_statement_syntax_checker is planned as a bunch of flags, e.g.
    0 = none
    1 = use for highlights
    2 = errors, i.e. pop up a dialog box if user tries to execute a bad-looking statement
    4 = extender
    8 = severe e.g. look whether declared variable is known, or severe e.g. look whether table is known (need to ask server)
   16 = tooltip
   32 = word-completion
   ... although so far the only thing being checked is 2 = errors
*/
#define FLAG_FOR_HIGHLIGHTS 1
#define FLAG_FOR_ERRORS     2

  int token_type(QChar *token, int token_length, bool ansi_quotes);
  void initial_asserts();
  void tokens_to_keywords(QString text, int start, bool ansi_quotes);
  void tokens_to_keywords_revert(int i_of_body, int i_of_function, int i_of_do, QString text, int start);
  int next_token(int i);
  int get_keyword_index(const char *, char *);
  int get_keyword_index_from_qstring(QString key);
  bool is_client_statement(int, int, QString);
  int find_start_of_body(QString text, int start, int *i_of_function, int *i_of_do);
#if (OCELOT_MYSQL_INCLUDE == 1)
  int connect_mysql(unsigned int connection_number);
  void connect_mysql_error_box(QString, unsigned int);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
  int connect_tarantool(unsigned int connection_number, QString, QString, QString, QString);
  void tarantool_initialize(int connection_number);
  void tarantool_flush_and_save_reply(unsigned int);
  const char *tarantool_point_to_data();
  int tarantool_real_query(const char *dbms_query, unsigned long dbms_query_len, unsigned int, unsigned int, unsigned int, const QString *);
  int tarantool_get_result_set(int, int);
  QString tarantool_get_messages(int);
  bool tarantool_is_result_count(const char *);
  const char *tarantool_get_result_type(int, const char *, int *);
  QString get_statement_type(QString, int *);
  int get_statement_type_low(QString, QString, QString);
  QString tarantool_fetch_row(const char *tarantool_tnt_reply_data, int *bytes, int *tsize);
  int tarantool_fetch_row_ext(const char *tarantool_tnt_reply_data, char *value_as_string, unsigned char *returned_ext_field_type);
  QString tarantool_fetch_header_row();
  const char * tarantool_seek_0(int*);
  QString tarantool_internal_query(char*, int);
#endif
#if (OCELOT_MYSQL_INCLUDE == 1)
  QString select_1_row(const char *select_statement);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  QWidget *main_window;
public:
  TextEditHistory *history_edit_widget;
#if (OCELOT_PLUGIN == 1)
  QList<Plugin *> plugin_widget_list;
  int plugin_widget_list_caller(int type, QString menu_function_name);
  int insert_plugin(QString, QString, const QString *); int delete_plugin(QString);
#endif
private:

#if (OCELOT_MYSQL_DEBUGGER == 1)
#define DEBUG_TAB_WIDGET_MAX 10
  QWidget *debug_top_widget;
  QVBoxLayout *debug_top_widget_layout;
  QLineEdit *debug_line_widget;
  QTabWidget *debug_tab_widget;
  CodeEditor *debug_widget[DEBUG_TAB_WIDGET_MAX]; /* todo: this should be variable-size */
#endif
#if (OCELOT_FIND_WIDGET == 1)
  Find_widget *find_widget;
#endif
#if (OCELOT_EXPLORER == 1)
public:
  ResultGrid *explorer_widget;
  explorer_items *oei;
  unsigned oei_count;
  explorer_items_fk *oei_fk;
  unsigned oei_fk_count;
private:
#endif
  XSettings *xsettings_widget;
#if (OCELOT_IMPORT_EXPORT == 1)
    QActionGroup *menu_file_export_group;
#endif
public:
private:
public:
private:

  //QWidget *the_manual_widget;
  //  QVBoxLayout *the_manual_layout;
  //  QTextEdit *the_manual_text_edit;
  //  QPushButton *the_manual_pushbutton;

  /* QTableWidget *grid_table_widget; */
public:
  QTabWidget48 *result_grid_tab_widget;
private:
  unsigned long result_row_count;

  int history_markup_counter; /* 0 when execute, +1 when "previous statement", -1 for "next statement" */

  int statement_edit_widget_text_changed_flag;
  QString ocelot_delimiter_str;                                           /* set up in connect section */
  int ocelot_password_was_specified; /* 0: never mentioned. 1: "--password=". 2: "password" but not "=". */

  /* MYSQL mysql; */
  MYSQL_RES *mysql_res;
  /* MYSQL_FIELD *fields; */

#ifdef DBMS_TARANTOOL
  struct tnt_reply tarantool_tnt_reply;
  const char *tarantool_tnt_reply_data_p; /* initially = tarantool_tnt_reply.data. can move if transaction. */
  unsigned int tarantool_field_names_count; /* duplication of field_name_list_all_rows.count() -- unnecessary? */
  bool tarantool_select_nosql;
  QStringList tarantool_table_ids;
  QStringList tarantool_table_names;
  QStringList tarantool_column_table_names;
  QStringList tarantool_column_names;
#if (OCELOT_EXPLORER == 1)
  QStringList tarantool_table_engines;
  QStringList tarantool_type_names;
  QStringList tarantool_index_column_numbers;
#endif
  QStringList tarantool_index_table_names;
  QStringList tarantool_index_names;
  QStringList tarantool_trigger_names;
  QStringList tarantool_fk_constraint_names; /* Version 1.9 addition for foreign keys */
  QStringList tarantool_fk_constraint_child_ids;
  QStringList tarantool_fk_constraint_parent_ids;
#endif

public:
#if (OCELOT_FIND_WIDGET == 1)
  QObject *last_focus_widget;
#endif
  bool keypress_shortcut_handler(QKeyEvent *);
  int tarantool_execute_sql(const char *, unsigned int, int);
  int tarantool_execute_lua(const char *, unsigned int, int);
  int tarantool_execute_lua_select(int, int);
  QString query_utf16;
  QString query_utf16_copy;
  /* main_token_offsets|lengths|types|flags|pointers are alloc'd in main_token_new() */
  int  *main_token_offsets;
  int  *main_token_lengths;
  int  *main_token_types;
  unsigned int *main_token_flags; /* e.g. TOKEN_FLAG_IS_RESERVED */
  int  *main_token_pointers;
  unsigned char *main_token_reftypes;
  unsigned int main_token_max_count;
  unsigned int main_token_count_in_all;
  unsigned int main_token_count_in_statement;
  /* todo: is main_token_number obsolete? does it do anything? */
  unsigned int main_token_number;      /* = offset within main_token_offsets, e.g. 0 if currently at first token */

  int  *saved_main_token_offsets;
  int  *saved_main_token_lengths;
  int  *saved_main_token_types;
  unsigned int *saved_main_token_flags;
  int  *saved_main_token_pointers;
  unsigned char *saved_main_token_reftypes;
  /* unsigned int saved_main_token_max_count; doesn't need saving */
  unsigned int saved_main_token_count_in_all;
  unsigned int saved_main_token_count_in_statement;
  unsigned int saved_main_token_number;

  QString tarantool_table_name;
  QString tarantool_column_name;

};



#endif // MAINWINDOW_H


#ifdef DBMS_TARANTOOL
/*
  Tarantool comments
  ------------------

  Automatic field names. Every tuple is an array with possible sub-arrays.
  In standard SQL we'd designate with f[1] f[1][1] f[1][1][1].
  But we will prefer f_1 f_1_1 f_1_1 so it's compatible with MySQL.
  The letter "f" is arbitrary, it's #define TARANTOOL_FIELD_NAME_BASE.

  Todo: probable bug: a map of arrays will probably cause a crash.
*/

/* If you want field names to start with "foo" instead of "f", change TARANTOOL_FIELD_NAME_BASE. */
#define TARANTOOL_FIELD_NAME_BASE "f"

/* Names like f_1_1 are shorter than 64 characters, but we might have user-defined names. */

#define TARANTOOL_MAX_FIELD_NAME_LENGTH 64
#define TARANTOOL_BOX_INDEX_EQ 0
#define TARANTOOL_BOX_INDEX_ALL 2
#define TARANTOOL_BOX_INDEX_LT 3
#define TARANTOOL_BOX_INDEX_LE 4
#define TARANTOOL_BOX_INDEX_GE 5
#define TARANTOOL_BOX_INDEX_GT 6

#define ER_8372_INT 8372

#endif

#define TEXTEDITFRAME_CELL_TYPE_DETAIL 0
#define TEXTEDITFRAME_CELL_TYPE_HEADER 1
#define TEXTEDITFRAME_CELL_TYPE_DETAIL_EXTRA_RULE_1 2


#ifdef OLD_STUFF
/*****************************************************************************************************************************/
/* THE TEXTEDITFRAME WIDGET */
/* See comments containing the word TextEditFrame, in ResultGrid code. */

#ifndef TEXTEDITFRAME_H
#define TEXTEDITFRAME_H


class TextEditFrame : public QFrame
{
  Q_OBJECT

public:
  explicit TextEditFrame(QWidget *parent, ResultGrid *ancestor, unsigned int index);
  ~TextEditFrame();

  int border_size;
  int minimum_width;
  int minimum_height;
  ResultGrid *ancestor_result_grid_widget;
  unsigned int text_edit_frames_index;                 /* e.g. for text_edit_frames[5] this will contain 5 */
  int ancestor_grid_column_number;
  int ancestor_grid_result_row_number;
  unsigned int content_length;
  /* todo: check: could this be unsigned char cell_type instead of unsigned short int cell_type? */
  unsigned short int cell_type;                        /* detail or header or detail_extra_rule_1 */
  char content_field_value_flags; /* if detail, might be a copy of result_row_copy field_value_flag values */
  char *content_pointer; /* if detail, might point to result_row_copy */
  bool is_retrieved_flag;
  bool is_style_sheet_set_flag;
  /* todo: check: now that we have field_value_flags, can we get rid of is_image_flag? */
  bool is_image_flag;                    /* true if data type = blob and appropriate flag is on */

protected:
  void mousePressEvent(QMouseEvent *event);
  void mouseMoveEvent(QMouseEvent* event);
  void mouseReleaseEvent(QMouseEvent *event);
  void paintEvent(QPaintEvent *event);

private:
  int left_mouse_button_was_pressed;
  int widget_side;
  enum {LEFT= 1, RIGHT= 2, TOP= 3, BOTTOM= 4};
  bool comparer(QString opd1, QString opd2, QString opr, char field_value_flags);
  void style_sheet_setter(TextEditFrame *text_frame, TextEditWidget *text_edit);
};
#endif // TEXTEDITFRAME_H
#endif

#ifdef OLD_STUFF
/*********************************************************************************************************/
/* THE TEXTEDITWIDGET WIDGET */
/* subclassed QTextEdit so paintEvent can be caught, for use in result_grid */
/* also for focusoutEvent|focusInEvent, since eventfilter use would probably cost more */

#ifndef TEXTEDITWIDGET_H
#define TEXTEDITWIDGET_H
class TextEditWidget : public QTextEdit
{
  Q_OBJECT

public:
  explicit TextEditWidget(QWidget *parent);
  ~TextEditWidget();

  TextEditFrame *text_edit_frame_of_cell;

  void copy();
  void paste();

  void generate_update();
protected:
  void paintEvent(QPaintEvent *event);
  void keyPressEvent(QKeyEvent *event);
  void focusOutEvent(QFocusEvent *event);
  void focusInEvent(QFocusEvent *event);

  QString unstripper(QString value_to_unstrip);


};

#endif // TEXTEDITWIDGET_H
#endif

/*********************************************************************************************************/
/* THE ROW_FORM_BOX WIDGET */

/*
  Todo: Currently this is only used for connecting. And export dialog coming soon.
        But it should be very easy to use with result-table rows,
        either for vertical display or in response to a keystroke on ResultGrid.
*/

/*
  Todo: Settle minimum and maximum width of dialog box.
        The calculation of main_window_maximum_width has been helpful here.
        Settle maximum width of each item.

  If user hits Enter, that should get Cancel or OK working.

  error text= "password must be entered" | as returned from last attempt | nothing (File|Connect)
  invoke: at start / when user types CONNECT / When File|Connect ... no auto-restart
  Actually call myoptions_and_connect()!
  Re-order the items?
  Would QTextEdit be nicer? You'd have horizontal scroll bars if necessary. However, a password would still be QLineEdit
                            Right ... QTextEdit, and height = 2 lines if otherwise there would be overflow
  Use row_form_width[]!
  Think again about how tabs work: setTabChangesFocus(true) works, but now it's hard to put a tab in except with escaping.
  Make spacing between widgets smaller: see comments about "no effect" below.
*/

#ifndef ROW_FORM_BOX_H
#define ROW_FORM_BOX_H
class Row_form_box: public QDialog
{
  Q_OBJECT
public:
  QDialog *row_form_box;
  bool is_ok;

private:
  QLabel **label;
  QLineEdit **line_edit;
  QTextEdit **text_edit;
  QComboBox **combo_box_edit;
  QHBoxLayout **hbox_layout;
  QWidget **widget;
  QPushButton *button_for_cancel, *button_for_ok;
  QHBoxLayout *hbox_layout_for_ok_and_cancel;
  QVBoxLayout *main_layout;
  QWidget *widget_for_ok_and_cancel;
  MainWindow *copy_of_parent;
  QLabel *label_for_message;
  QScrollArea *scroll_area;
  QWidget *widget_with_main_layout;
  QVBoxLayout *upper_layout;
  QWidget *widget_for_size_hint;

  int column_count_copy;
  int *row_form_is_password_copy;
  QString *row_form_data_copy;
  Row_form_box *this_row_form_box;
  int width_for_size_hint, height_for_size_hint;

public:
Row_form_box(int column_count, QString *row_form_label,
             int *row_form_type,
             int *row_form_is_password, QString *row_form_data,
//             QString *row_form_width,
             QString row_form_title, QString row_form_message,
             MainWindow *parent);
QSize sizeHint() const;
private slots:
void handle_button_for_ok();
void handle_button_for_cancel();
void garbage_collect();
};

#endif // ROW_FORM_BOX_H

#ifndef TEXTEDITWIDGET2_H
#define TEXTEDITWIDGET2_H
/*
  This is for when we want to size a QTextEdit based on its initial content.
  Minimum width is passed. Maximum height is assumed = 500.
  I suppose I don't really have to say "explicit" but it's harmless.
*/
class TextEditWidget2 : public QTextEdit
{
  Q_OBJECT
public:
  int passed_minimum_width;
  explicit TextEditWidget2(QString the_text, QWidget *parent, int minimum_width);
  ~TextEditWidget2();
  QSize sizeHint() const;
};
#endif // TEXTEDITWIDGET2_H

/***********************************************************/
/* THE MESSAGE_BOX WIDGET */
/***********************************************************/

/*
  QMessageBox equivalent, but with scroll bars.
  (A simple QMessageBox has no scroll bars.)
  We need scroll bars for some Help displays especially if screen size is small.
  Pass: button text e.g. "ok" or "yes" or "no". Sometimes two buttons.
  Return: 1 if button_1 pushed (default). 2 if button_2 pushed. Or equivalents e.g. Alt+Y for Yes.
  Also for hparse_f_multi_block() errors that get too long.
  Re size: We pass width to Message_box which passes it on to TextEditWidg2. But it doesn't mean that we
           will never go outside the bounds of MainWindow. And maximum height is hardcoded = 500.
  Re font: We use the same font as the statement, which might be a good choice when the dialog
           is for a syntax error on the statement widget, but less good for Help -- for Help,
           the menu font might be a better choice. We only use font and not other style sheet
           settings, and assume that it's best if QTextEdit2 and QPushButton have the same font.
  Todo: size calculation as in Row_form_box.
  Todo: Earlier, this had to exist for the scroll bar to work:
        layout->setSizeConstraint(QLayout::SetFixedSize);
        See if you can figure out why.
  Todo: Guarantee that initial width is enough so that entire header is visible.
*/
#ifndef MESSAGE_BOX_H
#define MESSAGE_BOX_H

class Message_box: public QDialog
{
  Q_OBJECT
public:
  int result;
  Message_box(QString the_title, QString the_text, int minimum_width,
              QString prompter, QString button_1_text, QString button_2_text, MainWindow *parent);
private slots:
void handle_button_1();
void handle_button_2();
};

#endif // MESSAGE_BOX_H

#ifndef COMPLETER_WIDGET_H
#define COMPLETER_WIDGET_H

/* See comments just before Completer_widget::construct() */

class Completer_widget: public QTextEdit
{
  Q_OBJECT

private:
  QTimer *timer;
  QStringList string_list_tooltips;
  int current_row;
  QList<int> token_type_list;
void copy_string_list();
void show_wrapper();
void set_current_row(int);

private slots:
void timer_expired();

protected:
void mousePressEvent(QMouseEvent *event);
void mouseDoubleClickEvent(QMouseEvent *event);
void keyPressEvent(QKeyEvent *event);


public:
QStringList string_list;
MainWindow *main_window;
int associated_widget_type;
void construct(MainWindow *m);
void call_for_action();
void set_timer_interval();
void initialize(int w);
void hide_wrapper();
void clear_wrapper();
int count_wrapper();
QString get_selected_item(QString *tool_tip);
void size_and_position_change();
void append_wrapper(QString token, QString hparse_token, int token_type, int flags, QString final_letter);
bool key_up_or_down(int);
void updater();
void timer_reset();
bool shortcut_override(QKeySequence shortcut);
void line_colors(int associated_widget_type);
int i_of_cmi_of_text(QString string);
Completer_widget();
~Completer_widget();
};
#endif // COMPLETER_WIDGET_H

#ifndef C_WIDGET_H
#define C_WIDGET_H

/* This will be for explorer only. Inherit Completer_widget but parent will be (?) main window. */

class C_widget: public Completer_widget
{
  Q_OBJECT

private:

private slots:

protected:
void focusInEvent(QFocusEvent *event);
void focusOutEvent(QFocusEvent *event);

public:
C_widget();
~C_widget();

};
#endif // C_WIDGET_H

#ifndef MESSAGEBOX_FLASH_H
#define MESSAGEBOX_FLASH_H

/*
  QMessagebox_flash is for putting up a QMessageBox, waiting 1 second, and closing.
  It's used by initialize_after_main_window_show() because, for unknown reasons, the
  main window rect() values are wrong unless we do this.
  Other possible ways to kludge:
    Just going to sleep for 1 second? No, that doesn't do the trick.
    Calculate what main window size will be once showMaximized() really takes effect?
*/

class Messagebox_flash : public QMessageBox
{
  Q_OBJECT

private:
QTimer *timer;

private slots:
void timer_expired();

protected:
void showEvent(QShowEvent *event);

public:
  Messagebox_flash();
  ~Messagebox_flash();

};
#endif // MESSAGEBOX_FLASH_H

#if (OCELOT_FIND_WIDGET == 1)
#ifndef FIND_WIDGET_H
#define FIND_WIDGET_H

/* See comments just before Find_widget::construct() */

class Find_widget: public QWidget
{
  Q_OBJECT

private:
  MainWindow *main_window;
  QHBoxLayout *layout;
  QToolButton *close_button;
  QLabel *find_label;
  QComboBox *combo_box;
  QToolButton *down_button;
  QToolButton *up_button;
  QToolButton *case_button;
  void construct();
  void action_find_widget_move(bool,bool);
  void enable_or_disable();

protected:
  void keyPressEvent(QKeyEvent *event);
private slots:
  void action_combo_box_text_changed(QString);
  void action_down_button_clicked();
  void action_up_button_clicked();
  void action_close_button_clicked();
  void action_case_button_clicked();
public:
  explicit Find_widget(MainWindow *m);
  void find_widget_activate();
  ~Find_widget();
};

#endif
#endif

/***********************************************************/
/* The Low-Level DBMS calls */
/***********************************************************/

/*
  The functions that start with "ldbms_" are supposed to be low level.
  Eventually there might be "#if mysql ... #endif" code inside them.
  Eventually there might be a separate class with all dbms-related calls.
  But we're still a long way from having dbms-independent code here.
  We have these new lists, which are created when we make the grid and deleted when we stop:
    grid_column_dbms_sources[].       = obsolete
    grid_column_dbms_field_numbers[]. = obsolete
  The idea is that any column can be special, that is, can have a source other than
  the DBMS field. So far the only special column is the row number, experimentally.
*/

/* Dynamic load
* Why dynamic-loading at runtime:
  To get rid of the warning "no version information available"
  So that we don't necessarily depend on libmysqlclient -- someday we'll allow other connections.
  The mysql documentation specifically says to use LD_RUN_PATH for mysqlclient; Qt ignores that.
  On the other hand, this is a pretty convoluted wrapper -- probably there's a more standard way
  to do it.
  (I could have checked out Qt's DBMS wrappers, but preferred to learn something at the lower level.)
  Re: mysql_library_end + mysql_library_init versus mysql_server_end + mysql_server_init:
      supposedly mysql_server_* functions are deprecated since MySQL version 5.0.3, but
      I still ran into a recent MariaDB libmysqlclient that used them, therefore if
      initially we can't find mysql_library_* functions we look for mysql_server_* functions.
  Todo: check library version (not sure how I do that, though). Maybe mysql_client_version()?
  Todo: consider allowing library name as parameter e.g. --library=perconaserverclient.so'
  Todo: if error, error message should say what you looked for. if okay, say what you found.
  Todo: consider adding in ocelotgui.pro: /opt/mysql/lib /opt/mysql/lib/mysql /usr/sfw/lib
  Todo: consider executing mysql_config --libs and using what it returns
  Todo: MySQL 5.7 has libmysqlclient.so.20, maybe look for that before libmysqlclient.so.18

  Initiate with: ldbms *lmysql;
                 lmysql= new ldbms();
                 if (lmysql == NULL) ... (Failure is possible if library cannot be loaded.)
  Call with:     lmysql->ldbms_function();
*/

#ifndef LDBMS_H
#define LDBMS_H

enum ocelot_option
{
  OCELOT_OPTION_0=0, /* for ocelot_opt_connect_timeout */
  OCELOT_OPTION_1=1,  /* for ocelot_opt_compress */
  OCELOT_OPTION_2=2,  /* for ocelot_opt_named_pipe */
  OCELOT_OPTION_3=3,  /* for ocelot_init_command */
  OCELOT_OPTION_4=4,  /* for ocelot_read_default_file_as_utf8 */
  OCELOT_OPTION_5=5,  /* for ocelot_read_default_group_as_utf8 */
  OCELOT_OPTION_6=6,  /* for ocelot_set_charset_dir_as_utf8 */
  OCELOT_OPTION_7=7,  /* for ocelot_set_charset_name_as_utf8 */
  OCELOT_OPTION_8=8,  /* for ocelot_opt_local_infile */
  OCELOT_OPTION_9=9,  /* for ocelot_protocol_as_int */
  OCELOT_OPTION_10=10,  /* for ocelot_shared_memory_base_name_as_utf8 */
  OCELOT_OPTION_11=11,  /* for ocelot_opt_read_timeout */
  OCELOT_OPTION_12=12,  /* for ocelot_opt_write_timeout */
  OCELOT_OPTION_13=13,  /* unused. in MySQL, opt_use_result */
  OCELOT_OPTION_14=14,  /* unused. in MySQL, use_remote_connection */
  OCELOT_OPTION_15=15,  /* unused. in MySQL, use_embedded_connection */
  OCELOT_OPTION_16=16,  /* unused. in MySQL, opt_guess_connection */
  OCELOT_OPTION_17=17,  /* unused. in MySQL, set_client_ip */
  OCELOT_OPTION_18=18,  /* for ocelot_secure_auth */
  OCELOT_OPTION_19=19,  /* for ocelot_report_data_truncation */
  OCELOT_OPTION_20=20,  /* for ocelot_opt_reconnect */
  OCELOT_OPTION_21=21,  /* ocelot_opt_ssl_verify_server_cert */
  OCELOT_OPTION_22=22,  /* ocelot_plugin_dir_as_utf8 */
  OCELOT_OPTION_23=23,  /* for ocelot_default_auth_as_utf8 */
  OCELOT_OPTION_24=24,  /* for ocelot_opt_bind_as_utf8 */
  OCELOT_OPTION_25=25,  /* unused. in MySQL, ssl_key */
  OCELOT_OPTION_26=26,  /* unused. in MySQL, opt_ssl_cert */
  OCELOT_OPTION_27=27,  /* unused. in MySQL, opt_ssl_ca */
  OCELOT_OPTION_28=28,  /* unused. in MySQL, opt_ssl_capath */
  OCELOT_OPTION_29=29,  /* unused. in MySQL, opt_ssl_cipher */
  OCELOT_OPTION_30=30,  /* for ocelot_opt_ssl_crl_as_utf8 */
  OCELOT_OPTION_31=31,  /* for ocelot_opt_ssl_crlpath_as_utf8 */
  OCELOT_OPTION_32=32,  /* for ocelot_opt_connect_attr_reset */
  OCELOT_OPTION_33=33,  /* unused. in MySQL, connect_attr_add */
  OCELOT_OPTION_34=34,  /* for ocelot_opt_connect_attr_delete_as_utf8 */
  OCELOT_OPTION_35=35,  /* for ocelot_server_public_key_as_utf8 */
  OCELOT_OPTION_36=36,  /* for ocelot_enable_cleartext_plugin */
  OCELOT_OPTION_37=37,  /* for ocelot_opt_can_handle_expired_passwords */
  OCELOT_OPTION_38=38,  /* for ocelot_opt_ssl_enforce */
  OCELOT_OPTION_39=39,  /* unused. in MySQL, opt_max_allowed_packet */
  OCELOT_OPTION_40=40,  /* unused. in MySQL, opt_net_buffer_length */
  OCELOT_OPTION_41=41,  /* unused. in MySQL, opt_tls_version */
  OCELOT_OPTION_42=42,  /* in MySQL 5.7.11+, opt_ssl_mode */
  OCELOT_OPTION_5999=5999,  /*unused. In MariaDB, progress_callback */
  OCELOT_OPTION_6000=6000,  /* unused. In MariaDB, nonblock */
  OCELOT_OPTION_6001=6001, /* unused. in MariaDB, thread_specific_memory */
  OCELOT_OPTION_7019=7019  /* unused, in MariaDB, found_rows */
};

#ifndef HEADER_AES_H
#define AES_BLOCK_SIZE 16
typedef struct aes_key_st { unsigned char x[244]; } AES_KEY;
#endif

class ldbms : public QWidget
{
public:


  void *dlopen_handle;

#if (OCELOT_MYSQL_INCLUDE == 1)
  /* For Qt typedef example see http://doc.qt.io/qt-4.8/qlibrary.html#fileName-prop */

  typedef my_ulonglong    (*tmysql_affected_rows)(MYSQL *);
  typedef void            (*tmysql_close)        (MYSQL *);
  typedef void            (*tmysql_data_seek)    (MYSQL_RES *, my_ulonglong);
  typedef unsigned int    (*tmysql_errno)        (MYSQL *);
  typedef const char*     (*tmysql_error)        (MYSQL *);
  typedef MYSQL_FIELD*    (*tmysql_fetch_fields) (MYSQL_RES *);
  typedef unsigned long*  (*tmysql_fetch_lengths)(MYSQL_RES *);
  typedef MYSQL_ROW       (*tmysql_fetch_row)    (MYSQL_RES *);
  typedef void            (*tmysql_free_result)  (MYSQL_RES *);
#if (MINGW_MARIADB == 0)
  typedef const char*     (*tmysql_get_client_info) (void);
#endif
  typedef const char*     (*tmysql_get_host_info)(MYSQL *);
  typedef const char*     (*tmysql_info)         (MYSQL *);
  typedef MYSQL*          (*tmysql_init)         (MYSQL *);
#if (MINGW_MARIADB == 0)
  typedef void            (*tmysql_library_end)  (void);
#endif
  typedef int             (*tmysql_library_init) (int, char **, char **);
  typedef MY_BOOL         (*tmysql_more_results) (MYSQL *);
  typedef int             (*tmysql_next_result)  (MYSQL *);
  typedef unsigned int    (*tmysql_num_fields)   (MYSQL_RES *);
  typedef my_ulonglong    (*tmysql_num_rows)     (MYSQL_RES *);
  typedef int             (*tmysql_options)      (MYSQL *, enum ocelot_option, const char *);
  typedef int             (*tmysql_ping)         (MYSQL *);
  typedef int             (*tmysql_query)        (MYSQL *, const char *);
  typedef MYSQL*          (*tmysql_real_connect) (MYSQL *, const char *,
                                                  const char *,
                                                  const char *,
                                                  const char *,
                                                  unsigned int,
                                                  const char *,
                                                  unsigned long);
  typedef int             (*tmysql_real_query)   (MYSQL *, const char *, unsigned long);
  typedef int             (*tmysql_select_db)    (MYSQL *, const char *);
  typedef char*           (*tmysql_sqlstate)     (MYSQL *);
  typedef bool            (*tmysql_ssl_set)      (MYSQL *, const char *,
                                                  const char *,
                                                  const char *,
                                                  const char *,
                                                  const char *);
  typedef MYSQL_RES*      (*tmysql_store_result) (MYSQL *);
  typedef void            (*tmysql_thread_end)   (void);
  typedef unsigned int    (*tmysql_warning_count)(MYSQL *);
  typedef int             (*tAES_set_decrypt_key)(unsigned char *, int, AES_KEY *);
  typedef void            (*tAES_decrypt)        (unsigned char *, unsigned char *, AES_KEY *);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
  typedef uint32_t        (*tmp_decode_array)    (const char **data);
  typedef const char*     (*tmp_decode_bin)      (const char **data, uint32_t *len);
  //typedef uint32_t        (*tmp_decode_binl)     (const char **data);
  typedef bool            (*tmp_decode_bool)     (const char **data);
  typedef float           (*tmp_decode_float)    (const char **data);
  typedef double          (*tmp_decode_double)   (const char **data);
  typedef int64_t         (*tmp_decode_int)      (const char **data);
  typedef uint32_t        (*tmp_decode_map)      (const char **data);
  typedef void            (*tmp_decode_nil)      (const char **data);
  typedef uint64_t        (*tmp_decode_uint)     (const char **data);
  typedef const char*     (*tmp_decode_str)      (const char **data, uint32_t *len);
  typedef uint32_t        (*tmp_decode_strl)     (const char **data);
  typedef void            (*tmp_next)            (const char **data);
  typedef enum mp_type    (*tmp_typeof)          (const char c);
  typedef ssize_t         (*ttnt_auth)           (struct tnt_stream *, const char *, int, const char *, int);
  typedef ssize_t         (*ttnt_call)           (struct tnt_stream *, const char *, size_t, struct tnt_stream *);
  typedef void            (*ttnt_close)          (struct tnt_stream *);
  typedef int             (*ttnt_connect)        (struct tnt_stream *);
  typedef ssize_t         (*ttnt_eval)           (struct tnt_stream *, const char *, size_t, struct tnt_stream *);
  typedef ssize_t         (*ttnt_delete)         (struct tnt_stream *, uint32_t, uint32_t, tnt_stream *);
  typedef ssize_t         (*ttnt_execute)        (struct tnt_stream *, const char *, size_t, struct tnt_stream *);
  typedef ssize_t         (*ttnt_flush)          (struct tnt_stream *);
  typedef int             (*ttnt_get_indexno)    (struct tnt_stream *, int, const char *, size_t);
  typedef int             (*ttnt_get_spaceno)    (struct tnt_stream *, const char *, size_t);
  typedef void            (*ttnt_stream_free)    (struct tnt_stream *);
  typedef ssize_t         (*ttnt_insert)         (struct tnt_stream *, uint32_t, struct tnt_stream *);
  typedef tnt_stream*     (*ttnt_net)            (struct tnt_stream *);
  typedef tnt_stream*     (*ttnt_object)         (struct tnt_stream *);
  typedef ssize_t         (*ttnt_object_add_array)(struct tnt_stream *, uint32_t);
  typedef ssize_t         (*ttnt_object_add_nil) (struct tnt_stream *);
  typedef ssize_t         (*ttnt_object_add_int) (struct tnt_stream *, int64_t);
  typedef ssize_t         (*ttnt_object_add_str) (struct tnt_stream *, const char *, uint32_t);
  typedef ssize_t         (*ttnt_object_add_bin) (struct tnt_stream *, const void *, uint32_t);
  typedef ssize_t         (*ttnt_object_add_bool)(struct tnt_stream *, char);
  typedef ssize_t         (*ttnt_object_add_float)(struct tnt_stream *s, float);
  typedef ssize_t         (*ttnt_object_add_double)(struct tnt_stream *, double);
  typedef ssize_t         (*ttnt_object_container_close)(struct tnt_stream *);
  typedef ssize_t         (*ttnt_object_format)  (struct tnt_stream *, const char *, int);
  typedef int             (*ttnt_object_reset)   (struct tnt_stream *);
  typedef int             (*ttnt_reload_schema)  (struct tnt_stream *);
  typedef ssize_t         (*ttnt_replace)        (struct tnt_stream *, uint32_t, struct tnt_stream *);
  typedef int             (*ttnt_reply)          (struct tnt_reply *, char *, size_t, size_t *);
  typedef tnt_reply*      (*ttnt_reply_init)     (struct tnt_reply *);
  typedef void            (*ttnt_reply_free)     (struct tnt_reply *);
  typedef int64_t         (*ttnt_request_compile)(struct tnt_stream *, struct tnt_request *);
  typedef tnt_request*    (*ttnt_request_eval)   (struct tnt_request *);
  typedef tnt_request*    (*ttnt_request_call)   (struct tnt_request *);
  typedef int             (*ttnt_request_set_exprz) (struct tnt_request *, const char *);
  typedef int             (*ttnt_request_set_tuple) (struct tnt_request *, struct tnt_stream *);
  typedef ssize_t         (*ttnt_select)         (struct tnt_stream *, uint32_t, uint32_t, uint32_t, uint32_t, uint8_t, struct tnt_stream *);
  typedef int             (*ttnt_set)            (struct tnt_stream *, int, char *);
  typedef ssize_t         (*ttnt_update)         (struct tnt_stream *, uint32_t, uint32_t, struct tnt_stream *, struct tnt_stream *);
  typedef enum tnt_error  (*ttnt_error)          (struct tnt_stream *);
  typedef char*           (*ttnt_strerror)       (struct tnt_stream *);
#endif

#if (OCELOT_MYSQL_INCLUDE == 1)
  tmysql_affected_rows t__mysql_affected_rows;   /* libmysqlclient */
  tmysql_close t__mysql_close;
  tmysql_data_seek t__mysql_data_seek;
  tmysql_errno t__mysql_errno;
  tmysql_error t__mysql_error;
  tmysql_fetch_fields t__mysql_fetch_fields;
  tmysql_fetch_lengths t__mysql_fetch_lengths;
  tmysql_fetch_row t__mysql_fetch_row;
  tmysql_free_result t__mysql_free_result;
#if (MINGW_MARIADB == 0)
  tmysql_get_client_info t__mysql_get_client_info;
#endif
  tmysql_get_host_info t__mysql_get_host_info;
  tmysql_info t__mysql_info;
  tmysql_init t__mysql_init;
#if (MINGW_MARIADB == 0)
  tmysql_library_end t__mysql_library_end;
#endif
  tmysql_library_init t__mysql_library_init;
  tmysql_more_results t__mysql_more_results;
  tmysql_next_result t__mysql_next_result;
  tmysql_num_fields t__mysql_num_fields;
  tmysql_num_rows t__mysql_num_rows;
  tmysql_options t__mysql_options;
  tmysql_ping t__mysql_ping;
  tmysql_query t__mysql_query;
  tmysql_real_connect t__mysql_real_connect;
  tmysql_real_query t__mysql_real_query;
  tmysql_select_db t__mysql_select_db;
  tmysql_sqlstate t__mysql_sqlstate;
  tmysql_ssl_set t__mysql_ssl_set;
  tmysql_store_result t__mysql_store_result;
  tmysql_thread_end t__mysql_thread_end;
  tmysql_warning_count t__mysql_warning_count;
  tAES_set_decrypt_key t__AES_set_decrypt_key;
  tAES_decrypt t__AES_decrypt;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef DBMS_TARANTOOL
  tmp_decode_array t__mp_decode_array;
  tmp_decode_bin t__mp_decode_bin;
  //tmp_decode_binl t__mp_decode_binl;
  tmp_decode_bool t__mp_decode_bool;
  tmp_decode_float t__mp_decode_float;
  tmp_decode_double t__mp_decode_double;
  tmp_decode_int t__mp_decode_int;
  tmp_decode_map t__mp_decode_map;
  tmp_decode_nil t__mp_decode_nil;
  tmp_decode_uint t__mp_decode_uint;
  tmp_decode_str t__mp_decode_str;
  tmp_decode_strl t__mp_decode_strl;
  tmp_next t__mp_next;
  tmp_typeof t__mp_typeof;
  ttnt_auth t__tnt_auth;
  ttnt_call t__tnt_call;
  ttnt_close t__tnt_close;
  ttnt_connect t__tnt_connect;
  ttnt_delete t__tnt_delete;
  ttnt_eval t__tnt_eval;
  ttnt_flush t__tnt_flush;
  ttnt_execute t__tnt_execute;
  ttnt_get_indexno t__tnt_get_indexno;
  ttnt_get_spaceno t__tnt_get_spaceno;
  ttnt_stream_free t__tnt_stream_free;
  ttnt_insert t__tnt_insert;
  ttnt_net t__tnt_net;
  ttnt_object t__tnt_object;
  ttnt_object_add_array t__tnt_object_add_array;
  ttnt_object_add_nil t__tnt_object_add_nil;
  ttnt_object_add_int t__tnt_object_add_int;
  ttnt_object_add_str t__tnt_object_add_str;
  ttnt_object_add_bin t__tnt_object_add_bin;
  ttnt_object_add_bool t__tnt_object_add_bool;
  ttnt_object_add_float t__tnt_object_add_float;
  ttnt_object_add_double t__tnt_object_add_double;
  ttnt_object_container_close t__tnt_object_container_close;
  ttnt_object_format t__tnt_object_format;
  ttnt_object_reset t__tnt_object_reset;
  ttnt_reload_schema t__tnt_reload_schema;
  ttnt_replace t__tnt_replace;
  ttnt_reply t__tnt_reply;
  ttnt_reply_init t__tnt_reply_init;
  ttnt_reply_free t__tnt_reply_free;
  ttnt_request_compile t__tnt_request_compile;
  ttnt_request_eval t__tnt_request_eval;
  ttnt_request_call t__tnt_request_call;
  ttnt_request_set_exprz t__tnt_request_set_exprz;
  ttnt_request_set_tuple t__tnt_request_set_tuple;
  ttnt_select t__tnt_select;
  ttnt_set t__tnt_set;
  ttnt_update t__tnt_update;
  ttnt_error t__tnt_error;
  ttnt_strerror t__tnt_strerror;
#endif

ldbms();

#define WHICH_LIBRARY_LIBMYSQLCLIENT 0
#define WHICH_LIBRARY_LIBCRYPTO 1
#define WHICH_LIBRARY_LIBMYSQLCLIENT18 2
#ifdef DBMS_TARANTOOL
#define WHICH_LIBRARY_LIBTARANTOOL 3
//#define WHICH_LIBRARY_LIBTARANTOOLNET 4
#endif
#define WHICH_LIBRARY_LIBMARIADBCLIENT 5
#define WHICH_LIBRARY_LIBMARIADB 6

void ldbms_get_library(QString ocelot_ld_run_path,
        int *is_library_loaded,
        void **library_handle,
        QString *return_string,
        int which_library,
        const char *so_buffer);
#if (OCELOT_MYSQL_INCLUDE == 1)
my_ulonglong ldbms_mysql_affected_rows(MYSQL *mysql);
void ldbms_mysql_close(MYSQL *mysql);
void ldbms_mysql_data_seek(MYSQL_RES *result, my_ulonglong offset);
unsigned int ldbms_mysql_errno(MYSQL *mysql);
const char *ldbms_mysql_error(MYSQL *mysql);
MYSQL_FIELD *ldbms_mysql_fetch_fields(MYSQL_RES *result);
unsigned long *ldbms_mysql_fetch_lengths(MYSQL_RES *result);
MYSQL_ROW ldbms_mysql_fetch_row(MYSQL_RES *result);
void ldbms_mysql_free_result(MYSQL_RES *result);
#if (MINGW_MARIADB == 0)
const char *ldbms_mysql_get_client_info(void);
#endif
const char *ldbms_mysql_get_host_info(MYSQL *mysql);
const char *ldbms_mysql_info(MYSQL *mysql);
MYSQL *ldbms_mysql_init(MYSQL *mysql);
#if (MINGW_MARIADB == 0)
void ldbms_mysql_library_end();
#endif
int ldbms_mysql_library_init(int argc, char **argv, char **groups);
MY_BOOL ldbms_mysql_more_results(MYSQL *mysql);
int ldbms_mysql_next_result(MYSQL *mysql);
unsigned int ldbms_mysql_num_fields(MYSQL_RES *result);
my_ulonglong ldbms_mysql_num_rows(MYSQL_RES *result);
int ldbms_mysql_options(MYSQL *mysql, enum ocelot_option option, const char *arg);
int ldbms_mysql_ping(MYSQL *mysql);
int ldbms_mysql_query(MYSQL *mysql, const char *stmt_str);
MYSQL *ldbms_mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag);
int ldbms_mysql_real_query(MYSQL *mysql, const char *stmt_str, unsigned long length);
int ldbms_mysql_select_db(MYSQL *mysql, const char *db);
const char *ldbms_mysql_sqlstate(MYSQL *mysql);
bool ldbms_mysql_ssl_set(MYSQL *mysql, const char *a, const char *b, const char *c, const char *d, const char *e);
MYSQL_RES *ldbms_mysql_store_result(MYSQL *mysql);
void ldbms_mysql_thread_end();
unsigned int ldbms_mysql_warning_count(MYSQL *mysql);
int ldbms_AES_set_decrypt_key(unsigned char *a, int b, AES_KEY *c);
void ldbms_AES_decrypt(unsigned char *a, unsigned char *b, AES_KEY *c);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1);
#ifdef DBMS_TARANTOOL
uint32_t ldbms_mp_decode_array(const char **data);
const char* ldbms_mp_decode_bin(const char **data, uint32_t *len);
//uint32_t ldbms_mp_decode_binl(const char **data);
bool ldbms_mp_decode_bool(const char **data);
float ldbms_mp_decode_float(const char **data);
double ldbms_mp_decode_double(const char **data);
int64_t ldbms_mp_decode_int(const char **data);
uint32_t ldbms_mp_decode_map(const char **data);
void ldbms_mp_decode_nil(const char **data);
uint64_t ldbms_mp_decode_uint(const char **data);
const char* ldbms_mp_decode_str(const char **data, uint32_t *len);
uint32_t ldbms_mp_decode_strl(const char **data);
void ldbms_mp_next(const char **data);
enum mp_type ldbms_mp_typeof(const char c);
ssize_t ldbms_tnt_auth(struct tnt_stream *a, const char *b, int c, const char *d, int e);
ssize_t ldbms_tnt_call(struct tnt_stream *a, const char *b, size_t c, struct tnt_stream *d);
void ldbms_tnt_close(struct tnt_stream *a);
int ldbms_tnt_connect(struct tnt_stream *a);
size_t ldbms_tnt_delete(struct tnt_stream *a, uint32_t b, uint32_t c, tnt_stream *d);
ssize_t ldbms_tnt_eval(struct tnt_stream *a, const char *b, size_t c, struct tnt_stream *d);
ssize_t ldbms_tnt_flush(struct tnt_stream *a);
ssize_t ldbms_tnt_execute(struct tnt_stream *a, const char *b, size_t c, struct tnt_stream *d);
int ldbms_tnt_get_indexno(struct tnt_stream *a, int b, const char *c, size_t d);
int ldbms_tnt_get_spaceno(struct tnt_stream *a, const char *b, size_t c);
void ldbms_tnt_stream_free(struct tnt_stream *a);
ssize_t ldbms_tnt_insert(struct tnt_stream *a, uint32_t b, struct tnt_stream *c);
tnt_stream* ldbms_tnt_net(tnt_stream *a);
tnt_stream* ldbms_tnt_object(tnt_stream *a);
ssize_t ldbms_tnt_object_add_array(tnt_stream *a, uint32_t b);
ssize_t ldbms_tnt_object_add_nil(tnt_stream *a);
ssize_t ldbms_tnt_object_add_int(tnt_stream *a, int64_t b);
ssize_t ldbms_tnt_object_add_str(tnt_stream *a, const char *b, uint32_t c);
ssize_t ldbms_tnt_object_add_bin(tnt_stream *a, const char *b, uint32_t c);
ssize_t ldbms_tnt_object_add_bool(tnt_stream *a, char b);
ssize_t ldbms_tnt_object_add_float(tnt_stream *a, float b);
ssize_t ldbms_tnt_object_add_double(tnt_stream *a, double b);
ssize_t ldbms_tnt_object_container_close(tnt_stream *a);
ssize_t ldbms_tnt_object_format(struct tnt_stream *a, const char *b, int c);
int ldbms_tnt_object_reset(struct tnt_stream *a);
int ldbms_tnt_reload_schema(struct tnt_stream *a);
ssize_t ldbms_tnt_replace(struct tnt_stream *a, uint32_t b, struct tnt_stream *c);
int ldbms_ttnt_reply(struct tnt_reply *a, char *b, size_t c, size_t *d);
void ldbms_tnt_reply_free(struct tnt_reply *a);
int64_t ldbms_tnt_request_compile(struct tnt_stream *a, struct tnt_request *b);
struct tnt_request* ldbms_tnt_request_eval(struct tnt_request *a);
struct tnt_request* ldbms_tnt_request_call(struct tnt_request *a);
int ldbms_tnt_request_set_exprz(struct tnt_request *a, const char *b);
int ldbms_tnt_request_set_tuple(struct tnt_request *a, struct tnt_stream *b);
struct tnt_reply* ldbms_tnt_reply_init(struct tnt_reply *a);
ssize_t ldbms_tnt_select(struct tnt_stream *a, uint32_t b, uint32_t c, uint32_t d, uint32_t e, uint8_t f, struct tnt_stream *g);
int ldbms_tnt_set(struct tnt_stream *a, int b, char *c);
ssize_t ldbms_tnt_update(struct tnt_stream *a, uint32_t b, uint32_t c, struct tnt_stream *d, struct tnt_stream *e);
enum tnt_error ldbms_tnt_error(struct tnt_stream *a);
char* ldbms_tnt_strerror(struct tnt_stream *a);
#endif
};


#endif // LDBMS_H

#define MAIN_WIDGET 0
#define HISTORY_WIDGET 1
#define GRID_WIDGET 2
#define STATEMENT_WIDGET 3
#define DEBUG_WIDGET 4
#define EXTRA_RULE_1 5
#define EXPLORER_WIDGET 6 /* if (OCELOT_EXPLORER == 1) */

#ifndef RESULT_CHANGES_H
#define RESULT_CHANGES_H

/*
  If a user edits a cell, the value in the result set becomes temporarily obsolete.
  So for display refreshing we will look in Result_changes to see if we want the newer value.
  Assumption = there will be very few changes (if there are many then find() will be slow).
  Todo: This must be set up when we make a result set (in fillup?) and wiped when we garbage collect.
  But should the parent be Result_qtextedit, or ResultGrid?
*/

class Result_changes: public QWidget
{
  Q_OBJECT

private:

struct Rows_and_columns{
    unsigned int row_number;
    unsigned int column_number;
    QByteArray qba;
};

Result_qtextedit *result_qtextedit;
QList<Rows_and_columns> *rows_and_columns_list;

public:
Result_changes(Result_qtextedit *m);
void append(unsigned int row_number, unsigned int column_number, QByteArray *value);
QByteArray find(unsigned int row_number, unsigned int column_number);
~Result_changes();
};
#endif

#ifndef RESULT_QTEXTEDIT_H
#define RESULT_QTEXTEDIT_H

/*
  Do not change class name "Result_qtextedit" without checking its uses e.g. in action_edit_paste().
*/

class Result_qtextedit: public QTextEdit
{
  Q_OBJECT

private:

    /* unused */
    struct result_column {
       unsigned int max_column_width;               /* calculate based on max if no squeeze */
       unsigned int height_in_chars;
       unsigned int width_in_pixels;                /* calculate from width_in_chars at start or if font change */
       unsigned int field_number;                   /* field number in result set if it's in the result set */
       char *field_names_pointer;
       unsigned int v_length;                       /* length of field name */
       unsigned char flags;
       unsigned int min_width_in_pixels;
    };


  int qtextedit_drag_start_x; /* See comment = Dragging theory. */
  int qtextedit_drag_start_y;
  int qtextedit_drag_start_time;
  bool qtextedit_is_in_drag_for_column, qtextedit_is_in_drag_for_row;
  int qtextedit_column_number_at_drag_start_time;
  int qtextedit_grid_row_number_at_drag_start_time;
  int qtextedit_result_row_number_at_drag_start_time;

  /* Things that get set by cell_analyze(). Mostly pixels or points. */
  int qtextedit_block_count;       /* from document()->blockCount() */
  int qtextedit_columns_per_row;   /* # of defined columns + 1 for the thin-image column */
  int qtextedit_x;                 /* from event->x() (changed to event->pos().x() due to qt 6 change) */
  int qtextedit_y;                 /* from event->y() (changed to event->pos().y() due to qt 6 change) */
  int qtextedit_block_number;      /* what we calculate other things from */
  int qtextedit_column_number;     /* column number, starts at 1, includes thin image column */
  int qtextedit_x_start;         /* start of the column that x is on */
  int qtextedit_x_end;           /* end of the column that x is on, border included (actual width = end - start) */
  int qtextedit_y_start;         /* start of the row that y is on */
  int qtextedit_y_end;           /* end of the row that y is on, border included (actual height = end - start) */

  Result_changes *qtextedit_result_changes;

  void cell_analyze(int x, int y);
  void construct();
  int result_row_number_from_grid_row_number(int grid_row_number);
  int grid_row_number_from_result_row_number(int result_row_number);
//  int result_column_number_from_grid_column_number(int grid_row_number, int grid_column_number);
  void generate_update();
  QString to_plain_text();

public:
  ResultGrid *result_grid;
  QString unstripper(QString value_to_unstrip);
  int qtextedit_grid_row_number;        /* row number, starts at 1, includes header row, within display */
  int qtextedit_result_row_number;      /* row number from result set, derived from qtextedit_grid_row_number */
  bool qtextedit_at_end;           /* If document doesn't fill result widget, this can become true */
  bool qtextedit_is_before_row;    /* y is on a pixel that precedes qtextedit_row */
  bool qtextedit_is_before_column; /* x is on a pixel that precedes qtextedit_column */
  QString qtextedit_cell_content;  /* cell contents. but if it's an image we get U+fffc or something like that */
                                   /* Actually this probably should be in locals */
#if (OCELOT_EXPLORER == 1)
  bool qtextedit_is_min_max_clicked;
  Context_menu *explorer_context_menu;
#endif

private slots:
// e.g. void timer_expired();

public slots:
void menu_context_t(const QPoint & pos);

#if (OCELOT_EXPLORER == 1)
void menu_context_t_explorer(const QPoint &pos);
#endif

protected:
void changeEvent(QEvent *e);
void closeEvent(QCloseEvent *e);
void focusInEvent(QFocusEvent *e);
void focusOutEvent(QFocusEvent *e);
void hideEvent(QHideEvent *e);
void keyPressEvent(QKeyEvent *e);
void mouseDoubleClickEvent(QMouseEvent *e);
void mouseMoveEvent(QMouseEvent *e);
void mousePressEvent(QMouseEvent *e);
void mouseReleaseEvent(QMouseEvent *e);
void paintEvent(QPaintEvent *e);
void resizeEvent(QResizeEvent *e);
void showEvent(QShowEvent *e);

public:

void copy();  /* via action_edit_copy() */
void cut();
void paste();
void undo();
void redo();
void selectAll();
void zoomIn();
void zoomOut();
void menu_context_t_2(const QPoint &pos);
#if (OCELOT_EXPLORER == 1)
void menu_context_t_2_explorer(const QPoint &pos);
#endif
int copy_html_cell(char *ocelot_grid_detail_numeric_column_start, char *ocelot_grid_detail_char_column_start,
                   char *tmp_pointer, char *result_pointer, char result_set_value_flags, int v_length, int cell_type,
                   int width, int height, QFont result_grid_font, int setting_max_width_of_a_char,
                   int passed_i, long unsigned int tmp_xrow, char *ocelot_grid_detail_char_column_end,
                   int *new_cell_height, unsigned int result_column_no);

explicit Result_qtextedit(ResultGrid *m);

~Result_qtextedit();

};
#endif

/*****************************************************************************************************************************/
/* THE CHART WIDGET */

#if (OCELOT_CHART == 1)
#ifndef CHART_H
#define CHART_H
/*
  CHART
  It is an alternate display choice within result grid.
  Intercept display() in result grid if user picks bar|line|pie in Options menu or via shortcut or with SET.
  It works only via display_html() and the result is HTML.
  Todo: bar|line: don't assume base is 0
  Todo: this should be exportable, because the exporting will still be of the normal result grid. But check.
  Todo: TOKEN_KEYWORD_BAR|LINE|PIE keywords aren't used by hparse. But left in because maybe someday
        we'll have them in conditional settings
  Todo: Separate statement =  [REFRESH n TIMES EVERY n SECONDS] default is 1 TIMES EVERY 60 SECONDS.
        Refreshing can be stopped by clicking OK or in extreme cases clicking Kill.
        The query is only stored in history once and history does not have results.
        If [REPEAT n] we replace completely, i.e. we don't shift|rotate the items. This is "monitoring".
        Or "performance dashboard" -- a way to repeat on the client makes monitoring easy
  Todo: Allow charts always, not just via shortcut, but with different control. "SET ocelot_extra_rule_1 = PIE"
        is one way, "SELECT x AS PIE" is one way, "SELECT 'pie',x" is one way. "SET ocelot_pie=1 is one way.
        Thus we'd be looking for signals in the output. For a while I was leaning toward
         "SELECT / *O OCELOT_GRID_CHART=BAR|CHART|PIE|NONE * /" and it could have a WHERE clause e.g.
         "SELECT / *O OCELOT_GRID_CHART=PIE WHERE COLUMN_NAME|COLUMN_NUMBER|COLUMN_TYPE|ROW_NUMBER|VLUE etc. * /"
         That is, conditions could be embedded in statement comments and applicable for grid settings in general.
         And the same WHERE clause could apply in a SET statement. (Sometimes comments are insufficient
         because the server might not store them, and because we don't know where they are when we call a
         stored procedure that returns a result set.) Con re SET statements: they're modal.
         At the moment what's implemented is SET ocelot_grid_chart=... and maybe that will never change.
         Syntax: currently any order:
            SET ocelot_grid_chart = '{BAR|LINE|PIE}          currently default=bar if this is missing, but don't do it
                           [VERTICAL]                        default is horizontal
                           [STACKED]                         default is grouping
                           [TOP=value]                       default is null
                           [RIGHT=value|LEGEND|NULL]         default is LEGEND
                           [LEFT=value|DEFAULT|NULL]         default is DEFAULT
                           [BOTTOM=value|DEFAULT|NULL]       default is DEFAULT
                           [AXIS=NULL|ALL]                   default is ALL, anything but NULL will make axes appear
                          '
            [WHERE condition];

          Someday we'll also think about other subgroups and
          RIGHT=LEGEND(GROUP_NUMBER|COLUMN_NAMES, etc.)
          PALETTE=DEFAULT (or COLOR_SCHEME?)
          TICKS=NULL|MAJOR|MEDIUM|MINOR,                         default NULL
          GROUP BY PREFIX | NAME(n) | TYPE | COUNT(n) | REGEXP(expression) | NULL (but we always break for non-numeric)
  Todo: more general way to check if data type is string or number
  Todo: add chart choices in grid settings menu, or make a chart settings menu
  * #include <QtCharts> would have been great but might not be installed
    and it is GPLv3 https://doc.qt.io/qt-5/qtcharts-index.html#licenses and ocelotgui is GPLv2.
    See illustrations at https://doc.qt.io/qt-6/qtcharts-overview.html
  * A chartable column group is a series of numeric columns, bounded by start | end | non-numeric | not-in-conditional.
    Strings or images will just be displayed as usual. So we can recognize these formats:
  * Suppose we have two rows:
    "A",1,2,3,"",2,NULL,4
    Then we want
     A         |         << bar with maximum height for 4
          |    |
         ||  | |
        |||  | |
        ---  ---          << zero line
        123  2NULL4       << captions
    ... which could even be done in ASCII.
  * Todo: Column names ending in _id are probably not quantities so could be treated as non-numeric.
  * Line width = ocelot_grid_cell_border_size. Bar width = width of a column in current (grid) font.
    Line or bar or pie-part colour = from the palette.
    When a row has more than one column, there are multiple lines|bars with different colours.
    But later lines can overwrite earlier lines.
  * Todo: Tooltip: We track mouseMoveEvent and show tooltip when mouse is over chart column.
    We could detect when a mouse is over a bar, or near a line (the "intersects" trick we
    use in ERDiagram would work for this), or over a pie's colour (by grabbing the widget
    specific or line, or when we're over a pie's colour, but that would be unhelpful when height
    is 0 or when lines cross, or colors repeat. Todo: if user has a conditional expression to change the tooltip,
    think of a way to accept it, despite the fact that there might be more than one column.
    Some thoughts about saving every relevant bit of information, that tooltip might care about, when drawing:
      Define list of structs: [ column group ] [line or rect or chord] [ x, y, width, height ] [ value ] [ column-name ]
      In Chart::Chart: set up list, blank
      In Chart::draw_group: add to list every time you draw
      In event filter: during mouseMove event: chane tooltip depending on what rect you're in
      This assumes TOOLTIP=DEFAULT
      What happens if you drag, resize, change font, etc.? do you draw again?
      Warning: you don't want to add to this every time you call draw_group, that's why there's deleting at the start.
      Alternative: make rects but do not paint, so you could recalculate 
  * Maybe in theory we could do this as an advance setting for a second result-set grid.
  * Todo: distinguishing for null, inf, nan -- maybe setAutoFillBackground() would help for bars?
    Nulls are treated as 0 (except for bars) but caption and tooltip should say NULL.
  * Todo: When numbers are negative, okay, but bars for positives don't go past the 0 point.
    And for pies, we could show abs(n), or invent a doughnut chart type, but we don't even check,
    figuring that results wouldn't make sense anyway. Eventually maybe allow doughnut charts.
  * Geometry: height in pixels. total = chart_pixmap_height, which = result grid height so max visible rows = 1
      cell border ocelot_grid_cell_border_size
      header      boundingRect("W") if there is a header
      cell border ocelot_grid_cell_border_size if there is a header
      margin      CHART_MARGIN_Y -- QPixmap starts
      chart       chart_bar_line_pie_height
      caption     boundingRect("W") maybe "list_of_values" is a better name?
      margin      CHART_MARGIN_TOP, CHART_MARGIN_BOTTOM -- QPixmap ends
      cell border ocelot_grid_cell_border_size
    ... but at this moment we're probably not looking at CHART_MARGIN values
  * Calculating bar heights
    Range = Maximum value - Minimum Value
            but if both < 0 then it's 0 - Minimum Value
            but if both > 0 then it's Maximum Value - 0
            (that means 0 is the base but maybe we should let user specify base?)
    Minimum Pixels = Character height. (though maybe ocelot_grid_cell_height would be better?)
    Maximum Pixels = ocelot_grid_height, or if that is 0 then (erd_mainwindow->height - size of "OK" button etc.)
                     (though maybe result grid height would be better?)
    Shrink_or_expand = Maximum Pixels / Maximum Value
                       e.g. if Maximum Pixels = 100 and Maximum Value = 1000 then shrink_or_expand = 0.1,
                       If Maximum Pixels = 1000 and Maximum Value = 100 then Shink = 10.
                       Earlier I said "If Shrink_or_expand > 0 then Shrink)or_expand = 1", dunno why.
    Multiply all heights * Maximum Pixels, then multiply * shrink_or_expand
    Examples of heights:
    Column Value   After * MIN     AFTER * SHRINK
    1, 2, 3        10, 20, 30      10, 20, 30
    1, 10000       10, 100000      0, 100
    ... Pie heights are more complex because we want % of area, not % of height.
  * Todo: watch out for horizontal scroll bar.
    In Chart() there could be a resize() for rg-width+rg-height.
    So we are not expecting vertical scroll bar to appear unless rg is very small but horizontal might appear.
  * Todo: A maximum column name width in characters might be okay, at least with #define
  * Shortcuts are Alt+Shift+B Alt+Shift+L Alt+Shift+P Alt+Shift+N. Alt+Shift+8/9/0 didn't work if detached.
  * Todo: define CHART_MAX_GROUP_SIZE 3, if more we start a new group. Eventually allow user-supplied.
  * Settings
    ocelot_shortcut_chart_bar|line|null|pie
    ocelot_grid_cell_border_color+size affect frame lines, not immediate
    ocelot_grid_font_size+style+weight+family affects text, immediate
    ocelot_grid_background_color affects background color, not immediate
    ocelot_grid_text_color affects left text, not immediate
    ocelot_grid_detached affects whole display, immediate
    ... plus some settings can be conditional
  * Todo: Check: what if there is no result grid
  * Todo: since color_palette_count is always <= 16, we might repeat colors.
  * Todo: the LINE chart is indented a lot, it should start at the left margin.
  * TODO: html_max_grid_rows > 1, but we only display one
  * BUG: after set ocelot_grid_font_size=40; ... we don't change the width so the header takes 2 rows!
  * BUG: set_byte_size() checks not even a number, rather than is-chartable
*/

class Chart: public QWidget
{
  Q_OBJECT

#define CHART_MARGIN_LEFT 2
#define CHART_MARGIN_RIGHT 2
//#define CHART_MARGIN_TOP 2
//#define CHART_MARGIN_BOTTOM 2
#define CHART_MARGIN_BETWEEN_BARS 1
//#define CHART_ZERO_LINE_WIDTH 2
//#define CHART_LITTLE_BAR_HEIGHT 2
//#define CHART_LITTLE_BAR_WIDTH 14
#define CHART_MAX_BYTE_SIZE 100000
#define CHART_MAX_TOKENS 20 /* we'll allow for more, or for dynamic, when possible # of tokens grows */
#define CHART_TICK_LENGTH 10 /* todo: this is too much  -- maybe should be multiple of line width? */
#define CHART_VERTICAL_LINE_WIDTH 2
#define CHART_HORIZONTAL_LINE_HEIGHT 2

public:
Chart(ResultGrid *rg, MainWindow *parent_mainwindow, int chart_type);
int chart_type; /* TOKEN_KEYWORD_BAR etc. */
ResultGrid *chart_rg;
QString group_header;
int width_n_total;
int height_n_total; /* we don't seem to be using this any more */
QList<int>chart_header_widths;
int chart_first_column_in_group;
int chart_last_column_in_group;
QFont chart_default_font;
unsigned int chart_alloc_byte_size;
void chart_row_setup(unsigned int tmp_result_row_number);
int column_in_group(int result_column_no);
double null_value(double group_max_column_value, double group_min_column_value, int chart_type, bool is_stacked);
void make_sub_group_list();
int draw_group(long unsigned int tmp_result_row_number, int result_column_no, int width, char *output);
//QList<char> chart_column_flags;

private:
MainWindow *chart_mainwindow;
int chart_pixmap_height;
int chart_width;
int chart_bar_line_pie_width;
int chart_pixmap_width;
void set_chart_width();
void set_chart_pixmap_height();
void set_byte_size();
unsigned int cha_result_column_count; /* Todo: check: why isn't this long unsigned int? */
unsigned int cha_result_row_count;
char **cha_result_set_copy_rows; /* dynamic-sized list of result_set_copy row offsets, if necessary */
char *cha_result_field_names;

QColor cha_default_text_color, cha_default_header_background_color, cha_default_detail_background_color;
int cha_default_container_pen_width;
QPen cha_default_container_pen, cha_default_text_pen;
QBrush cha_default_header_brush, cha_default_detail_brush;
QPen chart_new_container_pen, chart_new_text_pen;
QBrush chart_new_rect_brush;
char cha_color_palette[16][16];
int cha_color_palette_count;
double chart_bar_line_pie_height;
QStringList chart_column_names;
QList<double> cha_column_values;
QStringList cha_column_values_as_strings;
QList<double> cha_heights;
QList<char> cha_column_flags;

int chart_sub_group_by; /* 0 or value or column_name */
QList<int> chart_sub_group_list_sub_group_numbers;
QList<int> chart_sub_group_list_column_numbers;
int chart_sub_group_count;

QList<int> chart_column_types;
int chart_max_column_heights;
int chart_min_column_heights;
double chart_max_column_values;
double chart_min_column_values;
double chart_max_total_heights;
//double chart_height_of_zero_line;
int cha_numeric_column_count;
int cha_max_column_width, cha_max_column_height;
double cha_max_column_value;
double cha_min_column_value;
double cha_max_total_height;
int chart_bar_width;
int cha_chart_column_plus_margin_width;
int cha_left_width;
int cha_x;
QString cha_max_column_value_as_utf8;

void default_settings_all();
//void cha_setup();

unsigned short int cha_result_data_type(unsigned short int field_data_type, QString column_name);
//void cha_draw(QPainter* painter);
void set_color_palette();
void cha_draw_text_prepare(QPainter *painter,
               int column_number,    /* so we can get xpos i.e. column_number and ypos i.e. row_number */
               QString content,     /* table_name | column_name */
               int row_number,
               int cell_type,       /* TEXTEDITFRAME_CELL_TYPE_DETAIL | TEXTEDITFRAME_CELL_TYPE_HEADER */
               int text_lines,
               int numeric_column_count);

int offset_of_keyword(QString keyword);
public:
int chart_chartable_columns_count; /* result of evaluate(). if it's 0, we'll delete chart and produce a normal result set */

private:
QString chart_spec;  /* if set ocelot_grid_chart= ... need to keep frozen copy while chart is up */
int chart_token_offsets[CHART_MAX_TOKENS]; /* if set ocelot_grid_chart= */
int chart_token_lengths[CHART_MAX_TOKENS]; /* if set ocelot_grid_chart= */
//int chart_token_types[CHART_MAX_TOKENS]; /* if set ocelot_grid_chart= */

QStringList chart_column_specs;

QRect chart_bottom_rect, chart_left_rect, chart_vertical_line_rect, chart_right_rect, chart_top_rect, chart_canvas_rect, chart_horizontal_line_rect;
void set_chart_rects(int pixmap_width, int pixmap_height, int numeric_column_count, bool is_horizontal, QString top, QString bottom, QString left, QString right, QString axis, QString max_value);

#if (OCELOT_CHART_EVENTFILTER == 1)
protected:
bool eventFilter(QObject *obj, QEvent *ev);
#endif

//~Chart()
//{
//  ; /* should occur e.g. due to garbage collect or quit */
//}

};

#endif
#endif //#if (OCELOT_CHART == 1)

/*****************************************************************************************************************************/
/* THE QCHART WIDGET */

#if (OCELOT_QWT_INCLUDE == 1)

#ifndef QCHART_H
#define QCHART_H

class QMultiBarChart: public QwtPlotMultiBarChart
{
  //Q_OBJECT removed


public:

QChart *qchart;

QMultiBarChart(QChart*passed_qchart): QwtPlotMultiBarChart("Top");

void drawBar(QPainter *painter, int sampleIndex, int valueIndex, const QwtColumnRect &rect) const override;

};

class QChart: public QwtPlot
{
  Q_OBJECT

/* Some of these #defines may be unnecessary */
#define CHART_MARGIN_LEFT 2
#define CHART_MARGIN_RIGHT 2
#define CHART_MARGIN_TOP 2
#define CHART_MARGIN_BOTTOM 2
#define CHART_MARGIN_BETWEEN_BARS 1
#define CHART_ZERO_LINE_WIDTH 2
#define CHART_LITTLE_BAR_HEIGHT 2
#define CHART_LITTLE_BAR_WIDTH 14
#define CHART_MAX_BYTE_SIZE 100000
#define CHART_MAX_TOKENS 20 /* we'll allow for more, or for dynamic, when possible # of tokens grows */

public:
QChart(ResultGrid *rg, MainWindow *parent_mainwindow, int chart_type);
void chart_row_setup(unsigned int tmp_result_row_number);
char cha_color_palette[16][16];
int cha_color_palette_count;
QFont chart_default_font;
int draw_group(long unsigned int tmp_result_row_number, int result_column_no, int width, char *output);
QList<char> chart_column_flags;
int chart_bar_width;
int column_number_from_sample_and_series(int sample_number, int sub_group_number);
QString group_header;
int chart_last_column_in_group;
int width_n_total;
int height_n_total; /* we don't seem to be using this any more */
QList<int>chart_header_widths;
int column_in_group(int result_column_no);
int chart_chartable_columns_count; /* result of evaluate(). if it's 0, we'll delete chart and produce a normal result set */

private:
QString chart_spec;  /* if set ocelot_grid_chart= ... need to keep frozen copy while chart is up */
int chart_token_offsets[CHART_MAX_TOKENS]; /* if set ocelot_grid_chart= */
int chart_token_lengths[CHART_MAX_TOKENS]; /* if set ocelot_grid_chart= */
//int chart_token_types[CHART_MAX_TOKENS]; /* if set ocelot_grid_chart= */

ResultGrid *chart_rg;

int chart_first_column_in_group;

//unsigned int chart_alloc_byte_size;

MainWindow *chart_mainwindow;
int chart_pixmap_height;
//int chart_width;
int chart_bar_line_pie_width;
//int chart_pixmap_width;
void set_chart_width();
void set_chart_pixmap_height();
//Avoid set_byte_size();
unsigned int cha_result_column_count; /* Todo: check: why isn't this long unsigned int? */
unsigned int cha_result_row_count;
char **cha_result_set_copy_rows; /* dynamic-sized list of result_set_copy row offsets, if necessary */
char *cha_result_field_names;
QColor cha_default_text_color;
QColor cha_default_header_background_color;
QColor cha_default_detail_background_color;
int cha_default_container_pen_width;
QPen cha_default_container_pen;
QPen cha_default_text_pen;
QBrush cha_default_header_brush;
QBrush cha_default_detail_brush;
//QPen chart_new_container_pen,;
//QPen chart_new_text_pen;
//QBrush chart_new_rect_brush;

double chart_bar_line_pie_height;
QStringList chart_column_names;
QStringList chart_column_specs;
QList<double> cha_column_values;
//QStringList cha_column_values_as_strings;
//QList<double> cha_heights;

QList<int> chart_column_types;

int chart_sub_group_by; /* 0 or value or column_name */
QList<int> chart_sub_group_list_sub_group_numbers;
QList<int> chart_sub_group_list_column_numbers;
int chart_sub_group_count;

//int chart_max_column_heights;
//int chart_min_column_heights;
double chart_max_column_values;
double chart_min_column_values;
//double chart_max_total_heights;
//double chart_height_of_zero_line;
//int cha_numeric_column_count;
//int cha_max_column_width;
//int cha_max_column_height;
//double cha_max_column_value;
//double cha_min_column_value;
//double cha_max_total_height;
//int cha_chart_column_plus_margin_width;
//int cha_left_width;
//int cha_x;
//QString cha_max_column_value_as_utf8;
unsigned short int cha_result_data_type(unsigned short int field_data_type, QString column_name);
//void cha_draw(QPainter* painter);
void set_color_palette();
void cha_draw_text_prepare(
               int column_number,    /* so we can get xpos i.e. column_number and ypos i.e. row_number */
               QString content,     /* table_name | column_name */
               int row_number,
               int cell_type,       /* TEXTEDITFRAME_CELL_TYPE_DETAIL | TEXTEDITFRAME_CELL_TYPE_HEADER */
               int text_lines,
               int numeric_column_count);
int chart_type;
void set_orientation();
void set_mode();
void make_sub_group_list();
QColor get_color_from_palette(int sub_group_number);
//void exportChart();
void fill();
//bool is_grouped; /* probably obsolete */
//bool is_vertical; /* probably obsolete */
bool is_ticks;
void set_text_item(QString name, QString content);
void 	drawCanvas(QPainter *); /* overriding to draw pies */

int offset_of_keyword(QString keyword);
QMultiBarChart *chart_bar_chart;
void default_settings_all();
QSize chart_legend_icon_size;
//int chart_bar_width; /* guessed from font, activated with setLineWidth() */
/* NB: all QwtText items are affected by changes to font and text color but not text background color */
QwtText chart_title; bool chart_title_is_null; /* appears on top */
QwtText chart_left; bool chart_left_is_null; /* appears on left */
QwtText chart_bottom; bool chart_bottom_is_null; /* appears on bottom */
QwtText chart_legend; bool chart_legend_is_null; /* appears on right, once per color */
int chart_canvas_width;
int chart_canvas_height;
double null_value(int series, int chart_type, char *null_flag);
QwtPlotCurve *chart_curves[100];   /* todo: should be dynamic allocations or different method */
QwtLegend *chart_qwtlegend;
QScrollBar *chart_qwtlegend_scroll_bar;
protected:
//bool eventFilter(QObject *obj, QEvent *ev);
};

//#include<QPainter>

#endif //#ifndef QCHART_H
#endif //#if (OCELOT_QWT_INCLUDE == 1)

/*********************************************************************************************************/

/* THE GRID WIDGET */
/*
  As of June 2021 major change:
  The default display, which is also the odbc_html=1 vertical=0 display, is an HTML 4 table.
  We allow dragging, width|height changing, changing cell background for "focus", images,
  cut/copy/paste, scrolling.
  Todo: allow change of setTextDirection() based on language or on client variable.
  Todo: see this re trail spaces: http://qt-project.org/doc/qt-4.8/qtextoption.html#Flag-enum
  Todo: although min(column width) = heading width, don't have to make text editable area that wide
  Todo: have to think what to do with control characters, e.g. for tabs should I have
        setTabChangesFocus(true), for others should I allow the effects or display specially.
  Todo: I used an eventfilter to detect scrolling because QScrollBar::valueChanged()
        failed, but someday I should find out why and retry. See vertical_scroll_bar_event().
  Todo: "new" operations should have nothrow checks.
  Todo: add even more junk about dontshowonscreen or opacity if there is flickering.
  Todo: Our wrap policy is like QTextOption::WrapAnywhere -- there could be a user-settable option for this
        if the preference was to wrap on word boundaries when possible. Could be difficult.
*/
/*
  Todo:
  These events can happen to a grid and force recalculation:
  QEvent::ContentsRectChange               The margins of the widget's content rect changed.
  QEvent::FontChange                       Widget's font has changed.
  QEvent::HideToParent                     a child widget has been hidden
  QEvent::Resize
  QEvent::ShowToParent                     a child widget has been shown
  QEvent::StyleChange                      I don't think this matters
  ... Also, user might resize columns or rows via dragging.
*/

/*
  this
    hbox_layout                QHBoxLayout
      grid_scroll_area         QScrollArea *
      grid_vertical_scroll_bar QScrollBar *
  client                       QWidget *
    grid_main_layout           QVBoxLayout
      html_text_edit           Result_qtextedit *

  Making the grid-cell QTextWidgets resizable was difficult.
  I couldn't get satisfactory results with QSplitter, and don't believe that satisfactory results would be possible.
  Finally a suggestion by Aleksey Osipov aliks-os@yandex.ru https://qt-project.org/wiki/Widget-moveable-and-resizeable
  inspired me. I didn't actually use the suggestion (my requirements are much simpler), but I realized that all one has to do is
  subclass a QFrame with a QTextEdit inside it, and put routines in for when the mouse is pressed|moved|released on
  the QFrame. In this implementation only right|left dragging of the subclassed QFrame, called TextEditFrame, is allowed.
  Todo: Mr Osipov had routines for resizing with keyboard control, and I should add that.
  Todo: up|down dragging, although vertical shrinking will not mean that more rows appear on the screen.
        Up|down dragging "works" now but is undocumented, and still needs fixes for:
          todo: minimum height (currently doesn't look right), bottom drag line size, bottom drag line color
  Todo: vertical resizing currently looks odd. I've read that "Correct place to do special layout management is overridden resizeEvent."
  Todo: test with a frame that has been scrolled horizontally so half of it is not visible, while there's a scoll bar.
  Todo: There can be a bit of flicker during drag though I doubt that anyone will care.
  Todo: BUG: If the QTextEdit gets a vertical scroll bar, then the horizontal cursor appears over the scroll bar,
        and dragging won't work. The problem is alleviated if border_size > 1. (Check: maybe this is fixed.)
  Todo: Initializing copy_of_ocelot_html etc. works around a problem but isn't adequate if user changes
        ocelot_html etc. to non-default values and then changes the font.
  Todo: Find out why cut-and-paste often fails. Maybe it's that selecting doesn't change colour or paintevent returns wrong.
  Re cursor shapes, see http://qt-project.org/doc/qt-4.8/qcursor.html#details
*/

/*
  The changes made by dragging are persistent as long as the result set is up.
*/

/*
  Note#1:
  For TextEditFrame's mouseMoveEvent we say setCursor to change the shape, as we should, to hint it's draggable.
  But http://qt-project.org/doc/qt-4.8/qwidget.html#cursor-prop says:
  "If no cursor has been set, or after a call to unsetCursor(), the parent's cursor is used."
  That affects the child QTextEdit when it touches the border, and it in turn has a child: the vertical scroll bar.
  Therefore there is also an explicit setCursor for the child QTextEdit.
*/

/*
  Re: how the grid is displayed
  The display is reasonably close to instant in most cases, even when there are thousands of rows.
  Mostly that's because there are only a few hundred widgets, regardless of result row count.
  We create a pool of cell widgets and a pool of row widgets, which only needs expanding if there are many many columns per row.
  When it comes time to display a cell, if it was previously used  for displaying a different row + column, we change it.
  There's some added complication if sql_more_results is true; in that case we make a copy of the contents of mysql_res.
  Actually I think sql_more_results is always true nowadays.
*/

#ifndef RESULTGRID_H
#define RESULTGRID_H

class ResultGrid: public QWidget
{
  Q_OBJECT
private:
  QWidget *client;
public:
  int grid_vertical_scroll_bar_value;                            /* Todo: find out why this isn't defined as long unsigned */
  QScrollArea *grid_scroll_area;
  int result_grid_type; /* 0 or EXPLORER_WIDGET */
  unsigned long html_max_grid_rows;
  unsigned int explorer_max_name_width_in_chars;                 /* = EXPLORER_FIXED_NAME_WIDTH if default */
  QScrollBar *grid_vertical_scroll_bar;                          /* This might take over from the automatic scroll bar. */
  unsigned int result_column_count;
  long unsigned int result_row_count, grid_result_row_count;
//  long unsigned int *lengths;
  unsigned int *grid_column_widths;                         /* dynamic-sized list of widths */
  unsigned int *result_max_column_widths; /* chars not bytes */ /* dynamic-sized list of actual maximum widths in detail columns */
  unsigned int *grid_column_heights;                         /* dynamic-sized list of heights */
  unsigned char *grid_column_dbms_sources;                   /* dynamic-sized list of sources */
  unsigned short int *result_field_types;          /* dynamic-sized list of types */
  unsigned int *result_field_charsetnrs;           /* dynamic-sized list of character set numbers */
  unsigned int *result_field_flags;                /* dynamic-sized list of flags */
//  unsigned long result_row_number;                    /* row number in result set */
#if (OCELOT_MYSQL_INCLUDE == 1)
  MYSQL_ROW row;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
  int is_paintable;
#ifdef OLD_STUFF
  unsigned int max_text_edit_frames_count;                       /* used for a strange error check during paint events */
#endif
  unsigned int grid_row_heights[1000];

  unsigned int result_grid_widget_max_height_in_lines;
#if (OCELOT_MYSQL_INCLUDE == 1)
  MYSQL_FIELD *mysql_fields;
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef OLD_STUFF
  TextEditWidget **text_edit_widgets; /* Todo: consider using plaintext */ /* dynamic-sized list of pointers to QPlainTextEdit widgets */
  QHBoxLayout **text_edit_layouts;
  TextEditFrame **text_edit_frames;
#endif
  MYSQL_RES *grid_mysql_res;
  unsigned short ocelot_vertical_copy;
  unsigned short ocelot_result_grid_column_names_copy;
  unsigned short ocelot_client_side_functions_copy;
  char *result_set_copy;                                     /* gets a copy of mysql_res contents, if necessary */
  char **result_set_copy_rows;                               /* dynamic-sized list of result_set_copy row offsets, if necessary */
  char *result_field_names;                                  /* gets a copy of mysql_fields[].name */
  char *result_original_field_names;                         /* gets a copy of mysql_fields[].org_name */
  char *result_original_table_names;                         /* gets a copy of mysql_fields[].org_table */
  char *result_original_database_names;                      /* gets a copy of mysql_fields[].db */

  unsigned int gridx_column_count;
  long unsigned int gridx_row_count;
  char *gridx_field_names;                                   /* gets a copy of result_field_names */
  unsigned int *gridx_max_column_widths; /* chars not bytes */ /* gets a copy of result_max_column_widths */
  unsigned int *gridx_result_indexes;                        /* points to result_ lists */
  unsigned char *gridx_flags;                                /* 0 = normal, 1 = row counter */
  unsigned short int *gridx_field_types;                     /* gets a copy of result_field_types */

//  unsigned int grid_actual_grid_height_in_rows;
  unsigned int grid_actual_row_height_in_lines;
  /* ocelot_grid_height_of_highest_column will be between 1 and ocelot_grid_max_column_height_in_lines, * pixels-per-line */
  unsigned int max_height_of_a_char;
  unsigned int setting_max_width_of_a_char;                  /* changeable with settings_change_calc() */
  unsigned int setting_min_width_of_a_column;                /* changeable with settings_change_calc() */
  unsigned int setting_bearing;                              /* changeable with settings_change_calc() */

 QHBoxLayout *hbox_layout;

//  QHBoxLayout **grid_row_layouts;                               /* dynamic-sized list of pointers to rows' QHBoxLayout layouts */
//  QWidget **grid_row_widgets;                                   /* dynamic-sized list of pointers to rows' QWidget widgets */
  QVBoxLayout *grid_main_layout;                                   /* replaces QGridLayout *grid_layout */
  /* QWidget *grid_main_widget;  */                                /* replaces QGridLayout *grid_layout -- but we say "client" */

  MainWindow *copy_of_parent;
  int copy_of_connections_dbms;
  unsigned short int copy_of_ocelot_vertical;
  unsigned short int copy_of_ocelot_result_grid_column_names;
  unsigned short int copy_of_ocelot_batch;
  unsigned short int copy_of_ocelot_html;
  unsigned short int copy_of_ocelot_raw;
  unsigned short int copy_of_ocelot_xml;

  Result_qtextedit *html_text_edit;
  QTextEdit *batch_text_edit;

  int border_size;                                             /* used when calculating cell height + width */
  unsigned int ocelot_grid_max_desired_width_in_pixels;        /* used when calculating cell height + width */
  unsigned int ocelot_grid_max_column_height_in_lines;         /* used when calculating cell height + width */
  unsigned int grid_max_column_height_in_pixels;

  unsigned int setting_ocelot_grid_cell_drag_line_size_as_int; /* no longer used */
  unsigned int setting_ocelot_grid_cell_border_size_as_int;    /* changeable with settings_change_calc() */
  unsigned int setting_ocelot_grid_cell_width_as_int;
  QString ocelot_grid_text_color;
  QString ocelot_grid_background_color;
//  QString ocelot_grid_cell_drag_line_color;

#ifdef OLD_STUFF
  QString frame_color_setting;                                 /* based on drag line color */
#endif
  QFont result_grid_font;
  ldbms *lmysql;
  unsigned int scroll_bar_width;
  unsigned int scroll_bar_height;
  int result_grid_height_after_last_resize; /* not unsigned int because we might see it as -1 */
  int result_grid_width_after_last_resize;

  int result_grid_vertical_width_of_header;
  int result_grid_vertical_width_of_value;

  int focus_result_row_number, focus_column_number;
#if (OCELOT_CHART == 1)
  Chart *chart_widget;
#endif
#if (OCELOT_QWT_INCLUDE == 1)
  QChart *chart_widget;
#endif

/* How many rows can fit on the screen? Take a guess for initialization. */
#define RESULT_GRID_WIDGET_INITIAL_HEIGHT 10


/* Todo: Maybe it would be better to depend on setting_min_width_of_a_column */
#define MIN_WIDTH_IN_CHARS 3

ResultGrid(
//        MYSQL_RES *mysql_res,
        ldbms *passed_lmysql,
        MainWindow *parent,
        bool is_displayable,
        int passed_result_grid_type);

bool is_image_format(int length, char* pointer);
bool is_fancy();
QString fillup(MYSQL_RES *mysql_res,
            //struct tnt_reply *tarantool_tnt_reply,
            int connections_dbms,
            //MainWindow *parent,
            ldbms *passed_lmysql,
            int ocelot_client_side_functions,
            unsigned int connection_number,
            bool is_for_display);
QString fillup_in_client(QString, int *main_token_lengths, int *main_token_offsets); /* temporary? */
void switch_to_batch_text_edit();
void switch_to_html_text_edit();
void display_batch();
void display(int due_to,
             unsigned short ocelot_vertical,
             unsigned short int ocelot_batch,
             unsigned short int ocelot_html,
             unsigned short int ocelot_raw,
             unsigned short int ocelot_xml,
             unsigned short ocelot_result_grid_column_names,
             unsigned short int ocelot_bar,
             unsigned short int ocelot_line,
             unsigned short int ocelot_pie);
#ifdef OLD_STUFF
void frame_resize(int ki, int grid_col, int width, int height);
#endif
#ifdef OLD_STUFF
void frame_resize_for_drag_right(int ki, int grid_col, int width, int height);
void frame_resize_for_drag_bottom(long int xrow, int ki, int grid_col, int width, int height);
#endif
QString get_border_color();
int thin_image(char *tmp_pointer, const char *th_or_td, int height);
#define MAX_MAX_CONDITIONS 10
char ocelot_grid_table_start[4000];
char ocelot_grid_header_row_start[32];
char ocelot_grid_header_row_end[32];
char ocelot_grid_header_numeric_column_start[32];
char ocelot_grid_header_numeric_column_end[32];
char ocelot_grid_header_char_column_start[32];
char ocelot_grid_header_char_column_end[32];
char ocelot_grid_detail_row_start[32];
char ocelot_grid_detail_row_end[32];
char ocelot_grid_detail_numeric_column_start[320];
char ocelot_grid_detail_numeric_column_end[32];
char ocelot_grid_detail_char_column_start[320];
char ocelot_grid_detail_char_column_end[32];
char ocelot_grid_table_end[320];
void prepare_for_display_html();
int column_height(unsigned int grid_row, int column_no, int v_length, char *value);
void get_row_height_and_max_display_height_and_max_grid_rows(int *row_height, int *max_display_height, int *max_grid_rows);
void display_html(int new_grid_vertical_scroll_bar_value, int situation);
int html_row_height(char *tmp_pointer_of_row_start, char *tmp_pointer, int over_height);
void display_html_html_vertical(int new_grid_vertical_scroll_bar_value);
#if (OCELOT_EXPLORER == 1)
#define EXPLORER_MIN ""
#define EXPLORER_MAX ""
unsigned int explorer_first_result_row;
#define EXPLORER_COLUMN_COUNT 3
#define EXPLORER_FLAG_MIN 1/* = 1 if minimized */
#define EXPLORER_FLAG_FILTERED 2 /* = 2 if filtered */
#define EXPLORER_FLAG_NOT_FILTERED 4 /* = 4 if not filtered i.e. this alone is not filtered, all others are */
#define EXPLORER_FIXED_NAME_WIDTH 20 /* arbitrary, big names take more lines */
void explorer_initialize();
void explorer_display();
void explorer_display_part();
void explorer_display_html(int new_grid_vertical_scroll_bar_value);
void explorer_toggle(int focus_result_row_number);
void explorer_filter(int focus_result_row_number);
void explorer_reset();
void explorer_row_size();
#endif
#ifdef DBMS_TARANTOOL
int column_number(char *column_name, int *off);
#endif
#ifdef DBMS_TARANTOOL
int creates(QString create_table_statement, int connections_dbms_0, QString read_format_result);
#endif
#ifdef DBMS_TARANTOOL
int inserts(QString temporary_table_name);
#endif
void copy_result_to_gridx();
bool is_blob(int field_type);
bool is_extra_rule_1(int col);
bool is_image(int col);
QByteArray history_padder(char *str, int length,
                       int column_width, char field_value_flags);
#define HISTORY_COLUMN_MARGIN 1
#define HISTORY_MAX_COLUMN_WIDTH 65535
#define HISTORY_MAX_COLUMN_COUNT 65535
#define HISTORY_MAX_VERTICAL_COLUMN_WIDTH 8192
QString copy_to_history(long int ocelot_history_max_row_count,
                        unsigned short int is_vertical,
                        int connections_dbms,
                        char *file_name);
int get_cell_width_or_height_as_int(QString cell_width_or_height_as_qstring, int min);
void grid_column_size_calc(int setting_ocelot_grid_cell_border_size_as_int,
                           int setting_ocelot_grid_cell_drag_line_size_as_int,
                           unsigned short int is_using_column_names,
                           int connections_dbms);
void grid_column_size_calc_vertical(
                           unsigned short int is_using_column_names,
                           int connections_dbms);
QString client_scan_rows(unsigned int result_column_count, unsigned int result_row_count,
                         /* MYSQL_RES *p_mysql_res, */
                         char **p_result_set_copy,
                         char ***p_result_set_copy_rows,
                         unsigned int **p_result_max_column_widths, int query_size, QStringList values_list, QList<int>types_list);

#if (OCELOT_MYSQL_INCLUDE == 1)
void scan_rows(unsigned int p_result_column_count,
               unsigned int p_result_row_count,
               MYSQL_RES *p_mysql_res,
               char **p_result_set_copy,
               char ***p_result_set_copy_rows,
               unsigned int **p_result_max_column_widths);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
void set_img_type(const char *pointer, unsigned int v_length, char *img_type);
void set_max_column_width(unsigned int v_length,
                         const char *result_set_copy_pointer,
                         unsigned int *p_result_max_column_width);
#if (OCELOT_MYSQL_INCLUDE == 1)
void scan_field_names(
               const char *which_field,
               unsigned int p_result_column_count,
               char **p_result_field_names);
#endif //#if (OCELOT_MYSQL_INCLUDE == 1)
#ifdef OLD_STUFF
int set_alignment_and_height(int text_edit_frames_index, unsigned int grid_row, int field_type,
                              bool is_header, int maximum_width);
#endif
#ifdef OLD_STUFF
int get_column_height_in_pixels(unsigned int text_edit_frames_index, int width, int copy_of_grid_max_column_height_in_pixels);
#endif
#ifdef OLD_STUFF
int set_height(unsigned int text_edit_frames_index, int width);
#endif
int get_column_width_in_pixels(QString s, bool is_header, bool is_image_flag);
#ifdef OLD_STUFF
void fill_detail_widgets(int new_grid_vertical_scroll_bar_value, int connections_dbms);
#endif
void resize_or_font_change(int height_of_grid_widget, bool is_resize);
void color_change();
void set_grid_max_column_height_in_pixels(int result_grid_height);
void resizeEvent(QResizeEvent *event);
int fontchange_event();
bool show_event();
bool vertical_scroll_bar_event(QEvent *event, int connections_dbms);
void vertical_scroll_bar_construct();
void vertical_scroll_bar_initialize();
#ifdef OLD_STUFF
void text_align(TextEditWidget *cell_text_edit_widget, enum Qt::AlignmentFlag alignment_flag);
#endif
void fillup_garbage_collect(bool is_final);
void display_garbage_collect(bool is_final);
#ifdef OLD_STUFF
void set_frame_color_setting();
#endif
void set_all_style_sheets(QString new_ocelot_grid_style_string,
                          QString new_ocelot_grid_cell_drag_line_size,
                          int caller,
                          bool is_result_grid_font_changed);
void settings_change_calc();
int character_count_to_pixel_count(int character_count);
unsigned int dbms_get_field_flag(unsigned int column_number, int connections_dbms);
QString dbms_get_field_name(unsigned int column_number, int connections_dbms);
unsigned int dbms_get_field_name_length(unsigned int column_number, int connections_dbms);
~ResultGrid();
bool comparer(
        QString opd1,
        QString opd2,
        QString opr,
        char field_value_flags);
#define MAX_CONDITIONAL_STATEMENT_TOKENS 100 /* todo: this is a duplicate of what's defined in MainWindow */
bool conditional_setting_evaluate(int cs_number,
                                  int cs_column_number,
                                  int cs_result_row_number,
                                  char *cs_content_pointer,
                                  char cs_content_flags,
                                  unsigned int cs_content_length,
                                  unsigned short int cs_cell_type,
                                  QString old_style_sheet,
                                  bool is_always_true,
                                  QString *cs_new_tooltip,
                                  QString *cs_new_style_sheet,
                                  QString *cs_new_cell_height,
                                  QString *cs_new_cell_width,
                                  QString *cs_new_action,
                                  QString *cs_new_enabled,
                                  QString *cs_new_shortcut,
                                  QString *cs_new_text,
                                  ResultGrid* upper_rg);
bool conditional_setting_evaluate_till_true(
                                  int cs_column_number,
                                  int cs_result_row_number,
                                  char *cs_content_pointer,
                                  char cs_content_flags,
                                  unsigned int cs_content_length,
                                  unsigned short int cs_cell_type,
                                  QString *cs_new_tooltip,
                                  QString *cs_new_style_sheet,
                                  QString *cs_new_cell_height,
                                  QString *cs_new_cell_width,
                                  int *returned_cs_number,
                                  QString *cs_new_text,
                                  ResultGrid *upper_rg);
#if (OCELOT_CHART_OR_QCHART == 1)
bool evaluate_for_chart(bool is_mainwindow_calling);
#endif

public slots:

private:

};
#endif // RESULTGRID_H

#if (OCELOT_ERDIAGRAM == 1)
#ifndef ERDIAGRAM_H
#define ERDIAGRAM_H

/*
  THE ERDIAGRAM WIDGET
  Draw all base tables in schema, and lines between them if there are foreign keys.
  Widget is scrollable, cancellable with an OK button, sized appropriately if possible.
  Statement:
    SET ocelot_query = SHOW ERDIAGRAM OF schema-name
    [COLUMNS PRIMARY]
    [LINES IN BACKGROUND]
    [TABLES (table-list)];
    Statement is rejected if explorer is not visible. And explorer might need to be refreshed.
    COLUMNS PRIMARY means "only show columns of primary key". Not a great idea but others do it.
    LINES IN BACKGROUND means "draw lines before drawing tables" so rects overwrite lines.
    TABLES (table-list) means "draw these tables only" otherwise all tables appear.
  Lines:
    For each relationship there is a line between rects.
    Line width = ocelot_grid_cell_border_size, or 1. That's too thin so we multiply a bit.
    Lines contain marks.
    Lines are straight.
  Marks:
    A "mark" is a circle, crow's foot, double bar, or single bar on a line. (Is there a better word?)
    Marks take up a square area = erd_default_mark_length (line_width comes from the grid setting
    ocelot_grid_cell_border_size, or 1), not counting external, which is erd_default_mark_length.
    Saying "#define MARK_MULTIPLIER 5" looks okay, but 4 or >5 look okay too so it's arbitrary.
    Todo: maybe it should depend on font size?
    A line length has to be greater than the combined length of all marks.
    In all functions: y = where line is on y axis, x = where line is on x axis
    Todo: Reduce the multiplier if the resultant height would be more than the font's character height
  Angles:
    Bars, or side toes of a crow's foot, are at an angle from the main line. If the line is not pure horizontal
    or vertical, this angle might need a slight adjustment.
  Grid unconditionals:
    This is not a grid widget (using grid widget directly was considered and might be reconsidered someday).
    But grid settings affect it, including default font, background colour, cell border size.
    Maybe explorer settings would have been better?
  Grid conditionals:
    Some but not all conditional expressions should work. Theoretically I can affect background
    colour etc. for a style sheet, see https://codeloop.org/how-to-draw-text-line-in-qt5-with-qpainter/
    and https://stackoverflow.com/questions/30171022/qtextdocument-default-style-sheet. But I couldn't get
    proper results. So call conditional_setting_evaluate_till_true() but only take the changes to background
    and text (and border colour?). Interpret row and column as erd_table[].xpos and erd_table[].ypos.
    Todo: Accept conditional changes of font size, tooltip, width, height.
    Some conditional settings that affect ERDiagram are: ocelot_grid_text_color ocelot_grid_font_weight
    ocelot_grid_font_style ocelot_grid_background_color.
  Positions:
    When looking whether a space is available we compare x,y as if the rectangles are points near the middle
    of a (midpoint, midpoint) matrix where midpoint= number of tables. Later we expand the rectangles, leave
    spaces between, and subtract the smallest that's actually available.
  Bend counting:
    Routines whose names start with bend_count are for a late phase, after we've got something that might be OK
    but might contain some rects whose position is not ideal. Actually we have no bends, but the principle is
    the same as if we did: are our lines crossing rects, or (much less bad) diagonal? If so, try repositioning.
    This phase involves arbitrary numbers and might not always result in improvement.
  Additional information:
    In MySQL/MariaDB a primary key will always (?) be named PRIMARY so you can determine which columns
    are in primary keys just by looking at oei_fk[].constraint_name. Also you can determine which columns
    are in foreign keys: if oei_fk[].referencing_table is not blank. Also you can determine which columns
    are in unique keys: if they're not primary or foreign.
  Todo: searching oei would be quicker if parts simply pointed to objects rather than contain object_name.
  Todo: new option: zigzags instead of straight lines
  Todo: new option: user can list the palette's line colours, or colours can be in conditional expressions
        or palette can include dotted | transparent lines, e.g. setDashPattern for QPen
        e.g. [LINE COLORS (color [, color ...] and ocelot_grid_cell_border_color is an acceptable color.
  Todo: We're depending that in oei right after table "T" will come its parts including column "C".
        But is this dependable? Is it working with Tarantool too? Will choosing to sort wreck it?
        But this means oei is useless if we call explorer_sort() with user option 'yes' so disable that.
        It should be disabled, or an error should appear if it was used and users try to get a diagram.
  Todo: Export: could be done with this if you were satisfied with the part of the widget that is on the screen:
        QPixmap main_pixmap(16000, 16000); ... after painter.end()
        main_pixmap= erdiagram_widget->grab();
        main_pixmap.save("/home/pgulutzan/tmp.png");
        Maybe this could be a "Save" option, or maybe part of the SET ocelot_query statement.
  Todo: oei_fk[] has duplicates if there are multi-column keys. We don't care about ordinal position but when
        we add to relations we have to be sure we're not reflecting the duplication. Therefore:
        struct relation_items must include ordinal number.
  Todo: There might be references to nonexistent tables, due to user setting foreign_key_checks=0.
        We will ignore them. But it might be possible to set up dummies, if they appear in
        information_schema.key_column_usage.
        See: "if ((i_of_referenced_table != -1) && (i_of_referencing_table != -1)".
        Similarly, if there is a reference to a table in a different schema.
  Todo: Extra pixel(s) after last column would be nice, but changing ERD_MARGIN_Y doesn't solve it.
  Todo: if conditional causes italic, not wide enough. Actually we seem to have lost all the fixed margins.
  Todo: How about it being the current default database if user doesn't specify a schema?
  Todo: Notice lower case. Whether to compare case insensitive is a real trial depending on server settings.
        I'm comparing caseInsensitive but that will be bad if there's both an X and an x.
        Maybe say caseInsensitive if SHOW ERDIAGRAM SCHEMA "delimiated_name".
  Todo: Lots of errors can occur and we should pass them to the caller to pass to the user.
  Todo: Check that the erd widgets and other "new" items are properly destroyed after exec()
  Todo: Reconsider whether we should require explorer or do our own seeking here.
  Todo: We ignore when erd_mainwindow->oei_fk[i].ordinal_position <> "1" because with a multi-column foreign
        key we don't want to see three relations. However, if we ever decide to describe the relation to the
        user, e.g. via a tooltip, or by having lines coming out of each column with the non-first column
        lines skinny or transparent, we'll find that we can't ignore forever.
  Todo: (this is really a general todo but can apply for erdiagram as well as others) use
        int *x = new(nothrow) int;
        if (x == 0)) the new failed -- but all you can do is assert unless you can pass an error up the line
  Todo: Although we have a way to specify where rects go, there are are other possible ways to specify.
        There might be some semi-standard way to specify, so do some research first.
        Notice later comment re [TABLES (table-list)] clause.
  Todo: Catch right-click, give user a chance to delete or move a rect or a line.
  Todo: Catch keyboard, some control keys on main menu e.g.^Q might be okay.
  Todo: Probably this is a bug:
        SET ocelot_grid_text_color='white' WHERE row_number = 2;
        changes the second row, but tooltip says y (row) = 1
  Todo: Help | ERDiagram
  Todo: SET ocelot_grid_tooltip should affect what we do when mouseMoveEvent() happens
  Todo: If [TABLES (table-list)] I think we follow the list order, maybe reference_count order would be better,
        but (a) do not take into account a relation which relates a table to another table that we didn't list
            (b) priority is by the order that you inserted, not the references count
            (c) maybe we don't need to do the shift and exchange at the end
  Todo: Unfortunately changing font size won't affect setWindowTitle(), at least on Linux.
        Maybe I could hide the title and put in a (disabled) button but that would lack the Windows decoration.
*/
class ERDiagram;

class erd: public QWidget
{
  Q_OBJECT

private:
ERDiagram *erd_erdiagram;
MainWindow *erd_mainwindow;

#define ERD_MARGIN_X 2
#define ERD_MARGIN_Y 2
#define MARK_MULTIPLIER 5
#define ERD_BAR1 0
#define ERD_BAR2 1
#define ERD_CROWS_FOOT 2
#define ERD_CIRCLE 4
/* Todo: We're preventing big rects because there were crashes. See whether there's a better solution, eh? */
#define MAX_COLUMN_NAMES 500

//#define PACKED /* If this is defined, rects are closer. But I think it doesn't look as nice. */

QFont erd_default_font;

QColor erd_default_text_color, erd_default_header_background_color, erd_default_detail_background_color;
int erd_default_container_pen_width;
int erd_default_mark_length;
int erd_default_space_between_rects;
QPen erd_default_container_pen, erd_default_text_pen;
QBrush erd_default_header_brush, erd_default_detail_brush;
qreal erd_main_line_angle;
char erd_color_palette[16][16];
int erd_color_palette_count;
//QPixmap *main_pixmap;
QString erd_schema_name;
bool erd_is_lines_in_background;
bool erd_is_primary;
struct table_items {
  unsigned int i_of_oei;  /* so we can get table name from oei[i_of_oei].object_name */
  QRect erd_rect;      /* rectangle containing table + column names. outer, i.e. includes border */
  QRect columns_rect;     /* rectangle containing column names */
  int columns_count;
  int xpos;
  int ypos;
  int w;
  int l;
  int references_count;
  bool is_fixed; /* true iff user specified x and y in (table list) */
  QRect pushed_rect; /* Filled in by bend_count_push() */
};
struct table_items *erd_tables;
int erd_tables_count;
int erd_midpoint;
/* Relations are what we will use to determine positions and lines */
struct relation_items {
  int i_of_referencing_table; /* should point to erd_tables of the table with the referencing key */
  int i_of_referenced_table;  /* should point to erd_tables of the table with the primary|unique key */
  bool done;
  QPointF P1;
  QPointF P2;
  int i_of_explorer_items_fk;
};
struct relation_items *erd_relations;
int erd_relations_count;
QString erd_query;
int erd_token_offsets[1000]; /* todo: this should be dynamic, table list could have > 1000 tokens */
int erd_token_lengths[1000];
void default_settings_erd();
void default_settings_erdiagram();
void set_color_palette();
QRect place_table_and_connected_tables(QRect last_rect, int t);
QRect next_available_rect(QRect last_rect, QRect this_rect, int t);
QRect next_available_rect_2(QRect last_rect, QRect this_rect, int i_direction);
QRect next_available_rect_3(QRect last_rect, QRect this_rect, int i_direction);
bool is_available_rect(int x, int y);
int bounding_rect_width(QFont qf, QString name);
int bounding_rect_height(QFont qf, QString name);
public:
erd(ERDiagram *parent_erdiagram, MainWindow *parent_mainwindow, QString passed_schema_name, QString passed_query);
private:
void fill_tables();
int i_of_table_in_query_table(QString oei_table_name, int *x, int *y);
QPointF draw_mark(QPainter *painter, int erd_type, QPointF main_line_point);
void draw_line(QPainter *painter, int x1, int y1, int x2, int y2, int i_of_relation);
#ifdef PACKED
void set_table_rects(int max_x, int max_y);
#else
void set_table_rects();
#endif
void bend_count_main();
int bend_count_all();
int bend_count_one_relation(int i_of_relation);
int bend_count_one_table(int i_of_table);
void bend_count_push();
void bend_count_pop();
void bend_count_try_shift(int i_of_table);
void bend_count_try_exchange(int i_of_table);
void draw_table(QPainter *painter, int table_number);
void erd_draw_text_prepare(QPainter *painter,
               int table_number,
               QString content,
               int cell_type,
               QRect qr_of_content);
void set_lines();
QPointF point_near_point(QPointF p, QLineF l);
void line_ends(int r0, int r1, QPointF *p1, QPointF *p2, QLineF *line_at_rect_side_p1, QLineF *line_at_rect_side_p2);
QPointF line_rect_intersection(QRect rect, QLineF line, QLineF *line_at_rect_side);
void paintEvent(QPaintEvent *event);
void mouseMoveEvent(QMouseEvent *event);
QString tooltip_of_rect(QPoint mouse_point);
QString tooltip_of_line(QPoint mouse_point) ;
~erd();

};

class ERDiagram: public QDialog
{
  Q_OBJECT

private:
QPushButton *button_for_ok;
MainWindow *erdiagram_mainwindow;
erd* erd_widget_erd;

public:
ERDiagram(MainWindow *parent_mainwindow, QString passed_schema_name, QString query);
~ERDiagram();

private slots:
void handle_button_for_ok();

};

#endif // #ifndef ERDIAGRAM_H
#endif // #if (OCELOT_ERDIAGRAM == 1)

/*********************************************************************************************************/

/* The Statement Widget */

/*
  A small part of the code for the statement widget was copied from
  http://qt-project.org/doc/qt-4.8/widgets-codeeditor-codeeditor-h.html
  so the original copyright notice and BSD-license provisions are reproduced
  at the start of ocelotgui.cpp, applicable solely to what was copied.
*/

/* CodeEditor is actually used for both the statement widget and the debug widgets. */
/* The constructor is in codeeditor.h. */

#ifndef CODEEDITOR_H
#define CODEEDITOR_H

class QPaintEvent;
class QResizeEvent;
class QSize;
class QWidget;

class prompt_class;

class CodeEditor : public QPlainTextEdit
{
  Q_OBJECT

public:
  CodeEditor(MainWindow *parent= 0);

  void prompt_widget_paintevent(QPaintEvent *event);
  int prompt_width_calculate();
  QString prompt_translate(int line_number);
  int prompt_translate_k(QString s, int i);
  unsigned int statement_count;                                            /* used if "prompt \c ..." */
#if (OCELOT_MYSQL_DEBUGGER == 1)
  unsigned int block_number;                                               /* current line number, base 0 */
  bool is_debug_widget;
#endif
  QString dbms_version; /* Set to "" at start, select version() at connect, maybe display in prompt. */
  QString dbms_database;/* Set to "" at start, select database() at connect, maybe display in prompt. */
  QString dbms_port;/* Set to "" at start, select @@port at connect, maybe display in prompt. */
  QString dbms_current_user;/* Set to "" at start, select current_user() at connect, maybe display in prompt. */
  QString dbms_current_user_without_host;/* Set to "" at start, select current_user() at connect, maybe display in prompt. */
  QString dbms_host; /* Set to "" at start, mysql_get_host_info() at connect, maybe display in prompt. */
  int dbms_connection_id; /* Set to connection_id() at connect */
  QString delimiter; /* Set to ";" at start, can be changed with "delimiter //" etc. */
  QString result; /* What gets appended to history after statement executeion, e.g. error message */
  qint64 start_time; /* when statement started, in milliseconds since the epoch */

  /*
    The prompt is a read-only widget that
    appears on the left margin of statement_edit_widget.
    Mostly it's controlled by the "PROMPT" command.
    Font is same as main font for statement_edit_widget.
    It looks better if the font is fixed width.
    There is an assumption that prompts are latin1.
    PROMPT client statement decides whether there are line numbers.
  */

  QColor statement_edit_widget_left_bgcolor;                    /* suggestion = Qt::lightGray. */
  QColor statement_edit_widget_left_treatment1_textcolor;       /* suggestion = Qt::black */
  QString statement_edit_widget_left_treatment1_prompt_text;    /* suggestions = "     >" or "" */

  QString prompt_default;                     /* = "mysql>" -- or is it "\N [\d]>"? */
  QString prompt_as_input_by_user;            /* = What the user input with latest PROMPT statement, or prompt_default */
  /* QString prompt_translated;     */             /* = prompt_as_input_by_user, but with some \s converted for ease of parse */
  QString prompt_current;                     /* = latest result of prompt_reform() */
  MainWindow *main_window;

public slots:
  void update_prompt_width(int newBlockCount);
  void highlightCurrentLine();

protected:
  void resizeEvent(QResizeEvent *event);

private slots:
  void update_prompt(const QRect &, int);

private:
  QWidget *prompt_widget;
  void mousePressEvent(QMouseEvent *event);
  void mouseMoveEvent(QMouseEvent *event);
};

class prompt_class : public QWidget
{
public:
  explicit prompt_class(CodeEditor *editor);
  QSize sizeHint() const;
protected:
  void paintEvent(QPaintEvent *event);
private:
  CodeEditor *codeEditor;
};

#endif // CODEEDITOR_H

/*********************************************************************************************************/
/* THE QSCROLLAREAWITHSIZE WIDGET */

/*
  It's really really really hard to make a dialog box have a good size
  if it might scroll. With this subclass I can give a size hint when creating.
  Alas the Height hint tends to be ignored. (Todo: find out why.)
  It also tends to be ignored if I try sizeHint() for the Settings dialog box.
  The workaround is to check main_window_maximum_width later.
*/

#ifndef QSCROLLAREAWITHSIZE_H
#define QSCROLLAREAWITHSIZE_H
class QScrollAreaWithSize : public QScrollArea
{
public:
  int settings_width, settings_height;
  QScrollAreaWithSize(int width, int height);
  virtual QSize sizeHint() const;
};
#endif // QSCROLLAREAWITHSIZE_H

/*********************************************************************************************************/
/* THE QCOMBOBOXINSETTINGS WIDGET */
/* QComboBox::hidePopup() needs to be overridden in Settings calls so we can reset example. */
#ifndef QCOMBOBOXINSETTINGS_H
#define QCOMBOBOXINSETTINGS_H
class QComboBoxInSettings : public QComboBox
{
public:
  void hidePopup() override;
};
#endif // QCOMBOBOXINSETTINGS_H

/*********************************************************************************************************/
/* THE SETTINGS WIDGET */

/*
  Font Comments (all observations about how-to-do-font-settings should go here)
  Re weights:
    QFontDatabase and QFontDialog() sometimes disagree.
    We stopped using QFontDialog() in ocelotgui 1.5.
    In Qt version 6.x the QFont enums change: https://doc.qt.io/qt-6/gui-changes-qt6.html#qfont
    Our fontweightsvalues list has common names, alternate names, qt numbers, css numbers.
    Common names might not be the same as names that QFontDatabase returns in styles().
    Sometimes family contains weight (erroneously?) e.g. "Ubuntu Light", they probably mean "Ubuntu Condensed".
    Our style is always [nothing] | italic | oblique, derived from QFontDatabase.styles()
    Our weight is always fontweightsvalues that is closest to QFontDatabase::weights().
    (We also allow users to enter css numbers via SET.)
    Therefore what we show in the combo box often differs from what QFontDatabase or QFontDialog() show.
    But they are more consistent with each other and with css.
    See also the comments for canonical_font_family()
    Warning: "normal" can refer to QFont::StyleNormal (style) or to QFont::Normal (weight)
    Example: if QFontDatabase says family = "x", style = "light Italic" we show "x - light italic"
    Todo: we're using setFont and setItemData. Since elsewhere we use style sheets this is inconsistent.
    Todo: To make the initial display quicker, populate at first with only one item.
          Then, if mousePressEvent or something equivalent happens, populate fully.
    Todo: Get size of current font (i.e. "this"?) for the Settings dialog box
          For QFont(const QString &family, int pointSize = -1, int weight = -1, bool italic = false)
          We want pointSize of the dialog box font, weight + italic of the actual font.
    Todo: indicate if fixed pitch font
    Todo: SET statements match Settings
  Re sizes:
    In our experience QFontDatabase returns the same list regardless of family or style, around 18 options.
    So we make the list once for all suggested sizes. If somehow (e.g. via SET) an unsuggested size comes up,
    we pick the nearest.

  Re desired behaviour:
    * There is an label with an example of text in current basic colors and fonts.
      If user navigates and changes highlighting, change the example. But revert to currentIndex() setting
      if user closes the QComboBox (that's why we had to subclass the name and size comboboxes)
    * Weight can be either a name or a qt number or a css number. We might try to distinguish qt number
      from css number by value, which means we won't recognize qt number = 100, we think that's css.
      If there's somehow a change to an unknown weight value, consider it "normal"
      Re Qt Version 5.6+ https://doc.qt.io/qt-5/qfont.html#Weight-enum:
      We want to compile on earlier versions so we don't use the enums but we use the values.
*/

#ifndef SETTINGS_H
#define SETTINGS_H
class Settings: public QDialog
{
  Q_OBJECT
public:
  QDialog *settings;

private:
  QString actual_font_family;
  QString actual_font_size;
  QString actual_font_style;
  QString actual_font_weight;

  QVBoxLayout *main_layout;
  QWidget *widget_3, *widget_for_font_dialog;
  QHBoxLayout *hbox_layout_3, *hbox_layout_for_font_dialog;
  QPushButton *button_for_cancel, *button_for_ok;
  QLabel *widget_font_label;
  /* New Font Dialog */
  QComboBoxInSettings *combo_box_for_font_name;
  QComboBoxInSettings *combo_box_for_font_size;
  QLabel *text_for_font_example;
  /* New Font Dialog end */
  QWidget *widget_for_color[11];
  QHBoxLayout *hbox_layout_for_color[11];
  QLabel *label_for_color[11];
  QLabel *label_for_color_rgb[11];
  QLabel *label_for_font_dialog;

  QWidget *widget_for_syntax_checker;
  QLabel *label_for_syntax_checker;
  QComboBox *combo_box_for_syntax_checker;
  QHBoxLayout *hbox_layout_for_syntax_checker;

  QWidget *widget_for_max_row_count;
  QLabel *label_for_max_row_count;
  QSpinBox *spin_box_for_max_row_count;
  QHBoxLayout *hbox_layout_for_max_row_count;

  QWidget *widget_for_size[3];
  QHBoxLayout *hbox_layout_for_size[3];
  QLabel *label_for_size[3];
  QComboBox *combo_box_for_size[3];

  QWidget *widget_for_detached;
  QLabel *label_for_detached;
  QComboBox *combo_box_for_detached;
  QHBoxLayout *hbox_layout_for_detached;

  QWidget *widget_for_html_effects;
  QLabel *label_for_html_effects;
  QComboBox *combo_box_for_html_effects;
  QHBoxLayout *hbox_layout_for_html_effects;

  QWidget *widget_for_top, *widget_for_left, *widget_for_width, *widget_for_height;
  QLabel *label_for_top, *label_for_left, *label_for_width, *label_for_height;
  QComboBox *combo_box_for_top, *combo_box_for_left, *combo_box_for_width, *combo_box_for_height;

  QComboBox *combo_box_for_color_pick[11];
  QLabel *label_for_color_show[11];
  MainWindow *copy_of_parent;

#if (OCELOT_EXPLORER == 1)
  QTextEdit *text_for_query;
#endif

  /* current_widget = MAIN_WIDGET | HISTORY_WIDGET | GRID_WIDGET | STATEMENT_WIDGET | etc. */
  int current_widget;

  QString menu_strings_menu_font_copy; /* Kludge, see Settings() comment */

/* Following might be too short for some new language in ostrings.h */
#define MAX_COLOR_NAME_WIDTH 24

#define FONT_SIZE_MAX 72
#define FONT_SIZE_MIN 6
#define FONT_SIZE_ZOOM_INCREMENT 1

  void combo_box_filler(QComboBox **addr_of_combo_box, QString current_value, bool is_for_default);
  void combo_box_for_font_name_parse(QString name, QString *family, QString *weight, QString *style);
  int qt_style_to_our_style(QString qt_family, QString qt_style, QString *our_weight, QString *our_style);
  int combo_box_for_font_name_filler(QString actual_font_family, QString actual_font_style, QString actual_font_weight);
  void text_for_font_example_filler(QString text_color, QString background_color, QString font_family, QString font_style, QString font_weight, QString font_size);
  void combo_box_for_font_size_filler(QString actual_font_size);
public:
  Settings(int passed_widget_number, MainWindow *parent);
  private:
  void set_widget_values(int ci);
  private:
  void handle_combo_box_1(int i);
  void label_for_font_dialog_set_text();
  private slots:
  void handle_button_for_ok();
  void handle_button_for_cancel();
  void handle_combo_box_for_color_pick_0(int item_number);
  void handle_combo_box_for_color_pick_1(int item_number);
  void handle_combo_box_for_color_pick_2(int item_number);
  void handle_combo_box_for_color_pick_3(int item_number);
  void handle_combo_box_for_color_pick_4(int item_number);
  void handle_combo_box_for_color_pick_5(int item_number);
  void handle_combo_box_for_color_pick_6(int item_number);
  void handle_combo_box_for_color_pick_7(int item_number);
  void handle_combo_box_for_color_pick_8(int item_number);
  void handle_combo_box_for_color_pick_9(int item_number);
  void handle_combo_box_for_color_pick_10(int item_number);
  void handle_combo_box_for_font_any_change();
  void handle_combo_box_for_font_name_change(int i);
  void font_size_index_set(int actual_font_size_as_int);
  void handle_combo_box_for_font_size_change(int i);
  void handle_combo_box_for_any_highlighted(int i_of_font_name, int i_of_font_size);
  void handle_combo_box_for_font_name_highlighted(int i);
  void handle_combo_box_for_font_size_highlighted(int i);
  void handle_combo_box_for_syntax_check(int i);
  void handle_spin_box_for_max_row_count(int i);
  void handle_combo_box_for_detached(int item_number);
  void handle_combo_box_for_html_effects(int item_number);
  void handle_combo_box_for_top(int item_number);
  void handle_combo_box_for_left(int item_number);
  void handle_combo_box_for_width(int item_number);
  void handle_combo_box_for_height(int item_number);
  void handle_combo_box_for_size_0(int i);
  void handle_combo_box_for_size_1(int i);
  void handle_combo_box_for_size_2(int item_number);
  int get_font_weight_as_qfont_weight(QString font_weight_string);
  QFont::Style get_font_style_as_qfont_style(QString font_style_string);
  int q_color_list_index(QString color_name_string);
};
#endif // SETTINGS_H

/* QThread::msleep is protected in qt 4.8. so you have to say QThread48::msleep */
#ifndef QTHREAD48_H
#define QTHREAD48_H
class QThread48 : public QThread
{
public:
  static void msleep(int ms)
  {
    QThread::msleep(ms);
  }
};
#endif // QTHREAD48_H

/* QTabWidget:tabBar is protected in qt 4.8. so you have to say QTabWidget48::tabBar */

#ifndef QTABWIDGET48_H
#define QTABWIDGET48_H

class QTabWidget48 : public QTabWidget
{
  Q_OBJECT
public:
  explicit QTabWidget48(QWidget *parent);
  QTabBar *tabBar() const;
};

#endif // QTABWIDGET48_H

/* THE PARSEPOP WIDGET */

//#ifndef QPARSEPOP_H
//#define QPARSEPOP_H
//class QPopper : public QTextEdit
//{
//
//public:
//  int settings_width, settings_height;
//
//QParsePop(int width, int height)
//{
//  settings_width= width;
//  settings_height= height;
//}
//
//virtual QSize sizeHint() const
//{
//  return QSize(settings_width, settings_height);
//}
//
//};
//#endif // QPARSEPOP_H

/*****************************************************************************************************************************/
/* THE TEXTEDITHISTORY WIDGET */

/* Subclass of QTextEditWidget used for history_edit_widget */

/*
   Events That Go To Detached Windows
   When we detach a widget by calling setWindowFlags(Qt::Window),
   it becomes independent so relevant events no longer go through
   MainWindow::eventFilter. Therefore each should have its own event filter,
   to redirect events to MainWindow::eventFilter.
*/

/* Todo:
   It's unfortunate that a click on the main menu changes the focus.
   Several attempts have been made to fix this, e.g.
   the detached widget gets its own copy of the menu,
   focus-change events are intercepted and ignored.
   But nothing went well.
*/

#ifndef TEXTEDITHISTORY_H
#define TEXTEDITHISTORY_H

class TextEditHistory : public QTextEdit
{
  Q_OBJECT

public:

  MainWindow *main_window;
  explicit  TextEditHistory(MainWindow *parent);

  /* TODO: Following line caused an incomprehensible error. Removed temporarily. */
  /* Hmm. Maybe because we can call it for widgets that aren't subclasses of QTextEdit? */
  /* Notice there are other classes in this file where we use ~ without problem. */
  /* Watch for other classes where we fail to specify a destructor. */
  ~TextEditHistory();

public:
  void detach_start();
  void detach_stop();
  bool eventFilter(QObject *obj, QEvent *event);

};
#endif // TEXTEDITHISTORY_H

#ifndef XSETTINGS_H
#define XSETTINGS_H
class XSettings : public QWidget
{
  Q_OBJECT

/*
 This could be a separate .h file.
 For variables whose names begin with "ocelot_".
*/

/*
  For e.g. SET ocelot_statement_text_color='red'; or ocelotgui --statement_text_color='red'
  Call with e.g. ocelot_variable_set(TOKEN_KEYWORD_STATEMENT_TEXT_COLOR, text.mid(sub_token_offsets[3], sub_token_lengths[3])
  We used to have a lot of repetitive code here, now it's reduced.
  Todo: if debug compile, check that nobody changed keywords -- just put something in a comment?
  Todo: __attribute__((packed)) if gcc, but maybe it's enough to put char stuff at the end
  Todo: if compiled with debug, we need asserts at start to check that qstring_target addresses match token strings.
  Todo: in the original, we were doing nothing with ocelot_vertical, so it needs an extra look.
  Todo: Make sure ocelot_horizontal and ocelot_htmlraw, which have no variables, actually cause the changes.
  Todo: Check whether there has actually been a style change.
  Todo: For grid's set_all_style_sheets, we only redo existing display if there has been a font change.
  Todo: merge with Settings class?
*/

private:
#define OCELOT_VARIABLE_FLAG_SET_COLOR          0x01
#define OCELOT_VARIABLE_FLAG_SET_FONT           0x02
#define OCELOT_VARIABLE_FLAG_SET_FONT_FAMILY    0x12
#define OCELOT_VARIABLE_FLAG_SET_FONT_STYLE     0x22
#define OCELOT_VARIABLE_FLAG_SET_FONT_SIZE      0x42
#define OCELOT_VARIABLE_FLAG_SET_FONT_WEIGHT    0x82
#define OCELOT_VARIABLE_FLAG_SET_DEFAULTABLE    0x04
#define OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT    1
#define OCELOT_VARIABLE_ENUM_SET_FOR_GRID         2
#define OCELOT_VARIABLE_ENUM_SET_FOR_HISTORY      3
#define OCELOT_VARIABLE_ENUM_SET_FOR_MENU         4
#define OCELOT_VARIABLE_ENUM_SET_FOR_EXTRA_RULE_1 5
#define OCELOT_VARIABLE_ENUM_SET_FOR_SHORTCUT     6
#define OCELOT_VARIABLE_ENUM_SET_FOR_EXPLORER     7
#define OCELOT_VARIABLES_SIZE 145

struct ocelot_variable_keywords {
  QString *qstring_target;                /* e.g. &ocelot_statement_text_color */
  void *int_target; /* short unsigned int *int_target; */         /* e.g. NULL */
  int maximum;                            /* e.g. -1 because it's not an int target */
  unsigned char flags_style;              /* e.g. OCELOT_VARIABLE_FLAG_SET_COLOR */
  unsigned char enums_for;                /* e.g. OCELOT_VARIABLE_ENUM_SET_FOR_STATEMENT */
  unsigned short int k_i;                 /* keyword_index */
};

MainWindow *main_window;
int ocelot_variables_create();


public:
explicit XSettings(MainWindow *parent);
int ocelot_variable_offset(int keyword_index);
ocelot_variable_keywords *ocelot_variables;
int ocelot_variable_set(int keyword_index, QString new_value);
bool ocelot_variable_is_color(int keyword);
bool ocelot_variable_is_font_weight(int keyword);
bool ocelot_variable_is_font_style(int keyword);
bool ocelot_variable_is_font_family(int keyword);
int ocelot_variables_size();
~XSettings();

};
#endif //#ifndef XSETTINGS_H

#if (OCELOT_EXPLORER == 1)
#ifndef SMALL_DIALOG_H
#define SMALL_DIALOG_H
class Small_dialog: public QDialog
{
  Q_OBJECT

public:
QLineEdit line_edit;
Small_dialog(QString passed_title, QString passed_label, QString passed_value);
bool eventFilter(QObject *obj, QEvent *event);
~Small_dialog();

};
#endif // #ifndef SMALL_DIALOG_H
#endif // #if (OCELOT_EXPLORER == 1)

#if (OCELOT_EXPLORER == 1)

/***********************************************************/
/* THE EXPLORER WIDGET */
/***********************************************************/

/*
  Class explorer_widget does not exist at this time.
  For comments about it, see comments before MainWindow::initialize_widget_explorer().
*/

#ifndef CONTEXT_MENU_H
#define CONTEXT_MENU_H

/*
  User has asked for explorer context menu, presumably by right-clicking on explorer_widget.
  From oei[qtextedit_result_row_number] I can get object_type, object_name, column_name.
  User can press Esc, or click outside the choices, to select nothing.
  Put up a "menu" (well, it looks like one but it's not actually QMenu it's Completer_widget).
  Each menu item has a text (which should be ostrings.h?), and maybe an SQL statement.
  Todo: Make it start & pos!
  Action  Text What to do if clicked
  ----    ---- ---------------------
  Select Rows                       done, we say SELECT * FROM table-name LIMIT 1000;
  Table Inspector                         apparently this just allows analyze etc.
  Copy name to Clipboard -->        done, for one cell
  Foreign Keys                      done, we execute set ocelot_query = show foreign keys
  Table Data Export Wizard          done
  Table Data Import Wizard
  Send to SQL Editor                done, as send to statement edit widget. same as mousedoubleclickevent
  Create Table ...                  done, as show create table
  Create Table Like ...             done, with dialog box to give new table name
  Alter Table...                          close? we have drop column
  Table Maintenance...
  Drop Table...                     done (also Drop procedure)
  Truncate Table...                 done
  Search Table Data...                    meaning select from all tables, all text columns, returning counts
  Refresh All                       done, as refresh
  Todo: I could be specific, e.g. instead of "Copy to clipboard" say "Copy TABLE_X to clipboard"
  Todo: Put all the actions in a table: what-to-put-in-text, when-visible, what-to-do-if-clicked. E.g.:
        Text            Action                       Shortcut    Applicable Types
        ----            -------------                --------    ----------------
        "select rows"   "SELECT * FROM ${part_name};             T, V
                                             ?? or Lua? Or Read file? Or C program?
        This can be done with a SET statement:
          SET ocelot_explorer_text='SELECT ROWS',
              ocelot_explorer_statement=statement='SELECT * FROM ${object_name} LIMIT 1;',
              ocelot_explorer_shortcut='Ctrl+F'
          WHERE ocelot_explorer_text='select_rows';
        Or a dialog box: containing all:
          Fixed Statement Name | Text ___| SQL Statement ____ | Shortcut ___
        If we did it, users would have to be able to specify parameters e.g.:
          ${schema_name} ${object_name} ${part_name} ${clipboard} ${focus_cell} + whatever you used for PROMPT
        Some actions are not SQL statements e.g.:
          [Reset] [Copy ${cell} to clipboard] [Copy ${cell} to statement widget] [Text Export Dialog Box]
        Actions can be client statements.
        Actions can be multiple statements, but we might need a length limit, but you could call a procedure.
        The default should be in ostrings.h for the sake of the French translation.
        But "load" an instruction can be a general idea, not necessarily associated with explorer.
        But you'll need to add more, and you can't add an indefinite number of actions with what you have now.
        But if you allow add, you'll have to allow subtract too. And items need names. And will Reset wipe adds?
        So have a look at fill_menu(), and particularly things like TOKEN_KEYWORD_OCELOT_SHORTCUT_EXIT.
        Because this trick is applicable to all menus, except that I don't want to make many changes at once.
        Hmm, how could I handle submenus?
          Maybe as part of text e.g. "Dialog ... Text", "Dialog ... Html", etc.
          Alas, that would restrict you to only one submenu.
        Hmm, maybe there's only one "Applicable Type", so you'd act separately for 'T' and 'V'.
  Todo: Add "Hide"?
  Todo: Maybe I can import too, by calling LOAD DATA.
  Todo: There's been a non-repeatable crash. Maybe use "new" and "delete" for all objects?
        Maybe don't make submenus? Maybe it's fixed?
        Due to occasional mysterious crashes when we had a context menu created and destroyed within
        one function, we switched to having a context menu that is always existent. But perhaps we should
        change that to "as long as explorer widget is visible", i.e. delete if hide().
  Todo: for CREATE TABLE LIKE: see whether the widget you use for ^F Find might have been useful
  Todo: Bug: If we move the cursor while the menu is up, mousemoveevent won't happen, so row number is wrong.
        (I think this is fixed.)
  Todo: Format the SQL statements according to whatever happened with a format statement earlier.
  Todo: At one point we're using q->unstripper(), for data type, because the enum data type might contain ''s.
        Fine, but what about names that contain "s or `s?
        Anyway q->unstripper() looks a bit silly, why don't we use QString replace() as we seem to do elsewhere?
  Todo: Maybe the text|table|html decision could be done with a ${dialog}
  Todo: In cmi the action could be multiple statements including server SQL, client statement, RESET; etc.
        and maybe something more e.g. Lua statements, program execute
  Todo: Our SET ocelot_explorer_shortcut="...' confuses because we have SET OCELOT_SHORTCUT_... too.
  Todo: "Cut" could remove a line until the next reset.
  todo: something for menu->addSeparator()
  todo: validity check, although for default that isn't needed
  Todo: Syntax so far = SET ocelot_explorer_action='...' WHERE ocelot_explorer_text='[cmi.text choices]';
        This some things to be updated immediately, others affected during display. So actions are "scriptable".
        Todo: extend thus:
          Allow NEW and all components (text, statement, etc.) to be added|changed.
          Allow effect on main menu too.
          Allow new thing = "Enabled".
  Note: SET ocelot_menu_background_color etc. will affect context menu too.
        Todo: consider: base on statement widget instead, or make menu fixed font
  Note: For show create view we don't have a Tarantool statement but we stored it in part.
  Note: CREATE TABLE ... is depending on default schema so if you haven't said USE it will cause an error.
  Re macros: text and statement can have them. See the Wikipedia article "String interpolation".
    Some possibilities were: %xxx or $xxx or {xxx} or ${xxx} or {d ...}. Choice was ${xxx}, no beautiful reason.
    Currently Context_menu::replacer() substitutes ${cell} ${clipboard} ${dialog} ${object_name} ${occurs_text}
    ${part_name} ${part_type} ${schema_name} ${statement}. It also looks for special instructions e.g. CLIPBOARD=.
    NB: ${cell} copies the cell at QCursor::pos(), which might not be the cell that was clicked earlier.
    Replace '${macro_name}' with 'not-delimited-macro-name' then replace ${macro_name} with delimited-macro-name.
  TODO: BUG: For 'C' for Send to SQL editor, we copy the name not the qualified name.
  TODO: BUG: At one point we failed to show a table. It's okay now but watch for it happening again.
  TODO: BUG: occasional crash, again. I'm seeing whether it helps if I avoid "new".
  Todo: I dunno about 'M' and 'T' and '*'. Perhaps 'M%' | 'MariaDB' etc. and '%' would be clearer.
  Todo: During SET ocelot_explorer_... propose a text for the sake of ER_OK_PLUS e.g. warning what's not done.
  Todo: line_colors() looks like a good spot for marking something as disabled -- nearly done.
  Todo: in set_current_row give a specific tooltip, e.g. text of action
  Todo: re shortcutter(): Check if visible? Check if explorer is visible? return something if match and action?
  Todo: how to see what the current values are? At least make a separate .h file?
  Todo: example.cnf changes
  Todo: some things should be disabled for privilege reasons e.g. drop information_schema
        (mark disabled by setting to gray, or reducing brightness in line_color() function)
  Todo: re Completer_widget::shortcut_override(): we use this to override Tab if it's a main-menu shortcut,
        which is default. But we should override other main-menu shortcuts if there's a context-menu item
        for the same key sequence, which we can probably do with Context_menu::shortcutter().
        A complication: if it's disabled on the main menu, the action won't happen.
        A complication: actually I rather like the idea of e.g. Edit|Copy to copy what's in the menu.
  Todo: better import. Currently we only allow: no dialog box, UTF8, columns terminated by comma,
        lines terminated by line break e.g. lf, char|varchar must have ''s, no line break inside a column.
        Given that we can get data type from oei[n].part_type when oei[n].object_type='C', this is poor.
  Todo: Since we might someday do import|export with data types + column names, the alphabetical order choice
        for explorer_widget is bad. We should keep column numbers, or we should not sort by column names.
  Todo: For "I" we now have extra_type = index column name, we use it for erdiagram but not for explorer.
*/
class Context_menu: public QWidget
{
  Q_OBJECT

private:
  ResultGrid *result_grid;
  Result_qtextedit *q;
  void construct();

struct context_menu_items {
    QString action;           /* e.g. "Select * FROM ${object_name} limit 1000;" */
    QString applicable_dbmss; /* e.g. "M" or "T" */
    QString applicable_types; /* e.g. "T,V" */
    QString enabled;          /* e.g. "" (not used yet) */
    QString shortcut;         /* e.g. "" (not used yet) (key sequence) */
    QString text;             /* e.g. "select rows" */
    bool is_visible;
};
/* There are only about 35 default context menu items but allow for users making more. */
#define MAX_CMI_COUNT 40
//  QString strip_crlf(QByteArray result_row_value);
  QString replacer(QString);
  int add_action(QString action, QString applicable_dbmss, QString applicable_types,
                  QString enabled, QString shortcut, QString text);
  QString cm_delimited_object_name; /* variables beginning with cm_ are for use in macro replacement */
  QString cm_object_type;
  QString cm_cell;

protected:
  void keyPressEvent(QKeyEvent *event);

public:
  Context_menu(ResultGrid *m, Result_qtextedit *passed_q);
  void menu_context_t_2_explorer(const QPoint & pos);
  context_menu_items cmi[MAX_CMI_COUNT];
  int cmi_count;
  void action(int current_row, int i_of_cmi);
  bool shortcutter(QKeySequence qk);
  ~Context_menu();
};
#endif // #ifndef CONTEXT_MENU_H
#endif // #if (OCELOT_EXPLORER == 1)

#if (OCELOT_PLUGIN == 1)
/*
  Plugins
  This class is not complete and the only documentation is this comment and the comments in plugin.c.
  A plugin is a library with programs that can understand what ocelotgui passes,
  It can do anything at all (including in some cases replacing what ocelotgui passes), displaying).
  Writing the plugin
    C or C++ (ocelotgui itself is built with gnu tools).
    Any other language that can understand C/C++ structures would work but would be more trouble.
    Must start with #include "ocelotgui.h" which happens to be this file.
    Function names can be any of the names listed in static const struct plugin_keywords plugin_strvalues[]=, above.
    (We use dlsym() to find function names.) (Or, on Windows, a plugin_library function.)
    The ocelotgui.h header file has definitions that can be seen by C and more definitions that can be seen by C++.
    So the front of ocelotgui.h works for either C or C++, and the back (after "#ifdef __cplusplus") works only for C++.
    C definitions include some #define and struct items,
    C++ definitions include class descriptions.
  The plugin should be made into a library
    Currently Plugin::plugin() uses dlopen() to look for a Linux .so file
    The Windows equivalent is with Qt's QLibrary functions, there's poorly tested code for it enclosed by #ifdef _WIN32.
    So the plugin should be compiled and turned into a library with (substitute your name preferences here):
    (Linux) gcc -shared -o libplugin.so -fPIC plugin.c, or Windows equivalent mentioned in plugin.c
    Currently if ocelotgui doesn't find the plugin it does nothing, there is a printf but no error return.
    For security it is a good idea to protect the .so file from change, for example on Linux with chown and/or chmod.
    LD_LIBRARY_PATH or --rpath or --plugin_dir do not affect where ocelotgui looks for the Ocelot plugin library.
  The example file is plugin.c
    See plugin.c, it is included with the ocelotgui distribution.
    Notice it has a copyright message and is GPLv2. GPLv2 plugins are compatible with ocelotgui.
  Installing the plugin
    SET ocelot_query = INSERT INTO plugins VALUES ('library literal', 'action');
    where library literal has the full path of the library e.g.
    set ocelot_query = insert into plugins values ('/home/pgulutzan/ocelotgui/libplugin.so', 'real_query');
    If the plugin has already been installed, there is no error message, the plugin is called twice.
    It is legal to start ocelotgui --ocelot_query=insert... or put ocelot_query=insert... in a .cnf file.
    The "set ocelot_query = insert ..." statement is legal even if there is no connection to the server.
* Triggers i.e. places where ocelotgui can call the plugin:
  See "#define PLUGIN_..." declarations above.
  If the call point is for when the user clicks a menu item, INSERT INTO menus is responsible for connecting.

* Plugin action: execute server statement
  This is only legal when ocelotgui is about to execute a statement ... hmm, the plugin can't execute it, it can only tell the server to execute it
* Plugin calls (if activated)
    At start / end of certain functions, in the same places where we
    At start / end of statement execution -- notice that plugin can replace the statement text at start
    When we acquire or remove a result set -- we pass the result set address, the plugin can replace it, but remember to free when the result set is obsolete
    When we change any of the values mentioned in Connection Dialog Bo
    When returning "OK" or returning an error -- again, the plugin can change the text or change the error number, or log it, or whatever (the user sees what the plugin returns)
    Mouse click or other user action, including menu click but also statement-widget edit
    Before / after -display of the result grid or any widget -- we'll pass the co-ordinates, the plugin can use the area for whatever it wants,
    Program start / end
    Change in something that a structure points to
    Menu click -- either on the plugin menu or anywhere else -- maybe a shortcut
    Statement execution start / end
* Available structures
  Anything visible in Connection Dialog Box (so this would include any --options on the command line)
  Any OCELOT_* variable
  Whatever you see in Help (notice that this includes server-DBMS version and Qt version) (changing the text can result will result in change in what Help sees)
  Text of all menus (not just top menu, explorer menu too)
  Error numbers and messages (in English or French) (go ahead and point to your own) (or, French can replace English when it's time to display the message)
  Anything else in ostrings.h
  Latest result of rehash
  Latest result grid, usually as html -- there might be multiple result grids same as what we have in export -- but in that case, why not just have an event for export?
  Latest result set
  Where are we, i.e. what caused the call
  Version
  (If call is from start of a function) the values of the function parameters
  List of call points (this would only be needed if we wanted to decide within ocelotgui whether to call) (it might be easier but less efficient to let the plugin decide to ignore)

* Menu (whatever you say here will go in the ocelotgui main menu)
* An equivalent to MySQL Workbench mforms: form, box, table, scrollview -- but do we actually need mforms if any idiot can call Qt?
  "replace sql editor contents"
  The called routine may: execute SQL (silently or showingly), replace widget contents,
  ... So this is a good way to repetitive or timed operations
  ... Dunno the difference between this and FILE statement
* Since you can intercept the statement execution you can invent your own commands, but hparse won't help you with them unless you provide a BNF
  (a BNF is easy if there's no branching) (or you can re-use hparse functions?)
  ... The only thing you can do with your own commands is pass them to the plugin, I guess.
* Todo: allow addding items to a plugin menu, with all the call points
  So there will be a heap of plugin menu items, and clicking any of them will execute the plugin
  But also you might have what's used for REHASH
  The C plugin may:
    Replace anything in the pointed-to stuff (permanently or until the value is going to be replaced)
    Cancel the operation because it handled it itself
    Add to the operation either before or after
    Cause an error, either basic or customized
  Todo: C++ plugin example plugin.cpp
    What good is a C++ plugin? ... I suppose I cannot share the classes ... but the C++ routine has an easier time calling Qt
    plugin.cpp, use gcc, the example can take advantage of the fact that Qt headers are already included, e.g. make messagebox
    There are some functions I'd like to call, but they're all inside classes which makes it harder
    Well, the function can call the plugin, and the plugin can replace the values (unless they're Qt?)
  SET ocelot_query = SELECT * FROM plugins; works now.
  Todo: Bring in ostrings.h, I at least need to know what ER_OK is
  Todo: make some names public and ocelotgui can decide whether to call them, rather than having switch in a main function.
        With Linux I could use dladdr.
  Todo: callbacks
  Todo: more functions, systematic names.
  Todo: Include version number. Announce that when there's a breaking change (as might happen often), there will be an
        explanation here.
*/
#ifndef PLUGIN_H
#define PLUGIN_H
class Plugin: public QWidget /* why? do we intend to inherit something from QWidget? */
{
public:
  Plugin(MainWindow *m);
  int init(QString plugin_library_soname, QString plugin_name, int call_type);
  ~Plugin();
  int caller(int, struct plugin_pass *plugin_pass);
  QString id; /* whatever was in plugin_id when we called plugin_init */
  QString soname; /* whatever was in plugin_soname when we called plugin_init */
  int plugin_type; /* One of the #define PLUGIN_... values */
private:
  MainWindow *plugin_main_window;
#ifdef _WIN32
  QLibrary plugin_library;
#else
  void *plugin_handle;
#endif

  int (*plugin_function_pointer)(struct plugin_pass *arg);
};
#endif // #ifndef PLUGIN_H
#endif // #if (OCELOT_PLUGIN == 1)

#endif //__cplusplus

#endif // OCELOTGUI_H
